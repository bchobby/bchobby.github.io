<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构与算法入门(follow 左神) - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构与算法入门(follow 左神)" />
<meta property="og:description" content="文章目录 一. 认识时间复杂度和简单排序算法1.以选择排序为例2.异或运算3.插入排序4.二分查找5.对数器 二. 认识O(NlogN)的排序1.递归==栈的后序遍历2.归并排序3.快速排序 三.详解桶排序以及排序内容大总结1.堆结构(优先级队列)2.比较器3.桶排序4.排序总结 四.链表1.哈希表和有序表2.链表 五.二叉树1.哈希表和有序表2.BFS宽度优先遍历(层次遍历)3.套路题（可树型DP） 六.图1.定义好通用的图所需结构2.BFS和DFS &#43; 拓扑排序3.kruskal算法（边）和Prim算法（点）【无向图】4.Dijkstra:单元最短路径 七.详解前缀树和贪心算法1.前缀树2.贪心算法3.字典序证明4.其他题目 八.暴力递归1.N皇后2.暴力递归冲冲冲 Ending 本文是跟着左程云老师在b站发布的视频教程所记录的算法入门笔记，左神算法班
总共分为八节，一些相关代码和重点思路分析 大多已在下文呈现
一. 认识时间复杂度和简单排序算法 1.以选择排序为例 第一遍的时候，查询了n次，比较了n次，交换了1次；第二遍，查询n-1次，比较了n-1次，交换1次；。。。所以时间复杂度是O(n) ^2
算法分析先看时间复杂度指标，再分析不同数据样本下的实际运行时间，也就是&#34;常数项时间&#34;
额外空间复杂度指的是除去存放必要数据外，所需的空间。
2.异或运算 不同为1，相同为0；同时可以理解成无进位相加
1）0^N=N; N^N=0
2）交换律：a^b = b^a;结合律 (a^b) ^c= a^(b ^c)
第一题：已知一个数组中，只有一种数出现了奇数次，其余都是出现偶数次，请问怎么找到这种数
第二题：如果两种数出现了奇数次呢，怎么找到？ 要求O(N)时间，O(1)空间。
第一题int eor=0和数组中全部异或得到的数就是结果，因为偶数次的结果都没了；相当于消消乐
第二题先按照第一题得到int eor=a^b; 由于a！=b,所以eor！=0
==&gt; eor在32位比特位中至少有1位是1，假设是第8位，那么a和b的第八位一定一个是1，一个是0，不然得不到1这个异或结果
==&gt; int eor2去异或数组中所有第8位不是1/不是0的数，最后结果一定是a or b；相当于将整个数组根据第8位是否是1分成两部分，这两部分分别包含a和b以及其他偶数次的数字
==&gt; 最后再将eor^eor2得到另一个数
int rightOne = eor &amp; (~eor &#43; 1); //提取最右侧的1 eor和eor的补码进行 同1得1，有0则0 的与运算 int onlyOne = 0; for (int cur : arr) { if ((cur &amp; rightOne) !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/c25acb7804adb711500a2234b9e55443/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-07T23:08:39+08:00" />
<meta property="article:modified_time" content="2023-04-07T23:08:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构与算法入门(follow 左神)</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#__5" rel="nofollow">一. 认识时间复杂度和简单排序算法</a></li><li><ul><li><ul><li><a href="#1_6" rel="nofollow">1.以选择排序为例</a></li><li><a href="#2_12" rel="nofollow">2.异或运算</a></li><li><a href="#3_36" rel="nofollow">3.插入排序</a></li><li><a href="#4_49" rel="nofollow">4.二分查找</a></li><li><a href="#5_62" rel="nofollow">5.对数器</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_ONlogN_66" rel="nofollow">二. 认识O(NlogN)的排序</a></li><li><ul><li><ul><li><a href="#1_67" rel="nofollow">1.递归==栈的后序遍历</a></li><li><a href="#2_72" rel="nofollow">2.归并排序</a></li><li><a href="#3_153" rel="nofollow">3.快速排序</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_200" rel="nofollow">三.详解桶排序以及排序内容大总结</a></li><li><ul><li><ul><li><a href="#1_201" rel="nofollow">1.堆结构(优先级队列)</a></li><li><a href="#2_264" rel="nofollow">2.比较器</a></li><li><a href="#3_312" rel="nofollow">3.桶排序</a></li><li><a href="#4_329" rel="nofollow">4.排序总结</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_346" rel="nofollow">四.链表</a></li><li><ul><li><ul><li><a href="#1_347" rel="nofollow">1.哈希表和有序表</a></li><li><a href="#2_391" rel="nofollow">2.链表</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_710" rel="nofollow">五.二叉树</a></li><li><ul><li><ul><li><a href="#1_711" rel="nofollow">1.哈希表和有序表</a></li><li><a href="#2BFS_766" rel="nofollow">2.BFS宽度优先遍历(层次遍历)</a></li><li><a href="#3DP_828" rel="nofollow">3.套路题（可树型DP）</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_1078" rel="nofollow">六.图</a></li><li><ul><li><ul><li><a href="#1_1079" rel="nofollow">1.定义好通用的图所需结构</a></li><li><a href="#2BFSDFS___1157" rel="nofollow">2.BFS和DFS + 拓扑排序</a></li><li><a href="#3kruskalPrim_1236" rel="nofollow">3.kruskal算法（边）和Prim算法（点）【无向图】</a></li><li><a href="#4Dijkstra_1323" rel="nofollow">4.Dijkstra:单元最短路径</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_1403" rel="nofollow">七.详解前缀树和贪心算法</a></li><li><ul><li><ul><li><a href="#1_1404" rel="nofollow">1.前缀树</a></li><li><a href="#2_1494" rel="nofollow">2.贪心算法</a></li><li><a href="#3_1516" rel="nofollow">3.字典序证明</a></li><li><a href="#4_1560" rel="nofollow">4.其他题目</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_1613" rel="nofollow">八.暴力递归</a></li><li><ul><li><ul><li><a href="#1N_1617" rel="nofollow">1.N皇后</a></li><li><a href="#2_1660" rel="nofollow">2.暴力递归冲冲冲</a></li></ul> 
   </li></ul> 
   </li><li><a href="#Ending_1844" rel="nofollow">Ending</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<blockquote> 
 <p>本文是跟着左程云老师在b站发布的视频教程所记录的算法入门笔记，<a href="https://www.bilibili.com/video/BV13g41157hK" rel="nofollow">左神算法班</a><br> 总共分为八节，一些相关代码和重点思路分析 大多已在下文呈现</p> 
</blockquote> 
<h3><a id="__5"></a>一. 认识时间复杂度和简单排序算法</h3> 
<h5><a id="1_6"></a>1.以选择排序为例</h5> 
<p>第一遍的时候，查询了n次，比较了n次，交换了1次；第二遍，查询n-1次，比较了n-1次，交换1次；。。。所以时间复杂度是O(n) ^2</p> 
<p><strong>算法分析先看时间复杂度指标，再分析不同数据样本下的实际运行时间，也就是"常数项时间"</strong><br> 额外空间复杂度指的是除去存放必要数据外，所需的空间。</p> 
<h5><a id="2_12"></a>2.异或运算</h5> 
<p>不同为1，相同为0；同时可以理解成<strong>无进位</strong>相加</p> 
<p> 1）0^N=N; N^N=0<br>  2）交换律：a^b = b^a;结合律 (a^b) ^c= a^(b ^c)<br> 第一题：已知一个数组中，只有一种数出现了奇数次，其余都是出现偶数次，请问怎么找到这种数<br> 第二题：如果两种数出现了奇数次呢，怎么找到？ 要求O(N)时间，O(1)空间。</p> 
<p>第一题int eor=0和数组中全部异或得到的数就是结果，因为偶数次的结果都没了；相当于消消乐<br> 第二题先按照第一题得到int eor=a^b; 由于a！=b,所以eor！=0<br> ==&gt; eor在32位比特位中至少有1位是1，假设是第8位，那么a和b的第八位一定一个是1，一个是0，不然得不到1这个异或结果<br> ==&gt; int eor2去异或数组中所有第8位不是1/不是0的数，最后结果一定是a or b；相当于将整个数组根据第8位是否是1分成两部分，这两部分分别包含a和b以及其他偶数次的数字<br> ==&gt; 最后再将eor^eor2得到另一个数<br> <img src="https://images2.imgbox.com/95/1c/l76ZhwMM_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token keyword">int</span> rightOne <span class="token operator">=</span> eor <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span>eor  <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//提取最右侧的1  eor和eor的补码进行 同1得1，有0则0 的与运算</span>
<span class="token keyword">int</span> onlyOne <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> cur <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cur <span class="token operator">&amp;</span> rightOne<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">//取出在最右侧1位置，数组中该位置也等于1的值做异或  /  ==0也行</span>
	onlyOne <span class="token operator">^=</span> cur<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>onlyOne <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>eor <span class="token operator">^</span> onlyOne <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="3_36"></a>3.插入排序</h5> 
<p>插入排序不是严格的O(N^2)：0-1有序=&gt;0-i有序,而冒泡和选择是。</p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token operator">=</span><span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&gt;=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&gt;</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token comment">//达成范围有序，往前看一旦碰上顺序 可跳下一循环</span>
                    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>j<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//相邻做交换</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h5><a id="4_49"></a>4.二分查找</h5> 
<p>1&gt;找一组有序数中≥某个数num的最小数(最左侧位置)<br> （1）判断mid是否≥num =&gt; 若≥num，标记t=mid，令end=mid-1找其左侧；<br> （2）左侧的mid若小于num，令start=mid+1，重新二分找；若此时mid&gt;=num，由于该arr[mid]肯定小于t，重新令t=mid<br> （3）以此类推继续二分，就比正常二分多一个<strong>t</strong>标记。</p> 
<p>2&gt;局部最小值：在arr中，数值<strong>无序</strong>排列且相邻数一定不相等。局部最小指的是[0,N-1]中，arr[0]&lt;arr[1]，arr[N-1]&lt;arr[N-2]，arr[i-1]&lt;arr[i]&lt;arr[i+1]，0&lt;i&lt;N-1，则这三个数局部最小。<strong>如果只求一个局部最小，请问时间复杂度能好于O(N)吗</strong><br> 可以，一开始比较start，end是否小于相邻数，<strong>都不行，此时这条函数曲线左边下降，右边也是下降；f(0)&gt;f(1)且f(n-1)&gt;f(n-2),中间必有转折点</strong><br> 则比较mid是否小于相邻数；如果此时不行，要么是f(m)&gt;f(m-1)或f(m)&gt;f(m+1)，那就把f(m)当成新的start或end；当然f(m)是极大值，那两边都可<br> <strong>优化流程两个方向一是数据状况特殊，二是问题特殊</strong><br> 本题两个都特殊，数据相邻不等，问题求解时左右两边必和问题有关且必能舍弃一边就能采用二分策略</p> 
<h5><a id="5_62"></a>5.对数器</h5> 
<p>用于代替OJ检测<br> <img src="https://images2.imgbox.com/a5/75/138vFPnt_o.png" alt="在这里插入图片描述"><br> 自己做的随机样本产生器产生的数据分别跑法a，法b，两相比较，若不一，二者至少有1出错</p> 
<h3><a id="_ONlogN_66"></a>二. 认识O(NlogN)的排序</h3> 
<h5><a id="1_67"></a>1.递归==栈的后序遍历</h5> 
<p><img src="https://images2.imgbox.com/82/3b/pn4z98E1_o.png" alt="在这里插入图片描述"><br> 递归如果符合Master公式[<em>算法导论主定理</em>]，可以直接用其计算时间复杂度<br> <img src="https://images2.imgbox.com/06/31/hO6UMmWP_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_72"></a>2.归并排序</h5> 
<p>准备一个辅助空间(空间复杂度O(N))，合并两个有序数组(各有一个min指针)，使合并数组也有序<br> <strong>前面的排序浪费了大量的比较信息，而归并排序将比较行为变成了整体有序的部分去跟下一个更大范围的部分merge</strong></p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">L</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">L</span><span class="token operator">==</span><span class="token class-name">R</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token class-name">L</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token operator">-</span><span class="token class-name">L</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//L+（R-L）/2,防止溢出</span>
        <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token class-name">L</span><span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//该递归时间复杂度按照Master公式，a=2,b=2,d=1;因此是O(NlogN)</span>
        <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token class-name">L</span><span class="token punctuation">,</span>mid<span class="token punctuation">,</span><span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">L</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">M</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> help <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">R</span><span class="token operator">-</span><span class="token class-name">L</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//辅助空间</span>
        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//用于辅助空间的移动下标</span>
        <span class="token keyword">int</span> p1<span class="token operator">=</span><span class="token class-name">L</span><span class="token punctuation">,</span> p2<span class="token operator">=</span><span class="token class-name">M</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p1<span class="token operator">&lt;=</span><span class="token class-name">M</span> <span class="token operator">&amp;&amp;</span> p2<span class="token operator">&lt;=</span><span class="token class-name">R</span><span class="token punctuation">)</span>
            help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">?</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p1<span class="token operator">&lt;=</span><span class="token class-name">M</span><span class="token punctuation">)</span>
            help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p2<span class="token operator">&lt;=</span><span class="token class-name">R</span><span class="token punctuation">)</span> <span class="token comment">//这两个while必执行一个</span>
            help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>help<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
            arr<span class="token punctuation">[</span><span class="token class-name">L</span><span class="token operator">+</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> help<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><strong>扩展：</strong></p> 
<p><img src="https://images2.imgbox.com/d2/21/ksf0WeJO_o.png" alt="在这里插入图片描述"><br> 小和问题：<br> <strong>逆向思维</strong>反过来，求<em>右边有几个数比它大(Merge)</em>，就产生几个这个数的小和。<br> 只有左侧小，才会产生小和(此时乘以右侧排好序的数组剩余长度=&gt;排序不能省略，通过排序知道右侧能产生几个小和)，右侧小不产生小和<br> 既不遗漏也不重算，因为merge过程中一定会把一个数扩到整体的，且变成merge变成整体后是不会在这个整体内部产生小和;<br> 也就是说只有在merge时会产生小和，变成有序部分不会产生小和</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">smallSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">)</span> 
				<span class="token operator">+</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span> 
				<span class="token operator">+</span> <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左侧小和+右侧小和+两组归并新产生的小和</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> help <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> p1 <span class="token operator">=</span> l<span class="token punctuation">;</span>
		<span class="token keyword">int</span> p2 <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> m <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			res <span class="token operator">+=</span> arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> p2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//O(1)的时间找到r-p2+1个右侧产生小和的数【下标计算找】</span>
			help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">?</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//这里有修改，优先拷贝右侧到help【因为先拷贝左边，不知道右边有几个比左侧该值大的数(下标计算看不出来)】</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>p2 <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> help<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			arr<span class="token punctuation">[</span>l <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> help<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> res<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>逆序对问题：和上面等效，只是左边比右边大而已。<s>【找右边比左边小的元素】</s></p> 
<pre><code class="prism language-java">res <span class="token operator">+=</span> arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token punctuation">(</span>m <span class="token operator">-</span> p1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//改这两句就可以</span>
help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">?</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//优先拷贝左侧【与上优先右侧同理】</span>
</code></pre> 
<h5><a id="3_153"></a>3.快速排序</h5> 
<p>O(N^2)=&gt;等差数列或者说partition一直离左侧或者右侧开头很近</p> 
<p><img src="https://images2.imgbox.com/2f/86/qegKP9eY_o.png" alt="在这里插入图片描述"><br> 第一题一次start和end的快排就解决<br> 或者一开始i=0，小于等于区=null；如果arr[i]≤num，arr[i]和<strong>小于等于区</strong>的<strong>下一个数</strong>交换，同时≤区右扩且i++<br> 否则不右扩，i++,直到arr[i]≤num {快慢指针}<br> 第二题则是两个区域，左边小于区域，右边大于区域<br> <img src="https://images2.imgbox.com/2c/f8/NwBKbjdk_o.png" alt="在这里插入图片描述"><br> 第三条情况i原地不动是因为，从右侧&gt;区前一个数交换过来的数还没看过，得再拿他过一下情况1，2，3<br> 当i == 大于区域时，停止<br> <strong>快排1.0 以最后一个数为num与大于5区域第一个数做交换，再在左右两侧继续之前行为</strong><br> <img src="https://images2.imgbox.com/19/1b/rtrkH8Qi_o.png" alt="在这里插入图片描述"><br>                <img src="https://images2.imgbox.com/c5/c5/IDIkxlIs_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/19/d3/oAJ5Vu0O_o.png" alt="在这里插入图片描述"><br>       <img src="https://images2.imgbox.com/0b/04/hadD9YsB_o.png" alt="在这里插入图片描述"><br> 以荷兰国旗为例，一次搞定一批==5的数，比1.0稍快一些。<br> <strong>3.0采用概率随机选择索引范围内一个数做划分，做长期期望后为O(NlogN)</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等概率随机选一个位置和最右位置交换</span>
			<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回数组长度为2=&gt;划分中间区域的左边界和右边界</span>
			<span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;区</span>
			<span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &gt;区</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 默认以arr[r]做划分 arr[r]-&gt;p  |  &lt;p    ==p     &gt;p三块区域</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> less <span class="token operator">=</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//&lt;区有边界</span>
		<span class="token keyword">int</span> more <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token comment">//&gt;区左边界</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> more<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">//l表示当前数位置 arr[r]为划分值</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">++</span>less<span class="token punctuation">,</span> l<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">--</span>more<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&gt;区左扩</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
				l<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//中间区域不管</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> more<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最后把划分值换过来，此时为中间位置最右边</span>
		<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span> less <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> more <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>快排的额外空间复杂度是O(logN)：差的情况下，每次划分都是拿start和end做划分，且在递归过程中一直保留不释放=-&gt;O(N)；好的情况是二叉树，排序一小部分，释放一部分=&gt;O(logN)<br> 即使是不用递归写，也要自行压栈，各种情况概率分布后会收敛到O(logN)</p> 
<h3><a id="_200"></a>三.详解桶排序以及排序内容大总结</h3> 
<h5><a id="1_201"></a>1.堆结构(优先级队列)</h5> 
<p>堆是完全二叉树，满足左右孩子分别是2i+1和2i+2，父节点是(i-1)/2<br> 完全二叉树高度是O(logN)，删掉最大值往下调整成堆也是O(logN)<br> 假如有序是自小到大，堆排序就是构建大根堆，把构建好的堆<strong>最后一个位置与堆顶</strong>做交换，然后heapsize–，此时最后一位是最大值，然后对交换后的结构调整成堆，然后继续上述操作 逐步把大根堆顶放置最后一个(类似冒泡，但每次比较的值少了，且不额外空间复杂度O(1))。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//O(N)</span>
			<span class="token function">heapInsert</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// O(logN)</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">int</span> size <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
		<span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">--</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最后一个数和堆顶做交换</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//周而复始 从最后一个排序到第一个 O(N)</span>
			<span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// O(logN)</span>
			<span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">--</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//O(1)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//每次插入往上比：上</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapInsert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//比父亲大,或当index=0时跳出    | (0 - 1) / 2 = 0, int自动抹去小数，-0.5=&gt;0</span>
			<span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			index <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span> <span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//任意位置往下堆化：下，例如删除堆顶后，将最后一个属放置在arr[0]时往下堆化</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//heapsize管着堆的大小</span>
		<span class="token keyword">int</span> left <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//下方还有(左)孩子</span>
			<span class="token keyword">int</span> largest <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> 
					<span class="token operator">?</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> left<span class="token punctuation">;</span> <span class="token comment">//必须时有右孩子，且右孩子的值大于左孩子的值，右孩子才胜出</span>
			largest <span class="token operator">=</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">?</span> largest <span class="token operator">:</span> index<span class="token punctuation">;</span> <span class="token comment">//父和较大孩子间，谁值大，把下标给largest</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">==</span> index<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
			index <span class="token operator">=</span> largest<span class="token punctuation">;</span>
			left <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>如果只是给你一些数，只需求构建大根堆，不需要按照一个个往里填充的方式，没必要从后面的叶子节点开始调整，因为他们没有孩子，不需要heapify;所以从<strong>倒数第二排最后一个父节点</strong>开始向上调整（这样每个父亲节点只需要往下看就行）</p> 
<pre><code class="prism language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span>i<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token function">heapInsert</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>扩展题<br> <img src="https://images2.imgbox.com/27/bc/OAulOl44_o.png" alt="在这里插入图片描述"><br> 假设k=6，准备一个小根堆，遍历数组将前7个值放进小根堆，然后将堆顶对应的数组元素弹出放在arr[0]处，再把arr[7]放入小根堆，再弹出堆顶到arr[1] （类似滑动窗口，用小根堆找出）</p> 
<pre><code class="prism language-java"><span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> heap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>优先级队列(小根堆)底层是数组，但它扩容是成倍扩充 拷贝旧数组到新数组：单次扩容的代价由拷贝决定：O(N); 扩容次数是O(logN); N次均摊下来时间复杂度：O(NlogN)/N =O(logN)<br> 系统提供代码是黑盒：只支持简单的add,poll，不支持自己随便修改堆中任意节点的值，不是做不了而是不够高效</p> 
<h5><a id="2_264"></a>2.比较器</h5> 
<p>c++：重载运算符<br> Java：比较两个函数/变量/属性/bean类等的大小:其实也是重载比较运算符</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
		<span class="token keyword">public</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>
		<span class="token keyword">public</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

		<span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IdAscendingComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Student</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//返回负数的时候，第一个参数排在前面 if(o1.id&lt;o2.id) return -1;</span>
		<span class="token comment">//返回正数的时候，第二个参数排在前面 if(o1.id&gt;o2.id) return 1;</span>
		<span class="token comment">//返回0，无所谓 return 0;</span>
		<span class="token annotation punctuation">@Override</span>
		<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Student</span> o1<span class="token punctuation">,</span> <span class="token class-name">Student</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> o1<span class="token punctuation">.</span>id <span class="token operator">-</span> o2<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">Student</span> student1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">Student</span> student2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">Student</span> student3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token class-name">Student</span><span class="token punctuation">[</span><span class="token punctuation">]</span> students <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{<!-- --></span> student1<span class="token punctuation">,</span> student2<span class="token punctuation">,</span> student3 <span class="token punctuation">}</span><span class="token punctuation">;</span>
		<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>students<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">IdAscendingComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//数组和怎么比大小的策略都给</span>
		<span class="token comment">//如果不是自小到大，而是大到小，可以调整比较策略</span>
		<span class="token class-name">Interget</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
 		<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MyComp</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyComp</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
		<span class="token annotation punctuation">@Override</span>
		<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> o1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> o2 <span class="token operator">-</span> o1<span class="token punctuation">;</span> <span class="token comment">//第二个参数➖第一个参数</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>同理，结合堆，自定义的时候，可以认为返回负数，认为第一个参数放在上面</p> 
<pre><code class="prism language-java"><span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> heap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyComp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="3_312"></a>3.桶排序</h5> 
<p>之前所有的排序都是<strong>基于</strong>(数字)<strong>比较</strong>的排序</p> 
<p>比如员工按照年龄排序，申请一个arr[200]，下标对应员工年龄，arr[几]++，再把词频数组还原成 原年龄数组很容易；<br> 其余呢，比较🐖，比较🐂呢，不能直接用排序算法，都得根据数据状况 在已有方法上改<br> <strong>基数排序(比较重要的不基于比较的排序)</strong><br> 先左边补齐0，再分别按照个十百千位 先进先出 的进桶出桶。就是分别按照个位，十位，百位排序<br> 十进制准备十个桶，3进制准备三个桶</p> 
<p>code：用不同的方法实现了桶的功能 不是全倒入桶再全倒出来，而是从右到左根据词频划出片(当前位有序)来<br> <img src="https://images2.imgbox.com/de/87/8AF9BXEv_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a1/77/L3I0da1t_o.png" alt="在这里插入图片描述"><br> 然后count [0,2,2,1,0,0…]=&gt;[0,2,4,5,5,5…]变成前缀和数组 《=》这是由于从左到右先进先出现象可以看成从右到左后进后出<br> <img src="https://images2.imgbox.com/b2/21/okrbDaRk_o.png" alt="在这里插入图片描述"><br> 从右往左看的话，062是最右边的数，根据词频[0,2,4,5,5,5…]，它应该在出桶的第4个，因此放在help[3]这里，同时词频减一变成[0,2,3,5,5,5…]<br> 因为count[i]的值决定了在help数组中的index，也就是位置边界(比如52，62在排序后应该是help数组中的第3和第4个)</p> 
<h5><a id="4_329"></a>4.排序总结</h5> 
<p><strong>稳定性</strong>的概念，即排序后相同值的数字(比较对象)的顺序是否和排序前数字(比较对象)顺序一致。<br> 不过这个在计数的基础类型没啥用，结合上文的比较器在其他非基础类型有效（比如Mysql中数据先按姓名排，再按年龄排，需做到多条件排序依然有序）<br> <strong>快</strong>(速)<strong>些</strong>(希尔:多次插入)<strong>选</strong>(择)<strong>堆</strong> 排序不稳定，另外的四大比较稳定(插入，冒泡，归并，基数)：关键是<strong>相等</strong>时刻<strong>相对次序</strong>是否不变，其实只要不是<strong>相邻比较</strong>，做<strong>有跨度的交换</strong>就会破坏稳定<br> <img src="https://images2.imgbox.com/1f/85/luLLufRB_o.png" alt="在这里插入图片描述"></p> 
<p><strong>小结</strong>：</p> 
<p>1）基于比较的排序时间复杂度不能做到O(N<em>logN)以下<br> 2）基于比较的排序在时间复杂度O(N</em>logN)时，不能做到空间复杂度O(N)以下还能保证稳定性<br> <img src="https://images2.imgbox.com/31/65/qHM9a3M5_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0d/01/VoVRQ5f8_o.png" alt="在这里插入图片描述"><br> 1）例如 小样本量(≤60)利用插入排序常数级低的优势，大样本量运用快排调度优势。<br> <img src="https://images2.imgbox.com/de/52/02ELeDEC_o.png" alt="在这里插入图片描述"><br> 2）系统自定义的Arraysort 会根据你传参的数据类型选择快排(计数类型)还是归并排序(其他类型)<br> 由于计数类型 稳定性无效，而其他类型为了保证稳定性选择归并。</p> 
<h3><a id="_346"></a>四.链表</h3> 
<h5><a id="1_347"></a>1.哈希表和有序表</h5> 
<p><img src="https://images2.imgbox.com/3a/b1/o2MVLX0B_o.png" alt="在这里插入图片描述"><br> 上图的7) String虽然是引用数据类型， 但也按照key-value值传递，一律拷贝一份放到哈希表<br> 而像新建一个Student类传入时，会拷贝其地址放入哈希表，一律8字节<br> <img src="https://images2.imgbox.com/06/c0/qMDmT2hU_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> treeSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//红黑树</span>
<span class="token comment">// 以下的代码会报错，因为没有提供Node类型的比较器</span>
<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
	treeSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nodeA<span class="token punctuation">)</span><span class="token punctuation">;</span>
	treeSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nodeC<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"错误信息："</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

treeSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">NodeComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 以下的代码没问题，因为提供了Node类型的比较器</span>
<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
	treeSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nodeA<span class="token punctuation">)</span><span class="token punctuation">;</span>
	treeSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nodeB<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这次节点都加入了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 展示有序表常用操作</span>
<span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> treeMap1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
treeMap1<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">"我是7"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
treeMap1<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"我是5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
treeMap1<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token string">"我是9"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
treeMap1<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"我是2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>treeMap1<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>treeMap1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>treeMap1<span class="token punctuation">.</span><span class="token function">firstKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", 我最小"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>treeMap1<span class="token punctuation">.</span><span class="token function">lastKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", 我最大"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>treeMap1<span class="token punctuation">.</span><span class="token function">floorKey</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", 在表中所有&lt;=8的数中，我离8最近"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>treeMap1<span class="token punctuation">.</span><span class="token function">ceilingKey</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", 在表中所有&gt;=8的数中，我离8最近"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
treeMap1<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>treeMap1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", 删了就没有了哦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>哈希表能实现的，有序表都能实现，还能根据key之间有序 有新的功能，但它性能会差一些，O(logN)<br> <img src="https://images2.imgbox.com/1a/ca/kRzr1B4w_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_391"></a>2.链表</h5> 
<p>练习题：<br> 1）反转单向双向链表</p> 
<pre><code class="prism language-java"><span class="token class-name">DoubleNode</span> pre<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> next<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	next<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
	head<span class="token punctuation">.</span>next<span class="token operator">=</span>pre<span class="token punctuation">;</span>
	head<span class="token punctuation">.</span>pre<span class="token operator">=</span>next<span class="token punctuation">;</span>
	pre<span class="token operator">=</span>head<span class="token punctuation">;</span>
	head<span class="token operator">=</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> pre<span class="token punctuation">;</span>
</code></pre> 
<p>2）打印输出两链表公共部分<br> 两链表从头开始比较，谁小谁移动，若相等，则打印并同时移动指针，有一个越界了停<br> <img src="https://images2.imgbox.com/eb/6c/hTotu6ew_o.png" alt="在这里插入图片描述"></p> 
<p>3）<br> <img src="https://images2.imgbox.com/f4/18/dTG94RY3_o.png" alt="在这里插入图片描述"><br> 笔试碰到直接把链表value放入栈里面，然后依序比较链表值和栈弹出值完全一致 / 或单链表反转与原来对比<br> 稍微省一些空间：只把右半边(包括中间值)放入栈里面，然后比较直到栈弹空【其实就是把右侧部分折过来】=&gt; 快慢指针，快指针一次走两步，慢指针一次走一步：奇数个是慢指针先走，偶数个是快指针先走 {边界条件了解清楚练熟了，快指针走完了，慢指针在中点前，还是中点上，还是中点后}<br> 而面试：<br> <img src="https://images2.imgbox.com/13/86/AgMOXM2Q_o.png" alt="在这里插入图片描述"></p> 
<p>slow指针到中点时，中点指向null，同时右半部分指针反转，从两头开始新的指针遍历链表对比是否相同，如果到最后都一致或中间有不一致的情况，将链表还原并返回True或False。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome3</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">Node</span> n1 <span class="token operator">=</span> head<span class="token punctuation">;</span>
		<span class="token class-name">Node</span> n2 <span class="token operator">=</span> head<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>n2<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> n2<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// find mid node</span>
			n1 <span class="token operator">=</span> n1<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// n1 -&gt; mid</span>
			n2 <span class="token operator">=</span> n2<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// n2 -&gt; end</span>
		<span class="token punctuation">}</span>
		n2 <span class="token operator">=</span> n1<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// n2 -&gt; right part first node</span>
		n1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// mid.next -&gt; null</span>
		<span class="token class-name">Node</span> n3 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>n2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// right part convert</span>
			n3 <span class="token operator">=</span> n2<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// n3 -&gt; save next node</span>
			n2<span class="token punctuation">.</span>next <span class="token operator">=</span> n1<span class="token punctuation">;</span> <span class="token comment">// next of right node convert</span>
			n1 <span class="token operator">=</span> n2<span class="token punctuation">;</span> <span class="token comment">// n1 move</span>
			n2 <span class="token operator">=</span> n3<span class="token punctuation">;</span> <span class="token comment">// n2 move</span>
		<span class="token punctuation">}</span>
		n3 <span class="token operator">=</span> n1<span class="token punctuation">;</span> <span class="token comment">// n3 -&gt; save last node</span>
		n2 <span class="token operator">=</span> head<span class="token punctuation">;</span><span class="token comment">// n2 -&gt; left first node</span>
		<span class="token keyword">boolean</span> res <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>n1 <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> n2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// check palindrome</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>n1<span class="token punctuation">.</span>value <span class="token operator">!=</span> n2<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				res <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			n1 <span class="token operator">=</span> n1<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// left to mid</span>
			n2 <span class="token operator">=</span> n2<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// right to mid</span>
		<span class="token punctuation">}</span>
		n1 <span class="token operator">=</span> n3<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		n3<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>n1 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// recover list</span>
			n2 <span class="token operator">=</span> n1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
			n1<span class="token punctuation">.</span>next <span class="token operator">=</span> n3<span class="token punctuation">;</span>
			n3 <span class="token operator">=</span> n1<span class="token punctuation">;</span>
			n1 <span class="token operator">=</span> n2<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> res<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>4）<br> <img src="https://images2.imgbox.com/30/07/PYSs5nPf_o.png" alt="在这里插入图片描述"><br> 笔试：单链表节点放Node数组，玩partition，再在数组里把值串起来。<br> 面试：<img src="https://images2.imgbox.com/79/66/VhXisWeO_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/04/31/AueF6l9C_o.png" alt="在这里插入图片描述"><br> i所到之处把所有指针打乱，各部分头尾连起来，最后，小于等于大于三块区域重连的时候要讨论清楚(假如没有 等于区域 的边界条件)</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">listPartition2</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">Node</span> sH <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// small head</span>
		<span class="token class-name">Node</span> sT <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// small tail</span>
		<span class="token class-name">Node</span> eH <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// equal head</span>
		<span class="token class-name">Node</span> eT <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// equal tail</span>
		<span class="token class-name">Node</span> bH <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// big head</span>
		<span class="token class-name">Node</span> bT <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// big tail</span>
		<span class="token class-name">Node</span> next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// save next node</span>
		<span class="token comment">// every node distributed to three lists</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
			head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>value <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>sH <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					sH <span class="token operator">=</span> head<span class="token punctuation">;</span>
					sT <span class="token operator">=</span> head<span class="token punctuation">;</span>
				<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
					sT<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
					sT <span class="token operator">=</span> head<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>value <span class="token operator">==</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>eH <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					eH <span class="token operator">=</span> head<span class="token punctuation">;</span>
					eT <span class="token operator">=</span> head<span class="token punctuation">;</span>
				<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
					eT<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
					eT <span class="token operator">=</span> head<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>bH <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					bH <span class="token operator">=</span> head<span class="token punctuation">;</span>
					bT <span class="token operator">=</span> head<span class="token punctuation">;</span>
				<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
					bT<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
					bT <span class="token operator">=</span> head<span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			head <span class="token operator">=</span> next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// small and equal reconnect</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>sT <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			sT<span class="token punctuation">.</span>next <span class="token operator">=</span> eH<span class="token punctuation">;</span>
			eT <span class="token operator">=</span> eT <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> sT <span class="token operator">:</span> eT<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// all reconnect</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>eT <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			eT<span class="token punctuation">.</span>next <span class="token operator">=</span> bH<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> sH <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> sH <span class="token operator">:</span> eH <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> eH <span class="token operator">:</span> bH<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

</code></pre> 
<p>5）<br> <img src="https://images2.imgbox.com/21/66/h1Gj0cwa_o.png" alt="在这里插入图片描述"><br> 由于无环，rand不可能指向自己，能用额外空间就哈希表，key Node类型 表老节点，Value Node类型 拷贝新节点，第一遍不考虑指针怎么连，就单纯拷贝值；第二遍在根据老链表Node的rand指针，next指针的get()查出它们的克隆指针(仅有value)，并将新链表对应的Node的next和rand指针指向上述克隆指针位置。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">copyListWithRand1</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">Node</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">.</span>next <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
			map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">.</span>rand <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>rand<span class="token punctuation">)</span><span class="token punctuation">;</span>
			cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">copyListWithRand2</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">Node</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
		<span class="token class-name">Node</span> next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token comment">// copy node and link to every node</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
			cur<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
			cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
			cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
		<span class="token class-name">Node</span> curCopy <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token comment">// set copy node rand</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
			curCopy <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
			curCopy<span class="token punctuation">.</span>rand <span class="token operator">=</span> cur<span class="token punctuation">.</span>rand <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> cur<span class="token punctuation">.</span>rand<span class="token punctuation">.</span>next <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
			cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">Node</span> res <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
		<span class="token comment">// split</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
			curCopy <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
			cur<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
			curCopy<span class="token punctuation">.</span>next <span class="token operator">=</span> next <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> next<span class="token punctuation">.</span>next <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
			cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> res<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>而不用哈希表：克隆节点就放在下一个，用它去串下一个；然后一对一对拿出来去处理（由于老链表的next指的就是3撇）<br> 把哈希表省掉的原理：利用克隆节点的位置对应关系<br> <img src="https://images2.imgbox.com/5b/48/aRo6Zj7p_o.png" alt="在这里插入图片描述"><br> 6）<br> <img src="https://images2.imgbox.com/a2/ab/ozi2kHlA_o.png" alt="在这里插入图片描述"><br> 简单点还是用HashSet放每一个遍历的节点，每到一个节点就查一下Set.contains(Node)，一旦查到就是第一个入环节点。<br> 不用Set就是用快慢指针，首先明白一个问题，<strong>如果有环，在只有一个next指针的单链表情况下，那它一定会陷入里面出不来</strong>，也就是说，快指针走两步，慢指针走一步，快指针一旦走到空，一定无环；快指针一旦能追上慢指针(同时)，一定有环，且不会在环里走两圈以上(速度是两倍，肯定能遍历完追上，所以是常数级)。<br> 接下来就比较魔性，慢指针留在原点，快指针回到head，一定会在进入环的节点相遇(快指针此时腿打断了，只能一次走一步)<br> <em>这是由于，假设无环长度为a，有环长度为b，此时慢指针走了x步，则快指针2x = x + nb，也就是在环里跑了n次才追上慢指针；即x = nb，又由于当慢指针跑到环入点的值一定是a + nb，所以慢指针再走a步一定会和快指针在环入点相遇。</em></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">getLoopNode</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">Node</span> n1 <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// n1 -&gt; slow</span>
		<span class="token class-name">Node</span> n2 <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// n2 -&gt; fast</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>n1 <span class="token operator">!=</span> n2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>n2<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> n2<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			n2 <span class="token operator">=</span> n2<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
			n1 <span class="token operator">=</span> n1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		n2 <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// n2 -&gt; walk again from head</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>n1 <span class="token operator">!=</span> n2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			n1 <span class="token operator">=</span> n1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
			n2 <span class="token operator">=</span> n2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> n1<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>两个链表分别调用上述函数得到两个入环节点Loop1和Loop2。<br> ① Loop1 = Null，Loop2=Null，如果相交只有可能是后续都共有；两个链表重新遍历，记录各自终点end1和end2，长度len1和len2：如果end1！=end2，则不相交，若相等，则长链表先走差值步(Max(len1,len2)-Min(len1,len2))，然后长短链表同时走，他们肯定会在相交点相遇。<br> <img src="https://images2.imgbox.com/57/ca/SnUOjKAl_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">noLoop</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head1<span class="token punctuation">,</span> <span class="token class-name">Node</span> head2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>head1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">Node</span> cur1 <span class="token operator">=</span> head1<span class="token punctuation">;</span>
		<span class="token class-name">Node</span> cur2 <span class="token operator">=</span> head2<span class="token punctuation">;</span>
		<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//用一个变量表长度差值：len1-len2</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur1<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//到最后一个节点停，而不是到Null停</span>
			n<span class="token operator">++</span><span class="token punctuation">;</span>
			cur1 <span class="token operator">=</span> cur1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur2<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			n<span class="token operator">--</span><span class="token punctuation">;</span>
			cur2 <span class="token operator">=</span> cur2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>cur1 <span class="token operator">!=</span> cur2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">//一定不相交</span>
		<span class="token punctuation">}</span>
		cur1 <span class="token operator">=</span> n <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> head1 <span class="token operator">:</span> head2<span class="token punctuation">;</span> <span class="token comment">// 谁长，谁的头变成cur1</span>
		cur2 <span class="token operator">=</span> cur1 <span class="token operator">==</span> head1 <span class="token operator">?</span> head2 <span class="token operator">:</span> head1<span class="token punctuation">;</span> <span class="token comment">//谁短，谁的头变成cur2</span>
		n <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			n<span class="token operator">--</span><span class="token punctuation">;</span>
			cur1 <span class="token operator">=</span> cur1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur1 <span class="token operator">!=</span> cur2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			cur1 <span class="token operator">=</span> cur1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
			cur2 <span class="token operator">=</span> cur2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> cur1<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>② Loop1和Loop2 1个为null，另一个不为null ： 不可能相交<br> ③ Loop1和Loop2都有null，只会是下图三种情况<br> <img src="https://images2.imgbox.com/e1/87/TQpoL3TH_o.png" alt="在这里插入图片描述"><br> 第二种最好求，loop1==loop2即可，然后计算head1和head2到入环点(当成end)的距离差值，其余和①一样<br> 当loop1 !=loop2时，让loop1继续往下走，不能碰到loop2是情况一，返回Null，能碰到Loop2就是情况三，此时返回Loop1和Loop2都对，只不过就是离head1和head2距离远近而已。</p> 
<pre><code class="prism language-java">
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">bothLoop</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head1<span class="token punctuation">,</span> <span class="token class-name">Node</span> loop1<span class="token punctuation">,</span> <span class="token class-name">Node</span> head2<span class="token punctuation">,</span> <span class="token class-name">Node</span> loop2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token class-name">Node</span> cur1 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token class-name">Node</span> cur2 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>loop1 <span class="token operator">==</span> loop2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		cur1 <span class="token operator">=</span> head1<span class="token punctuation">;</span>
		cur2 <span class="token operator">=</span> head2<span class="token punctuation">;</span>
		<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur1 <span class="token operator">!=</span> loop1<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			n<span class="token operator">++</span><span class="token punctuation">;</span>
			cur1 <span class="token operator">=</span> cur1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur2 <span class="token operator">!=</span> loop2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			n<span class="token operator">--</span><span class="token punctuation">;</span>
			cur2 <span class="token operator">=</span> cur2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		cur1 <span class="token operator">=</span> n <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">?</span> head1 <span class="token operator">:</span> head2<span class="token punctuation">;</span>
		cur2 <span class="token operator">=</span> cur1 <span class="token operator">==</span> head1 <span class="token operator">?</span> head2 <span class="token operator">:</span> head1<span class="token punctuation">;</span>
		n <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			n<span class="token operator">--</span><span class="token punctuation">;</span>
			cur1 <span class="token operator">=</span> cur1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur1 <span class="token operator">!=</span> cur2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			cur1 <span class="token operator">=</span> cur1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
			cur2 <span class="token operator">=</span> cur2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> cur1<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		cur1 <span class="token operator">=</span> loop1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>cur1 <span class="token operator">!=</span> loop1<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>cur1 <span class="token operator">==</span> loop2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> loop1<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			cur1 <span class="token operator">=</span> cur1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">getIntersectNode</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head1<span class="token punctuation">,</span> <span class="token class-name">Node</span> head2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>head1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token class-name">Node</span> loop1 <span class="token operator">=</span> <span class="token function">getLoopNode</span><span class="token punctuation">(</span>head1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">Node</span> loop2 <span class="token operator">=</span> <span class="token function">getLoopNode</span><span class="token punctuation">(</span>head2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>loop1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> loop2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token function">noLoop</span><span class="token punctuation">(</span>head1<span class="token punctuation">,</span> head2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>loop1 <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> loop2 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token function">bothLoop</span><span class="token punctuation">(</span>head1<span class="token punctuation">,</span> loop1<span class="token punctuation">,</span> head2<span class="token punctuation">,</span> loop2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_710"></a>五.二叉树</h3> 
<h5><a id="1_711"></a>1.哈希表和有序表</h5> 
<p>二叉树递归时会进出三次本节点，此时顺序是递归序(self = null return; self.left; self.right;)，在递归序的基础上延续出了先序中序后序遍历。<br> <img src="https://images2.imgbox.com/e1/bd/d6hLhpfD_o.png" alt="在这里插入图片描述"><br> 非递归<br> <img src="https://images2.imgbox.com/14/dc/Ymd20otl_o.png" alt="在这里插入图片描述"><br> 改一下第三步，先左后右，那么就是前序丿，打印出来就是 头右左；但如果不打印，再放到新的一个(收集)栈里面，打印出来就是左右头(后序遍历)</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">posOrderUnRecur1</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"pos-order: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			s1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s1<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				head <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				s2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					s1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					s1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s2<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>中序非递归就是逮住一棵树，先把它左子树全压栈里面，(到无左子树时)然后依次弹出打印节点的过程中，对弹出节点的右树重复</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">inOrderUnRecur</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"in-order: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//head复用遍历左节点</span>
					stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
					head <span class="token operator">=</span> head<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
				<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
					head <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//此时可能栈空</span>
					<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					head <span class="token operator">=</span> head<span class="token punctuation">.</span>right<span class="token punctuation">;</span> <span class="token comment">//但如果进了右树还有搞头</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>能这么写是因为，整棵树是可以被左树分解的，按这个左边界遍历进栈时先头再左，出栈自然就是先左后头；最后再在右子树上进行左边界遍历进栈的过程。<br> <img src="https://images2.imgbox.com/15/33/UubS9s8a_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2BFS_766"></a>2.BFS宽度优先遍历(层次遍历)</h5> 
<p>思路：采用队列，头节点进去，然后打印，先放左再放右</p> 
<p>扩展：获取树的最宽层长度和第几层：需要多一个表来记录是第几层</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">BFS_GetMaxWidth</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> levelMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录当前节点在哪一层</span>
        levelMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> curLevel <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//记录当前层</span>
        <span class="token keyword">int</span> curLevelNode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//记录当前层节点数</span>
        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Node</span> cur <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//弹出后才考虑相关操作以及左右孩子进队列</span>
            <span class="token keyword">int</span> curNodeLevel <span class="token operator">=</span> levelMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//确定当前节点在哪一层</span>
<span class="token comment">//            System.out.println(cur.value);</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>curNodeLevel <span class="token operator">==</span> curLevel<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">// BFS时没进左右树</span>
                curLevelNode<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                max <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span>curLevelNode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//不在前一层，可以开始同级了</span>
                curLevel<span class="token operator">++</span><span class="token punctuation">;</span>
                curLevelNode <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//这是发现的第一个子树节点</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                levelMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">,</span>curNodeLevel<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//进Map的时候确定好层数，在弹出的时候才知道现在是哪层</span>
                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                levelMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">,</span>curNodeLevel<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>PS：看代码别硬看，它设置多少属性，就在纸上写几个变量，画图慢慢死扣还原。</p> 
<p>不用哈希表：<br> <img src="https://images2.imgbox.com/76/f7/mm3psyQ7_o.png" alt="在这里插入图片描述"><br> 队列头进尾出+四个变量：当前弹出层/下一层最后一个节点，当前层目前几个节点，max；<br> 流程：1节点进队列，curend=①，nextend=null，curlevelNode=max=0；<br> 1节点出队列，先让左孩子2进队列，先看nextend等不等于null，如果等于null，令nextend=②；右孩子3再进队列，nextend=③；<br> 然后判断，当前层多发现一个节点，curlevelNode=1,当前节点是不是本层最后一个节点(1节点<mark>curend)=&gt;max=curlevelNode；<br> 接下来就是进入下一层，curend=nextend=③，nextend=null，curlevelNode=0，然后继续；<br> 2出，4进，nextend=④，②!=curend=&gt;curlevelNode++；<br> 3出，56进，nextend=⑥，③ == curend=&gt;max=++curlevelNode；<br> curend=nextend，nextend=null，curlevelNode=0；<br> 4出，④!=curend=&gt;curlevelNode++；<br> 5出，7进，nextend=⑦，⑤!=curend=&gt;curlevelNode++；<br> 6出，8进，nextend=⑧，⑥</mark>curend=&gt;max=++curlevelNode =3；<br> 7出，8出就不说了</p> 
<p><strong>nextend永远变成最新进队列的，当当前节点==curend时，本层结束，计算max，curend=nextend，其余初始化<br> 也就是说利用curend和nextend完成滚动更新</strong></p> 
<h5><a id="3DP_828"></a>3.套路题（可树型DP）</h5> 
<p><img src="https://images2.imgbox.com/5d/95/cISvPNuP_o.png" alt="在这里插入图片描述"><br> 1）搜索二叉树时用中序，判断弹出节点value是否升序，不升序则false。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">checkBST</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">boolean</span> isLeftBst <span class="token operator">=</span> <span class="token function">checkBST</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isLeftBst<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>preValue <span class="token operator">&gt;=</span> <span class="token class-name"><span class="token namespace">head<span class="token punctuation">.</span></span>Value</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">// 如果值不重复</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
            preValue <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">head<span class="token punctuation">.</span></span>Value</span><span class="token punctuation">;</span>   
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token function">checkBST</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token punctuation">}</span>
</code></pre> 
<p>2）层次遍历<br> ① if 如果碰到某个节点有右无左，返回false<br> ② elseif 碰到某个节点有左但无右，后续节点必须都是叶子节点（无右无左）</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isCBT</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">boolean</span> leaf <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token class-name">Node</span> l <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token class-name">Node</span> r <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			head <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			l <span class="token operator">=</span> head<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
			r <span class="token operator">=</span> head<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>leaf <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>l <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> r <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//如果遇到了不双全的节点后，又发现当前节点居然有孩子</span>
				<span class="token operator">||</span>
				<span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> r <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//有右孩子，但无左孩子</span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//有左无右</span>
				leaf <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>4）平衡二叉树<br> 套路：解决树型DP问题<br> 先列出满足题目的self节点条件：满足，左右子树平衡，且|左-右|≤1<br> 再罗列向左右树索要何种信息=&gt;因此需要左树：平衡和高度；右树：平衡和高度</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">.</span>isBalanced<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ReturnType</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">public</span> <span class="token keyword">boolean</span> isBalanced<span class="token punctuation">;</span>
		<span class="token keyword">public</span> <span class="token keyword">int</span> height<span class="token punctuation">;</span>

		<span class="token keyword">public</span> <span class="token class-name">ReturnType</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> isB<span class="token punctuation">,</span> <span class="token keyword">int</span> hei<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			isBalanced <span class="token operator">=</span> isB<span class="token punctuation">;</span>
			height <span class="token operator">=</span> hei<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ReturnType</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ReturnType</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">ReturnType</span> leftData <span class="token operator">=</span> <span class="token function">process</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">ReturnType</span> rightData <span class="token operator">=</span> <span class="token function">process</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> height <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftData<span class="token punctuation">.</span>height<span class="token punctuation">,</span> rightData<span class="token punctuation">.</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">boolean</span> isBalanced <span class="token operator">=</span> leftData<span class="token punctuation">.</span>isBalanced <span class="token operator">&amp;&amp;</span> rightData<span class="token punctuation">.</span>isBalanced
				<span class="token operator">&amp;&amp;</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>leftData<span class="token punctuation">.</span>height <span class="token operator">-</span> rightData<span class="token punctuation">.</span>height<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ReturnType</span><span class="token punctuation">(</span>isBalanced<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>同理，搜索二叉树也可以<br> 一是保证左右子树是搜索二叉树，且左max&lt;x，右min&gt;x<br> 二是左：是否搜索二叉树，max；右：boolean，min<br> 又由于递归每次返回一样的，因此需返回全集三个信息：搜，max，min</p> 
<pre><code class="prism language-java"><span class="token keyword">boolean</span> isBST <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>
	<span class="token punctuation">(</span>leftData<span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">?</span> <span class="token punctuation">(</span>leftData<span class="token punctuation">.</span>isBST <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>leftData<span class="token punctuation">.</span>max <span class="token operator">&lt;</span> x<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
	<span class="token operator">&amp;&amp;</span>
	<span class="token punctuation">(</span>rightData<span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">?</span> <span class="token punctuation">(</span>rightData<span class="token punctuation">.</span>isBST <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rightData<span class="token punctuation">.</span>min <span class="token operator">&gt;</span> x<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	isBST <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>rightData<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment">//左子树同理</span>
	max <span class="token operator">=</span> rightData<span class="token punctuation">.</span>max
<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ReturnDate</span><span class="token punctuation">(</span>isBST<span class="token punctuation">,</span> min<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>3）满二叉树<br> 简单做法：分别统计二叉树最大深度L和节点个数N，如果满足2^L-1=N即可<br> 借助套路（向左右树要信息）：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span>  <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        info data <span class="token operator">=</span> <span class="token function">process4</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> data<span class="token punctuation">.</span>nodes <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> data<span class="token punctuation">.</span>heigth<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> info<span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> heigth<span class="token punctuation">;</span>
        <span class="token keyword">int</span> nodes<span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            heigth <span class="token operator">=</span> h<span class="token punctuation">;</span>
            nodes <span class="token operator">=</span> n<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> info <span class="token function">process4</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">info</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        info leftInfo <span class="token operator">=</span> <span class="token function">process4</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        info rightInfo <span class="token operator">=</span> <span class="token function">process4</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> height <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftInfo<span class="token punctuation">.</span>heigth<span class="token punctuation">,</span>rightInfo<span class="token punctuation">.</span>heigth<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> nodes <span class="token operator">=</span> leftInfo<span class="token punctuation">.</span>nodes<span class="token operator">+</span>rightInfo<span class="token punctuation">.</span>nodes<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">info</span><span class="token punctuation">(</span>height<span class="token punctuation">,</span>nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><strong>但套路不能全能，比如要整棵树的中位数，不能通过向左右子树要中位数得解。</strong></p> 
<p>4.给定两个二叉树的节点node1和node2，找到他们的最低公共祖先节点<br> 简单方法：先用HashMap的key-value存遍历时的节点和其父节点。再用HashSet存node1开始通过fartherMap.get(cur)往上窜，直到头节点；之后再从node2开始往上窜，边检查在不在Set存的node1父亲链里，找第一个。<br> 复杂方法：<br> 分情况思考<br> 1）o1是o2最低公共祖先 或 反过来<br> 2）o1和o2不互为公共最低祖先，向上遍历才能找到<br> <img src="https://images2.imgbox.com/fb/0c/Q6l9PWBU_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">lowestAncestor</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">,</span> <span class="token class-name">Node</span> o1<span class="token punctuation">,</span> <span class="token class-name">Node</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head <span class="token operator">==</span> o1 <span class="token operator">||</span> head <span class="token operator">==</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//base case，有o返o</span>
			<span class="token keyword">return</span> head<span class="token punctuation">;</span> <span class="token comment">//返回null说明这颗子树既没有o1也没有o2</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">Node</span> left <span class="token operator">=</span> <span class="token function">lowestAncestor</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>left<span class="token punctuation">,</span> o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">Node</span> right <span class="token operator">=</span> <span class="token function">lowestAncestor</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>right<span class="token punctuation">,</span> o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//左右返回都不为空=&gt;子树各有o1和o2=&gt;从底一路往上扔</span>
			<span class="token keyword">return</span> head<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> left <span class="token operator">:</span> right<span class="token punctuation">;</span> <span class="token comment">//左右两棵树，不是都有返回值 =&gt; 会尽量返回不空的</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>5.找一个节点的后继节点（中序遍历中 后一个节点）<br> 这个简单就两个指针cur，net按中序遍历，net保存的是下一个位置的节点<br> <img src="https://images2.imgbox.com/b2/29/153KDSyZ_o.png" alt="在这里插入图片描述"><br> 但如果按上图所示的节点结构(有parent)，想比之前O(N)更快的方式找到后继节点也是有可能的<br> 也是两种情况，一是x有右树，那它的后继是右树的最左节点；（中序下一个：右边第一个最左）<br> 二是x无右树，那其后继是依次parent想上找，看x是不是parent的左孩子，此时parent就是后继（因为对于parent来说，x是左树的最右节点）；但还要考虑最后一个节点：也就是往上寻到head的时候，返回null。</p> 
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">getSuccessorNode</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> node<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            node <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span>
                node <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span> <span class="token comment">//一直往左</span>
            <span class="token keyword">return</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> 
            <span class="token class-name">Node</span> parent <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token operator">!=</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//情况二+最后节点的特殊情况</span>
                node <span class="token operator">=</span> parent<span class="token punctuation">;</span>
                parent <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span>  parent<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>6.二叉树序列化与反序列化：内存中的一棵树如何变成字符串形式，又如何从字符串形式变成内存里的树(1对1)。<br> 如何判断一棵二叉树是不是另一棵二叉树的子树。<br> <img src="https://images2.imgbox.com/63/ae/BP5d9Gc8_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java">	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">serialByPre</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//序列化</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token string">"#!"</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">String</span> res <span class="token operator">=</span> head<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token string">"_"</span><span class="token punctuation">;</span>
		res <span class="token operator">+=</span> <span class="token function">serialByPre</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		res <span class="token operator">+=</span> <span class="token function">serialByPre</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> res<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">reconByPreString</span><span class="token punctuation">(</span><span class="token class-name">String</span> preStr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//反序列化</span>
		<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> preStr<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"_"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> values<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token function">reconPreOrder</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">reconPreOrder</span><span class="token punctuation">(</span><span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> queue<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">String</span> value <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">Node</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		head<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">reconPreOrder</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
		head<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">reconPreOrder</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> head<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<ol start="7"><li></ol> 
<p>折纸条<br> 1次对折         1个凹折痕<br> 2次对折          凹凹凸<br> 3次折    凹凹凸    凹    凹凸凸<br> 4次折 凹凹凸 凹 凹凸凸 凹 凹凹凸 凸 凹凸凸<br> 每次新折痕都是在上次出现折痕上下两侧出现，上凹下凸<br> <img src="https://images2.imgbox.com/28/49/6q83x7gZ_o.png" alt="在这里插入图片描述"><br> 这是一颗头节点为凹折痕，左树凹，右树凸的满二叉树。<br> 这题是中序，在第二次经历递归序的时候打印。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printAllFolds</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">printProcess</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token class-name">N</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//递归过程，来到了某一个节点</span>
    <span class="token comment">//i是节点的层数，N是一共的层数，down==true 凹  down == false 凸</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printProcess</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">,</span> <span class="token keyword">boolean</span> down<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&gt;</span><span class="token class-name">N</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token function">printProcess</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token class-name">N</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>down<span class="token operator">?</span><span class="token string">"凹"</span><span class="token operator">:</span><span class="token string">"凸"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printProcess</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token class-name">N</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_1078"></a>六.图</h3> 
<h5><a id="1_1079"></a>1.定义好通用的图所需结构</h5> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Edge</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> weight<span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token class-name">Node</span> from<span class="token punctuation">;</span> <span class="token comment">//出边</span>
	<span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token keyword">to</span><span class="token punctuation">;</span> <span class="token comment">//入边</span>

	<span class="token keyword">public</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> weight<span class="token punctuation">,</span> <span class="token class-name">Node</span> from<span class="token punctuation">,</span> <span class="token class-name">Node</span> <span class="token keyword">to</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>from <span class="token operator">=</span> from<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">to</span> <span class="token operator">=</span> <span class="token keyword">to</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> in<span class="token punctuation">;</span> <span class="token comment">//入度</span>
	<span class="token keyword">public</span> <span class="token keyword">int</span> out<span class="token punctuation">;</span> <span class="token comment">//出度</span>
	<span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> nexts<span class="token punctuation">;</span> <span class="token comment">//出点集</span>
	<span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> edges<span class="token punctuation">;</span> <span class="token comment">//边集</span>

	<span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
		in <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		out <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		nexts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		edges <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> nodes<span class="token punctuation">;</span>
	<span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> edges<span class="token punctuation">;</span>

	<span class="token keyword">public</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		nodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		edges <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>下列代码就是将特殊类型的矩阵图表示转换为，我们经常用的图结构（上面三块）：这里的矩阵表示每一行表示一个节点，第一个值为边的权重，第2，3个值为from和to节点。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GraphGenerator</span> <span class="token punctuation">{<!-- --></span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Graph</span> <span class="token function">createGraph</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">Graph</span> graph <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">Integer</span> weight <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token class-name">Integer</span> from <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token class-name">Integer</span> <span class="token keyword">to</span> <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>graph<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				graph<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>graph<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				graph<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token class-name">Node</span> fromNode <span class="token operator">=</span> graph<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//从一开始的Integer类型 转为 Node类型</span>
			<span class="token class-name">Node</span> toNode <span class="token operator">=</span> graph<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token class-name">Edge</span> newEdge <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span>weight<span class="token punctuation">,</span> fromNode<span class="token punctuation">,</span> toNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
			fromNode<span class="token punctuation">.</span>nexts<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>toNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
			fromNode<span class="token punctuation">.</span>out<span class="token operator">++</span><span class="token punctuation">;</span>
			toNode<span class="token punctuation">.</span>in<span class="token operator">++</span><span class="token punctuation">;</span>
			fromNode<span class="token punctuation">.</span>edges<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>newEdge<span class="token punctuation">)</span><span class="token punctuation">;</span>
			graph<span class="token punctuation">.</span>edges<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>newEdge<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> graph<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="2BFSDFS___1157"></a>2.BFS和DFS + 拓扑排序</h5> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//宽度优先用队列</span>
		<span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//为了解决无向图和有向图 中环结构跑到重复点问题</span>
		queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
		map<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">Node</span> cur <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//具体操作</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> next <span class="token operator">:</span> cur<span class="token punctuation">.</span>nexts<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>map<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
					map<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
					queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//深度优先选择栈</span>
		<span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		stack<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
		set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//一进来就处理</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">Node</span> cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//当前点弹出</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> next <span class="token operator">:</span> cur<span class="token punctuation">.</span>nexts<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前点再压回去</span>
					stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//再压入next=》下次保证弹出路径</span>
					set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//不再看其他next了</span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>B弹出，再把B压入，C压入（栈永远保持深度的路径）<br> <img src="https://images2.imgbox.com/0b/af/W2o5VpFM_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token comment">// directed graph and no loop 也可以用于检测有无环</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> <span class="token function">sortedTopology</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> graph<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//入度为0点，然后删掉它的影响，再找入度为0点，依次</span>
		<span class="token comment">// key:某一个Node，value：剩余的入度</span>
		<span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> inMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//入度为0的点才能进这个队列</span>
		<span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> zeroInQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> node <span class="token operator">:</span> graph<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			inMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> node<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>in <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				zeroInQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//拓扑排序的结果，依次加入result</span>
		<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>zeroInQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token class-name">Node</span> cur <span class="token operator">=</span> zeroInQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> next <span class="token operator">:</span> cur<span class="token punctuation">.</span>nexts<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				inMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> inMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//影响消除</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>inMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					zeroInQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> result<span class="token punctuation">;</span>
</code></pre> 
<h5><a id="3kruskalPrim_1236"></a>3.kruskal算法（边）和Prim算法（点）【无向图】</h5> 
<p><img src="https://images2.imgbox.com/b0/92/Jyzrd4wz_o.png" alt="在这里插入图片描述"><br> 边从小到大考虑，如果加上不会形成环，就加上（会存在两片独立边集 突然连起来的情况）<br> 具体做法是 先将每个点 各自看成一个独立集，由小边将这些集合一个个并起来，比如上图A和C就是通过权值最小边2 并起来的。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MySets</span><span class="token punctuation">{<!-- --></span>
		<span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> setMap<span class="token punctuation">;</span>
		<span class="token keyword">public</span> <span class="token class-name">MySets</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> nodes<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">//简单类并查集的实现，但没实际上并查集快</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> cur <span class="token operator">:</span> nodes<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
				<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
				setMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSameSet</span><span class="token punctuation">(</span><span class="token class-name">Node</span> from<span class="token punctuation">,</span> <span class="token class-name">Node</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> fromSet <span class="token operator">=</span> setMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> toSet <span class="token operator">=</span> setMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> fromSet <span class="token operator">==</span> toSet<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token class-name">Node</span> from<span class="token punctuation">,</span> <span class="token class-name">Node</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> fromSet <span class="token operator">=</span> setMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> toSet <span class="token operator">=</span> setMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> toNode <span class="token operator">:</span> toSet<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">//这有个for，不够快</span>
				fromSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>toNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
				setMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>toNode<span class="token punctuation">,</span>fromSet<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> <span class="token function">kruskal</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> graph<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token class-name">MySets</span> myset <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MySets</span><span class="token punctuation">(</span>graph<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> priorityQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">EdgeComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//o1-o2，负数返回第一个，即从小到大排序</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Edge</span> edge <span class="token operator">:</span> graph<span class="token punctuation">.</span>edges<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			priorityQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>priorityQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token class-name">Edge</span> edge <span class="token operator">=</span> priorityQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>myset<span class="token punctuation">.</span><span class="token function">isSameSet</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>from<span class="token punctuation">,</span>edge<span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
				result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">)</span><span class="token punctuation">;</span>
				myset<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span>from<span class="token punctuation">,</span>edge<span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> result<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>Prim是以任意点出发，例如从Node A开始考虑它的所有Edge，选最小Edge连接新Node 同时解锁新Edge，再从所有Edge选最小<br> <img src="https://images2.imgbox.com/61/98/yYdPaRRd_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">EdgeComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
		<span class="token annotation punctuation">@Override</span>
		<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Edge</span> o1<span class="token punctuation">,</span> <span class="token class-name">Edge</span> o2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> o1<span class="token punctuation">.</span>weight <span class="token operator">-</span> o2<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> <span class="token function">primMST</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> graph<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//解锁的边进入小根堆</span>
		<span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> priorityQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>
				<span class="token keyword">new</span> <span class="token class-name">EdgeComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//考察过的Node进Set，没出现就是新Node</span>
		<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//依次挑选的边放在result</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> node <span class="token operator">:</span> graph<span class="token punctuation">.</span>nodes<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//随便挑了一个点=》由于整张图可能会不是连通图，一个点跑不完，只能各自最小生成树</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// A Node 开始</span>
				set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Edge</span> edge <span class="token operator">:</span> node<span class="token punctuation">.</span>edges<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//由一个点，解锁所有相连的边</span>
					priorityQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>priorityQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token class-name">Edge</span> edge <span class="token operator">=</span> priorityQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//弹出解锁的边中，最小的边</span>
					<span class="token class-name">Node</span> toNode <span class="token operator">=</span> edge<span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">;</span> <span class="token comment">// 可能的一个新的点</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>toNode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 不含有的时候，就是新的点</span>
						set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>toNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
						result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">)</span><span class="token punctuation">;</span>
						<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Edge</span> nextEdge <span class="token operator">:</span> toNode<span class="token punctuation">.</span>edges<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//新点所有边放进队列</span>
							priorityQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nextEdge<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 虽然会把重复边放进去，但前面的if会判断点重不重复，因此即便重复也会跳过=》也可以用一个Edge Set优化常数时间</span>
						<span class="token punctuation">}</span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> result<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="4Dijkstra_1323"></a>4.Dijkstra:单元最短路径</h5> 
<p>从A出发 新解锁路径有没有比现有路径更小 有就更新，新解锁的Node再比较完所有路径后会锁死{ <strong>没有权值为负数 的边/没有累加和负数的环</strong> =&gt; 累加和无穷小}<br> <img src="https://images2.imgbox.com/4c/47/tj7Lr5Sv_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">dijkstra1</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">// 从head出发到所有点的最小距离</span>
		<span class="token comment">// key :  从head出发到达key （某一个节点）</span>
		<span class="token comment">//value: 从head出发到达key 的最小距离</span>
		<span class="token comment">// 如果在表中，没有T的记录，含义是从head出发到T这个点的距离为正无穷</span>
		<span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> distanceMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 假如 2 Node ， 距离 7，意思是目前为止发现到2Node的最小距离为7</span>
		distanceMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//到自己距离为0</span>
		<span class="token comment">//以及求过距离的点，给锁起来放进selectedNodes中，以后再也不碰</span>
		<span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> selectedNodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token class-name">Node</span> minNode <span class="token operator">=</span> <span class="token function">getMinDistanceAndUnselectedNode</span><span class="token punctuation">(</span>distanceMap<span class="token punctuation">,</span> selectedNodes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在distanceMap中找到一个 非selectedNodes 的最小记录来处理它</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>minNode <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">int</span> distance <span class="token operator">=</span> distanceMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>minNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Edge</span> edge <span class="token operator">:</span> minNode<span class="token punctuation">.</span>edges<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token class-name">Node</span> toNode <span class="token operator">=</span> edge<span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>distanceMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>toNode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//表里没有=》正无穷，总是可以更新它</span>
					distanceMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>toNode<span class="token punctuation">,</span> distance <span class="token operator">+</span> edge<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//一开始就 0+weight</span>
				<span class="token punctuation">}</span>
				distanceMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>distanceMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>toNode<span class="token punctuation">)</span><span class="token punctuation">,</span> distance <span class="token operator">+</span> edge<span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//修改最小distance</span>
			<span class="token punctuation">}</span>
			selectedNodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>minNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
			minNode <span class="token operator">=</span> <span class="token function">getMinDistanceAndUnselectedNode</span><span class="token punctuation">(</span>distanceMap<span class="token punctuation">,</span> selectedNodes<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> distanceMap<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">getMinDistanceAndUnselectedNode</span><span class="token punctuation">(</span><span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> distanceMap<span class="token punctuation">,</span> 
			<span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> touchedNodes<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//每次通过遍历找最小</span>
		<span class="token class-name">Node</span> minNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> minDistance <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> distanceMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//entry迭代</span>
			<span class="token class-name">Node</span> node <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> distance <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>touchedNodes<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> distance <span class="token operator">&lt;</span> minDistance<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//找未touch的最小distance</span>
				minNode <span class="token operator">=</span> node<span class="token punctuation">;</span>
				minDistance <span class="token operator">=</span> distance<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> minNode<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>当然迪杰斯特拉算法可以在寻找最小未选择点的时候加速：具体做法如下<br> 维护一个小根堆，将所有未选择点放入，每次选择 堆顶并弹出，然后堆重新调整，并根据新弹出的节点，会更新堆中的值甚至增加新节点。<br> 此时，系统提供的堆不再适用与其上操作的修改值后的heapify，不能改具体的某个值，只能给一个然后出来一个再调整成堆。只能自己写！</p> 
<pre><code class="prism language-java"><span class="token comment">//改进后的dijkstra算法</span>
<span class="token comment">//从head出发，所有head能到达的节点，生成到达每个节点的最小路径记录并返回</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">dijkstra2</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token class-name">NodeHeap</span> nodeHeap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NodeHeap</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//自定义一个堆，size大小</span>
    nodeHeap<span class="token punctuation">.</span><span class="token function">addOrUpdateOrIgnore</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//第一次出现就add；塞的记录比之前更小就update；新纪录 &gt;= 原distance就ignore</span>
    <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>nodeHeap<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">NodeRecord</span> <span class="token keyword">record</span> <span class="token operator">=</span> nodeHeap<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Node</span> cur <span class="token operator">=</span> <span class="token keyword">record</span><span class="token punctuation">.</span>node<span class="token punctuation">;</span>
        <span class="token keyword">int</span> distance <span class="token operator">=</span> <span class="token keyword">record</span><span class="token punctuation">.</span>distance<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Edge</span> edge <span class="token operator">:</span> cur<span class="token punctuation">.</span>edge<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
            nodeHeap<span class="token punctuation">.</span><span class="token function">addOrUpdateOrIgnore</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">,</span> edge<span class="token punctuation">.</span>weight <span class="token operator">+</span> distance<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        result<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> distance<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//再放进result之前，把它相连的每个节点在小根堆上都更新一下</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">NodeRecord</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token class-name">Node</span> node<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> distance<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">NodeRecord</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> distance<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>node <span class="token operator">=</span> node<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>distance <span class="token operator">=</span> distance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_1403"></a>七.详解前缀树和贪心算法</h3> 
<h5><a id="1_1404"></a>1.前缀树</h5> 
<p><img src="https://images2.imgbox.com/17/0f/UKHk2eI6_o.png" alt="在这里插入图片描述"></p> 
<p>经典前缀树字符一定是放在路上的。没有这条路就新建，有这条路就复用，当然实际上会在节点和路径上多一些别的信息。</p> 
<p><img src="https://images2.imgbox.com/7b/90/00sW7Oxt_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">public</span> <span class="token keyword">int</span> path<span class="token punctuation">;</span> <span class="token comment">//在加前缀树的时候，这个节点到达（通过）多少次</span>
		<span class="token keyword">public</span> <span class="token keyword">int</span> end<span class="token punctuation">;</span> <span class="token comment">//这个节点是否是一个字符串的结尾节点，如果是的话，那它是多少字符串的结尾节点</span>
		<span class="token keyword">public</span> <span class="token class-name">TrieNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nexts<span class="token punctuation">;</span> <span class="token comment">//有多少条路 // TreeMap/HashMap&lt;Char, Node&gt; nexts; //字符多(数组费空间)可以换成哈希表，key表示有某条路，value代表通过这条路走到下个节点上去</span>

		<span class="token keyword">public</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			path <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token comment">// nexts[0] == null 没有走向'a'的路</span>
			<span class="token comment">// nexts[0] ！= null 有走向'a'的路</span>
			<span class="token comment">// ......</span>
			<span class="token comment">// nexts[25] ！= null 有走向'z'的路</span>
			nexts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//每个Node下面都可能会有26条路（26个字母），只是走没走/建没建而已</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/1d/c3/70zXyJiS_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Trie</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">private</span> <span class="token class-name">TrieNode</span> root<span class="token punctuation">;</span>

		<span class="token keyword">public</span> <span class="token class-name">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//加入一个字符串</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>word <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token class-name">TrieNode</span> node <span class="token operator">=</span> root<span class="token punctuation">;</span>
			node<span class="token punctuation">.</span>path<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//一开始根节点p++：加入多少个字符串；而其e表示有多少个空串</span>
			<span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//从左往右遍历字符串</span>
				index <span class="token operator">=</span> chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span> <span class="token comment">//由字符，对应成走向哪条路</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//没有就新建</span>
				<span class="token punctuation">}</span>
				node <span class="token operator">=</span> node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//有就下一位</span>
				node<span class="token punctuation">.</span>path<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			node<span class="token punctuation">.</span>end<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//到结尾</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">search</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//确认树中加入过word，才删除</span>
				<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token class-name">TrieNode</span> node <span class="token operator">=</span> root<span class="token punctuation">;</span>
				<span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					index <span class="token operator">=</span> chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>path <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//如果删没了==自己包括后面都没路了，这个节点标空</span>
						node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
						<span class="token keyword">return</span><span class="token punctuation">;</span>
					<span class="token punctuation">}</span>
					node <span class="token operator">=</span> node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				node<span class="token punctuation">.</span>end<span class="token operator">--</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>word <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token class-name">TrieNode</span> node <span class="token operator">=</span> root<span class="token punctuation">;</span>
			<span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				index <span class="token operator">=</span> chs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//查到一半发现没路了：即不存在</span>
					<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
				node <span class="token operator">=</span> node<span class="token punctuation">.</span>nexts<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">return</span> node<span class="token punctuation">.</span>end<span class="token punctuation">;</span> <span class="token comment">//查prefix的话 return node.path;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="2_1494"></a>2.贪心算法</h5> 
<p>（面试很少出现，01结论 区分度不高）</p> 
<p><img src="https://images2.imgbox.com/e3/48/013Cuk2p_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0b/20/F5ByqVtR_o.png" alt="在这里插入图片描述"></p> 
<p>题7:FIFS，SJF都不行，还是以<strong>谁先结束谁先</strong>就局部最优(保证剩下的时间最多)，和已经安排到的会议有重合的会议就跳过</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">bestArrange</span><span class="token punctuation">(</span><span class="token class-name">Program</span><span class="token punctuation">[</span><span class="token punctuation">]</span> programs<span class="token punctuation">,</span> <span class="token keyword">int</span> timePoint<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//timePoint即会议分配的时间</span>
		<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>programs<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ProgramComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//用一个比较器就行</span>
		<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> programs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//从左往右依次遍历所有会议</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>timePoint <span class="token operator">&lt;=</span> programs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>start<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//timePoint比现在最小的start是不是要小（也就是该会议能不能安排得上）</span>
				result<span class="token operator">++</span><span class="token punctuation">;</span>
				timePoint <span class="token operator">=</span> programs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>end<span class="token punctuation">;</span> <span class="token comment">//这里start和end表示各自会议的开始和结束时间点</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> result<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/0f/fc/g9A7ND7i_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="3_1516"></a>3.字典序证明</h5> 
<p>字典序证明：一个数组中所有字符串拼接起来，使得最终形成的字符串字典序最小<br> 长度一样比较：每位当成26进制数来比较<br> 长度不一：短的右边补0，如”b“和”ba“=&gt;“b0”&lt;“ba”<br> 直观想法是按照每个字符串各自的字典序来排：但"bba"&gt;“bab”<br> <img src="https://images2.imgbox.com/eb/10/tE35ionc_o.png" alt="在这里插入图片描述"><br> 于是升级成比较两位的</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
		<span class="token annotation punctuation">@Override</span>
		<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">String</span> a<span class="token punctuation">,</span> <span class="token class-name">String</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>b <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">lowestString</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>strs <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> strs<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strs<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MyComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">String</span> res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> strs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			res <span class="token operator">+=</span> strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> res<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>但碰到无传递性的比较策略就麻瓜了，比如斗兽棋，鼠本来最小，但它却能吃掉最大的大象，这就成<strong>环</strong>了 <strong>比较无效</strong>（原始数据值一样但顺序不一样得到的结果也不一样）</p> 
<p><strong>证明代码有效如下：</strong><br> 比如，a.b ≤ b.a + b.c ≤ c.b =&gt; a.c ≤ c.a（传递性）<br> str -&gt; k进制数<br> 比如"abc"拼接"de" =&gt; “abc” * k^2 + “de”<br> a.b &lt;=&gt; a * k^b.length + b == a * m(b) + b 【m(b)就是改写成一个函数好理解】<br> <img src="https://images2.imgbox.com/93/65/M6QPnyNe_o.png" alt="在这里插入图片描述"><br> 这两张图证明比较策略具有传递性：可以排出唯一序列，且前 . 后 ≤ 后 . 前<br> <img src="https://images2.imgbox.com/42/34/wHiVdZtJ_o.png" alt="在这里插入图片描述"><br> 因此在【。。。a。。。b。。。】的初始字典序中交换a和b后想证明其比交换前小<br> 需要通过相隔字符的传递性【下图有点像线性代数的逆序数】<br> <img src="https://images2.imgbox.com/11/58/AYi7Nnd2_o.png" alt="在这里插入图片描述"></p> 
<p>后续还需通过数学归纳法推得n=3，以及n=n时有效<br> <strong>所以，证明还是算了</strong>，不如根据某标准建立一个比较器来<strong>排序或组成堆</strong>的贪心算法+对数器（全排列暴力+数组随机生成）靠谱</p> 
<h5><a id="4_1560"></a>4.其他题目</h5> 
<p><img src="https://images2.imgbox.com/ec/03/YDBHaEFc_o.png" alt="在这里插入图片描述"><br> 思路：把数组所有数放到小根堆里面去，每次弹出最小的两个，然后把合起来的数再放入小根堆，再拿出两个做结合，依次弹出至堆只剩放回的那一个。{哈夫曼编码}</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">lessMoney</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> pQ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			pQ<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>pQ<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			cur <span class="token operator">=</span> pQ<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> pQ<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//每次弹两个，结合一个</span>
			sum <span class="token operator">+=</span> cur<span class="token punctuation">;</span> <span class="token comment">//算累加和</span>
			pQ<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重新仍入小根堆</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> sum<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ae/33/ltVblNIc_o.png" alt="在这里插入图片描述"><br> 思路：一开始把所有项目加入小根堆(按花费)里去，这是被锁住的项目，然后再依次根据是否＜m弹出到大根堆(按利润)，即解锁的项目：总结就是局部：花费最小，利润最大。最后就是弹出大根堆的堆顶，并修改m，继续上述行为【串行做有点像银行家算法】</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">findMaximizedCapital</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">W</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">Profits</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">Capital</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//W即m</span>
		<span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span><span class="token class-name">Profits</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">Profits</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			nodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Profits</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">Capital</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Capital即cost</span>
		<span class="token punctuation">}</span>

		<span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> minCostQ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MinCostComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//o1-o2</span>
		<span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> maxProfitQ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MaxProfitComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//o2-o1</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nodes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//所有项目扔进被锁的 由花费组织的小根堆</span>
			minCostQ<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//进行k轮</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>minCostQ<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> minCostQ<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>c <span class="token operator">&lt;=</span> <span class="token class-name">W</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//能力所及项目全解锁</span>
				maxProfitQ<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>minCostQ<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>maxProfitQ<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//剩下项目都做不了了</span>
				<span class="token keyword">return</span> <span class="token class-name">W</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token class-name">W</span> <span class="token operator">+=</span> maxProfitQ<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>p<span class="token punctuation">;</span> <span class="token comment">//完成一项就+利润</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token class-name">W</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/e9/c0/9APTlp2V_o.png" alt="在这里插入图片描述"></p> 
<p>两个堆，最后如果是偶数个，弹出两个堆顶取平均，奇数个 弹出size大的那个的堆顶即可。<img src="https://images2.imgbox.com/d6/9f/SnIU8pFD_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_1613"></a>八.暴力递归</h3> 
<p><img src="https://images2.imgbox.com/26/2e/Vi7f4Sht_o.png" alt="在这里插入图片描述"><br> 就是把大问题分解成小问题进行决策，一直分划到从一个范围变成一个值的base case，这个过程中不记录子问题的解(就纯分)。</p> 
<h5><a id="1N_1617"></a>1.N皇后</h5> 
<p>N皇后:其实行和列一眼就能验证，但主要要把斜线要描述的好。</p> 
<p><img src="https://images2.imgbox.com/bc/b9/U8tDlGVv_o.png" alt="在这里插入图片描述"><br> 回溯：暴力递归 这个n！</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">num1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">record</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//record[i]表示第i行的皇后摆在第value列 record[0]摆好在 record[1] record[2]</span>
		<span class="token keyword">return</span> <span class="token function">process1</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">record</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 潜台词：record[0...i-1]的任意两个皇后不共行，不共列，不共斜线</span>
	<span class="token comment">// 返回之是摆完所有皇后，合理摆法多少种</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">process1</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">record</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//目前来到第i行。record[0...i-1]表示之前行所放皇后位置。n表示整体有多少行</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//终止行，0-n-1这n个摆好了，base case达成，成功result+1</span>
			<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//当前i行皇后放在j列，会不会和之前(0...i-1)的皇后共行共列共斜线，是则无效，不是则有效</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span><span class="token keyword">record</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">record</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>
				res <span class="token operator">+=</span> <span class="token function">process1</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">record</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> res<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//record[0...i-1]你需要看，record[i...]不需要看</span>
	<span class="token comment">//返回i行皇后，放在了j列，是否有效</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">record</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">//之前某行的皇后</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token keyword">record</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token keyword">record</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">-</span> j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>k <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token comment">//不共列+ 行之差绝对值!=列之差绝对值</span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre> 
<p>时间复杂度是n!，除非按论文方法，否则指标上已是最优，唯一优化就是在常数级通过位运算对列行斜线限制代理record做检查。<br> <img src="https://images2.imgbox.com/3a/f4/WldY00SV_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_1660"></a>2.暴力递归冲冲冲</h5> 
<p><strong>①汉诺塔问题</strong><br> 其实就是分成三个圆盘 from、to和other，和一个移动函数P(i, from, to, other)</p> 
<ol><li>1 - i-1个圆盘从from-&gt;other上去 ——》P(i-1, from, other, to)</li><li>第 i 个圆盘从from-&gt;to上 ——》 打印 Print</li><li>1 - i-1个圆盘从other-&gt;to上去 ——》P(i-1, other, to, from)</li></ol> 
<p><em>尝试的时候只需要保证在这个局部下拆解是对的，那他就是对的</em></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token class-name">String</span> start<span class="token punctuation">,</span> <span class="token class-name">String</span> end<span class="token punctuation">,</span> <span class="token class-name">String</span> other<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//只剩最后一个</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Move 1 from "</span><span class="token operator">+</span> start <span class="token operator">+</span> <span class="token string">" to "</span> <span class="token operator">+</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">func</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> other<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//i不违规，i-1一样也不违规</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Move "</span><span class="token operator">+</span>i<span class="token operator">+</span> <span class="token string">" from "</span><span class="token operator">+</span> start <span class="token operator">+</span> <span class="token string">" to "</span> <span class="token operator">+</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">func</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> other<span class="token punctuation">,</span> end<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>② 打印一个字符串全部子序列，包括空串。<br> 思路：从左往右每一个字符开始，每个字符都有 要或者不要 这两条路，相当于从一开始就是做一个二叉树的子集筛选。<br> 其中可以把之前的结果存在List中，或者省内存的话，可以通过tmp暂存str[i]，str[i] = 0; ascii对应“\0”不打印，最后str[i]=tmp</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">process1</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> str<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">process</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//保留第i个字符</span>
    <span class="token keyword">char</span> tmp <span class="token operator">=</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//保留在系统栈里</span>
    str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//相当于删除该字符，相当于分配ASCII字符“\0”，也称为空字符或字符串终止符。这个字符不会在屏幕上打印任何内容，但它占用了一个字节的内存</span>
    <span class="token function">process</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//不保留</span>
    str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span> <span class="token comment">//又还回来，实现空间复用</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>③ 打印一个字符串全部排列，要求不重复<br> 思路：第一个位置n种可能性，第二个位置n-1种，…</p> 
<pre><code class="prism language-java"><span class="token comment">//str[i...]范围上，所有的字符，都可以在i位置上，后续去尝试</span>
<span class="token comment">//str[0...i-1]范围上，是之前做的选择</span>
<span class="token comment">//res存放之前所有字符串形成的全排列</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">process2</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> res<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//visit[0 1 ... 25]表示试没试过,这里是默认全是小写字母，表示当前节点对26个字母使用情况</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> str<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visit<span class="token punctuation">[</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">//不是之前走所有路取去重结果，这里是直接限定分支，常数快一些 &gt; 剪枝，分支限界</span>
            visit<span class="token punctuation">[</span>str<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//后续j和i互换位置,i==j代表不交换的排列</span>
            <span class="token function">process2</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">swap</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//回溯，回到进入递归之前的状态</span>
        <span class="token punctuation">}</span>   
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>④<br> <img src="https://images2.imgbox.com/68/c7/JWLDN0og_o.png" alt="在这里插入图片描述"><br> 这里的绝顶聪明其实就是获取自己先手情况下的最大分数，且让对方获得该情况下的最低分数，但是此最低分数是相对的，不代表比先手的最佳分数低。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">win</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">first</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">second</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//先手</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">==</span>r<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//先手只有唯一选择</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+</span><span class="token function">second</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token operator">+</span><span class="token function">second</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//A这么聪明，当然是最大化（抽左边+后手抽其他，抽右边+后手抽其他）</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">second</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//后手</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">==</span>r<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//后手没得拿</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token function">first</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">first</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//后手只能被决定，对方会从拿走l和r中选择对我而言最小的</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>⑤ 逆序栈，且不申请额外的数据结果，只能递归<br> 思路：这就需要一个函数，首先能做到移除栈内元素，再返回栈底元素，其余栈内元素放回<br> <img src="https://images2.imgbox.com/5c/26/qMNkKRH4_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">tmpsave</span><span class="token punctuation">(</span><span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> result <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//递归暂存站内元素</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>isEmpty<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span> <span class="token comment">//返回栈底元素 </span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> last <span class="token operator">=</span> <span class="token function">tmpsave</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//向下</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//存回站内元素</span>
        <span class="token keyword">return</span> last<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ad/41/kKDDCQdV_o.png" alt="在这里插入图片描述"><br> 这里其实就再延续之前style，取栈底，递归调，到栈空，往回压。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">tmpsave</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">reverse</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span>
    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>⑥ 规定1和A对应，2和B对应…，这样数字111可以转化为“AAA”，“KA”和“AK”，<br> 给定一个只有数字字符组成的字符串str，返回有多少种转化结果。<br> 思路：仍然是<strong>从左往右试</strong>，不能更改的[0-i-1 ] + i 位置开始试 + 递归后面 [i+1 …]<br> base case: i 位置是0字符，由于前面i-1均确定，0字符没法单独做决定，只能返回0。<br> i 位置不是0，则<br> 1）i 位置单独直接转化为对应字母，+ [i+1]之后数字的转化<br> 2）i = 1 || i = 2时，既可以走情况一，也可以和 i + 1位置一起转化为对应字母(不超过26)</p> 
<pre><code class="prism language-java"><span class="token comment">//i之前位置如何转化已经决定好了，i之后的位置有多少种转化结果</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span>str<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//到最后了，之前做的决定有效，1种可行结果</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//之前做的决定有效  但在看到这个位置发现没法继续转化了，只能无效，返回0种</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">transfer</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//i自己作为单独部分，后续有多少种方法</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span> i<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> str<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            res <span class="token operator">+=</span> <span class="token function">transfer</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//（i和i+1）作为单独部分，后续多少种</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">transfer</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">if</span><span class="token punctuation">(</span> i<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> str<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&gt;=</span><span class="token char">'0'</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token char">'6'</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">//小于26</span>
            res <span class="token operator">+=</span> <span class="token function">transfer</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">transfer</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//'3'-'9'</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>⑦ 01背包问题: 给定两个长度都为N的数组weights和values，weights[i]和values[i]分别代表i号物品的重量和价值。给定一个正数bag，表示一个载重bag的袋子，你装的物品不能超过这个重量。返回你能装下最多的价值是多少?<br> 思路：从左到右试呗，0号要或不要，1号要或不要…</p> 
<pre><code class="prism language-java"><span class="token comment">//i之后的货物自由选择，形成最大价值返回（不超过bag）</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">process1</span><span class="token punctuation">(</span><span class="token keyword">int</span> weights<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> alreadWeight<span class="token punctuation">,</span> <span class="token keyword">int</span> bag<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>alreadWeight <span class="token operator">&gt;</span> bag<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token comment">//之前做的决定所达到的重量 alreadWeight</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>values<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//加第i-1个的时候超重了，得减去那个超重的物品</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> weights<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">process1</span><span class="token punctuation">(</span>weights<span class="token punctuation">,</span>values<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>alreadWeight<span class="token punctuation">,</span>bag<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">//不加该物品</span>
    values<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">process1</span><span class="token punctuation">(</span>weights<span class="token punctuation">,</span>values<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>alreadWeight<span class="token operator">+</span>weights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>bag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//加[i]物品</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">process2</span><span class="token punctuation">(</span><span class="token keyword">int</span> weights<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> alreadWeight<span class="token punctuation">,</span> <span class="token keyword">int</span> alreadValue<span class="token punctuation">,</span> <span class="token keyword">int</span> bag<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>alreadWeight <span class="token operator">&gt;</span> bag<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> values<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> alreadValue<span class="token punctuation">;</span> <span class="token comment">//alreadValue表示已加背包的物品价值</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">process2</span><span class="token punctuation">(</span>weights<span class="token punctuation">,</span>values<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>alreadWeight<span class="token punctuation">,</span>alreadValue<span class="token punctuation">,</span>bag<span class="token punctuation">)</span><span class="token punctuation">,</span>  
     <span class="token function">process2</span><span class="token punctuation">(</span>weights<span class="token punctuation">,</span>values<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> alreadWeight<span class="token operator">+</span>weights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> alreadValue<span class="token operator">+</span>values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> bag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>找可变参数少，形式简单的(值就可以那就不用list)，容易改动态规划 dp是根据试法不同搞得东西</strong></p> 
<h3><a id="Ending_1844"></a>Ending</h3> 
<p>接下来就是LeetCode实战Practice了，后续也可跟着左神的基础提升班继续啊</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/887a2c72d8bb2ec7015f11171b0f261c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">javaSE-值传递和引用传递</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/62d48ec3447a8987ae7eb431d5928dcc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">git bash反应慢解决办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>