<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第二讲《k8s资源介绍：Namespace与Pod 》 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第二讲《k8s资源介绍：Namespace与Pod 》" />
<meta property="og:description" content="一、namespace介绍 1.概念 在 Kubernetes 中，命名空间（Namespace） 提供一种机制，将同一集群中的资源划分为相互隔离的组。 同一命名空间内的资源命名要唯一，但跨命名空间时没有这个要求。 命名空间作用域仅针对带有命名空间的对象，例如 Deployment、Service 等， 这种作用域对集群访问的对象不适用，例如 StorageClass、Node、PersistentVolume 等。
2.集群默认的namespace 命名空间查看
[root@k8s-master test-namespace]# kubectl get namespace NAME STATUS AGE default Active 1d kube-node-lease Active 1d kube-public Active 1d kube-system Active 1d default 没有指明使用其它命名空间的对象所使用的默认命名空间
kube-system Kubernetes系统创建对象所使用的命名空间
kube-public 这个命名空间是自动创建的，所有用户（包括未经过身份验证的用户）都可以读取它。这个命名空间主要用于集群使用，以防某些资源在整个集群中应该是可见和可读的。 这个命名空间的公共方面只是一种约定，而不是要求。
kube-node-lease 此命名空间用于与各个节点相关的 租约（Lease）对象。 节点租期允许 kubelet发送心跳，由此控制面能够检测到节点故障
3.创建命名空间 用apply创建
[root@k8s-master test-namespace]# cat test-namespace.yaml apiVersion: v1 kind: Namespace metadata: name: test [root@k8s-master test-namespace]# kubectl apply -f test-namespace.yaml namespace/test created 用create创建的两种方式" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/c2e8887e2d2466b50471e40b4dae23af/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-19T15:46:45+08:00" />
<meta property="article:modified_time" content="2023-06-19T15:46:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第二讲《k8s资源介绍：Namespace与Pod 》</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="namespace_0"></a>一、namespace介绍</h2> 
<h3><a id="1_1"></a>1.概念</h3> 
<p>在 Kubernetes 中，命名空间（Namespace） 提供一种机制，将同一集群中的资源划分为相互隔离的组。 同一命名空间内的资源命名要唯一，但跨命名空间时没有这个要求。 命名空间作用域仅针对带有命名空间的对象，例如 Deployment、Service 等， 这种作用域对集群访问的对象不适用，例如 StorageClass、Node、PersistentVolume 等。</p> 
<h3><a id="2namespace_3"></a>2.集群默认的namespace</h3> 
<p>命名空间查看</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># kubectl get namespace</span>
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
</code></pre> 
<blockquote> 
 <p>default 没有指明使用其它命名空间的对象所使用的默认命名空间<br> kube-system Kubernetes系统创建对象所使用的命名空间<br> kube-public 这个命名空间是自动创建的，所有用户（包括未经过身份验证的用户）都可以读取它。这个命名空间主要用于集群使用，以防某些资源在整个集群中应该是可见和可读的。 这个命名空间的公共方面只是一种约定，而不是要求。<br> kube-node-lease 此命名空间用于与各个节点相关的 租约（Lease）对象。 节点租期允许 kubelet发送心跳，由此控制面能够检测到节点故障</p> 
</blockquote> 
<h3><a id="3_17"></a>3.创建命名空间</h3> 
<p>用apply创建</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># cat test-namespace.yaml</span>
apiVersion: v1
kind: Namespace
metadata:
  name: <span class="token builtin class-name">test</span>
<span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f test-namespace.yaml</span>
namespace/test created
</code></pre> 
<p>用create创建的两种方式</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># kubectl create namespace test</span>
namespace/test created
<span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># kubectl create -f test-namespace.yaml</span>
namespace/test created
</code></pre> 
<h3><a id="4_35"></a>4.命名空间删除（谨慎使用）</h3> 
<p>用yaml文件删除</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># kubectl delete -f test-namespace.yaml</span>
namespace/test deleted
</code></pre> 
<p>用命令删除</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># kubectl delete namespace test</span>
namespace/test deleted
</code></pre> 
<p><strong>线上环境命名空间删除需谨慎，因为命名空间删除后，此命名空间下的所有资源会被全部删除，切记切记切记~</strong></p> 
<h3><a id="5applycreate_47"></a>5.浅谈apply和create的区别</h3> 
<p>create命令演示</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># kubectl create -f test-namespace.yaml</span>
namespace/test1 created
<span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># vim test-namespace.yaml</span>
apiVersion: v1
kind: Namespace
metadata:
  name: test1
  labels:
    test: <span class="token function">env</span>
<span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># kubectl create -f test-namespace.yaml</span>
Error from server <span class="token punctuation">(</span>AlreadyExists<span class="token punctuation">)</span>: error when creating <span class="token string">"test-namespace.yaml"</span><span class="token builtin class-name">:</span> namespaces <span class="token string">"test1"</span> already exists
</code></pre> 
<p>apply命令演示</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f test-namespace.yaml</span>
namespace/test1 created
<span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># vim test-namespace.yaml</span>
apiVersion: v1
kind: Namespace
metadata:
  name: test1
  labels:
    test: <span class="token function">env</span>
<span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f test-namespace.yaml</span>
namespace/test1 configured
</code></pre> 
<ul><li>create 此命令将告诉 K8S API服务器，你要创建、删除或替换一个或多个资源。以更简化的方式，这意味着你可以从头开始创建一个全新的对象。或者，它通过定义需求对任何现有对象进行一些更改。</li><li>apply 此命令意味着通过在给定的 YAML 文件中声明您确切需要的内容来更改已经存在的对象。</li></ul> 
<p>在 kubectl create 命令中，我们指定了一个特定行为，也就是 create，因此它是一种更具命令式的方法。在 kubectl apply 命令中，我们指定系统的目标状态，而不指定一个特定的行为，因此它是更具声明性的方法。我们让系统决定采取什么行动。如果资源不存在，它将创建它，如果资源存在，则它将配置应用于现有资源。</p> 
<h3><a id="6_81"></a>6.哪些资源在命名空间下</h3> 
<p>true OR false</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@k8s-master ~<span class="token punctuation">]</span><span class="token comment"># kubectl api-resources</span>
NAME                              SHORTNAMES   APIVERSION                             NAMESPACED   KIND
bindings                                       v1                                     <span class="token boolean">true</span>         Binding
componentstatuses                 cs           v1                                     <span class="token boolean">false</span>        ComponentStatus
configmaps                        cm           v1                                     <span class="token boolean">true</span>         ConfigMap
endpoints                         ep           v1                                     <span class="token boolean">true</span>         Endpoints
events                            ev           v1                                     <span class="token boolean">true</span>         Event
limitranges                       limits       v1                                     <span class="token boolean">true</span>         LimitRange

</code></pre> 
<h2><a id="Pod_94"></a>二、Pod介绍</h2> 
<h3><a id="1_95"></a>1.概念</h3> 
<p>Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元，也是 kubernetes 系统上运行容器化应用的资源对象。Kubernetes 集群中其他资源对象都是为 pod 这个资源对象做支撑来实现 kubernetes 管理应用服务的目的。</p> 
<h3><a id="2Pod_97"></a>2.Pod的结构</h3> 
<p><img src="https://images2.imgbox.com/b3/34/hFqTUAim_o.png" alt="在这里插入图片描述"></p> 
<p>Pause容器 全称infrastucture container（又叫infra）基础容器</p> 
<ul><li>1.每个Pod里运行着一个特殊的被称之为Pause的容器，其他容器则为业务容器，这些业务容器共享Pause容器的网络栈和Volume挂载卷</li><li>2.因此他们之间通信和数据交换更为高效，在设计时我们可以充分利用这一特性将一组密切相关的服务进程放入同一个Pod中。</li><li>3.同一个Pod里的容器之间仅需通过localhost就能互相通信。</li></ul> 
<p>pause容器主要为每个业务容器提供以下功能：</p> 
<blockquote> 
 <p>① PID命名空间：Pod中的不同应用程序可以看到其他应用程序的进程ID。<br> ② 网络命名空间：Pod中的多个容器能够访问同一个IP和端口范围。<br> ③ IPC命名空间：Pod中的多个容器能够使用SystemV IPC或POSIX消息队列进行通信。<br> ④ UTS命名空间：Pod中的多个容器共享一个主机名；Volumes（共享存储卷）<br> ⑤ Pod中的各个容器可以访问在Pod级别定义的Volumes。</p> 
</blockquote> 
<h3><a id="2Pod_112"></a>2.Pod生命周期</h3> 
<p><strong>生命周期全过程</strong><br> <img src="https://images2.imgbox.com/29/b9/pCw8Z8vQ_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <ol><li>pod创建</li><li>运行初始化容器过程（init container）</li><li>运行主容器过程（main container）</li><li>容器启动钩子（post start），容器终止前钩子（prestop）（这两个钩子的作用就是，如果你想让容器启动之后做一些事情，你可以传递一些参数或者命令给容器启动钩子这个节点，当然如果你想在终止之前执行一些命令，你可以传递一些参数和一些命令给终止前这个节点）</li><li>容器的存活性探测（liveness probe），就绪性探测（readliness probe）（这两个作用就是子过程)</li><li>pod终止</li></ol> 
</blockquote> 
<p><strong>创建主容器是必须的操作，初始化init容器，启动后钩子，存活性探测，就绪性探测，停止前钩子为可选执行。</strong><br> <img src="https://images2.imgbox.com/01/8e/GJ2fkFgM_o.png" alt="在这里插入图片描述"></p> 
<p>在整个生命周期终，pod会出现5种状态，分别如下：</p> 
<blockquote> 
 <p>Pending（挂起）：apiserver已经创建了pod资源对象，但它尚未被调度完成或者仍处于下载镜像的过程中<br> Running（运行中）：Pod 已经调度到了某个节点，Pod中所有的容器都已被创建。至少有一个容器仍在运行，或者正处于启动或重启状态。<br> Succeeded（成功）：pod中所有的容器都已经成功终止并且不会被重启<br> Failed（失败）：所有容器都已经终止，但至少有一个容器终止失败，即容器返回了非0值的退出状态<br> Unknown（未知）：apiserver无法正常获取到pod对象的状态信息，通常由网络通信失败所导致。</p> 
</blockquote> 
<h3><a id="3Pod_132"></a>3.Pod的定义</h3> 
<pre><code class="prism language-bash">apiVersion: v1     <span class="token comment">#必选，版本号，例如v1</span>
kind: Pod       　 <span class="token comment">#必选，资源类型，例如 Pod</span>
metadata:       　 <span class="token comment">#必选，元数据</span>
  name: string     <span class="token comment">#必选，Pod名称</span>
  namespace: string  <span class="token comment">#Pod所属的命名空间,默认为"default"</span>
  labels:       　　  <span class="token comment">#自定义标签列表</span>
    - name: string      　          
spec:  <span class="token comment">#必选，Pod中容器的详细定义</span>
  containers:  <span class="token comment">#必选，Pod中容器列表</span>
  - name: string   <span class="token comment">#必选，容器名称</span>
    image: string  <span class="token comment">#必选，容器的镜像名称</span>
    imagePullPolicy: <span class="token punctuation">[</span> Always<span class="token operator">|</span>Never<span class="token operator">|</span>IfNotPresent <span class="token punctuation">]</span>  <span class="token comment">#获取镜像的策略 </span>
    command: <span class="token punctuation">[</span>string<span class="token punctuation">]</span>   <span class="token comment">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span>
    args: <span class="token punctuation">[</span>string<span class="token punctuation">]</span>      <span class="token comment">#容器的启动命令参数列表</span>
    workingDir: string  <span class="token comment">#容器的工作目录</span>
    volumeMounts:       <span class="token comment">#挂载到容器内部的存储卷配置</span>
    - name: string      <span class="token comment">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span>
      mountPath: string <span class="token comment">#存储卷在容器内mount的绝对路径，应少于512字符</span>
      readOnly: boolean <span class="token comment">#是否为只读模式</span>
    ports: <span class="token comment">#需要暴露的端口库号列表</span>
    - name: string        <span class="token comment">#端口的名称</span>
      containerPort: int  <span class="token comment">#容器需要监听的端口号</span>
      hostPort: int       <span class="token comment">#容器所在主机需要监听的端口号，默认与Container相同</span>
      protocol: string    <span class="token comment">#端口协议，支持TCP和UDP，默认TCP</span>
    env:   <span class="token comment">#容器运行前需设置的环境变量列表</span>
    - name: string  <span class="token comment">#环境变量名称</span>
      value: string <span class="token comment">#环境变量的值</span>
    resources: <span class="token comment">#资源限制和请求的设置</span>
      limits:  <span class="token comment">#资源限制的设置</span>
        cpu: string     <span class="token comment">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span>
        memory: string  <span class="token comment">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span>
      requests: <span class="token comment">#资源请求的设置</span>
        cpu: string    <span class="token comment">#Cpu请求，容器启动的初始可用数量</span>
        memory: string <span class="token comment">#内存请求,容器启动的初始可用数量</span>
    lifecycle: <span class="token comment">#生命周期钩子</span>
		postStart: <span class="token comment">#容器启动后立即执行此钩子,如果执行失败,会根据重启策略进行重启</span>
		preStop: <span class="token comment">#容器终止前执行此钩子,无论结果如何,容器都会终止</span>
    livenessProbe:  <span class="token comment">#对Pod内各容器健康检查的设置，当探测无响应几次后将自动重启该容器</span>
      exec:       　 <span class="token comment">#对Pod容器内检查方式设置为exec方式</span>
        command: <span class="token punctuation">[</span>string<span class="token punctuation">]</span>  <span class="token comment">#exec方式需要制定的命令或脚本</span>
      httpGet:       <span class="token comment">#对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span>
        path: string
        port: number
        host: string
        scheme: string
        HttpHeaders:
        - name: string
          value: string
      tcpSocket:     <span class="token comment">#对Pod内个容器健康检查方式设置为tcpSocket方式</span>
         port: number
       initialDelaySeconds: <span class="token number">0</span>       <span class="token comment">#容器启动完成后首次探测的时间，单位为秒</span>
       timeoutSeconds: <span class="token number">0</span>    　　    <span class="token comment">#对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span>
       periodSeconds: <span class="token number">0</span>     　　    <span class="token comment">#对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span>
       successThreshold: <span class="token number">0</span>			<span class="token comment">#健康检查成功几次算成功</span>
       failureThreshold: <span class="token number">0</span>			<span class="token comment">#健康检查失败几次算失败</span>
       securityContext:
         privileged: <span class="token boolean">false</span>
  restartPolicy: <span class="token punctuation">[</span>Always <span class="token operator">|</span> Never <span class="token operator">|</span> OnFailure<span class="token punctuation">]</span>  <span class="token comment">#Pod的重启策略</span>
  nodeName: <span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> <span class="token comment">#设置NodeName表示将该Pod调度到指定到名称的node节点上</span>
  nodeSelector: obeject <span class="token comment">#设置NodeSelector表示将该Pod调度到包含这个label的node上</span>
  imagePullSecrets: <span class="token comment">#Pull镜像时使用的secret名称，以key：secretkey格式指定</span>
  - name: string
  hostNetwork: <span class="token boolean">false</span>   <span class="token comment">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span>
  volumes:   <span class="token comment">#在该pod上定义共享存储卷列表</span>
  - name: string    <span class="token comment">#共享存储卷名称 （volumes类型有很多种）</span>
    emptyDir: <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>       <span class="token comment">#类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span>
    hostPath: string   <span class="token comment">#类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span>
      path: string      　　        <span class="token comment">#Pod所在宿主机的目录，将被用于同期中mount的目录</span>
      type：string		<span class="token comment">#</span>
    secret:       　　　<span class="token comment">#类型为secret的存储卷，挂载集群与定义的secret对象到容器内部</span>
      scretname: string  
      items:     
      - key: string
        path: string
    configMap:         <span class="token comment">#类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span>
      name: string
      items:
      - key: string
        path: string
</code></pre> 
<p>命令行查看资源的详细属性</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># kubectl explain pod</span>
KIND:     Pod
VERSION:  v1

DESCRIPTION:
     Pod is a collection of containers that can run on a host. This resource is
     created by clients and scheduled onto hosts.

FIELDS:
   apiVersion   <span class="token operator">&lt;</span>string<span class="token operator">&gt;</span>
     APIVersion defines the versioned schema of this representation of an
     object. Servers should convert recognized schemas to the latest internal
     value, and may reject unrecognized values. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md<span class="token comment">#resources</span>

   kind <span class="token operator">&lt;</span>string<span class="token operator">&gt;</span>
     Kind is a string value representing the REST resource this object
     represents. Servers may infer this from the endpoint the client submits
     requests to. Cannot be updated. In CamelCase. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md<span class="token comment">#types-kinds</span>

   metadata     <span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span>
     Standard object's metadata. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md<span class="token comment">#metadata</span>

   spec <span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span>
     Specification of the desired behavior of the pod. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md<span class="token comment">#spec-and-status</span>

   status       <span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span>
     Most recently observed status of the pod. This data may not be up to date.
     Populated by the system. Read-only. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md<span class="token comment">#spec-and-status</span>
<span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># kubectl explain pod.apiVersion</span>
KIND:     Pod
VERSION:  v1

FIELD:    apiVersion <span class="token operator">&lt;</span>string<span class="token operator">&gt;</span>

DESCRIPTION:
     APIVersion defines the versioned schema of this representation of an
     object. Servers should convert recognized schemas to the latest internal
     value, and may reject unrecognized values. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md<span class="token comment">#resources</span>
</code></pre> 
<h3><a id="4Pod_261"></a>4.Pod的基本配置</h3> 
<h4><a id="41_262"></a>4.1镜像拉取策略</h4> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># cat test-pod.yaml</span>
apiVersion: v1
kind: Pod
metadata:
  name: test-pod
  namespace: <span class="token builtin class-name">test</span>
  labels:
    env: <span class="token builtin class-name">test</span>
spec:
  containers:
    - name: nginx <span class="token comment"># 容器名称</span>
      image: nginx:1.16.1 <span class="token comment"># 容器需要的镜像地址</span>
      imagePullPolicy: Always <span class="token comment"># 镜像拉去策略[Always|IfNotPresent|Never]</span>
</code></pre> 
<p>三种拉取策略：</p> 
<blockquote> 
 <p>Always：总是从远程仓库拉取镜像（一直远程下载）。<br> IfNotPresent：本地有则使用本地镜像，本地没有则从远程仓库拉取镜像（本地有就用本地，本地没有就使用远程下载）。<br> Never：只使用本地镜像，从不去远程仓库拉取，本地没有就报错（一直使用本地，没有就报错）。</p> 
</blockquote> 
<p>默认值说明：</p> 
<blockquote> 
 <p>如果镜像tag为具体的版本号，默认策略是IfNotPresent。 如果镜像tag为latest（最终版本），默认策略是Always。</p> 
</blockquote> 
<p>创建Pod</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f test-pod.yaml</span>
</code></pre> 
<p>查看Pod的详细信息</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># kubectl describe pod test-pod -n test</span>
</code></pre> 
<h4><a id="42_294"></a>4.2启动命令</h4> 
<p>添加command参数</p> 
<pre><code class="prism language-bash">apiVersion: v1
kind: Pod
metadata:
  name: test-pod
  namespace: <span class="token builtin class-name">test</span>
  labels:
    env: <span class="token builtin class-name">test</span>
spec:
  containers:
    - name: nginx <span class="token comment"># 容器名称</span>
      image: nginx:1.16.1 <span class="token comment"># 容器需要的镜像地址</span>
      imagePullPolicy: Always <span class="token comment"># 镜像拉去策略[Always|IfNotPresent|Never]</span>
    - name: busybox <span class="token comment"># 容器名称</span>
      image: busybox:1.30 <span class="token comment"># 容器需要的镜像地址</span>
      command: <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span>,<span class="token string">"-c"</span>,<span class="token string">"touch /tmp/hello.txt;while true;do /bin/echo <span class="token variable"><span class="token variable">$(</span><span class="token function">date</span> +%T<span class="token variable">)</span></span> &gt;&gt; /tmp/hello.txt;sleep 3;done;"</span><span class="token punctuation">]</span>
</code></pre> 
<p>更新pod</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f test-pod.yaml</span>
</code></pre> 
<p>进入pod查看命令执行结果</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># kubectl exec -it test-pod -n test -c busybox -- /bin/sh</span>
/ <span class="token comment"># cat /tmp/hello.txt</span>
02:02:14
02:02:17
02:02:20
02:02:23
</code></pre> 
<p>特别说明：通过上面发现command已经可以完成启动命令和传递参数的功能，为什么还要提供一个args选项，用于传递参数？其实和Docker有点关系，kubernetes中的command和args两个参数其实是为了实现覆盖Dockerfile中的ENTRYPOINT的功能：</p> 
<blockquote> 
 <p>如果command和args均没有写，那么用Dockerfile的配置。<br> 如果command写了，但是args没有写，那么Dockerfile默认的配置会被忽略，执行注入的command。<br> 如果command没有写，但是args写了，那么Dockerfile中配置的ENTRYPOINT命令会被执行，使用当前args的参数。<br> 如果command和args都写了，那么Dockerfile中的配置会被忽略，执行command并追加上args参数。</p> 
</blockquote> 
<h4><a id="43_333"></a>4.3环境变量</h4> 
<p>添加env参数</p> 
<pre><code class="prism language-bash">apiVersion: v1
kind: Pod
metadata:
  name: test-pod
  namespace: <span class="token builtin class-name">test</span>
  labels:
    env: <span class="token builtin class-name">test</span>
spec:
  containers:
    - name: nginx <span class="token comment"># 容器名称</span>
      image: nginx:1.16.1 <span class="token comment"># 容器需要的镜像地址</span>
      imagePullPolicy: Always <span class="token comment"># 镜像拉去策略[Always|IfNotPresent|Never]</span>
    - name: busybox <span class="token comment"># 容器名称</span>
      image: busybox:1.30 <span class="token comment"># 容器需要的镜像地址</span>
      command: <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span>,<span class="token string">"-c"</span>,<span class="token string">"touch /tmp/hello.txt;while true;do /bin/echo <span class="token variable"><span class="token variable">$(</span><span class="token function">date</span> +%T<span class="token variable">)</span></span> &gt;&gt; /tmp/hello.txt;sleep 3;done;"</span><span class="token punctuation">]</span>
      env:
        - name: <span class="token string">"username"</span>
          value: <span class="token string">"admin"</span>
        - name: <span class="token string">"password"</span>
          value: <span class="token string">"123456"</span>
</code></pre> 
<p>更新pod</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f pod-test.yaml</span>
pod/test-pod created
</code></pre> 
<p>进入Pod查看环境变量</p> 
<pre><code class="prism language-bash">/tmp <span class="token comment"># echo $username</span>
admin
/tmp <span class="token comment"># echo $password</span>
<span class="token number">123456</span>
</code></pre> 
<h4><a id="44_370"></a>4.4端口配置</h4> 
<pre><code class="prism language-bash">apiVersion: v1
kind: Pod
metadata:
  name: test-pod
  namespace: <span class="token builtin class-name">test</span>
  labels:
    env: <span class="token builtin class-name">test</span>
spec:
  containers:
    - name: nginx <span class="token comment"># 容器名称</span>
      image: nginx:1.16.1 <span class="token comment"># 容器需要的镜像地址</span>
      imagePullPolicy: Always <span class="token comment"># 镜像拉去策略[Always|IfNotPresent|Never]</span>
      ports:
      - containerPort: <span class="token number">8090</span>	<span class="token comment"># 容器端口</span>
        name: nginx-port	<span class="token comment"># 端口名称</span>
        protocol: TCP		<span class="token comment"># 端口协议</span>
    - name: busybox <span class="token comment"># 容器名称</span>
      image: busybox:1.30 <span class="token comment"># 容器需要的镜像地址</span>
      command: <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span>,<span class="token string">"-c"</span>,<span class="token string">"touch /tmp/hello.txt;while true;do /bin/echo <span class="token variable"><span class="token variable">$(</span><span class="token function">date</span> +%T<span class="token variable">)</span></span> &gt;&gt; /tmp/hello.txt;sleep 3;done;"</span><span class="token punctuation">]</span>
      env:
        - name: <span class="token string">"username"</span>
          value: <span class="token string">"admin"</span>
        - name: <span class="token string">"password"</span>
          value: <span class="token string">"123456"</span>
</code></pre> 
<p>更新pod</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@k8s-master test-namespace<span class="token punctuation">]</span><span class="token comment"># kubectl apply -f pod-test.yaml</span>
pod/test-pod created
</code></pre> 
<p>查看端口<br> <img src="https://images2.imgbox.com/3a/aa/Yu6oaa4X_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/831ab59d2d2ce35c551b7e6a44b07d06/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Idea&#43;maven&#43;springboot项目搭建系列--3 整合阿里云Canal完成Mysql数据的监听</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/90d9e02e06bb16c8f2bbdb0972820ee8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">cdp hive3.1表为事务表和外部表的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>