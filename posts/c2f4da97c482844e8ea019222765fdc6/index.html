<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>从私有Git仓库的搭建到命令的使用再到分支管理，全流程全套服务包您满意 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="从私有Git仓库的搭建到命令的使用再到分支管理，全流程全套服务包您满意" />
<meta property="og:description" content="您好，我是码农飞哥，感谢您阅读本文，欢迎一键三连哦。
💪🏻 1. Python基础专栏，基础知识一网打尽，9.9元买不了吃亏，买不了上当。 Python从入门到精通
❤️ 2. Python爬虫专栏，系统性的学习爬虫的知识点。9.9元买不了吃亏，买不了上当，持续更新中 。python爬虫入门进阶
❤️ 3. Ceph实战，从原理到实战应有尽有。 Ceph实战
❤️ 4. Java高并发编程入门，打卡学习Java高并发。 Java高并发编程入门
😁 5. 社区逛一逛，周周有福利，周周有惊喜。码农飞哥社区，飞跃计划
全网同名【码农飞哥】欢迎关注，个人VX: wei158556
文章目录 1. Git是什么？2. Git与SVN的比较3. 系统环境4. 安装Git客户端Linux系统下 Windows系统下5.本地版本库操作创建本地版本库工作区和暂存区管理修改删除文件 5.Ubuntu搭建私有的git仓库GitLab的使用添加用户添加团队新建远程仓库 SSH key的配置（生成公钥和私钥） 6. 分支管理创建与合并分支1. 创建dev分支2. 查看所有分支3. 分支合并 解决冲突比较差异分支管理策略Bug分支保存工作现场查看工作现场恢复工作现场删除工作现场恢复并删除工作现场合并某一次的提交 feature分支远程仓库（多人协作）本地仓库关联远程仓库第一次先拉取远程库中的README.md和.gitignore等文件克隆远程仓库删除远程Git仓库查看远程分支推送分支创建远程分支拉取分支关联本地分支和远程分支拉取远程分支并创建本地分支删除远程分支查看分支版本回退将多次提交合并成一次提交分支重命名 7. 标签管理回滚某次提交 总结 1. Git是什么？ Git是一款开源的分布式版本控制系统，可以有效，高速处理从很小到非常大的项目版本管理。 Git是通过C语言开发实现的。
2. Git与SVN的比较 Git和SVN是两种截然不同的版本控制系统，Git是分布式版本控制系统，而SVN则是集中式版本控制系统。要想比较Git和SVN的区别，首先需要了解分布式版本控制系统和集中式版本控制系统的基本概念。
集中式版本控制系统：一个显著的特征是版本库是存放在中央服务器上的，由中央服务器统一管理项目的版本信息和分支信息。团队中的每个成员在工作时都需要先从中央服务器上拉取最新的代码，然后开始干活。干完活之后再将代码提交到中央服务器上。集中式版本服务器有两个弊端：
必须联网才能工作，当没有网络或者网络很差时，则团队中的成员无法协同工作。安全性不好，因为版本库存放在了中央服务器，当中央服务器损坏时则会丢失版本库，使所有成员都没法工作。 集中式版本控制系统的网络拓扑图如下图所示：
可以看出团队中所有成员的工作电脑都只与中央服务器打交道。如果把版本库比做书库的话，那么每个人（每个电脑）都需要先从书库借到书（拉取最新的代码），阅读完之后然后还给书库（修改之后提交到中央服务器）
分布式版本控制系统: 与集中式版本控制系统最大的不同是团队中所有成员的工作电脑上都有一个完整的版本库，并且没有中央服务器。,这就相当于团队中每个成员都有一个自己的小书库（版本库），成员之间可以互相交换自己书库中的图书（将自己的修改提交给对方）。这里完全不需要中央服务器来管理协调管理。
在实际使用分布式版本控制系统时，其实很少在两人之间的电脑上进行版本库推送，这是因为有时候你们不在同一个局域网内，或者你同事的电脑关机了。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。这台充当“中央服务器”的电脑上的版本库称之为远程版本库，其他成员电脑上的版本库称之为本地版本库。后面会详细介绍。
分布式版本控制系统的网络拓扑图如下图所示：
分布式版本控制系统剔除了中央服务器，这充分体现了分布式的核心概念，就是去中心化。这样带来的好处有两点：
没有网络也能上班：团队中的每个成员在没有网络的情况下也能工作，因为本地有完整的版本库，不需要担心数据的丢失。数据更安全：当某个成员的电脑坏掉了不要紧，只需要从其他成员的电脑上复制一份即可。但是集中式版本控制系统的中央服务器出问题，则可能会丢失版本库，使得所有人都没法工作。 3. 系统环境 系统版本WindowsWindows10LinuxUbuntu16.04 4. 安装Git客户端 说完了Git的基本概念，接下来还是安装个Git客户端下来耍一耍。这里分不同的操作系统简单的介绍一下Git客户端的安装。
Linux系统下 首先通过git --version 命令查看电脑上是否已经安装了Git客户端。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/c2f4da97c482844e8ea019222765fdc6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-27T16:29:28+08:00" />
<meta property="article:modified_time" content="2022-09-27T16:29:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从私有Git仓库的搭建到命令的使用再到分支管理，全流程全套服务包您满意</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p><strong>您好，我是码农飞哥，感谢您阅读本文，欢迎一键三连哦</strong>。<br> <strong>💪🏻 1. Python基础专栏，基础知识一网打尽，9.9元买不了吃亏，买不了上当。 <a href="https://blog.csdn.net/u014534808/category_10711684.html">Python从入门到精通</a></strong><br> <strong>❤️ 2. Python爬虫专栏，系统性的学习爬虫的知识点。9.9元买不了吃亏，买不了上当，持续更新中 。<a href="https://blog.csdn.net/u014534808/category_11432885.html">python爬虫入门进阶</a></strong><br> <strong>❤️ 3. Ceph实战，从原理到实战应有尽有。 <a href="https://blog.csdn.net/u014534808/category_10515730.html">Ceph实战</a></strong><br> <strong>❤️ 4. Java高并发编程入门，打卡学习Java高并发。 <a href="https://blog.csdn.net/u014534808/category_9621854.html">Java高并发编程入门</a></strong><br> <strong>😁 5. 社区逛一逛，周周有福利，周周有惊喜。<a href="https://bbs.csdn.net/forums/feige?category=0">码农飞哥社区，飞跃计划</a></strong><br> <strong>全网同名【码农飞哥】欢迎关注，个人VX: wei158556</strong></p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#1_Git_10" rel="nofollow">1. Git是什么？</a></li><li><a href="#2_GitSVN_12" rel="nofollow">2. Git与SVN的比较</a></li><li><a href="#3__32" rel="nofollow">3. 系统环境</a></li><li><a href="#4_Git_39" rel="nofollow">4. 安装Git客户端</a></li><li><ul><li><a href="#Linux_41" rel="nofollow">Linux系统下</a></li></ul> 
   </li><li><a href="#Windows_68" rel="nofollow">Windows系统下</a></li><li><a href="#5_73" rel="nofollow">5.本地版本库操作</a></li><li><ul><li><a href="#_75" rel="nofollow">创建本地版本库</a></li><li><a href="#_86" rel="nofollow">工作区和暂存区</a></li><li><a href="#_99" rel="nofollow">管理修改</a></li><li><a href="#_114" rel="nofollow">删除文件</a></li></ul> 
   </li><li><a href="#5Ubuntugit_121" rel="nofollow">5.Ubuntu搭建私有的git仓库</a></li><li><ul><li><a href="#GitLab_181" rel="nofollow">GitLab的使用</a></li><li><ul><li><a href="#_182" rel="nofollow">添加用户</a></li><li><a href="#_188" rel="nofollow">添加团队</a></li><li><a href="#_193" rel="nofollow">新建远程仓库</a></li></ul> 
    </li><li><a href="#SSH_key_201" rel="nofollow">SSH key的配置（生成公钥和私钥）</a></li></ul> 
  </li></ul> 
  </li><li><a href="#6__225" rel="nofollow">6. 分支管理</a></li><li><ul><li><a href="#_226" rel="nofollow">创建与合并分支</a></li><li><ul><li><ul><li><a href="#1_dev_232" rel="nofollow">1. 创建dev分支</a></li><li><a href="#2__257" rel="nofollow">2. 查看所有分支</a></li><li><a href="#3__259" rel="nofollow">3. 分支合并</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_285" rel="nofollow">解决冲突</a></li><li><a href="#_302" rel="nofollow">比较差异</a></li><li><a href="#_306" rel="nofollow">分支管理策略</a></li><li><a href="#Bug_313" rel="nofollow">Bug分支</a></li><li><ul><li><a href="#_317" rel="nofollow">保存工作现场</a></li><li><a href="#_323" rel="nofollow">查看工作现场</a></li><li><a href="#_330" rel="nofollow">恢复工作现场</a></li><li><a href="#_336" rel="nofollow">删除工作现场</a></li><li><a href="#_343" rel="nofollow">恢复并删除工作现场</a></li><li><a href="#_350" rel="nofollow">合并某一次的提交</a></li></ul> 
   </li><li><a href="#feature_355" rel="nofollow">feature分支</a></li><li><a href="#_362" rel="nofollow">远程仓库（多人协作）</a></li><li><ul><li><a href="#_364" rel="nofollow">本地仓库关联远程仓库</a></li><li><a href="#READMEmdgitignore_375" rel="nofollow">第一次先拉取远程库中的README.md和.gitignore等文件</a></li><li><a href="#_380" rel="nofollow">克隆远程仓库</a></li><li><a href="#Git_393" rel="nofollow">删除远程Git仓库</a></li><li><a href="#_398" rel="nofollow">查看远程分支</a></li><li><a href="#_408" rel="nofollow">推送分支</a></li><li><a href="#_420" rel="nofollow">创建远程分支</a></li><li><a href="#_426" rel="nofollow">拉取分支</a></li><li><a href="#_444" rel="nofollow">关联本地分支和远程分支</a></li><li><a href="#_452" rel="nofollow">拉取远程分支并创建本地分支</a></li><li><a href="#_462" rel="nofollow">删除远程分支</a></li><li><a href="#_470" rel="nofollow">查看分支</a></li><li><a href="#_474" rel="nofollow">版本回退</a></li><li><a href="#_487" rel="nofollow">将多次提交合并成一次提交</a></li><li><a href="#_505" rel="nofollow">分支重命名</a></li></ul> 
   </li><li><a href="#7__509" rel="nofollow">7. 标签管理</a></li><li><ul><li><a href="#_527" rel="nofollow">回滚某次提交</a></li></ul> 
   </li><li><a href="#_537" rel="nofollow">总结</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1_Git_10"></a>1. Git是什么？</h3> 
<p>Git是一款开源的分布式版本控制系统，可以有效，高速处理从很小到非常大的项目版本管理。 Git是通过C语言开发实现的。</p> 
<h3><a id="2_GitSVN_12"></a>2. Git与SVN的比较</h3> 
<p>Git和SVN是两种截然不同的版本控制系统，Git是分布式版本控制系统，而SVN则是集中式版本控制系统。要想比较Git和SVN的区别，首先需要了解分布式版本控制系统和集中式版本控制系统的基本概念。<br> 集中式版本控制系统：一个显著的特征是<strong>版本库是存放在中央服务器上的</strong>，由中央服务器统一管理项目的版本信息和分支信息。团队中的每个成员在工作时都需要先从中央服务器上拉取最新的代码，然后开始干活。干完活之后再将代码提交到中央服务器上。集中式版本服务器有两个弊端：</p> 
<ol><li>必须联网才能工作，当没有网络或者网络很差时，则团队中的成员无法协同工作。</li><li>安全性不好，因为版本库存放在了中央服务器，当中央服务器损坏时则会丢失版本库，使所有成员都没法工作。</li></ol> 
<p>集中式版本控制系统的网络拓扑图如下图所示：<br> <img src="https://images2.imgbox.com/a6/5b/pvFOVGvB_o.png" alt="在这里插入图片描述"><br> 可以看出团队中所有成员的工作电脑都只与中央服务器打交道。如果把版本库比做书库的话，那么每个人（每个电脑）都需要先从书库借到书（拉取最新的代码），阅读完之后然后还给书库（修改之后提交到中央服务器）</p> 
<p>分布式版本控制系统: 与集中式版本控制系统最大的不同是<strong>团队中所有成员的工作电脑上都有一个完整的版本库，并且没有中央服务器。</strong>,这就相当于团队中每个成员都有一个自己的小书库（版本库），成员之间可以互相交换自己书库中的图书（将自己的修改提交给对方）。这里完全不需要中央服务器来管理协调管理。<br> 在实际使用分布式版本控制系统时，其实很少在两人之间的电脑上进行版本库推送，这是因为有时候你们不在同一个局域网内，或者你同事的电脑关机了。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。<strong>这台充当“中央服务器”的电脑上的版本库称之为远程版本库，其他成员电脑上的版本库称之为本地版本库</strong>。后面会详细介绍。</p> 
<p>分布式版本控制系统的网络拓扑图如下图所示：</p> 
<p><img src="https://images2.imgbox.com/dd/c9/5mG0fdGx_o.png" alt="在这里插入图片描述"><br> 分布式版本控制系统剔除了中央服务器，这充分体现了分布式的核心概念，就是去中心化。这样带来的好处有两点：</p> 
<ol><li>没有网络也能上班：团队中的每个成员在没有网络的情况下也能工作，因为本地有完整的版本库，不需要担心数据的丢失。</li><li>数据更安全：当某个成员的电脑坏掉了不要紧，只需要从其他成员的电脑上复制一份即可。但是集中式版本控制系统的中央服务器出问题，则可能会丢失版本库，使得所有人都没法工作。</li></ol> 
<h3><a id="3__32"></a>3. 系统环境</h3> 
<table><thead><tr><th>系统</th><th>版本</th></tr></thead><tbody><tr><td>Windows</td><td>Windows10</td></tr><tr><td>Linux</td><td>Ubuntu16.04</td></tr></tbody></table> 
<h3><a id="4_Git_39"></a>4. 安装Git客户端</h3> 
<p>说完了Git的基本概念，接下来还是安装个Git客户端下来耍一耍。这里分不同的操作系统简单的介绍一下Git客户端的安装。</p> 
<h4><a id="Linux_41"></a>Linux系统下</h4> 
<p>首先通过<code>git --version</code> 命令查看电脑上是否已经安装了Git客户端。<br> <img src="https://images2.imgbox.com/01/b7/4bacehNx_o.png" alt="在这里插入图片描述"><br> 如果已经安装了就可以跳过此章节。如果没有安装的话就接着往下面看：<br> Linux系统有不同的发行版本，可以通过<code>cat /proc/version</code> 命令查看Linux的版本。</p> 
<ol><li>Debian或Ubuntu下安装Git<br> 在 Debian或Ubuntu可以通过apt包管理工具安装Git，命令如下：</li></ol> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">git</span>
</code></pre> 
<ol start="2"><li>Red Hat 或者CentOS下安装Git<br> Red Hat 或者CentOS下可以通过yum包管理工具安装Git，命令如下：</li></ol> 
<pre><code class="prism language-bash">yum <span class="token function">install</span> <span class="token function">git</span> -y
</code></pre> 
<p>如果找不到yum命令的话，则需要先安装yum工具。可以参考下面命令</p> 
<pre><code class="prism language-bash"><span class="token comment">#删除yum.repos.d目录下所有文件</span>
<span class="token function">rm</span> -f /etc/yum.repos.d/*
<span class="token comment">#然后重新下载阿里的yum源</span>
<span class="token function">wget</span> -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
<span class="token comment">#清理缓存</span>
yun clean all
</code></pre> 
<h3><a id="Windows_68"></a>Windows系统下</h3> 
<p>Git的官方下载地址是：<a href="https://git-scm.com/downloads" rel="nofollow">Git的下载地址</a><br> <img src="https://images2.imgbox.com/1c/55/Cr3Okjji_o.png" alt="在这里插入图片描述"><br> 下载好安装包之后，一直点击下一步即可安装。再次就不在赘述。</p> 
<h3><a id="5_73"></a>5.本地版本库操作</h3> 
<p>Windows下安装好Git之后会出现Git Bash 和Git GUI两个应用程序，其中Git Bash是Git的命令行工具，而Git GUI则是Git的可视化工具（一般很少用）。</p> 
<h4><a id="_75"></a>创建本地版本库</h4> 
<p>创建本地版本库分为两步：<br> 第一步是创建一个空文件夹,命名为: git_learn。<br> 第二步就是在该文件夹下执行<code>git init</code> 命令将该文件夹变成git可以管理的版本库。<br> 执行第二步之后，在 git_learn目录下会出现一个名为.git的隐藏文件夹，该文件夹就是git的版本库。<strong>切记不要手动修改.git文件夹下的任何内容，以免本地版本库不可用</strong>。</p> 
<p>本地版本库建好之后就可以在git_learn文件夹下创建一个文件进行测试了。这里创建了一个名为readme.txt的文件。<br> 添加到暂存区<br> 通过<code>git add readme.txt</code>命令可以将readme.txt文件提交到暂存区（关于暂存区的概念后面会详细介绍）。如果有多个文件需要添加的话，可以执行<code>git add .</code> 命令。<br> 提交到版本库<br> 因为git的本地都是有完整版本库的，所以还需要将前面创建的readme.txt文件提交到本地版本库的当前分支，默认是master。命令格式是<code>git commit -m '&lt;message&gt;'</code> ,其中写入你的提交备注。</p> 
<h4><a id="_86"></a>工作区和暂存区</h4> 
<p>这里有两个很重要的概念，一个是工作区，另一个是暂存区（Git特有的概念）。<br> 工作区<br> 工作区就是你电脑上能看到的目录（不包括隐藏文件），例如：git_learn目录就是一个工作区。</p> 
<p>暂存区<br> 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库，其中最重要的是暂存区（stage）。</p> 
<p>还有Git为我们自动创建的第一个分支叫master，以及指向master的一个指针叫HEAD。</p> 
<p>前面提到了工作区，暂存区，<code>git add</code>命令和<code>git comit</code> 命令。那么他们之间有啥关系呢？下面就用一张流程图展示一下：<br> <img src="https://images2.imgbox.com/8d/6b/h1ltZJvR_o.png" alt="在这里插入图片描述"><br> 通过add命令将工作区中ABC文件夹提交到暂存区stage，在通过commit命令将stage中的ABC文件夹提交到当前分支master。</p> 
<h4><a id="_99"></a>管理修改</h4> 
<p>Git管理的是修改而非文件。这里的修改指的是对工作区的任何操作，包括新增文件；删除文件；修改文件等等。哪怕是在文件中增加一句话或者删除一个字符都可以算是修改。下面就举例说明下,还是以readme.txt文件为例：</p> 
<ol><li>第一次在readme.txt文件中增加一个词语 gittest。然后执行<code>git add readme.txt</code>,并通过命令<code>git status</code>查看状态。<br> <em>hello world<br> gittest</em><br> <img src="https://images2.imgbox.com/1f/44/ZXrhJq8H_o.png" alt="在这里插入图片描述"></li><li>第二次再在readme.txt文件上添加一行内容<code>git tracks changes</code>。<br> <em>hello world<br> gittest<br> git tracks changes</em></li></ol> 
<p>直接执行<code>git commit -m 'git tracks changes'</code>命令。然后通过 <code>git status </code>，可以发现第二次的修改没有提交。这是因为第二次的修改没有先提交到暂存区中。<br> <img src="https://images2.imgbox.com/2a/e2/sHSMR5na_o.png" alt="在这里插入图片描述"><br> 我们的操作过程是<code>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit</code>。当使用<code>git add</code> 命令后，在工作区中的第一次修改被放入暂存区中，准备提交，在工作区中的第二次修改没有被放入暂存区中，所以，<code>git commit</code>只负责把暂存区中的修改提交到当前分支。所以第二次的修改没有提交。<br> <strong>也就是说，所有的修改必须先通过git add 提交到暂存区，然后通过git commit 提交到当前分支。</strong>。在实际开发中一般是将所有修改合并起来add,然后在一起commit。</p> 
<h4><a id="_114"></a>删除文件</h4> 
<p>当前分支上有一个已经废弃不用的文件，该如何删除呢？比如要删除一个名为test1.txt文件。只需要两行命令。</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> <span class="token function">rm</span> test1.txt
<span class="token function">git</span> commit -m <span class="token string">"remove test.txt"</span>
</code></pre> 
<h3><a id="5Ubuntugit_121"></a>5.Ubuntu搭建私有的git仓库</h3> 
<p>前面介绍了在实际开发中，一般会拿一台电脑作为“中央仓库”，充当中央仓库的电脑需要安装一个代码仓库软件，这里选用开源软件GitLab，它是基于git实现的在线代码仓库软件，提供web可视化管理界面，可以在本地部署。通常用于企业团队内部协作开发。当然，如果你不想搭建私人的git仓库，那么也可以直接使用最大的同性交友网站Github（使用与GitLab类似）。<br> 那么该如何在Ubuntu上安装GitLab软件，搭建私有的Git仓库呢？</p> 
<ol><li>安装必须的一些服务</li></ol> 
<pre><code class="prism language-bash"><span class="token comment">#更新apt源</span>
<span class="token function">sudo</span> <span class="token function">apt-get</span> update
<span class="token comment">#安装依赖包，运行命令</span>
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">curl</span> openssh-server ca-certificates postfix
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> -y postfix
</code></pre> 
<ol start="2"><li>接着信任 GitLab 的 GPG 公钥:</li></ol> 
<pre><code class="prism language-bash"><span class="token function">curl</span> https://packages.gitlab.com/gpg.key <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> /dev/null <span class="token operator">|</span> <span class="token function">sudo</span> apt-key <span class="token function">add</span> - <span class="token operator">&amp;&gt;</span>/dev/null  
</code></pre> 
<ol start="3"><li>配置镜像路径<br> 由于国外的下载速度过慢，所以配置清华大学镜像的路径。</li></ol> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">vi</span> /etc/apt/sources.list.d/gitlab-ce.list  
</code></pre> 
<p>在该文件中写入如下代码</p> 
<pre><code>deb https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu xenial main 
</code></pre> 
<ol start="4"><li>安装gitlab-ce</li></ol> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> gitlab-ce
</code></pre> 
<p>安装gitlab-ce成功之后。<br> 5. 修改外部url<br> 在gitlab配置文件/etc/gitlab/gitlab.rb中修改外部url，改为自己的ip地址或者域名。</p> 
<pre><code>sudo vi /etc/gitlab/gitlab.rb
</code></pre> 
<p>找到external_url，修改其默认的地址，这里改成了我本机局域网IP：<code>192.168.40.138</code></p> 
<pre><code class="prism language-bash">external_url <span class="token string">'http://192.168.40.138/'</span>  <span class="token comment">## 本机的局域网ip地址为192.168.41.128</span>
</code></pre> 
<ol start="6"><li>执行配置<br> 前面步骤顺利的话就可以执行配置了，该过程可能需要较长的时间。</li></ol> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> gitlab-ctl reconfigure
</code></pre> 
<ol start="7"><li>启动GitLab</li></ol> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> gitlab-ctl start
</code></pre> 
<p>可以通过<code>ps -ef|grep gitlab</code> 命令查看GitLab是否启动成功。<br> 8. 进行浏览器访问<br> GitLab成功启动之后就可以通过浏览器访问GitLab的主页了。在浏览器上输入<code>http://192.168.40.138/</code>;<br> <img src="https://images2.imgbox.com/61/e8/LtlTEtZt_o.png" alt="在这里插入图片描述"><br> 默认输入的用户名是root用户，输入的密码是root的账户密码。<br> 至此GitLab的安装就全部结束，我们也成功的搭建了属于自己的Git仓库。</p> 
<h4><a id="GitLab_181"></a>GitLab的使用</h4> 
<h5><a id="_182"></a>添加用户</h5> 
<p>点击设置按钮，进入设置栏，选中<code>Users-&gt;New User</code> 进入添加用户页面。<br> <img src="https://images2.imgbox.com/ab/0e/wN98YfcB_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7f/67/JsmWEKjl_o.png" alt="在这里插入图片描述"><br> 输入姓名，用户名，和邮箱即可注册添加新用户。</p> 
<h5><a id="_188"></a>添加团队</h5> 
<p>用户添加好之后，就是将用户添加到团队中，GitLab中默认会有一个名为GitLab Instance的团队，你也可以添加自己的团队，这里我添加了一个名为ai_edu的团队。并在团队中添加了两个成员。<br> <img src="https://images2.imgbox.com/d9/c6/Lc8H3hN9_o.png" alt="在这里插入图片描述"><br> 选中要添加成员的团队，在右侧会出现一个添加Add user(s) to the group的栏目。再此栏目中所有用户并添加到团队中。用户的角色有游客，测试人员，开发人员，管理者，拥有者等几个不同的角色。<br> <img src="https://images2.imgbox.com/04/2c/mnbqOAs5_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_193"></a>新建远程仓库</h5> 
<p>说完了用户和团队的设置后，现在就进入了重点了，如何新建一个远程仓库。同样也是比较方便。操作步骤是：<code>Project-&gt;Your projects-&gt;New project</code><br> <img src="https://images2.imgbox.com/d6/bb/MaE3ByeQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/61/b4/l4lBlYGS_o.png" alt="在这里插入图片描述"><br> 这里新建了一个名为git_test的远程仓库，仓库的所有这是属于ai_edu团队。<br> <img src="https://images2.imgbox.com/3f/7f/MKDFXSGD_o.png" alt="在这里插入图片描述"></p> 
<p>这里仓库的权限等级有三个等级，分别是：Private(只有你团队的人才能拉取和推送代码)，Internal（除了黑名单之外的用户可以拉取和推送代码）。Public （所有的用户都可以拉取）。</p> 
<h4><a id="SSH_key_201"></a>SSH key的配置（生成公钥和私钥）</h4> 
<p>为啥要配置SSH key呢？这是因为GitLab与你的电脑是通过SSH协议来通信的。说白了，如果你没有配置SSH key的话，则你不能推送代码到远程库。这里首先在你本地生成公钥和私钥文件，然后把公钥文件的内容复制到GitLab上。</p> 
<ol><li>配置用户名</li></ol> 
<pre><code class="prism language-bash"><span class="token function">git</span> config --global user.name “username”
</code></pre> 
<ol start="3"><li>配置邮箱</li></ol> 
<pre><code class="prism language-bash"> <span class="token function">git</span> config --global user.email  jayxiang31@gmail.com
</code></pre> 
<p>jayxiang31@gmail.com替换成你实际的邮箱地址。不需要加单引号。<br> 4. 生成公钥和私钥</p> 
<pre><code>ssh-keygen -C 'you email jayxiang31@gmail.com' -t rsa
</code></pre> 
<p>如果简单些的话可以直接填写<code>ssh-keygen </code> 命令。邮箱地址填写前面设置的邮箱地址。有提示的话一直按Enter键。正确执行后会输入如下信息<br> <img src="https://images2.imgbox.com/53/d0/B2fuZoUR_o.png" alt="在这里插入图片描述"></p> 
<p>2 找到公钥文件id_rsa.pub，复制公钥内容到GitLab<br> <img src="https://images2.imgbox.com/23/3d/9Yd5OmRm_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="6__225"></a>6. 分支管理</h2> 
<h3><a id="_226"></a>创建与合并分支</h3> 
<p>分支的概念：分支就是每次提交创建的点所连接成的时间线。这条时间线就是一个分支，默认的话只有一个主分支master分支。HEAD严格来说不是指向提交，而是指向master,master才是指向提交，HEAD指向的就是当前分支。<br> 一开始的时候，master分支就是一条线，Git用master指向最新的提交，再用HEAD指向master,就能够确定当前的分支以及当前分支的提交点。<br> 每次提交,master分支都会向前进移动一步，这样随着你不断提交，master分支的线也会越来越长。其结构如下图所示：<br> <img src="https://images2.imgbox.com/bd/00/Uark1Rmt_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="1_dev_232"></a>1. 创建dev分支</h5> 
<p>当我们新创建一个分支dev时，Git会创建一个指针dev指向master分支当前的提交点。当切换到dev分支后，HEAD指针会指向dev。也就是说<strong>HEAD始终是指向当前分支的</strong>。</p> 
<pre><code>git checkout -b dev
</code></pre> 
<p>git checkout 加上-b参数表示创建并切换到dev分支上，相当于下面两条命令。</p> 
<pre><code class="prism language-dev">$ git branch dev
$ git checkout dev
</code></pre> 
<p>执行该上面的命令之后的git的提交时间线如下图所示：<br> <img src="https://images2.imgbox.com/1c/1f/N8FKw39c_o.png" alt="在这里插入图片描述"><br> 当在dev分支上提交代码（未改变master分支）之后，dev分支会不断的向后推进。而master指针的指向则不会变。<br> <img src="https://images2.imgbox.com/15/a9/uUVNnlI4_o.png" alt="在这里插入图片描述"><br> <code>git checkout</code>命令是一个比较特殊的命令，传入不同的参数会有截然不同的效果。例如：<code>git checkout -- file</code> 命令，表示的意思是撤销file文件中所有的修改。所以Git还提供了<code>git switch</code>命令用于创建和切换分支。</p> 
<pre><code class="prism language-bash"><span class="token comment">## 创建并切换到新的dev分支</span>
<span class="token function">git</span> switch -c dev
<span class="token comment">## 切换到已有的master分支</span>
<span class="token function">git</span> switch master
</code></pre> 
<h5><a id="2__257"></a>2. 查看所有分支</h5> 
<p>分支创建好之后，可以通过<code>git branch</code>命令进行查看。</p> 
<h5><a id="3__259"></a>3. 分支合并</h5> 
<p>当团队成员在dev分支上开发完毕之后，就可以将dev分支上的内容合并到master分支上，合并分支的原理就是将master指针指向dev的当前提交。Git合并分支只是改了下指针，工作区的内容没有改变。<br> <img src="https://images2.imgbox.com/d6/d9/JiVSzAg0_o.png" alt="在这里插入图片描述"></p> 
<p>其合并的命令分两步，第一步是切换到master分支，第二步是合并dev分支</p> 
<pre><code class="prism language-bash"><span class="token comment">#切换到master分支</span>
<span class="token function">git</span> checkout master
<span class="token comment">#合并dev分支</span>
<span class="token function">git</span> merge dev
</code></pre> 
<p>通过merge合并的话会有两个分支路径，如果觉得这样不好看的话，可以通过rebase来合并</p> 
<pre><code class="prism language-bash"><span class="token comment">#切换到master分支</span>
<span class="token function">git</span> checkout master
<span class="token comment">#合并dev分支</span>
<span class="token function">git</span> rebase origin/dev
</code></pre> 
<p>这样同样可以将dev分支合并到master分支上。<br> 4. 删除dev分支<br> 现在dev分支的内容也合并到了master分支上了，可以将dev分支删除了。<strong>Git删除dev分支其实就是删除dev指针</strong>。删除之后又只剩下master分支了。需要注意的是必须要先切换到master分支上再进行删除dev分支的操作。删除dev分支的命令如下:</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> branch -d dev
</code></pre> 
<h3><a id="_285"></a>解决冲突</h3> 
<p>在团队协作过程中，难免会碰到各种修改冲突。那么该如何解决这些冲突呢? 例如：你和你同事分别修改了readme.txt文件，那么当你们同时提交时就会出现冲突。又或者在你在master分支和feature1分支上分别修改了readme.txt文件。那么当你合并feature1分支到master分支时就会出现冲突。举个栗子吧：</p> 
<ol><li>在feature1分支上给readme.txt文件中加上了文本<code>处理冲突</code>。然后提交到feature1分支。</li><li>切换到master分支，给readme.txt文件中加上文本</li></ol> 
<pre><code>冲突处理
master有冲突
</code></pre> 
<p>然后提交到master分支上。<br> 3. 将feature1分支合并到master分支，此时就会出现合并冲突。如下图所示：</p> 
<p>冲突之后，Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容。如下图所示：<br> 处理冲突的方式就是<strong>编辑冲突内容。然后重新提交。</strong></p> 
<pre><code>$ git add README.md
$ git commit -m "解决冲突"
</code></pre> 
<h3><a id="_302"></a>比较差异</h3> 
<ol><li>比较两个提交之间的差异 <code>git diff 36e4fd7 b55da38</code><br> <img src="https://images2.imgbox.com/b6/91/hA7Y6Hmb_o.png" alt="在这里插入图片描述"></li><li>比较工作区与仓库区的不同，HEAD表示最新的那次提交 <code>git diff HEAD</code></li></ol> 
<h3><a id="_306"></a>分支管理策略</h3> 
<p>通常情况下，Git在合并分支时，会使用Fast forward模式。但是，这种模式下，删除分支后，会丢掉分支信息。如下图所示，删除dev分支之后，分支的信息也就就丢失了</p> 
<p><img src="https://images2.imgbox.com/75/5c/lpi2SwQ4_o.png" alt="在这里插入图片描述"><br> 如果要强制禁用Fast forward模式，Git会在merge时生成一个新的commit。当删除分支时就不会丢失分支信息。其命令是<br> <code> git merge --no-ff -m "merge with no-ff" dev</code><br> 准备合并dev分支，其中<code>--no-ff</code>参数，表示禁用Fast forward,因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数。把commit描述写进去。</p> 
<h3><a id="Bug_313"></a>Bug分支</h3> 
<p>当你接到一个修复代号为01的bug的任务时，很自然地，你会创建一个分支issue-01来修复它，但是，如果这是你正在dev分支上进行的工作还没有提交,提交吧，可是你在dev上的工作只进行了一般，还没法提交，预计完成还需1天的时间。但是，现在必须要在两个小时内修复代号01的bug。这时候该怎么办呢？你不是期望有一个功能可以隐藏你当前在dev上未提交的工作，然后，切换到issue-01分支修改bug呢。<br> 通过stash功能可以满足你的愿望，将当前工作现场隐藏起来。如下图所示：执行<code>git stash</code>命令之后，新建的hello.html文件就从工作区中消失了。<br> <img src="https://images2.imgbox.com/b0/04/5PxcKvzV_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_317"></a>保存工作现场</h4> 
<pre><code class="prism language-bash"><span class="token function">git</span> stash
</code></pre> 
<p>git stash命令可以将当前未提交的工作隐藏起来。让你的工作区变的干净清爽。</p> 
<h4><a id="_323"></a>查看工作现场</h4> 
<p>git stash list 可以查看当前仓库所有已经保存的工作现场。</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> stash list
</code></pre> 
<h4><a id="_330"></a>恢复工作现场</h4> 
<p>现在代号为01的bug已经修复好了，你可以继续切换到dev分支上进行开发了。那么这时候你需要做的第一件事就是恢复之前保存的工作现场。恢复工作现场的命令是：</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> stash apply
</code></pre> 
<h4><a id="_336"></a>删除工作现场</h4> 
<p>通过<code>git stash apply</code> 命令可以恢复工作现场。但是，恢复之后工作现场还在。那么这时候我们还需要一个命令来删除工作现场。其命令是：</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> stash drop
</code></pre> 
<h4><a id="_343"></a>恢复并删除工作现场</h4> 
<p>恢复工作现场一条命令，删除工作现场又是一条命令。未免有点繁琐了吧。有没有将两者合二为一的命令呢?答案是有的：通过下面的命令就可以实现：</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> stash pop
</code></pre> 
<p>在master分支上修复了bug后，我们想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？这种方法也不是不行，如果该BUG涉及的修改过多，这样的方式就显得有点捉襟见肘了。那么我们能不能把修改BUG做的提交复制到当前的dev分支呢？答案是有的：</p> 
<h4><a id="_350"></a>合并某一次的提交</h4> 
<pre><code class="prism language-bash"><span class="token function">git</span> cherry-pick  821ea4d
</code></pre> 
<p>通过<code>git cherry-pick</code> 命令可以将单个的提交复制到当前分支。可以通过 git log 查看提交的提交的版本号。</p> 
<h3><a id="feature_355"></a>feature分支</h3> 
<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。<br> 前面介绍可以通过<code>git branch -d branchname</code> 命令删除分支。但是，如果被删除的分支还没有合并到主分支的话，用该命令删除的话分支的话，Git会抛出一个错误提示并不能删除该分支。如下：要删除一个名为feature-01的分支。但是该分支还没有被merge。这时候就需要强制删除分支的命令了。</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> branch -D feature-01
</code></pre> 
<p>其中feature-01为待删除的分支名。其实就是将<code>-d</code>参数换成<code>-D</code>参数。</p> 
<h3><a id="_362"></a>远程仓库（多人协作）</h3> 
<p>前面说了那么多，好像都是一个人在本地操作，没有涉及到多人协作的情况。这在团队开发中肯定是不可能的啦，因为我们是一个team。那么多人协作的情况涉及哪些操作呢？</p> 
<h4><a id="_364"></a>本地仓库关联远程仓库</h4> 
<pre><code class="prism language-bash"><span class="token function">git</span> remote <span class="token function">add</span> origin http://192.168.40.138/ai-edu/git-demo.git
</code></pre> 
<p>或者，推荐使用下面这种，因为前面配置了SSH公钥和私钥</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> remote <span class="token function">add</span> origin git@gitee.com:jayxiang31/python_learn.git
</code></pre> 
<h4><a id="READMEmdgitignore_375"></a>第一次先拉取远程库中的README.md和.gitignore等文件</h4> 
<pre><code>git pull --rebase origin master
</code></pre> 
<h4><a id="_380"></a>克隆远程仓库</h4> 
<p>前面第三章已经搭好了私有的Git仓库管理器GitLab。同时也创建了一个名为git_test的仓库。现在要做的就是将远程仓库克隆下来。克隆的命令是<code>git clone</code></p> 
<pre><code class="prism language-bash"><span class="token function">git</span> clone http://192.168.40.138/ai-edu/git_test.git
</code></pre> 
<p>其中<code>http://192.168.40.138/ai-edu/git_test.git</code> 是远程仓库的地址。<br> 当然也可以在IDEA上直接通过图形界面操作，还省去了导入项目的过程。其操作步骤是:</p> 
<ol><li>选中<code>File-&gt;New-&gt;Project from Version Control-&gt;Git</code>。如下图所示：<br> <img src="https://images2.imgbox.com/40/6f/r6RB5rQU_o.png" alt="在这里插入图片描述"></li><li>在URL中填入远程仓库的地址，点击Clone按钮。如下图所示：<br> <img src="https://images2.imgbox.com/27/5d/YZAQBLo4_o.png" alt="在这里插入图片描述"><br> <strong>需要注意的是默认情况下只会克隆master分支，其他的分支不会被克隆下来。其他的分支需要通过git pull命令拉取，后面会详细介绍。</strong></li></ol> 
<h4><a id="Git_393"></a>删除远程Git仓库</h4> 
<pre><code class="prism language-bash"> <span class="token function">git</span> remote <span class="token function">rm</span> origin
</code></pre> 
<h4><a id="_398"></a>查看远程分支</h4> 
<p>通过<code>git remote</code>命令可以查看远程仓库，origin表示远程主机。<br> 通过<code>git remote -v</code> 命令可以查看远程仓库详细的信息，包括远程仓库的地址。</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> remote -v
origin  http://192.168.40.138/ai-edu/git_test.git <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>
origin  http://192.168.40.138/ai-edu/git_test.git <span class="token punctuation">(</span>push<span class="token punctuation">)</span>
</code></pre> 
<p>上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</p> 
<h4><a id="_408"></a>推送分支</h4> 
<p>现在将远程仓库克隆下来了，那么该如何将当前分支上所有的本地提交推送到远程库呢？答案是通过<code>git push</code>命令，其语法结构是<code>git push &lt;remote branch&gt; &lt;local branch&gt;</code> 其中<code>&lt;remote branch&gt;</code>表示远程分支名，<code>&lt;local branch&gt;</code>表示本地分支名。</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> push origin master
</code></pre> 
<p>该语句表示将本地的master分支推送到远程的origin分支上。在实际应用中会在<code>git push</code>命令后面加上<code>-u</code>参数，就像<code>git push -u origin master</code>这样。这是因为如果当前分支与多个主机存在追踪关系，则可以使用 -u 参数指定一个默认主机，这样后面就可以不加任何参数使用git push。那么哪些分支该与远程分支保持一致呢？一般认为：</p> 
<ol><li>master 分支是主分支，需要时时与远程同步</li><li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。<br> 说白了就是需要团队协作的分支一定要推送到远程库，否则则不需要。</li></ol> 
<h4><a id="_420"></a>创建远程分支</h4> 
<p>通过<code>git push</code>命令还能创建远程分支。</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> push origin dev
</code></pre> 
<p>假设你本地已经有了dev分支。通过上面的命令可以将dev分支推送到远程库，并创建远程的dev分支。</p> 
<h4><a id="_426"></a>拉取分支</h4> 
<p>通过<code>git pull</code>命令可以拉取远程仓库的数据和分支信息。假设如下这个场景：你同事在他本地创建了一个dev分支，并提交到了远程库。同时你也在本地创建了一个dev库，当你push时会推送失败。结果如下图所示：</p> 
<p>因为你同事的最新提交和你试图推送的的提交有冲突。解决的办法就是根据Git的提示，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突后，在推送。</p> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> pull
There is no tracking information <span class="token keyword">for</span> the current branch.
Please specify <span class="token function">which</span> branch you want to merge with.
See git-pull<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> details.

    <span class="token function">git</span> pull <span class="token operator">&lt;</span>remote<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>branch<span class="token operator">&gt;</span>

If you wish to <span class="token builtin class-name">set</span> tracking information <span class="token keyword">for</span> this branch you can <span class="token keyword">do</span> so with:

    <span class="token function">git</span> branch --set-upstream-to<span class="token operator">=</span>origin/<span class="token operator">&lt;</span>branch<span class="token operator">&gt;</span> dev
</code></pre> 
<p><code>git pull</code>也失败了。原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：</p> 
<h4><a id="_444"></a>关联本地分支和远程分支</h4> 
<pre><code class="prism language-bash">$ <span class="token function">git</span> branch --set-upstream-to<span class="token operator">=</span>origin/dev dev
Branch <span class="token string">'dev'</span> <span class="token builtin class-name">set</span> up to track remote branch <span class="token string">'dev'</span> from <span class="token string">'origin'</span><span class="token builtin class-name">.</span>
</code></pre> 
<p>关联好本地分支和远程分支之后，在pull就能成功了。这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方式也是在本地手动处理冲突文件，解决后，提交，在push。</p> 
<h4><a id="_452"></a>拉取远程分支并创建本地分支</h4> 
<pre><code class="prism language-bash"><span class="token function">git</span> checkout -b 本地分支名x origin/远程分支名x
</code></pre> 
<p>该命令会在本地新建分支x，并自动切换到该本地分支x。<br> 采用此种方法建立的本地分支会和远程分支建立映射关系。<br> 例如：</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> checkout -b dev origin/dev
</code></pre> 
<h4><a id="_462"></a>删除远程分支</h4> 
<p>通过</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> push origin :dev
</code></pre> 
<p>命令可以删除远程dev分支。但是这时候本地的dev分支还是存在的。所以还需要通过<code>git branch -d dev</code>删除本地的dev分支。</p> 
<h4><a id="_470"></a>查看分支</h4> 
<p>通过<code>git branch</code>可以查看本地分支<br> 通过<code>git branch -a</code> 可以查看本地分支和远程分支。<br> <img src="https://images2.imgbox.com/37/55/TwDBIRos_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_474"></a>版本回退</h4> 
<p>在实际开发中我们经常会碰到这样一个场景，比如：你误提交了一段有问题的代码，导致其他同事更新代码之后项目启动不了，这时候该怎么办呢？我们首先想到的就是将版本回退。回退到之前那个没有问题的版本。</p> 
<ol><li>通过<code>git log</code> 命令找到当前的仓库所有的提交日志。然后，找到你需要回退到的版本。如下图所示：</li><li>回退到上一个版本：<code>git reset HEAD</code></li><li>回退到指定版本：<code>git reset commitId</code> 其中commitId是指定版本的版本号，比如这里将版本信息回退到<code>b50c9bdcbf9641d33e4b531bd96dc1f27d4bf602</code> 这个版本。那么命令就是:</li></ol> 
<pre><code class="prism language-bash"><span class="token function">git</span> reset b50c9bdcbf9641d33e4b531bd96dc1f27d4bf602
</code></pre> 
<p>回退之后，再次通过<code>git log</code>查看，则最新的提交日志已经变成了<code>hello 提交</code>这个版本了。<br> 当然，通过IDEA来回退则更加的简单。直接在<code>Version Control-&gt;Log</code> 在待回退到的版本上右键，选中<code>Reset Current Branch to Here</code> 即可。<br> <img src="https://images2.imgbox.com/de/7f/DCzxXTsS_o.png" alt="在这里插入图片描述"><br> 其实回退操作的本质，就是将HEAD指针的指向要回退的那个版本上。</p> 
<h4><a id="_487"></a>将多次提交合并成一次提交</h4> 
<p>在实际开发中我们经常需要进行代码Review。如果同一个功能点分了很多次提交话，那么在进行代码Review时则会非常的不方便。这时候就需要将多次提交合并成一次提交。具体的步骤是：</p> 
<ol><li>通过<code>git switch &lt;branchname&gt;</code>命令切换到需要合并提交的代码的分支，比如：<code>git switch test</code></li><li>查看需要合并的提交，如下有三次提交需要合并<br> <img src="https://images2.imgbox.com/30/87/WzqUZlpz_o.png" alt="在这里插入图片描述"></li><li>通过rebase命令修改提交指令，这里<code>git rebase -i HEAD~3</code> 表示查看最近的三次提交命令，合并几次则需要将对应的数字改成几。</li></ol> 
<pre><code class="prism language-bash"><span class="token function">git</span> rebase -i HEAD~3
</code></pre> 
<p>执行该命令之后会打开提交指令的日志文件，这里只保留第一次的提交，将另外的两次提交改成 s<br> <img src="https://images2.imgbox.com/11/cc/K473Sqgk_o.png" alt="在这里插入图片描述"><br> 保存之后会进入另外一个文件，该文件无需修改，直接输入<code>:q!</code> 命令退出即可。操作之后我们可以看到之前的三次提交记录变成了一次提交记录。<br> <img src="https://images2.imgbox.com/2d/ba/tC7v00El_o.png" alt="在这里插入图片描述"><br> 4. 如何要把这次提交合并到其他分支只需要切换到目标分支，执行如下命令;</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> cherry-pick <span class="token operator">&lt;</span>commitid<span class="token operator">&gt;</span>
</code></pre> 
<h4><a id="_505"></a>分支重命名</h4> 
<pre><code class="prism language-bash"><span class="token function">git</span> branch -m oldname newname
</code></pre> 
<h3><a id="7__509"></a>7. 标签管理</h3> 
<p>标签管理比较简单，再此只是简单描述一下。</p> 
<pre><code class="prism language-bash"><span class="token comment">#创建标签 v1.0</span>
<span class="token function">git</span> tag v1.0
<span class="token comment">#查看标签</span>
<span class="token function">git</span> tag
<span class="token comment">#删除标签v1.0</span>
<span class="token function">git</span> tag -d v0.1
<span class="token comment">#*****还可以加上-a参数来创建一个带备注的tag，备注信息由-m指定。如果你未传入-m则创建过程系统会自动为你打开编辑器让你填写备注信息。</span>
<span class="token function">git</span> tag -a v1.0 -m <span class="token string">"这是第一次发版"</span>
<span class="token comment">#推送标签</span>
<span class="token function">git</span> push origin --tags
<span class="token comment">#删除远程标签</span>
<span class="token function">git</span> push origin :refs/tags/v1.0

</code></pre> 
<h4><a id="_527"></a>回滚某次提交</h4> 
<p>回滚本地仓库的某次提交，回滚的命令是</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> revert <span class="token operator">&lt;</span>subcommand<span class="token operator">&gt;</span>
</code></pre> 
<p>例如：本次提交的commandId 是311737d3</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> revert 311737d3
</code></pre> 
<h3><a id="_537"></a>总结</h3> 
<p>一万六千多字，我写的累，你们看的也累！！！文中奉上几张美女照片给各位读者大大解解乏。我真真正正的肝了两天了。现在终于肝完了。希望对读者朋友们有所帮助。<br> 看文字实在是太累了。下面就用一张图来做一个总结吧。<br> <img src="https://images2.imgbox.com/d0/36/p2rF3kWp_o.png" alt="在这里插入图片描述"><br> 这张图清晰的表明了Git的基本流程。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c14858df96022b6d6010c1b786cbb74f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">win10应用商店怎么重新安装？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a49f5c4aad4778f33541df6bdd9cb167/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一文了解异步编程基础</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>