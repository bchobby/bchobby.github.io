<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TypeScript的特性 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TypeScript的特性" />
<meta property="og:description" content="什么是TypeScript 从 TypeScript 的名字就可以看出来，「类型」是其最核心的特性。
我们知道，JavaScript 是一门非常灵活的编程语言：
它没有类型约束，一个变量可能初始化时是字符串，过一会儿又被赋值为数字。由于隐式类型转换的存在，有的变量的类型很难在运行前就确定。基于原型的面向对象编程，使得原型上的属性或方法可以在运行时被修改。函数是 JavaScript 中的一等公民[2]，可以赋值给变量，也可以当作参数或返回值。 这种灵活性就像一把双刃剑，一方面使得 JavaScript 蓬勃发展，无所不能，从 2013 年开始就一直蝉联最普遍使用的编程语言排行榜冠军[3]；另一方面也使得它的代码质量参差不齐，维护成本高，运行时错误多。
而 TypeScript 的类型系统，在很大程度上弥补了 JavaScript 的缺点。
TypeScript 是静态类型 TypeScript 是弱类型 类型系统按照「类型检查的时机」来分类，可以分为动态类型和静态类型。
TypeScript 是完全兼容 JavaScript 的，它不会修改 JavaScript 运行时的特性，所以它们都是弱类型。
什么是 TypeScript？ TypeScript 是添加了类型系统的 JavaScript，适用于任何规模的项目。 TypeScript 是一门静态类型、弱类型的语言。 TypeScript 是完全兼容 JavaScript 的，它不会修改 JavaScript 运行时的特性。 TypeScript 可以编译为 JavaScript，然后运行在浏览器、Node.js 等任何能运行 JavaScript 的环境中。 TypeScript 拥有很多编译选项，类型检查的严格程度由你决定。 TypeScript 可以和 JavaScript 共存，这意味着 JavaScript 项目能够渐进式的迁移到 TypeScript。 TypeScript 增强了编辑器（IDE）的功能，提供了代码补全、接口提示、跳转到定义、代码重构等能力。 TypeScript 拥有活跃的社区，大多数常用的第三方库都提供了类型声明。 TypeScript 与标准同步发展，符合最新的 ECMAScript 标准（stage 3）。 TypeScript2012-10 :微软发布了TypeScript第一个版本（0.8），从此已经在微软内部开发了两年" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/c334fad7f0ebb5fe3dfd01f2e35957df/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-11T20:25:11+08:00" />
<meta property="article:modified_time" content="2021-10-11T20:25:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TypeScript的特性</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3></h3> 
<h2>什么是TypeScript</h2> 
<p>从 TypeScript 的名字就可以看出来，「类型」是其最核心的特性。</p> 
<p>我们知道，JavaScript 是一门非常灵活的编程语言：</p> 
<ul><li>它没有类型约束，一个变量可能初始化时是字符串，过一会儿又被赋值为数字。</li><li>由于隐式类型转换的存在，有的变量的类型很难在运行前就确定。</li><li>基于原型的面向对象编程，使得原型上的属性或方法可以在运行时被修改。</li><li>函数是 JavaScript 中的一等公民<a href="http://ts.xcatliu.com/introduction/what-is-typescript.html#link-2" rel="nofollow" title="[2]">[2]</a>，可以赋值给变量，也可以当作参数或返回值。</li></ul> 
<p>这种灵活性就像一把双刃剑，一方面使得 JavaScript 蓬勃发展，无所不能，从 2013 年开始就一直蝉联最普遍使用的编程语言排行榜冠军<a href="http://ts.xcatliu.com/introduction/what-is-typescript.html#link-3" rel="nofollow" title="[3]">[3]</a>；另一方面也使得它的代码质量参差不齐，维护成本高，运行时错误多。</p> 
<p>而 TypeScript 的类型系统，在很大程度上弥补了 JavaScript 的缺点。</p> 
<h3>TypeScript 是静态类型    TypeScript 是弱类型</h3> 
<p>类型系统按照「类型检查的时机」来分类，可以分为动态类型和静态类型。</p> 
<p>TypeScript 是完全兼容 JavaScript 的，它不会修改 JavaScript 运行时的特性，所以<strong>它们都是弱类型</strong>。</p> 
<h3></h3> 
<h4>什么是 TypeScript？</h4> 
<ul><li> <h4>TypeScript 是添加了类型系统的 JavaScript，适用于任何规模的项目。</h4> </li><li> <h4>TypeScript 是一门静态类型、弱类型的语言。</h4> </li><li> <h4>TypeScript 是完全兼容 JavaScript 的，它不会修改 JavaScript 运行时的特性。</h4> </li><li> <h4>TypeScript 可以编译为 JavaScript，然后运行在浏览器、Node.js 等任何能运行 JavaScript 的环境中。</h4> </li><li> <h4>TypeScript 拥有很多编译选项，类型检查的严格程度由你决定。</h4> </li><li> <h4>TypeScript 可以和 JavaScript 共存，这意味着 JavaScript 项目能够渐进式的迁移到 TypeScript。</h4> </li><li> <h4>TypeScript 增强了编辑器（IDE）的功能，提供了代码补全、接口提示、跳转到定义、代码重构等能力。</h4> </li><li> <h4>TypeScript 拥有活跃的社区，大多数常用的第三方库都提供了类型声明。</h4> </li><li> <h4>TypeScript 与标准同步发展，符合最新的 ECMAScript 标准（stage 3）。</h4> </li></ul> 
<p>TypeScript2012-10 :微软发布了TypeScript第一个版本（0.8），从此已经在微软内部开发了两年</p> 
<h2>安装 TypeScript</h2> 
<pre><code>npm install -g typescript</code></pre> 
<h2> 1.原始数据类型、</h2> 
<p>JavaScript 的类型分为两种：原始数据类型（<a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" rel="nofollow" title="Primitive data types">Primitive data types</a>）和对象类型（Object types）。</p> 
<p>原始数据类型包括：布尔值、数值、字符串、<code>null</code>、<code>undefined</code> 以及 ES6 中的新类型 <a href="http://es6.ruanyifeng.com/#docs/symbol" rel="nofollow" title="Symbol">Symbol</a> 和 ES10 中的新类型 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt" rel="nofollow" title="BigInt">BigInt</a>。</p> 
<h3 id="%E5%B8%83%E5%B0%94%E5%80%BC">布尔值：</h3> 
<pre><code>let isDone: boolean = false;</code></pre> 
<p>注意，使用构造函数 <code>Boolean</code> 创造的对象<strong>不是</strong>布尔值：</p> 
<pre><code>let createdByNewBoolean: boolean = new Boolean(1);

// Type 'Boolean' is not assignable to type 'boolean'.
//   'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possib</code></pre> 
<h3> 数值：</h3> 
<p>使用 <code>number</code> 定义数值类型：</p> 
<pre><code>let decLiteral: number = 6;
let hexLiteral: number = 0xf00d;
// ES6 中的二进制表示法
let binaryLiteral: number = 0b1010;
// ES6 中的八进制表示法
let octalLiteral: number = 0o744;
let notANumber: number = NaN;
let infinityNumber: number = Infinity;</code></pre> 
<h3> 字符串：</h3> 
<p>使用 <code>string</code> 定义字符串类型：</p> 
<pre><code>let myName: string = 'Tom';
let myAge: number = 25;

// 模板字符串
let sentence: string = `Hello, my name is ${myName}.
I'll be ${myAge + 1} years old next month.`;</code></pre> 
<h3> 空值：JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 <code>void</code> 表示没有任何返回值的函数：</h3> 
<pre><code>function alertName(): void {
    alert('My name is Tom');
}</code></pre> 
<p> </p> 
<h3 id="null-%E5%92%8C-undefined">Null 和 Undefined<a href="http://ts.xcatliu.com/basics/primitive-data-types.html#null-%E5%92%8C-undefined" rel="nofollow" title="§">§</a></h3> 
<p>在 TypeScript 中，可以使用 <code>null</code> 和 <code>undefined</code> 来定义这两个原始数据类型：</p> 
<pre><code>let u: undefined = undefined;
let n: null = null;</code></pre> 
<h2> 1.任意值</h2> 
<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%BB%E6%84%8F%E5%80%BC%E7%B1%BB%E5%9E%8B">什么是任意值类型？</h3> 
<p>如果是一个普通类型，在赋值过程中改变类型是不被允许的：</p> 
<pre><code>let myFavoriteNumber: string = 'seven';
myFavoriteNumber = 7;

// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.
</code></pre> 
<p>但如果是 <code>any</code> 类型，则允许被赋值为任意类型。</p> 
<pre><code>let myFavoriteNumber: any = 'seven';
myFavoriteNumber = 7;</code></pre> 
<p> </p> 
<h3 id="%E4%BB%BB%E6%84%8F%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">任意值的属性和方法<a href="http://ts.xcatliu.com/basics/any.html#%E4%BB%BB%E6%84%8F%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95" rel="nofollow" title="§">§</a></h3> 
<p>在任意值上访问任何属性都是允许的：</p> 
<pre><code>let anyThing: any = 'hello';
console.log(anyThing.myName);
console.log(anyThing.myName.firstName);
</code></pre> 
<p>也允许调用任何方法：</p> 
<pre><code>let anyThing: any = 'Tom';
anyThing.setName('Jerry');
anyThing.setName('Jerry').sayHello();
anyThing.myName.setFirstName('Cat');
</code></pre> 
<p>可以认为，<strong>声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</strong>。</p> 
<p> </p> 
<h3 id="%E6%9C%AA%E5%A3%B0%E6%98%8E%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F">未声明类型的变量<a href="http://ts.xcatliu.com/basics/any.html#%E6%9C%AA%E5%A3%B0%E6%98%8E%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F" rel="nofollow" title="§">§</a></h3> 
<p><strong>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型</strong></p> 
<pre><code>let something;
something = 'seven';
something = 7;

something.setName('Tom');
</code></pre> 
<p>等价于</p> 
<pre><code>let something: any;
something = 'seven';
something = 7;

something.setName('Tom');</code></pre> 
<p> </p> 
<h2>3.类型推论</h2> 
<p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</p> 
<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA">什么是类型推论<a href="http://ts.xcatliu.com/basics/type-inference.html#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA" rel="nofollow" title="§">§</a></h3> 
<p>以下代码虽然没有指定类型，但是会在编译的时候报错：</p> 
<pre><code>let myFavoriteNumber = 'seven';
myFavoriteNumber = 7;

// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.
</code></pre> 
<p>事实上，它等价于：</p> 
<pre><code>let myFavoriteNumber: string = 'seven';
myFavoriteNumber = 7;

// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.</code></pre> 
<p> </p> 
<p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 <code>any</code> 类型而完全不被类型检查</strong>：</p> 
<pre><code>let myFavoriteNumber;
myFavoriteNumber = 'seven';
myFavoriteNumber = 7;</code></pre> 
<h2>4.联合类型</h2> 
<p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p> 
<p> </p> 
<h3 id="%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90">简单的例子<a href="http://ts.xcatliu.com/basics/union-types.html#%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90" rel="nofollow" title="§">§</a></h3> 
<pre><code>let myFavoriteNumber: string | number;
myFavoriteNumber = 'seven';
myFavoriteNumber = 7;
</code></pre> 
<pre><code>let myFavoriteNumber: string | number;
myFavoriteNumber = true;</code></pre> 
<h3> 访问联合类型的属性或方法</h3> 
<p>我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong>：</p> 
<pre><code>function getLength(something: string | number): number {
    return something.length;
}</code></pre> 
<h2> 5.对象的类型——接口</h2> 
<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3">什么是接口<a href="http://ts.xcatliu.com/basics/type-of-object-interfaces.html#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3" rel="nofollow" title="§">§</a></h3> 
<p>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。</p> 
<h3>简单的例子<a href="http://ts.xcatliu.com/basics/type-of-object-interfaces.html#%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90" rel="nofollow" title="§">§</a></h3> 
<pre><code>interface Person {
    name: string;
    age: number;
}

let tom: Person = {
    name: 'Tom',
    age: 25
};</code></pre> 
<p> </p> 
<h3 id="%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7">可选属性<a href="http://ts.xcatliu.com/basics/type-of-object-interfaces.html#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7" rel="nofollow" title="§">§</a></h3> 
<p>有时我们希望不要完全匹配一个形状，那么可以用可选属性：</p> 
<pre><code>interface Person {
    name: string;
    age?: number;
}

let tom: Person = {
    name: 'Tom'
};
</code></pre> 
<pre><code>interface Person {
    name: string;
    age?: number;
}

let tom: Person = {
    name: 'Tom',
    age: 25
};</code></pre> 
<p> </p> 
<h3 id="%E4%BB%BB%E6%84%8F%E5%B1%9E%E6%80%A7">任意属性<a href="http://ts.xcatliu.com/basics/type-of-object-interfaces.html#%E4%BB%BB%E6%84%8F%E5%B1%9E%E6%80%A7" rel="nofollow" title="§">§</a></h3> 
<p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式：</p> 
<pre><code>interface Person {
    name: string;
    age?: number;
    [propName: string]: any;
}

let tom: Person = {
    name: 'Tom',
    gender: 'male'
};</code></pre> 
<p> 需要注意的是，<strong>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</strong>：</p> 
<pre><code>interface Person {
    name: string;
    age?: number;
    [propName: string]: string;
}

let tom: Person = {
    name: 'Tom',
    age: 25,
    gender: 'male'
};</code></pre> 
<p> </p> 
<h3 id="%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7">只读属性<a href="http://ts.xcatliu.com/basics/type-of-object-interfaces.html#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7" rel="nofollow" title="§">§</a></h3> 
<p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 <code>readonly</code> 定义只读属性：</p> 
<pre><code>interface Person {
    readonly id: number;
    name: string;
    age?: number;
    [propName: string]: any;
}

let tom: Person = {
    id: 89757,
    name: 'Tom',
    gender: 'male'
};</code></pre> 
<p> </p> 
<p><strong>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</strong>：</p> 
<pre><code>interface Person {
    readonly id: number;
    name: string;
    age?: number;
    [propName: string]: any;
}

let tom: Person = {
    name: 'Tom',
    gender: 'male'
};

tom.id = 89757;
</code></pre> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e0d2f9a88d2d4a60ce4ab45ff81b15d5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nginx通过虚拟主机功能，实现反向代理多个Tomcat服务</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1a771a5a47b33afded8f5833cbb5484d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">latex使用笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>