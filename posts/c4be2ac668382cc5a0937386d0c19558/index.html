<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【翻译】Graphlib API 指南 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【翻译】Graphlib API 指南" />
<meta property="og:description" content="github - raphlib
文章目录 安装npm Install 介绍API 指南图像概念展现节点和边线Multigraphs复合图默认标签Graph APIgraph.isDirected()graph.isMultigraph()graph.isCompound()graph.graph()graph.setGraph(label)graph.nodeCount()graph.edgeCount()graph.setDefaultNodeLabel(val)graph.setDefaultEdgeLabel(val)graph.nodes()graph.edges()graph.sources()graph.sinks()graph.hasNode(v)graph.node(v)graph.setNode(v, [label])graph.removeNode(v)graph.predecessors(v)graph.successors(v)graph.neighbors(v)graph.inEdges(v, [u])graph.outEdges(v, [w])graph.nodeEdges(v, [w])graph.parent(v)graph.children(v)graph.setParent(v, parent)graph.hasEdge(v, w, [name]) / graph.hasEdge(edgeObj)graph.edge(v, w, [name]) / graph.edge(edgeObj)graph.setEdge(v, w, [label], [name]) / graph.setEdge(edgeObj, [label])graph.removeEdge(v, w, [name]) 序列化json.write(g)json.read(json) 算法alg.components(graph)alg.dijkstra(graph, source, weightFn, edgeFn)alg.dijkstraAll(graph, weightFn, edgeFn)alg.findCycles(graph)alg.isAcyclic(graph)alg.postorder(graph, vs)alg.preorder(graph, vs)alg.prim(graph, weightFn)alg.tarjan(graph)alg.topsort(graph) 安装 npm Install $ npm install @dagrejs/graphlib 介绍 Graphlib是一个JavaScript Lib库，为无向和有向多变图提供数据结构，以及可以一起使用的算法。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7YWcTEXZ-1648378764148)(https://secure.travis-ci.org/dagrejs/graphlib.svg)]
更多学习内容, 查看wiki。
API 指南 本部分主要阐述graphlib的概念并提供API指南。默认情况下，graphlib函数和对象暴露在graphlib的命名空间下。
图像概念 Graphlib有一种图类型: Graph。
创建一个新的实例:
var g = new Graph(); 默认情况下，将会创建一个不允许多边或者复合节点的有向图。以下则是参数选项:
directed:设置为true时, 得到一个有向图。false时, 得到一个无向图。无向图不会把节点的顺序视为第一要务。换句话说, 对无向图来说g." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/c4be2ac668382cc5a0937386d0c19558/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-27T19:03:36+08:00" />
<meta property="article:modified_time" content="2022-03-27T19:03:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【翻译】Graphlib API 指南</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><a href="https://github.com/fwx5618177/graphlib">github - raphlib</a></p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_3" rel="nofollow">安装</a></li><li><ul><li><a href="#npm_Install_4" rel="nofollow">npm Install</a></li></ul> 
  </li><li><a href="#_9" rel="nofollow">介绍</a></li><li><a href="#API__16" rel="nofollow">API 指南</a></li><li><a href="#_19" rel="nofollow">图像概念</a></li><li><a href="#_35" rel="nofollow">展现节点和边线</a></li><li><a href="#Multigraphs_65" rel="nofollow">Multigraphs</a></li><li><a href="#_102" rel="nofollow">复合图</a></li><li><a href="#_116" rel="nofollow">默认标签</a></li><li><a href="#Graph_API_121" rel="nofollow">Graph API</a></li><li><ul><li><a href="#graphisDirected_123" rel="nofollow">graph.isDirected()</a></li><li><a href="#graphisMultigraph_139" rel="nofollow">graph.isMultigraph()</a></li><li><a href="#graphisCompound_142" rel="nofollow">graph.isCompound()</a></li><li><a href="#graphgraph_145" rel="nofollow">graph.graph()</a></li><li><a href="#graphsetGraphlabel_155" rel="nofollow">graph.setGraph(label)</a></li><li><a href="#graphnodeCount_158" rel="nofollow">graph.nodeCount()</a></li><li><a href="#graphedgeCount_161" rel="nofollow">graph.edgeCount()</a></li><li><a href="#graphsetDefaultNodeLabelval_164" rel="nofollow">graph.setDefaultNodeLabel(val)</a></li><li><a href="#graphsetDefaultEdgeLabelval_169" rel="nofollow">graph.setDefaultEdgeLabel(val)</a></li><li><a href="#graphnodes_174" rel="nofollow">graph.nodes()</a></li><li><a href="#graphedges_178" rel="nofollow">graph.edges()</a></li><li><a href="#graphsources_182" rel="nofollow">graph.sources()</a></li><li><a href="#graphsinks_185" rel="nofollow">graph.sinks()</a></li><li><a href="#graphhasNodev_188" rel="nofollow">graph.hasNode(v)</a></li><li><a href="#graphnodev_191" rel="nofollow">graph.node(v)</a></li><li><a href="#graphsetNodev_label_194" rel="nofollow">graph.setNode(v, [label])</a></li><li><a href="#graphremoveNodev_199" rel="nofollow">graph.removeNode(v)</a></li><li><a href="#graphpredecessorsv_203" rel="nofollow">graph.predecessors(v)</a></li><li><a href="#graphsuccessorsv_206" rel="nofollow">graph.successors(v)</a></li><li><a href="#graphneighborsv_209" rel="nofollow">graph.neighbors(v)</a></li><li><a href="#graphinEdgesv_u_212" rel="nofollow">graph.inEdges(v, [u])</a></li><li><a href="#graphoutEdgesv_w_218" rel="nofollow">graph.outEdges(v, [w])</a></li><li><a href="#graphnodeEdgesv_w_223" rel="nofollow">graph.nodeEdges(v, [w])</a></li><li><a href="#graphparentv_228" rel="nofollow">graph.parent(v)</a></li><li><a href="#graphchildrenv_233" rel="nofollow">graph.children(v)</a></li><li><a href="#graphsetParentv_parent_238" rel="nofollow">graph.setParent(v, parent)</a></li><li><a href="#graphhasEdgev_w_name__graphhasEdgeedgeObj_243" rel="nofollow">graph.hasEdge(v, w, [name]) / graph.hasEdge(edgeObj)</a></li><li><a href="#graphedgev_w_name__graphedgeedgeObj_248" rel="nofollow">graph.edge(v, w, [name]) / graph.edge(edgeObj)</a></li><li><a href="#graphsetEdgev_w_label_name__graphsetEdgeedgeObj_label_254" rel="nofollow">graph.setEdge(v, w, [label], [name]) / graph.setEdge(edgeObj, [label])</a></li><li><a href="#graphremoveEdgev_w_name_260" rel="nofollow">graph.removeEdge(v, w, [name])</a></li></ul> 
  </li><li><a href="#_266" rel="nofollow">序列化</a></li><li><ul><li><a href="#jsonwriteg_267" rel="nofollow">json.write(g)</a></li><li><a href="#jsonreadjson_294" rel="nofollow">json.read(json)</a></li></ul> 
  </li><li><a href="#_307" rel="nofollow">算法</a></li><li><ul><li><a href="#algcomponentsgraph_308" rel="nofollow">alg.components(graph)</a></li><li><a href="#algdijkstragraph_source_weightFn_edgeFn_322" rel="nofollow">alg.dijkstra(graph, source, weightFn, edgeFn)</a></li><li><a href="#algdijkstraAllgraph_weightFn_edgeFn_354" rel="nofollow">alg.dijkstraAll(graph, weightFn, edgeFn)</a></li><li><a href="#algfindCyclesgraph_391" rel="nofollow">alg.findCycles(graph)</a></li><li><a href="#algisAcyclicgraph_421" rel="nofollow">alg.isAcyclic(graph)</a></li><li><a href="#algpostordergraph_vs_442" rel="nofollow">alg.postorder(graph, vs)</a></li><li><a href="#algpreordergraph_vs_457" rel="nofollow">alg.preorder(graph, vs)</a></li><li><a href="#algprimgraph_weightFn_471" rel="nofollow">alg.prim(graph, weightFn)</a></li><li><a href="#algtarjangraph_489" rel="nofollow">alg.tarjan(graph)</a></li><li><a href="#algtopsortgraph_508" rel="nofollow">alg.topsort(graph)</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_3"></a>安装</h2> 
<h3><a id="npm_Install_4"></a>npm Install</h3> 
<pre><code class="prism language-shell">$ <span class="token function">npm</span> <span class="token function">install</span> @dagrejs/graphlib
</code></pre> 
<h2><a id="_9"></a>介绍</h2> 
<p><code>Graphlib</code>是一个JavaScript Lib库，为无向和有向多变图提供数据结构，以及可以一起使用的算法。</p> 
<p><a href="http://travis-ci.org/dagrejs/graphlib" rel="nofollow">[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7YWcTEXZ-1648378764148)(https://secure.travis-ci.org/dagrejs/graphlib.svg)]</a></p> 
<p>更多学习内容, 查看<a href="https://github.com/cpettitt/graphlib/wiki">wiki</a>。</p> 
<h2><a id="API__16"></a>API 指南</h2> 
<p>本部分主要阐述graphlib的概念并提供API指南。默认情况下，graphlib函数和对象暴露在graphlib的命名空间下。</p> 
<h2><a id="_19"></a>图像概念</h2> 
<p>Graphlib有一种图类型: Graph。<br> 创建一个新的实例:</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>默认情况下，将会创建一个不允许多边或者复合节点的有向图。以下则是参数选项:</p> 
<ul><li><code>directed</code>:设置为<code>true</code>时, 得到一个有向图。<code>false</code>时, 得到一个无向图。无向图不会把节点的顺序视为第一要务。换句话说, 对无向图来说<code>g.edge("a", "b") === g.edge("b", "a")</code>。默认为<code>true</code></li><li><code>multigraph</code>: 设置为<code>true</code>时, 允许图像在同一对节点之间有多条边。默认: <code>false</code>。</li><li><code>compound</code>: 设置为<code>true</code>时, 允许图像有复合节点。 可以是其他节点的父节点。 默认为<code>false</code>。</li></ul> 
<p>可以在constructor中通过对象配置属性。比如，创建一个有向复合多边图:</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> directed<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> compound<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> multigraph<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_35"></a>展现节点和边线</h2> 
<p>在graphlib中，节点由用户提供的字符串id表示。 所有节点相关的函数都使用此字符串id作为唯一标识节点的方式。以下为与节点交互的例子:</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">setNode</span><span class="token punctuation">(</span><span class="token string">"my-id"</span><span class="token punctuation">,</span> <span class="token string">"my-label"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

g<span class="token punctuation">.</span><span class="token function">node</span><span class="token punctuation">(</span><span class="token string">"my-id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// return "my-label"</span>
</code></pre> 
<p>graphlib中的边由他们连接的节点标识。比如:</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

g<span class="token punctuation">.</span><span class="token function">setEdge</span><span class="token punctuation">(</span><span class="token string">"source"</span><span class="token punctuation">,</span> <span class="token string">"target"</span><span class="token punctuation">,</span> <span class="token string">"my-label"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">edge</span><span class="token punctuation">(</span><span class="token string">"source"</span><span class="token punctuation">,</span> <span class="token string">"target"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// return my-label</span>
</code></pre> 
<p>但是，为了进行各种类型的边缘查询，我们需要一种方法去唯一标识单个对象里的边。(比如：<a href="https://github.com/dagrejs/graphlib/wiki/API-Reference#outEdges">outEdges</a>)。我们使用<code>edgeObj</code>应对，而此主要由以下组成:</p> 
<ul><li><code>v</code>: 源id或者是边线上的尾节点。</li><li><code>w</code>: 目标id或者是边线上的头节点。</li><li><code>name</code>(可选): 唯一标识多边边线(<a href="https://github.com/dagrejs/graphlib/wiki/API-Reference#multigraphs">multi-edge</a>)的名称。</li></ul> 
<p>任何采用了一个边线id的边缘函数也可以使用<code>edgeObj</code>：</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

g<span class="token punctuation">.</span><span class="token function">setEdge</span><span class="token punctuation">(</span><span class="token string">"source"</span><span class="token punctuation">,</span> <span class="token string">"target"</span><span class="token punctuation">,</span> <span class="token string">"my-label"</span><span class="token punctuation">)</span>
g<span class="token punctuation">.</span><span class="token function">edge</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> v<span class="token operator">:</span> <span class="token string">"source"</span><span class="token punctuation">,</span> w<span class="token operator">:</span> <span class="token string">"target"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// return my-label</span>
</code></pre> 
<h2><a id="Multigraphs_65"></a>Multigraphs</h2> 
<p>multigraphs的数学概念: <a href="https://en.wikipedia.org/wiki/Multigraph" rel="nofollow">multigraph</a></p> 
<p><img src="https://images2.imgbox.com/dd/f9/oCzkgmcZ_o.png" alt="在这里插入图片描述"></p> 
<p>多重图是一种在一对节点中可以拥有多条边的图。默认情况下, graphlib的图像不是多重图, 需要在构造体中设置多重图的属性为<code>true</code>:</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> multigraph<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>在两个节点由多条边的情况下，我们需要相同的办法去识别每一条边。 我们称这样的属性为<code>name</code>。 这有关于相同节点之间的几条边的例子:</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> multigraph<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

g<span class="token punctuation">.</span><span class="token function">setEdge</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"edge1-label"</span><span class="token punctuation">,</span> <span class="token string">"edge1"</span><span class="token punctuation">)</span>
g<span class="token punctuation">.</span><span class="token function">setEdge</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"edge2-label"</span><span class="token punctuation">,</span> <span class="token string">"edge2"</span><span class="token punctuation">)</span>

g<span class="token punctuation">.</span><span class="token function">edge</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"edge1"</span><span class="token punctuation">)</span>
g<span class="token punctuation">.</span><span class="token function">edge</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"edge2"</span><span class="token punctuation">)</span>

g<span class="token punctuation">.</span><span class="token function">edges</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">/**
 * return [
 *  { v: "a", w: "b", name: "edge1" },
 *  { v: "a", w: "b", name: "edge2" }
 * ]
 */</span>
</code></pre> 
<p>多重图也允许创建没有名字的一条边</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> multigraph<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

g<span class="token punctuation">.</span><span class="token function">setEdge</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"my-label"</span><span class="token punctuation">)</span>
g<span class="token punctuation">.</span><span class="token function">edge</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> v<span class="token operator">:</span> <span class="token string">"a"</span><span class="token punctuation">,</span> w<span class="token operator">:</span> <span class="token string">"b"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<h2><a id="_102"></a>复合图</h2> 
<p>复合图就是一个节点可以是其他节点的父节点。子节点组成一个"子图"。 以下例子为构建一个复合图并与之交互:</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> compound<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

g<span class="token punctuation">.</span><span class="token function">setParent</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"parent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">setParent</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"parent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

g<span class="token punctuation">.</span><span class="token function">parent</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns "parent"</span>
g<span class="token punctuation">.</span><span class="token function">parent</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns "parent"</span>

g<span class="token punctuation">.</span><span class="token function">parent</span><span class="token punctuation">(</span><span class="token string">"parent"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns undefined</span>
</code></pre> 
<h2><a id="_116"></a>默认标签</h2> 
<p>当一个节点或边没有创建标签时，会被默认分配一个标签。详情请看这两个API:</p> 
<ul><li><a href="https://github.com/dagrejs/graphlib/wiki/API-Reference#setDefaultNodeLabel">setDefaultNodeLabel</a></li><li><a href="https://github.com/dagrejs/graphlib/wiki/API-Reference#setDefaultEdgeLabel">setDefaultEdgeLabel</a></li></ul> 
<h2><a id="Graph_API_121"></a>Graph API</h2> 
<h3><a id="graphisDirected_123"></a>graph.isDirected()</h3> 
<p>如果图是有向图的话，会返回<code>true</code>。<br> 有向图会将在线段里的节点顺序是做有意义的，而无向图则会忽视。以下例子证明了不同:</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> directed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> directed<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

directed<span class="token punctuation">.</span><span class="token function">setEdge</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"my-label"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
directed<span class="token punctuation">.</span><span class="token function">edge</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns my-label</span>
directed<span class="token punctuation">.</span><span class="token function">edge</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns undefined</span>

<span class="token keyword">var</span> undirected <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> directed<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
undirected<span class="token punctuation">.</span><span class="token function">setEdge</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"my-label"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
undirected<span class="token punctuation">.</span><span class="token function">edge</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns my-label</span>
undirected<span class="token punctuation">.</span><span class="token function">edge</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns my-label</span>
</code></pre> 
<h3><a id="graphisMultigraph_139"></a>graph.isMultigraph()</h3> 
<p>如果图是多重图，返回<code>true</code>。<a href="https://github.com/dagrejs/graphlib/wiki/API-Reference#multigraphs">Multigraph</a></p> 
<h3><a id="graphisCompound_142"></a>graph.isCompound()</h3> 
<p>如果是复合图，返回<code>true</code>。<a href="https://github.com/dagrejs/graphlib/wiki/API-Reference#compound-graphs">compound</a></p> 
<h3><a id="graphgraph_145"></a>graph.graph()</h3> 
<p>返回为图形分配的标签。 如果没有指定标签，则返回<code>undefined</code>。</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

g<span class="token punctuation">.</span><span class="token function">graph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// return undefined</span>
g<span class="token punctuation">.</span><span class="token function">setGraph</span><span class="token punctuation">(</span><span class="token string">"graph-label"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">graph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// return "graph-label"</span>
</code></pre> 
<h3><a id="graphsetGraphlabel_155"></a>graph.setGraph(label)</h3> 
<p>为图像设置标签。</p> 
<h3><a id="graphnodeCount_158"></a>graph.nodeCount()</h3> 
<p>返回图像中节点的数量。</p> 
<h3><a id="graphedgeCount_161"></a>graph.edgeCount()</h3> 
<p>返回节点中边线的数量。</p> 
<h3><a id="graphsetDefaultNodeLabelval_164"></a>graph.setDefaultNodeLabel(val)</h3> 
<p>设置一个新的默认值，以便于在没有指定标签创建节点时，分配过去。<br> 如果<code>val</code>不是一个函数，将会作为标签分配。<br> 如果是一个函数, 正被创建的节点的id将会调用此函数。</p> 
<h3><a id="graphsetDefaultEdgeLabelval_169"></a>graph.setDefaultEdgeLabel(val)</h3> 
<p>为没有分配标签的线段指定一个新的默认标签。<br> 如果<code>val</code>不是函数，则作为标签。<br> 如果是函数，则会随着参数<code>(v, w, name)</code>而被调用。</p> 
<h3><a id="graphnodes_174"></a>graph.nodes()</h3> 
<p>返回图像里的所有节点id。<br> 使用<a href="https://github.com/dagrejs/graphlib/wiki/API-Reference#node">node(v)</a>获取每个节点的标签，花费<code>O(|v|)</code>的时间。</p> 
<h3><a id="graphedges_178"></a>graph.edges()</h3> 
<p>返回图中的每个边线的<a href="https://github.com/dagrejs/graphlib/wiki/API-Reference#node-and-edge-representation">edgeObj</a>。<br> 使用<a href="https://github.com/dagrejs/graphlib/wiki/API-Reference#edge">edge(edgeObj)</a>获取每个边线的标签。花费<code>O(|v|)</code>的时间。</p> 
<h3><a id="graphsources_182"></a>graph.sources()</h3> 
<p>返回图中没有入边的节点。</p> 
<h3><a id="graphsinks_185"></a>graph.sinks()</h3> 
<p>返回途中没有出边的节点。</p> 
<h3><a id="graphhasNodev_188"></a>graph.hasNode(v)</h3> 
<p>如果图里存在节点的id为<code>v</code>，则返回<code>true</code>。</p> 
<h3><a id="graphnodev_191"></a>graph.node(v)</h3> 
<p>如果图中存在id为<code>v</code>的节点，则返回指定的标签，否则返回<code>undefined</code>。</p> 
<h3><a id="graphsetNodev_label_194"></a>graph.setNode(v, [label])</h3> 
<p>在图中创建或更新节点v的值。 如果提供了label，则更新掉。如果没有提供，在创建过程中会分配一个默认的标签。<a href="https://github.com/dagrejs/graphlib/wiki/API-Reference#default-labels">default node label</a>。</p> 
<p>返回图，允许图和其他的函数连接起来。</p> 
<h3><a id="graphremoveNodev_199"></a>graph.removeNode(v)</h3> 
<p>移除图中id为<code>v</code>的节点，如果不存在则不处理。如果节点被移除，也会移除所有边。<br> 返回图，允许图和其他的函数连接起来。</p> 
<h3><a id="graphpredecessorsv_203"></a>graph.predecessors(v)</h3> 
<p>返回指定节点的所有前导节点，如果图中不存在此节点，则返回<code>undefined</code>. 如果是无向图，则会返回<code>undefined</code>，应该使用<a href="https://github.com/dagrejs/graphlib/wiki/API-Reference#neighbors">neighbors</a>。</p> 
<h3><a id="graphsuccessorsv_206"></a>graph.successors(v)</h3> 
<p>返回指定节点的所有后续节点。如果图中没有此节点，则返回<code>undefined</code>. 如果是无向图，则会返回<code>undefined</code>，应该使用<a href="https://github.com/dagrejs/graphlib/wiki/API-Reference#neighbors">neighbors</a>。</p> 
<h3><a id="graphneighborsv_209"></a>graph.neighbors(v)</h3> 
<p>返回指定节点的前导节点或者后续节点。如果图中没有此节点，则返回<code>undefined</code>。</p> 
<h3><a id="graphinEdgesv_u_212"></a>graph.inEdges(v, [u])</h3> 
<p>返回所有指向节点(v)的边。 可以过滤出只来自于节点u的边。<br> 对无向图来说都是<code>undefined</code>，请使用<a href="https://github.com/dagrejs/graphlib/wiki/API-Reference#nodeEdges">nodeEdges</a>。<br> 如果图中没有节点<code>v</code>，则返回<code>undefined</code>。</p> 
<h3><a id="graphoutEdgesv_w_218"></a>graph.outEdges(v, [w])</h3> 
<p>返回所有指向节点的边。可以过滤出只指向节点w的边。<br> 对无向图来说都是<code>undefined</code>，请使用<a href="https://github.com/dagrejs/graphlib/wiki/API-Reference#nodeEdges">nodeEdges</a>。<br> 如果图中没有节点<code>v</code>，则返回<code>undefined</code>。</p> 
<h3><a id="graphnodeEdgesv_w_223"></a>graph.nodeEdges(v, [w])</h3> 
<p>返回所有与节点v有关的边，而不管方向。<br> 可以过滤出节点v和w之间的所有线段，无论方向。<br> 如果图中没有节点<code>v</code>，则返回<code>undefined</code>。</p> 
<h3><a id="graphparentv_228"></a>graph.parent(v)</h3> 
<p>返回节点v的父节点。<br> 如果节点没有父节点或不在图中，则返回<code>undefined</code>。<br> 如果不是复合图的话，始终返回<code>undefined</code>。</p> 
<h3><a id="graphchildrenv_233"></a>graph.children(v)</h3> 
<p>返回节点v的所有孩子节点。<br> 如果不在图中则返回<code>undefined</code>。<br> 如果不是复合图，始终返回<code>[]</code>。</p> 
<h3><a id="graphsetParentv_parent_238"></a>graph.setParent(v, parent)</h3> 
<p>如果<code>parent</code>有值，则设置为节点v的父节点; 如果没有值，则移除节点v的父节点。<br> 如果图不是复合图，则抛出异常。<br> 返回值为图本身，允许被连接到其他的函数内。</p> 
<h3><a id="graphhasEdgev_w_name__graphhasEdgeedgeObj_243"></a>graph.hasEdge(v, w, [name]) / graph.hasEdge(edgeObj)</h3> 
<p>如果图中的节点v和节点w之间存在一条边，名字为<code>name</code>,则返回<code>true</code>。<br> [name]参数只适用于多重图。<br> 对于无向图来说,v和w可以互换位置。</p> 
<h3><a id="graphedgev_w_name__graphedgeedgeObj_248"></a>graph.edge(v, w, [name]) / graph.edge(edgeObj)</h3> 
<p>如果图中节点v和w之间存在线段，并带有可选名称，则返回线段(v,w)的标签。<br> 如果图中没有这条线，则返回<code>undefined</code>。<br> 参数[name]只适用于多重图。<br> 无向图中,v,w可以互换。</p> 
<h3><a id="graphsetEdgev_w_label_name__graphsetEdgeedgeObj_label_254"></a>graph.setEdge(v, w, [label], [name]) / graph.setEdge(edgeObj, [label])</h3> 
<p>使用参数[name]去创建或更新(v,w)的边。<br> 如果提供了[label]，则将其设置为边的值。而如果没有被提供，则将分配给默认的标签。<br> 参数[name]只适用于多重图。<br> 返回值为图本身，允许被连接到其他的函数内。</p> 
<h3><a id="graphremoveEdgev_w_name_260"></a>graph.removeEdge(v, w, [name])</h3> 
<p>如果图中的节点v,w之间有一条可选名[name]的边，则移除它。否则将无效。<br> 参数[name]只适用于多重图。<br> 无向图中,v,w可以互换。</p> 
<h2><a id="_266"></a>序列化</h2> 
<h3><a id="jsonwriteg_267"></a>json.write(g)</h3> 
<p>创建可以用JSON序列化为字符串的图形的JSONrepresentation。稍后可以使用<a href="https://github.com/dagrejs/graphlib/wiki/API-Reference#json-read">json-read</a>恢复图形。</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">graphlib<span class="token punctuation">.</span>Graph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">setNode</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span> label<span class="token operator">:</span> <span class="token string">"node a"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">setNode</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span> label<span class="token operator">:</span> <span class="token string">"node b"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">setEdge</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span> label<span class="token operator">:</span> <span class="token string">"edge a-&gt;b"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
graphlib<span class="token punctuation">.</span>json<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Returns the object:</span>
<span class="token comment">//</span>
<span class="token comment">// {<!-- --></span>
<span class="token comment">//   "options": {<!-- --></span>
<span class="token comment">//     "directed": true,</span>
<span class="token comment">//     "multigraph": false,</span>
<span class="token comment">//     "compound": false</span>
<span class="token comment">//   },</span>
<span class="token comment">//   "nodes": [</span>
<span class="token comment">//     { "v": "a", "value": { "label": "node a" } },</span>
<span class="token comment">//     { "v": "b", "value": { "label": "node b" } }</span>
<span class="token comment">//   ],</span>
<span class="token comment">//   "edges": [</span>
<span class="token comment">//     { "v": "a", "w": "b", "value": { "label": "edge a-&gt;b" } }</span>
<span class="token comment">//   ]</span>
<span class="token comment">// }</span>
</code></pre> 
<h3><a id="jsonreadjson_294"></a>json.read(json)</h3> 
<p>将输入的json转换为图像的展示类型。比如，我们使用<code>json-write</code>将图像序列化为<code>str</code>的字符串，我们可以使用以下的办法去恢复:</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> g2 <span class="token operator">=</span> graphlib<span class="token punctuation">.</span>json<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// or, in order to copy the graph</span>
<span class="token keyword">var</span> g3 <span class="token operator">=</span> graphlib<span class="token punctuation">.</span>json<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>graphlib<span class="token punctuation">.</span>json<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">)</span>

g2<span class="token punctuation">.</span><span class="token function">nodes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ['a', 'b']</span>
g2<span class="token punctuation">.</span><span class="token function">edges</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// [ { v: 'a', w: 'b' } ]</span>
</code></pre> 
<h2><a id="_307"></a>算法</h2> 
<h3><a id="algcomponentsgraph_308"></a>alg.components(graph)</h3> 
<p>找到图中所有的连接部分，并且将这些部分作为数组返回。<br> 每个组件本身就是一个数组，包含组件中节点id。</p> 
<p><img src="https://images2.imgbox.com/de/f9/dCAiKtHz_o.jpg" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-js">graphlib<span class="token punctuation">.</span>alg<span class="token punctuation">.</span><span class="token function">components</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// =&gt; [ [ 'A', 'B', 'C', 'D' ],</span>
<span class="token comment">//      [ 'E', 'F', 'G' ],</span>
<span class="token comment">//      [ 'H', 'I' ] ]</span>
</code></pre> 
<h3><a id="algdijkstragraph_source_weightFn_edgeFn_322"></a>alg.dijkstra(graph, source, weightFn, edgeFn)</h3> 
<p>此算法是[Dijkstra]算法的js版本. 旨在从g的源节点到其他任意节点的最短路径。</p> 
<p>这个函数将会返回一个map结构:<br> <code>v -&gt; { distance, predecessor }</code></p> 
<p>distance属性会保存从source到v的最短路径权重之和。<br> 如果从source过来没有路径，则结果为正无穷大。</p> 
<p>predecessor属性可以按照相反顺序遍历source到v的每个元素。</p> 
<p>根据<code>weightFn(e)</code>来返回边e的权重。如果没有赋值，默认的每条边的权重是1.<br> 如果任何遍历的边具有负边权重，则此函数将抛出错误。</p> 
<p>edgeFn（v）会返回与节点v相关的所有边的ID，以便进行最短路径遍历。默认使用<code>g.outEdges</code>。</p> 
<p>例子：<br> <img src="https://images2.imgbox.com/9d/31/2Yipi5Ci_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">weight</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> g<span class="token punctuation">.</span><span class="token function">edge</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

graphlib<span class="token punctuation">.</span>alg<span class="token punctuation">.</span><span class="token function">dijkstra</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">,</span> weight<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// =&gt; { A: { distance: 0 },</span>
<span class="token comment">//      B: { distance: 6, predecessor: 'C' },</span>
<span class="token comment">//      C: { distance: 4, predecessor: 'A' },</span>
<span class="token comment">//      D: { distance: 2, predecessor: 'A' },</span>
<span class="token comment">//      E: { distance: 8, predecessor: 'F' },</span>
<span class="token comment">//      F: { distance: 4, predecessor: 'D' } }</span>
</code></pre> 
<h3><a id="algdijkstraAllgraph_weightFn_edgeFn_354"></a>alg.dijkstraAll(graph, weightFn, edgeFn)</h3> 
<p>此函数用于查找从每个节点到其他每个可到达节点到最短距离。<br> 与<code>alg.dijkstra</code>类似，但返回的不是单个数组，而是返回一个map映射: <code>source -&gt; alg.dijkstra(g, source, weightFn, edgeFn)</code></p> 
<p>函数的<code>weightFn</code>返回边<code>e</code>的权重。如果没有指定，则默认为1。如果可遍历的边有负数，则会立即抛出错误。</p> 
<p>函数的<code>edgeFn(u)</code>返回所有与节点<code>u</code>有关的边的id，以便于进行最短路径的遍历。默认使用<code>g.outEdges</code>。</p> 
<p>例子:<br> <img src="https://images2.imgbox.com/35/34/Wyh8YATj_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">weight</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> g<span class="token punctuation">.</span><span class="token function">edge</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

graphlib<span class="token punctuation">.</span>alg<span class="token punctuation">.</span><span class="token function">dijkstraAll</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> g<span class="token punctuation">.</span><span class="token function">edge</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// =&gt; { A:</span>
<span class="token comment">//       { A: { distance: 0 },</span>
<span class="token comment">//         B: { distance: 6, predecessor: 'C' },</span>
<span class="token comment">//         C: { distance: 4, predecessor: 'A' },</span>
<span class="token comment">//         D: { distance: 2, predecessor: 'A' },</span>
<span class="token comment">//         E: { distance: 8, predecessor: 'F' },</span>
<span class="token comment">//         F: { distance: 4, predecessor: 'D' } },</span>
<span class="token comment">//      B:</span>
<span class="token comment">//       { A: { distance: Infinity },</span>
<span class="token comment">//         B: { distance: 0 },</span>
<span class="token comment">//         C: { distance: Infinity },</span>
<span class="token comment">//         D: { distance: Infinity },</span>
<span class="token comment">//         E: { distance: 6, predecessor: 'B' },</span>
<span class="token comment">//         F: { distance: Infinity } },</span>
<span class="token comment">//      C: { ... },</span>
<span class="token comment">//      D: { ... },</span>
<span class="token comment">//      E: { ... },</span>
<span class="token comment">//      F: { ... } }</span>
</code></pre> 
<h3><a id="algfindCyclesgraph_391"></a>alg.findCycles(graph)</h3> 
<p>假定存在一个图<code>g</code>，此函数将会返回图中循环的部分。</p> 
<p>由于图中不止有1个循环，所以该函数返回有循环体所构成的数组，而每个循环体由涉及的节点id构成。</p> 
<p>如果要判断图是否有循环部分，请使用<code>g.isAcyclic</code>则更为高效。</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">graphlib<span class="token punctuation">.</span>Graph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">setNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">setNode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">setNode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">setEdge</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">setEdge</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
graphlib<span class="token punctuation">.</span>alg<span class="token punctuation">.</span><span class="token function">findCycles</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// =&gt; []</span>

g<span class="token punctuation">.</span><span class="token function">setEdge</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
graphlib<span class="token punctuation">.</span>alg<span class="token punctuation">.</span><span class="token function">findCycles</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// =&gt; [ [ '3', '2', '1' ] ]</span>

g<span class="token punctuation">.</span><span class="token function">setNode</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">setNode</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">setEdge</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">setEdge</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
graphlib<span class="token punctuation">.</span>alg<span class="token punctuation">.</span><span class="token function">findCycles</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// =&gt; [ [ '3', '2', '1' ], [ '5', '4' ] ]</span>
</code></pre> 
<h3><a id="algisAcyclicgraph_421"></a>alg.isAcyclic(graph)</h3> 
<p>给定一个图<code>g</code>，如果该图有循环的部分，则返回<code>true</code>。否则，返回<code>false</code>。</p> 
<p>该函数会返回检测到的第一个循环体。如果要获取全部内容，请使用<code>alg.findCycles</code>。</p> 
<pre><code class="prism language-js"><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">graphlib<span class="token punctuation">.</span>Graph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">setNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">setNode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">setNode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">setEdge</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">setEdge</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

graphlib<span class="token punctuation">.</span>alg<span class="token punctuation">.</span><span class="token function">isAcyclic</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// =&gt; true</span>

g<span class="token punctuation">.</span><span class="token function">setEdge</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
graphlib<span class="token punctuation">.</span>alg<span class="token punctuation">.</span><span class="token function">isAcyclic</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// =&gt; false</span>
</code></pre> 
<h3><a id="algpostordergraph_vs_442"></a>alg.postorder(graph, vs)</h3> 
<p>该函数将会从图像g的节点vs开始，进行后序遍历。</p> 
<p>对于访问的每个节点，假定节点名为<code>v</code>，将会调用<code>callback(v)</code>。<br> <img src="https://images2.imgbox.com/56/6a/WjXuzI3C_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-js">graphlib<span class="token punctuation">.</span>alg<span class="token punctuation">.</span><span class="token function">postorder</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// =&gt; One of:</span>
<span class="token comment">// [ "B", "D", "E", C", "A" ]</span>
<span class="token comment">// [ "B", "E", "D", C", "A" ]</span>
<span class="token comment">// [ "D", "E", "C", B", "A" ]</span>
<span class="token comment">// [ "E", "D", "C", B", "A" ]</span>
</code></pre> 
<h3><a id="algpreordergraph_vs_457"></a>alg.preorder(graph, vs)</h3> 
<p>该函数将会从图像g的节点vs开始，进行前序遍历。<br> 对于访问的每个节点，假定节点名为<code>v</code>，将会调用<code>callback(v)</code>。<br> <img src="https://images2.imgbox.com/6f/77/rgOkxij8_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-js">graphlib<span class="token punctuation">.</span>alg<span class="token punctuation">.</span><span class="token function">preorder</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// =&gt; One of:</span>
<span class="token comment">// [ "A", "B", "C", "D", "E" ]</span>
<span class="token comment">// [ "A", "B", "C", "E", "D" ]</span>
<span class="token comment">// [ "A", "C", "D", "E", "B" ]</span>
<span class="token comment">// [ "A", "C", "E", "D", "B" ]</span>
</code></pre> 
<h3><a id="algprimgraph_weightFn_471"></a>alg.prim(graph, weightFn)</h3> 
<p>Prim算法采用连通无向图，并生成最小生成树。<br> <a href="https://en.wikipedia.org/wiki/Prim'%20rel=">Prim’s algorithm</a>.</p> 
<p>该函数将会以无向图的形式返回最小生成树。这个算法取自《算法导论》。</p> 
<p>weightFn(e)将会返回边的权重e，如果图没有被联通，则会抛出异常。</p> 
<p><img src="https://images2.imgbox.com/74/e8/bZyUmzGS_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-js"><span class="token keyword">function</span> <span class="token function">weight</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token function">g</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
graphlib<span class="token punctuation">.</span>alg<span class="token punctuation">.</span><span class="token function">prim</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> weight<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>返回的树，以图的形式展现:<br> <img src="https://images2.imgbox.com/5c/ee/CU8WsZ5o_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="algtarjangraph_489"></a>alg.tarjan(graph)</h3> 
<p><a href="http://en.wikipedia.org/wiki/Tarjan'%20rel=">Tarjan’s algorithm</a></p> 
<p>该函数是Tarjan算法的一个实现，该算法在有向图g中找到所有<a href="http://en.wikipedia.org/wiki/Strongly_connected_component" rel="nofollow">强连通分量</a></p> 
<p>每个强连通分量由节点组成，这些节点可以通过定向边到达分量中的所有其他节点。</p> 
<p>如果一个强连接的组件既不能到达图中的任何其他特定节点，也不能被该节点访问，则该组件可以由单个节点组成。多个节点的组件要保证至少有一个循环。</p> 
<p>此函数将会返回一个组件数组。每个组件本身也是一个数组，并且包含了组件内所有节点的id。<br> <img src="https://images2.imgbox.com/93/62/C8zj6WKW_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-js">graphlib<span class="token punctuation">.</span>alg<span class="token punctuation">.</span><span class="token function">tarjan</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// =&gt; [ [ 'F', 'G' ],</span>
<span class="token comment">//      [ 'H', 'D', 'C' ],</span>
<span class="token comment">//      [ 'E', 'B', 'A' ] ]</span>
</code></pre> 
<h3><a id="algtopsortgraph_508"></a>alg.topsort(graph)</h3> 
<p><a href="https://en.wikipedia.org/wiki/Topological_sorting" rel="nofollow">topological sorting</a></p> 
<p>topological 排序算法的实现。</p> 
<p>给定一个图<code>g</code>，该函数返回一个节点数组，使得每个边<code>u -&gt; v</code>， u出现在v之前。<br> 如果图有循环，则不可能生成列表，并抛出异常。<br> <img src="https://images2.imgbox.com/01/ab/qUxJdkxs_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-js">graphlib<span class="token punctuation">.</span>alg<span class="token punctuation">.</span><span class="token function">topsort</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span>
<span class="token comment">// [ '1', '2', '3', '4' ] or [ '1', '3', '2', '4' ]</span>
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d51f7827708a8ba3f0229f04746a73ff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java实现Treap</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c6b4660f22ed89ea7f10d38a73bc5b5f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python判定两个列表list是否具有完全相同的元素</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>