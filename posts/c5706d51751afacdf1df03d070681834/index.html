<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>处理器体系结构（了解CPU的基本运行原理）——《深入理解计算机系统》 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="处理器体系结构（了解CPU的基本运行原理）——《深入理解计算机系统》" />
<meta property="og:description" content="处理器体系结构
ISA 一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构ISA。
虽然每个厂商制造的处理器性能和复杂性不断提高，但是不同型号在ISA级别上都保持着兼容。因此，ISA在编译器编写者和处理器设计人员之间提供了一个概念抽象层。
这个概念抽象层即ISA模型：CPU允许的指令集编码，且顺序地执行指令，也就是先取出一条指令，等到她执行完毕，再开始下一条。然而，现代处理器的实际工作方式可能跟ISA隐含的计算模型大相径庭。通过同时处理多条指令的不同部分，处理器可以获得较高的性能。但其必须对外表现出符合ISA模型的执行结果。
在计算机科学中，用巧妙的方法在提高性能的同时，又保持一个更简单、更抽象模型的功能，这种思想是众所周知的（抽象）。
CPU硬件简介 大多数现代电路设计都是用信号线上的高电压和低电压来表示不同的位值。
要实现一个数字系统需要三个主要的组成部分：
①计算对位进行操作的函数的组合逻辑(ALU)
②存储位的存储器元素(寄存器)
③控制存储器元素更新的时钟信号
逻辑门是数字电路的基本计算元素，它们产生的输出，等于它们输入位值的某个布尔函数。
将很多逻辑门组合成一个网，就能构建计算块，称为组合电路。(相当于一个表达式)
算术/逻辑单元(ALU)是一种很重要的组合电路，这个电路有三个输入：两个数据输入及一个控制输入。根据控制输入的设置，电路会对数据输入执行不同的算术或逻辑操作。
存储器和时钟 组合电路从本质上讲，不存储任何信息。它们只是简单地响应输入信号，产生等于输入的某个函数的输出。为了产生时序电路，也就是有状态并且在这个状态上进行计算的系统，我们必须引入按位存储信息的设备。
存储设备都是由同一个时钟控制，时钟是一个周期性信号，决定了什么时候要把新值加载到设备中。
大多数时候，寄存器都保持在稳定状态(用x表示)，产生的输出等于它的当前状态。信号沿着寄存器前面的组合逻辑传播，这时，产生了一个新的寄存器输入(用y表示)，但只要时钟是低电位的，寄存器的输出就仍然保持不变。当时钟变成高电位的时候，输入信号才加载到寄存器中，成为下一个状态y，直至下一个时钟的上升沿。
寄存器是作为电路不同部分中的组合逻辑之间的屏障。每当每个时钟到达上升沿时，值才会从寄存器的输入传送到输出。
寄存器文件(通用寄存器组成的逻辑块) 有两个读端口，还有一个写端口。电路可以读两个程序寄存器的值，同时更新第三个寄存器的状态。每个端口都有一个地址输入，表明选择哪个程序寄存器。
虽然寄存器文件不是组合电路，因为它有内部存储。不过，从寄存器文件读数据就好像它是一个以地址为输入、数据为输出的一个组合逻辑块。
指令编码 指令集的一个重要性质就是字节编码必须有唯一的解释。任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。因为每条指令的第一个字节有唯一的代码和功能组合，给定这个字节，我们就可以决定所有其他附加字节的长度和含义。
每条指令需要1——6个字节不等，这取决于需要哪些字段。每条指令的第一个字节表明指令的类型：高4位是代码部分(例：6为整数类操作指令)，低4位是功能部分(例：1为整数类中的减法指令) 61合起来即为sub指令。
处理一条指令的序列： 取指(fetch)
取值阶段从存储器读取指令字节，放到指令存储器(CPU中)中，地址为程序计数器(PC)的值。
它按顺序的方式计算当前指令的下一条指令的地址(即PC的值加上已取出指令的长度)
译码(decode)
ALU从寄存器文件(通用寄存器的集合)读入最多两个操作数。（即一次最多读取两个寄存器中的内容）
执行(execute)
在执行阶段会根据指令的类型，将算数/逻辑单元(ALU)用于不同的目的。对其他指令，它会作为一个加法器来计算增加或减少栈指针，或者计算有效地址，或者只是简单地加0，将一个输入传递到输出。
条件码寄存器(CC)有三个条件位。ALU负责计算条件码新值。当执行一条跳转指令时，会根据条件码和跳转类型来计算分支信号cnd。
访存(memory)
访存阶段，数据存储器(CPU中)读出或写入一个存储器字。指令和数据存储器访问的是相同的存储器位置，但是用于不同的目的。
写回(write back)
写回阶段最多可以写两个结果到寄存器文件。寄存器文件有两个写端口。端口E用来写ALU计算出来的值，而端口M用来写从数据存储器中读出的值。
更新PC(PC update)
根据指令代码和分支标志，从前几步得出的信号值中，选出下一个PC的值。
我们以SEQ(sequential 顺序的)处理器为例讲解CPU的基本原理。每个时钟周期上，SEQ执行处理一条完整指令所需的所有步骤。不过这需要一个很长的时钟周期时间，因此时钟周期频率会低到不可接受。
SEQ的时序 组合逻辑不需要任何时序或控制——只要输入变化了，值就通过逻辑门网络传播。
我们也将读随机访问存储器(寄存器文件、指令存储器和数据存储器)看成和组合逻辑一样的操作。（写随机访问存储器需要等待高电平）
由于指令存储器只用来读指令，因此我们可以将这个单元看成是组合逻辑。（内存向指令存储器中写指令是CPU外部的事件 不属于CPU内的时序）
每个时钟周期，程序计数器都会装载新的指令地址。
只有在执行整数运算指令时，才会装载条件码寄存器。
只有在执行mov、push、call指令时，才会写数据存储器。
要控制处理器中活动的时序，只需要寄存器和存储器的时钟控制。
因为指令运行计算的结果，写入寄存器或存储器中。
我们可以把取指、译码、执行等过程看做是组合逻辑的处理过程（因为它们不涉及写入寄存器）。把写回看做是另一个过程。
则整个过程可简化为下图所示：
【举例详解】
有如下指令：
0x000 ： irmovl $0x100, %ebx
0x006 ： irmovl $0x200, %edx" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/c5706d51751afacdf1df03d070681834/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-03-30T00:02:26+08:00" />
<meta property="article:modified_time" content="2014-03-30T00:02:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">处理器体系结构（了解CPU的基本运行原理）——《深入理解计算机系统》</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center"><span style="font-size:32px">处理器体系结构</span></p> 
<p style="text-align:center"><span style="font-size:32px"><br> </span></p> 
<h2>ISA</h2> 
<p><span style="font-size:14px">一个处理器支持的<u><span style="color:red">指令</span></u>和<u><span style="color:red">指令的字节级编码</span></u>称为它的<strong>指令集体系结构ISA</strong>。</span></p> 
<p><span style="font-size:14px">虽然每个厂商制造的处理器性能和复杂性不断提高，但是不同型号在ISA级别上都保持着兼容。因此，ISA在编译器编写者和处理器设计人员之间提供了一个<strong>概念抽象层</strong>。</span></p> 
<p><span style="font-size:14px">这个概念抽象层即ISA模型：CPU允许的指令集编码，且顺序地执行指令，也就是先取出一条指令，等到她执行完毕，再开始下一条。</span><span style="font-size:14px">然而，现代处理器的实际工作方式可能跟ISA隐含的计算模型大相径庭。通过同时处理多条指令的不同部分，处理器可以获得较高的性能。但其必须对外表现出符合ISA模型的执行结果。</span></p> 
<p><span style="font-size:14px">在计算机科学中，用巧妙的方法在提高性能的同时，又保持一个更简单、更抽象模型的功能，这种思想是众所周知的（抽象）。</span></p> 
<p> </p> 
<h2>CPU硬件简介</h2> 
<p><br> </p> 
<p><span style="font-size:14px">大多数现代电路设计都是用信号线上的高电压和低电压来表示不同的位值。</span></p> 
<p><span style="font-size:14px">要实现一个数字系统需要三个主要的组成部分：</span></p> 
<p><span style="font-size:14px">①计算对位进行操作的函数的<strong>组合逻辑</strong>(ALU)</span></p> 
<p><span style="font-size:14px">②存储位的<strong>存储器元素</strong>(寄存器)</span></p> 
<p><span style="font-size:14px">③控制存储器元素更新的<strong>时钟信号</strong></span></p> 
<p> </p> 
<p><strong><span style="font-family:Microsoft YaHei; font-size:18px">逻辑门</span></strong>是数字电路的基本计算元素，它们产生的输出，等于它们输入位值的某个布尔函数。</p> 
<p>将很多逻辑门组合成一个网，就能构建计算块，称为<strong>组合电路</strong>。(相当于一个表达式)</p> 
<p> </p> 
<p><strong><span style="font-family:Microsoft YaHei; font-size:18px">算术/逻辑单元(ALU)</span></strong>是一种很重要的<u>组合电路</u>，这个电路有三个输入：两个数据输入及一个控制输入。根据控制输入的设置，电路会对数据输入执行不同的算术或逻辑操作。</p> 
<p> </p> 
<h5><span style="font-family:Microsoft YaHei; font-size:18px">存储器和时钟</span></h5> 
<p>组合电路从本质上讲，不存储任何信息。它们只是简单地响应输入信号，产生等于输入的某个函数的输出。为了产生<u>时序电路</u>，也就是有状态并且在这个状态上进行计算的系统，我们必须引入按位存储信息的设备。</p> 
<p>存储设备都是由同一个时钟控制，<u>时钟是一个周期性信号，决定了什么时候要把新值加载到设备中</u>。</p> 
<p> </p> 
<p>大多数时候，寄存器都保持在稳定状态(用x表示)，产生的输出等于它的当前状态。信号沿着寄存器前面的组合逻辑传播，这时，产生了一个新的寄存器输入(用y表示)，<u><span style="color:red">但只要时钟是低电位的，寄存器的输出就仍然保持不变。当时钟变成高电位的时候，输入信号才加载到寄存器中</span></u>，成为下一个状态y，直至下一个时钟的上升沿。</p> 
<p><u><span style="color:red">寄存器是作为电路不同部分中的组合逻辑之间的屏障。每当每个时钟到达上升沿时，值才会从寄存器的输入传送到输出</span></u>。</p> 
<p> </p> 
<p><strong><span style="font-family:Microsoft YaHei; font-size:18px">寄存器文件</span></strong>(通用寄存器组成的逻辑块) 有两个读端口，还有一个写端口。电路可以读两个程序寄存器的值，同时更新第三个寄存器的状态。每个端口都有一个地址输入，表明选择哪个程序寄存器。</p> 
<p>虽然寄存器文件不是组合电路，因为它有内部存储。不过，从寄存器文件读数据就好像它是一个以地址为输入、数据为输出的一个组合逻辑块。</p> 
<p> </p> 
<h6><span style="font-family:Microsoft YaHei; font-size:18px">指令编码</span></h6> 
<p>指令集的一个重要性质就是字节编码必须有唯一的解释。任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。<u>因为每条指令的第一个字节有唯一的代码和功能组合，给定这个字节，我们就可以决定所有其他附加字节的长度和含义</u>。</p> 
<p> </p> 
<p>每条指令需要1——6个字节不等，这取决于需要哪些字段。每条指令的第一个字节表明指令的类型：高4位是代码部分(例：6为整数类操作指令)，低4位是功能部分(例：1为整数类中的减法指令) 61合起来即为sub指令。</p> 
<p> </p> 
<h2>处理一条指令的序列：</h2> 
<p><strong><span style="font-family:Microsoft YaHei; font-size:18px"><br> </span></strong></p> 
<p><strong><span style="font-family:Microsoft YaHei; font-size:18px">取指(fetch)</span></strong></p> 
<p>取值阶段从存储器读取指令字节，放到指令存储器(CPU中)中，地址为程序计数器(PC)的值。</p> 
<p>它按顺序的方式计算当前指令的下一条指令的地址(即PC的值加上已取出指令的长度)</p> 
<p> </p> 
<p><strong><span style="font-family:Microsoft YaHei; font-size:18px">译码(decode)</span></strong></p> 
<p>ALU从寄存器文件(通用寄存器的集合)读入最多两个操作数。（即一次最多读取两个寄存器中的内容）</p> 
<p> </p> 
<p><strong><span style="font-family:Microsoft YaHei; font-size:18px">执行(execute)</span></strong></p> 
<p>在执行阶段会根据指令的类型，将算数/逻辑单元(ALU)用于不同的目的。对其他指令，它会作为一个加法器来计算增加或减少栈指针，或者计算有效地址，或者只是简单地加0，将一个输入传递到输出。</p> 
<p>条件码寄存器(CC)有三个条件位。ALU负责计算条件码新值。当执行一条跳转指令时，会根据条件码和跳转类型来计算分支信号cnd。</p> 
<p> </p> 
<p><strong><span style="font-family:Microsoft YaHei; font-size:18px">访存(memory)</span></strong></p> 
<p>访存阶段，数据存储器(CPU中)读出或写入一个存储器字。指令和数据存储器访问的是相同的存储器位置，但是用于不同的目的。</p> 
<p> </p> 
<p><strong><span style="font-family:Microsoft YaHei; font-size:18px">写回(write back)</span></strong></p> 
<p>写回阶段最多可以写两个结果到寄存器文件。寄存器文件有两个写端口。端口E用来写ALU计算出来的值，而端口M用来写从数据存储器中读出的值。</p> 
<p> </p> 
<p><strong><span style="font-family:Microsoft YaHei; font-size:18px">更新PC(PC update)</span></strong></p> 
<p>根据指令代码和分支标志，从前几步得出的信号值中，选出下一个PC的值。</p> 
<p><img src="https://images2.imgbox.com/be/64/9zNU8zpi_o.jpg" alt=""><br> </p> 
<p></p> 
<p>我们以<strong>SEQ(sequential </strong>顺序的)处理器为例讲解CPU的基本原理。每个时钟周期上，SEQ执行处理一条完整指令所需的所有步骤。不过这需要一个很长的时钟周期时间，因此时钟周期频率会低到不可接受。</p> 
<br> 
<p></p> 
<h2>SEQ的时序</h2> 
<p></p> 
<p><strong><u><br> </u></strong></p> 
<p><strong><u>组合逻辑</u></strong><u>不需要任何时序或控制——只要<strong>输入变化了</strong>，值就通过逻辑门网络传播。</u></p> 
<p>我们也将<strong>读</strong>随机访问存储器(寄存器文件、指令存储器和数据存储器)看成和组合逻辑一样的操作。（<u>写</u>随机访问存储器需要等待高电平）</p> 
<p>由于指令存储器只用来读指令，因此我们可以将这个单元看成是组合逻辑。（内存向指令存储器中写指令是CPU外部的事件 不属于CPU内的时序）</p> 
<p> </p> 
<p>每个时钟周期，程序计数器都会装载新的指令地址。</p> 
<p>只有在执行整数运算指令时，才会装载条件码寄存器。</p> 
<p>只有在执行mov、push、call指令时，才会写数据存储器。</p> 
<p> </p> 
<p><u>要控制处理器中活动的时序，只需要寄存器和存储器的时钟控制</u>。</p> 
<p>因为指令运行计算的结果，写入寄存器<strong>或</strong>存储器中。</p> 
<p>我们可以把取指、译码、执行等过程看做是组合逻辑的处理过程（因为它们不涉及写入寄存器）。把写回看做是另一个过程。</p> 
<p>则整个过程可简化为下图所示：</p> 
<img src="https://images2.imgbox.com/d3/c8/0WyQNVs5_o.jpg" alt=""> 
<br> 
<p></p> 
<p>【<strong>举例详解</strong>】</p> 
<p>有如下指令：</p> 
<p>0x000 ： irmovl  $0x100, %ebx</p> 
<p>0x006 ： irmovl  $0x200, %edx</p> 
<p>0x00c ： addl    %edx, %ebx</p> 
<p>0x00e ： je  dest</p> 
<p>0x013 ： rmmovl  %ebx, 0(%edx)</p> 
<p>0x019 ： dest: halt </p> 
<p> </p> 
<p>在我们的SEQ处理器中，一个时钟周期(即两次高电平时间的时间间隔)执行一条指令。</p> 
<p> <img src="https://images2.imgbox.com/0c/fe/CiXqRGkI_o.jpg" alt=""></p> 
<p></p> 
<p>时钟周期3开始时(点1处)，一个高电平打入，地址0x00c载入程序计数器PC中。这样，与PC相连的MCU(主存控制单元)就在内存中把地址0x00c处的addl指令提取出来，加载到指令存储器中。（从内存中读取数据很慢，这个过程会很久，所以我们的时钟周期要很长，才能做到一个时钟周期执行一条指令）同时，PC的值加上addl指令的长度，得出新PC值，新PC值通过总线传播，等待下次高电平时写入PC。</p> 
<p> </p> 
<p>组合逻辑<u>指令存储器中的输入一变化，值(addl指令)就通过逻辑门网络传播。</u>故，瞬间读出了寄存器文件中%edx、%ebx的值（因为读寄存器文件不需要高电平触发）</p> 
<p> </p> 
<p>读出的%edx、%ebx的值瞬间流动到组合逻辑ALU中，ALU根据之前传播的addl指令，知道此为加法指令，瞬间计算出这两个值的结果valE。valE通过总线传播瞬间到达寄存器文件，但是此时还不能向寄存器文件写入，必须等待下次的高电平。</p> 
<p>故此时，寄存器文件和存储器中保存的还都是上条指令的结果值。（点1、2处）</p> 
<p> </p> 
<p>时钟周期4开始时(点3处)，一个高电平打入，上周期产生的新PC值写入程序计数器，上周期计算得到的addl的结果valE值写入寄存器文件中的%ebx中。</p> 
<p>因为地址0x00e载入了程序计数器中，故会取出并执行跳转指令je。因为条件码ZF为0，所以不会选择分支。在这个周期末尾(点4)，程序计数器已经产生了新值0x013。但是直到下个周期开始之前，寄存器和存储器中的状态还是保持着addl指令设置的值。</p> 
<p> </p> 
<p>【如此例所示，用时钟来控制状态元素的更新，以及值通过组合逻辑来传播，足够控制我们SEQ实现中每条指令执行的计算了。每次时钟由低变高时，处理器开始执行一条新指令。】</p> 
<p> </p> 
<p>【<strong>读操作沿着这些单元传播，就好像它们是组合逻辑，而写操作是由时钟控制的。</strong>】</p> 
<p> </p> 
<p><span style="font-size:18px">【<strong>注意</strong>】（个人理解）</span></p> 
<p>早期的没有流水线的CPU可不是一个周期执行一条指令，我们的SEQ处理器只不过是为了讲解CPU的时序而特意做成的一个周期执行一条指令，这样做，使得一个时钟周期的时间特别长（因为我们要等主存把指令加载到指令寄存器，有的指令还要等待数据寄存器把数据写入到主存）。</p> 
<p> </p> 
<p>若按照执行时间最长的指令的执行时间作为时钟周期，则时钟的粒度太大，因为不同的指令需要的执行时间不同，时钟粒度太大会导致有些指令早早执行完毕，但CPU还得闲着，等待本周期结束。（我们的六步划分是针对所有指令整体而言的，很多指令只经历其中几步）</p> 
<p> </p> 
<p>故早期的CPU设计者，把由一个大组合逻辑完成的执行，分割成几个阶段，由几个小组合逻辑完成。中间插入寄存器保存中间结果，就像后面讲的流水线机制那样，只是指令顺序进入，一条指令运行完，下条指令才开始进入。</p> 
<p>这样做的好处是，由于各种指令涉及的阶段不同，有的指令经历较少的阶段就完成了，有的指令要经历较多的阶段，运行一条指令所需的时间不同了，小于等于最耗时指令的时间。（而我们设计的SEQ处理器每条指令都要经历同样的大组合逻辑，时钟周期只能定为最耗时指令的时间）</p> 
<p>[类比内存管理的分页机制，提高内存利用率。]</p> 
<p> </p> 
<p>1978年的Intel 8086，需要多个(通常是3~10个)时钟周期来执行一条指令。比较先进的处理器可以保持每个时钟2~4条指令的执行速率。其实每条指令从开始到结束需要长的多的时间，大约20个或者更多的周期，但是处理器使用了非常多的聪明技巧来同时处理多达100条的指令。</p> 
<p> </p> 
<p><br> </p> 
<p>---------------------------------------------------------------------------------------分割线-------------------------------------------------------------------------------------------</p> 
<p><br> </p> 
<p><br> </p> 
<h2><span style="color:red">流水线原理</span></h2> 
<p><br> </p> 
<p><span style="font-family:Microsoft YaHei">我们通过将执行每条指令所需的步骤组织成一个统一的流程，就可以用很少量的各种硬件单元以及一个时钟来控制计算的顺序，从而实现整个处理器。不过这样一来，控制逻辑就必须要在这些单元之间路由信号，并根据指令类型和分支条件产生适当的控制信号。（CPU内有三种总线：控制总线、地址总线、数据总线）</span></p> 
<p> </p> 
<p>SEQ处理器不能充分利用硬件单元，因为每个单元只在整个时钟周期的一部分时间内才被使用。我们会看到引入流水线能获得更好的性能。</p> 
<p> </p> 
<p><span style="font-size:18px"><strong>在流水线化的系统中，待执行的任务被划分成了若干独立的阶段</strong>。</span></p> 
<p><span style="font-size:18px">例如在汽车清洗中，这些阶段包括喷水、打肥皂、擦洗、上蜡和烘干。通常都会允许多个顾客同时经过系统，而不是要等到一个用户完成了所有从头至尾的过程才让下一个开始。</span></p> 
<p><span style="font-size:18px">当前面一辆汽车从喷水阶段进入擦洗阶段时，下一辆就可以进入喷水阶段了。通常，汽车必须以相同的速度通过这个系统，以避免撞车。</span></p> 
<p> </p> 
<p><span style="color:#ff0000">流水线化的一个重要特性就是<strong><u>增加了系统的吞吐量</u></strong></span>，也就是单位时间内服务的顾客总数，不过它<strong>也会轻微地增加延迟</strong>，也就是服务一个用户所需要的时间。（例如一个只需要喷水的汽车，在非流水线的系统，它喷完水就可以走了。而在流水线化的系统，不管你是什么需求，都要走完整个流程的时间）</p> 
<p> </p> 
<p>（我们之前的设计是一条指令执行完，下条指令才能进入CPU，（所不同的是时钟周期的粒度）。流水线化是允许多条指令在CPU中，每条指令在CPU中的时间是一样的，哪怕你一个周期就执行完了，你也得等剩下的阶段结束，使后面的指令被延迟了。</p> 
<p>虽然流水线化，所有指令在CPU中待的时间都一样（且都按最耗时指令算的），但它们的时间是重叠的。假设一条指令在CPU中待6ms，那么12ms能处理7条指令，而非流水线，虽然一条指令最多执行6ms，但它们的时间是相加的，12ms可能只执行3条。12=6+2+4）</p> 
<p> </p> 
<p>【例如】</p> 
<p>一个简单地<u>非流水化</u>的硬件系统：</p> 
<p>它是由一些执行计算的逻辑以及一个保存计算结果的寄存器组成的。时钟信号控制在每个特定的时间间隔加载寄存器。</p> 
<p>（CD播放器中的译码器就是这样的一个系统。输入信号是从CD表面读出的位，逻辑电路对这些位进行译码，产生音频信号。图中的计算块是用组合逻辑来实现的，意味着信号会穿过一系列逻辑门，在一定时间的延迟之后，输出就成为了输入的某个函数）</p> 
<img src="https://images2.imgbox.com/cc/41/2nND4Eqn_o.jpg" alt=""> 
<br> 
<p></p> 
<p>在这个例子中，我们假设组合逻辑需要300ps，而加载寄存器需要20ps。这个实现中，在开始下一条指令之前必须完成前一个。执行一条指令需要320ps，即每秒钟系统吞吐量3.12GIPS。</p> 
<p> </p> 
<p><span style="font-family:Microsoft YaHei; font-size:18px"><u>流水化</u>的硬件系统</span></p> 
<p>假设将系统执行的计算分成三个阶段（A、B和C），每个阶段需要100ps，如图所示、然后在各个阶段之间放上<strong>流水线寄存器</strong>，这样每条指令都会按照三步经过这个系统，从头到尾需要三个时钟周期。</p> （流水线寄存器的作用：作为电路不同部分中的 
<strong>组合逻辑之间的屏障</strong>。保存每步组合逻辑的运算结果。这是为了分割流水而插入的寄存器。） 
<br> 
<p><img src="https://images2.imgbox.com/ba/d5/PW89eVia_o.jpg" alt=""><br> </p> 
<p><img src="https://images2.imgbox.com/87/36/Agg0FTYT_o.jpg" alt=""><br> </p> 
<p></p> 
<p>流水线，在稳定状态下，三个阶段应该都是活动的，每个时钟周期，一条指令离开系统，一条新的进入。</p> 
<p>这样，我们一个阶段的时间，相当于运行了一条指令，在这个系统中，我们将时钟周期设为100+20=120ps，得到的吞吐量大约为8.33GIPS。（这是在）</p> 
<p>因为处理一条指令需要3个时钟周期，所以这条流水线的延迟就是3*120=360ps。非流水运行一条完整指令需要320ps。</p> 
<p>（从宏观整体上看，一个时钟周期运行了一条指令（这条指令是由多条指令的各阶段拼合的），而从单条指令的执行看，需要3个时钟周期执行一条完整指令。）</p> 
<p> </p> 
<p>我们将系统吞吐量提高到原来的8.33/3.12=2.67倍，代价是增加一些硬件（流水线寄存器），以及延迟的少量增加（360/320=1.12）。延迟变大是由于增加的流水线寄存器的时间开销。</p> 
<p>时钟周期的时间就是流水线分割的一个阶段的时间，这样，从宏观上看，是一个时钟周期执行一条指令。</p> 
<p><strong>【注意】</strong></p> 
<p>如果时钟运行得太快，就会有灾难性的后果。值可能会来不及通过组合逻辑，并且当时钟上升时，寄存器的输入还不是合法的值。（即时钟周期比流水线一个阶段的时间短）</p> 
<p>而我们减缓时钟不会影响流水线的行为。信号传播到流水线寄存器的输入，但是直到时钟上升时才会改变寄存器的状态。（即时钟周期比流水线一个阶段的时间长）</p> 
<p>故，我们通过改变倍频器的值来提高时钟频率的超频手段，其提高是有限的。</p> 
<p> </p> 
<h4><span style="font-family:Microsoft YaHei; font-size:24px">流水线的局限性</span></h4> 
<p><span style="font-size:18px"><br> </span></p> 
<p><span style="font-size:18px">1、<strong>不一致的划分</strong></span></p> 
<p>之前的是一个理想的流水线化的系统，每个阶段需要的时间都相同。而实际系统通过各阶段的延迟一般是不同的。且运行时钟的速率是由最慢阶段的延迟限制的。（即系统吞吐量受最慢阶段的速度所限制）</p> 
<p> </p> 
<p><span style="font-size:18px">2、<strong>流水线过深，收益反而下降</strong></span></p> 
<p>例如，我们把计算分成6个阶段，每个阶段需要50ps。在每对阶段之间插入流水线寄存器就得到了一个六阶段流水线。</p> 
<p>这个系统的最小时钟周期为50+20=70ps，吞吐量为14.29GIPS。性能比3阶段流水提高了14.29/8.33=1.71倍。由于通过流水线寄存器的延迟，吞吐量并没有加倍。这个延迟成了流水线吞吐量的一个制约因素。</p> 
<p> </p> 
<p>为了提高时钟频率，现代处理器采用了很深的（15或更多的阶段）流水线。</p> 
<p> </p> 
<h4><span style="font-size:24px">分支预测</span></h4> 
<p><br> </p> 
<p>流水线化设计的目的就是每个时钟周期都发射一条新指令，要做到这一点，我们必须在取出当前指令之后，马上确定下一条指令的位置。</p> 
<p>但如果取出的指令是<strong>条件分支指令</strong>，要到几个周期后，也就是指令通过执行阶段之后，我们才能知道是否要选择分支。类似的，如果取出的指令是<strong>ret</strong>，要到指令通过访存阶段，才能确定返回地址。</p> 
<p> </p> 
<p>对条件转移来说，我们既可以<u>预测</u>选择了分支，那么新PC值应为valC，也可以<u>预测</u>没有选择分支，那么新PC值应为valP。</p> 
<p>对ret指令，可能的返回值几乎是无限的，因为返回地址位于栈顶的字，其内容可以是任意的。在设计中，我们不会试图对返回地址做任何预测。只是简单地暂停处理新指令，直到ret指令通过写回阶段。</p> 
<p> </p> 
<p>无论哪种情况，我们都必须以某种方式来处理预测错误的情况，因为此时已经取出并部分执行了错误的指令。</p> 
<p>（流水线惩罚待写）</p> 
<p> </p> 
<h4><span style="font-size:24px"><span style="color:#ff0000">流水线冒险</span></span></h4> 
<p><br> </p> 
<p>使用流水线技术，当<u>相邻指令间存在相关时</u>会导致出现问题。</p> 
<p>这些相关有：</p> 
<p>1、数据相关：下一条指令会用到这一条指令计算出的结果</p> 
<p>2、控制相关：一条指令要确定下一条指令的位置，例如在执行跳转、调用或返回指令时。</p> 
<p>这些相关可能会导致流水线产生计算错误，称为<strong>冒险</strong>。</p> 
<p> </p> 
<h4><span style="font-size:24px">用<u><span style="color:red">暂停</span></u>来避免数据冒险</span></h4> 
<p>暂停(stalling)是避免冒险的一种常用技术。让一条指令停顿在译码阶段，直到产生它的源操作数的指令通过了写回阶段，这样我们的处理器就能避免数据冒险。</p> 
<p><strong>暂停技术就是让一组指令阻塞在它们所处的阶段，而允许其他指令继续通过流水线</strong>。</p> 
<p>【例】</p> 
<p>irmovl  $10, %edx</p> 
<p>irmovl  $3, %eax</p> 
<p>addl   %edx, %eax</p> 
<p>halt</p> 
<p> </p> 
<p><u>当对addl指令译码之后，暂停控制逻辑发现了对两个源寄存器的数据冒险</u>。（其发现前面的执行、访存或写回阶段中至少有一条指令会更新寄存器%edx或%eax 我们addl下一阶段就要取%eax和%edx的值，但却不能保证其是更新过的值）</p> 
<p><span style="color:#ff0000"><u>暂停控制逻辑就在执行阶段中插入一个气泡，并在下个周期重复对addl的译码</u>。</span></p> 
<p>它再次发现对两个源寄存器的冒险，就在执行阶段中插入一个气泡，并在下个周期重复对addl的译码。</p> 
<p>实际上，机器是动态地插入3条nop指令。（插到执行阶段，而不是从取指开始）</p> 
<p>irmovl  $10, %edx</p> 
<p>irmovl  $3, %eax</p> 
<p><em>bubble</em></p> 
<p><em>bubble</em></p> 
<p><em>bubble</em></p> 
<p>addl   %edx, %eax</p> 
<p>halt</p> 
<p>（这个过程就像，排队的时候前面的人前进了一步，但这时有另一个人插在了你前面的空缺中，你的位置保持不动，但前面的人都前进了一步。不断的有空缺，但不断地有人插入，你就一直在原地不动）</p> 
<p>当确定前面的指令已经更新过了我们要的两个寄存器的值，则addl开始前行。</p> 
<p> </p> 
<p>但是这样的解决方案得到的性能并不好，一条指令更新一个寄存器，紧跟其后的指令就使用被更新的寄存器，像这样的情况不胜枚举。<strong>这会导致流水线暂停长达三个周期，严重降低了整体的吞吐量</strong>。</p> 
<p> </p> 
<h4><span style="font-size:24px">用<u><span style="color:red">转发</span></u>来避免数据冒险</span></h4> 
<p><br> </p> 
<p>在译码阶段从寄存器文件中读入源操作数，但是对这些源寄存器的写有可能要在写回阶段才能进行。<span style="color:#ff0000"><strong>与其暂停直到写完成，不如简单地将要写的值传到流水线寄存器E作为源操作数</strong>。</span></p> 
<p>（即，我们不必等到irmovl  $10, %edx和irmovl  $3, %eax 完成对寄存器的写更新之后再继续addl，而是在addl译码阶段发现需要%edx、%eax值，译码逻辑不从寄存器文件中去读，而是用前面阶段未写入寄存器的值。）</p> 这种将结果直接从一个流水线阶段传到较早阶段的技术称为 
<strong>数据转发</strong>。 
<br> 
<p><img src="https://images2.imgbox.com/89/19/RSNDpeum_o.jpg" alt=""><br> </p> 
<p></p> 
<p>在周期4中，译码阶段逻辑发现有在访存阶段中对寄存器%edx未进行的写，还发现在执行阶段中正在计算寄存器%eax的新值。它用这些值，而不是从寄存器文件中读出的值，作为valA和valB的值。</p> 
<p> </p> 
<h4><span style="font-size:24px">加载/使用数据冒险</span></h4> 
<p><br> </p> 
<p>有一类数据冒险不能单纯用转发来解决，<u>因为存储器读(访存阶段)在流水线发生的比较晚</u>。</p> 
<p>例：</p> 
<p>mrmovl  0(%edx), %eax</p> 
<p>addl  %ebx, %eax</p> 
<p>halt</p> 
<p>指令mrmovl读取存储器0(%edx)处的值，发生在访存阶段，而此时指令addl已经在执行阶段了！其已经读取了%eax的值了。即由于mrmovl指令获取的操作数值比较晚，来不及发送给后面需要用的指令了。</p> 
<p>我们可以<strong>将暂停和转发结合起来，避免加载/使用数据冒险</strong>。（既然是来不及发送给后面的指令，那就让后面的指令暂停几个周期，再发送）</p> 
<p> </p> 
<p>当mrmovl指令通过执行阶段时，<u>流水线控制逻辑</u>发现译码阶段中的指令(addl)需要从存储器中读出的结果。它会将译码阶段中的addl指令暂停一个周期，导致执行阶段中插入一个气泡。 mrmovl指令从存储器中读出的值可以从访存阶段转发到译码阶段中的addl指令。</p> 
<p> </p> 
<p>这种用暂停来处理加载/使用冒险的方法称为<strong>加载互锁</strong>。<u>加载互锁和转发技术结合起来足以处理所有可能类型的数据冒险</u>。</p> 
<p> </p> 
<h4><span style="font-size:24px">异常处理</span></h4> 
<p><br> </p> 
<p>异常可以由程序执行从内部产生，也可以由某个外部信号从外部产生。</p> 
<p>简单的三种内部异常：</p> 
<p>1、halt指令</p> 
<p>2、非法指令</p> 
<p>3、访问非法地址</p> 
<p>（还有一些外部异常：网口收到新包、用户点击鼠标等）</p> 
<p> </p> 
<p><u>在简化的ISA模型中</u>，当处理器遇到异常时，会停止，设置适当的状态码，且应该是到异常指令之前的所有指令都已经完成，而其后的指令都不应该对程序员可见的状态产生任何影响。</p> 
<p>在一个更完整的设计中，处理器会继续调用异常处理程序，这是操作系统的一部分。</p> 
<p> </p> 
<p>★一般地，通过在流水线结构中加入异常处理逻辑，我们会<strong>在每个流水线寄存器中包括一个状态码Stat</strong>。如果一条指令在其处理器中于某个阶段产生了一个异常，这个状态字段就被设置成指示异常的种类。</p> 
<p><strong>异常状态和该指令的其他信息一起沿着流水线传播，直到它到达写回阶段</strong>。在此，流水线控制逻辑发现了异常，并停止执行。</p> 
<p> </p> 
<p>异常事件不会对流水线中的指令流有任何影响，除了<u>会禁止流水线中后面的指令更新程序员的可见状态</u>（条件码寄存器和存储器），直到异常指令到达最后的流水线阶段。</p> 
<p>因为指令到达写回阶段的顺序与它们在非流水化的处理器中执行的顺序相同，所以我们可以保证第一条遇到异常的指令会第一个到达写回阶段，此时程序执行会停止，流水线寄存器(W写回)中的状态码会被记录为程序状态。</p> 
<p> </p> 
<h4><span style="font-size:24px">其他问题</span></h4> 
<h6><span style="font-size:24px">多周期指令</span></h6> 
<p>我们之前设计的处理器指令集中的所有指令都包括一些简单的操作，例如数字加法。这些操作可以在执行阶段中一个周期内处理完。</p> 
<p>在一个更完整的指令集中，还有整数乘法除法、以及浮点运算。在我们之前设计的流水化处理器中，浮点加法需要3、4个周期，整数除法需要32个周期。</p> 
<p> </p> 
<p>实现多周期指令的一种简单方法就是简单地<u>扩展执行阶段逻辑</u>的功能，添加一些整数和浮点算数运算单元。一条指令在执行阶段中逗留它所需要的多个时钟周期，会导致取指和译码阶段暂停。这种方法实现起来很简单，但是得到的性能并不是太好。</p> 
<p> </p> 
<p>通过采用独立于主流水线的特殊硬件功能单元来处理较为复杂的操作，可以得到更好的性能。通常，有一个功能单元来执行整数乘法和除法，还有一个来执行浮点操作(<strong>协处理器</strong>)。</p> 
<p><strong>当一条指令进入到译码阶段时，它可以被发射到特殊单元</strong>。<u>在这个特殊单元执行该操作时，流水线会继续处理其他指令。通常，浮点单元本身也是流水线化的，因此多条指令可以在主流水线和各个单元中并行执行</u>。</p> 
<p> </p> 
<p>不同单元的操作必须同步，以避免出错。</p> 
<p>如果在不同单元执行的各个指令之间有数据相关，控制逻辑可能需要暂停系统的某个部分，直到由系统其他部分处理的操作的结果完成。</p> 
<p><u>使用各种形式的转发，将结果从系统的一部分传递到其他部分，这和前面的PIPE流水线各个阶段之间的转发一样</u>。虽然与PIPE相比，整个设计变得更复杂，但还是可以使用暂停、转发、以及流水线控制等同样的技术，使整体行为与顺序的ISA模型相匹配。</p> 
<p> </p> 
<h6><span style="font-size:24px">与存储系统的接口</span></h6> 
<p>在我们之前的流水化CPU中，我们假设取指单元和数据存储器都可以在一个时钟周期内读或是写存储器中任意的位置。</p> 
<p>但是，<u>实际情况是，我们以存储器位置的虚拟地址来引用数据，这就要求在执行实际的读写操作之前，要将虚拟地址翻译成物理地址。显然，要在一个时钟周期内完成所有这些处理是不现实的</u>。更糟糕的是，要访问的存储器的的值可能位于磁盘上，这会需要上百万个时钟周期才能把数据读入到处理器存储器中。</p> 
<p> </p> 
<h6><span style="font-size:24px">存储系统：</span></h6> 
<p>CPU的存储系统是由多种<u>硬件存储器</u>和管理虚拟存储器的<u>操作系统</u>软件共同组成的。</p> 
<p>存储系统被组织成一个层次结构，<strong>较快但是较小的存储器保持着存储器的一个子集</strong>，而较慢但是较大的存储器作为它的后备。</p> 
<p>最靠近处理器的一层是高速缓存(cache)存储器，它提供对最常使用的存储器位置的快速访问。一般有2个一层cache——一<u>个用于读指令，一个用于读写数据</u>。</p> 
<p>还有另一种类型的高速缓存存储器，称为<strong>TLB</strong>(Translation Look-aside Buffer翻译后备缓冲器)，<strong>它提供了从虚拟地址到物理地址的快速翻译</strong>。</p> 
<p><u>将TLB和cache结合起来使用，在大多数时候，确实可能在一个时钟周期内读指令并读或是写数据</u>。</p> 
<p> </p> 
<p>缓存不命中：有些引用的位置不在高速缓存中，即出现高速缓存不命中。在最好的情况下，可以冲=从较高层的cache或处理器的主存中找到不命中的数据，这需要3--20个时钟周期。同时，流水线会简单地暂停，将指令保持在取值或访存阶段，直到高速缓存能够执行读或写操作。</p> 
<p> </p> 
<p>缺页异常：当被引用的存储器位置实际上是在磁盘存储器上的，硬件会产生一个缺页异常信号。同其他异常一样，这个异常会导致处理器调用操作系统的异常处理程序代码。然后这段代码会发起一个从磁盘到主存的传送操作。</p> 
<p><u>让硬件调用操作系统例程，然后操作系统例程又会将控制返回给硬件，这就使得硬件和系统软件在处理缺页时能协同工作</u>。</p> 
<p> </p> 
<p>从处理器的角度来看，将用暂停来处理短时间的高速缓存不命中和用异常处理来处理长时间的缺页结合起来，能够顾及到存储器访问时由于存储器层次结构引起的所有不可预测性。</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<br> 
<br> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/20dfb733c12f712583f6ad0206d0a53e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Celery(bind=True) 修饰实例方法和类方法时怎么传参, self问题.</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/08f3b46600fffb865f883e41120c1cdd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java.sql.SQLException: Unknown type &#39;246 in column 4 of 11 in binary-encoded result set.</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>