<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32中文手册解读（2） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32中文手册解读（2）" />
<meta property="og:description" content="GPIO简介
GPIO 是通用输入输出端口的简称，简单来说就是 STM32 可控制的引脚，STM32 芯片
的 GPIO 引脚与外部设备连接起来，从而实现与外部通讯、控制以及数据采集的功能。
STM32 芯片的 GPIO 被分成很多组，每组有 16 个引脚，如型号为 STM32F103VET6 型号的
芯片有 GPIOA、GPIOB、GPIOC 至 GPIOE 共 5 组 GPIO，芯片一共 100 个引脚，其中
GPIO 就占了一大部分，所有的 GPIO 引脚都有基本的输入输出功能。
最基本的输出功能是由 STM32 控制引脚输出高、低电平，实现开关控制，如把 GPIO
引脚接入到 LED 灯，那就可以控制 LED 灯的亮灭，引脚接入到继电器或三极管，那就可
以通过继电器或三极管控制外部大功率电路的通断。
基本结构分析
下面我们按图中的编号对 GPIO 端口的结构部件进行说明。
1. 保护二极管及上、下拉电阻
引脚的两个保护二级管可以防止引脚外部过高或过低的电压输入，当引脚电压高于
VDD 时，上方的二极管导通，当引脚电压低于 VSS 时，下方的二极管导通，防止不正常电
压引入芯片导致芯片烧毁。尽管有这样的保护，并不意味着 STM32 的引脚能直接外接大功
率驱动器件，如直接驱动电机，强制驱动要么电机不转，要么导致芯片烧坏，必须要加大
功率及隔离电路驱动。
2. P-MOS 管和 N-MOS 管
GPIO 引脚线路经过两个保护二极管后，向上流向“输入模式”结构，向下流向“输出
模式”结构。先看输出模式部分，线路经过一个由 P-MOS 和 N-MOS 管组成的单元电路。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/c842260ca14a29676edecf863948816c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-10T18:12:13+08:00" />
<meta property="article:modified_time" content="2020-06-10T18:12:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32中文手册解读（2）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>GPIO简介</strong><br> GPIO 是通用输入输出端口的简称，简单来说就是 STM32 可控制的引脚，STM32 芯片<br> 的 GPIO 引脚与外部设备连接起来，从而实现与外部通讯、控制以及数据采集的功能。<br> STM32 芯片的 GPIO 被分成很多组，每组有 16 个引脚，如型号为 STM32F103VET6 型号的<br> 芯片有 GPIOA、GPIOB、GPIOC 至 GPIOE 共 5 组 GPIO，芯片一共 100 个引脚，其中<br> GPIO 就占了一大部分，所有的 GPIO 引脚都有基本的输入输出功能。<br> 最基本的输出功能是由 STM32 控制引脚输出高、低电平，实现开关控制，如把 GPIO<br> 引脚接入到 LED 灯，那就可以控制 LED 灯的亮灭，引脚接入到继电器或三极管，那就可<br> 以通过继电器或三极管控制外部大功率电路的通断。</p> 
<p><strong>基本结构分析</strong><br> 下面我们按图中的编号对 GPIO 端口的结构部件进行说明。<br> <img src="https://images2.imgbox.com/1e/fd/xfdLmEYo_o.jpg" alt="在这里插入图片描述GPIO框图"></p> 
<p><strong>1. 保护二极管及上、下拉电阻</strong><br> 引脚的两个保护二级管可以防止引脚外部过高或过低的电压输入，当引脚电压高于<br> VDD 时，上方的二极管导通，当引脚电压低于 VSS 时，下方的二极管导通，防止不正常电<br> 压引入芯片导致芯片烧毁。尽管有这样的保护，并不意味着 STM32 的引脚能直接外接大功<br> 率驱动器件，如直接驱动电机，强制驱动要么电机不转，要么导致芯片烧坏，必须要加大<br> 功率及隔离电路驱动。<br> <strong>2. P-MOS 管和 N-MOS 管</strong><br> GPIO 引脚线路经过两个保护二极管后，向上流向“输入模式”结构，向下流向“输出<br> 模式”结构。先看输出模式部分，线路经过一个由 P-MOS 和 N-MOS 管组成的单元电路。<br> 这个结构使 GPIO 具有了“推挽输出”和“开漏输出”两种模式。<br> 所谓的推挽输出模式，是根据这两个 MOS 管的工作方式来命名的。在该结构中输入<br> 高电平时，经过反向后，上方的 P-MOS 导通，下方的 N-MOS 关闭，对外输出高电平；而<br> 在该结构中输入低电平时，经过反向后，N-MOS 管导通，P-MOS 关闭，对外输出低电平。<br> 当引脚高低电平切换时，两个管子轮流导通，P 管负责灌电流，N 管负责拉电流，使其负<br> 载能力和开关速度都比普通的方式有很大的提高。推挽输出的低电平为 0 伏，高电平为 3.3<br> 伏，它是推挽输出模式时的等效电路。<br> 而在开漏输出模式时，上方的 P-MOS 管完全不工作。如果我们控制输出为 0，低电平，<br> 则 P-MOS 管关闭，N-MOS 管导通，使输出接地，若控制输出为 1 (它无法直接输出高电平)<br> 时，则 P-MOS 管和 N-MOS 管都关闭，所以引脚既不输出高电平，也不输出低电平，为高<br> 阻态。为正常使用时必须外部接上拉电阻，参考图 8-3 中等效电路。它具有“线与”特性，<br> 也就是说，若有很多个开漏模式引脚连接到一起时，只有当所有引脚都输出高阻态，才由<br> 上拉电阻提供高电平，此高电平的电压为外部上拉电阻所接的电源的电压。若其中一个引<br> 脚为低电平，那线路就相当于短路接地，使得整条线路都为低电平，0 伏。<br> 推挽输出模式一般应用在输出电平为 0 和 3.3 伏而且需要高速切换开关状态的场合。 在 STM32 的应用中，除了必须用开漏模式的场合，我们都习惯使用推挽输出模式。<br> 开漏输出一般应用在 I2C、SMBUS 通讯等需要“线与”功能的总线电路中。除此之外，<br> 还用在电平不匹配的场合，如需要输出 5 伏的高电平，就可以在外部接一个上拉电阻，上 拉电源为 5 伏，并且把 GPIO 设置为开漏模式，当输出高阻态时，由上拉电阻和电源向外<br> 输出 5 伏的电平<br> <strong>3. 输出数据寄存器</strong><br> 前面提到的 双 MOS 管结构电路的输入信号，是由 GPIO“输出数据寄存 器<br> GPIOx_ODR”提供的，因此我们通过修改输出数据寄存器的值就可以修改 GPIO 引脚的输<br> 出电平。而“置位/复位寄存器 GPIOx_BSRR”可以通过修改输出数据寄存器的值从而影响<br> 电路的输出。<br> <strong>4. 复用功能输出</strong><br> “复用功能输出”中的“复用”是指 STM32 的其它片上外设对 GPIO 引脚进行控制，<br> 此时 GPIO 引脚用作该外设功能的一部分，算是第二用途。从其它外设引出来的“复用功<br> 能输出信号”与 GPIO 本身的数据据寄存器都连接到双 MOS 管结构的输入中，通过图中的<br> 梯形结构作为开关切换选择。<br> 例如我们使用 USART 串口通讯时，需要用到某个 GPIO 引脚作为通讯发送引脚，这个<br> 时候就可以把该 GPIO 引脚配置成 USART 串口复用功能，由串口外设控制该引脚，发送数<br> 据<br> <strong>5. 输入数据寄存器</strong><br> 看 GPIO 结构框图的上半部分，GPIO 引脚经过内部的上、下拉电阻，可以配置成上/<br> 下拉输入，然后再连接到施密特触发器，信号经过触发器后，模拟信号转化为 0、1 的数字<br> 信号，然后存储在“输入数据寄存器 GPIOx_IDR”中，通过读取该寄存器就可以了解<br> GPIO 引脚的电平状态。<br> <strong>6. 复用功能输入</strong><br> 与“复用功能输出”模式类似，在“复用功能输入模式”时，GPIO 引脚的信号传输到<br> STM32 其它片上外设，由该外设读取引脚状态。<br> 同样，如我们使用 USART 串口通讯时，需要用到某个 GPIO 引脚作为通讯接收引脚，<br> 这个时候就可以把该 GPIO 引脚配置成 USART 串口复用功能，使 USART 可以通过该通讯<br> 引脚的接收远端数据。<br> <strong>7. 模拟输入输出</strong><br> 当 GPIO 引脚用于 ADC 采集电压的输入通道时，用作“模拟输入”功能，此时信号是<br> 不经过施密特触发器的，因为经过施密特触发器后信号只有 0、1 两种状态，所以 ADC 外<br> 设要采集到原始的模拟信号，信号源输入必须在施密特触发器之前。类似地，当 GPIO 引<br> 脚用于 DAC 作为模拟电压输出通道时，此时作为“模拟输出”功能，DAC 的模拟信号输<br> 出就不经过双 MOS 管结构，模拟信号直接输出到引脚</p> 
<p>**</p> 
<h3><a id="GPIO__76"></a>GPIO 工作模式</h3> 
<p>**<br> 总结一下，由 GPIO 的结构决定了 GPIO 可以配置成以下模式</p> 
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token keyword">typedef</span> <span class="token keyword">enum</span>
<span class="token number">2</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">3</span> GPIO_Mode_AIN <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">,</span>                      <span class="token comment">// 模拟输入</span>
<span class="token number">4</span> GPIO_Mode_IN_FLOATING <span class="token operator">=</span> <span class="token number">0x04</span><span class="token punctuation">,</span>             <span class="token comment">// 浮空输入</span>
<span class="token number">5</span> GPIO_Mode_IPD <span class="token operator">=</span> <span class="token number">0x28</span><span class="token punctuation">,</span>                     <span class="token comment">// 下拉输入</span>
<span class="token number">6</span> GPIO_Mode_IPU <span class="token operator">=</span> <span class="token number">0x48</span><span class="token punctuation">,</span>                     <span class="token comment">// 上拉输入</span>
<span class="token number">7</span> GPIO_Mode_Out_OD <span class="token operator">=</span> <span class="token number">0x14</span><span class="token punctuation">,</span>                  <span class="token comment">// 开漏输出</span>
<span class="token number">8</span> GPIO_Mode_Out_PP <span class="token operator">=</span> <span class="token number">0x10</span><span class="token punctuation">,</span>                  <span class="token comment">// 推挽输出</span>
<span class="token number">9</span> GPIO_Mode_AF_OD <span class="token operator">=</span> <span class="token number">0x1C</span><span class="token punctuation">,</span>                   <span class="token comment">// 复用开漏输出</span>
<span class="token number">10</span> GPIO_Mode_AF_PP <span class="token operator">=</span> <span class="token number">0x18</span>                   <span class="token comment">// 复用推挽输出</span>
<span class="token number">11</span> <span class="token punctuation">}</span> GPIOMode_TypeDef<span class="token punctuation">;</span>

</code></pre> 
<p>在固件库中，GPIO 总共有 8 种细分的工作模式，稍加整理可以大致归类为以下三类：<br> <strong>1. 输入模式(模拟/浮空/上拉/下拉)</strong><br> 在输入模式时，施密特触发器打开，输出被禁止，可通过输入数据寄存器 GPIOx_IDR<br> 读取 I/O 状态。其中输入模式，可设置为上拉、下拉、浮空和模拟输入四种。上拉和下拉<br> 输入很好理解，默认的电平由上拉或者下拉决定。浮空输入的电平是不确定的，完全由外<br> 部的输入决定，一般接按键的时候用的是这个模式。模拟输入则用于 ADC 采集。<br> <strong>2. 输出模式(推挽/开漏)</strong><br> 在输出模式中，推挽模式时双 MOS 管以轮流方式工作，输出数据寄存器 GPIOx_ODR<br> 可控制 I/O 输出高低电平。开漏模式时，只有 N-MOS 管工作，输出数据寄存器可控制 I/O<br> 输出高阻态或低电平。输出速度可配置，有 2MHz\10MHz\50MHz 的选项。此处的输出速<br> 度即 I/O 支持的高低电平状态最高切换频率，支持的频率越高，功耗越大，如果功耗要求<br> 不严格，把速度设置成最大即可。<br> 在输出模式时施密特触发器是打开的，即输入可用，通过输入数据寄存器 GPIOx_IDR<br> 可读取 I/O 的实际状态。<br> <strong>3. 复用功能(推挽/开漏)</strong><br> 复用功能模式中，输出使能，输出速度可配置，可工作在开漏及推挽模式，但是输出<br> 信号源于其它外设，输出数据寄存器 GPIOx_ODR 无效；输入可用，通过输入数据寄存器<br> 可获取 I/O 实际状态，但一般直接用外设的寄存器来获取该数据信号。<br> 通过对 GPIO 寄存器写入不同的参数，就可以改变 GPIO 的工作模式，再强调一下，<br> 要了解具体寄存器时一定要查阅《STM32F10X-中文参考手册》中对应外设的寄存器说明。<br> 在 GPIO 外设中，控制端口高低控制寄存器 CRH 和 CRL 可以配置每个 GPIO 的工作模式和<br> 工作的速度，每 4 个位控制一个 IO，CRH 控制端口的高八位，CRL 控制端口的低 8 位，<br> 具体的看 CRH 和 CRL 的寄存器描述。</p> 
<p><em><strong>学习 STM32 最好的方法是用固件库，然后在固件库的基础上了解底层，学习寄存器。</strong></em><br> <strong>什么是 STM32 函数库</strong><br> 以上所说的固件库是指“STM32 标准函数库”，它是由 ST 公司针对 STM32 提供的函<br> 数接口，即 API (Application Program Interface)，开发者可调用这些函数接口来配置 STM32<br> 的寄存器，使开发人员得以脱离最底层的寄存器操作，有开发快速，易于阅读，维护成本<br> 低等优点。<br> 当我们调用库 API 的时候不需要挖空心思去了解库底层的寄存器操作，就像当年我们<br> 刚开始学习 C 语言的时候，用 prinft()函数时只是学习它的使用格式，并没有去研究它的源<br> 码实现，但需要深入研究的时候，经过千锤百炼的库源码就是最佳学习范例。<br> 实际上，库是架设在寄存器与用户驱动层之间的代码，向下处理与寄存器直接相关的<br> 配置，向上为用户提供配置寄存器的接口。</p> 
<p><strong>外设寄存器结构体定义</strong><br> 上一章中我们在操作寄存器的时候，操作的是都寄存器的绝对地址，如果每个外设寄存器都这样操作，那将非常麻烦。我们考虑到外设寄存器的地址都是基于外设基地址的偏移地址，都是在外设基地址上逐个连续递增的，每个寄存器占 32 个字节，这种方式跟结构体里面的成员类似。<br> 所以我们可以定义一种外设结构体，结构体的地址等于外设的基地址，结构体的成员等于寄存器，成员的排列顺序跟寄存器的顺序一样。这样我们操作寄存器的时候就不用每次都找到绝对地址，只要知道外设的基地址就可以操作外设的全部寄存器，即操作结构体的成员即可。<br> 在工程中的“stm32f10x.h”文件中，我们使用结构体封装 GPIO 及 RCC 外设的的寄存<br> 器，见代码清单 9-1。结构体成员的顺序按照寄存器的偏移地址从低到高排列，成员类型<br> 跟寄存器类型一样。<br> 9-1 封装寄存器列表</p> 
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token comment">//寄存器的值常常是芯片外设自动更改的，即使 CPU 没有执行程序，也有可能发生变化</span>
<span class="token number">2</span> <span class="token comment">//编译器有可能会对没有执行程序的变量进行优化</span>
<span class="token number">3</span> 
<span class="token number">4</span> <span class="token comment">//volatile 表示易变的变量，防止编译器优化，</span>
<span class="token number">5</span> #define __IO <span class="token keyword">volatile</span>
<span class="token number">6</span> <span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> uint32_t<span class="token punctuation">;</span>
<span class="token number">7</span> <span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> uint16_t<span class="token punctuation">;</span>
<span class="token number">8</span> 
<span class="token number">9</span> <span class="token comment">// GPIO 寄存器结构体定义</span>
<span class="token number">10</span> <span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token number">11</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">12</span> __IO uint32_t CRL<span class="token punctuation">;</span> <span class="token comment">// 端口配置低寄存器， 地址偏移 0X00</span>
<span class="token number">13</span> __IO uint32_t CRH<span class="token punctuation">;</span> <span class="token comment">// 端口配置高寄存器， 地址偏移 0X04</span>
<span class="token number">14</span> __IO uint32_t IDR<span class="token punctuation">;</span> <span class="token comment">// 端口数据输入寄存器， 地址偏移 0X08</span>
<span class="token number">15</span> __IO uint32_t ODR<span class="token punctuation">;</span> <span class="token comment">// 端口数据输出寄存器， 地址偏移 0X0C</span>
<span class="token number">16</span> __IO uint32_t BSRR<span class="token punctuation">;</span> <span class="token comment">// 端口位设置/清除寄存器，地址偏移 0X10</span>
<span class="token number">17</span> __IO uint32_t BRR<span class="token punctuation">;</span> <span class="token comment">// 端口位清除寄存器， 地址偏移 0X14</span>
<span class="token number">18</span> __IO uint32_t LCKR<span class="token punctuation">;</span> <span class="token comment">// 端口配置锁定寄存器， 地址偏移 0X18</span>
<span class="token number">19</span> <span class="token punctuation">}</span> GPIO_TypeDef<span class="token punctuation">;</span>
</code></pre> 
<p>这段代码在每个结构体成员前增加了一个“__IO”前缀，它的原型在这段代码的第一<br> 行，代表了 C 语言中的关键字“volatile”，在 C 语言中该关键字用于表示变量是易变的，<br> 要求编译器不要优化。这些结构体内的成员，都代表着寄存器，而寄存器很多时候是由外<br> 设或 STM32 芯片状态修改的，也就是说即使 CPU 不执行代码修改这些变量，变量的值也<br> 有可能被外设修改、更新，所以每次使用这些变量的时候，我们都要求 CPU 去该变量的地<br> 址重新访问。若没有这个关键字修饰，在某些情况下，编译器认为没有代码修改该变量，<br> 就直接从 CPU 的某个缓存获取该变量值，这时可以加快执行速度，但该缓存中的是陈旧数<br> 据，与我们要求的寄存器最新状态可能会有出入。</p> 
<p><strong>外设存储器映射</strong><br> 外设寄存器结构体定义仅仅是一个定义，要想实现给这个结构体赋值就达到操作寄存<br> 器的效果，我们还需要找到该寄存器的地址，就把寄存器地址跟结构体的地址对应起来。<br> 所以我们要再找到外设的地址，根据我们前面的学习，我们可以把这些外设的地址定义成<br> 一个个宏，实现外设存储器的映射。</p> 
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token comment">/*片上外设基地址 */</span>
<span class="token number">2</span> #define PERIPH_BASE                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token number">0x40000000</span><span class="token punctuation">)</span>
<span class="token number">3</span> 
<span class="token number">4</span> <span class="token comment">/*APB2 总线基地址 */</span>
<span class="token number">5</span> #define APB2PERIPH_BASE            <span class="token punctuation">(</span>PERIPH_BASE <span class="token operator">+</span> <span class="token number">0x10000</span><span class="token punctuation">)</span>
<span class="token number">6</span> <span class="token comment">/* AHB 总线基地址 */</span>
<span class="token number">7</span> #define AHBPERIPH_BASE             <span class="token punctuation">(</span>PERIPH_BASE <span class="token operator">+</span> <span class="token number">0x20000</span><span class="token punctuation">)</span>
<span class="token number">8</span> 
<span class="token number">9</span> <span class="token comment">/*GPIO 外设基地址*/</span>
<span class="token number">10</span> #define GPIOA_BASE                <span class="token punctuation">(</span>APB2PERIPH_BASE <span class="token operator">+</span> <span class="token number">0x0800</span><span class="token punctuation">)</span>
<span class="token number">11</span> #define GPIOB_BASE                <span class="token punctuation">(</span>APB2PERIPH_BASE <span class="token operator">+</span> <span class="token number">0x0C00</span><span class="token punctuation">)</span>
<span class="token number">12</span> #define GPIOC_BASE                <span class="token punctuation">(</span>APB2PERIPH_BASE <span class="token operator">+</span> <span class="token number">0x1000</span><span class="token punctuation">)</span>
<span class="token number">13</span> #define GPIOD_BASE                <span class="token punctuation">(</span>APB2PERIPH_BASE <span class="token operator">+</span> <span class="token number">0x1400</span><span class="token punctuation">)</span>
<span class="token number">14</span> #define GPIOE_BASE                <span class="token punctuation">(</span>APB2PERIPH_BASE <span class="token operator">+</span> <span class="token number">0x1800</span><span class="token punctuation">)</span>
<span class="token number">15</span> #define GPIOF_BASE                <span class="token punctuation">(</span>APB2PERIPH_BASE <span class="token operator">+</span> <span class="token number">0x1C00</span><span class="token punctuation">)</span>
<span class="token number">16</span> #define GPIOG_BASE                <span class="token punctuation">(</span>APB2PERIPH_BASE <span class="token operator">+</span> <span class="token number">0x2000</span><span class="token punctuation">)</span>
<span class="token number">17</span> 
<span class="token number">18</span> <span class="token comment">/*RCC 外设基地址*/</span>
<span class="token number">19</span> #define RCC_BASE <span class="token punctuation">(</span>AHBPERIPH_BASE <span class="token operator">+</span> <span class="token number">0x1000</span><span class="token punctuation">)</span>
</code></pre> 
<p><strong>外设声明</strong><br> 定义好外设寄存器结构体，实现完外设存储器映射后，我们再把外设的基址强制类型<br> 转换成相应的外设寄存器结构体指针，然后再把该指针声明成外设名，这样一来，外设名<br> 就跟外设的地址对应起来了，而且该外设名还是一个该外设类型的寄存器结构体指针，通<br> 过该指针可以直接操作该外设的全部寄存器，见代码清单 9-2。</p> 
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token comment">// GPIO 外设声明</span>
<span class="token number">2</span> #define GPIOA <span class="token punctuation">(</span><span class="token punctuation">(</span>GPIO_TypeDef <span class="token operator">*</span><span class="token punctuation">)</span> GPIOA_BASE<span class="token punctuation">)</span>
<span class="token number">3</span> #define GPIOB <span class="token punctuation">(</span><span class="token punctuation">(</span>GPIO_TypeDef <span class="token operator">*</span><span class="token punctuation">)</span> GPIOB_BASE<span class="token punctuation">)</span>
<span class="token number">4</span> #define GPIOC <span class="token punctuation">(</span><span class="token punctuation">(</span>GPIO_TypeDef <span class="token operator">*</span><span class="token punctuation">)</span> GPIOC_BASE<span class="token punctuation">)</span>
<span class="token number">5</span> #define GPIOD <span class="token punctuation">(</span><span class="token punctuation">(</span>GPIO_TypeDef <span class="token operator">*</span><span class="token punctuation">)</span> GPIOD_BASE<span class="token punctuation">)</span>
<span class="token number">6</span> #define GPIOE <span class="token punctuation">(</span><span class="token punctuation">(</span>GPIO_TypeDef <span class="token operator">*</span><span class="token punctuation">)</span> GPIOE_BASE<span class="token punctuation">)</span>
<span class="token number">7</span> #define GPIOF <span class="token punctuation">(</span><span class="token punctuation">(</span>GPIO_TypeDef <span class="token operator">*</span><span class="token punctuation">)</span> GPIOF_BASE<span class="token punctuation">)</span>
<span class="token number">8</span> #define GPIOG <span class="token punctuation">(</span><span class="token punctuation">(</span>GPIO_TypeDef <span class="token operator">*</span><span class="token punctuation">)</span> GPIOG_BASE<span class="token punctuation">)</span>
<span class="token number">9</span> 
<span class="token number">10</span> 
<span class="token number">11</span> <span class="token comment">// RCC 外设声明</span>
<span class="token number">12</span> #define RCC <span class="token punctuation">(</span><span class="token punctuation">(</span>RCC_TypeDef <span class="token operator">*</span><span class="token punctuation">)</span> RCC_BASE<span class="token punctuation">)</span>
<span class="token number">13</span> 
<span class="token number">14</span> <span class="token comment">/*RCC 的 AHB1 时钟使能寄存器地址,强制转换成指针*/</span>
<span class="token number">15</span> #define RCC_APB2ENR <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>RCC_BASE<span class="token operator">+</span><span class="token number">0x18</span><span class="token punctuation">)</span>
</code></pre> 
<p>首先通过强制类型转换把外设的基地址转换成 GPIO_TypeDef 类型的结构体指针，然<br> 后通过宏定义把 GPIOA、GPIOB 等定义成外设的结构体指针，通过外设的结构体指针我们<br> 就可以达到访问外设的寄存器的目的。<br> 通过操作外设结构体指针的方式，我们把 main 文件里对应的代码修改掉，见代码 9-2<br> else 部分。<br> 使用寄存器结构体指针操作寄存器</p> 
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token comment">// 使用寄存器结构体指针点亮 LED</span>
<span class="token number">2</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token number">3</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">4</span> #<span class="token keyword">if</span> <span class="token number">0</span> <span class="token comment">// 直接通过操作内存来控制寄存器</span>
<span class="token number">5</span> <span class="token comment">// 开启 GPIOB 端口时钟</span>
<span class="token number">6</span> RCC_APB2ENR <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">7</span> 
<span class="token number">8</span> <span class="token comment">//清空控制 PB0 的端口位</span>
<span class="token number">9</span> GPIOB_CRL <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span> <span class="token number">0x0F</span><span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">*</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">10</span> <span class="token comment">// 配置 PB0 为通用推挽输出，速度为 10M</span>
<span class="token number">11</span> GPIOB_CRL <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token operator">*</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">12</span> 
<span class="token number">13</span> <span class="token comment">// PB0 输出 低电平</span>
<span class="token number">14</span> GPIOB_ODR <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">15</span> 
<span class="token number">16</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">17</span> 
<span class="token number">18</span> #<span class="token keyword">else</span> <span class="token comment">// 通过寄存器结构体指针来控制寄存器</span>
<span class="token number">19</span> 
<span class="token number">20</span> <span class="token comment">// 开启 GPIOB 端口时钟</span>
<span class="token number">21</span> RCC<span class="token operator">-&gt;</span>APB2ENR <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">22</span> 
<span class="token number">23</span> <span class="token comment">//清空控制 PB0 的端口位</span>
<span class="token number">24</span> GPIOB<span class="token operator">-&gt;</span>CRL <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span> <span class="token number">0x0F</span><span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">*</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">25</span> <span class="token comment">// 配置 PB0 为通用推挽输出，速度为 10M</span>
<span class="token number">26</span> GPIOB<span class="token operator">-&gt;</span>CRL <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token operator">*</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">27</span> 
<span class="token number">28</span> <span class="token comment">// PB0 输出 低电平</span>
<span class="token number">29</span> GPIOB<span class="token operator">-&gt;</span>ODR <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">&lt;&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">30</span> 
<span class="token number">31</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">32</span> 
<span class="token number">33</span> #endi
</code></pre> 
<p>乍一看，除了把“_”换成了“-&gt;”，其他都跟使用寄存器点亮 LED 那部分代码一样。<br> 这是因为我们现在只是实现了库函数的基础，还没有定义库函数。<br> 打好了地基，下面我们就来建高楼。接下来使用函数来封装 GPIO 的基本操作，方便<br> 以后应用的时候不需要再查询寄存器，而是直接通过调用这里定义的函数来实现。我们把<br> 针 对 GPIO 外 设 操 作 的 函 数 及 其 宏 定 义 分 别 存 放 在 “ stm32f10x_gpio.c ” 和<br> “stm32f10x_gpio.h”文件中，这两个文件需要自己新建。</p> 
<p><strong>定义位操作函数</strong><br> 在“stm32f10x_gpio.c”文件定义两个位操作函数，分别用于控制引脚输出高电平和低<br> 电平，见代码清单 9-3。</p> 
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token comment">/**
2 *函数功能：设置引脚为高电平
3 *参数说明：GPIOx:该参数为 GPIO_TypeDef 类型的指针，指向 GPIO 端口的地址
4 * GPIO_Pin:选择要设置的 GPIO 端口引脚，可输入宏 GPIO_Pin_0-15，
5 * 表示 GPIOx 端口的 0-15 号引脚。
6 */</span>
<span class="token number">7</span> <span class="token keyword">void</span> <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIO_TypeDef<span class="token operator">*</span> GPIOx<span class="token punctuation">,</span> uint16_t GPIO_Pin<span class="token punctuation">)</span>
<span class="token number">8</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">9</span> <span class="token comment">/*设置 GPIOx 端口 BSRR 寄存器的第 GPIO_Pin 位，使其输出高电平*/</span>
<span class="token number">10</span> <span class="token comment">/*因为 BSRR 寄存器写 0 不影响，
11 宏 GPIO_Pin 只是对应位为 1，其它位均为 0，所以可以直接赋值*/</span>
<span class="token number">12</span> 
<span class="token number">13</span> GPIOx<span class="token operator">-&gt;</span>BSRR <span class="token operator">=</span> GPIO_Pin<span class="token punctuation">;</span>
<span class="token number">14</span> <span class="token punctuation">}</span>
<span class="token number">15</span> 
<span class="token number">16</span> <span class="token comment">/**
17 *函数功能：设置引脚为低电平
18 *参数说明：GPIOx:该参数为 GPIO_TypeDef 类型的指针，指向 GPIO 端口的地址
19 * GPIO_Pin:选择要设置的 GPIO 端口引脚，可输入宏 GPIO_Pin_0-15，
20 * 表示 GPIOx 端口的 0-15 号引脚。
21 */</span>
<span class="token number">22</span> <span class="token keyword">void</span> <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIO_TypeDef<span class="token operator">*</span> GPIOx<span class="token punctuation">,</span> uint16_t GPIO_Pin<span class="token punctuation">)</span>
<span class="token number">23</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">24</span> <span class="token comment">/*设置 GPIOx 端口 BRR 寄存器的第 GPIO_Pin 位,使其输出低电平*/</span>
<span class="token number">25</span> <span class="token comment">/*因为 BRR 寄存器写 0 不影响，
26 宏 GPIO_Pin 只是对应位为 1，其它位均为 0，所以可以直接赋值*/</span>
<span class="token number">27</span> 
<span class="token number">28</span> GPIOx<span class="token operator">-&gt;</span>BRR <span class="token operator">=</span> GPIO_Pin<span class="token punctuation">;</span>
<span class="token number">29</span> <span class="token punctuation">}</span>
</code></pre> 
<p>这两个函数体内都是只有一个语句，对 GPIOx 的 BSRR 或 BRR 寄存器赋值，从而设<br> 置引脚为高电平或低电平，操作 BSRR 或者 BRR 可以实现单独的操作某一位，<br> 其中 GPIOx 是一个指针变量，通过函数的输入参数我们<br> 可以修改它的值，如给它赋予 GPIOA、GPIOB、GPIOH 等结构体指针值，这个函数就可<br> 以控制相应的 GPIOA、GPIOB、GPIOH 等端口的输出。<br> 利用这两个位操作函数，可以方便地操作各种 GPIO 的引脚电平，控制各种端口引脚</p> 
<pre><code class="prism language-c"><span class="token number">1</span> 
<span class="token number">2</span> <span class="token comment">/*控制 GPIOB 的引脚 10 输出高电平*/</span>
<span class="token number">3</span> <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span><span class="token punctuation">(</span>uint16_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">4</span> <span class="token comment">/*控制 GPIOB 的引脚 10 输出低电平*/</span>
<span class="token number">5</span> <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span><span class="token punctuation">(</span>uint16_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">6</span> 
<span class="token number">7</span> <span class="token comment">/*控制 GPIOB 的引脚 10、引脚 11 输出高电平，使用“|”同时控制多个引脚*/</span>
<span class="token number">8</span> <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span><span class="token punctuation">(</span>uint16_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>uint16_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">9</span> <span class="token comment">/*控制 GPIOB 的引脚 10、引脚 11 输出低电平*/</span>
<span class="token number">10</span> <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span><span class="token punctuation">(</span>uint16_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>uint16_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">11</span> 
<span class="token number">12</span> <span class="token comment">/*控制 GPIOA 的引脚 8 输出高电平*/</span>
<span class="token number">13</span> <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span><span class="token punctuation">(</span>uint16_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">14</span> <span class="token comment">/*控制 GPIOB 的引脚 9 输出低电平*/</span>
<span class="token number">15</span> <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span><span class="token punctuation">(</span>uint16_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>使用位操作函数及宏控制 GPIO</p> 
<pre><code class="prism language-c"><span class="token number">1</span> 
<span class="token number">2</span> <span class="token comment">/*控制 GPIOB 的引脚 10 输出高电平*/</span>
<span class="token number">3</span> <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span>GPIO_Pin_10<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">4</span> <span class="token comment">/*控制 GPIOB 的引脚 10 输出低电平*/</span>
<span class="token number">5</span> <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span>GPIO_Pin_10<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">6</span> 
<span class="token number">7</span> <span class="token comment">/*控制 GPIOB 的引脚 10、引脚 11 输出高电平，使用“|”，同时控制多个引脚*/</span>
<span class="token number">8</span> <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span>GPIO_Pin_10<span class="token operator">|</span>GPIO_Pin_11<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">9</span> <span class="token comment">/*控制 GPIOB 的引脚 10、引脚 11 输出低电平*/</span>
<span class="token number">10</span> <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span>GPIO_Pin_10<span class="token operator">|</span>GPIO_Pin_11<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">11</span> <span class="token comment">/*控制 GPIOB 的所有输出低电平*/</span>
<span class="token number">12</span> <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span>GPIO_Pin_ALL<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">13</span> 
<span class="token number">14</span> <span class="token comment">/*控制 GPIOA 的引脚 8 输出高电平*/</span>
<span class="token number">15</span> <span class="token function">GPIO_SetBits</span><span class="token punctuation">(</span>GPIOA<span class="token punctuation">,</span>GPIO_Pin_8<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">16</span> <span class="token comment">/*控制 GPIOB 的引脚 9 输出低电平*/</span>
<span class="token number">17</span> <span class="token function">GPIO_ResetBits</span><span class="token punctuation">(</span>GPIOB<span class="token punctuation">,</span>GPIO_Pin_9<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>使用以上代码控制 GPIO，我们就不需要再看寄存器了，直接从函数名和输入参数就<br> 可以直观看出这个语句要实现什么操作。(英文中―Set‖表示“置位”，即高电平，“Reset”<br> 表示“复位”，即低电平)。</p> 
<p><strong>定义初始化结构体 GPIO_InitTypeDef</strong><br> 定义位操作函数后，控制 GPIO 输出电平的代码得到了简化，但在控制 GPIO 输出电<br> 平前还需要初始化 GPIO 引脚的各种模式，这部分代码涉及的寄存器有很多，我们希望初<br> 始化 GPIO 也能以如此简单的方法去实现。为此，我们先根据 GPIO 初始化时涉及到的初<br> 始化参数以结构体的形式封装起来，声明一个名为 GPIO_InitTypeDef 的结构体类型，见代 码 9-3</p> 
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token number">2</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">3</span> uint16_t GPIO_Pin<span class="token punctuation">;</span> <span class="token comment">/*!&lt; 选择要配置的 GPIO 引脚 */</span>
<span class="token number">4</span> 
<span class="token number">5</span> uint16_t GPIO_Speed<span class="token punctuation">;</span> <span class="token comment">/*!&lt; 选择 GPIO 引脚的速率 */</span>
<span class="token number">6</span> 
<span class="token number">7</span> uint16_t GPIO_Mode<span class="token punctuation">;</span> <span class="token comment">/*!&lt; 选择 GPIO 引脚的工作模式 */</span>
<span class="token number">8</span> <span class="token punctuation">}</span> GPIO_InitTypeDef<span class="token punctuation">;</span>
</code></pre> 
<p>这个结构体中包含了初始化 GPIO 所需要的信息，包括引脚号、工作模式、输出速率。<br> 设计这个结构体的思路是：初始化 GPIO 前，先定义一个这样的结构体变量，根据需要配<br> 置 GPIO 的模式，对这个结构体的各个成员进行赋值，然后把这个变量作为“GPIO 初始化<br> 函数”的输入参数，该函数能根据这个变量值中的内容去配置寄存器，从而实现 GPIO 的<br> 初始化。</p> 
<p>**</p> 
<h3><a id="_GPIO__376"></a>定义 GPIO 初始化函数</h3> 
<p>**<br> 接着前面的思路，对初始化结构体赋值后，把它输入到 GPIO 初始化函数，由它来实<br> 现寄存器配置。我们的 GPIO 初始化函数实现见代码</p> 
<pre><code class="prism language-c"><span class="token number">1</span> <span class="token comment">/**
2 *函数功能：初始化引脚模式
3 *参数说明：GPIOx，该参数为 GPIO_TypeDef 类型的指针，指向 GPIO 端口的地址
4 * GPIO_InitTypeDef:GPIO_InitTypeDef 结构体指针，指向初始化变量
5 */</span>
<span class="token number">6</span> <span class="token keyword">void</span> <span class="token function">GPIO_Init</span><span class="token punctuation">(</span>GPIO_TypeDef<span class="token operator">*</span> GPIOx<span class="token punctuation">,</span> GPIO_InitTypeDef<span class="token operator">*</span> GPIO_InitStruct<span class="token punctuation">)</span>
<span class="token number">7</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">8</span> uint32_t currentmode <span class="token operator">=</span><span class="token number">0x00</span><span class="token punctuation">,</span>currentpin <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">,</span>pinpos <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">,</span>pos <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">;</span>
<span class="token number">9</span> uint32_t tmpreg <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">,</span> pinmask <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">;</span>
<span class="token number">10</span> 
<span class="token number">11</span> <span class="token comment">/*---------------- GPIO 模式配置 -------------------*/</span>
<span class="token number">12</span> <span class="token comment">// 把输入参数 GPIO_Mode 的低四位暂存在 currentmode</span>
<span class="token number">13</span> currentmode <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>GPIO_InitStruct<span class="token operator">-&gt;</span>GPIO_Mode<span class="token punctuation">)</span> <span class="token operator">&amp;</span>
<span class="token number">14</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token number">0x0F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">15</span> 
<span class="token number">16</span> <span class="token comment">// bit4 是 1 表示输出，bit4 是 0 则是输入</span>
<span class="token number">17</span> <span class="token comment">// 判断 bit4 是 1 还是 0，即首选判断是输入还是输出模式</span>
<span class="token number">18</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>GPIO_InitStruct<span class="token operator">-&gt;</span>GPIO_Mode<span class="token punctuation">)</span> <span class="token operator">&amp;</span>
<span class="token number">19</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0x00</span><span class="token punctuation">)</span>
<span class="token number">20</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">21</span> <span class="token comment">// 输出模式则要设置输出速度</span>
<span class="token number">22</span> currentmode <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>GPIO_InitStruct<span class="token operator">-&gt;</span>GPIO_Speed<span class="token punctuation">;</span>
<span class="token number">23</span> <span class="token punctuation">}</span>
<span class="token number">24</span> <span class="token comment">/*-----GPIO CRL 寄存器配置 CRL 寄存器控制着低 8 位 IO- ----*/</span>
<span class="token number">25</span> <span class="token comment">// 配置端口低 8 位，即 Pin0~Pin7</span>
<span class="token number">26</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span>GPIO_InitStruct<span class="token operator">-&gt;</span>GPIO_Pin <span class="token operator">&amp;</span>
<span class="token number">27</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token number">0x00FF</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0x00</span><span class="token punctuation">)</span>
<span class="token number">28</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">29</span> <span class="token comment">// 先备份 CRL 寄存器的值</span>
<span class="token number">30</span> tmpreg <span class="token operator">=</span> GPIOx<span class="token operator">-&gt;</span>CRL<span class="token punctuation">;</span>
<span class="token number">31</span> 
<span class="token number">32</span> <span class="token comment">// 循环，从 Pin0 开始配对，找出具体的 Pin</span>
<span class="token number">33</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>pinpos <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">;</span> pinpos <span class="token operator">&lt;</span> <span class="token number">0x08</span><span class="token punctuation">;</span> pinpos<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token number">34</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">35</span> <span class="token comment">// pos 的值为 1 左移 pinpos 位</span>
<span class="token number">36</span> pos <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token number">0x01</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> pinpos<span class="token punctuation">;</span>
<span class="token number">37</span> 
<span class="token number">38</span> <span class="token comment">// 令 pos 与输入参数 GPIO_PIN 作位与运算</span>
<span class="token number">39</span> currentpin <span class="token operator">=</span> <span class="token punctuation">(</span>GPIO_InitStruct<span class="token operator">-&gt;</span>GPIO_Pin<span class="token punctuation">)</span> <span class="token operator">&amp;</span> pos<span class="token punctuation">;</span>
<span class="token number">40</span> 
<span class="token number">41</span> <span class="token comment">//若 currentpin=pos,则找到使用的引脚</span>
<span class="token number">42</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>currentpin <span class="token operator">==</span> pos<span class="token punctuation">)</span>
<span class="token number">43</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">44</span> <span class="token comment">//pinpos 的值左移两位(乘以 4),因为寄存器中 4 个位配置一个引脚</span>
<span class="token number">45</span> pos <span class="token operator">=</span> pinpos <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token number">46</span> <span class="token comment">//把控制这个引脚的 4 个寄存器位清零，其它寄存器位不变</span>
<span class="token number">47</span> pinmask <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token number">0x0F</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> pos<span class="token punctuation">;</span>
<span class="token number">48</span> tmpreg <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>pinmask<span class="token punctuation">;</span>
<span class="token number">49</span>
<span class="token number">50</span> <span class="token comment">// 向寄存器写入将要配置的引脚的模式</span>
<span class="token number">51</span> tmpreg <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>currentmode <span class="token operator">&lt;&lt;</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">52</span> 
<span class="token number">53</span> <span class="token comment">// 判断是否为下拉输入模式</span>
<span class="token number">54</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>GPIO_InitStruct<span class="token operator">-&gt;</span>GPIO_Mode <span class="token operator">==</span> GPIO_Mode_IPD<span class="token punctuation">)</span>
<span class="token number">55</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">56</span> <span class="token comment">// 下拉输入模式,引脚默认置 0,对 BRR 寄存器写 1 对引脚置 0</span>
<span class="token number">57</span> GPIOx<span class="token operator">-&gt;</span>BRR <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token number">0x01</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> pinpos<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">58</span> <span class="token punctuation">}</span>
<span class="token number">59</span> <span class="token keyword">else</span>
<span class="token number">60</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">61</span> <span class="token comment">// 判断是否为上拉输入模式</span>
<span class="token number">62</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>GPIO_InitStruct<span class="token operator">-&gt;</span>GPIO_Mode <span class="token operator">==</span> GPIO_Mode_IPU<span class="token punctuation">)</span>
<span class="token number">63</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">64</span> <span class="token comment">// 上拉输入模式,引脚默认值为 1,对 BSRR 寄存器写 1 对引脚置 1</span>
<span class="token number">65</span> GPIOx<span class="token operator">-&gt;</span>BSRR <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token number">0x01</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> pinpos<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">66</span> <span class="token punctuation">}</span>
<span class="token number">67</span> <span class="token punctuation">}</span>
<span class="token number">68</span> <span class="token punctuation">}</span>
<span class="token number">69</span> <span class="token punctuation">}</span>
<span class="token number">70</span> <span class="token comment">// 把前面处理后的暂存值写入到 CRL 寄存器之中</span>
<span class="token number">71</span> GPIOx<span class="token operator">-&gt;</span>CRL <span class="token operator">=</span> tmpreg<span class="token punctuation">;</span>
<span class="token number">72</span> <span class="token punctuation">}</span>
<span class="token number">73</span> <span class="token comment">/*--------GPIO CRH 寄存器配置 CRH 寄存器控制着高 8 位 IO- -----*/</span>
<span class="token number">74</span> <span class="token comment">// 配置端口高 8 位，即 Pin8~Pin15</span>
<span class="token number">75</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>GPIO_InitStruct<span class="token operator">-&gt;</span>GPIO_Pin <span class="token operator">&gt;</span> <span class="token number">0x00FF</span><span class="token punctuation">)</span>
<span class="token number">76</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">77</span> <span class="token comment">// // 先备份 CRH 寄存器的值</span>
<span class="token number">78</span> tmpreg <span class="token operator">=</span> GPIOx<span class="token operator">-&gt;</span>CRH<span class="token punctuation">;</span>
<span class="token number">79</span> 
<span class="token number">80</span> <span class="token comment">// 循环，从 Pin8 开始配对，找出具体的 Pin</span>
<span class="token number">81</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>pinpos <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">;</span> pinpos <span class="token operator">&lt;</span> <span class="token number">0x08</span><span class="token punctuation">;</span> pinpos<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token number">82</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">83</span> pos <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token number">0x01</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>pinpos <span class="token operator">+</span> <span class="token number">0x08</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">84</span> 
<span class="token number">85</span> <span class="token comment">// pos 与输入参数 GPIO_PIN 作位与运算</span>
<span class="token number">86</span> currentpin <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>GPIO_InitStruct<span class="token operator">-&gt;</span>GPIO_Pin<span class="token punctuation">)</span> <span class="token operator">&amp;</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">87</span> 
<span class="token number">88</span> <span class="token comment">//若 currentpin=pos,则找到使用的引脚</span>
<span class="token number">89</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>currentpin <span class="token operator">==</span> pos<span class="token punctuation">)</span>
<span class="token number">90</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">91</span> <span class="token comment">//pinpos 的值左移两位(乘以 4),因为寄存器中 4 个位配置一个引脚</span>
<span class="token number">92</span> pos <span class="token operator">=</span> pinpos <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token number">93</span> 
<span class="token number">94</span> <span class="token comment">//把控制这个引脚的 4 个寄存器位清零，其它寄存器位不变</span>
<span class="token number">95</span> pinmask <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token number">0x0F</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> pos<span class="token punctuation">;</span>
<span class="token number">96</span> tmpreg <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>pinmask<span class="token punctuation">;</span>
<span class="token number">97</span> 
<span class="token number">98</span> <span class="token comment">// 向寄存器写入将要配置的引脚的模式</span>
<span class="token number">99</span> tmpreg <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>currentmode <span class="token operator">&lt;&lt;</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">100</span> 
<span class="token number">101</span> <span class="token comment">// 判断是否为下拉输入模式</span>
<span class="token number">102</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>GPIO_InitStruct<span class="token operator">-&gt;</span>GPIO_Mode <span class="token operator">==</span> GPIO_Mode_IPD<span class="token punctuation">)</span>
<span class="token number">103</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">104</span> <span class="token comment">// 下拉输入模式,引脚默认置 0,对 BRR 寄存器写 1 可对引脚置 0</span>
<span class="token number">105</span> GPIOx<span class="token operator">-&gt;</span>BRR <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token number">0x01</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>pinpos <span class="token operator">+</span> <span class="token number">0x08</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">106</span> <span class="token punctuation">}</span>
<span class="token number">107</span> <span class="token comment">// 判断是否为上拉输入模式</span>
<span class="token number">108</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>GPIO_InitStruct<span class="token operator">-&gt;</span>GPIO_Mode <span class="token operator">==</span> GPIO_Mode_IPU<span class="token punctuation">)</span>
<span class="token number">109</span> <span class="token punctuation">{<!-- --></span>
<span class="token number">110</span> <span class="token comment">// 上拉输入模式,引脚默认值为 1,对 BSRR 寄存器写 1 可对引脚置 1</span>
<span class="token number">111</span> GPIOx<span class="token operator">-&gt;</span>BSRR <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint32_t<span class="token punctuation">)</span><span class="token number">0x01</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>pinpos <span class="token operator">+</span> <span class="token number">0x08</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">112</span> <span class="token punctuation">}</span>
<span class="token number">113</span> <span class="token punctuation">}</span>
<span class="token number">114</span> <span class="token punctuation">}</span>
<span class="token number">115</span> <span class="token comment">// 把前面处理后的暂存值写入到 CRH 寄存器之中</span>
<span class="token number">116</span> GPIOx<span class="token operator">-&gt;</span>CRH <span class="token operator">=</span> tmpreg<span class="token punctuation">;</span>
<span class="token number">117</span> <span class="token punctuation">}</span>
<span class="token number">118</span> <span class="token punctuation">}</span>
</code></pre> 
<p>这个函数有 GPIOx 和 GPIO_InitStruct 两个输入参数，分别是 GPIO 外设指针和 GPIO<br> 初始化结构体指针。分别用来指定要初始化的 GPIO 端口及引脚的工作模式。</p> 
<h3><a id="_508"></a>总结</h3> 
<p>**</p> 
<p>什么是 ST 标准固件库？不懂的时候总觉得莫测高深，懂了之后一切都是纸老虎。<br> 我们从寄存器映射开始，把内存跟寄存器建立起一一对应的关系，然后操作寄存器点<br> 亮 LED，再把寄存器操作封装成一个个函数。一步一步走来，我们实现了库最简单的雏形，<br> 如果我们不断地增加操作外设的函数，并且把所有的外设都写完，一个完整的库就实现了。<br> 本章中的 GPIO 相关库函数及结构体定义，实际上都是从 ST 标准库搬过来的。这样分<br> 析它纯粹是为了满足自己的求知欲，学习其编程的方式、思想，这对提高我们的编程水平<br> 是很有好处的，顺便感受一下 ST 库设计的严谨性，我认为这样的代码不仅严谨且华丽优<br> 美，不知您是否也有这样的感受。<br> 与直接配置寄存器相比，从执行效率上看会有额外的消耗：初始化变量赋值的过程、<br> 库函数在被调用的时候要耗费调用时间；在函数内部，对输入参数转换所需要的额外运算<br> 也消耗一些时间(如 GPIO 中运算求出引脚号时)。而其它的宏、枚举等解释操作是作编译过<br> 程完成的，这部分并不消耗内核的时间。那么函数库的优点呢？是我们可以快速上手<br> STM32 控制器；配置外设状态时，不需要再纠结要向寄存器写入什么数值；交流方便，查<br> 错简单。这就是我们选择库的原因。<br> 现在的处理器的主频是越来越高，我们不需要担心 CPU 耗费那么多时间来干活会不会<br> 被累倒，库主要应用是在初始化过程，而初始化过程一般是芯片刚上电或在核心运算之前<br> 的执行的，这段时间的等待是 0.02us 还是 0.01us 在很多时候并没有什么区别。相对来说，<br> 我们还是担心一下如果都用寄存器操作，每行代码都要查数据手册的寄存器说明，自己会<br> 不会被累倒吧。<br> 在以后开发的工程中，一般不会去分析 ST 的库函数的实现。因为外设的库函数是很<br> 类似的，库外设都包含初始化结构体，以及特定的宏或枚举标识符，这些封装被库函数这<br> 些转化成相应的值，写入到寄存器之中，函数内部的具体实现是十分枯燥和机械的工作。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6729721e9061fe43d9c96040715eaa8d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">iOS scrollToItemAtIndexPath 无效的解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a54d72c5d786a469131408cf30b68b70/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决使用python过程中可能出现的编码问题UnicodeEncodeError</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>