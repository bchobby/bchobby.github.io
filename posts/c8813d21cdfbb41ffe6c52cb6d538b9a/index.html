<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ARM 编译器 C 库启动和初始化 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ARM 编译器 C 库启动和初始化" />
<meta property="og:description" content="1 介绍 本文档描述了 C 库启动代码和在使用 ARM 编译器编译的应用程序启动期间可能调用的初始化函数。该文档概述了启动代码中的功能的作用以及它们存在的原因。您可以使用此文档来验证您的应用程序的启动代码。
1.1 版本 本文档描述了 ARM 编译器的启动代码。启动代码中的函数可能会在工具链的不同版本和补丁之间发生变化。本文档不保证库启动代码在后续版本或工具链补丁中的持续运行。
1.2 补充阅读 本节列出了 ARM 和第三方的出版物。请参阅 Infocenter，http://infocenter.arm.com，以访问 ARM 文档。
1.2.1 ARM 出版物 以下文档包含与本文档相关的信息：
• ARM 编译器工具链 ARM 处理器开发软件 (ARM DUI 0471)
• ARM 编译器工具链 ARM C 和 C&#43;&#43; 库和浮点支持参考 (ARM DUI 0492)
• 使用 ARM 的 ARM 编译器工具链C 和 C&#43;&#43; 库和浮点支持 (ARM DUI 0475)
• ARM 编译器工具链链接器参考 (ARM DUI 0493)。
2 启动代码 嵌入式应用程序需要在用户定义的 main() 函数启动之前进行初始化序列。这称为启动代码或引导代码。 ARM C 库包含启动应用程序所需的预编译和预汇编代码部分。链接您的应用程序时，链接器会根据应用程序从 C 库中包含必要的代码，以便为应用程序创建自定义启动代码。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/c8813d21cdfbb41ffe6c52cb6d538b9a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-29T00:17:19+08:00" />
<meta property="article:modified_time" content="2022-04-29T00:17:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ARM 编译器 C 库启动和初始化</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="margin-left:0px;">1 介绍</h2> 
<p style="margin-left:0;">本文档描述了 C 库启动代码和在使用 ARM 编译器编译的应用程序启动期间可能调用的初始化函数。该文档概述了启动代码中的功能的作用以及它们存在的原因。您可以使用此文档来验证您的应用程序的启动代码。</p> 
<p style="margin-left:0;"></p> 
<h2 style="margin-left:0px;">1.1 版本</h2> 
<p style="margin-left:0;">本文档描述了 ARM 编译器的启动代码。启动代码中的函数可能会在工具链的不同版本和补丁之间发生变化。本文档不保证库启动代码在后续版本或工具链补丁中的持续运行。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">1.2 补充阅读</h3> 
<p style="margin-left:0;">本节列出了 ARM 和第三方的出版物。请参阅 Infocenter，http://infocenter.arm.com，以访问 ARM 文档。</p> 
<p style="margin-left:0;"></p> 
<h4 style="margin-left:0px;">1.2.1 ARM 出版物</h4> 
<p style="margin-left:0;">以下文档包含与本文档相关的信息：</p> 
<p style="margin-left:0;">         • ARM 编译器工具链 ARM 处理器开发软件 (ARM DUI 0471)</p> 
<p style="margin-left:0;">         • ARM 编译器工具链 ARM C 和 C++ 库和浮点支持参考 (ARM DUI 0492)</p> 
<p style="margin-left:0;">         • 使用 ARM 的 ARM 编译器工具链C 和 C++ 库和浮点支持 (ARM DUI 0475)</p> 
<p style="margin-left:0;">        • ARM 编译器工具链链接器参考 (ARM DUI 0493)。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<h2 style="margin-left:0px;">2 启动代码</h2> 
<p style="margin-left:0;">嵌入式应用程序需要在用户定义的 main() 函数启动之前进行初始化序列。这称为启动代码或引导代码。 ARM C 库包含启动应用程序所需的预编译和预汇编代码部分。链接您的应用程序时，链接器会根据应用程序从 C 库中包含必要的代码，以便为应用程序创建自定义启动代码。</p> 
<p style="margin-left:0;">笔记：在目标上运行的嵌入式应用程序可以在调用 C 库启动代码之前执行其他目标硬件初始化。有关详细信息，请参阅为 ARM 处理器开发软件中的重置和初始化。</p> 
<p style="margin-left:0;">一个应用程序的启动代码可能与另一个应用程序的启动代码不同。该文档没有描述任何特定用户应用程序的精确启动代码。此外，该文档没有描述如何自己自定义启动代码。有关如何自定义启动代码的信息，请参阅为 ARM 处理器开发软件。本文档中描述的启动代码适用于标准 ARM C 库。它不适用于 ARM C 微库。这对于 ARMv4T 及更高版本的架构也很常见。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<h2 style="margin-left:0px;">3 C 库的入口点</h2> 
<p style="margin-left:0;">函数 __main 是 C 库的入口点。除非您更改它，否则 __main 是 ARM 链接器 (armlink) 在创建映像时使用的 ELF 映像的默认入口点。图 1 显示了 C 库启动期间 __main 调用的函数。</p> 
<p class="img-center"><img alt="" height="269" src="https://images2.imgbox.com/13/e1/cjGUtTuv_o.png" width="392"></p> 
<p style="margin-left:0px;text-align:center;"><strong>图 1 C 库启动时调用的函数概述</strong></p> 
<p style="margin-left:0;">__rt_entry 和 __rt_entry 调用的函数在 __rt_entry 调用的函数中进行了描述。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">3.1 __scatterload</h3> 
<p style="margin-left:0;">应用程序代码和数据可以位于根区域或非根区域。根区域具有相同的加载时间和执行时间地址。非根区域具有不同的加载时间和执行时间地址。根区域包含 ARM 链接器输出的区域表。区域表包含需要初始化的非根代码和数据区域的地址。区域表还包含一个函数指针，该指针指示该区域需要什么初始化，例如复制、归零或解压缩函数。</p> 
<p style="margin-left:0;">__scatterload 遍历区域表并初始化各种执行时区域。功能：</p> 
<p style="margin-left:0;">        • 将零初始化(ZI) 区域初始化为零</p> 
<p style="margin-left:0;">        • 将非根代码和数据区域从加载时位置复制或解压缩到执行时区域。</p> 
<p style="margin-left:0;">__main 总是在启动期间调用此函数，然后再调用 __rt_entry。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">3.2 参见</h3> 
<p style="margin-left:0;">使用 ARM C 和 C++ 库和浮点支持：</p> 
<p style="margin-left:0;">        • 初始化执行环境和执行应用程序。</p> 
<p style="margin-left:0;">ARM C 和 C++ 库和浮点支持参考：</p> 
<p style="margin-left:0;">        • 线程安全的 C 库函数。</p> 
<p style="margin-left:0;">为 ARM 处理器开发软件：</p> 
<p style="margin-left:0;">        • 为您的目标硬件定制映像内存映射</p> 
<p style="margin-left:0;">        • 本地内存设置注意事项</p> 
<p style="margin-left:0;">        • 应用程序启动</p> 
<p style="margin-left:0;">        • 重置和初始化</p> 
<p style="margin-left:0;">        • 分散加载描述文件</p> 
<p style="margin-left:0;">        • 根区域。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<h2 style="margin-left:0px;">4 __rt_entry 调用的函数</h2> 
<p style="margin-left:0;">__main 调用 __rt_entry 来初始化栈、堆和其他 C 库子系统。 __rt_entry 调用各种初始化函数，然后调用用户级main()。</p> 
<p style="margin-left:0;">这列出了 _rt_entry 可以调用的函数。这些函数按它们被调用的顺序列出：</p> 
<p style="margin-left:0;">        1. _platform_pre_stackheap_init</p> 
<p style="margin-left:0;">        2. __user_setup_stackheap or setup the Stack Pointer (SP) by another method</p> 
<p style="margin-left:0;">        3. _platform_post_stackheap_init</p> 
<p style="margin-left:0;">        4. __rt_lib_init</p> 
<p style="margin-left:0;">        5. _platform_post_lib_init</p> 
<p style="margin-left:0;">        6. main()</p> 
<p style="margin-left:0;">        7. exit()</p> 
<p style="margin-left:0;">_platform_* 函数不是标准 C 库的一部分。如果您定义了它们，那么链接器会在 __rt_entry 中调用它们。</p> 
<p style="margin-left:0;">main() 是用户级应用程序的入口点。寄存器 r0 和 r1 包含 main() 的参数。如果 main() 返回，则将其返回值传递给 exit() 并退出应用程序。</p> 
<p style="margin-left:0;">__rt_entry 还负责设置栈和堆。但是，设置堆栈和堆取决于用户指定的方法。堆栈和堆可以通过以下任何一种方法设置：</p> 
<p style="margin-left:0;">        • 调用__user_setup_stackheap。这也获得了堆使用的内存边界（堆顶和堆底）。</p> 
<p style="margin-left:0;">        • 使用符号__initial_sp 的值加载SP。</p> 
<p style="margin-left:0;">        • 使用链接器分散文件中指定的ARM_LIB_STACK 或ARM_LIB_STACKHEAP 区域的顶部。</p> 
<p style="margin-left:0;">__rt_entry 和 __rt_lib_init 在 C 库中不作为完整函数存在。这些函数的一小部分存在于作为 C 库一部分的几个内部对象中。并非所有这些代码段都对给定的用户应用程序有用。链接器决定给定应用程序需要这些代码段的哪个子集，并仅在启动代码中包含这些段。链接器以正确的顺序放置这些部分，以根据用户应用程序的要求创建自定义的 __rt_entry 和 __rt_lib_init 函数。</p> 
<p style="margin-left:0;">__rt_lib_init 调用的函数在 __rt_lib_init 调用的函数中进行了描述。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">4.1 _platform_pre_stackheap_init</h3> 
<p style="margin-left:0;">标准 C 库不提供此功能，但您可以根据需要定义它。例如，您可以使用此功能设置硬件。 __rt_entry 在初始化堆栈和堆的代码之前调用此函数（如果您定义它）​​。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">4.2 __user_setup_stackheap</h3> 
<p style="margin-left:0;">此函数使您能够设置和返回初始堆栈和堆的位置。 C 库不提供此功能，但您可以根据需要定义它。 __rt_entry 如果您定义它或定义旧函数 __user_initial_stackheap，则调用此函数。如果定义 __user_initial_stackheap，则 C 库提供默认的 __user_setup_stackheap 作为 __user_initial_stackheap 函数的包装器。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">4.3 _platform_post_stackheap_init</h3> 
<p style="margin-left:0;">C 库不提供此功能，但您可以根据需要定义它。例如，您可以使用此功能设置硬件。 __rt_entry 在初始化堆栈和堆的代码之后调用此函数（如果您定义它）​​。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">4.4 __rt_lib_init</h3> 
<p style="margin-left:0;">此函数初始化各种 C 库子系统。它初始化引用的库函数，初始化语言环境，并在必要时为 main() 设置 argc 和 argv。 __rt_entry 总是在启动期间调用此函数。</p> 
<p style="margin-left:0;">如果使用 __user_setup_stackheap 或 __user_initial_stackheap 函数来设置堆栈指针和堆，则堆内存块的起始地址和结束地址分别作为参数传递给寄存器 r0 和 r1 中的 __rt_lib_init。</p> 
<p style="margin-left:0;">如果用户级 main() 需要，该函数分别在寄存器 r0 和 r1 中返回 argc 和 argv。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">4.5 _platform_post_lib_init</h3> 
<p style="margin-left:0;">C 库不提供此功能，但您可以根据需要定义它。例如，您可以使用此功能设置硬件。 __rt_entry 在调用 __rt_lib_init 之后和调用用户级 main() 函数之前调用此函数（如果您定义它）​​。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">4.6 参见</h3> 
<p style="margin-left:0;">C 库的入口点</p> 
<p style="margin-left:0;">为 ARM 处理器开发软件：</p> 
<p style="margin-left:0;">        • 复位和初始化</p> 
<p style="margin-left:0;">        • 应用程序启动</p> 
<p style="margin-left:0;">        • 堆栈指针初始化</p> 
<p style="margin-left:0;">        • 放置堆栈和堆。</p> 
<p style="margin-left:0;">ARM C 和 C++ 库和浮点支持参考：</p> 
<p style="margin-left:0;">        • __rt_entry</p> 
<p style="margin-left:0;">        • __user_setup_stackeheap()</p> 
<p style="margin-left:0;">        • __rt_stackheap_init()</p> 
<p style="margin-left:0;">        • __rt_lib_init()</p> 
<p style="margin-left:0;">        • __rt_lib_shutdown()</p> 
<p style="margin-left:0;">        • _sys_exit()</p> 
<p style="margin-left:0;">        • 旧函数__user_initial_stackheap()。</p> 
<p style="margin-left:0;">使用 ARM C 和 C++ 库和浮点支持：</p> 
<p style="margin-left:0;">        • 堆栈指针初始化和堆边界</p> 
<p style="margin-left:0;">        • 执行环境的初始化和应用程序的执行</p> 
<p style="margin-left:0;">        • 对 __user_initial_stackheap() 的传统支持。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<h2 style="margin-left:0px;">5 __rt_lib_init 调用的函数</h2> 
<p style="margin-left:0;">链接器包括来自内部目标文件的各种初始化代码部分，以创建自定义 __rt_lib_int 函数。仅当应用程序需要时，链接器才会在 __rt_lib_init 中放置一个函数。</p> 
<p style="margin-left:0;">这列出了 _rt_lib_init 可以调用的函数。这些函数按它们被调用的顺序列出：</p> 
<p style="margin-left:0;">        1. _fp_init</p> 
<p style="margin-left:0;">        2. _init_alloc</p> 
<p style="margin-left:0;">        3. _rand_init</p> 
<p style="margin-left:0;">        4. _get_lc_collate</p> 
<p style="margin-left:0;">        5. _get_lc_ctype</p> 
<p style="margin-left:0;">        6. _get_lc_monetary</p> 
<p style="margin-left:0;">        7. _get_lc_numeric</p> 
<p style="margin-left:0;">        8. _get_lc_time</p> 
<p style="margin-left:0;">        9. _atexit_init</p> 
<p style="margin-left:0;">        10. _signal_init</p> 
<p style="margin-left:0;">        11. _fp_trap_init</p> 
<p style="margin-left:0;">        12. _clock_init</p> 
<p style="margin-left:0;">        13. _getenv_init</p> 
<p style="margin-left:0;">        14. _initio</p> 
<p style="margin-left:0;">        15. _ARM_get_argv</p> 
<p style="margin-left:0;">        16. _alloca_initialize</p> 
<p style="margin-left:0;">        17. _ARM_exceptions_init</p> 
<p style="margin-left:0;">        18. __cpp_initialize__aeabi_</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">5.1 _fp_init</h3> 
<p style="margin-left:0;">该函数通过设置 FP 状态字来初始化浮点环境。如果用户应用程序使用 VFP 硬件，该函数会初始化浮点状态和控制寄存器 (FPSCR)。如果应用程序使用软件 VFP，该函数会初始化内存中的 FP 状态字。 __rt_lib_init 总是在启动期间调用此函数。</p> 
<p style="margin-left:0;">如何调用 fp_init 取决于 ARM 编译器版本：</p> 
<p style="margin-left:0;">        • ARM 编译器 v4.1</p> 
<p style="margin-left:0;">                fp_init 始终在启动期间调用。</p> 
<p style="margin-left:0;">        • ARM Compiler 5</p> 
<p style="margin-left:0;">                _fp_init 在启动期间被调用，除非您同时使用softfp 和不带状态字的FP 模型(--fpmode={ieee_no_fenv,std,fast})。在这种情况下，完全省略了对 _fp_init 的调用。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">5.2 _init_alloc</h3> 
<p style="margin-left:0;">此函数设置 malloc、free 和其他相关函数使用的数据结构。该函数有 2 个参数。寄存器 r0 中的第一个参数是堆内存块（heapbase）的开始，寄存器 r1 中的第二个参数是堆内存块（heaptop）的结束。如果这些堆绑定参数未作为参数传递给 __rt_lib_init，则 __rt_lib_init 使用符号 __heap_base 和 __heap_limit 或特殊的分散加载区域加载它们，请参阅 __rt_entry 调用的函数。如果应用程序使用堆，__rt_lib_init 调用此函数。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">5.3 _rand_init</h3> 
<p style="margin-left:0;">此函数将随机数生成器初始化为其默认起始状态。如果应用程序使用 rand()，__rt_lib_init 调用此函数。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">5.4 _get_lc_collate</h3> 
<p style="margin-left:0;">此函数获取指向包含 LC_COLLATE 语言环境类别设置的默认数据块的指针。它将指针插入到 C 库存储的语言环境指针变量中。如果应用程序调用其行为取决于此区域设置的任何函数，__rt_lib_init 将调用此函数。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">5.5 _get_lc_ctype</h3> 
<p style="margin-left:0;">此函数获取指向包含 LC_CTYPE 语言环境类别设置的默认数据块的指针。它将指针插入到 C 库存储的语言环境指针变量中。如果应用程序调用其行为取决于此语言环境设置的任何函数，__rt_lib_init 将调用此函数。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">5.6 _get_lc_monetary</h3> 
<p style="margin-left:0;">此函数获取指向包含 LC_MONETARY 语言环境类别设置的默认数据块的指针。它将指针插入到 C 库存储的语言环境指针变量中。如果应用程序调用其行为取决于此区域设置的任何函数，__rt_lib_init 将调用此函数。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">5.7 _get_lc_numeric</h3> 
<p style="margin-left:0;">此函数获取指向包含 LC_NUMERIC 语言环境类别设置的默认数据块的指针。它将指针插入到 C 库存储的语言环境指针变量中。如果应用程序调用其行为取决于此语言环境设置的任何函数，__rt_lib_init 将调用此函数。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">5.8 _get_lc_time</h3> 
<p style="margin-left:0;">此函数获取指向包含 LC_TIME 语言环境类别设置的默认数据块的指针。它将指针插入到 C 库存储的语言环境指针变量中。如果应用程序调用其行为取决于此语言环境设置的任何函数，__rt_lib_init 将调用此函数。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">5.9 _atexit_init</h3> 
<p style="margin-left:0;">此函数为传递给 atexit() 的函数指针设置 C 库的存储。在多线程应用程序中，它还设置了互斥锁以保护存储免受并发访问。如果应用程序使用 atexit()，__rt_lib_init 调用此函数。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">5.10 _signal_init</h3> 
<p style="margin-left:0;">此函数设置包含每个信号编号的当前处理程序的存储。在多线程应用程序中，它还设置了互斥锁以保护此存储免受并发访问。如果应用程序使用 signal()，__rt_lib_init 调用此函数。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">5.11 _fp_trap_init</h3> 
<p style="margin-left:0;">此函数设置库的存储，其中包含每种浮点异常的当前处理程序。在多线程应用程序中，它还设置了互斥锁以保护此存储免受并发访问。如果应用程序使用捕获的浮点异常，__rt_lib_init 将调用此函数，例如，如果您使用以下任何一种：</p> 
<p style="margin-left:0;">        • --fpmode=ieee_full</p> 
<p style="margin-left:0;">        • --fpmpde=ieee_fixed。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">5.12 _clock_ini</h3> 
<p style="margin-left:0;">该函数读取clock() 使用的定时器的当前值。这被存储为程序的开始时间。随后对clock() 的调用返回自程序开始时间以来经过的时间。这些是clock() 和_clock_init 的默认实现。您可以以不同的方式重新实现它们。如果应用程序使用clock()，__rt_lib_init 调用这个函数。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">5.13 _getenv_init</h3> 
<p style="margin-left:0;">标准 C 库不提供此功能，但您可以根据需要定义它。此函数使 getenv() 能够检索任何需要的数据。 __rt_lib_init 如果您定义它，则调用此函数。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">5.14 _initio</h3> 
<p style="margin-left:0;">此函数设置 stdio 内部状态。这包括初始化打开文件列表，调用 _sys_open() 打开三个标准流。如果应用程序使用 stdio，__rt_lib_init 会调用此函数。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">5.15 __ARM_get_argv</h3> 
<p style="margin-left:0;">此函数获取传递给 main() 的 argc 和 argv 值。该函数分别在寄存器 r0 和 r1 中返回 argc 和 argv。该函数可能会在寄存器 r2 和 r3 中返回另外两个参数。如果 main() 用参数声明，__rt_lib_init 调用此函数。</p> 
<p style="margin-left:0;">__ARM_get_argv 调用 _sys_command_string 以获取作为单个字符串的参数列表。然后它将这个字符串分解为每个单词的单独字符串。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">5.16 __alloca_initialize</h3> 
<p style="margin-left:0;">此函数将 alloca 列表指针设置为 NULL。如果使用基于 RVCT 堆的分配，__rt_lib_init 将调用此函数。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">5.17 __ARM_exceptions_init</h3> 
<p style="margin-left:0;">此函数设置 C++ 异常处理状态。如果应用程序使用 C++ 异常，__rt_lib_init 会调用此函数。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">5.18 __cpp_initialize__aeabi_</h3> 
<p style="margin-left:0;">此函数调用顶级 C++ 对象的构造函数。如果应用程序具有顶级 C++ 对象，__rt_lib_init 将调用此函数。</p> 
<p style="margin-left:0;"></p> 
<h3 style="margin-left:0px;">5.19 参见</h3> 
<p style="margin-left:0;">__rt_entry 调用的函数</p> 
<p style="margin-left:0;">使用 ARM C 和 C++ 库和浮点支持：</p> 
<p style="margin-left:0;">        • __rt_fp_status_addr()</p> 
<p style="margin-left:0;">        • 在利用 C 库时使用 malloc()</p> 
<p style="margin-left:0;">        • 从裸机 C 使用堆实现</p> 
<p style="margin-left:0;">        • C 库中语言环境数据块的定义</p> 
<p style="margin-left:0;">        • C++ 初始化、构造和销毁</p> 
<p style="margin-left:0;">        • 执行环境的初始化和应用程序的执行</p> 
<p style="margin-left:0;">        • 异常系统初始化</p> 
<p style="margin-left:0;">        • 在C 库中定制语言环境函数的汇编器宏。</p> 
<p style="margin-left:0;">ARM C 和 C++ 库和浮点支持参考：</p> 
<p style="margin-left:0;">        • _getenv_init()</p> 
<p style="margin-left:0;">        • getenv()</p> 
<p style="margin-left:0;">        • _clock_init()</p> 
<p style="margin-left:0;">        • _findlocale()</p> 
<p style="margin-left:0;">        • _sys_command_string()</p> 
<p style="margin-left:0;">        • __rt_lib_init。</p> 
<p style="margin-left:0;">链接器参考：</p> 
<p style="margin-left:0;">        • --ref_cpp_init, --no_ref_cpp_init。</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"></p> 
<h2 style="margin-left:0px;">6 附录</h2> 
<p style="margin-left:0;">本附录提供了在应用程序启动期间可能调用的各种函数的摘要。它还显示该函数何时包含在启动代码中。</p> 
<p style="margin-left:0;"><strong>表1 启动功能汇总</strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;"><strong>符号名称 </strong></p> 
<p style="margin-left:0;"><strong>描述 </strong></p> 
<p style="margin-left:0;"><strong>包含在启动代码中</strong></p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">__alloca_initialize</p> 
<p style="margin-left:0;">将 alloca 列表指针设置为 NULL</p> 
<p style="margin-left:0;">使用基于堆的 alloca 时</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">__ARM_exceptions_init</p> 
<p style="margin-left:0;">设置异常处理状态</p> 
<p style="margin-left:0;">使用 C++ 异常时</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">__ARM_get_argv</p> 
<p style="margin-left:0;">获取 main() 的 argc 和 argv 值</p> 
<p style="margin-left:0;">如果 main() 使用参数定义</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">_atexit_init</p> 
<p style="margin-left:0;">为函数指针设置存储</p> 
<p style="margin-left:0;">使用 atexit() 时</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">_clock_init</p> 
<p style="margin-left:0;">读取由 clock() 使用的计时器的当前值</p> 
<p style="margin-left:0;">使用 clock() 时</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">__cpp_initialize__aeabi_</p> 
<p style="margin-left:0;">调用顶级 C++ 构造函数</p> 
<p style="margin-left:0;">当使用顶级 C++ 对象时</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">_fp_init</p> 
<p style="margin-left:0;">初始化浮点环境</p> 
<p style="margin-left:0;">始终</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">_fp_trap_init</p> 
<p style="margin-left:0;">为浮点异常处理程序设置存储</p> 
<p style="margin-left:0;">使用捕获的浮点异常时</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">_get_lc_collat​​e</p> 
<p style="margin-left:0;">存储指向包含 LC_COLLATE 设置的数据块的指针</p> 
<p style="margin-left:0;">当使用依赖于整理区域设置的函数时</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">_get_lc_ctype</p> 
<p style="margin-left:0;">存储指向包含 LC_CTYPE 的数据块的指针settings</p> 
<p style="margin-left:0;">使用依赖于 ctype 的功能时区域设置</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">_get_lc_monetary</p> 
<p style="margin-left:0;">存储指向包含 LC_MONETARY 设置的数据块的指针</p> 
<p style="margin-left:0;">当使用依赖于货币区域设置的函数时</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">_get_lc_numeric</p> 
<p style="margin-left:0;">存储指向包含 LC_NUMERIC 设置的数据块的指针</p> 
<p style="margin-left:0;">当使用依赖于数字区域设置的函数时</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">_get_lc_time</p> 
<p style="margin-left:0;">存储指向包含 LC_TIME 设置的数据块的指针</p> 
<p style="margin-left:0;">使用依赖于时间区域设置的函数时</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">_getenv_init</p> 
<p style="margin-left:0;">使 getenv() 能够自行初始化</p> 
<p style="margin-left:0;">如果定义 _getenv_init</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">_init_alloc</p> 
<p style="margin-left:0;">设置 malloc、free 和其他相关函数使用的数据结构</p> 
<p style="margin-left:0;">使用堆时</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">_initio</p> 
<p style="margin-left:0;">设置 stdio 内部状态</p> 
<p style="margin-left:0;">使用 stdio 时</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">_rand_init</p> 
<p style="margin-left:0;">初始化随机数生成器</p> 
<p style="margin-left:0;">使用 rand() 时</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">_platform_post_lib_init</p> 
<p style="margin-left:0;">在 __rt_lib_init 之后启用初始化</p> 
<p style="margin-left:0;">如果您定义 _platform_post_lib_init</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">_platform_post_stackheap_init</p> 
<p style="margin-left:0;">在堆栈初始化后启用初始化</p> 
<p style="margin-left:0;">如果您定义 _platform_post_stackheap_init</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">_platform_pre_stackheap_init</p> 
<p style="margin-left:0;">在堆栈初始化之前启用初始化</p> 
<p style="margin-left:0;">如果定义 _platform_pre_stackheap_init</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">__rt_entry</p> 
<p style="margin-left:0;">设置运行时环境，然后调用 main() 始终 __rt_lib_init 调用必要的 C 库初始化函数</p> 
<p style="margin-left:0;">始终</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">__scatterload</p> 
<p style="margin-left:0;">将代码和数据从加载区域复制到执行区域</p> 
<p style="margin-left:0;">始终</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">_signal_init</p> 
<p style="margin-left:0;">为信号处理程序设置存储</p> 
<p style="margin-left:0;">使用 signal() 时</p> 
<p style="margin-left:0;"></p> 
<p style="margin-left:0;">_user_setup_stackheap</p> 
<p style="margin-left:0;">设置堆栈和堆</p> 
<p style="margin-left:0;">如果您定义 _user_setup_stackheap</p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7009923d70763b73baf1ceae555d0323/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于acrobat登录弹窗解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/544b37f5890de49f0623b390250f3342/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">自动化测试之：python各种测试用库</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>