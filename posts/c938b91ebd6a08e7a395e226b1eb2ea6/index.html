<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>面试-框架篇 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="面试-框架篇" />
<meta property="og:description" content="Spring 你对Spring了解多少？ Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inverse of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。
Spring 提供的核心功能主要是 IoC 和 AOP
IOC IoC（Inverse of Control:控制反转） 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。
IoC 容器是 Spring⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注（DI）⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件/注解即可，完全不⽤考虑对象是如何被创建出来的。
AOP 动态代理
AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。
Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDKProxy，去创建代理对象，⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了，这时候Spring AOP会使⽤基于asm框架字节流的Cglib动态代理 ，这时候Spring AOP会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理。
当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/c938b91ebd6a08e7a395e226b1eb2ea6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-25T15:56:12+08:00" />
<meta property="article:modified_time" content="2022-10-25T15:56:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">面试-框架篇</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>Spring</h2> 
<h3><span style="color:#fe2c24;"><strong>你对Spring了解多少？</strong></span></h3> 
<p>Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发<span style="color:#fe2c24;">，比如说 Spring 支持 IoC（Inverse of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)</span>、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。</p> 
<p>Spring 提供的核心功能主要是 IoC 和 AOP</p> 
<h4>IOC</h4> 
<p><strong>IoC（Inverse of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p> 
<p>IoC 容器是 Spring⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注（DI）⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件/注解即可，完全不⽤考虑对象是如何被创建出来的。</p> 
<p><strong>AOP 动态代理</strong></p> 
<blockquote> 
 <p>AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p> 
 <p>Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDKProxy，去创建代理对象，⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了，这时候Spring AOP会使⽤基于asm框架字节流的Cglib动态代理 ，这时候Spring AOP会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理。</p> 
</blockquote> 
<p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p> 
<p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p> 
<h4>Spring AOP 和 AspectJ AOP 有什么区别?</h4> 
<blockquote> 
 <p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p> 
 <p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p> 
 <p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p> 
</blockquote> 
<h2>SpringBean得生命周期</h2> 
<blockquote> 
 <p>​ （1）通过构造器创建 bean 实例（无参数构造）</p> 
 <p>​ （2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</p> 
 <p>​ （3）把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization</p> 
 <p>​ （4）调用 bean 的初始化的方法（需要进行配置初始化的方法）</p> 
 <p>​ （5）把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization</p> 
 <p>​ （6）bean 可以使用了（对象获取到了）</p> 
 <p>​ （7）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</p> 
</blockquote> 
<p></p> 
<h2>Spring源码<a href="https://www.bilibili.com/video/BV1Q44y1V7fi?spm_id_from=333.337.top_right_bar_window_custom_collection.content.click" rel="nofollow" title="没有套路，全是技术：思路最清晰的Spring源码分析教程，最后再给你手写一个Spring，就问你顶不顶_哔哩哔哩_bilibili">没有套路，全是技术：思路最清晰的Spring源码分析教程，最后再给你手写一个Spring，就问你顶不顶_哔哩哔哩_bilibili</a></h2> 
<p><img alt="" height="405" src="https://images2.imgbox.com/c7/b4/iQbuxx0O_o.png" width="592"></p> 
<p></p> 
<h3>初识spring</h3> 
<p>spring大致流程(初级)</p> 
<p>UserService类---&gt;<span style="color:#fe2c24;"><strong>无参的构造方法(相当于只是一个空对象)</strong></span>---&gt;对象---&gt;依赖注入(如果有@Autowaire注解的对象，会注入)--&gt;Bean对象</p> 
<hr> 
<p>如果是单例bean </p> 
<p>UserService类---&gt;<span style="color:#fe2c24;"><strong>无参的构造方法(相当于只是一个空对象)</strong></span>---&gt;对象---&gt;依赖注入(如果有@Autowaire注解的对象，会注入)--&gt;放入map----&gt;Bean对象</p> 
<p><img alt="" height="51" src="https://images2.imgbox.com/b5/a1/OWJFP456_o.png" width="821"></p> 
<p> spring底层有一个map(单例池)，getBean的时候就去寻找key为userService的值，如果没有就创建一个，如果有直接拿，所以spring是单例的</p> 
<hr> 
<p>如果是多例bean就没有map，也不存在放入map这一步</p> 
<hr> 
<p><strong>bean对象和对象有什么区别？</strong></p> 
<p>bean和bean对象大部分情况下都指的是同一个对象，只不过是不同阶段</p> 
<p>就好像10岁的小男孩(对象)，成长为30岁的男人(bean对象)</p> 
<hr> 
<p>spring大致流程(进阶)</p> 
<blockquote> 
 <p><u>UserService类---&gt;无参的构造方法---&gt;对象---&gt;依赖注入--&gt;<span style="color:#fe2c24;"><strong>初始化前(</strong></span>@PostConstruct<span style="color:#fe2c24;"><strong>)---&gt;初始化(</strong></span>afterPropertiesSet<span style="color:#fe2c24;"><strong>)--&gt;初始化后(AOP)</strong></span>--&gt;放入Map单例池---&gt;Bean对象</u></p> 
</blockquote> 
<p>依赖注入后，对象有一个初始化过程：</p> 
<p><strong>什么是初始化前？</strong></p> 
<p><img alt="" height="318" src="https://images2.imgbox.com/35/6a/yQu8ypSA_o.png" width="469"></p> 
<p> userservice中有一个属性是admin，admin的含义是获取管理员信息，获取方式是从数据库中去，假如需要执行这个sql</p> 
<p>select * from db_user where `is_admin` = 1</p> 
<p>这样admin就被赋值成功，那spring怎么知道admin的赋值就是这个方法呢？给该方法上加入@PostConstruct ，就是初始化前需要执行的方法</p> 
<p><img alt="" height="406" src="https://images2.imgbox.com/5b/47/ZLTUdZQD_o.png" width="534"></p> 
<p>源码大概是这样，遍历所有方法，看看有没有@Postconstruct的注解 </p> 
<p><img alt="" height="376" src="https://images2.imgbox.com/73/57/CHlB1UN6_o.png" width="986"></p> 
<hr> 
<p><strong>什么是初始化？</strong></p> 
<p><a href="https://www.bilibili.com/video/BV1Q44y1V7fi?p=5&amp;spm_id_from=pageDriver&amp;vd_source=09cff8f1aecdef9d3ca62a3d91ea4af9" rel="nofollow" title="5、Bean的初始化是如何工作的？_哔哩哔哩_bilibili">5、Bean的初始化是如何工作的？_哔哩哔哩_bilibili</a></p> 
<p>Q：拿之前的案例，获取管理员，可以放到初始化前，也可以放在初始化的时候。初始化前的加@postconstruct注解，初始化的时候呢？</p> 
<p>A:bean对象继承InitializingBean接口，然后重新afterPropertiesSet方法</p> 
<p> <img alt="" height="450" src="https://images2.imgbox.com/51/95/E37n8tqj_o.png" width="663"></p> 
<p> Q：spring是如何判断类继承了InitializingBean接口的呢？</p> 
<p><img alt="" height="33" src="https://images2.imgbox.com/42/58/Q98720Dz_o.png" width="595"></p> 
<p></p> 
<hr> 
<p><strong>bean的初始化和bean的实例化区别</strong></p> 
<p><img alt="" height="90" src="https://images2.imgbox.com/69/72/6RFhszZd_o.png" width="1200"></p> 
<p></p> 
<hr> 
<p><strong>什么是初始化后？</strong></p> 
<p>其实初始化后就是AOP，如果使用动态代理，那就好生产一个代理对象，那就不是将之前实例化的对象放入map单例池，而是将代理对象放入。后面会详细解释初始化后(AOP)</p> 
<p><span style="color:#fe2c24;">那spring的流程就会再次进阶成</span></p> 
<blockquote> 
 <p><img alt="" height="50" src="https://images2.imgbox.com/0e/f3/oTJ5a2pA_o.png" width="1200"></p> 
</blockquote> 
<hr> 
<h3>进一步spring</h3> 
<p><strong><u>无参的构造方法的说明</u></strong></p> 
<p><a href="https://www.bilibili.com/video/BV1Q44y1V7fi?p=9&amp;spm_id_from=pageDriver&amp;vd_source=09cff8f1aecdef9d3ca62a3d91ea4af9" rel="nofollow" title="9、什么是先bytype再byName_哔哩哔哩_bilibili">9、什么是先bytype再byName_哔哩哔哩_bilibili</a></p> 
<p>s在实例化bean的时候</p> 
<p>如果类中只定义了一个构造方法(无论是有参还是无参)那就会调用这个方法</p> 
<p>如果类中只定义了多个构造方法，如果<span style="color:#fe2c24;">有无参就调用无参</span>，<span style="color:#0d0016;">如果</span><span style="color:#fe2c24;">没有无参就报错</span></p> 
<p>especially，我们可以指定spring调用某个构造方法，只要在那个构造方法上面加上@Autowired</p> 
<p>就可以</p> 
<p><img alt="" height="334" src="https://images2.imgbox.com/03/af/NaJIEUQA_o.png" width="999"></p> 
<blockquote> 
 <p> 这样我们就可以把无参的构造方法改成推断构造方法</p> 
 <p><img alt="" height="48" src="https://images2.imgbox.com/ab/31/PxE6Jhtz_o.png" width="1200"></p> 
 <p></p> 
</blockquote> 
<p></p> 
<p><strong>Q：那么问题来啦，调用有参构造方法的时候，spring是怎么知道参数是什么的</strong></p> 
<p>A：参数类型是OrderService，那spring会去map单例池中找OrderService bean对象，有的话，直接调用，没有的话就创建，那又来问题了，会出现<span style="color:#fe2c24;"><strong>循环依赖</strong></span></p> 
<p><span style="color:#0d0016;"><strong>Q;去map单例池中寻找对象，是根据type还是根据name？</strong></span></p> 
<p><span style="color:#0d0016;">A：如果根据name，会不会乱套，假如写错了name，写成</span></p> 
<p><span style="color:#0d0016;">public Userservice(orderservice userservice) ，那spring不就去找userservice这个bean对象，不就会出错，即ByName的话，如果名字乱套，随便取名字就会出错，所以spring是ByType。</span></p> 
<p><strong><span style="color:#0d0016;">Q：但是又有问题了，Orderservice类型的bean对象有好几个怎么办，即在map单例池中，key为Orderservice的value有好多个，那怎么具体到哪一个Orderservice类型的bean对象呢？</span></strong></p> 
<p>A：spring就会现根据type找到符合条件得bean，然后再根据入参得名字去寻找bean ，如果我们得入参是OrderService orderService,那spring就找到第三个 OrderService 类型得bean</p> 
<p><img alt="" height="378" src="https://images2.imgbox.com/7b/e6/WaUN8Je8_o.png" width="623"></p> 
<p> <img alt="" height="156" src="https://images2.imgbox.com/9a/b4/Lwcqr0DQ_o.png" width="511"></p> 
<blockquote> 
 <p><span style="color:#fe2c24;"> 注意，application.getBean是根据name调用的bean对象</span></p> 
 <p><img alt="" height="124" src="https://images2.imgbox.com/76/94/JTtbHpvG_o.png" width="694"></p> 
 <p><strong> 再讲一下什么是单例bean</strong></p> 
 <p><img alt="" height="544" src="https://images2.imgbox.com/90/27/vdWQ7dcD_o.png" width="1200"></p> 
 <p> 如果getbean按name取多次，取得都是同一个对象。如果</p> 
 <p></p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong><span style="background-color:#fef2f0;">总结：推断构造方法！！！</span></strong></span></p> 
 <p> spring去类中寻找构造方法，如果有无参构造方法就选无参构造方法，如果没有无参但是只有一个有参构造方法，那就调用唯一的有参。</p> 
 <p>但是如果没有无参，且有多个有参，spring就看看哪个有参构造方法上面加了@Autowired注解，如果没有加@Autowired注解的有参，就会报错。</p> 
 <p>确定好了构造方法后，看看选定的构造方法中有没有入参，如果有入参就根据“先byType再ByName”的方式去map单例池中找到符合条件的bean对象，执行构造方法。</p> 
</blockquote> 
<hr> 
<h3>依赖注入的说明</h3> 
<p><img alt="" height="233" src="https://images2.imgbox.com/9a/a1/1a63Vd4r_o.png" width="760"></p> 
<p> 根据@Autowired注解，去单例池中找到对应的bean对象，也是根据“先byType再byName”的方法</p> 
<hr> 
<h3>初始化后(AOP)的说明</h3> 
<h4>理论</h4> 
<p>先看一下，但目前为止，我们看到的bean创建流程，<strong><span style="color:#fe2c24;"><span style="background-color:#fff5e6;">初始化后得到代理对象，这里是不会对代理对象进行DI的</span></span></strong></p> 
<p><img alt="" height="48" src="https://images2.imgbox.com/bf/c5/0gn9cWJB_o.png" width="1200"></p> 
<p>简述一下动态代理</p> 
<p>搞一个代理类继承UserService，重写test方法(需要扩展的方法),然后使用super.test()调用原来的test方法，然后在super.test()前后加上需要扩展的逻辑</p> 
<p><img alt="" height="397" src="https://images2.imgbox.com/c1/fa/YFHtsFUo_o.png" width="570"></p> 
<p>但是这样存在一个问题，如果UserService注入了对象OrderService，且调用了OrderService的方法，如果super.test()，是没办法注入OrderService对象的，因为<strong><span style="color:#fe2c24;"><span style="background-color:#fff5e6;">初始化后得到代理对象，spring是不会对代理对象进行DI的. </span></span><span style="color:#0d0016;">那</span></strong><span style="color:#0d0016;">spring是真没搞得呢？</span></p> 
<p>是直接调用普通对象，然后调用test方法 </p> 
<p> <img alt="" height="420" src="https://images2.imgbox.com/bd/66/3Rv1Zamq_o.png" width="986"></p> 
<h4>有了这个理论基础之后，我们来看看spring的事务</h4> 
<p><a href="https://www.bilibili.com/video/BV1Q44y1V7fi?p=11&amp;spm_id_from=pageDriver&amp;vd_source=09cff8f1aecdef9d3ca62a3d91ea4af9" rel="nofollow" title="11、Spring事务底层是怎么工作的？_哔哩哔哩_bilibili">11、Spring事务底层是怎么工作的？_哔哩哔哩_bilibili</a></p> 
<p>@Transcatinal 就是事务的注解，假如在类UserService的test方法上加了@Transcatinal</p> 
<p>他的底层原理就是，先看看有没有@Transcatinal注解的方法，有的话就会使用AOP，在test方法前后加了切面逻辑，具体如下</p> 
<blockquote> 
 <p><span style="color:#fe2c24;">这里对事务管理器建立连接的说明还不够准确，详细看下面@configuration部分</span></p> 
</blockquote> 
<p><img alt="" height="454" src="https://images2.imgbox.com/c6/29/kIIeODyg_o.png" width="936"></p> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;"><span style="background-color:#fef2f0;">这就是aop的思想！ 使用了aop的对象，就会被spring创建一个代理对象</span></span></strong></p> 
</blockquote> 
<p> 为了加深理解，我们再来看一下事务失效的情况</p> 
<p><img alt="" height="547" src="https://images2.imgbox.com/c5/11/AzzoXdCi_o.png" width="1028"></p> 
<p>propagation是事务的传播，NEVER的意思就是，如果已经存在了事务，就抛异常，第一感觉是肯定抛异常，因为test方法已经有事务了，在调用a方法就会报错</p> 
<p>但实际情况是不会报错，a方法上的@Transactional注解失效。</p> 
<p>为什么会失效？</p> 
<p>由上面AOP的理论部分可以知道spring运行时候，代理对象调用test的对象是普通对象，即<span style="color:#fe2c24;">普通对象中只存在普通方法，即所有注解都是失效的</span>。 </p> 
<p>翻译一下,就是这样</p> 
<pre><code class="language-java">    @Transactional
    public void test(){
        jdbcTemplate.execute( "insert into t1 values(1,1,1,1,'1')");
        //a();
        jdbcTemplate.execute( "insert into t1 values(2,2,2,2,'2')");

    }
    
    //@Transactional(propagation = Propagation.NEVER)
    //public void a(){
    //    jdbcTemplate.execute( "insert into t1 values(2,2,2,2,'2')");
    //}</code></pre> 
<p>那我们该怎么做到让两个注解都生效呢？</p> 
<p>那就让a方法，也被代理对象调用 </p> 
<p><img alt="" height="424" src="https://images2.imgbox.com/d9/c4/wFwJgRKn_o.png" width="1200"></p> 
<p><img alt="" height="550" src="https://images2.imgbox.com/c7/65/7PI6Lcw4_o.png" width="929"></p> 
<hr> 
<h3> @Configuration</h3> 
<p><a href="https://www.bilibili.com/video/BV1Q44y1V7fi?p=12&amp;spm_id_from=pageDriver&amp;vd_source=09cff8f1aecdef9d3ca62a3d91ea4af9" rel="nofollow" title="12、@Configuration注解的作用是什么？_哔哩哔哩_bilibili">12、@Configuration注解的作用是什么？_哔哩哔哩_bilibili</a></p> 
<p><img alt="" height="614" src="https://images2.imgbox.com/04/da/9HtpZffX_o.png" width="1113"></p> 
<p></p> 
<p> 我们可以看到事务管理器获取连接的时候需要一个datasource，jdbc建立连接也需要datasource</p> 
<p><img alt="" height="313" src="https://images2.imgbox.com/4e/f6/avpRZiRC_o.png" width="976"></p> 
<p> 书接上文，Q：为什么不用JDBC进行连接？</p> 
<p>A：多个SQL，就会多个JDBC建立连接，spring只会在增强的部分关闭自动提交和提交/回滚，多个jdbc自己建立连接，就不好统一管理；</p> 
<p>所以spring自己建立连接，然后jdbc共享这个连接，就方便统一管理。</p> 
<p>Q：那如何使得jdbc共享这个连接呢？</p> 
<p>A：使用ThreadLocal，Map&lt;DataSource，conn&gt;的形式存放，如果jdbc和事务管理器能得到同一个datasource，那就能获取同一个连接</p> 
<p>Q：那如何保证拿到同一个datasource呢？</p> 
<p>A；看上面第一个图，是没有加@Configuration的，如果调用JDBC的方法，JDBC就去调用datasource方法，创建一个新连接，</p> 
<p>如果调用事务管理器方法，调用datasource方法(无法保证datasource跟jdbc的一样)，又创建一个新连接，就是不同的连接(即无法保证两次获取的datasource都是去容器里取得，<span style="color:#fe2c24;">我们见到的去容器中取，都是使用@Autowired等注解</span>)。加上@Configuration，就会将Appconfig变成代理对象，前置通知就会判断是否存在datasoure，如果没有就执行蓝框子中的datasource方法，注入到容器中，这样另一个获取datasource的时候直接从容器中取，就能保证是同一个datasource</p> 
<p></p> 
<hr> 
<h3>循环依赖</h3> 
<blockquote> 
 <p>将类注入到容器中，spring会将类名的第一个大写字母改为小写，然后命名这个类，但是如果该类的前两个字母都是大写，那就不会转为小写</p> 
</blockquote> 
<blockquote> 
 <p><span style="color:#ff9900;">回答第一步什么是循环依赖 </span></p> 
 <p><span style="color:#0d0016;">假设我们有两个类,其中AService中注入了BService，BService中注入了AService</span></p> 
 <p><span style="color:#0d0016;">我们知道bean的生命周期中创建完了一个AService普通对象之后，就要填充BService属性，这时候就要去单例池中去找BService对象，发现没有，就去创建BService的bean对象，先是创建BService的普通对象，然后填充aService属性，这时候就要去单例池中去找AService对象，发现没有，就又去 创建AService的普通对象，进入死循环，这就是循环依赖。</span></p> 
</blockquote> 
<p><img alt="" height="429" src="https://images2.imgbox.com/90/13/3xlg2Xwh_o.png" width="910"></p> 
<blockquote> 
 <p><span style="color:#ffd900;">回答第二步：先看看二级缓存的解决效果</span></p> 
 <p><img alt="" height="491" src="https://images2.imgbox.com/02/a1/GkHXsrbc_o.png" width="1200"></p> 
 <p> Q：普通对象不是一个空对象吗，啥也没有，如果A中有其他的加了@Autowired的属性不是空的吗，这样B怎么调用A</p> 
 <p>A：不是的，zhouyumap中存的是地址，A创建生命周期后续会填入的，那B从map中取得A也会同步。<span style="color:#fe2c24;">所以@Autowired并不是AOP的成分</span></p> 
 <p>那么这样看来好像也听不错的</p> 
 <p>但是如果这样<span style="color:#fe2c24;">给b的是A的普通对象，但是A放在单例池中的是代理对象。</span><span style="color:#9c8ec1;"><strong>这里还是要继续详细了解一下</strong></span></p> 
 <p>(猜想，@Autowired的意思是去容器中取代理对象(如果存在AOP)，跟B取A的普通对象，矛盾)</p> 
 <p><span style="color:#fe2c24;"><strong>那么我们在zhouyumap中直接放aop不就行了</strong></span></p> 
</blockquote> 
<p>接上面的思路，提前AOP，然后放入 <span style="color:#fe2c24;"><strong>zhouyumap</strong></span></p> 
<p><img alt="" height="456" src="https://images2.imgbox.com/c4/29/TKvubMVK_o.png" width="1193"></p> 
<p> Q: A怎么知道要提前AOP 呢，在图中的<span style="background-color:#fe2c24;">  ？ </span>  处可以吗？，</p> 
<p>A：好像不可以，A还没创建B，肯定不知道B要创建A，会出现循环。<span style="color:#fe2c24;">只有B才会知道</span></p> 
<p><span style="color:#0d0016;">下面看看三级缓存是怎么做到的</span></p> 
<p><img alt="" height="563" src="https://images2.imgbox.com/80/62/aKYx6b2m_o.png" width="1200"></p> 
<p> 但是如何A类中不仅有AB的循环依赖，还有AC的循环依赖怎么办？</p> 
<p><img alt="" height="353" src="https://images2.imgbox.com/d9/7b/KC03cyXw_o.png" width="453"></p> 
<p> <img alt="" height="395" src="https://images2.imgbox.com/88/1f/JOp8VS11_o.png" width="814"></p> 
<p><img alt="" height="571" src="https://images2.imgbox.com/94/89/tbhmKuX9_o.png" width="1200"></p> 
<p> Q：为什么要搞一个二级缓存&gt;earlysingletonobjects，不如直接放进单例池，然后C对象直接去取？</p> 
<p>A：提前AOP获得的代理对象是不完整的，其他的属性是不完整的，如果现在就放入单例池，其他bean调用，不就会出错</p> 
<p><strong><span style="color:#fe2c24;"><span style="background-color:#fef2f0;">所以二级缓存的作用就是存储没有经过完整的bean的声明周期的单例bean</span></span></strong></p> 
<p><span style="color:#edf6e8;"><span style="background-color:#1a439c;">又出现一个问题，就是在创建BService对象时，对A对象提前AOP的时候，怎么拿到A的普通对象，怎么知道AOP的操作有哪些？</span></span></p> 
<p></p> 
<blockquote> 
 <p><span style="color:#ff9900;"> 回答第三步：那么就要用到三级缓存</span></p> 
 <p><img alt="" height="613" src="https://images2.imgbox.com/1b/90/c6XO0Huv_o.png" width="1200"></p> 
 <p>三个缓存的说明</p> 
 <p>一级缓存-单例池-singletonObject： 存储经过完整bean生命周期得到的bean对象</p> 
 <p>二级缓存-earlysingletonObject：存<strong><span style="color:#fe2c24;"><span style="background-color:#fef2f0;">储没有经过完整的bean的生命周期的单例bean对象，能保证这类Bean是单例的</span></span></strong></p> 
 <p>三级缓存-earlysingletonFactories：某个bean是否要出现循环依赖是不知道的，所以spring将bean的名字+beandefinition+bean对象生成lambda表达式存到三级缓存中，当出现循环依赖的时候，直接取出lambda表达式，执行，如果需要AOP就返回代理对象，如果没有就直接返回bean普通对像</p> 
 <p>注释：</p> 
 <p>①boolean issingletoncurrentlyIncreation(beanName) 这是源码中对于第0步的方法<br> ②如果这样提前aop了，那上面的第五步就不需要aop了，且会在map中做一个判断，见图二</p> 
 <p>③如果第一步执行时候，使用的是有参构造方法，而入参里面有B类</p> 
 <p><img alt="" height="297" src="https://images2.imgbox.com/0f/01/HRjsXkrv_o.png" width="450"><img alt="" height="311" src="https://images2.imgbox.com/c1/1b/F6znOW9q_o.png" width="490"></p> 
 <p></p> 
 <p> 就不太好处理了，需要加上注解@Lazy</p> 
 <p><img alt="" height="346" src="https://images2.imgbox.com/22/a9/yCflVrMk_o.png" width="524"></p> 
</blockquote> 
<pre><code class="language-java">protected Object getSingleton(String beanName, boolean allowEarlyReference) {
        //先去一级缓存(单例池),找bean对象
		Object singletonObject = this.singletonObjects.get(beanName);
        //如果没有找到，并且当前正在创建当前bean
		if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {
			synchronized (this.singletonObjects) {//加锁
                //从二级缓存中找当前bean
				singletonObject = this.earlySingletonObjects.get(beanName);
                //如果不存在，并且允许循环依赖(？)
				if (singletonObject == null &amp;&amp; allowEarlyReference) {
					ObjectFactory&lt;?&gt; singletonFactory = 
  this.singletonFactories.get(beanName);//从三级缓存中找到当前bean对象的lambda表达式
					if (singletonFactory != null) {
                        //执行lambda获得代理对象或者实例对象
						singletonObject = singletonFactory.getObject();
                        //存入二级缓存
						this.earlySingletonObjects.put(beanName, singletonObject);
                        //删除三级缓存中的bean
						this.singletonFactories.remove(beanName);
					}
				}
			}
		}
		return singletonObject;
	}</code></pre> 
<p><img alt="" height="565" src="https://images2.imgbox.com/52/b6/8kWa13YK_o.png" width="985"></p> 
<p> 综上，终极流程</p> 
<p><img alt="" height="652" src="https://images2.imgbox.com/49/5f/HdbBrbPc_o.png" width="1200"></p> 
<hr> 
<h3>@Value</h3> 
<p><img alt="" height="454" src="https://images2.imgbox.com/05/f0/fuD0fSYM_o.png" width="1041"></p> 
<p></p> 
<p>1.如果value里面的key不存在，那么就会直接将key赋值给下面的属性 </p> 
<p><img alt="" height="71" src="https://images2.imgbox.com/55/77/Bpz1o1XK_o.png" width="313"><img alt="" height="254" src="https://images2.imgbox.com/fd/6c/5G4t8Aa5_o.png" width="436"></p> 
<p></p> 
<p>2.如果value里面不用   ${ }   这个格式的写法，那么就直接将值赋给属性</p> 
<p><img alt="" height="679" src="https://images2.imgbox.com/81/b1/lzd7wSiA_o.png" width="1002"></p> 
<p></p> 
<hr> 
<h3>@Lazy</h3> 
<p>加在类上：</p> 
<p>加上Lazy的类，只会在调用的时候生成bean对象</p> 
<p>不加lazy的类，在容器创建时，也会创建</p> 
<p>加在属性上</p> 
<p>加上lazy的属性，没有被使用的时候，给他会赋一个代理对象，等到真正用的时候才回去容器里拿</p> 
<p>写在方法上，就等于写在方法的所有参数上，跟写在属性上的效果是一样的</p> 
<hr> 
<p><img alt="" height="266" src="https://images2.imgbox.com/a5/09/hFErS9Dh_o.png" width="607"></p> 
<hr> 
<h2>Bean的作用域</h2> 
<p>单例 ：原理就是将创建好的bean对象都放入单例池中，要用直接拿，不再创建</p> 
<p>多例：就是直接创建</p> 
<p>Request，Session，application：都是仅用于web应用，如果作用域是request，那么会先先调用requst.getAttribute，看看能不能拿到指定的bean对象，如果有直接返回，如果没有调用requst.setAttribute，创建好了扔进去，session也是调用session.getAttribute和session.setAttribute。application调用application.getAttribute和application.setAttribute</p> 
<p><img alt="" height="301" src="https://images2.imgbox.com/ef/4c/UhnZ3U0Q_o.png" width="689"></p> 
<p></p> 
<hr> 
<p> <img alt="" height="208" src="https://images2.imgbox.com/b6/e1/YKNNTu2f_o.png" width="592"></p> 
<h2>SpringMVC</h2> 
<h4>SpringMVC处理请求的底层原理</h4> 
<blockquote> 
 <p>Tomcat启动</p> 
 <p>解析web.xml</p> 
 <p>dispatcherServlet实例化</p> 
 <p>dispatcherServlet.init()</p> 
 <p>初始化会得到spring容器-xmlwebapplication，注意此时容器还是空的</p> 
 <p>然后调用</p> 
 <p>getContextConfiguration方法，获取spring的配置文件 </p> 
 <p><img alt="" height="163" src="https://images2.imgbox.com/f1/6a/zbyoslY7_o.png" width="934"></p> 
 <p>然后调用图中的redresh，加载所有的bean</p> 
</blockquote> 
<h4> SpringMVC处理请求的底层原理</h4> 
<blockquote> 
 <p>1. 客户端（浏览器）发送请求，直接请求到  DispatcherServlet 。<br> 2. DispatcherServlet 根据请求信息调⽤  HandlerMapping ，解析请求对应的  Handler 。<br> 3. 解析到对应的  Handler （也就是  Controller 控制器）后，开始由HandlerAdapter 适配器处理。<br> 4. HandlerAdapter 会根据  Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。<br> 5. 处理器处理完业务后，会返回⼀个  ModelAndView 对象， Model 是返回的数据对象<br> 6. ViewResolver 会根据逻辑  View 查找实际的  View 。<br> 7. DispaterServlet 把返回的  Model 传给  View （视图渲染）。<br> 8. 把  View 返回给请求者（浏览器）</p> 
</blockquote> 
<h4>SpringMVC常见的注解以及作用 </h4> 
<blockquote> 
 <p></p> 
 <p>@RequestMapping</p> 
 <p>将请求和处理请求的控制器方法关联 起来，建立映射关系。</p> 
 <p></p> 
 <p id="3%E3%80%81%40RequestParam">@RequestParam</p> 
 <p>将@RequestParam 的value中的对应的请求参数的值赋值给后面的形参</p> 
 <p></p> 
 <p>@RequestBody</p> 
 <p>作用就是将请求体的值 赋值给它标识的形参 </p> 
 <p></p> 
 <p>@ResponseBody</p> 
 <p>用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到 浏览器，直接在浏览器显示</p> 
</blockquote> 
<p></p> 
<h4>域对象共享数据</h4> 
<blockquote> 
 <p>一共有四个域对象：</p> 
 <p>servletcontext（application）：范围是服务器的开启到关闭</p> 
 <p>session：一次会话指的是浏览器的开启到关闭，跟服务器是否关闭无关</p> 
 <p>                session的钝化：浏览器没关，服务器关闭，此时会话仍在继续，原先存在session上的数据，经过序列化存放在磁盘上</p> 
 <p>                                活化：钝化后，服务器重启（此时浏览器没有关闭），将钝化的数据重新读取到session中</p> 
 <p>request：范围是一次请求，所以通过请求转发后，仍可以访问request域中的共享数据</p> 
 <p>pagecontext：仅仅在当前的页面有效</p> 
</blockquote> 
<h4 id="5%E3%80%81%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB"><strong>请求转发和重定向的区别</strong></h4> 
<blockquote> 
 <p>请求转发：①“一次”请求（请求是相对于浏览器，实际有两次请求）：第一次发生在浏览器，第二次发生在服务器内部</p> 
 <p>                  ②地址栏不会发生变化，始终是第一次请求的地址</p> 
 <p>                  ③请求转发后仍可以获取请求域中的共享数据（用的同一个request）</p> 
 <p>                  ④请求转发可以访问WEB-INF中的资源</p> 
 <p>重定向：    ①两次请求，第一次访问servlet，第二次访问重定向的地址</p> 
 <p>                  ②地址栏发生变化，最后的地址是重定向的地址</p> 
 <p>                  ③重定向后不可以获取请求域中的共享数据</p> 
 <p>                  ④重定向后不可以访问WEB-INF中的资源</p> 
 <p></p> 
 <p>**WEB-INF中的资源只允许服务器访问，不允许浏览器直接访问</p> 
</blockquote> 
<h4> Spring中的设计模式</h4> 
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485303&amp;idx=1&amp;sn=9e4626a1e3f001f9b0d84a6fa0cff04a&amp;chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&amp;token=255050878&amp;lang=zh_CN%23rd" rel="nofollow" title="面试官:“谈谈Spring中都用到了那些设计模式?”。">面试官:“谈谈Spring中都用到了那些设计模式?”。</a></p> 
<blockquote> 
 <p><strong>工厂设计模式</strong></p> 
 <p></p> 
 <p>Spring使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</p> 
 <p><strong>两者对比：</strong></p> 
 <ul><li> <p><code>BeanFactory</code> ：延迟注入(使用到某个 bean 的时候才会注入),相比于<code>BeanFactory</code>来说会占用更少的内存，程序启动速度更快。</p> </li><li> <p><code>ApplicationContext</code> ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。<code>BeanFactory</code> 仅提供了最基本的依赖注入支持，<code>ApplicationContext</code> 扩展了 <code>BeanFactory</code> ,除了有<code>BeanFactory</code>的功能还有额外更多功能，所以一般开发人员使用<code>ApplicationContext</code>会更多。</p> </li></ul> 
 <p><strong>单例设计模式</strong></p> 
 <p>Spring 中 bean 的默认作用域就是 singleton(单例)的。</p> 
 <p></p> 
 <p><strong>代理设计模式</strong></p> 
 <p>代理模式在 AOP 中的应用，详细见最上面对aop的描述</p> 
 <p></p> 
 <p><strong>观察者模式</strong></p> 
 <p>观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</p> 
 <p></p> 
 <p><strong>适配器模式</strong></p> 
 <p><a href="https://www.bilibili.com/video/BV1Hz411e7sA/?spm_id_from=333.337.search-card.all.click&amp;vd_source=09cff8f1aecdef9d3ca62a3d91ea4af9" rel="nofollow" title="五分钟学设计模式.06.适配器模式_哔哩哔哩_bilibili">五分钟学设计模式.06.适配器模式_哔哩哔哩_bilibili</a></p> 
 <p>我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式</p> 
 <p>spring MVC中的适配器模式</p> 
 <p><strong>为什么要在 Spring MVC 中使用适配器模式？</strong> Spring MVC 中的 <code>Controller</code> 种类众多，不同类型的 <code>Controller</code> 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，<code>DispatcherServlet</code> 直接获取对应类型的 <code>Controller</code>，需要的自行来判断</p> 
 <p></p> 
 <p><strong>装饰者模式</strong></p> 
 <p><a href="https://www.bilibili.com/video/BV1hp4y1D7MP/?spm_id_from=333.788&amp;vd_source=09cff8f1aecdef9d3ca62a3d91ea4af9" rel="nofollow" title="五分钟学设计模式.05.装饰器模式_哔哩哔哩_bilibili">五分钟学设计模式.05.装饰器模式_哔哩哔哩_bilibili</a></p> 
 <p>装饰器模式和代理模式很像，只不过代理模式只有一个方法，是对原方法的扩展，适配器可以有多个方法，是静态的</p> 
 <p><a href="https://www.bilibili.com/video/BV1kY411N7nH/?spm_id_from=333.337.search-card.all.click&amp;vd_source=09cff8f1aecdef9d3ca62a3d91ea4af9" rel="nofollow" title="动静态代理的区别是什么，一般在什么场景下使用_哔哩哔哩_bilibili">动静态代理的区别是什么，一般在什么场景下使用_哔哩哔哩_bilibili</a></p> 
</blockquote> 
<h3>SpringBoot的启动流程</h3> 
<blockquote> 
 <p>●SpringBoot先加载所有的自动配置类  xxxxxAutoConfiguration<br> ●每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。xxxxProperties里面拿。xxxProperties和配置文件进行了绑定<br> ●生效的配置类就会给容器中装配很多组件<br> ●只要容器中有这些组件，相当于这些功能就有了<br> ●定制化配置(详细见 https://www.bilibili.com/video/BV19K4y1L7MT?p=15&amp;spm_id_from=pageDriver 中的P15 24分钟开始)<br>     ○方法一：用户直接自己@Bean替换底层的组件<br>     ○方法二：用户去看这个组件是获取的配置文件什么值就去修改。<br> xxxxxAutoConfiguration ---&gt; 组件  ---&gt; xxxxProperties里面拿值  ----&gt; application.properties</p> 
 <p>人话：</p> 
 <p>springboot加载所有jar包下META-INF/spring.factories文件中的自动配置类xxxAutoConfiguration，<br> 一共127个（？？？为什么只加载EnableAutoConfiguration属性指定的类），但不一定127个都会被注入容器，<br> 每一个自动配置类都会根据条件装配，按需配置。自动配置类默认都会绑定配置文件(xxxProperties)，从配置文件中拿值。而这些值是从application.properties中获取的<br> 生效的配置类就会给容器中装配很多组件，只要容器中有这些组件，相当于这些功能就有。<br> 如果我们想修改一些默认的配置，有两个方法：<br> 一个是直接自己@Bean替换底层的组件，一个是到自动配置类对应的配置文件对应的application.properties中修改值<br>  </p> 
 <p>调用run方法，run方法的执行流程是：创建SpringBoot项目时，会默认生成一个application入口类，该类中含有的main方法可以实现项目的启动，main方法中spring application的静态方法，即run方法完成对spring application的实例化操作，针对实例化对象调用另一个run方法来实现整个项目的初始化和启动。run方法的操作有：获取监听器的参数配置，打印banner信息，创建并初始化容器，监听器发送通知。</p> 
 <p><img alt="" height="247" src="https://images2.imgbox.com/11/ed/PqEjQbrA_o.png" width="813"></p> 
 <p> </p> 
</blockquote> 
<h2>springe源码 <a href="https://www.bilibili.com/video/BV1t44y1H7dq?p=3&amp;spm_id_from=pageDriver&amp;vd_source=09cff8f1aecdef9d3ca62a3d91ea4af9" rel="nofollow" title="第一节：基础概述--ioc如何处理_哔哩哔哩_bilibili">第一节：基础概述--ioc如何处理_哔哩哔哩_bilibili</a></h2> 
<h4>IOC-Ⅰ</h4> 
<p><img alt="" height="524" src="https://images2.imgbox.com/b5/7a/iawwqdq3_o.png" width="951"></p> 
<p></p> 
<p><img alt="" height="173" src="https://images2.imgbox.com/9f/6d/zk8qV5ne_o.png" width="838"></p> 
<p> <img alt="" height="550" src="https://images2.imgbox.com/76/4f/UuyJ7G0o_o.png" width="939"></p> 
<p> <img alt="" height="668" src="https://images2.imgbox.com/f1/f2/mh2bLKj6_o.png" width="899"></p> 
<p> <img alt="" height="724" src="https://images2.imgbox.com/d3/9b/BvznrM8y_o.png" width="993"></p> 
<p> 实例化和初始化</p> 
<p><img alt="" height="281" src="https://images2.imgbox.com/2a/58/Ner9M06s_o.png" width="867"></p> 
<p> <img alt="" height="556" src="https://images2.imgbox.com/27/a0/VwXmngDy_o.png" width="1073"></p> 
<p></p> 
<p><img alt="" height="457" src="https://images2.imgbox.com/e0/a4/qkcUDxge_o.png" width="426"></p> 
<p> <img alt="" height="660" src="https://images2.imgbox.com/6d/30/MKfqmTCU_o.png" width="846"></p> 
<p> <img alt="" height="210" src="https://images2.imgbox.com/29/4d/xZdiaLFs_o.png" width="791"></p> 
<p> BeanFactory和FactoryBean的区别</p> 
<p><img alt="" height="660" src="https://images2.imgbox.com/27/32/DIIFoF46_o.png" width="1131"></p> 
<h2> Spring的执行流程</h2> 
<p>一第一步</p> 
<p>第一感觉第一步应该是读取xml配置文件，然后注入到bean容器，可以bean容器还没有呢，怎么注入</p> 
<p>所以第一步是创建bean容器</p> 
<p><img alt="" height="757" src="https://images2.imgbox.com/7f/02/CMgEloLt_o.png" width="1200"></p> 
<p> 第二步解析xml等配置文件，得到beanDefinition</p> 
<p>第三步</p> 
<p><img alt="" height="678" src="https://images2.imgbox.com/a9/56/zmotaQ8o_o.png" width="1200"></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/88bb67f1c549b9deb3756de48a843bcf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">论文阅读：分布式多传感器多目标跟踪方法综述</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b06b7f382aae557f9227d4c2e01e560a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">韩顺平java基础——坦克大战（含有线程、I\O流的讲解）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>