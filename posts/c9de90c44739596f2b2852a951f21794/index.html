<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深度思考rpc框架面经之一：基本组件和概览 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深度思考rpc框架面经之一：基本组件和概览" />
<meta property="og:description" content="1 一个rpc框架应该具有哪些组件？ 一个RPC（远程过程调用）框架通常由以下几个组件组成：
通信协议（Communication Protocol）：RPC框架需要定义一种通信协议，用于客户端和服务器之间的通信。这个协议可以是自定义的二进制格式，也可以是像JSON-RPC、gRPC、Thrift等标准化的协议。
序列化和反序列化（Serialization/Deserialization）：在远程过程调用中，参数和返回值需要在网络上进行传输。因此，数据必须被序列化为通信协议所支持的格式，然后在接收端进行反序列化。这使得客户端和服务器能够将数据转换为字节流以进行传输，并将其还原为数据结构以供处理。
代理（Proxy）：客户端需要通过代理来调用远程服务器上的方法。代理隐藏了底层的网络通信细节，使得客户端能够像调用本地方法一样调用远程方法，这里的代理负责具体的发送请求动作
Stub（存根）：服务器端也需要处理客户端发送的请求。Stub在服务器端扮演了代理的角色，接收客户端请求，解析它们，并将其转发给实际的服务实现。同样，客户端也需要存根来完成接收服务端的请求，从字节流中反序列化数据，序列化数据发送给客户端。
服务接口定义（Service Interface Definition）：RPC框架需要定义一种服务接口描述语言，以明确定义服务提供的方法和参数。这可以是使用IDL（接口定义语言）或类似的方法。
服务注册和发现（Service Registration and Discovery）：在一个分布式环境中，服务的位置可能会经常变化，因此需要一种机制来注册和发现可用的服务。这可以通过集中式服务注册中心或分布式服务发现机制来实现。
负载均衡（Load Balancing）：当多个服务提供相同功能时，负载均衡是确保请求在它们之间平衡分配的机制。这有助于提高系统的可伸缩性和性能。
安全性（Security）：RPC框架需要提供一定程度的安全性，确保通信过程中的数据传输和访问不会受到未经授权的访问或恶意攻击。
故障处理（Fault Tolerance）：分布式系统中难免会遇到故障，RPC框架应该具备一些故障处理机制，例如重试、超时设置和错误处理，以保障系统的可靠性。
监控和日志（Monitoring and Logging）：为了方便排查问题和了解系统的运行状况，RPC框架应该支持监控和日志记录，收集关键的性能指标和事件信息。
这些组件共同构成了一个完整的RPC框架，使得分布式系统中的不同服务能够方便地进行通信和交互。不同的RPC框架可能会有一些特定的功能和特性，但总体来说，它们都应该满足上述基本要素。
1.2 什么是Stub存根 1.2.1 这里的存根是指什么，用于服务调用端还是提供端 存根（Stub）是RPC框架中的一个关键组件，它是服务调用的客户端与服务器端之间的一个中介。存根可以存在于两端：
客户端存根（Client Stub）：当客户端希望调用远程服务时，它实际上首先调用的是客户端存根。客户端存根负责：
将调用的方法和参数序列化为一种格式，这个格式能够通过网络传输。通过网络发送这个序列化后的请求到服务器端。接收服务器的响应，然后反序列化该响应以转换为客户端可用的格式。 服务器端存根（Server Stub）：服务器端收到客户端的请求后，是由服务器端存根来处理这个请求的。服务器端存根的职责包括：
从网络接收序列化后的请求数据。反序列化这个请求以获取原始的方法调用和参数。调用实际的服务实现。将结果序列化并发送回客户端。 从上述描述中可以看出，存根起到了在客户端和服务器端之间转化调用的桥梁作用。客户端通过存根发送请求，服务器端通过存根接收请求并发送响应。
在许多RPC框架中，存根是自动生成的，通常是基于服务的接口定义（如IDL - 接口定义语言）。这样做的目的是为了减少开发者的工作量，使他们能够专注于业务逻辑的实现，而不是通信的细节。
1.2.2 给我一个protocol buffer协议中规定生成的存根格式 Protocol Buffers（通常简称为protobuf）是Google开发的一种序列化协议。在protobuf的上下文中，当我们谈论“存根”时，通常是指gRPC（Google的远程过程调用系统）中用protobuf定义的服务的客户端和服务器代码。
以下是一个protobuf协议的简单示例，定义了一个HelloService服务：
syntax = &#34;proto3&#34;; package example; // The message format for a greeting. message HelloRequest { string name = 1; } message HelloResponse { string greeting = 1; } // The HelloService service definition." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/c9de90c44739596f2b2852a951f21794/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-04T15:59:15+08:00" />
<meta property="article:modified_time" content="2023-09-04T15:59:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深度思考rpc框架面经之一：基本组件和概览</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_rpc_0"></a>1 一个rpc框架应该具有哪些组件？</h2> 
<p>一个RPC（远程过程调用）框架通常由以下几个组件组成：</p> 
<ol><li> <p>通信协议（Communication Protocol）：RPC框架需要定义一种通信协议，用于客户端和服务器之间的通信。这个协议可以是自定义的二进制格式，也可以是像JSON-RPC、gRPC、Thrift等标准化的协议。</p> </li><li> <p>序列化和反序列化（Serialization/Deserialization）：在远程过程调用中，参数和返回值需要在网络上进行传输。因此，数据必须被序列化为通信协议所支持的格式，然后在接收端进行反序列化。这使得客户端和服务器能够将数据转换为字节流以进行传输，并将其还原为数据结构以供处理。</p> </li><li> <p>代理（Proxy）：客户端需要通过代理来调用远程服务器上的方法。代理隐藏了底层的网络通信细节，使得客户端能够像调用本地方法一样调用远程方法，这里的代理负责具体的发送请求动作</p> </li><li> <p>Stub（存根）：服务器端也需要处理客户端发送的请求。Stub在服务器端扮演了代理的角色，接收客户端请求，解析它们，并将其转发给实际的服务实现。同样，客户端也需要存根来完成接收服务端的请求，从字节流中反序列化数据，序列化数据发送给客户端。</p> </li><li> <p>服务接口定义（Service Interface Definition）：RPC框架需要定义一种服务接口描述语言，以明确定义服务提供的方法和参数。这可以是使用IDL（接口定义语言）或类似的方法。</p> </li><li> <p>服务注册和发现（Service Registration and Discovery）：在一个分布式环境中，服务的位置可能会经常变化，因此需要一种机制来注册和发现可用的服务。这可以通过集中式服务注册中心或分布式服务发现机制来实现。</p> </li><li> <p>负载均衡（Load Balancing）：当多个服务提供相同功能时，负载均衡是确保请求在它们之间平衡分配的机制。这有助于提高系统的可伸缩性和性能。</p> </li><li> <p>安全性（Security）：RPC框架需要提供一定程度的安全性，确保通信过程中的数据传输和访问不会受到未经授权的访问或恶意攻击。</p> </li><li> <p>故障处理（Fault Tolerance）：分布式系统中难免会遇到故障，RPC框架应该具备一些故障处理机制，例如重试、超时设置和错误处理，以保障系统的可靠性。</p> </li><li> <p>监控和日志（Monitoring and Logging）：为了方便排查问题和了解系统的运行状况，RPC框架应该支持监控和日志记录，收集关键的性能指标和事件信息。</p> </li></ol> 
<p>这些组件共同构成了一个完整的RPC框架，使得分布式系统中的不同服务能够方便地进行通信和交互。不同的RPC框架可能会有一些特定的功能和特性，但总体来说，它们都应该满足上述基本要素。</p> 
<h3><a id="12_Stub_25"></a>1.2 什么是Stub存根</h3> 
<h4><a id="121__26"></a>1.2.1 这里的存根是指什么，用于服务调用端还是提供端</h4> 
<p>存根（Stub）是RPC框架中的一个关键组件，它是服务调用的客户端与服务器端之间的一个中介。存根可以存在于两端：</p> 
<ol><li> <p><strong>客户端存根（Client Stub）</strong>：当客户端希望调用远程服务时，它实际上首先调用的是客户端存根。客户端存根负责：</p> 
  <ul><li>将调用的方法和参数序列化为一种格式，这个格式能够通过网络传输。</li><li>通过网络发送这个序列化后的请求到服务器端。</li><li>接收服务器的响应，然后反序列化该响应以转换为客户端可用的格式。</li></ul> </li><li> <p><strong>服务器端存根（Server Stub）</strong>：服务器端收到客户端的请求后，是由服务器端存根来处理这个请求的。服务器端存根的职责包括：</p> 
  <ul><li>从网络接收序列化后的请求数据。</li><li>反序列化这个请求以获取原始的方法调用和参数。</li><li>调用实际的服务实现。</li><li>将结果序列化并发送回客户端。</li></ul> </li></ol> 
<p>从上述描述中可以看出，存根起到了在客户端和服务器端之间转化调用的桥梁作用。客户端通过存根发送请求，服务器端通过存根接收请求并发送响应。</p> 
<p>在许多RPC框架中，存根是自动生成的，通常是基于服务的接口定义（如IDL - 接口定义语言）。这样做的目的是为了减少开发者的工作量，使他们能够专注于业务逻辑的实现，而不是通信的细节。</p> 
<h4><a id="122_protocol_buffer_44"></a>1.2.2 给我一个protocol buffer协议中规定生成的存根格式</h4> 
<p>Protocol Buffers（通常简称为protobuf）是Google开发的一种序列化协议。在protobuf的上下文中，当我们谈论“存根”时，通常是指gRPC（Google的远程过程调用系统）中用protobuf定义的服务的客户端和服务器代码。</p> 
<p>以下是一个protobuf协议的简单示例，定义了一个<code>HelloService</code>服务：</p> 
<pre><code class="prism language-protobuf">syntax = "proto3";

package example;

// The message format for a greeting.
message HelloRequest {
  string name = 1;
}

message HelloResponse {
  string greeting = 1;
}

// The HelloService service definition.
service HelloService {
  rpc SayHello (HelloRequest) returns (HelloResponse);
}
</code></pre> 
<p>在上述定义中：</p> 
<ul><li><code>HelloRequest</code>和<code>HelloResponse</code>是两个消息格式。</li><li><code>HelloService</code>是一个服务定义，它有一个<code>SayHello</code>的RPC方法。</li></ul> 
<p>当你使用gRPC工具链（例如<code>protoc</code>编译器与gRPC插件）来编译这个<code>.proto</code>文件时，它将生成客户端和服务器的代码。对于大多数语言，这会生成以下内容：</p> 
<ol><li> <p><strong>客户端存根</strong>：允许应用程序在客户端调用<code>SayHello</code>方法，就像是本地调用一样。客户端存根处理消息的序列化、网络通信等细节。</p> </li><li> <p><strong>服务器端存根</strong>：应用程序可以继承并实现<code>SayHello</code>方法。当服务器收到客户端的<code>SayHello</code>请求时，它会调用这个实现。</p> </li></ol> 
<p>例如，对于Java，您可能会得到类似<code>HelloServiceGrpc.HelloServiceImplBase</code>的服务器存根，您可以扩展它来实现您的服务。同样地，客户端代码也会为你提供一种方法来调用远程服务。</p> 
<p>这种自动生成的存根使开发者能够专注于实现业务逻辑，而不必担心网络通信的复杂性。</p> 
<h2><a id="2_spring_cloud_dubbo_83"></a>2 spring cloud 和dubbo</h2> 
<h3><a id="21_Spring_Cloud__Dubbo__84"></a>2.1 <strong>Spring Cloud 和 Dubbo 的区别</strong>：</h3> 
<pre><code>- **功能差异**：Dubbo 主要是一个 RPC 框架，主要解决服务间的调用、负载均衡和**故障转移问题**。而 Spring Cloud 是一套完整的微服务解决方案，除了 RPC 调用，它还提供了服务注册与发现、配置中心、API 网关、熔断器、分布式链路追踪等多种微服务常用功能。

- **通信机制**：Dubbo 默认使用的是基于 TCP 协议的高性能 NIO 框架 Netty 进行网络通信，数据默认使用 Hessian 进行序列化，所以性能比较高。而 Spring Cloud 默认使用的是 HTTP/REST 作为服务通信协议，相比于 Dubbo 的二进制协议，性能相对较低。

- **集成度**：Spring Cloud 是 Spring 官方出品，和 Spring 其它项目集成度非常高，使用 Spring Boot 风格的启动和配置，让 Spring 用户能更方便的上手。而 Dubbo 需要手动进行各种配置，上手难度相对较大。

- **社区活跃度**：Spring Cloud 社区非常活跃，更新迭代速度快，能更好的应对新的业务场景。而 Dubbo 虽然现在已经捐赠给了 Apache，但是社区相比于 Spring Cloud 还是相对较小。
</code></pre> 
<h4><a id="211_dubboopen_feign_93"></a>2.1.1 dubbo作用是什么，与open feign有什么区别，各自使用场景？</h4> 
<p>Dubbo:</p> 
<ul><li>作用: Dubbo 是一个高性能、轻量级的开源Java RPC框架，它主要用于微服务之间的通信。它提供了负载均衡、容错、服务注册与发现等功能。</li><li>使用场景: 当你需要在分布式系统中进行服务间的高性能远程调用，特别是在较大的微服务架构中，Dubbo 是一个很好的选择。</li></ul> 
<p>Open Feign:</p> 
<ul><li>作用: Open Feign 是一个声明式的WebService客户端。它使得编写Web Service客户端更加简单。与Ribbon（负载均衡器）和Eureka（服务发现器）集成，可以轻松地实现负载均衡的RESTful服务调用。</li><li>使用场景: 主要用于Spring Cloud应用程序中，当你需要一个简单、声明式的方式来调用REST服务时，Open Feign 是一个不错的选择。</li></ul> 
<h3><a id="22_dubbo_103"></a>2.2 dubbo支持的部分容错策略</h3> 
<p>Dubbo提供了多种集群容错策略来确保服务的高可用性。故障转移是其中一种策略。以下是Dubbo支持的部分容错策略：</p> 
<ul><li>Failover（故障转移）: 这是默认的容错策略。当调用失败时，会自动尝试其他可用的服务提供者。通常，可以设置重试的次数。</li><li>Failfast（快速失败）: 这是一种“快速失败”策略，只尝试调用一次，如果失败，立即抛出异常。</li><li>Failsafe（失败安全）: 这种策略用于写操作，如果调用失败，只是打印一个警告信息，并不会抛出异常。</li><li>Failback（失败后回退）: 当请求失败时，将请求记录到队列中，后台定时重发。</li><li>Forking（分叉）: 同时调用多个服务提供者，只要有一个返回结果，那么就返回该结果。</li><li>Broadcast（广播）: 逐个调用所有提供者，通常用于更新所有提供者的缓存或日志等本地状态。</li></ul> 
<h4><a id="221_DubboFailfastFailsafe_113"></a>2.2.1 为什么Dubbo要支持Failfast（快速失败）策略和Failsafe（失败安全）策略:</h4> 
<ol><li> <p>Failfast（快速失败）: 这种策略对于那些不希望浪费资源在不必要的重试上的场景是很有用的。当明确知道再次尝试也可能会失败或者当错误明确是由不可恢复的问题引起的（例如参数验证失败）时，快速失败可以迅速反馈给调用者，让调用者进行下一步操作或者处理。</p> </li><li> <p>Failsafe（失败安全）: 这种策略对于一些非关键性的操作特别有用，例如日志记录、监控上报等。如果这些操作失败，虽然不理想，但系统仍可以继续运行。因此，Failsafe策略可以确保这些非关键性操作的失败不会对主业务流程产生影响。<br> Dubbo 是一个分布式服务框架，其主要目的是提供高效、可靠和透明的远程服务调用。在分布式系统中，由于网络、服务实例的不可靠性等因素，故障几乎是不可避免的。因此，拥有一套可靠的故障处理策略是至关重要的。Dubbo 提供了多种故障处理策略以满足不同场景和需求。以下是为什么 Dubbo 支持上述三种故障处理策略的原因：</p> </li><li> <p><strong>Failback（失败后回退）</strong>:</p> 
  <ul><li><strong>适用场景</strong>: 有些业务请求不需要立即得到结果，但它们的成功执行是必要的，即使在稍后的时间。</li><li><strong>原因</strong>: 对于非实时性要求的请求，如日志记录、统计上报等，如果请求失败，系统可以先暂存起来，待系统资源或网络环境稳定后，再进行重试。这样可以提高系统的健壮性和容错能力。</li></ul> </li><li> <p><strong>Forking（分叉）</strong>:</p> 
  <ul><li><strong>适用场景</strong>: 当用户对响应时间有严格要求，但可以容忍后台服务的部分失败。</li><li><strong>原因</strong>: 在某些场景中，调用方希望尽快得到响应，因此可以同时向多个服务提供者发送请求。一旦有一个提供者返回结果，请求就可以结束。这种方式可以增加获取响应的速度，但会增加系统的总体负载。</li></ul> </li><li> <p><strong>Broadcast（广播）</strong>:</p> 
  <ul><li><strong>适用场景</strong>: 当需要对所有服务提供者执行某些操作，如数据的清理、缓存的更新等。</li><li><strong>原因</strong>: 在分布式环境中，有些操作需要确保所有的服务提供者都得到相同的命令或数据。例如，当一个数据项发生变化时，可能需要通知所有相关的服务提供者更新其缓存（这里的客户端不一定得是服务调用者）。广播策略可以确保所有的提供者都执行特定的操作。</li></ul> </li></ol> 
<p>总之，Dubbo 通过提供多种故障处理策略，使得开发者可以根据不同的业务场景和需求，选择最适合的策略，从而提高分布式系统的可靠性、效率和灵活性。</p> 
<h3><a id="23__134"></a>2.3 什么是分布式链路追踪技术</h3> 
<p>推荐文章：<a href="https://www.zhihu.com/question/529732816/answer/2552525236" rel="nofollow">分布式链路追踪技术怎么落地？</a></p> 
<h4><a id="231_Spring_CloudSleuthZipkinSleuth_136"></a>2.3.1 Spring Cloud使用Sleuth和Zipkin来实现链路追踪。Sleuth负责在微服务之间的请求中添加跟踪信息，一般这些信息包含什么字段:</h4> 
<p>当Sleuth为请求添加跟踪信息时，主要的字段包括：</p> 
<p>Trace ID: 代表整个请求链路的唯一标识。<br> Span ID: 代表一个基本的工作单元，例如发送一个HTTP请求。<br> Parent Span ID: 当前工作单元（Span）的父工作单元ID。它链接子Span和父Span。<br> Sampled Flag: 表示是否要记录这个请求的跟踪数据。<br> Name of the service: 当前服务的名称。<br> 这些字段在请求在微服务间传递时，将被嵌入到请求的Header中，从而实现跟踪的目的。</p> 
<h4><a id="232_spanIdparentIdspan_146"></a>2.3.2 这里的spanId是，parentId字段是干什么的，span的作用</h4> 
<p>在分布式链路追踪中，为了能够清晰地表示出一个完整请求在多个服务或组件之间的调用关系，我们需要用到“Trace”和“Span”的概念。以下是对这些概念和字段的解释：</p> 
<ol><li> <p><strong>Trace</strong>: 表示一次完整的、跨多个服务的请求。Trace 内部包含多个 Span，这些 Span 串联起来就描述了这次请求的完整路径。</p> </li><li> <p><strong>Span</strong>: 表示请求在一个服务或组件中的一次处理或操作。在一个 Trace 中，可以有多个 Span。每个 Span 都代表了请求在某个服务或组件中的处理过程。</p> </li><li> <p><strong>SpanId</strong>: 是 Span 的唯一标识符，用于唯一确定一个 Span。</p> </li><li> <p><strong>ParentSpanId</strong>: 指向这个 Span 的上一级 Span 的 SpanId。通过 ParentSpanId，我们可以知道这个 Span 是由哪个 Span 调用的，从而建立起 Span 之间的调用关系。</p> </li></ol> 
<p><strong>Span 的作用</strong>:</p> 
<ul><li> <p><strong>描述请求路径</strong>: Span 可以告诉我们请求在某个服务或组件中做了什么，花了多长时间，以及这之前请求又经过了哪些服务或组件。</p> </li><li> <p><strong>性能分析</strong>: 通过 Span，我们可以知道每个服务或组件处理请求的时间，从而分析出系统的瓶颈所在。</p> </li><li> <p><strong>故障定位</strong>: 如果请求出错，我们可以通过分析 Span 来定位问题出在哪个服务或组件上。</p> </li><li> <p><strong>系统监控</strong>: 我们可以对 Span 中的数据进行统计，得到各个服务或组件的调用次数、平均响应时间等关键指标，用于系统的监控和报警。</p> </li></ul> 
<p>总的来说，通过 Span 和 Trace，我们可以清晰地看到一个请求在分布式系统中的完整路径，从而进行性能分析、故障定位和系统监控。</p> 
<h4><a id="232_Trace_demospan_167"></a>2.3.2 Trace demo，包括各个服务的span结构和值</h4> 
<p>让我们假设一个简单的分布式系统场景，其中客户端发起一个请求，这个请求首先到达前端服务，然后前端服务调用认证服务进行用户认证，随后调用订单服务获取订单信息，订单服务再调用库存服务确认库存。</p> 
<p>在这个场景下，一个 Trace 的示例描述如下：</p> 
<pre><code>TraceId: 12345

1. Span (Frontend Service)
    - SpanId: 1
    - ParentSpanId: None (因为它是首个 Span)
    - Name: "FrontendServiceHandler"
    - StartTime: 09:00:00
    - EndTime: 09:00:03
    - Attributes: { "method": "GET", "url": "/getOrderInfo" }

    2. Span (Authentication Service)
        - SpanId: 2
        - ParentSpanId: 1 (这是 Frontend Service 的 SpanId)
        - Name: "AuthenticationHandler"
        - StartTime: 09:00:00.5
        - EndTime: 09:00:01
        - Attributes: { "user": "john_doe" }

    3. Span (Order Service)
        - SpanId: 3
        - ParentSpanId: 1 (这也是 Frontend Service 的 SpanId)
        - Name: "OrderServiceHandler"
        - StartTime: 09:00:01.1
        - EndTime: 09:00:02.5
        - Attributes: { "orderId": "56789" }

        4. Span (Inventory Service)
            - SpanId: 4
            - ParentSpanId: 3 (这是 Order Service 的 SpanId)
            - Name: "InventoryCheck"
            - StartTime: 09:00:02
            - EndTime: 09:00:02.3
            - Attributes: { "productId": "101112" }
</code></pre> 
<p>这里，整个请求的 TraceId 是 <code>12345</code>，表明所有这些 Spans 都属于同一个请求。Span 的结构包括了其名称、起始和结束时间、相关属性等。每个 Span（除了顶级的 Span）都有一个 <code>ParentSpanId</code>，这说明了它是由哪个 Span 触发的。</p> 
<p>从上述描述中，我们可以清晰地看到请求的完整路径：首先到达前端服务，然后并行地调用了认证服务和订单服务（这里为了简化描述，我们假设它们是并行的），然后订单服务再去调用库存服务。</p> 
<p>这只是一个简化的例子，实际的 Trace 会根据系统的复杂性和请求的路径包含更多的 Spans 和属性。</p> 
<h4><a id="233__213"></a>2.3.3 当我们考虑技术的底层原理，快递物流的追踪技术和分布式链路追踪的确有一些相似之处。以下是它们的相似点：</h4> 
<ol><li> <p><strong>标识符（Identifiers）</strong>:</p> 
  <ul><li><strong>快递物流</strong>：每个快递包裹都有一个唯一的追踪号，用于标识和追踪该包裹。</li><li><strong>分布式链路追踪</strong>：每个请求都有一个唯一的Trace ID，用于在整个链路中跟踪该请求。</li></ul> </li><li> <p><strong>事件或状态的记录（Event or State Logging）</strong>:</p> 
  <ul><li><strong>快递物流</strong>：在包裹的整个生命周期中，每当包裹到达或离开一个地点（例如集散中心、邮局或终端）时，系统都会记录其状态和时间戳。</li><li><strong>分布式链路追踪</strong>：在请求的整个生命周期中，系统会记录关键事件（如请求开始、请求结束、数据库调用等）及其时间戳。</li></ul> </li><li> <p><strong>层级结构（Hierarchical Structure）</strong>:</p> 
  <ul><li><strong>快递物流</strong>：一个包裹可能会经过多个中转站，形成一个层级或路径。</li><li><strong>分布式链路追踪</strong>：一个请求可能会涉及多个服务或组件，形成一个调用链或路径。</li></ul> </li><li> <p><strong>可视化（Visualization）</strong>:</p> 
  <ul><li><strong>快递物流</strong>：用户可以通过网站或应用程序查看包裹的当前状态和历史路径。</li><li><strong>分布式链路追踪</strong>：开发者或运维人员可以通过工具（如Zipkin、Jaeger等）可视化地查看请求的整个路径和性能指标。</li></ul> </li><li> <p><strong>故障检测和诊断（Fault Detection and Diagnostics）</strong>:</p> 
  <ul><li><strong>快递物流</strong>：如果包裹在某个阶段停滞不前或丢失，追踪系统可以帮助定位问题所在。</li><li><strong>分布式链路追踪</strong>：如果请求在某个服务中出现延迟或失败，追踪数据可以帮助定位和诊断问题所在。</li></ul> </li><li> <p><strong>上下文信息（Contextual Information）</strong>:</p> 
  <ul><li><strong>快递物流</strong>：除了基本的位置和时间信息，追踪系统还可能提供其他上下文信息，如天气条件、交通状况等。</li><li><strong>分布式链路追踪</strong>：除了基本的调用信息，链路追踪数据还可能包括其他上下文信息，如请求参数、服务版本等。</li></ul> </li></ol> 
<p>总结：从技术的底层原理来看，快递物流的追踪技术和分布式链路追踪都关注于如何有效地标识、记录和可视化一个过程或事物在多个步骤或组件中的状态和路径。</p> 
<h4><a id="234__240"></a>2.3.4 这里的链路只追踪发起调用的过程，但是响应返回过程呢</h4> 
<p>你提到的是一个很好的观点。确实，链路追踪通常重点关注请求的发起和调用，但响应的返回过程也是请求生命周期的一部分，并且也被记录下来。</p> 
<p>在实际的分布式追踪系统中，一个span通常会跨越请求和响应的完整生命周期。例如：</p> 
<ol><li>一个span开始于服务A开始处理请求的时刻。</li><li>该span继续跟踪服务A调用服务B的时刻。</li><li>当服务B收到请求、处理它并返回响应时，这一过程也会被记录在服务B的span中。</li><li>最后，当服务A收到服务B的响应并完成其处理，服务A的span结束。</li></ol> 
<p>因此，一个span的开始和结束时间实际上代表了请求和响应的全周期。对于每个服务调用，span的StartTime表示服务开始处理请求的时间，EndTime则代表服务完成响应并将其发送回调用者的时间。</p> 
<p>为了进一步区分请求和响应的处理，链路追踪工具通常提供了标注（Annotations）或事件（Events）这样的特性。例如，你可以在span内部为关键事件添加标注，如"请求开始"、“请求结束”、“响应开始"和"响应结束”。这使得开发者和运维团队能够更详细地了解每个服务处理请求和响应的具体时刻，从而更好地诊断性能瓶颈或其他问题。</p> 
<h4><a id="235_Spring_Cloud_254"></a>2.3.5 Spring Cloud如何实现链路追踪，是否可以用这里的链路追踪替换快递场景中的链路追踪技术:</h4> 
<p>Spring Cloud使用Sleuth和Zipkin来实现链路追踪。Sleuth负责在微服务之间的请求中添加跟踪信息，而Zipkin则负责收集这些信息并为其提供可视化界面。这种链路追踪可以帮助开发者理解请求如何在一个复杂的微服务体系中流动，以及定位性能瓶颈和故障。</p> 
<p>当我们谈论快递场景中的“链路追踪”时，我们通常指的是物流跟踪，也就是跟踪一个包裹从发货地到目的地的整个过程。虽然从表面上看，两者都是追踪“流程”的，但实际上它们追踪的是两种完全不同的流程。一个追踪的是数据请求在系统中的流动，另一个追踪的是物体在现实世界中的移动。</p> 
<p>因此，不能直接用Spring Cloud的链路追踪来替代快递的链路追踪。虽然技术的底层原理（如跟踪、记录和可视化）在某种程度上是相似的，但它们在实际应用中的具体实现和需求是截然不同的。</p> 
<h2><a id="3_RPC30_262"></a>3 当面试涉及中国互联网大厂和RPC框架时，以下是30个可能会被问到的问题，按照出现频率从高到低排列，并附上简要回答：</h2> 
<h3><a id="31_RPC_264"></a>3.1. 什么是RPC框架？它在大型互联网公司中的作用是什么？</h3> 
<p>回答：<strong>RPC框架是一种用于不同计算机或进程间通信的技术，允许像调用本地方法一样调用远程方法</strong>。在大型互联网公司中，RPC框架用于构建分布式系统，将各个服务连接在一起，实现服务间的通信与协作。</p> 
<h3><a id="32_RPC_267"></a>3.2. 请列举一些在中国互联网公司中常见的RPC框架。</h3> 
<p>回答：在中国互联网公司中，常见的RPC框架有gRPC、Thrift、Dubbo等。</p> 
<h3><a id="33_gRPCThriftRPC_270"></a>3.3. 请简要介绍gRPC和Thrift这两种RPC框架的区别。</h3> 
<p>回答：gRPC和Thrift都是高性能的RPC框架，但gRPC使用HTTP/2和Protocol Buffers来实现通信，而Thrift则使用自己的二进制协议和IDL。</p> 
<h3><a id="34_RPC_273"></a>3.4. 在微服务架构中，RPC框架有什么关键的作用？</h3> 
<p>回答：在微服务架构中，RPC框架充当了连接不同微服务之间通信的桥梁，实现了服务之间的相互调用。</p> 
<h3><a id="35_RPC_276"></a>3.5. 请解释一下负载均衡在RPC框架中的应用场景和重要性。</h3> 
<p>回答：在RPC框架中，负载均衡用于将请求平均分配到多个服务提供者，以实现资源的合理利用和系统的高可用性。</p> 
<h3><a id="36_RPC_279"></a>3.6. <strong>如何确保RPC调用的安全性？</strong></h3> 
<p>关于jwt的内容，可以参考：<a href="https://blog.csdn.net/yxg520s/article/details/131829433?spm=1001.2014.3001.5502">jwt面试详解</a><br> 回答：为了确保RPC调用的安全性，可以使用认证和授权机制，如OAuth、JWT等，并实现数据传输的加密和解密。</p> 
<h3><a id="37_RPC_283"></a>3.7. <strong>什么是服务注册与发现？在RPC框架中为什么需要它？</strong></h3> 
<p>回答：服务注册与发现是一种机制，用于动态地发现和管理分布式系统中的服务。在RPC框架中，它可以确保客户端能够找到可用的服务实例。</p> 
<h3><a id="38_Dubbo_286"></a>3.8. Dubbo框架在阿里巴巴集团中的应用情况如何？</h3> 
<p>回答：Dubbo是阿里巴巴开源的高性能RPC框架，在阿里巴巴集团内被广泛应用于构建大规模分布式系统。</p> 
<h3><a id="39_RPC_289"></a>3.9. 在RPC框架中，同步调用和异步调用有什么区别？何时使用它们？</h3> 
<p>回答：同步调用是指客户端发起调用后会一直等待结果返回，而异步调用是指客户端发起调用后可以继续执行其他任务，并在结果返回时得到通知。选择何种调用方式取决于具体的业务需求。</p> 
<h3><a id="310_RPC_292"></a>3.10. <strong>如何处理RPC框架中的超时问题？</strong></h3> 
<p>回答：为了处理RPC框架中的超时问题，可以设置合理的超时时间，并在超时后进行重试或采取其他补救措施。</p> 
<h3><a id="311_RPC_295"></a>3.11. <strong>在RPC框架中，如果一个服务不可用，你会采取什么措施？</strong></h3> 
<p>回答：如果一个服务不可用，可以使用负载均衡机制将请求转发到其他可用的服务实例，或者根据具体情况返回错误信息。</p> 
<h3><a id="12_RPC_298"></a>12. <strong>如何确保RPC框架的高可用性和容错性？</strong></h3> 
<p>回答：为了确保RPC框架的高可用性和容错性，可以使用负载均衡、服务注册与发现、熔断器等机制，并实现合理的故障处理策略。</p> 
<h3><a id="13_RPC_301"></a>13. RPC框架如何处理大规模请求并发？</h3> 
<p>回答：RPC框架可以采用线程池、异步处理等方式来处理大规模请求并发，以提高系统的性能和吞吐量。</p> 
<h4><a id="131__304"></a>13.1 这里的线程池是服务提供端的行为，而异步是调用端的行为对吧?</h4> 
<p>不完全是。线程池和异步处理既可以在服务提供端（server side）应用，也可以在调用端（client side）应用。让我们详细看一下：</p> 
<ol><li> <p><strong>线程池（服务提供端）</strong>:</p> 
  <ul><li>当一个RPC请求到达服务端，而不是为每一个请求都新建一个线程，线程池模式会从池中选择一个现有的线程来处理这个请求。</li><li>使用线程池可以有效地复用已经创建的线程，减少线程创建和销毁的开销。</li><li>通过合理配置线程池大小，可以避免过多线程导致的上下文切换开销，进而提高系统响应速度。</li></ul> </li><li> <p><strong>线程池（调用端）</strong>:</p> 
  <ul><li>当客户端并发发出多个RPC请求时，可以使用线程池来并发处理这些请求，尤其是当客户端需要等待服务器响应时。</li></ul> </li><li> <p><strong>异步处理（服务提供端）</strong>:</p> 
  <ul><li>服务端可以采用异步编程模型来处理请求，如基于事件的模型，这样可以不阻塞线程，从而服务端可以同时处理多个请求。</li></ul> </li><li> <p><strong>异步处理（调用端）</strong>:</p> 
  <ul><li>当客户端发出RPC请求后，它不必等待响应，而是可以立即执行其他任务。当响应到达时，它可以通过回调函数或者其他机制来处理这个响应。</li><li>这样，客户端可以并发地发出多个请求而不等待每一个请求的响应，提高了调用端的效率和响应性。</li></ul> </li></ol> 
<p>所以，线程池和异步处理都可以在服务端和客户端实施，取决于具体的需求和系统设计。</p> 
<h4><a id="132_1_rpc_324"></a>13.2 1 这里的线程池既可以发送rpc又可以处理请求对吧</h4> 
<p>是的。线程池可以用于发送RPC请求（客户端的行为）或处理到达的RPC请求（服务端的行为）。在客户端，线程池可以帮助并发地发送多个RPC请求；在服务端，线程池则用于并发地处理多个到达的RPC请求。</p> 
<h4><a id="1322_dubbo_326"></a>13.2.2 dubbo中使用了线程池吗，哪个线程池</h4> 
<p>是的，Dubbo 在其架构中使用了线程池来处理服务提供者的并发请求。使用线程池可以有效地提高系统吞吐量，处理高并发请求，而避免了为每个请求创建新线程的开销。</p> 
<p>Dubbo 中关于线程池的配置有以下几种：</p> 
<ol><li><strong>fixed</strong>：固定大小的线程池，启动时即创建全部核心线程，核心线程在整个生命周期中一直存在。</li><li><strong>cached</strong>：可缓存的线程池，非核心线程的闲置超时时间为 1 分钟。</li><li><strong>lru</strong>：基于 LRU 策略的线程池，当线程池满了，会按照 LRU 策略选择要终止的线程。</li><li><strong>eager</strong>：饥饿加载的线程池，与 <code>cached</code> 模式相似，但区别在于，当所有线程都处于活动状态时，会创建新线程处理新请求。</li></ol> 
<p>在 Dubbo 的实际实现中，它使用了 Java 标准库中的 <code>ThreadPoolExecutor</code> 作为其线程池实现，并通过上述策略进行配置。</p> 
<p>除了选择线程池类型，Dubbo 还允许你配置其他相关参数，如核心线程数、最大线程数、队列大小等，以便根据实际使用场景对线程池进行优化。</p> 
<p>注意：正确的线程池配置对于系统的性能和稳定性至关重要。过大或过小的线程池都可能导致系统资源的浪费或响应延迟。</p> 
<h3><a id="14_RPCProxy_341"></a>14. 请解释一下RPC框架中的服务代理（Proxy）是什么？</h3> 
<p>回答：<strong>服务代理在RPC框架中充当客户端与服务器之间的中间人，隐藏了底层的通信细节，使得客户端可以像调用本地方法一样调用远程方法。</strong></p> 
<h3><a id="15_RPC15protocol_buffer_344"></a>15. <strong>在RPC框架中，如何处理版本兼容性问题？</strong>（请看第15个知识点protocol buffer如何处理兼容问题）</h3> 
<p>回答：为了处理版本兼容性问题，可以在服务接口上定义灵活的IDL（Interface Definition Language，接口定义语言），并确保对旧版本的兼容支持。</p> 
<h3><a id="16_IDL_347"></a>16. 什么是IDL</h3> 
<p>IDL（Interface Definition Language，接口定义语言）是一种用于描述接口的语言，它是一种中立的语言，不依赖于具体的编程语言或硬件平台。<strong>IDL用于定义在分布式系统中各个组件或模块之间进行通信和交互的接口规范。</strong></p> 
<p>在RPC（远程过程调用）框架中，IDL用于描述服务的接口，包括服务提供的方法、参数类型、返回值等信息。通过IDL的定义，客户端和服务器之间可以明确地了解彼此的接口规范，从而能够实现远程过程调用。</p> 
<p>具体来说，IDL可以描述以下内容：</p> 
<ol><li> <p>服务接口：定义服务所提供的方法和方法的参数列表。</p> </li><li> <p>参数类型：定义方法的参数类型，例如整数、字符串、自定义结构体等。</p> </li><li> <p>返回值类型：定义方法的返回值类型，例如整数、字符串、自定义结构体等。</p> </li></ol> 
<p>IDL通常是中立的，不依赖于具体的编程语言或平台，因此可以让不同编程语言的开发者都能够理解服务接口的规范。对于不同的RPC框架，可以使用不同的IDL来描述服务接口，例如gRPC使用Google的Protocol Buffers作为IDL，而Apache Thrift则有自己的IDL。</p> 
<p>使用IDL的好处是，它提供了一种标准化的方式来定义服务接口，<strong>让不同团队或开发者之间能够在接口规范上达成一致</strong>。这样，在分布式系统中的不同模块之间进行通信时，可以避免由于接口规范不一致而导致的通信问题。<strong>同时，IDL还可以自动生成代码，使得开发者能够更方便地使用RPC框架进行开发</strong>。</p> 
<h3><a id="151_protocol_buffer_protoIDL_363"></a>15.1 protocol buffer 的.proto文件应该就是一种IDL对吧</h3> 
<p>对的，你完全正确。<code>.proto</code> 文件确实是 Protocol Buffers 的 IDL（接口定义语言）描述。<strong>它用于定义服务接口以及消息类型</strong>。通过这个描述，<strong>工具可以为各种语言自动生成客户端和服务器的代码</strong>，使得这些语言可以轻松地进行RPC调用或者消息的序列化与反序列化。</p> 
<p>简单地说，<code>.proto</code> 文件允许开发者以中立的方式描述数据结构和服务接口，然后通过 Protocol Buffers 编译器（如 <code>protoc</code>）生成目标语言的源代码。</p> 
<p>这种做法具有以下几点优势：</p> 
<ol><li><strong>跨语言和跨平台</strong>：同一个 <code>.proto</code> 文件可以生成多种编程语言的代码，支持多平台交互。</li><li><strong>明确性和统一性</strong>：所有参与者都参考同一份 <code>.proto</code> 文件，确保了接口和数据结构的统一性。</li><li><strong>高效的序列化和反序列化</strong>：由 Protocol Buffers 生成的代码具有高效的序列化和反序列化能力。</li><li><strong>版本兼容性</strong>：<code>.proto</code> 文件的设计考虑了向前兼容性和向后兼容性。</li></ol> 
<p>因此，你可以把 <code>.proto</code> 文件看作是 Protocol Buffers 的 IDL，它为跨语言和跨平台的服务交互提供了标准化的定义。</p> 
<h3><a id="17_gRPCRESTful_API_376"></a>17. gRPC和RESTful API在性能方面有什么区别？</h3> 
<p>回答：通常情况下，gRPC比传统的RESTful API在性能方面更高效，因为它使用了二进制协议和HTTP/2，可以减少网络开销。</p> 
<h3><a id="18_RPC_379"></a>18. RPC框架如何处理大数据量的传输？</h3> 
<p>回答：RPC框架可以使用数据压缩技术来减少大数据量的传输，例如使用gzip或其他压缩算法。</p> 
<h3><a id="19_gRPC_382"></a>19. 请解释一下gRPC的序列化机制。</h3> 
<p>回答：gRPC使用Google的Protocol Buffers作为默认的序列化机制，它是一种高效且可扩展的二进制序列化格式。</p> 
<h3><a id="20_RPC_385"></a>20. 如何确保RPC框架的安全性，防止数据被篡改或截获？</h3> 
<p>回答：<strong>为了确保RPC框架的安全性，可以使用SSL/TLS协议来加密通信，并采用数字签名等技术来防止数据被篡改。</strong></p> 
<h3><a id="21_RPC_388"></a>21. 在RPC框架中，你如何监控和追踪请求的性能？</h3> 
<p>回答：可以使用监控工具和性能追踪系统来监控RPC框架中请求的性能，如Prometheus、Zipkin等。</p> 
<h3><a id="22_RPC_391"></a>22. RPC框架是否支持流式传输？如果支持，它在哪些场景下特别有用？</h3> 
<p>回答：是的，许多RPC框架支持流式传输。流式传输在处理大量数据流或长时间运行的任务时特别有用。</p> 
<h4><a id="221__394"></a>22.1 流式传输在处理大量数据流或长时间运行的任务时特别有用。为什么</h4> 
<p>流式传输在处理大量数据流或长时间运行的任务时特别有用，主要有以下几个原因：</p> 
<ol><li> <p>降低内存压力：流式传输可以分批次传输数据，每次只传输部分数据而不是一次性传输全部数据，从而减少了客户端和服务器的内存压力。特别是在处理大量数据流时，一次性传输可能会导致内存溢出，而流式传输可以避免这个问题。</p> </li><li> <p>提高响应速度：对于长时间运行的任务，流式传输允许客户端逐步接收处理结果，而不需要等待任务全部完成后才返回结果。这样可以实现即时性的反馈，提高用户体验。</p> </li><li> <p>并发性：流式传输支持并发处理多个数据流或任务，从而允许同时处理多个任务而不阻塞其他任务的执行。</p> </li><li> <p>节省带宽：流式传输只传输实际需要的数据，而不是一次性传输全部数据。这样可以节省带宽，特别是在处理大量数据流时，可以减少网络传输的负担。</p> </li><li> <p>适应不同处理速率：在处理大量数据流时，数据的生成和消费速率可能不同。流式传输可以根据实际情况调整数据传输的速率，以便更好地适应数据的生成和处理速度。</p> </li></ol> 
<p>总之，流式传输在处理大量数据流或长时间运行的任务时，可以提供更高的效率和性能，并且能够更好地适应不同的数据处理需求，从而在分布式系统中发挥重要作用。这使得流式传输成为处理大规模数据和长时间运行任务的有效解决方案。</p> 
<h4><a id="222_tcpudp_409"></a>22.2 tcp采用了流式传输吗，udp呢？</h4> 
<p>TCP（传输控制协议）：TCP采用了面向连接的流式传输。它通过建立连接、保持连接状态和确认机制来确保数据可靠传输。在TCP中，数据被视为连续的字节流，因此发送端将数据划分为小的数据块，并逐个发送，接收端会按顺序接收这些数据块并组装成完整的数据。在GBN中，TCP会保证数据按顺序到达，并处理重传、丢失、乱序等问题，以确保数据传输的可靠性。</p> 
<p>UDP（用户数据报协议）：UDP采用了面向无连接的数据报传输。在UDP中，数据被分成独立的数据包，每个数据包都带有目标地址和端口。UDP没有连接的概念，因此发送端将数据包发送到目标地址，而不关心接收方是否准备接收数据。UDP不提供数据可靠性保证，因此可能出现丢包、乱序等问题，但由于没有连接建立和确认过程，UDP的传输开销较小，适用于实时性要求较高的场景。</p> 
<h4><a id="223__413"></a>22.3 如何理解“流式传输只传输实际需要的数据，而不是一次性传输全部数据”，是说不必要传输整个数据块，只需要传输接收方需要的小块就可以？</h4> 
<p>正确，"流式传输只传输实际需要的数据，而不是一次性传输全部数据"意味着数据在传输过程中被切分成较小的数据块，然后逐个传输。发送方不必等待整个数据块全部就绪，而是根据接收方的接收能力和需求，逐块地发送数据。这种方式可以有效地利用网络资源，减少传输过程中的延迟和开销。</p> 
<p>例如，在视频流传输中，发送方会将视频数据切分成小的数据包，然后逐个发送给接收方。接收方不必等待所有数据都到达才能开始播放视频，而是可以边接收边播放，这样可以实现较低的延迟，提高实时性。同样，对于大文件的传输，可以使用流式传输，只传输接收方所需的部分数据，而不是等待整个文件传输完成才能开始使用。这样可以优化网络传输，提高数据传输的效率。</p> 
<h4><a id="224__417"></a>22.4 流式传输支持并发处理多个数据流或任务，从而允许同时处理多个任务而不阻塞其他任务的执行。如何并发处理</h4> 
<p>流式传输通过异步处理机制来支持并发处理多个数据流或任务，从而允许同时处理多个任务而不阻塞其他任务的执行。异步处理是一种非阻塞的方式，使得一个任务在等待某些资源时，可以继续执行其他任务，从而实现并发性。</p> 
<p>下面是流式传输并发处理的一般步骤：</p> 
<ol><li> <p><strong>异步发送：发送方在启动数据发送后不需要等待发送操作的完成，而是可以继续处理其他任务</strong>。</p> </li><li> <p>异步接收：<strong>接收方使用异步接收机制，接收到一个数据块后可以立即处理，而不必等待全部数据到达</strong>。</p> </li><li> <p>处理队列：在接收方，可以设置一个处理队列，用于存放接收到的数据块。每当接收到一个数据块，就将其放入处理队列中，然后立即处理队列中的数据块。</p> </li><li> <p>并发处理：接收方使用多线程或异步任务来并发地处理处理队列中的数据块。这样，即使一个任务在处理一个数据块时需要等待某些资源或I/O操作，其他任务也可以继续处理其他数据块，从而实现并发处理。</p> </li><li> <p>并发发送：发送方可以一次性并发的发送多个数据流</p> </li><li> <p>结果合并：对于某些需要汇总结果的任务，可以使用同步机制来等待所有数据块的处理完成，然后合并处理结果。</p> </li></ol> 
<p>通过这种方式，流式传输可以支持并发处理多个数据流或任务，提高系统的并发性和吞吐量，同时减少任务之间的相互阻塞，提高系统的性能和效率。这在处理大量数据流或长时间运行的任务时尤其有用，能够更好地满足实时性和高性能的需求。</p> 
<h4><a id="225__435"></a>22.5 异步发送本质上与将数据分割为小块是否有关？</h4> 
<p>异步发送本质上与是否将数据分割为小块无关。异步发送的核心是发送方在启动数据发送后不需要等待发送操作的完成（例如，不需要等待数据被完全发送出去或等待接收方的确认），而是可以立刻返回并继续进行其他任务。这种方式提供了非阻塞的数据传输，允许系统在发送数据的同时执行其他任务。</p> 
<p>将数据分割为小块并异步发送它们可能是为了提高效率和响应时间，但不是异步发送的必要条件。无论是大块还是小块，关键是发送方在发送数据后不被阻塞。</p> 
<p>因此，正确的描述应该是：</p> 
<p><strong>异步发送</strong>：发送方在启动数据发送后不需要等待发送操作的完成，而是可以继续处理其他任务。</p> 
<p>所以如果不把一个大块的数据切割，只要保证发送端发送完数据后不需要等待操作完成就可以立即处理其他的事件，它也是异步的。</p> 
<h4><a id="225_CompletableFutureCompletableFuture_445"></a>22.5 这里的异步接收和CompletableFuture的异步接收是一个概念吗？CompletableFuture的异步是指多个子线程执行，其中某一个先有返回值就执行一个后续操作？还是指要等待所有子线程全部返回呢？</h4> 
<p>异步接收在流式传输中的含义与<code>CompletableFuture</code>的异步接收概念是相关但不完全相同的。</p> 
<ol><li> <p><strong>流式传输中的异步接收</strong>：在网络编程和流式传输的上下文中，异步接收意味着当数据到达时，你不必等待所有数据都到达才开始处理。例如，如果你正在接收一个由多个数据包组成的大文件，你可以在第一个数据包到达时就开始处理它，而不是等待整个文件都下载完毕。这是非阻塞I/O的一个示例，它允许程序在等待其他数据时继续执行其他操作。</p> </li><li> <p><strong>CompletableFuture中的异步</strong>：<code>CompletableFuture</code>是Java 8引入的一个工具，用于表示异步计算的结果。它允许你编写非阻塞的代码，这意味着你可以启动一个异步操作，并在此操作进行时继续其他操作。<code>CompletableFuture</code>提供了多种方法来组合、组装和应用异步操作的结果。</p> 
  <ul><li><code>thenApply</code>, <code>thenAccept</code>, <code>thenRun</code>等方法允许你在一个<code>CompletableFuture</code>完成后进行某些操作。</li><li><code>thenCombine</code>和<code>thenCompose</code>方法允许你组合多个<code>CompletableFuture</code>的结果。</li><li><code>allOf</code>方法可以等待多个<code>CompletableFuture</code>都完成，而<code>anyOf</code>方法则在多个<code>CompletableFuture</code>中的任意一个完成时返回。</li></ul> </li></ol> 
<p>所以，答复你的问题：</p> 
<ul><li><code>CompletableFuture</code>的异步不仅仅是多个子线程执行某一个先有返回值就执行一个后续操作。它更为强大，允许你定义多种情况，如何组合、串联和处理异步操作的结果。</li><li>使用<code>CompletableFuture</code>，你可以选择等待所有子线程全部返回（使用<code>allOf</code>）或者只等待第一个返回（使用<code>anyOf</code>）。</li></ul> 
<p>总之，两者都是异步概念，但应用的上下文和具体的行为有所不同。</p> 
<h3><a id="23_RPC_461"></a>23. 如何处理RPC框架中的死锁问题？</h3> 
<p>在RPC框架中，死锁问题可能出现在分布式系统中，特别是当多个服务之间存在相互依赖或相互调用时。死锁是指两个或多个进程（或服务）在相互等待对方释放资源的情况下，无法继续执行的状态。</p> 
<p>下面举一个简单的例子来说明RPC框架中的死锁问题：</p> 
<p>假设有两个服务A和B，它们分别提供了两个方法：MethodA和MethodB。</p> 
<ol><li> <p>服务A的MethodA方法调用了服务B的MethodB方法，而同时服务B的MethodB方法又调用了服务A的MethodA方法。这样形成了一个循环调用的情况。</p> </li><li> <p>当客户端发起对服务A的MethodA方法的调用时，服务A首先会向服务B发起对MethodB方法的RPC调用，并等待返回结果。</p> </li><li> <p>同时，服务B在接收到来自服务A的RPC请求后，开始执行MethodB方法，并在方法体中调用了服务A的MethodA方法，然后等待返回结果。</p> </li><li> <p>此时，服务A在等待服务B的返回结果，而服务B又在等待服务A的返回结果，导致两个服务互相等待对方的返回结果，形成死锁状态。</p> </li></ol> 
<p>死锁的原因是两个服务之间形成了循环调用，且彼此都在等待对方的结果。由于RPC框架通常采用了异步调用或多线程机制来处理请求，一旦发生死锁，很难通过简单的超时或重试来解决问题。</p> 
<ul><li><strong>需要谨慎设计系统架构，避免循环依赖和相互调用的情况</strong></li><li><strong>设置合理的超时</strong>：为每个服务调用设置合理的超时时间。这样，如果一个服务由于某种原因不能立即响应，它不会无限制地等待，从而降低了死锁的可能性。</li></ul> 
<h3><a id="24_RPC_481"></a>24. RPC框架是否支持消息队列集成？为什么要这样做？</h3> 
<p>回答：是的，许多RPC框架支持消息队列集成。这样做可以实现异步调用和削峰填谷，提高系统的可伸缩性和稳定性。<br> dubbo RPC中有一个失败回退策略，对于不要求立即执行但是必须最终成功的调用，dubbo会在其失败时先放入重试队列中，然后重试。</p> 
<h3><a id="25_RPC_484"></a>25. 如何评估一个RPC框架的性能？</h3> 
<p>回答：评估RPC框架的性能可以通过压力测试和性能对比实验来进行，考虑吞吐量、延迟、资源利用率等指标。</p> 
<h3><a id="26_RPC_487"></a>26. 请列举一些在RPC框架中常见的错误类型。</h3> 
<p>回答：在RPC框架中常见的错误类型包括连接超时、请求超时、服务端错误、客户端错误等。</p> 
<h3><a id="27_RPC_490"></a>27. 在RPC框架中，你如何处理请求的重试？</h3> 
<p>回答：可以设置合理的重试次数和重试间隔，并在请求失败时自动进行重试。</p> 
<h3><a id="28_Dubbo_492"></a>28. Dubbo框架中的动态代理是如何实现的？</h3> 
<p>回答：Dubbo框架中的动态代理通过Javassist字节码技术动态生成代理类来实现。</p> 
<h3><a id="30_RPC_494"></a>30. 在RPC框架中，你如何处理长时间运行的任务？</h3> 
<p>回答：可以使用异步调用或流式传输来处理长时间运行的任务，以避免阻塞并提高系统的性能。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3dca137183774ca2850cd629ca3061bb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">全网最详细的linux逻辑卷制作教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ec2a246ba39937919021c69799721717/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">运行在JVM上的编程语言，认为只有java你就狭隘了</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>