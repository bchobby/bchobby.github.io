<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>select, poll和epoll - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="select, poll和epoll" />
<meta property="og:description" content="select()系统调用提供一个机制来实现同步多元I/O：
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int select (int n,
fd_set *readfds,
fd_set *writefds,
fd_set *exceptfds,
struct timeval *timeout);
FD_CLR(int fd, fd_set *set);
FD_ISSET(int fd, fd_set *set);
FD_SET(int fd, fd_set *set);
FD_ZERO(fd_set *set);
调用select()将阻塞，直到指定的文件描述符准备好执行I/O，或者可选参数timeout指定的时间已经过去。
监 视的文件描述符分为三类set，每一种对应等待不同的事件。readfds中列出的文件描述符被监视是否有数据可供读取（如果读取操作完成则不会阻塞）。 writefds中列出的文件描述符则被监视是否写入操作完成而不阻塞。最后，exceptfds中列出的文件描述符则被监视是否发生异常，或者无法控制 的数据是否可用（这些状态仅仅应用于套接字）。这三类set可以是NULL，这种情况下select()不监视这一类事件。
select()成功 返回时，每组set都被修改以使它只包含准备好I/O的文件描述符。例如，假设有两个文件描述符，值分别是7和9，被放在readfds中。当 select()返回时，如果7仍然在set中，则这个文件描述符已经准备好被读取而不会阻塞。如果9已经不在set中，则读取它将可能会阻塞（我说可能 是因为数据可能正好在select返回后就可用，这种情况下，下一次调用select()将返回文件描述符准备好读取）。
第一个参数n，等于所有set中最大的那个文件描述符的值加1。因此，select()的调用者负责检查哪个文件描述符拥有最大值，并且把这个值加1再传递给第一个参数。
timeout参数是一个指向timeval结构体的指针，timeval定义如下：
#include &lt;sys/time.h&gt;
struct timeval {
long tv_sec; /* seconds */
long tv_usec; /* 10E-6 second */
}; 如 果这个参数不是NULL，则即使没有文件描述符准备好I/O，select()也会在经过tv_sec秒和tv_usec微秒后返回。当select() 返回时，timeout参数的状态在不同的系统中是未定义的，因此每次调用select()之前必须重新初始化timeout和文件描述符set。实际 上，当前版本的Linux会自动修改timeout参数，设置它的值为剩余时间。因此，如果timeout被设置为5秒，然后在文件描述符准备好之前经过 了3秒，则这一次调用select()返回时tv_sec将变为2。
如果timeout中的两个值都设置为0，则调用select()将立即返回，报告调用时所有未决的事件，但不等待任何随后的事件。
文件描述符set不会直接操作，一般使用几个助手宏来管理。这允许Unix系统以自己喜欢的方式来实现文件描述符set。但大多数系统都简单地实现set为位数组。FD_ZERO移除指定set中的所有文件描述符。每一次调用select()之前都应该先调用它。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/ca6b42f5a1755d1c0b9068cc0108bf8f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-12-29T23:49:39+08:00" />
<meta property="article:modified_time" content="2014-12-29T23:49:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">select, poll和epoll</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="color:rgb(69,69,69); font-family:Verdana,Helvetica,Arial; line-height:18px; text-align:justify; background-color:rgb(247,247,247)"> 
 <p>select()系统调用提供一个机制来实现同步多元I/O：<br> </p> 
 <table align="center" border="0" cellspacing="0" width="95%"><tbody><tr><td style="color:rgb(69,69,69); font-family:Verdana,Helvetica,Arial; word-break:break-all; line-height:18px"> <p><span style="font-family:FixedSys"><span style="color:rgb(0,0,0)"><span style="color:rgb(0,0,204)"><br> #</span><span style="color:rgb(255,0,0)">include</span> <span style="color:rgb(0,0,204)">&lt;</span>sys<span style="color:rgb(0,0,204)">/</span><span style="color:rgb(255,0,0)">time</span><span style="color:rgb(0,0,204)">.</span>h<span style="color:rgb(0,0,204)">&gt;</span><br> <span style="color:rgb(0,0,204)">#</span><span style="color:rgb(255,0,0)">include</span> <span style="color:rgb(0,0,204)">&lt;</span>sys<span style="color:rgb(0,0,204)">/</span>types<span style="color:rgb(0,0,204)">.</span>h<span style="color:rgb(0,0,204)">&gt;</span><br> <span style="color:rgb(0,0,204)">#</span><span style="color:rgb(255,0,0)">include</span> <span style="color:rgb(0,0,204)">&lt;</span>unistd<span style="color:rgb(0,0,204)">.</span>h<span style="color:rgb(0,0,204)">&gt;</span><br> <br> <span style="color:rgb(0,0,255)">int</span> <span style="color:rgb(255,0,0)">select</span> <span style="color:rgb(0,0,204)">(</span><span style="color:rgb(0,0,255)">int</span> n<span style="color:rgb(0,0,204)">,</span><br> fd_set <span style="color:rgb(0,0,204)">*</span>readfds<span style="color:rgb(0,0,204)">,</span><br> fd_set <span style="color:rgb(0,0,204)">*</span>writefds<span style="color:rgb(0,0,204)">,</span><br> fd_set <span style="color:rgb(0,0,204)">*</span>exceptfds<span style="color:rgb(0,0,204)">,</span><br> <span style="color:rgb(0,0,255)">struct</span> <span style="color:rgb(255,0,0)">timeval</span> <span style="color:rgb(0,0,204)">*</span>timeout<span style="color:rgb(0,0,204)">)</span><span style="color:rgb(0,0,204)">;</span><br> <br> FD_CLR<span style="color:rgb(0,0,204)">(</span><span style="color:rgb(0,0,255)">int</span> fd<span style="color:rgb(0,0,204)">,</span> fd_set <span style="color:rgb(0,0,204)">*</span><span style="color:rgb(255,0,0)">set</span><span style="color:rgb(0,0,204)">)</span><span style="color:rgb(0,0,204)">;</span><br> FD_ISSET<span style="color:rgb(0,0,204)">(</span><span style="color:rgb(0,0,255)">int</span> fd<span style="color:rgb(0,0,204)">,</span> fd_set <span style="color:rgb(0,0,204)">*</span><span style="color:rgb(255,0,0)">set</span><span style="color:rgb(0,0,204)">)</span><span style="color:rgb(0,0,204)">;</span><br> FD_SET<span style="color:rgb(0,0,204)">(</span><span style="color:rgb(0,0,255)">int</span> fd<span style="color:rgb(0,0,204)">,</span> fd_set <span style="color:rgb(0,0,204)">*</span><span style="color:rgb(255,0,0)">set</span><span style="color:rgb(0,0,204)">)</span><span style="color:rgb(0,0,204)">;</span><br> FD_ZERO<span style="color:rgb(0,0,204)">(</span>fd_set <span style="color:rgb(0,0,204)">*</span><span style="color:rgb(255,0,0)">set</span><span style="color:rgb(0,0,204)">)</span><span style="color:rgb(0,0,204)">;</span></span></span></p> </td></tr></tbody></table> 
 <p><br> 调用select()将阻塞，直到指定的文件描述符准备好执行I/O，或者可选参数timeout指定的时间已经过去。<br> 监 视的文件描述符分为三类set，每一种对应等待不同的事件。readfds中列出的文件描述符被监视是否有数据可供读取（如果读取操作完成则不会阻塞）。 writefds中列出的文件描述符则被监视是否写入操作完成而不阻塞。最后，exceptfds中列出的文件描述符则被监视是否发生异常，或者无法控制 的数据是否可用（这些状态仅仅应用于套接字）。这三类set可以是NULL，这种情况下select()不监视这一类事件。<br> select()成功 返回时，每组set都被修改以使它只包含准备好I/O的文件描述符。例如，假设有两个文件描述符，值分别是7和9，被放在readfds中。当 select()返回时，如果7仍然在set中，则这个文件描述符已经准备好被读取而不会阻塞。如果9已经不在set中，则读取它将可能会阻塞（我说可能 是因为数据可能正好在select返回后就可用，这种情况下，下一次调用select()将返回文件描述符准备好读取）。<br> 第一个参数n，等于所有set中最大的那个文件描述符的值加1。因此，select()的调用者负责检查哪个文件描述符拥有最大值，并且把这个值加1再传递给第一个参数。<br> timeout参数是一个指向timeval结构体的指针，timeval定义如下：<br> </p> 
 <table align="center" border="0" cellspacing="0" width="95%"><tbody><tr><td style="color:rgb(69,69,69); font-family:Verdana,Helvetica,Arial; word-break:break-all; line-height:18px"> <span style="font-family:FixedSys"><span style="color:rgb(0,0,0)"><span style="color:rgb(0,0,204)">#</span><span style="color:rgb(255,0,0)">include</span> <span style="color:rgb(0,0,204)">&lt;</span>sys<span style="color:rgb(0,0,204)">/</span><span style="color:rgb(255,0,0)">time</span><span style="color:rgb(0,0,204)">.</span>h<span style="color:rgb(0,0,204)">&gt;</span><br> <span style="color:rgb(0,0,255)">struct</span> <span style="color:rgb(255,0,0)">timeval</span> <span style="color:rgb(0,0,204)">{<!-- --></span><br> <span style="color:rgb(0,0,255)">long</span> tv_sec<span style="color:rgb(0,0,204)">;</span> <span style="color:rgb(255,153,0)">/* seconds */</span><br> <span style="color:rgb(0,0,255)">long</span> tv_usec<span style="color:rgb(0,0,204)">;</span> <span style="color:rgb(255,153,0)">/* <span style="font-size:10px; color:rgb(0,0,0); font-family:Arial">10E-6 second</span> */</span><br> <span style="color:rgb(0,0,204)">}</span><span style="color:rgb(0,0,204)">;</span></span></span></td></tr></tbody></table> 
 <p><br> 如 果这个参数不是NULL，则即使没有文件描述符准备好I/O，select()也会在经过tv_sec秒和tv_usec微秒后返回。当select() 返回时，timeout参数的状态在不同的系统中是未定义的，因此每次调用select()之前必须重新初始化timeout和文件描述符set。实际 上，当前版本的Linux会自动修改timeout参数，设置它的值为剩余时间。因此，如果timeout被设置为5秒，然后在文件描述符准备好之前经过 了3秒，则这一次调用select()返回时tv_sec将变为2。<br> 如果timeout中的两个值都设置为0，则调用select()将立即返回，报告调用时所有未决的事件，但不等待任何随后的事件。<br> 文件描述符set不会直接操作，一般使用几个助手宏来管理。这允许Unix系统以自己喜欢的方式来实现文件描述符set。但大多数系统都简单地实现set为位数组。FD_ZERO移除指定set中的所有文件描述符。每一次调用select()之前都应该先调用它。<br> fd_set writefds;<br> FD_ZERO(&amp;writefds);<br> <br> FD_SET添加一个文件描述符到指定的set中，FD_CLR则从指定的set中移除一个文件描述符：<br> FD_SET(fd, &amp;writefds); /* add 'fd' to the set */<br> FD_CLR(fd, &amp;writefds); /* oops, remove 'fd' from the set */<br> <br> 设计良好的代码应该永远不使用FD_CLR，而且实际情况中它也确实很少被使用。<br> FD_ISSET测试一个文件描述符是否指定set的一部分。如果文件描述符在set中则返回一个非0整数，不在则返回0。FD_ISSET在调用select()返回之后使用，测试指定的文件描述符是否准备好相关动作：<br> if (FD_ISSET(fd, &amp;readfds))<br> /* 'fd' is readable without blocking! */<br> <br> <span style="color:rgb(255,0,0)">因为文件描述符set是静态创建的，它们对文件描述符的最大数目强加了一个限制，能够放进set中的最大文件描述符的值由FD_SETSIZE指定。在Linux中，这个值是1024。本章后面我们还将看到这个限制的衍生物。</span><br> 返回值和错误代码<br> select()成功时返回准备好I/O的文件描述符数目，包括所有三个set。如果提供了timeout，返回值可能是0；错误时返回-1，并且设置errno为下面几个值之一：<br> EBADF<br> 给某个set提供了无效文件描述符。<br> EINTR<br> 等待时捕获到信号，可以重新发起调用。<br> EINVAL<br> 参数n为负数，或者指定的timeout非法。<br> ENOMEM<br> 不够可用内存来完成请求。<br> --------------------------------------------------------------------------------------------------------------</p> 
 <p>poll()系统调用是System V的多元I/O解决方案。<span style="color:rgb(255,0,0)">它解决了select()的几个不足，尽管select()仍然经常使用</span>（多数还是出于习惯，或者打着可移植的名义）：<br> <br> </p> 
 <table align="center" border="0" cellspacing="0" width="95%"><tbody><tr><td style="color:rgb(69,69,69); font-family:Verdana,Helvetica,Arial; word-break:break-all; line-height:18px"> <span style="font-family:FixedSys"><span style="color:rgb(0,0,0)"><span style="color:rgb(0,0,204)">#</span><span style="color:rgb(255,0,0)">include</span> <span style="color:rgb(0,0,204)">&lt;</span>sys<span style="color:rgb(0,0,204)">/</span>poll<span style="color:rgb(0,0,204)">.</span>h<span style="color:rgb(0,0,204)">&gt;</span><br> <span style="color:rgb(0,0,255)">int</span> poll <span style="color:rgb(0,0,204)">(</span><span style="color:rgb(0,0,255)">struct</span> pollfd <span style="color:rgb(0,0,204)">*</span>fds<span style="color:rgb(0,0,204)">,</span> <span style="color:rgb(0,0,255)">unsigned</span> <span style="color:rgb(0,0,255)">int</span> nfds<span style="color:rgb(0,0,204)">,</span> <span style="color:rgb(0,0,255)">int</span> timeout<span style="color:rgb(0,0,204)">)</span><span style="color:rgb(0,0,204)">;</span></span></span></td></tr></tbody></table> 
 <p><br> <span style="color:rgb(255,0,0)">和select()不一样，poll()没有使用低效的三个基于位的文件描述符set，而是采用了一个单独的结构体pollfd数组，由fds指针指向这个组</span>。pollfd结构体定义如下：<br> <br> </p> 
 <table align="center" border="0" cellspacing="0" width="95%"><tbody><tr><td style="color:rgb(69,69,69); font-family:Verdana,Helvetica,Arial; word-break:break-all; line-height:18px"> <span style="font-family:FixedSys"><span style="color:rgb(0,0,0)"><span style="color:rgb(0,0,204)">#</span><span style="color:rgb(255,0,0)">include</span> <span style="color:rgb(0,0,204)">&lt;</span>sys<span style="color:rgb(0,0,204)">/</span>poll<span style="color:rgb(0,0,204)">.</span>h<span style="color:rgb(0,0,204)">&gt;</span><br> <br> <span style="color:rgb(0,0,255)">struct</span> pollfd <span style="color:rgb(0,0,204)">{<!-- --></span><br> <span style="color:rgb(0,0,255)">int</span> fd<span style="color:rgb(0,0,204)">;</span> <span style="color:rgb(255,153,0)">/* file descriptor */</span><br> <span style="color:rgb(0,0,255)">short</span> events<span style="color:rgb(0,0,204)">;</span> <span style="color:rgb(255,153,0)">/* requested events to watch */</span><br> <span style="color:rgb(0,0,255)">short</span> revents<span style="color:rgb(0,0,204)">;</span> <span style="color:rgb(255,153,0)">/* returned events witnessed */</span><br> <span style="color:rgb(0,0,204)">}</span><span style="color:rgb(0,0,204)">;</span></span></span></td></tr></tbody></table> 
 <p><br> 每 一个pollfd结构体指定了一个被监视的文件描述符，可以传递多个结构体，指示poll()监视多个文件描述符。每个结构体的events域是监视该文 件描述符的事件掩码，由用户来设置这个域。revents域是文件描述符的操作结果事件掩码。内核在调用返回时设置这个域。events域中请求的任何事 件都可能在revents域中返回。合法的事件如下：<br> POLLIN<br> 有数据可读。<br> POLLRDNORM<br> 有普通数据可读。<br> POLLRDBAND<br> 有优先数据可读。<br> POLLPRI<br> 有紧迫数据可读。<br> POLLOUT<br> 写数据不会导致阻塞。<br> POLLWRNORM<br> 写普通数据不会导致阻塞。<br> POLLWRBAND<br> 写优先数据不会导致阻塞。<br> POLLMSG<br> SIGPOLL消息可用。<br> <br> 此外，revents域中还可能返回下列事件：<br> POLLER<br> 指定的文件描述符发生错误。<br> POLLHUP<br> 指定的文件描述符挂起事件。<br> POLLNVAL<br> 指定的文件描述符非法。<br> <br> 这些事件在events域中无意义，因为它们在合适的时候总是会从revents中返回。使用poll()和select()不一样，你不需要显式地请求异常情况报告。<br> POLLIN | POLLPRI等价于select()的读事件，POLLOUT | POLLWRBAND等价于select()的写事件。POLLIN等价于POLLRDNORM | POLLRDBAND，而POLLOUT则等价于POLLWRNORM。<br> 例 如，要同时监视一个文件描述符是否可读和可写，我们可以设置events为POLLIN | POLLOUT。在poll返回时，我们可以检查revents中的标志，对应于文件描述符请求的events结构体。如果POLLIN事件被设置，则文 件描述符可以被读取而不阻塞。如果POLLOUT被设置，则文件描述符可以写入而不导致阻塞。这些标志并不是互斥的：它们可能被同时设置，表示这个文件描 述符的读取和写入操作都会正常返回而不阻塞。<br> timeout参数指定等待的毫秒数，无论I/O是否准备好，poll都会返回。timeout指定 为负数值表示无限超时；timeout为0指示poll调用立即返回并列出准备好I/O的文件描述符，但并不等待其它的事件。这种情况下，poll()就 像它的名字那样，一旦选举出来，立即返回。<br> 返回值和错误代码<br> 成功时，poll()返回结构体中revents域不为0的文件描述符个数；如果在超时前没有任何事件发生，poll()返回0；失败时，poll()返回-1，并设置errno为下列值之一：<br> EBADF<br> 一个或多个结构体中指定的文件描述符无效。<br> EFAULT<br> fds指针指向的地址超出进程的地址空间。<br> EINTR<br> 请求的事件之前产生一个信号，调用可以重新发起。<br> EINVAL<br> nfds参数超出PLIMIT_NOFILE值。<br> ENOMEM<br> 可用内存不足，无法完成请求。<br> --------------------------------------------------------------------------------------------------------------<br> 以上内容来自《OReilly.Linux.System.Programming - Talking.Directly.to.the.Kernel.and.C.Library.2007》<br> --------------------------------------------------------------------------------------------------------------</p> 
 <p>epoll的优点：<br> 1.支持一个进程打开大数目的socket描述符(FD)<br>     select 最不能忍受的是一个进程所打开的FD是有一定限制的，由FD_SETSIZE设置，默认值是2048。对于那些需要支持的上万连接数目的IM服务器来说显 然太少了。这时候你一是可以选择修改这个宏然后重新编译内核，不过资料也同时指出这样会带来网络效率的下降，二是可以选择多进程的解决方案(传统的 Apache方案)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完 美的方案。不过 epoll则没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</p> 
 <p>2.IO效率不随FD数目增加而线性下降<br>     传统的select/poll另一个致命弱点就是当你拥有一个很大的socket集合，不过由于网络延时，任一时间只有部分的socket是"活跃"的， 但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它只会对"活跃"的socket进行 操作---这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有"活跃"的socket才会主动的去调用 callback函数，其他idle状态socket则不会，在这点上，epoll实现了一个"伪"AIO，因为这时候推动力在os内核。在一些 benchmark中，如果所有的socket基本上都是活跃的---比如一个高速LAN环境，epoll并不比select/poll有什么效率，相 反，如果过多使用epoll_ctl,效率相比还有稍微的下降。但是一旦使用idle connections模拟WAN环境,epoll的效率就远在select/poll之上了。</p> 
 <p>3.使用mmap加速内核与用户空间的消息传递。<br>     这点实际上涉及到epoll的具体实现了。无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就 很重要，在这点上，epoll是通过内核于用户空间mmap同一块内存实现的。而如果你想我一样从2.5内核就关注epoll的话，一定不会忘记手工 mmap这一步的。</p> 
 <p>4.内核微调<br>     这一点其实不算epoll的优点了，而是整个linux平台的优点。也许你可以怀疑linux平台，但是你无法回避linux平台赋予你微调内核的能力。 比如，内核TCP/IP协议栈使用内存池管理sk_buff结构，那么可以在运行时期动态调整这个内存pool(skb_head_pool)的大小 --- 通过echo XXXX&gt;/proc/sys/net/core/hot_list_length完成。再比如listen函数的第2个参数(TCP完成3次握手 的数据包队列长度)，也可以根据你平台内存大小动态调整。更甚至在一个数据包面数目巨大但同时每个数据包本身大小却很小的特殊系统上尝试最新的NAPI网 卡驱动架构。</p> 
 <h2 style="margin:10px 0px 5px; font-size:14.7px; color:rgb(102,102,102); border:1px solid rgb(204,204,204); padding:3px; text-align:center"> <a target="_blank" id="ctl04_TitleUrl" href="http://www.cnblogs.com/OnlyXP/archive/2007/08/10/851222.html" rel="nofollow noopener noreferrer" style="color:rgb(93,93,93); text-decoration:none">epoll简介</a></h2> 在linux的网络编程中，很长的时间都在使用select来做事件触发。在linux新的内核中，有了一种替换它的机制，就是epoll。 
 <br> 相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。并且，在linux/posix_types.h头文件有这样的声明： 
 <br> 
 <span style="color:rgb(255,1,2)">#define __FD_SETSIZE    1024</span> 
 <br> 表示select最多同时监听1024个fd，当然，可以通过修改头文件再重编译内核来扩大这个数目，但这似乎并不治本。 
 <br> 
 <br> epoll的接口非常简单，一共就三个函数： 
 <br> 
 <span style="color:rgb(255,1,2)">1. int epoll_create(int size);</span> 
 <br> 创 建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。 需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在 使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。 
 <br> 
 <br> 
 <br> 
 <span style="color:rgb(255,1,2)">2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span> 
 <br> epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示： 
 <br> EPOLL_CTL_ADD：注册新的fd到epfd中； 
 <br> EPOLL_CTL_MOD：修改已经注册的fd的监听事件； 
 <br> EPOLL_CTL_DEL：从epfd中删除一个fd； 
 <br> 第三个参数是需要监听的fd，第四个参数是告诉内核需要监听什么事，struct epoll_event结构如下： 
 <br> struct epoll_event { 
 <br>   __uint32_t events;  /* Epoll events */ 
 <br>   epoll_data_t data;  /* User data variable */ 
 <br> }; 
 <br> 
 <br> events可以是以下几个宏的集合： 
 <br> EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）； 
 <br> EPOLLOUT：表示对应的文件描述符可以写； 
 <br> EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）； 
 <br> EPOLLERR：表示对应的文件描述符发生错误； 
 <br> EPOLLHUP：表示对应的文件描述符被挂断； 
 <br> EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。 
 <br> EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里 
 <br> 
 <br> 
 <br> 
 <span style="color:rgb(255,1,2)">3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span> 
 <br> 等 待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有 说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。 
 <br> 
 <br> 
 <a target="_blank" href="http://blogold.chinaunix.net/u3/98692/showart_2161102.html" rel="nofollow noopener noreferrer" style="color:rgb(93,93,93); text-decoration:none">http://blogold.chinaunix.net/u3/98692/showart_2161102.html</a> 
</div> 
<br style="color:rgb(69,69,69); font-family:Verdana,Helvetica,Arial; line-height:18px; text-align:justify; background-color:rgb(247,247,247)"> 
<div style="color:rgb(69,69,69); font-family:Verdana,Helvetica,Arial; line-height:18px; text-align:justify; background-color:rgb(247,247,247)">
  最近有朋友在面试的时候被问了select 和epoll效率差的原因，和一般人一样，大部分都会回答select是轮询、epoll是触发式的，所以效率高。这个答案听上去很完美，大致也说出了二者的主要区别。  
 <br> 今天闲来无事，翻看了下内核代码，结合内核代码和大家分享下我的观点。  
 <br> 
 <br> 一、连接数  
 <br> 我本人也曾经在项目中用过select和epoll,对于select，感触最深的是linux下select最大数目限制(windows 下似乎没有限制)，每个进程的select最多能处理FD_SETSIZE个FD(文件句柄)，  
 <br> 如果要处理超过1024个句柄，只能采用多进程了。  
 <br> 常见的使用slect的多进程模型是这样的： 一个进程专门accept，成功后将fd通过unix socket传递给子进程处理，父进程可以根据子进程负载分派。曾经用过1个父进程+4个子进程 承载了超过4000个的负载。  
 <br> 这种模型在我们当时的业务运行的非常好。epoll在连接数方面没有限制，当然可能需要用户调用API重现设置进程的资源限制。  
 <br> 
 <br> 二、IO差别  
 <br> 1、select的实现  
 <br> 
 <br> 这段可以结合linux内核代码描述了，我使用的是2.6.28，其他2.6的代码应该差不多吧。  
 <br> 先看看select:  
 <br> select系统调用的代码在fs/Select.c下，  
 <br> 
 <div id=""> 
  <div>
    C代码   
   <a target="_blank" title="收藏这段代码"><img src="https://images2.imgbox.com/07/42/XC3vmf4n_o.png" alt="收藏代码"></a> 
  </div> 
  <ol start="1"><li>asmlinkage long sys_select(int n, fd_set __user *inp, fd_set __user *outp,  </li><li>            fd_set __user *exp, struct timeval __user *tvp)  </li><li>{  </li><li>    struct timespec end_time, *to = NULL;  </li><li>    struct timeval tv;  </li><li>    int ret;  </li><li>  </li><li>    if (tvp) {  </li><li>        if (copy_from_user(&amp;tv, tvp, sizeof(tv)))  </li><li>            return -EFAULT;  </li><li>  </li><li>        to = &amp;end_time;  </li><li>        if (poll_select_set_timeout(to,  </li><li>                tv.tv_sec + (tv.tv_usec / USEC_PER_SEC),  </li><li>                (tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))  </li><li>            return -EINVAL;  </li><li>    }  </li><li>  </li><li>    ret = core_sys_select(n, inp, outp, exp, to);  </li><li>    ret = poll_select_copy_remaining(&amp;end_time, tvp, 1, ret);  </li><li>  </li><li>    return ret;  </li><li>}   </li></ol> 
 </div> 
 <br> 前面是从用户控件拷贝各个fd_set到内核空间，接下来的具体工作在core_sys_select中，  
 <br> core_sys_select-&gt;do_select,真正的核心内容在do_select里：  
 <br> 
 <div id=""> 
  <div>
    C代码   
   <a target="_blank" title="收藏这段代码"><img src="https://images2.imgbox.com/d3/e2/a7phi1QP_o.png" alt="收藏代码"></a> 
  </div> 
  <ol start="1"><li>int do_select(int n, fd_set_bits *fds, struct timespec *end_time)  </li><li>{  </li><li>    ktime_t expire, *to = NULL;  </li><li>    struct poll_wqueues table;  </li><li>    poll_table *wait;  </li><li>    int retval, i, timed_out = 0;  </li><li>    unsigned long slack = 0;  </li><li>  </li><li>    rcu_read_lock();  </li><li>    retval = max_select_fd(n, fds);  </li><li>    rcu_read_unlock();  </li><li>  </li><li>    if (retval &lt; 0)  </li><li>        return retval;  </li><li>    n = retval;  </li><li>  </li><li>    poll_initwait(&amp;table);  </li><li>    wait = &amp;table.pt;  </li><li>    if (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) {  </li><li>        wait = NULL;  </li><li>        timed_out = 1;  </li><li>    }  </li><li>  </li><li>    if (end_time &amp;&amp; !timed_out)  </li><li>        slack = estimate_accuracy(end_time);  </li><li>  </li><li>    retval = 0;  </li><li>    for (;;) {  </li><li>        unsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;  </li><li>  </li><li>        set_current_state(TASK_INTERRUPTIBLE);  </li><li>  </li><li>        inp = fds-&gt;in; outp = fds-&gt;out; exp = fds-&gt;ex;  </li><li>        rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;  </li><li>  </li><li>        for (i = 0; i &lt; n; ++rinp, ++routp, ++rexp) {  </li><li>            unsigned long in, out, ex, all_bits, bit = 1, mask, j;  </li><li>            unsigned long res_in = 0, res_out = 0, res_ex = 0;  </li><li>            const struct file_operations *f_op = NULL;  </li><li>            struct file *file = NULL;  </li><li>  </li><li>            in = *inp++; out = *outp++; ex = *exp++;  </li><li>            all_bits = in | out | ex;  </li><li>            if (all_bits == 0) {  </li><li>                i += __NFDBITS;  </li><li>                continue;  </li><li>            }  </li><li>  </li><li>            for (j = 0; j &lt; __NFDBITS; ++j, ++i, bit &lt;&lt;= 1) {  </li><li>                int fput_needed;  </li><li>                if (i &gt;= n)  </li><li>                    break;  </li><li>                if (!(bit &amp; all_bits))  </li><li>                    continue;  </li><li>                file = fget_light(i, &amp;fput_needed);  </li><li>                if (file) {  </li><li>                    f_op = file-&gt;f_op;  </li><li>                    mask = DEFAULT_POLLMASK;  </li><li>                    if (f_op &amp;&amp; f_op-&gt;poll)  </li><li>                        mask = (*f_op-&gt;poll)(file, retval ? NULL : wait);  </li><li>                    fput_light(file, fput_needed);  </li><li>                    if ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) {  </li><li>                        res_in |= bit;  </li><li>                        retval++;  </li><li>                    }  </li><li>                    if ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) {  </li><li>                        res_out |= bit;  </li><li>                        retval++;  </li><li>                    }  </li><li>                    if ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) {  </li><li>                        res_ex |= bit;  </li><li>                        retval++;  </li><li>                    }  </li><li>                }  </li><li>            }  </li><li>            if (res_in)  </li><li>                *rinp = res_in;  </li><li>            if (res_out)  </li><li>                *routp = res_out;  </li><li>            if (res_ex)  </li><li>                *rexp = res_ex;  </li><li>            cond_resched();  </li><li>        }  </li><li>        wait = NULL;  </li><li>        if (retval || timed_out || signal_pending(current))  </li><li>            break;  </li><li>        if (table.error) {  </li><li>            retval = table.error;  </li><li>            break;  </li><li>        }  </li><li>  </li><li>        /* </li><li>         * If this is the first loop and we have a timeout </li><li>         * given, then we convert to ktime_t and set the to </li><li>         * pointer to the expiry value. </li><li>         */  </li><li>        if (end_time &amp;&amp; !to) {  </li><li>            expire = timespec_to_ktime(*end_time);  </li><li>            to = &amp;expire;  </li><li>        }  </li><li>  </li><li>        if (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS))  </li><li>            timed_out = 1;  </li><li>    }  </li><li>    __set_current_state(TASK_RUNNING);  </li><li>  </li><li>    poll_freewait(&amp;table);  </li><li>  </li><li>    return retval;  </li><li>}   </li></ol> 
 </div> 
 <br> 上面的代码很多，其实真正关键的代码是这一句:  
 <br> mask = (*f_op-&gt;poll)(file, retval ? NULL : wait);  
 <br> 这个是调用文件系统的 poll函数，不同的文件系统poll函数自然不同，由于我们这里关注的是tcp连接，而socketfs的注册在 net/Socket.c里。  
 <br> register_filesystem(&amp;sock_fs_type);  
 <br> socket文件系统的函数也是在net/Socket.c里：  
 <br> 
 <div id=""> 
  <div>
    C代码   
   <a target="_blank" title="收藏这段代码"><img src="https://images2.imgbox.com/cf/32/tdMMqqT2_o.png" alt="收藏代码"></a> 
  </div> 
  <ol start="1"><li>static const struct file_operations socket_file_ops = {  </li><li>    .owner =    THIS_MODULE,  </li><li>    .llseek =    no_llseek,  </li><li>    .aio_read =    sock_aio_read,  </li><li>    .aio_write =    sock_aio_write,  </li><li>    .poll =        sock_poll,  </li><li>    .unlocked_ioctl = sock_ioctl,  </li><li>#ifdef CONFIG_COMPAT  </li><li>    .compat_ioctl = compat_sock_ioctl,  </li><li>#endif  </li><li>    .mmap =        sock_mmap,  </li><li>    .open =        sock_no_open,    /* special open code to disallow open via /proc */  </li><li>    .release =    sock_close,  </li><li>    .fasync =    sock_fasync,  </li><li>    .sendpage =    sock_sendpage,  </li><li>    .splice_write = generic_splice_sendpage,  </li><li>    .splice_read =    sock_splice_read,  </li><li>};  </li></ol> 
 </div> 
 <br> 从sock_poll跟随下去，  
 <br> 最后可以到 net/ipv4/tcp.c的  
 <br> unsigned int tcp_poll(struct file *file, struct socket *sock, poll_table *wait)  
 <br> 这个是最终的查询函数，  
 <br> 也就是说select 的核心功能是调用tcp文件系统的poll函数，不停的查询，如果没有想要的数据，主动执行一次调度（防止一直占用cpu），直到有一个连接有想要的消息为止。  
 <br> 从这里可以看出select的执行方式基本就是不同的调用poll,直到有需要的消息为止，如果select 处理的socket很多，这其实对整个机器的性能也是一个消耗。  
 <br> 
 <br> 2、epoll的实现  
 <br> 
 <br> epoll的实现代码在 fs/EventPoll.c下，  
 <br> 由于epoll涉及到几个系统调用，这里不逐个分析了，仅仅分析几个关键点，  
 <br> 第一个关键点在  
 <br> static int ep_insert(struct eventpoll *ep, struct epoll_event *event,  
 <br>              struct file *tfile, int fd)  
 <br> 这是在我们调用sys_epoll_ctl 添加一个被管理socket的时候调用的函数，关键的几行如下：  
 <br> epq.epi = epi;  
 <br>     init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);  
 <br> 
 <br>     /*  
 <br>      * Attach the item to the poll hooks and get current event bits.  
 <br>      * We can safely use the file* here because its usage count has  
 <br>      * been increased by the caller of this function. Note that after  
 <br>      * this operation completes, the poll callback can start hitting  
 <br>      * the new item.  
 <br>      */  
 <br>     revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);  
 <br> 这里也是调用文件系统的poll函数，不过这次初始化了一个结构，这个结构会带有一个poll函数的callback函数：ep_ptable_queue_proc，  
 <br> 在调用poll函数的时候，会执行这个callback，这个callback的功能就是将当前进程添加到 socket的等待进程上。  
 <br> 
 <div id=""> 
  <div>
    C代码   
   <a target="_blank" title="收藏这段代码"><img src="https://images2.imgbox.com/f5/de/IzRWL3l8_o.png" alt="收藏代码"></a> 
  </div> 
  <ol start="1"><li>static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,  </li><li>                 poll_table *pt)  </li><li>{  </li><li>    struct epitem *epi = ep_item_from_epqueue(pt);  </li><li>    struct eppoll_entry *pwq;  </li><li>  </li><li>    if (epi-&gt;nwait &gt;= 0 &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) {  </li><li>        init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);  </li><li>        pwq-&gt;whead = whead;  </li><li>        pwq-&gt;base = epi;  </li><li>        add_wait_queue(whead, &amp;pwq-&gt;wait);  </li><li>        list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);  </li><li>        epi-&gt;nwait++;  </li><li>    } else {  </li><li>        /* We have to signal that an error occurred */  </li><li>        epi-&gt;nwait = -1;  </li><li>    }  </li><li>}    </li></ol> 
 </div> 
 <br> 注意到参数 whead 实际上是 sk-&gt;sleep，其实就是将当前进程添加到sk的等待队列里，当该socket收到数据或者其他事件触发时，会调用  
 <br> sock_def_readable 或者sock_def_write_space 通知函数来唤醒等待进程，这2个函数都是在socket创建的时候填充在sk结构里的。  
 <br> 从前面的分析来看，epoll确实是比select聪明的多、轻松的多，不用再苦哈哈的去轮询了。 
 <br> 
</div> 
<div style="color:rgb(69,69,69); font-family:Verdana,Helvetica,Arial; line-height:18px; text-align:justify; background-color:rgb(247,247,247)"> 
 <br> 
</div> 
<div style="color:rgb(69,69,69); font-family:Verdana,Helvetica,Arial; line-height:18px; text-align:justify; background-color:rgb(247,247,247)"> 
 <a target="_blank" href="http://buluzhai.iteye.com/blog/1013451" rel="nofollow noopener noreferrer" style="color:rgb(93,93,93); text-decoration:none; font-family:Verdana,Helvetica,Arial; line-height:18px; text-align:justify; background-color:rgb(247,247,247)">http://buluzhai.iteye.com/blog/1013451</a>  
 <br> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f263775278e687a237cfa8e3e73f9d77/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows Socket编程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9936b39fb1a1791f994560417764a457/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CSS&#43;JS实现图片集展示</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>