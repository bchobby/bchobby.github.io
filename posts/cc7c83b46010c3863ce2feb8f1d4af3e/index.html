<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>万字长文，38 图爆肝 Redis 基础！ - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="万字长文，38 图爆肝 Redis 基础！" />
<meta property="og:description" content="00 前言 Redis 在互联网技术存储方面的使用可以说是非常广泛了，只要是接触过 Java 开发的朋友就算你没用过，都会听过它。在面试也是非常高频的一个知识点。
最近，我的的小弟小胖和老王就对 Redis 非常感兴趣；我推荐它一本书《Redis设计与实现》。谁知这货说看不下去，非要我来总结一波。所以本文算是给小胖和老王的学习资料，也是我自己的学习笔记。希望对你有帮助。
还是老规矩，先上张脑图。全文 13274 字，从下午 2 点爆肝到晚上 9 点，先上张思维导图镇楼：
0.1 往期精彩 1、小胖问我：select 语句是怎么执行的？
2、女朋友问我：MySQL 索引的原理是怎样的？
3、小胖问我：MySQL 日志到底有啥用？
4、老王问我：MySQL 事务与 MVCC 原理是怎样的？
5、女朋友问我：MySQL 的锁机制是怎样的？
01 什么是 Redis？ 官方是这么描述的：
Redis （用 C 语言实现的）是一个开源的，基于内存的数据结构存储，可用作于数据库、缓存、消息中间件。
信息简洁明了，一下就知道了三个点：基于内存、用作缓存、多种数据结构。
的了，那就从这三个方面开始研究呗。
1.0 为什么要用 Redis 做缓存？ 上面说了，用作缓存。有些小伙伴可能会问：有 MySQL 数据库就得了呗？干嘛还要缓存？而且为啥要用 Redis 做？Map 不行嘛？
第一、二个问题，都知道 MySQL 数据是存在磁盘的，而 CPU 访问磁盘是非常慢的。如果遇到并发高的时候，所有线程每次都要访问磁盘，估计得挂。 到底有多慢？请看链接：zhuanlan.zhihu.com/p/24726196
Redis 和 Map 做下对比，就知道为啥不合适了。
Map 是本地缓存，如果在多台机器部署，必须每个机器都要复制一份，否则造成缓存不一致；Redis 是分布式缓存，部署在多台机器，也是用的同一份缓存，保持了一致性，问题不大。Map 做缓存，数据量大的话会导致 JVM 内存飙升，进而拖垮程序，并且 JVM 挂了，还会导致数据丢失；Redis 可以用更大容量的内存（看你的配置，即几十G都没问题）做缓存，并且还可以持久化到磁盘。 02 Redis 的数据结构 你可能第一反应不就 “String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合）么？”，太简单了，我都会。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/cc7c83b46010c3863ce2feb8f1d4af3e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-21T15:11:37+08:00" />
<meta property="article:modified_time" content="2021-04-21T15:11:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">万字长文，38 图爆肝 Redis 基础！</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="00__0"></a>00 前言</h2> 
<p>Redis 在互联网技术存储方面的使用可以说是非常广泛了，只要是接触过 Java 开发的朋友就算你没用过，都会听过它。在面试也是非常高频的一个知识点。</p> 
<p>最近，我的的小弟<strong>小胖和老王</strong>就对 Redis 非常感兴趣；我推荐它一本书《Redis设计与实现》。谁知这货说看不下去，非要我来总结一波。所以本文算是给<strong>小胖和老王</strong>的学习资料，也是我自己的学习笔记。希望对你有帮助。</p> 
<p>还是老规矩，先上张脑图。全文 13274 字，从下午 2 点爆肝到晚上 9 点，先上张思维导图镇楼：</p> 
<p><img src="https://images2.imgbox.com/92/64/TVtJgkmR_o.png" alt=""></p> 
<h3><a id="01__10"></a>0.1 往期精彩</h3> 
<p><a href="https://mp.weixin.qq.com/s/lRY7b9iS_xDDuyKNQKUWSg" rel="nofollow">1、小胖问我：select 语句是怎么执行的？</a></p> 
<p><a href="https://mp.weixin.qq.com/s/ZDM_ttWCstw0mUwGtUEciw" rel="nofollow">2、女朋友问我：MySQL 索引的原理是怎样的？</a></p> 
<p><a href="https://mp.weixin.qq.com/s/yG2pQW7qkTPF4TLBk8qgwQ" rel="nofollow">3、小胖问我：MySQL 日志到底有啥用？</a></p> 
<p><a href="https://mp.weixin.qq.com/s/l62CAZ55ZU9f9fsLOQR71A" rel="nofollow">4、老王问我：MySQL 事务与 MVCC 原理是怎样的？</a></p> 
<p><a href="https://mp.weixin.qq.com/s/cuD8QiadO64VcSncpY18KQ" rel="nofollow">5、女朋友问我：MySQL 的锁机制是怎样的？</a></p> 
<h2><a id="01__Redis_21"></a>01 什么是 Redis？</h2> 
<p>官方是这么描述的：</p> 
<blockquote> 
 <p>Redis （用 C 语言实现的）是一个开源的，基于内存的数据结构存储，可用作于数据库、缓存、消息中间件。</p> 
</blockquote> 
<p>信息简洁明了，一下就知道了三个点：<strong>基于内存、用作缓存、多种数据结构</strong>。</p> 
<p>的了，那就从这三个方面开始研究呗。</p> 
<h3><a id="10__Redis__31"></a>1.0 为什么要用 Redis 做缓存？</h3> 
<p>上面说了，用作缓存。有些小伙伴可能会问：有 MySQL 数据库就得了呗？干嘛还要缓存？而且为啥要用 Redis 做？Map 不行嘛？</p> 
<ul><li>第一、二个问题，都知道 MySQL 数据是存在磁盘的，而 CPU 访问磁盘是非常慢的。如果遇到并发高的时候，所有线程每次都要访问磁盘，估计得挂。</li></ul> 
<p>到底有多慢？请看链接：zhuanlan.zhihu.com/p/24726196</p> 
<p>Redis 和 Map 做下对比，就知道为啥不合适了。</p> 
<ul><li>Map 是本地缓存，如果在多台机器部署，必须每个机器都要复制一份，否则造成缓存不一致；Redis 是分布式缓存，部署在多台机器，也是用的同一份缓存，保持了一致性，问题不大。</li><li>Map 做缓存，数据量大的话会导致 JVM 内存飙升，进而拖垮程序，并且 JVM 挂了，还会导致数据丢失；Redis 可以用更大容量的内存（看你的配置，即几十G都没问题）做缓存，并且还可以持久化到磁盘。</li></ul> 
<h2><a id="02_Redis__44"></a>02 Redis 的数据结构</h2> 
<p>你可能第一反应不就 “String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合）么？”，太简单了，我都会。</p> 
<p>老铁你错了，你说的是 Redis 的数据类型只有 5 种，也就是他的表现形式。而我说的数据结构是底层的，<strong>有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组</strong>，它们的对应关系如下：</p> 
<p><img src="https://images2.imgbox.com/a6/85/XjZspJDy_o.png" alt="对应关系"></p> 
<p>由上图可知 String 类型的底层实现只有一种数据结构，而 List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构都是集合。</p> 
<p>看到这里，你可能又有疑问了。这些数据结构都是值的底层实现，键和值本身之间用什么结构组织？</p> 
<h3><a id="20__56"></a>2.0 键和值用什么结构组织？</h3> 
<p>实际上，<strong>Redis 使用了一个哈希表来保存所有键值对。它的存储是以 key-value 的形式的。 key 一定是字符串，value 可以是 string、list、hash、set、sortset 中的随便一种</strong>。</p> 
<p><strong>一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。每个哈希桶中保存了键值对数据，哈希桶中的元素保存的并不是值本身，而是指向具体值的指针</strong>。这点从下图可以看出：</p> 
<p><img src="https://images2.imgbox.com/0b/d0/gba85aWo_o.png" alt="哈希表"></p> 
<p>**哈希桶中的 entry 元素中保存了 *key 和 <em>value 指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过 <em>value 指针被查找到</em></em>。</p> 
<p>redis 的键值都是 redisObject 对象，即在创建时会生成一个用于键名的 redisObject 对象和一个用于键值的 redisObject 对象。这点从源码也可以看出来：</p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> redisObject <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 类型</span>
    <span class="token keyword">unsigned</span> type<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 编码</span>
    <span class="token keyword">unsigned</span> encoding<span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 指向数据的指针</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>

    <span class="token comment">// 记录对象最后一次被程序访问时间，用于计算空转时长(当前时间-lru)</span>
    <span class="token keyword">unsigned</span> lru<span class="token punctuation">:</span><span class="token number">22</span><span class="token punctuation">;</span> <span class="token comment">/* lru time (relative to server.lruclock) */</span>
    
    <span class="token comment">// 引用计数，用于内存回收</span>
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>
<span class="token punctuation">}</span> robj<span class="token punctuation">;</span>
</code></pre> 
<p>也就是说上图 entry 中的健值指针就分别指向这样一个 redisObject。<strong>其中 type、 encoding 和 ptr 是最重要的三个属性</strong>。type 记录了对象所保存的值的类型，它的值可能是以下常量的其中一个。</p> 
<pre><code class="prism language-c"><span class="token comment">/*
 * 对象类型
 */</span>
<span class="token macro property">#<span class="token directive keyword">define</span> REDIS_STRING 0  </span><span class="token comment">// 字符串</span>
<span class="token macro property">#<span class="token directive keyword">define</span> REDIS_LIST 1    </span><span class="token comment">// 列表</span>
<span class="token macro property">#<span class="token directive keyword">define</span> REDIS_SET 2     </span><span class="token comment">// 集合</span>
<span class="token macro property">#<span class="token directive keyword">define</span> REDIS_ZSET 3    </span><span class="token comment">// 有序集</span>
<span class="token macro property">#<span class="token directive keyword">define</span> REDIS_HASH 4    </span><span class="token comment">// 哈希表</span>
</code></pre> 
<p>encoding 记录了 对象所保存的值的编码，它的值可能是以下常量的其中一个.</p> 
<pre><code class="prism language-c"><span class="token comment">/*
 * 对象编码
 */</span>
<span class="token macro property">#<span class="token directive keyword">define</span> REDIS_ENCODING_RAW 0            </span><span class="token comment">// 编码为字符串</span>
<span class="token macro property">#<span class="token directive keyword">define</span> REDIS_ENCODING_INT 1            </span><span class="token comment">// 编码为整数</span>
<span class="token macro property">#<span class="token directive keyword">define</span> REDIS_ENCODING_HT 2             </span><span class="token comment">// 编码为哈希表</span>
<span class="token macro property">#<span class="token directive keyword">define</span> REDIS_ENCODING_ZIPMAP 3         </span><span class="token comment">// 编码为 zipmap</span>
<span class="token macro property">#<span class="token directive keyword">define</span> REDIS_ENCODING_LINKEDLIST 4     </span><span class="token comment">// 编码为双端链表</span>
<span class="token macro property">#<span class="token directive keyword">define</span> REDIS_ENCODING_ZIPLIST 5        </span><span class="token comment">// 编码为压缩列表</span>
<span class="token macro property">#<span class="token directive keyword">define</span> REDIS_ENCODING_INTSET 6         </span><span class="token comment">// 编码为整数集合</span>
<span class="token macro property">#<span class="token directive keyword">define</span> REDIS_ENCODING_SKIPLIST 7       </span><span class="token comment">// 编码为跳跃表</span>
</code></pre> 
<p>比如，我们在 redis 里面 put (“狗哥”,666)，在 redisObject 实际上是这样存放的：</p> 
<p><img src="https://images2.imgbox.com/b7/e8/W9KwkF4n_o.png" alt="redisObject"></p> 
<h3><a id="21_SDS__120"></a>2.1 SDS 简单动态字符串</h3> 
<blockquote> 
 <p>简单动态字符串 (Simple dynamic string,SDS)</p> 
</blockquote> 
<p>跟传统的 C 语言字符串不一样，Redis 使用了 SDS 来构建自己的字符串对象，源码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">struct</span> sdshdr<span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 字节数组，用于保存字符串</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// 记录buf数组中已使用的字节数量，也是字符串的长度</span>
    <span class="token keyword">int</span> len<span class="token punctuation">;</span>

    <span class="token comment">// 记录buf数组未使用的字节数量</span>
    <span class="token keyword">int</span> free<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>图示：</p> 
<p><img src="https://images2.imgbox.com/19/6c/K4IlhhNT_o.png" alt="SDS例子"></p> 
<blockquote> 
 <p>buf属性是一个char类型的数组，最后一个字节保存了空字符’\0’，不算入 len 长度。</p> 
</blockquote> 
<h4><a id="210__SDS_146"></a>2.1.0 为什么使用 SDS？</h4> 
<p>SDS 比 C 字符串好在哪？</p> 
<ul><li><strong>常数复杂度获取字符串长度</strong>：C 字符串不记录长度，统计长度只能逐个遍历字符，复杂度是 O(N)；而 SDS 在 len 属性中记录了自身长度，复杂度仅为 O(1)。</li><li><strong>不会发生缓冲区溢出</strong>：SDS 不会发生溢出的问题，如果修改 SDS 时，空间不足。先会扩展空间，再修改！(<strong>内部实现了动态扩展机制</strong>)。</li><li>SDS 可以<strong>减少内存分配的次数 (空间预分配 &amp; 惰性空间释放)</strong>。在扩展空间时，除了分配修改时所必要的空间，还会分配额外的空闲空间 (free 属性)。</li><li>SDS 是<strong>二进制安全的</strong>，所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据。</li></ul> 
<h3><a id="22__155"></a>2.2 链表</h3> 
<p>链表，大家都很熟悉了吧？在 Java 中 LinkedList 的底层数据结构就是链表 + 数组实现的。那 Redis 中的链表是怎样的呢？</p> 
<p>按照惯例，上源码。它使用 listNode 结构（源码位于 adlist.h）表示链表的每个节点：</p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> strcut listNode<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//前置节点</span>
    strcut listNode  <span class="token operator">*</span>pre<span class="token punctuation">;</span>

    <span class="token comment">//后置节点</span>
    strcut listNode  <span class="token operator">*</span>pre<span class="token punctuation">;</span>

    <span class="token comment">//节点的值</span>
    <span class="token keyword">void</span>  <span class="token operator">*</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>listNode
</code></pre> 
<p>多个 listNode 可以通过 prev 和 next 指针组成一个双向链表，像这样：</p> 
<p><img src="https://images2.imgbox.com/31/53/38GlGwzg_o.png" alt="双向链表"></p> 
<p>节点表示出来了，整个链表又该怎么表示呢？Redis 使用 list 结构（源码位于 adlist.h）来构建链表，上源码：</p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> list<span class="token punctuation">{<!-- --></span>

    <span class="token comment">//表头结点</span>
    listNode  <span class="token operator">*</span>head<span class="token punctuation">;</span>

    <span class="token comment">//表尾节点</span>
    listNode  <span class="token operator">*</span>tail<span class="token punctuation">;</span>

    <span class="token comment">//链表长度</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>

    <span class="token comment">//节点值复制函数</span>
    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>dup<span class="token punctuation">)</span> <span class="token punctuation">(</span>viod <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//节点值释放函数</span>
    <span class="token keyword">void</span>  <span class="token punctuation">(</span><span class="token operator">*</span>free<span class="token punctuation">)</span> <span class="token punctuation">(</span>viod <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//节点值对比函数</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>match<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>list
</code></pre> 
<p><img src="https://images2.imgbox.com/79/40/66YGnKVk_o.png" alt="链表"></p> 
<h4><a id="220_Redis__206"></a>2.2.0 Redis 链表的特性</h4> 
<ul><li>双端：有 prev 和 next 两个指针；可以前后移动。</li><li>无环：链表不闭环，prev 和 next 都指向 null，链表访问以 null 为终点。</li><li>获取带表头指针、表尾指针、节点数量的时间复杂度均为 O (1)。</li><li>链表使用 void * 指针来保存节点值，可以保存各种不同类型的值。</li></ul> 
<h3><a id="23__213"></a>2.3 哈希表</h3> 
<p>哈希表，大家也都不陌生吧？在 Java 中哈希表的底层数据结构就是数组 + 链表实现的。那 Redis 中的哈希表是怎样实现的呢？</p> 
<p>按照惯例，上源码。哈希表使用 dictht 结构（源码位于 dict.h）表示哈希表，源码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictht<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 哈希表数组</span>
	dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span>  

	<span class="token comment">// 哈希表大小，也即 table 大小</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>    

	<span class="token comment">// 哈希表大小掩码，用于计算索引值</span>
	<span class="token comment">// 总是等于size-1</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemark<span class="token punctuation">;</span>     

    <span class="token comment">// 哈希表已有节点数量</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span>
<span class="token punctuation">}</span>dictht
</code></pre> 
<p>sizemark 和哈希值决定一个键应该被放到 table 数组的那个索引上。PS：就是 Java 中计算哈希值决定位置的方法。</p> 
<p>图示一个大小为 4 的空哈希表（不包含任何键值）</p> 
<p><img src="https://images2.imgbox.com/01/a5/fixNeGsj_o.png" alt="空的哈希表"></p> 
<p>哈希表节点使用 dictEntry 结构表示，每个 dictEntry 都保存着一个键值对。源码如下：</p> 
<pre><code class="prism language-c"> <span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictEntry <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 键</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>

	<span class="token comment">// 值</span>
	<span class="token keyword">union</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>
		uint64_tu64<span class="token punctuation">;</span>
		int64_ts64<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>v<span class="token punctuation">;</span> 

	<span class="token comment">// 指向下个哈希节点，组成链表</span>
	<span class="token keyword">struct</span> dictEntry <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>dictEntry<span class="token punctuation">;</span>
</code></pre> 
<p>key 解释得很清楚了；说说 v 属性，它 保存着键值对中的值，可以是一个指针，或者是一个 uint64_t 整数，又或者是一个 int64_t 整数。</p> 
<p><strong>next 则是执行下一个哈希表节点的指针，可以将多个哈希值相同的键值对连接在一起作为一个链表，以此来解决键冲突（collision）的问题</strong>。PS：参考 Java 中 HashMap 是怎么解决冲突的。旧文：<a href="https://mp.weixin.qq.com/s/PgIcJV_7H4kb4ZIGs20KaQ" rel="nofollow">《HashMap 源码解读》</a>有提过。</p> 
<p>图示通过 next 指针把相同索引值的键 k1 和 k0 连接在一起。</p> 
<p><img src="https://images2.imgbox.com/3c/eb/JmMjetqy_o.png" alt="next 指针串联键"></p> 
<p>为了更好实现 rehash（扩容）；Redis 又在哈希表之上封装了一层，称之为字典。由 dict 结构表示，源码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dict <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 类型特定函数</span>
    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span>
    <span class="token comment">// 私有数据</span>
    <span class="token keyword">void</span> <span class="token operator">*</span> privdata<span class="token punctuation">;</span> 
    <span class="token comment">// 哈希表，代表两个哈希表</span>
    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// rehash索引</span>
    <span class="token comment">// 当rehash不在进行时， 值为 - 1 </span>
    in trehashidx<span class="token punctuation">;</span> <span class="token comment">/*rehashing not in pro gress if rehashidx==-1*/</span>
<span class="token punctuation">}</span>dict<span class="token punctuation">;</span>

<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictType<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//计算哈希值的函数</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>hashFunction<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 复制键的函数</span>
    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>keyDup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>private<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 复制值的函数</span>
    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>valDup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>private<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  

    <span class="token comment">// 对比键的函数</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>keyCompare<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>privdata <span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key2<span class="token punctuation">)</span>

    <span class="token comment">// 销毁键的函数</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>keyDestructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>private<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 销毁值的函数</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>valDestructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>private<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>dictType
</code></pre> 
<p>type 属性和 privdata 属性是针对不同类型的键值对，为创建多态字典而设置的。</p> 
<ul><li>type 是一个指向 dictType 的指针，每个 dictType 保存了一簇用于操作特定类型键值对的函数，Redis 为用途不同的字典设置不同的类型特定函数</li><li>而 privdata 则保存了传给类型特定函数的可选参数</li><li><strong>ht 是包含了两个哈希表的数组； ht[0] 存放真实数据，ht[1] 在对 ht[0] 进行 rehash（扩容）时使用</strong>。</li></ul> 
<p>最终，<strong>你会发现其实所谓的字典就是两个哈希表组成的</strong>。图式结构如下：</p> 
<p><img src="https://images2.imgbox.com/e2/d8/zvuRKH4G_o.png" alt="哈希表"></p> 
<h4><a id="230__316"></a>2.3.0 哈希冲突</h4> 
<p>当往哈希表写入大量数据时，不可避免的就出现多个 key 计算出来的哈希值相同。也就是多个不同的 key 需要放到同一个哈希桶，这就是所谓的<strong>哈希冲突</strong>。</p> 
<p>而 Redis 解决哈希冲突的手段很 Java 一样，都是链式哈希：<strong>同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接</strong>。</p> 
<p><img src="https://images2.imgbox.com/b1/73/WMeoRE3O_o.png" alt="解决哈希冲突"></p> 
<p>如图，假设 entry1、entry2、entry3 的哈希值都是 3 ；那么他们将存放在下标为 3 的哈希桶里面，并转换成链表。</p> 
<p>PS：没懂哈希冲突的看旧文。旧文：<a href="https://mp.weixin.qq.com/s/PgIcJV_7H4kb4ZIGs20KaQ" rel="nofollow">《HashMap 源码解读》</a>有详细例子解析。</p> 
<p>当不断发生哈希冲突，链表越来越长，影响查询性能时，Redis 就需要 rehash。</p> 
<h4><a id="231_rehash_330"></a>2.3.1 rehash（扩容）</h4> 
<p>Redis 开始执行 rehash，这个过程分为三步：</p> 
<ul><li>1、给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li><li>2、把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；</li><li>3、释放哈希表 1 的空间。</li></ul> 
<p>如此，就可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用。</p> 
<p>你肯定以为这样就完美了？但还有坑，<strong>当哈希表 1 数据量很大，如果一次性复制就会造成线程阻塞，无法服务其他请求</strong>。Redis 不允许这种事发生，因此使用了<strong>渐进式 rehash</strong>。</p> 
<p>PS：没懂 rehash 的看旧文。旧文：《HashMap 源码解读》有详细例子解析。</p> 
<h4><a id="232__rehash_344"></a>2.3.2 渐进式 rehash</h4> 
<p>啥是渐进式 rehash ？</p> 
<p>在第二步拷贝数据时，Redis 仍然正常处理客户端请求，<strong>每处理一个请求，顺带从哈希表 1 中的第一个索引位置开始，把这个位置上所有的 entry 复制到哈希表 2 中，下个请求就复制位置 2</strong>；直至全部复制完成。</p> 
<p>过程如下图所示：</p> 
<p><img src="https://images2.imgbox.com/40/1f/beNBFZTO_o.png" alt="渐进式rehash"></p> 
<p>具体到代码，它的过程是这样的：</p> 
<ul><li>1、在字典中维持一个索引计数器变量 rehashidx，并将设置为 0，表示 rehash 开始。</li><li>2、在 rehash 期间，客户端每次对字典进行 CRUD 操作时，会将 ht [0] 中 rehashidx 索引上的值 rehash 到 ht [1]，操作完成后 rehashidx+1。</li><li>3、字典操作不断执行，最终在某个时间点，所有的键值对完成 rehash，这时将 rehashidx 设置为 - 1，表示 rehash 完成</li></ul> 
<p>说到这，你可能还有以下几点疑问？</p> 
<p><strong>只有在操作字典的时候才进行复制数据吗？如果客户端只操作一次字段是不是就完不成 rehash 了？</strong></p> 
<p>渐进式 rehash 执行时，除了根据针对字典的 CRUD 操作来进行数据迁移，<strong>Redis 本身还会有一个定时任务在执行 rehash</strong>，如果没有针对字典的请求时，这个定时任务会周期性地（例如每 100ms 一次）搬移一些数据到新的哈希表。</p> 
<p><strong>渐进式 rehash，CRUD 究竟在哪个哈希表操作呢？</strong></p> 
<p>在渐进式 rehash 过程中，字典会同时使用两个哈希表 ht [0] 和 ht [1]，所有的 CRUD 操作也会在两个哈希表进行。</p> 
<p>比如要查找一个键时，服务器会优先查找 ht [0]，如果不存在，再查找 ht [1]。当执行<strong>新增操作</strong>时，新的键值对一律保存到 ht [1]，不再对 ht [0] 进行任何操作，以保证 ht [0] 的键值对数量只减不增，最后变为空表。</p> 
<h3><a id="24__372"></a>2.4 跳跃表</h3> 
<p>跳跃表在 Java 中很少接触到，大家对这个知识点也是挺陌生的。之前在学习数据结构是看到过小灰的一篇文章，写得通俗易懂，大家可以看下，建议看完再往下看。</p> 
<p>https://mp.weixin.qq.com/s/COBdoHWDhlw4rmG_fGFhSA</p> 
<p>跳跃表 (shiplist) 是实现 sortset (有序集合) 的底层数据结构之一；除此以外，在集群节点中也有用到它。</p> 
<p>Redis 的跳跃表由 zskiplistNode 和 zskiplist 两个结构定义，源码位于 redis.h 文件中。<strong>其中前者是跳跃表的结构；后者的作用是保存跳跃表的节点数量与头、尾节点的指针等信息</strong>。</p> 
<pre><code class="prism language-c"><span class="token keyword">typeof</span> <span class="token keyword">struct</span> zskiplistNode <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 后退指针</span>
    <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span>backward<span class="token punctuation">;</span>
    <span class="token comment">// 分值</span>
    <span class="token keyword">double</span> score<span class="token punctuation">;</span>
    <span class="token comment">// 成员对象</span>
    robj <span class="token operator">*</span>obj<span class="token punctuation">;</span>
    <span class="token comment">// 层</span>
	<span class="token keyword">struct</span> zskiplistLevel <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 前进指针</span>
        <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span>forward<span class="token punctuation">;</span>
		<span class="token comment">// 跨度</span>
		<span class="token keyword">unsigned</span> <span class="token keyword">int</span> span<span class="token punctuation">;</span>
	<span class="token punctuation">}</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> zskiplistNode<span class="token punctuation">;</span>
</code></pre> 
<p>如下图所示，展示了不同层高的跳跃表节点</p> 
<p><img src="https://images2.imgbox.com/da/a9/y0CLpc2c_o.png" alt="不同层高的节点"></p> 
<pre><code class="prism language-c"><span class="token keyword">typeof</span> <span class="token keyword">struct</span> zskiplist <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 表头节点，表尾节点</span>
    <span class="token keyword">struct</span> skiplistNode <span class="token operator">*</span>header<span class="token punctuation">,</span><span class="token operator">*</span>tail<span class="token punctuation">;</span>
    <span class="token comment">// 表中节点数量</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span>
    <span class="token comment">// 表中最大层数</span>
    <span class="token keyword">int</span> level<span class="token punctuation">;</span>
<span class="token punctuation">}</span> zskiplist<span class="token punctuation">;</span>
</code></pre> 
<p>下图展示了一个跳跃表示例：</p> 
<p><img src="https://images2.imgbox.com/90/e4/tvrfjnM0_o.png" alt="多个节点组成跳跃表"></p> 
<p>图片最左边的是 zskiplist 结构，包含：</p> 
<ul><li>header：指向跳跃表的表头节点。</li><li>tail：指向跳跃表的表尾节点。</li><li>level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li><li>length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li></ul> 
<p>zskiplist结构右方的是四个zskiplistNode结构， 包含：</p> 
<ul><li>层：比如节点中的 L1、L2、L3 等，包括前进指针和跨度</li><li>前进指针：用于访问位于表尾方向的其他节点</li><li>跨度：记录了前进指针所指向节点和当前节点的距离</li><li>后退指针：指向当前节点的前一个节点，从表尾向表头遍历</li><li>分值：节点按各自分值从小到大排列</li><li>成员对象：节点所保存的成员对象</li></ul> 
<p><strong>PS：跳跃表这块的内容比较多，比较难说清楚实现细节。具体的看上面的链接，以及《Redis 设计与实现》这本书（说得很好，微信读书网页版就有）</strong></p> 
<h3><a id="25__437"></a>2.5 整数集合</h3> 
<p>整数集合是 Set（集合）的底层数据结构之一。 当 Set 只包含整数值元素，并且这个 Set 的元素数量不多时，Redis 就会使用整数集合作为 Set 的底层实现。</p> 
<p>Redis 使用了 intset 用于保存整数值集合，它保证了有序以及不重复。源码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">typeof</span> <span class="token keyword">struct</span> intset <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 编码方式</span>
    unit32_t encoding<span class="token punctuation">;</span>
    <span class="token comment">// 集合包含的元素数量</span>
    unit32_t lenght<span class="token punctuation">;</span>
    <span class="token comment">// 保存元素的数组</span>
    int8_t contents<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> intset<span class="token punctuation">;</span>
</code></pre> 
<p>一个保存了 5 个整数的集合如下所示：</p> 
<p><img src="https://images2.imgbox.com/77/96/4uWIyRiT_o.png" alt="整数集合"></p> 
<p>length 就不说了，主要说下 contents 和 encoding 的关系； contents 的真正类型取决于encoding 的值：</p> 
<ul><li>INTSET_ENC_INT16</li><li>INTSET_ENC_INT32</li><li>INTSET_ENC_INT64</li></ul> 
<p>这三个值分别对应 16、32、64 编码对应能存放的数字范围是不一样的。16 最小（-32768~32767），32 在中间（-2147483648~2147483647）64 最大（-9223372036854775808~9223372036854775807）。</p> 
<p>如下图所示为 INTSET_ENC_INT16 类型集合存放 5 位整数占用的空间：16 * 5</p> 
<p><img src="https://images2.imgbox.com/20/1b/VEpHUQn3_o.png" alt="上图集合占用位数"></p> 
<h4><a id="250__470"></a>2.5.0 升级操作</h4> 
<p>如果 contents 本来保存 1、3、5 三个整数值，后面加一个 2147483647456。</p> 
<p>那么只有 2147483647456 是真正需要 int64_t 类型来保存的，而其他的 1、3、5 都可以用 int16_t 类型来保存；<strong>这时是整体升级，所有元素都会被升级为 int64_t 类型</strong>。</p> 
<p>也就是说本来是 int16_t 类型的集合，要放入大于本身的整数。就需要升级，步骤如下：</p> 
<ul><li>1、根据新元素类型拓展整数集合底层数组的空间并为新元素分配空间。</li><li>2、将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放到正确的位上，需要维持底层数组的有序性质不变。</li><li>3、将新元素添加到底层数组。</li></ul> 
<p>举个栗子：</p> 
<p>1、原来是数组是 INTSET_ENC_INT16 类型 3 位，占用 48 位空间；</p> 
<p><img src="https://images2.imgbox.com/d7/26/i73pCPmQ_o.png" alt="原始数据"></p> 
<p>2、插入整数 65535，超出 INTSET_ENC_INT16 范围；升级为 INTSET_ENC_INT32 。需要的空间也从 48 加到 128 位。如下所示：新分配空间 = 128 - 48 = 80</p> 
<p><img src="https://images2.imgbox.com/20/01/q3N89d6K_o.png" alt="新分配空间"></p> 
<p>3、元素 3 排名第三，移动到 contents 索引 2 位置；其他类似，元素 2 移动到索引 1 位置；元素 1 移动到索引 0 位置</p> 
<p><img src="https://images2.imgbox.com/47/ed/zomi9SYy_o.png" alt="移动元素 3"></p> 
<p>4、最后添加新元素 65535 即可完成升级。</p> 
<p>注意点：<strong>整数集合只支持升级、不支持降级</strong>。</p> 
<h3><a id="26__500"></a>2.6 压缩列表</h3> 
<p>压缩列表是 list 和 hash 的底层实现之一，当 list 只包含少量元素，并且每个元素都是小整数值，或者是比较短的字符串，压缩列表会作为 list 的底层实现。</p> 
<p>压缩列表（ziplist）是 Redis 为<strong>节约内存</strong>而开发，它的理念是<strong>多大元素用多大内存</strong>。</p> 
<p>如下图，根据每个节点的实际存储的内容决定内存的大小，第一个节点占用 5 字节，第二个节点占用 5 字节，第三个节点占用 1 字节，第四个节点占用 4 字节，第五个节点占用 3 字节。</p> 
<p><img src="https://images2.imgbox.com/f8/46/uFltGuTK_o.png" alt="多大元素用多大内存"></p> 
<p>图示为 ziplist 的结构：它类似于一个数组，不同的是它在表头有三个字段 zlbytes、zltail 和 zllen；分别表示列表长度、列表尾的偏移量和元素的个数；表尾有 zlend，列表结束的标识。</p> 
<p><img src="https://images2.imgbox.com/a5/78/wm6iqO8p_o.png" alt="压缩列表"></p> 
<h4><a id="260__514"></a>2.6.0 节点构成</h4> 
<p>图示一个压缩列表中一个节点的构成：</p> 
<p><img src="https://images2.imgbox.com/b0/bd/avp71oyL_o.png" alt="节点构成"></p> 
<ul><li>previous_entry_length：记录前一个节点的长度</li><li>encoding：编码，控制 content 的类型和长度；分为字节数组编码和整数编码</li><li>content：保存节点值，可以是一个字节数组或整数</li></ul> 
<h4><a id="261__524"></a>2.6.1 压缩列表的查找</h4> 
<p><img src="https://images2.imgbox.com/9b/0a/tEJYLbjG_o.png" alt="压缩列表"></p> 
<p>如果查找的是第一个元素或最后一个元素，可通过表头三个字段的长度直接定位，复杂度是 O (1)。而查找其他元素时，只能逐个查找，复杂度是 O (N) 。</p> 
<p>倒序遍历：首先指针通过 zltail 偏移量指向表尾节点，然后通过指向<strong>节点记录的前一个节点的长度依次向前遍历访问整个压缩列表</strong>。</p> 
<h2><a id="03__532"></a>03 数据类型与数据结构</h2> 
<p>还记得文章开头那张数据类型与底层数据结构的对应关系图吗？长这样：</p> 
<p><img src="https://images2.imgbox.com/2e/fc/nIYJwkol_o.png" alt="对应关系"></p> 
<p>Redis 这种对应关系实际上是由 redisObject 的 type（类型）和 encoding （编码）共同决定的，详细对应关系如下：</p> 
<p><img src="https://images2.imgbox.com/29/a5/eW0fDb5U_o.png" alt="不同类型和编码的对象"></p> 
<p>下面来具体介绍下，什么条件下使用那种类型实现对应的对象。比如：String 什么情况下用 int 编码实现？什么情况下用 embstr 编码实现？什么情况下用 raw 编码实现呢？</p> 
<h3><a id="30_String_544"></a>3.0 字符串（String）对象</h3> 
<p>从上图得知，String 有 int、raw、embst 三种编码格式：</p> 
<ul><li>int：整数值，可以用 long 类型表示，使用整数值保存对象</li><li>raw：字符串值且长度 &gt; 32字节，使用 SDS 保存对象</li><li>embstr：字符串值且长度 &lt; 32字节，使用 embstr 编码的 SDS 保存对象</li></ul> 
<p>PS：对于浮点数（long double 类型表示的），Redis 会将浮点数转换成字符串值；最终视长度决定用那种编码（embstr 或 raw）保存。取出时，再将其转成浮点值。</p> 
<p><img src="https://images2.imgbox.com/e2/80/VQ492paY_o.png" alt="总结"></p> 
<h4><a id="300_embstr__raw__556"></a>3.0.0 embstr 和 raw 有啥区别？</h4> 
<ul><li>raw 分配内存和释放内存的次数是<strong>两次</strong>，embstr 是一次</li><li>embstr 编码的数据保存在一块<strong>连续的内存</strong>里面</li></ul> 
<h4><a id="301__561"></a>3.0.1 编码的转换</h4> 
<ul><li>int 类型的字符串，当保存的不再是<strong>整数值</strong>，将转换成 raw 类型</li><li>embstr 类型的字符串是<strong>只读的</strong>，修改时会转换成 raw 类型。原因：Redis 没有为 embstr 提供修改程序，所以它是只读的；要修改只能先转成 raw。</li></ul> 
<h3><a id="31_list_566"></a>3.1 列表（list）对象</h3> 
<p>还是从上图得知，列表的编码可以是 ziplist 或 linkedlist：</p> 
<ul><li>ziplist：所有元素长度都小于 64 字节且元素数量少于 512 个 
  <ul><li>以上两个条件的上限值可以通过配置文件的 <code>list-max-ziplist-value</code>和<code>list-max-ziplist-entries</code>修改</li></ul> </li><li>linkedlist：不满足上述条件时，将从 ziplist 转换成 linkedlist</li></ul> 
<h4><a id="310__574"></a>3.1.0 区别</h4> 
<p>执行 RPUSH 命令将创建一个列表对象，比如：</p> 
<pre><code class="prism language-sql">redis<span class="token operator">&gt;</span> RPUSH numbers <span class="token number">1</span> <span class="token string">"three"</span> <span class="token number">5</span>
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">3</span>
</code></pre> 
<p>如果 numbers 使用 ziplist 编码，对象结构如下：</p> 
<p><img src="https://images2.imgbox.com/3a/24/QZxxnhQU_o.png" alt="ziplist"></p> 
<p>否则使用 linkedlist，就是双端链表作为底层实现。结构如下：</p> 
<p><img src="https://images2.imgbox.com/2d/6d/204lIVqh_o.png" alt="linkedlist"></p> 
<h3><a id="32_hash_590"></a>3.2 哈希（hash）对象</h3> 
<p>又是从上图得知，哈希的编码可以是 ziplist 或 hashtable：</p> 
<ul><li>ziplist：哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节且键值对数量小于 512 
  <ul><li>以上两个条件的上限值可以通过配置文件的 <code>hash-max-ziplist-value</code>和<code>hash-max-ziplist-entries</code>修改</li></ul> </li><li>hashtable：不能满足上述条件，将从 ziplist 转成 hashtable</li></ul> 
<h4><a id="320__598"></a>3.2.0 区别</h4> 
<p>执行 HSET 命令，可以创建一个 hash 对象并保存数据：</p> 
<pre><code class="prism language-sql">redis<span class="token operator">&gt;</span> HSET profile name <span class="token string">"Tom"</span>
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> HSET profile age <span class="token number">25</span>
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> HSET profile career <span class="token string">"Programmer"</span>
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre> 
<p>ziplist 保存的 hash 对象：</p> 
<p><img src="https://images2.imgbox.com/8f/a1/h6b4uh3W_o.png" alt="ziplist 编码的哈希对象"></p> 
<p><img src="https://images2.imgbox.com/b9/28/FoT0im5J_o.png" alt="ziplist 底层实现"></p> 
<p>hashtable 保存的 hash 对象：</p> 
<ul><li>字典中每个键都是一个字符串对像，对象中保存键值对的键</li><li>字典中每个值都是一个字符串对像，对象中保存键值对的值</li></ul> 
<p>架构如下：</p> 
<p><img src="https://images2.imgbox.com/06/f9/dnW2xYiN_o.png" alt="hashtable 编码的哈希对象"></p> 
<h3><a id="33_set_626"></a>3.3 集合（set）对象</h3> 
<p>又又是从上图得知，哈希的编码可以是 intset 或 hashtable：</p> 
<ul><li>intset：集合对象保存的所有元素都是整数值且元素数量小于 512 个 
  <ul><li>以上两个条件的上限值可以通过配置文件的 <code>set-max-intset-entries</code>修改</li></ul> </li><li>hashtable：不能满足上述条件，将从 intset 转成 hashtable</li></ul> 
<h4><a id="330__634"></a>3.3.0 区别</h4> 
<p>使用 <strong>SADD 命令</strong>可构建一个 intset 编码的 set 对象并保存数据：</p> 
<pre><code class="prism language-sql">redis<span class="token operator">&gt;</span> SADD numbers <span class="token number">1</span> <span class="token number">3</span> <span class="token number">5</span>
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">3</span>
</code></pre> 
<p>intset 编码的集合对象结构如下：</p> 
<p><img src="https://images2.imgbox.com/07/98/KjzdXKU6_o.png" alt="intset 编码的集合对象"></p> 
<p>使用 <strong>SADD 命令</strong>可构建一个 hashtable 编码的 set 对象并保存数据：</p> 
<pre><code class="prism language-sql">redis<span class="token operator">&gt;</span> SADD fruits <span class="token string">"apple"</span> <span class="token string">"banana"</span> <span class="token string">"cherry"</span>
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">3</span>
</code></pre> 
<p>hashtable 编码的 set 使用字典作为底层实现，每个键都是字符串对象，每个对象包含一个集合元素，<strong>字典值全部置为 null</strong> 。</p> 
<p>hashtable 编码的集合对象结构如下：</p> 
<p><img src="https://images2.imgbox.com/e8/fa/9wznIWO5_o.png" alt="hashtable 编码的集合对象"></p> 
<h3><a id="34_Sorted_Set_659"></a>3.4 有序集合（Sorted Set）对象</h3> 
<p>又又又是从上图得知，有序集合的编码可以是 ziplist 或 skiplist：</p> 
<ul><li>ziplist：保存的元素数量小于 128 个且所有元素长度都小于 64 字节 
  <ul><li>以上两个条件的上限值可以通过配置文件的 <code>zset-max-ziplist-entries</code>和<code>zset-max-ziplist-value</code>修改</li></ul> </li><li>skiplist：不能同时满足上述条件，将从 ziplist 转成 skiplist</li></ul> 
<h4><a id="340__667"></a>3.4.0 区别</h4> 
<p>使用 <strong>ZADD</strong> 命令可以构建一个 Sorted Set 对象并保存数据：</p> 
<pre><code class="prism language-sql">redis<span class="token operator">&gt;</span> ZADD price <span class="token number">8.5</span> apple <span class="token number">5.0</span> banana <span class="token number">6.0</span> cherry
<span class="token punctuation">(</span><span class="token keyword">integer</span><span class="token punctuation">)</span> <span class="token number">3</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/f5/e8/XTnxic0x_o.png" alt="ziplist 编码的 zset 对象"></p> 
<p>ziplist 编码实现的 Sorted Set 对象，每个集合元素使用两个相邻的节点保存，第一个节点是<strong>元素成员</strong>，第二个节点是<strong>元素分值</strong>。按分值<strong>从小到大</strong>进行排序，结构如下：</p> 
<p><img src="https://images2.imgbox.com/a0/75/0zp1YzqM_o.png" alt="压缩列表的具体实现"></p> 
<p>skiplist 编码实现的 Sorted Set 使用 <strong>zset</strong> 作为底层实现，它包含<strong>跳跃表</strong>和<strong>字典</strong>，源码如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> zset <span class="token punctuation">{<!-- --></span>
    zskpilist <span class="token operator">*</span>zsl<span class="token punctuation">;</span>
    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>
<span class="token punctuation">}</span>zset<span class="token punctuation">;</span>
</code></pre> 
<p>大体结构如下：</p> 
<p><img src="https://images2.imgbox.com/f4/3b/ki0s5u5W_o.png" alt="skiplist编码的有序集合对象"></p> 
<ul><li> <p>跳跃表 zsl 按分值从小到大保存所有集合元素；每个节点保存一个集合元素；object 属性保存元素成员、score 属性保存元素分值。目的：<strong>实现快速的范围查询操作</strong>。</p> </li><li> <p>字典 dict 创建一个从成员到分值的 key-value；字典中每个键值对都保存一个集合元素；键保存元素成员、值保存元素分值。目的：<strong>用 O(1) 复杂度 get 元素分值</strong>。</p> </li></ul> 
<p>最后，详细的结构如下所示：</p> 
<p><img src="https://images2.imgbox.com/2b/f9/SuXwvpbW_o.png" alt="有序集合元素同时被保存在字典和跳跃表中"></p> 
<p>听到这里有人可能有疑问：zset 结构同时使用<strong>跳跃表和字典</strong>来保存有序集合元素，不会重复吗？</p> 
<p>不会，因为二者会通过<strong>指针</strong>来共享同一个元素，并不会产生重复。</p> 
<p>为什么 skiplist 编码实现的有序集合要同时用跳跃表和字典实现？<strong>随便用一个行吗</strong>？</p> 
<p>答案是：不好。我们来看看两种情况：</p> 
<ul><li> <p>只用 dict ，可以保留以 O(1) 复杂度 get 成员分值；但<strong>字典是无序的</strong>，所以<strong>每次进行范围操作都要对所有元素排序</strong>；显然这是性能更低的。</p> </li><li> <p>只用跳跃表，快速范围操作得以保留；但是没了字典，get 成员分值的复杂度将提高至 O(logN)，这也影响性能。</p> </li></ul> 
<p>所以，Redis 为了把两者有点结合起来，采用了通过<strong>指针共享</strong>的方式，使用两种数据结构实现。</p> 
<h2><a id="04__717"></a>04 一些注意的点</h2> 
<h3><a id="40_Redis__719"></a>4.0 Redis 如何执行命令</h3> 
<p>Redis 执行命令前，会先检查<strong>值对象类型</strong>，判断<strong>键是否能执行该命令</strong>；再检查<strong>值对象的编码方式</strong>选择合适的命令执行。</p> 
<p>举个例子：列表对象有 ziplist 和 linkedlist 两种编码格式可用；前者通过 ziplist 的 API 执行命令、后者通过 linkedlist 的 API 执行命令。</p> 
<p>如果我们执行 LLEN 命令，Redis <strong>第一步判断执行的命令是不是针对列表的</strong>？是的话，第二步判断<strong>值的编码格式</strong>，如果是 ziplist，使用 <strong>ziplistLen 函数</strong>操作；如果是 linkedlist 则使用 <strong>listLength 函数</strong>操作。</p> 
<h3><a id="41_Redis__727"></a>4.1 Redis 内存回收机制与共享对象</h3> 
<p>Redis 为每个对象构建一个<strong>引用计数</strong>属性，通过它可实现<strong>内存回收机制</strong>（当一个对象的引用计数为 0 时，将会释放所占用内存）。</p> 
<p>Redis 会共享值为 <strong>0 到 9999 的字符串对象</strong>（这个值可能通过修改 redis.h 文件的 REDIS_SHARDED_INTEGER 常量修改）</p> 
<p>Redis 只共享字符串对象本身，<strong>为什么不共享包含字符串的对象</strong>？</p> 
<p>能共享的前提是<strong>目标对象和共享对象完全相同</strong>。要共享就需要验证两者是否相同？因为<strong>包含字符串的对象复杂度更高，验证消耗的 CPU 时间也更多</strong>，而性能将会下降。</p> 
<h3><a id="42_lru__737"></a>4.2 lru 属性的作用</h3> 
<p>redisObject 的 lru 属性<strong>记录对象最后一次被访问的时间</strong>，这个时间可以用于计算对象的空转时间（<strong>公式：当前时间 - lru 时间</strong>）。</p> 
<h2><a id="05__741"></a>05 巨人的肩膀</h2> 
<ul><li>《Redis 设计与实现》</li><li>redis 源码：github.com/antirez/redis</li><li>redis 源码中文注释版：github.com/huangz1990/redis-3.0-annotated</li><li>cnblogs.com/Java3y/p/9870829.html</li><li>time.geekbang.org/column/article/268253</li><li>http://www.fidding.me/article/108</li><li>segmentfault.com/a/1190000019980165</li><li>cnblogs.com/chenchen0618/p/13260202.html</li></ul> 
<h2><a id="06__752"></a>06 总结</h2> 
<p>本文从常用的缓存技术讲起，深入 Redis 的数据类型与底层数据结构。第一小节从 Redis 和缓存聊起；第二节站在源码角度跟你分析 Redis 的 6 种数据结构：SDS、链表、哈希表、跳跃表、整数集合以及压缩列表的特性；第三节着重和你分享 5 种数据类型和 6 中底层结构的对应关系；第四节则是画龙点睛地和你分享了 Redis 是怎么执行命令的？怎么释放内存等问题。</p> 
<p>全文将近 13330 字，38 张图，希望能帮到你。好啦，以上就是狗哥关于 Redis 基础的总结。感谢各技术社区大佬们的付出，尤其是极客时间，真的牛逼。如果说我看得更远，那是因为我站在你们的肩膀上。希望这篇文章对你有帮助，我们下篇文章见~</p> 
<h2><a id="07____758"></a>07 送点面试题 &amp; 电子书</h2> 
<p>如果看到这里，喜欢这篇文章的话，请帮点个<strong>好看</strong>。</p> 
<p>初次见面，也不知道送你们啥。干脆就送<strong>几百本电子书</strong>和<strong>2021最新面试资料</strong>吧。微信搜索<strong>一个优秀的废人</strong>回复<strong>电子书</strong>送你 1000+ 本编程电子书；回复<strong>面试</strong>送点面试题；回复<strong>1024</strong>送你一套完整的 java 视频教程。</p> 
<p>面试题都是有答案的，如下所示：有需要的就来拿吧，<strong>绝对免费，无套路获取</strong>。</p> 
<p><img src="https://images2.imgbox.com/55/d7/5wkR13sz_o.png" alt=""></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/673bb0dd924d0e0588cb2579efc7f705/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">详解GCN的性质</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ae257bc9e36cfa320a50502468d0bcb7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">流动粒子（flow01001）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>