<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java面试题及答案整理与下载（2021最新版） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java面试题及答案整理与下载（2021最新版）" />
<meta property="og:description" content="Java面试题及答案整理 一、Java 基础# 1. JDK 和 JRE 有什么区别？# JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。 具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。
2. == 和 equals 的区别是什么？# == 解读
对于基本类型和引用类型 == 的作用效果是不同的，如下所示：
基本类型：比较的是值是否相同；引用类型：比较的是引用是否相同； 代码示例：
Copy
String x = &#34;string&#34;; String y = &#34;string&#34;; String z = new String(&#34;string&#34;); System.out.println(x==y); // true System.out.println(x==z); // false System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/ce9b6c2f1fd54710d7990ad3661ed8cc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-16T15:19:41+08:00" />
<meta property="article:modified_time" content="2022-02-16T15:19:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java面试题及答案整理与下载（2021最新版）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="java面试题及答案整理">Java面试题及答案整理</h2> 
<h3 id="3774108866"><strong>一、Java 基础</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#3774108866" rel="nofollow" title="#">#</a></h3> 
<h4 id="2157425836"><strong>1. JDK 和 JRE 有什么区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#2157425836" rel="nofollow" title="#">#</a></h4> 
<ul><li>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。</li><li>JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。</li></ul> 
<p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。</p> 
<h4 id="2743950141"><strong>2. == 和 equals 的区别是什么？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#2743950141" rel="nofollow" title="#">#</a></h4> 
<p><strong>== 解读</strong></p> 
<p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p> 
<ul><li>基本类型：比较的是值是否相同；</li><li>引用类型：比较的是引用是否相同；</li></ul> 
<p>代码示例：</p> 
<pre></pre> 
<p>Copy</p> 
<p><code id="copy_target_0">String x = "string"; String y = "string"; String z = new String("string"); System.out.println(x==y); // true System.out.println(x==z); // false System.out.println(x.equals(y)); // true System.out.println(x.equals(z)); // true </code></p> 
<p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p> 
<p><strong>equals 解读</strong></p> 
<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p> 
<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p> 
<pre></pre> 
<p>Copy</p> 
<p><code id="copy_target_1">class Cat { public Cat(String name) { this.name = name; } private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } Cat c1 = new Cat("王磊"); Cat c2 = new Cat("王磊"); System.out.println(c1.equals(c2)); // false </code></p> 
<p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p> 
<pre></pre> 
<p>Copy</p> 
<p><code id="copy_target_2">public boolean equals(Object obj) { return (this == obj); } </code></p> 
<p>原来 equals 本质上就是 ==。</p> 
<p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p> 
<pre></pre> 
<p>Copy</p> 
<p><code id="copy_target_3">String s1 = new String("老王"); String s2 = new String("老王"); System.out.println(s1.equals(s2)); // true </code></p> 
<p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p> 
<pre></pre> 
<p>Copy</p> 
<p><code id="copy_target_4">public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; } </code></p> 
<p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p> 
<p><strong>总结</strong> ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p> 
<h4 id="2537714312"><strong>3. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#2537714312" rel="nofollow" title="#">#</a></h4> 
<p>不对，两个对象的 hashCode()相同，equals()不一定 true。</p> 
<p>代码示例：</p> 
<pre></pre> 
<p>Copy</p> 
<p><code id="copy_target_5">String str1 = "通话"; String str2 = "重地"; System.out.println(String.format("str1：%d | str2：%d", str1.hashCode(),str2.hashCode())); System.out.println(str1.equals(str2)); </code></p> 
<p>执行的结果：</p> 
<blockquote> 
 <p>str1：1179395 | str2：1179395<br> false</p> 
</blockquote> 
<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p> 
<h4 id="2461643549"><strong>4. final 在 java 中有什么作用？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#2461643549" rel="nofollow" title="#">#</a></h4> 
<ul><li>final 修饰的类叫最终类，该类不能被继承。</li><li>final 修饰的方法不能被重写。</li><li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li></ul> 
<h4 id="1063997739"><strong>5. java 中的 Math.round(-1.5) 等于多少？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1063997739" rel="nofollow" title="#">#</a></h4> 
<p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p> 
<h4 id="2567014516"><strong>6. String 属于基础的数据类型吗？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#2567014516" rel="nofollow" title="#">#</a></h4> 
<p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p> 
<h4 id="1001262620"><strong>7. java 中操作字符串都有哪些类？它们之间有什么区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1001262620" rel="nofollow" title="#">#</a></h4> 
<p>操作字符串的类有：String、StringBuffer、StringBuilder。</p> 
<p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p> 
<p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p> 
<h4 id="4160128675"><strong>8. String str="i"与 String str=new String("i")一样吗？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#4160128675" rel="nofollow" title="#">#</a></h4> 
<p>不一样，因为内存的分配方式不一样。String str="i"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String("i") 则会被分到堆内存中。</p> 
<h4 id="3316648602"><strong>9. 如何将字符串反转？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#3316648602" rel="nofollow" title="#">#</a></h4> 
<p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p> 
<p>示例代码：</p> 
<pre></pre> 
<p>Copy</p> 
<p><code id="copy_target_6">// StringBuffer reverse StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append("abcdefg"); System.out.println(stringBuffer.reverse()); // gfedcba // StringBuilder reverse StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append("abcdefg"); System.out.println(stringBuilder.reverse()); // gfedcba </code></p> 
<h4 id="1825799131"><strong>10. String 类的常用方法都有那些？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1825799131" rel="nofollow" title="#">#</a></h4> 
<ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字符。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li></ul> 
<h4 id="1324671560"><strong>11. 抽象类必须要有抽象方法吗？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1324671560" rel="nofollow" title="#">#</a></h4> 
<p>不需要，抽象类不一定非要有抽象方法。</p> 
<p>示例代码：</p> 
<pre></pre> 
<p>Copy</p> 
<p><code id="copy_target_7">abstract class Cat { public static void sayHi() { System.out.println("hi~"); } } </code></p> 
<p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p> 
<h4 id="2827988243"><strong>12. 普通类和抽象类有哪些区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#2827988243" rel="nofollow" title="#">#</a></h4> 
<ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul> 
<h4 id="954677006"><strong>13. 抽象类能使用 final 修饰吗？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#954677006" rel="nofollow" title="#">#</a></h4> 
<p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/56/f2/KMrsF3oC_o.png"></p> 
<h4 id="2646143123"><strong>14. 接口和抽象类有什么区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#2646143123" rel="nofollow" title="#">#</a></h4> 
<ul><li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li><li>构造函数：抽象类可以有构造函数；接口不能有。</li><li>main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。</li><li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li><li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li></ul> 
<h4 id="833374944"><strong>15. java 中 IO 流分为几种？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#833374944" rel="nofollow" title="#">#</a></h4> 
<p>按功能来分：输入流（input）、输出流（output）。</p> 
<p>按类型来分：字节流和字符流。</p> 
<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p> 
<h4 id="2912799826"><strong>16. BIO、NIO、AIO 有什么区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#2912799826" rel="nofollow" title="#">#</a></h4> 
<ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul> 
<h4 id="4204042623"><strong>17. Files的常用方法都有哪些？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#4204042623" rel="nofollow" title="#">#</a></h4> 
<ul><li>Files.exists()：检测文件路径是否存在。</li><li>Files.createFile()：创建文件。</li><li>Files.createDirectory()：创建文件夹。</li><li>Files.delete()：删除一个文件或目录。</li><li>Files.copy()：复制文件。</li><li>Files.move()：移动文件。</li><li>Files.size()：查看文件个数。</li><li>Files.read()：读取文件。</li><li>Files.write()：写入文件。</li></ul> 
<p>博主已将以下这些面试题整理成了一个Java面试手册，是PDF版的。</p> 
<p><a href="https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI1OTQ2MTk4MQ%3D%3D%26mid%3D100003082%26idx%3D1%26sn%3Dabc844cd8c333a2a1ada49c48e4e162d%26chksm%3D6a79cb385d0e422e81c966d1a674a2ba304656e03b5acbd87280d0c99b4e1e0ee68a5bdf0457%23rd" rel="nofollow" title="肝了一个月，终于完成了24万字的Java面试手册mp.weixin.qq.com">肝了一个月，终于完成了24万字的Java面试手册mp.weixin.qq.com</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/42/08/4bKpTS2J_o.png"></p> 
<p><strong>二、容器</strong></p> 
<h4 id="1868110045"><strong>18. java 容器都有哪些？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1868110045" rel="nofollow" title="#">#</a></h4> 
<p>常用容器的图录：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/28/48/Vxzg5rRF_o.png"></p> 
<h4 id="431607587"><strong>19. Collection 和 Collections 有什么区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#431607587" rel="nofollow" title="#">#</a></h4> 
<ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul> 
<h4 id="2071400860"><strong>20. List、Set、Map 之间的区别是什么？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#2071400860" rel="nofollow" title="#">#</a></h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/97/d7/5WFMWygh_o.png"></p> 
<h4 id="863634379"><strong>21. HashMap 和 Hashtable 有什么区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#863634379" rel="nofollow" title="#">#</a></h4> 
<ul><li>hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。</li><li>hashTable同步的，而HashMap是非同步的，效率上逼hashTable要高。</li><li>hashMap允许空键值，而hashTable不允许。</li></ul> 
<h4 id="1826158579"><strong>22. 如何决定使用 HashMap 还是 TreeMap？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1826158579" rel="nofollow" title="#">#</a></h4> 
<p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p> 
<h4 id="2164166158"><strong>23. 说一下 HashMap 的实现原理？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#2164166158" rel="nofollow" title="#">#</a></h4> 
<p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p> 
<p>HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p> 
<p>当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。</p> 
<p>需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)</p> 
<h4 id="1465479336"><strong>24. 说一下 HashSet 的实现原理？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1465479336" rel="nofollow" title="#">#</a></h4> 
<ul><li>HashSet底层由HashMap实现</li><li>HashSet的值存放于HashMap的key上</li><li>HashMap的value统一为PRESENT</li></ul> 
<h4 id="615186826"><strong>25. ArrayList 和 LinkedList 的区别是什么？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#615186826" rel="nofollow" title="#">#</a></h4> 
<p>最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。</p> 
<h4 id="674197658"><strong>26. 如何实现数组和 List 之间的转换？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#674197658" rel="nofollow" title="#">#</a></h4> 
<ul><li>List转换成为数组：调用ArrayList的toArray方法。</li><li>数组转换成为List：调用Arrays的asList方法。</li></ul> 
<h4 id="1098094098"><strong>27. ArrayList 和 Vector 的区别是什么？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1098094098" rel="nofollow" title="#">#</a></h4> 
<ul><li>Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。</li><li>ArrayList比Vector快，它因为有同步，不会过载。</li><li>ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</li></ul> 
<h4 id="3681830916"><strong>28. Array 和 ArrayList 有何区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#3681830916" rel="nofollow" title="#">#</a></h4> 
<ul><li>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</li><li>Array是指定大小的，而ArrayList大小是固定的。</li><li>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。</li></ul> 
<h4 id="3574686602"><strong>29. 在 Queue 中 poll()和 remove()有什么区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#3574686602" rel="nofollow" title="#">#</a></h4> 
<p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p> 
<h4 id="3457613012"><strong>30. 哪些集合类是线程安全的？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#3457613012" rel="nofollow" title="#">#</a></h4> 
<ul><li>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</li><li>statck：堆栈类，先进后出。</li><li>hashtable：就比hashmap多了个线程安全。</li><li>enumeration：枚举，相当于迭代器。</li></ul> 
<h4 id="3784547615"><strong>31. 迭代器 Iterator 是什么？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#3784547615" rel="nofollow" title="#">#</a></h4> 
<p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。</p> 
<h4 id="1578025896"><strong>32. Iterator 怎么使用？有什么特点？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1578025896" rel="nofollow" title="#">#</a></h4> 
<p>Java中的Iterator功能比较简单，并且只能单向移动：</p> 
<p>(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。</p> 
<p>(2) 使用next()获得序列中的下一个元素。</p> 
<p>(3) 使用hasNext()检查序列中是否还有元素。</p> 
<p>(4) 使用remove()将迭代器新返回的元素删除。</p> 
<p>Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</p> 
<h4 id="3072510319"><strong>33. Iterator 和 ListIterator 有什么区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#3072510319" rel="nofollow" title="#">#</a></h4> 
<ul><li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</li><li>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</li><li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</li></ul> 
<h4 id="1619545615">三、<strong>多线程</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1619545615" rel="nofollow" title="#">#</a></h4> 
<h4 id="3639250844"><strong>35. 并行和并发有什么区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#3639250844" rel="nofollow" title="#">#</a></h4> 
<ul><li>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li><li>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</li><li>在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。</li></ul> 
<p>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p> 
<h4 id="3265055302"><strong>36. 线程和进程的区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#3265055302" rel="nofollow" title="#">#</a></h4> 
<p>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</p> 
<h4 id="2175376468"><strong>37. 守护线程是什么？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#2175376468" rel="nofollow" title="#">#</a></h4> 
<p>守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。</p> 
<h4 id="3337624346"><strong>38. 创建线程有哪几种方式？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#3337624346" rel="nofollow" title="#">#</a></h4> 
<p>①. 继承Thread类创建线程类</p> 
<ul><li>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</li><li>创建Thread子类的实例，即创建了线程对象。</li><li>调用线程对象的start()方法来启动该线程。</li></ul> 
<p>②. 通过Runnable接口创建线程类</p> 
<ul><li>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li><li>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li><li>调用线程对象的start()方法来启动该线程。</li></ul> 
<p>③. 通过Callable和Future创建线程</p> 
<ul><li>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</li><li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</li><li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li><li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</li></ul> 
<h4 id="4283098288"><strong>39. 说一下 runnable 和 callable 有什么区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#4283098288" rel="nofollow" title="#">#</a></h4> 
<p>有点深的问题了，也看出一个Java程序员学习知识的广度。</p> 
<ul><li>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；</li><li>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</li></ul> 
<h4 id="1296638166"><strong>40. 线程有哪些状态？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1296638166" rel="nofollow" title="#">#</a></h4> 
<p>线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。</p> 
<ul><li>创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。</li><li>就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。</li><li>运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。</li><li>阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。</li><li>死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 　　</li></ul> 
<h4 id="571491262"><strong>41. sleep() 和 wait() 有什么区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#571491262" rel="nofollow" title="#">#</a></h4> 
<p>sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。</p> 
<p>wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。</p> 
<h4 id="3288575075"><strong>42. notify()和 notifyAll()有什么区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#3288575075" rel="nofollow" title="#">#</a></h4> 
<ul><li>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</li><li>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。</li><li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li></ul> 
<h4 id="1212359382"><strong>43. 线程的 run()和 start()有什么区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1212359382" rel="nofollow" title="#">#</a></h4> 
<p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。</p> 
<p>start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</p> 
<p>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p> 
<h4 id="942983167"><strong>44. 创建线程池有哪几种方式？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#942983167" rel="nofollow" title="#">#</a></h4> 
<p>①. newFixedThreadPool(int nThreads)</p> 
<p>创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</p> 
<p>②. newCachedThreadPool()</p> 
<p>创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。</p> 
<p>③. newSingleThreadExecutor()</p> 
<p>这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。</p> 
<p>④. newScheduledThreadPool(int corePoolSize)</p> 
<p>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。</p> 
<h4 id="2778499080"><strong>45. 线程池都有哪些状态？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#2778499080" rel="nofollow" title="#">#</a></h4> 
<p>线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。</p> 
<p>线程池各个状态切换框架图：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fa/0b/lfnu7xdM_o.png"></p> 
<h4 id="990564885"><strong>46. 线程池中 submit()和 execute()方法有什么区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#990564885" rel="nofollow" title="#">#</a></h4> 
<ul><li>接收的参数不一样</li><li>submit有返回值，而execute没有</li><li>submit方便Exception处理</li></ul> 
<p><strong>47. 在 java 程序中怎么保证多线程的运行安全？</strong></p> 
<p>线程安全在三个方面体现：</p> 
<ul><li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；</li><li>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；</li><li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</li></ul> 
<p><strong>48. 多线程锁的升级原理是什么？</strong></p> 
<p>在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。</p> 
<p>锁升级的图示过程：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c1/9a/EhLDn3XF_o.png"></p> 
<h4 id="4216568731"><strong>49. 什么是死锁？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#4216568731" rel="nofollow" title="#">#</a></h4> 
<p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。</p> 
<h4 id="2150452517"><strong>50. 怎么防止死锁？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#2150452517" rel="nofollow" title="#">#</a></h4> 
<p>死锁的四个必要条件：</p> 
<ul><li>互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</li><li>请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放</li><li>不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</li><li>环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系</li></ul> 
<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。</p> 
<p>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。</p> 
<p>所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。</p> 
<p>此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p> 
<h4 id="1783512648"><strong>51. ThreadLocal 是什么？有哪些使用场景？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1783512648" rel="nofollow" title="#">#</a></h4> 
<p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p> 
<h4 id="3281518556"><strong>52.说一下 synchronized 底层实现原理？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#3281518556" rel="nofollow" title="#">#</a></h4> 
<p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p> 
<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p> 
<ul><li>普通同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类的class对象</li><li>同步方法块，锁是括号里面的对象</li></ul> 
<h4 id="1176496002"><strong>53. synchronized 和 volatile 的区别是什么？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1176496002" rel="nofollow" title="#">#</a></h4> 
<ul><li>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li><li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。</li><li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</li><li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li><li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li></ul> 
<h4 id="149493497"><strong>54. synchronized 和 Lock 有什么区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#149493497" rel="nofollow" title="#">#</a></h4> 
<ul><li>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</li><li>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</li><li>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</li><li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</li><li>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；</li><li>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</li></ul> 
<h4 id="1811048512"><strong>55. synchronized 和 ReentrantLock 区别是什么？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1811048512" rel="nofollow" title="#">#</a></h4> 
<p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p> 
<ul><li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li><li>ReentrantLock可以获取各种锁的信息</li><li>ReentrantLock可以灵活地实现多路通知</li></ul> 
<p>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。</p> 
<h4 id="2060935665"><strong>56. 说一下 atomic 的原理？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#2060935665" rel="nofollow" title="#">#</a></h4> 
<p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。</p> 
<p>Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。</p> 
<p>四、反射</p> 
<h4 id="533314132"><strong>57. 什么是反射？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#533314132" rel="nofollow" title="#">#</a></h4> 
<p>反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力</p> 
<p>Java反射：</p> 
<p>在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法</p> 
<p>Java反射机制主要提供了以下功能：</p> 
<ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时调用任意一个对象的方法。</li></ul> 
<h4 id="1334679615"><strong>58. 什么是 java 序列化？什么情况下需要序列化？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1334679615" rel="nofollow" title="#">#</a></h4> 
<p>简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。</p> 
<p>什么情况下需要序列化：</p> 
<p>a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；<br> b）当你想用套接字在网络上传送对象的时候；<br> c）当你想通过RMI传输对象的时候；</p> 
<h4 id="2469810589"><strong>59. 动态代理是什么？有哪些应用？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#2469810589" rel="nofollow" title="#">#</a></h4> 
<p>动态代理：</p> 
<p>当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。</p> 
<p>动态代理的应用：</p> 
<ul><li>Spring的AOP</li><li>加事务</li><li>加权限</li><li>加日志</li></ul> 
<h4 id="1163536845"><strong>60. 怎么实现动态代理？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1163536845" rel="nofollow" title="#">#</a></h4> 
<p>首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。</p> 
<h3 id="503226001">五、<strong>对象拷贝</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#503226001" rel="nofollow" title="#">#</a></h3> 
<h4 id="2824194348"><strong>61. 为什么要使用克隆？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#2824194348" rel="nofollow" title="#">#</a></h4> 
<p>想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。</p> 
<h4 id="3310777440"><strong>62. 如何实现对象克隆？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#3310777440" rel="nofollow" title="#">#</a></h4> 
<p>有两种方式：</p> 
<p>1). 实现Cloneable接口并重写Object类中的clone()方法；</p> 
<p>2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下：</p> 
<pre></pre> 
<p>Copy</p> 
<p><code id="copy_target_8">import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; public class MyUtil { private MyUtil() { throw new AssertionError(); } @SuppressWarnings("unchecked") public static &lt;T extends Serializable&gt; T clone(T obj) throws Exception { ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bout); oos.writeObject(obj); ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bin); return (T) ois.readObject(); // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义 // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放 } } </code></p> 
<p>下面是测试代码：</p> 
<pre></pre> 
<p>Copy</p> 
<p><code id="copy_target_9">import java.io.Serializable; /** * 人类 * @author nnngu * */ class Person implements Serializable { private static final long serialVersionUID = -9102017020286042305L; private String name; // 姓名 private int age; // 年龄 private Car car; // 座驾 public Person(String name, int age, Car car) { this.name = name; this.age = age; this.car = car; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Car getCar() { return car; } public void setCar(Car car) { this.car = car; } @Override public String toString() { return "Person [name=" + name + ", age=" + age + ", car=" + car + "]"; } } </code></p> 
<pre></pre> 
<p>Copy</p> 
<p><code id="copy_target_10">/** * 小汽车类 * @author nnngu * */ class Car implements Serializable { private static final long serialVersionUID = -5713945027627603702L; private String brand; // 品牌 private int maxSpeed; // 最高时速 public Car(String brand, int maxSpeed) { this.brand = brand; this.maxSpeed = maxSpeed; } public String getBrand() { return brand; } public void setBrand(String brand) { this.brand = brand; } public int getMaxSpeed() { return maxSpeed; } public void setMaxSpeed(int maxSpeed) { this.maxSpeed = maxSpeed; } @Override public String toString() { return "Car [brand=" + brand + ", maxSpeed=" + maxSpeed + "]"; } } </code></p> 
<pre></pre> 
<p>Copy</p> 
<p><code id="copy_target_11">class CloneTest { public static void main(String[] args) { try { Person p1 = new Person("郭靖", 33, new Car("Benz", 300)); Person p2 = MyUtil.clone(p1); // 深度克隆 p2.getCar().setBrand("BYD"); // 修改克隆的Person对象p2关联的汽车对象的品牌属性 // 原来的Person对象p1关联的汽车不会受到任何影响 // 因为在克隆Person对象时其关联的汽车对象也被克隆了 System.out.println(p1); } catch (Exception e) { e.printStackTrace(); } } } </code></p> 
<p>注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。</p> 
<h4 id="52653543"><strong>63. 深拷贝和浅拷贝区别是什么？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#52653543" rel="nofollow" title="#">#</a></h4> 
<ul><li>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）</li><li>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）</li></ul> 
<h3 id="1206070195">六、<strong>Java Web</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1206070195" rel="nofollow" title="#">#</a></h3> 
<h4 id="3899416480"><strong>64. jsp 和 servlet 有什么区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#3899416480" rel="nofollow" title="#">#</a></h4> 
<ol><li>jsp经编译后就变成了Servlet.（JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码，Web容器将JSP的代码编译成JVM能够识别的java类）</li><li>jsp更擅长表现于页面显示，servlet更擅长于逻辑控制。</li><li>Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。</li><li>Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。</li></ol> 
<h4 id="3063570469"><strong>65. jsp 有哪些内置对象？作用分别是什么？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#3063570469" rel="nofollow" title="#">#</a></h4> 
<p>JSP有9个内置对象：</p> 
<ul><li>request：封装客户端的请求，其中包含来自GET或POST请求的参数；</li><li>response：封装服务器对客户端的响应；</li><li>pageContext：通过该对象可以获取其他对象；</li><li>session：封装用户会话的对象；</li><li>application：封装服务器运行环境的对象；</li><li>out：输出服务器响应的输出流对象；</li><li>config：Web应用的配置对象；</li><li>page：JSP页面本身（相当于Java程序中的this）；</li><li>exception：封装页面抛出异常的对象。</li></ul> 
<h4 id="3142083556"><strong>66. 说一下 jsp 的 4 种作用域？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#3142083556" rel="nofollow" title="#">#</a></h4> 
<p>JSP中的四种作用域包括page、request、session和application，具体来说：</p> 
<ul><li><strong>page</strong>代表与一个页面相关的对象和属性。</li><li><strong>request</strong>代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。</li><li><strong>session</strong>代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。</li><li><strong>application</strong>代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</li></ul> 
<h4 id="4128902893"><strong>67. session 和 cookie 有什么区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#4128902893" rel="nofollow" title="#">#</a></h4> 
<ul><li>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。</li><li>思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</li><li>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</li></ul> 
<h4 id="4116396702"><strong>68. 说一下 session 的工作原理？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#4116396702" rel="nofollow" title="#">#</a></h4> 
<p>其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了。</p> 
<h4 id="3201950338"><strong>69. 如果客户端禁止 cookie 能实现 session 还能用吗？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#3201950338" rel="nofollow" title="#">#</a></h4> 
<p>Cookie与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。</p> 
<p>假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：</p> 
<ol><li>设置php.ini配置文件中的“session.use_trans_sid = 1”，或者编译时打开打开了“--enable-trans-sid”选项，让PHP自动跨页传递Session ID。</li><li>手动通过URL传值、隐藏表单传递Session ID。</li><li>用文件、数据库等形式保存Session ID，在跨页过程中手动调用。</li></ol> 
<h4 id="4017041354"><strong>70. spring mvc 和 struts 的区别是什么？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#4017041354" rel="nofollow" title="#">#</a></h4> 
<ul><li>拦截机制的不同</li></ul> 
<p>Struts2是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype，然后通过setter，getter吧request数据注入到属性。Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。</p> 
<p>SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。</p> 
<p>Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。</p> 
<ul><li>底层框架的不同</li></ul> 
<p>Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。Filter在容器启动之后即初始化；服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。</p> 
<ul><li>性能方面</li></ul> 
<p>Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。</p> 
<ul><li>配置方面</li></ul> 
<p>spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。</p> 
<h4 id="219771335"><strong>71. 如何避免 sql 注入？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#219771335" rel="nofollow" title="#">#</a></h4> 
<ol><li>PreparedStatement（简单又有效的方法）</li><li>使用正则表达式过滤传入的参数</li><li>字符串过滤</li><li>JSP中调用该函数检查是否包函非法字符</li><li>JSP页面判断代码</li></ol> 
<h4 id="2164245507"><strong>72. 什么是 XSS 攻击，如何避免？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#2164245507" rel="nofollow" title="#">#</a></h4> 
<p>XSS攻击又称CSS,全称Cross Site Script （跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。XSS 攻击类似于 SQL 注入攻击，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息。 XSS是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式。</p> 
<p>XSS防范的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码。</p> 
<h4 id="1775606385"><strong>73. 什么是 CSRF 攻击，如何避免？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1775606385" rel="nofollow" title="#">#</a></h4> 
<p>CSRF（Cross-site request forgery）也被称为 one-click attack或者 session riding，中文全称是叫<strong>跨站请求伪造</strong>。一般来说，攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。常用于盗取账号、转账、发送虚假消息等。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为。</p> 
<p>如何避免：</p> 
<p>\1. 验证 HTTP Referer 字段</p> 
<blockquote> 
 <p>HTTP头中的Referer字段记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF<br> 攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证Referer值来防御CSRF 攻击。</p> 
</blockquote> 
<p>\2. 使用验证码</p> 
<blockquote> 
 <p>关键操作页面加上验证码，后台收到请求后通过判断验证码可以防御CSRF。但这种方法对用户不太友好。</p> 
</blockquote> 
<p>\3. 在请求地址中添加token并验证</p> 
<blockquote> 
 <p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于session之中，然后在每次请求时把token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。<br> 对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href="https://link.zhihu.com/?target=http%3A//url" rel="nofollow" title="http://url">http://url</a>?csrftoken=tokenvalue。<br> 而对于 POST 请求来说，要在 form 的最后加上 ，这样就把token以参数的形式加入请求了。</p> 
</blockquote> 
<p>\4. 在HTTP 头中自定义属性并验证</p> 
<blockquote> 
 <p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p> 
</blockquote> 
<p><strong>七、异常</strong></p> 
<h4 id="2117396984"><strong>74. throw 和 throws 的区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#2117396984" rel="nofollow" title="#">#</a></h4> 
<p>throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。</p> 
<h4 id="4273649571"><strong>75. final、finally、finalize 有什么区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#4273649571" rel="nofollow" title="#">#</a></h4> 
<ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li><li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。</li></ul> 
<h4 id="120706571"><strong>76. try-catch-finally 中哪个部分可以省略？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#120706571" rel="nofollow" title="#">#</a></h4> 
<p>答：catch 可以省略</p> 
<p><strong>原因：</strong></p> 
<p>更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。</p> 
<p>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。</p> 
<p>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</p> 
<h4 id="2525277495"><strong>77. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#2525277495" rel="nofollow" title="#">#</a></h4> 
<p>答：会执行，在 return 前执行。</p> 
<p><strong>代码示例1：</strong></p> 
<pre></pre> 
<p>Copy</p> 
<p><code id="copy_target_12">/* * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？ */ public class FinallyDemo2 { public static void main(String[] args) { System.out.println(getInt()); } public static int getInt() { int a = 10; try { System.out.println(a / 0); a = 20; } catch (ArithmeticException e) { a = 30; return a; /* * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了 * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40 * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30 */ } finally { a = 40; } // return a; } } </code></p> 
<p>执行结果：30</p> 
<p><strong>代码示例2：</strong></p> 
<pre></pre> 
<p>Copy</p> 
<p><code id="copy_target_13">package com.java_02; /* * java面试题--如果catch里面有return语句，finally里面的代码还会执行吗？ */ public class FinallyDemo2 { public static void main(String[] args) { System.out.println(getInt()); } public static int getInt() { int a = 10; try { System.out.println(a / 0); a = 20; } catch (ArithmeticException e) { a = 30; return a; /* * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了 * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40 * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30 */ } finally { a = 40; return a; //如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40 } // return a; } } </code></p> 
<p>执行结果：40</p> 
<h4 id="1205839344"><strong>78. 常见的异常类有哪些？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1205839344" rel="nofollow" title="#">#</a></h4> 
<ul><li>NullPointerException：当应用程序试图访问空对象时，则抛出该异常。</li><li>SQLException：提供关于数据库访问错误或其他错误信息的异常。</li><li>IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</li><li>NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</li><li>FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。</li><li>IOException：当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。</li><li>ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。</li><li>ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常。</li><li>IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。</li><li>ArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。</li><li>NegativeArraySizeException：如果应用程序试图创建大小为负的数组，则抛出该异常。</li><li>NoSuchMethodException：无法找到某一特定方法时，抛出该异常。</li><li>SecurityException：由安全管理器抛出的异常，指示存在安全侵犯。</li><li>UnsupportedOperationException：当不支持请求的操作时，抛出该异常。</li><li>RuntimeExceptionRuntimeException：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。</li></ul> 
<p>八、<strong>网络</strong></p> 
<h4 id="379118533"><strong>79. http 响应码 301 和 302 代表的是什么？有什么区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#379118533" rel="nofollow" title="#">#</a></h4> 
<p>答：301，302 都是HTTP状态的编码，都代表着某个URL发生了转移。</p> 
<p><strong>区别：</strong></p> 
<ul><li>301 redirect: 301 代表永久性转移(Permanently Moved)。</li><li>302 redirect: 302 代表暂时性转移(Temporarily Moved )。</li></ul> 
<h4 id="513863701"><strong>80. forward 和 redirect 的区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#513863701" rel="nofollow" title="#">#</a></h4> 
<p>Forward和Redirect代表了两种请求转发方式：直接转发和间接转发。</p> 
<p><strong>直接转发方式（Forward）</strong>，客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。</p> 
<p><strong>间接转发方式（Redirect）</strong>实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。</p> 
<p><strong>举个通俗的例子：</strong></p> 
<p>直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；</p> 
<p>间接转发就相当于："A找B借钱，B说没有，让A去找C借"。</p> 
<h4 id="1410388195"><strong>81. 简述 tcp 和 udp的区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#1410388195" rel="nofollow" title="#">#</a></h4> 
<ul><li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。</li><li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。</li><li>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li><li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li><li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。</li><li>TCP对系统资源要求较多，UDP对系统资源要求较少。</li></ul> 
<h4 id="2401208458"><strong>82. tcp 为什么要三次握手，两次不行吗？为什么？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#2401208458" rel="nofollow" title="#">#</a></h4> 
<p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。</p> 
<p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。</p> 
<p><strong>83. 说一下 tcp 粘包是怎么产生的？</strong></p> 
<p><strong>①. 发送方产生粘包</strong></p> 
<p>采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；但当发送的数据包过于的小时，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/53/2d/nmeHOHuR_o.png"></p> 
<p><strong>②. 接收方产生粘包</strong></p> 
<p>接收方采用TCP协议接收数据时的过程是这样的：数据到底接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度）</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4f/cb/jJOfjHgO_o.png"></p> 
<h4 id="974155444"><strong>84. OSI 的七层模型都有哪些？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#974155444" rel="nofollow" title="#">#</a></h4> 
<ol><li>应用层：网络服务与最终用户的一个接口。</li><li>表示层：数据的表示、安全、压缩。</li><li>会话层：建立、管理、终止会话。</li><li>传输层：定义传输数据的协议端口号，以及流控和差错校验。</li><li>网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。</li><li>数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。</li><li>物理层：建立、维护、断开物理连接。</li></ol> 
<h4 id="362040030"><strong>85. get 和 post 请求有哪些区别？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#362040030" rel="nofollow" title="#">#</a></h4> 
<ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ul> 
<h4 id="3417361511"><strong>86. 如何实现跨域？</strong><a href="https://www.cnblogs.com/wobushitiegan/p/14761737.html#3417361511" rel="nofollow" title="#">#</a></h4> 
<p><strong>方式一：图片ping或script标签跨域</strong></p> 
<p><strong>图片ping</strong>常用于跟踪用户点击页面或动态广告曝光次数。<br><strong>script标签</strong>可以得到从其他来源数据，这也是JSONP依赖的根据。</p> 
<p><strong>方式二：JSONP跨域</strong></p> 
<p>JSONP（JSON with Padding）是数据格式JSON的一种“使用模式”，可以让网页从别的网域要数据。根据 XmlHttpRequest 对象受到同源策略的影响，而利用</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/51bd06ab80f7649e094936aa5edf6192/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">(亲测)java.lang.ClassNotFoundException: javax.servlet.jsp.jstl.core.LoopTag</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf0dd1dc390d68e71215ccccb575c74e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">详解二叉树经典基础算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>