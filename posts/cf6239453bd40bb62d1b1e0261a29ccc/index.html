<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>互联网加竞赛 基于CNN实现谣言检测 - python 深度学习 机器学习 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="互联网加竞赛 基于CNN实现谣言检测 - python 深度学习 机器学习" />
<meta property="og:description" content="文章目录 1 前言1.1 背景 2 数据集3 实现过程4 CNN网络实现5 模型训练部分6 模型评估7 预测结果8 最后 1 前言 🔥 优质竞赛项目系列，今天要分享的是
基于CNN实现谣言检测
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1.1 背景 社交媒体的发展在加速信息传播的同时，也带来了虚假谣言信息的泛滥，往往会引发诸多不安定因素，并对经济和社会产生巨大的影响。
2 数据集 本项目所使用的数据是从新浪微博不实信息举报平台抓取的中文谣言数据，数据集中共包含1538条谣言和1849条非谣言。
如下图所示，每条数据均为json格式，其中text字段代表微博原文的文字内容。
每个文件夹里又有很多新闻文本。
每个文本又是json格式，具体内容如下：
3 实现过程 步骤入下：
*（1）解压数据，读取并解析数据，生成all_data.txt
*（2）生成数据字典，即dict.txt
*（3）生成数据列表，并进行训练集与验证集的划分，train_list.txt 、eval_list.txt
*（4）定义训练数据集提供器train_reader和验证数据集提供器eval_reader
import zipfile import os import io import random import json import matplotlib.pyplot as plt import numpy as np import paddle import paddle.fluid as fluid from paddle.fluid.dygraph.nn import Conv2D, Linear, Embedding from paddle." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/cf6239453bd40bb62d1b1e0261a29ccc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-29T15:29:14+08:00" />
<meta property="article:modified_time" content="2023-12-29T15:29:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">互联网加竞赛 基于CNN实现谣言检测 - python 深度学习 机器学习</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1__3" rel="nofollow">1 前言</a></li><li><ul><li><a href="#11__15" rel="nofollow">1.1 背景</a></li></ul> 
  </li><li><a href="#2__19" rel="nofollow">2 数据集</a></li><li><a href="#3__34" rel="nofollow">3 实现过程</a></li><li><a href="#4_CNN_254" rel="nofollow">4 CNN网络实现</a></li><li><a href="#5__362" rel="nofollow">5 模型训练部分</a></li><li><a href="#6__425" rel="nofollow">6 模型评估</a></li><li><a href="#7__469" rel="nofollow">7 预测结果</a></li><li><a href="#8__510" rel="nofollow">8 最后</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1__3"></a>1 前言</h2> 
<p>🔥 优质竞赛项目系列，今天要分享的是</p> 
<p><strong>基于CNN实现谣言检测</strong></p> 
<p>该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！</p> 
<p>🧿 <strong>更多资料, 项目分享：</strong></p> 
<p><a href="https://gitee.com/dancheng-senior/postgraduate" rel="nofollow">https://gitee.com/dancheng-senior/postgraduate</a></p> 
<h3><a id="11__15"></a>1.1 背景</h3> 
<p>社交媒体的发展在加速信息传播的同时，也带来了虚假谣言信息的泛滥，往往会引发诸多不安定因素，并对经济和社会产生巨大的影响。</p> 
<h2><a id="2__19"></a>2 数据集</h2> 
<p>本项目所使用的数据是从新浪微博不实信息举报平台抓取的中文谣言数据，数据集中共包含1538条谣言和1849条非谣言。</p> 
<p>如下图所示，每条数据均为json格式，其中text字段代表微博原文的文字内容。</p> 
<p><img src="https://images2.imgbox.com/c3/49/oqV4YlcY_o.png" alt="在这里插入图片描述"></p> 
<p>每个文件夹里又有很多新闻文本。</p> 
<p><img src="https://images2.imgbox.com/31/1f/FxWsgIIK_o.png" alt="在这里插入图片描述"><br> 每个文本又是json格式，具体内容如下：</p> 
<p><img src="https://images2.imgbox.com/84/06/PlW1K6KY_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="3__34"></a>3 实现过程</h2> 
<p>步骤入下：</p> 
<p>*（1）解压数据，读取并解析数据，生成all_data.txt<br> *（2）生成数据字典，即dict.txt<br> *（3）生成数据列表，并进行训练集与验证集的划分，train_list.txt 、eval_list.txt<br> *（4）定义训练数据集提供器train_reader和验证数据集提供器eval_reader</p> 
<pre><code>import zipfile
import os
import io
import random
import json
import matplotlib.pyplot as plt
import numpy as np
import paddle
import paddle.fluid as fluid
from paddle.fluid.dygraph.nn import Conv2D, Linear, Embedding
from paddle.fluid.dygraph.base import to_variable

#解压原始数据集，将Rumor_Dataset.zip解压至data目录下
src_path="/home/aistudio/data/data36807/Rumor_Dataset.zip" #这里填写自己项目所在的数据集路径
target_path="/home/aistudio/data/Chinese_Rumor_Dataset-master"
if(not os.path.isdir(target_path)):
    z = zipfile.ZipFile(src_path, 'r')
    z.extractall(path=target_path)
    z.close()

#分别为谣言数据、非谣言数据、全部数据的文件路径
rumor_class_dirs = os.listdir(target_path+"非开源数据集") # 这里填写自己项目所在的数据集路径
non_rumor_class_dirs = os.listdir(target_path+"非开源数据集")
original_microblog = target_path+"非开源数据集"
#谣言标签为0，非谣言标签为1
rumor_label="0"
non_rumor_label="1"

#分别统计谣言数据与非谣言数据的总数
rumor_num = 0
non_rumor_num = 0
all_rumor_list = []
all_non_rumor_list = []

#解析谣言数据
for rumor_class_dir in rumor_class_dirs: 
    if(rumor_class_dir != '.DS_Store'):
        #遍历谣言数据，并解析
        with open(original_microblog + rumor_class_dir, 'r') as f:
            rumor_content = f.read()
        rumor_dict = json.loads(rumor_content)
        all_rumor_list.append(rumor_label+"\t"+rumor_dict["text"]+"\n")
        rumor_num +=1
#解析非谣言数据
for non_rumor_class_dir in non_rumor_class_dirs: 
    if(non_rumor_class_dir != '.DS_Store'):
        with open(original_microblog + non_rumor_class_dir, 'r') as f2:
            non_rumor_content = f2.read()
        non_rumor_dict = json.loads(non_rumor_content)
        all_non_rumor_list.append(non_rumor_label+"\t"+non_rumor_dict["text"]+"\n")
        non_rumor_num +=1
        
print("谣言数据总量为："+str(rumor_num))
print("非谣言数据总量为："+str(non_rumor_num))

#全部数据进行乱序后写入all_data.txt
data_list_path="/home/aistudio/data/"
all_data_path=data_list_path + "all_data.txt"
all_data_list = all_rumor_list + all_non_rumor_list

random.shuffle(all_data_list)

#在生成all_data.txt之前，首先将其清空
with open(all_data_path, 'w') as f:
    f.seek(0)
    f.truncate() 
    
with open(all_data_path, 'a') as f:
    for data in all_data_list:
        f.write(data) 
print('all_data.txt已生成')
</code></pre> 
<p>​</p> 
<p><img src="https://images2.imgbox.com/57/9f/Fug9o0eh_o.png" alt="在这里插入图片描述"></p> 
<p><strong>接下来就是生成数据字典。</strong></p> 
<p>​<br> # 生成数据字典<br> def create_dict(data_path, dict_path):<br> with open(dict_path, ‘w’) as f:<br> f.seek(0)<br> f.truncate()</p> 
<pre><code>    dict_set = set()
    # 读取全部数据
    with open(data_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    # 把数据生成一个元组
    for line in lines:
        content = line.split('\t')[-1].replace('\n', '')
        for s in content:
            dict_set.add(s)
    # 把元组转换成字典，一个字对应一个数字
    dict_list = []
    i = 0
    for s in dict_set:
        dict_list.append([s, i])
        i += 1
    # 添加未知字符
    dict_txt = dict(dict_list)
    end_dict = {"": i}
    dict_txt.update(end_dict)
    # 把这些字典保存到本地中
    with open(dict_path, 'w', encoding='utf-8') as f:
        f.write(str(dict_txt))
    print("数据字典生成完成！",'\t','字典长度为：',len(dict_list))
</code></pre> 
<p>我们可以查看一下dict_txt的内容</p> 
<p><img src="https://images2.imgbox.com/d5/d9/AqPYeRnV_o.png" alt="在这里插入图片描述"></p> 
<p>接下来就是数据列表的生成</p> 
<p>​<br> # 创建序列化表示的数据,并按照一定比例划分训练数据与验证数据<br> def create_data_list(data_list_path):</p> 
<pre><code>    with open(os.path.join(data_list_path, 'dict.txt'), 'r', encoding='utf-8') as f_data:
        dict_txt = eval(f_data.readlines()[0])

    with open(os.path.join(data_list_path, 'all_data.txt'), 'r', encoding='utf-8') as f_data:
        lines = f_data.readlines()
    
    i = 0
    with open(os.path.join(data_list_path, 'eval_list.txt'), 'a', encoding='utf-8') as f_eval,\
    open(os.path.join(data_list_path, 'train_list.txt'), 'a', encoding='utf-8') as f_train:
        for line in lines:
            title = line.split('\t')[-1].replace('\n', '')
            lab = line.split('\t')[0]
            t_ids = ""
            if i % 8 == 0:
                for s in title:
                    temp = str(dict_txt[s])
                    t_ids = t_ids + temp + ','
                t_ids = t_ids[:-1] + '\t' + lab + '\n'
                f_eval.write(t_ids)
            else:
                for s in title:
                    temp = str(dict_txt[s])
                    t_ids = t_ids + temp + ','
                t_ids = t_ids[:-1] + '\t' + lab + '\n'
                f_train.write(t_ids)
            i += 1
        
    print("数据列表生成完成！")
</code></pre> 
<p><strong>定义数据读取器</strong></p> 
<p>​<br> def data_reader(file_path, phrase, shuffle=False):<br> all_data = []<br> with io.open(file_path, “r”, encoding=‘utf8’) as fin:<br> for line in fin:<br> cols = line.strip().split(“\t”)<br> if len(cols) != 2:<br> continue<br> label = int(cols[1])</p> 
<pre><code>            wids = cols[0].split(",")
            all_data.append((wids, label))

    if shuffle:
        if phrase == "train":
            random.shuffle(all_data)

    def reader():
        for doc, label in all_data:
            yield doc, label
    return reader

class SentaProcessor(object):
    def __init__(self, data_dir,):
        self.data_dir = data_dir
        
    def get_train_data(self, data_dir, shuffle):
        return data_reader((self.data_dir + "train_list.txt"), 
                            "train", shuffle)

    def get_eval_data(self, data_dir, shuffle):
        return data_reader((self.data_dir + "eval_list.txt"), 
                            "eval", shuffle)

    def data_generator(self, batch_size, phase='train', shuffle=True):
        if phase == "train":
            return paddle.batch(
                self.get_train_data(self.data_dir, shuffle),
                batch_size,
                drop_last=True)
        elif phase == "eval":
            return paddle.batch(
                self.get_eval_data(self.data_dir, shuffle),
                batch_size,
                drop_last=True)
        else:
            raise ValueError(
                "Unknown phase, which should be in ['train', 'eval']")
</code></pre> 
<p>总之在数据处理这一块需要我们注意的是一共生成以下的几个文件。</p> 
<p><img src="https://images2.imgbox.com/06/fc/0qhuAHkL_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="4_CNN_254"></a>4 CNN网络实现</h2> 
<p>接下来就是构建以及配置卷积神经网络(Convolutional Neural Networks,<br> CNN)，开篇也说了，其实这里有很多模型的选择，之所以选择CNN是因为让我们熟悉CNN的相关实现。 输入词向量序列，产生一个特征图（feature<br> map），对特征图采用时间维度上的最大池化（max pooling over<br> time）操作得到此卷积核对应的整句话的特征，最后，将所有卷积核得到的特征拼接起来即为文本的定长向量表示，对于文本分类问题，将其连接至softmax即构建出完整的模型。在实际应用中，我们会使用多个卷积核来处理句子，窗口大小相同的卷积核堆叠起来形成一个矩阵，这样可以更高效的完成运算。另外，我们也可使用窗口大小不同的卷积核来处理句子。具体的流程如下：</p> 
<p><img src="https://images2.imgbox.com/29/c6/NKj0JTnu_o.png" alt="在这里插入图片描述"><br> 首先我们构建单层CNN神经网络。</p> 
<p>​</p> 
<pre><code class="prism language-python">

    <span class="token comment">#单层</span>
    <span class="token keyword">class</span> <span class="token class-name">SimpleConvPool</span><span class="token punctuation">(</span>fluid<span class="token punctuation">.</span>dygraph<span class="token punctuation">.</span>Layer<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>
                     num_channels<span class="token punctuation">,</span> <span class="token comment"># 通道数</span>
                     num_filters<span class="token punctuation">,</span>  <span class="token comment"># 卷积核数量</span>
                     filter_size<span class="token punctuation">,</span>  <span class="token comment"># 卷积核大小</span>
                     batch_size<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 16</span>
            <span class="token builtin">super</span><span class="token punctuation">(</span>SimpleConvPool<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>batch_size <span class="token operator">=</span> batch_size
            self<span class="token punctuation">.</span>_conv2d <span class="token operator">=</span> Conv2D<span class="token punctuation">(</span>num_channels <span class="token operator">=</span> num_channels<span class="token punctuation">,</span>
                num_filters <span class="token operator">=</span> num_filters<span class="token punctuation">,</span>
                filter_size <span class="token operator">=</span> filter_size<span class="token punctuation">,</span>
                act<span class="token operator">=</span><span class="token string">'tanh'</span><span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>_pool2d <span class="token operator">=</span> fluid<span class="token punctuation">.</span>dygraph<span class="token punctuation">.</span>Pool2D<span class="token punctuation">(</span>
                pool_size <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">150</span> <span class="token operator">-</span> filter_size<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                pool_type <span class="token operator">=</span> <span class="token string">'max'</span><span class="token punctuation">,</span>
                pool_stride<span class="token operator">=</span><span class="token number">1</span>
            <span class="token punctuation">)</span>
    
        <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># print('SimpleConvPool_inputs数据纬度',inputs.shape) # [16, 1, 148, 128]</span>
            x <span class="token operator">=</span> self<span class="token punctuation">.</span>_conv2d<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>
            x <span class="token operator">=</span> self<span class="token punctuation">.</span>_pool2d<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
            x <span class="token operator">=</span> fluid<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>x<span class="token punctuation">,</span> shape<span class="token operator">=</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>batch_size<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> x



    <span class="token keyword">class</span> <span class="token class-name">CNN</span><span class="token punctuation">(</span>fluid<span class="token punctuation">.</span>dygraph<span class="token punctuation">.</span>Layer<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token builtin">super</span><span class="token punctuation">(</span>CNN<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>dict_dim <span class="token operator">=</span> train_parameters<span class="token punctuation">[</span><span class="token string">"vocab_size"</span><span class="token punctuation">]</span>
            self<span class="token punctuation">.</span>emb_dim <span class="token operator">=</span> <span class="token number">128</span>   <span class="token comment">#emb纬度</span>
            self<span class="token punctuation">.</span>hid_dim <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span>  <span class="token comment">#卷积核数量</span>
            self<span class="token punctuation">.</span>fc_hid_dim <span class="token operator">=</span> <span class="token number">96</span>  <span class="token comment">#fc参数纬度</span>
            self<span class="token punctuation">.</span>class_dim <span class="token operator">=</span> <span class="token number">2</span>    <span class="token comment">#分类数</span>
            self<span class="token punctuation">.</span>channels <span class="token operator">=</span> <span class="token number">1</span>     <span class="token comment">#输入通道数</span>
            self<span class="token punctuation">.</span>win_size <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment"># 卷积核尺寸</span>
            self<span class="token punctuation">.</span>batch_size <span class="token operator">=</span> train_parameters<span class="token punctuation">[</span><span class="token string">"batch_size"</span><span class="token punctuation">]</span> 
            self<span class="token punctuation">.</span>seq_len <span class="token operator">=</span> train_parameters<span class="token punctuation">[</span><span class="token string">"padding_size"</span><span class="token punctuation">]</span>
            self<span class="token punctuation">.</span>embedding <span class="token operator">=</span> Embedding<span class="token punctuation">(</span> 
                size<span class="token operator">=</span><span class="token punctuation">[</span>self<span class="token punctuation">.</span>dict_dim <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>emb_dim<span class="token punctuation">]</span><span class="token punctuation">,</span>
                dtype<span class="token operator">=</span><span class="token string">'float32'</span><span class="token punctuation">,</span> 
                is_sparse<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>_simple_conv_pool_1 <span class="token operator">=</span> SimpleConvPool<span class="token punctuation">(</span>
                self<span class="token punctuation">.</span>channels<span class="token punctuation">,</span>
                self<span class="token punctuation">.</span>hid_dim<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                self<span class="token punctuation">.</span>win_size<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                batch_size<span class="token operator">=</span>self<span class="token punctuation">.</span>batch_size<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>_fc1 <span class="token operator">=</span> Linear<span class="token punctuation">(</span>input_dim <span class="token operator">=</span> self<span class="token punctuation">.</span>hid_dim<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                                output_dim <span class="token operator">=</span> self<span class="token punctuation">.</span>fc_hid_dim<span class="token punctuation">,</span>
                                act<span class="token operator">=</span><span class="token string">"tanh"</span><span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>_fc_prediction <span class="token operator">=</span> Linear<span class="token punctuation">(</span>input_dim <span class="token operator">=</span> self<span class="token punctuation">.</span>fc_hid_dim<span class="token punctuation">,</span>
                                        output_dim <span class="token operator">=</span> self<span class="token punctuation">.</span>class_dim<span class="token punctuation">,</span>
                                        act<span class="token operator">=</span><span class="token string">"softmax"</span><span class="token punctuation">)</span>
    
        <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    
            emb <span class="token operator">=</span> self<span class="token punctuation">.</span>embedding<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span> <span class="token comment"># [2400, 128]</span>
            <span class="token comment"># print('CNN_emb',emb.shape)  </span>
            emb <span class="token operator">=</span> fluid<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>   <span class="token comment"># [16, 1, 150, 128]</span>
                emb<span class="token punctuation">,</span> shape<span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>channels <span class="token punctuation">,</span> self<span class="token punctuation">.</span>seq_len<span class="token punctuation">,</span> self<span class="token punctuation">.</span>emb_dim<span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token comment"># print('CNN_emb',emb.shape)</span>
            conv_3 <span class="token operator">=</span> self<span class="token punctuation">.</span>_simple_conv_pool_1<span class="token punctuation">(</span>emb<span class="token punctuation">)</span>
            fc_1 <span class="token operator">=</span> self<span class="token punctuation">.</span>_fc1<span class="token punctuation">(</span>conv_3<span class="token punctuation">)</span>
            prediction <span class="token operator">=</span> self<span class="token punctuation">.</span>_fc_prediction<span class="token punctuation">(</span>fc_1<span class="token punctuation">)</span>
            <span class="token keyword">if</span> label <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
                acc <span class="token operator">=</span> fluid<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>accuracy<span class="token punctuation">(</span>prediction<span class="token punctuation">,</span> label<span class="token operator">=</span>label<span class="token punctuation">)</span>
                <span class="token keyword">return</span> prediction<span class="token punctuation">,</span> acc
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> prediction



</code></pre> 
<p>接下来就是参数的配置，不过为了在模型训练过程中更直观的查看我们训练的准确率，我们首先利用python的matplotlib.pyplt函数实现一个可视化图，具体的实现如下：</p> 
<p>​<br> def draw_train_process(iters, train_loss, train_accs):<br> title=“training loss/training accs”<br> plt.title(title, fontsize=24)<br> plt.xlabel(“iter”, fontsize=14)<br> plt.ylabel(“loss/acc”, fontsize=14)<br> plt.plot(iters, train_loss, color=‘red’, label=‘training loss’)<br> plt.plot(iters, train_accs, color=‘green’, label=‘training accs’)<br> plt.legend()<br> plt.grid()<br> plt.show()</p> 
<h2><a id="5__362"></a>5 模型训练部分</h2> 
<p>​<br> def train():<br> with fluid.dygraph.guard(place = fluid.CUDAPlace(0)): # 因为要进行很大规模的训练，因此我们用的是GPU，如果没有安装GPU的可以使用下面一句，把这句代码注释掉即可<br> # with fluid.dygraph.guard(place = fluid.CPUPlace()):</p> 
<pre><code>        processor = SentaProcessor( data_dir="data/")
    
        train_data_generator = processor.data_generator(
            batch_size=train_parameters["batch_size"],
            phase='train',
            shuffle=True)
            
        model = CNN()
        sgd_optimizer = fluid.optimizer.Adagrad(learning_rate=train_parameters["adam"],parameter_list=model.parameters())
        steps = 0
        Iters,total_loss, total_acc = [], [], []
        for eop in range(train_parameters["epoch"]):
            for batch_id, data in enumerate(train_data_generator()):
                steps += 1
                #转换为 variable 类型
                doc = to_variable(
                    np.array([
                        np.pad(x[0][0:train_parameters["padding_size"]],  #对句子进行padding，全部填补为定长150
                              (0, train_parameters["padding_size"] - len(x[0][0:train_parameters["padding_size"]])),
                               'constant',
                              constant_values=(train_parameters["vocab_size"])) # 用  的id 进行填补
                        for x in data
                    ]).astype('int64').reshape(-1))
                #转换为 variable 类型
                label = to_variable(
                    np.array([x[1] for x in data]).astype('int64').reshape(
                        train_parameters["batch_size"], 1))

                model.train() #使用训练模式
                prediction, acc = model(doc, label)
                loss = fluid.layers.cross_entropy(prediction, label)
                avg_loss = fluid.layers.mean(loss)
                avg_loss.backward()
                sgd_optimizer.minimize(avg_loss)
                model.clear_gradients()
                
                if steps % train_parameters["skip_steps"] == 0:
                    Iters.append(steps)
                    total_loss.append(avg_loss.numpy()[0])
                    total_acc.append(acc.numpy()[0])
                    print("eop: %d, step: %d, ave loss: %f, ave acc: %f" %
                         (eop, steps,avg_loss.numpy(),acc.numpy()))
                if steps % train_parameters["save_steps"] == 0:
                    save_path = train_parameters["checkpoints"]+"/"+"save_dir_" + str(steps)
                    print('save model to: ' + save_path)
                    fluid.dygraph.save_dygraph(model.state_dict(),
                                                   save_path)
                # break
    draw_train_process(Iters, total_loss, total_acc)
</code></pre> 
<p>训练的过程以及训练的结果如下：</p> 
<p><img src="https://images2.imgbox.com/22/38/kGtPP6P9_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="6__425"></a>6 模型评估</h2> 
<p>​<br> def to_eval():<br> with fluid.dygraph.guard(place = fluid.CUDAPlace(0)):<br> processor = SentaProcessor(data_dir=“data/”) #写自己的路径</p> 
<pre><code>        eval_data_generator = processor.data_generator(
                batch_size=train_parameters["batch_size"],
                phase='eval',
                shuffle=False)

        model_eval = CNN() #示例化模型
        model, _ = fluid.load_dygraph("data//save_dir_180.pdparams") #写自己的路径
        model_eval.load_dict(model)

        model_eval.eval() # 切换为eval模式
        total_eval_cost, total_eval_acc = [], []
        for eval_batch_id, eval_data in enumerate(eval_data_generator()):
            eval_np_doc = np.array([np.pad(x[0][0:train_parameters["padding_size"]],
                                    (0, train_parameters["padding_size"] -len(x[0][0:train_parameters["padding_size"]])),
                                    'constant',
                                    constant_values=(train_parameters["vocab_size"]))
                            for x in eval_data
                            ]).astype('int64').reshape(-1)
            eval_label = to_variable(
                                    np.array([x[1] for x in eval_data]).astype(
                                    'int64').reshape(train_parameters["batch_size"], 1))
            eval_doc = to_variable(eval_np_doc)
            eval_prediction, eval_acc = model_eval(eval_doc, eval_label)
            loss = fluid.layers.cross_entropy(eval_prediction, eval_label)
            avg_loss = fluid.layers.mean(loss)
            total_eval_cost.append(avg_loss.numpy()[0])
            total_eval_acc.append(eval_acc.numpy()[0])

    print("Final validation result: ave loss: %f, ave acc: %f" %
        (np.mean(total_eval_cost), np.mean(total_eval_acc) ))   
</code></pre> 
<p>评估准确率如下：</p> 
<p><img src="https://images2.imgbox.com/bf/93/EjvRapk0_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="7__469"></a>7 预测结果</h2> 
<p>​<br> # 获取数据<br> def load_data(sentence):<br> # 读取数据字典<br> with open(‘data/dict.txt’, ‘r’, encoding=‘utf-8’) as f_data:<br> dict_txt = eval(f_data.readlines()[0])<br> dict_txt = dict(dict_txt)<br> # 把字符串数据转换成列表数据<br> keys = dict_txt.keys()<br> data = []<br> for s in sentence:<br> # 判断是否存在未知字符<br> if not s in keys:<br> s = ‘’<br> data.append(int(dict_txt[s]))<br> return data</p> 
<pre><code>train_parameters["batch_size"] = 1
lab = [ '谣言', '非谣言']
 
with fluid.dygraph.guard(place = fluid.CUDAPlace(0)):
    
    data = load_data('兴仁县今天抢小孩没抢走，把孩子母亲捅了一刀，看见这车的注意了，真事，车牌号辽HFM055！！！！！赶紧散播！ 都别带孩子出去瞎转悠了 尤其别让老人自己带孩子出去 太危险了 注意了！！！！辽HFM055北京现代朗动，在各学校门口抢小孩！！！110已经 证实！！全市通缉！！')
    data_np = np.array(data)
    data_np = np.array(np.pad(data_np,(0,150-len(data_np)),"constant",constant_values =train_parameters["vocab_size"])).astype('int64').reshape(-1)

    infer_np_doc = to_variable(data_np)
   
    model_infer = CNN()
    model, _ = fluid.load_dygraph("data/save_dir_900.pdparams")
    model_infer.load_dict(model)
    model_infer.eval()
    result = model_infer(infer_np_doc)
    print('预测结果为：', lab[np.argmax(result.numpy())])
</code></pre> 
<p><img src="https://images2.imgbox.com/4c/6f/0osozEQA_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="8__510"></a>8 最后</h2> 
<p>🧿 <strong>更多资料, 项目分享：</strong></p> 
<p><a href="https://gitee.com/dancheng-senior/postgraduate" rel="nofollow">https://gitee.com/dancheng-senior/postgraduate</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2d73cce6669c178e825a9f4098ce2fcf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle函数【详细 &amp;&amp; 包括举例】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5ad3942a5be2cd417787f0302167e9fe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">flink generic log-based incremental checkpoints 设计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>