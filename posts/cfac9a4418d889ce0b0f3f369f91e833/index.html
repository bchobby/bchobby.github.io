<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Flask Mega-Tutorial V2.0 第16章：全文搜索 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Flask Mega-Tutorial V2.0 第16章：全文搜索" />
<meta property="og:description" content="最近在Flask Web Development作者博客看到第二版Flask Mega-Tutorial已在2017年底更新，现翻译给大家参考，希望帮助大家学习flask。
这是Flask Mega-Tutorial系列的第十六章，其中我将为Microblog添加全文搜索功能。
供您参考，以下是本系列文章的列表。
第1章：Hello, World！第2章：模板 第3章：Web表单第4章：数据库第5章：用户登录第6章：配置文件页面和头像第7章：错误处理第8章：关注与被关注第9章：分页第10章：电子邮件支持第11章：整容第12章：日期和时间第13章：I18n和L10n第14章：Ajax第15章：大型应用程序结构第16章：全文搜索（本文）第17章：在Linux上部署第18章：在Heroku上部署第19章：Docker容器上的部署第20章：一些JavaScript Magic第21章：用户通知第22章：后台工作第23章：应用程序编程接口（API） 注意1：如果您正在寻找本教程的旧版本，请在此处。
注意2：如果您想在此博客上支持我的工作，或者只是没有耐心等待每周的文章，我将提供完整的本教程版本，打包成电子书或视频集。欲了解更多信息，请访问courses.miguelgrinberg.com。
本章的目的是为Microblog实现搜索功能，以便用户可以使用自然语言找到有趣的帖子。对于许多类型的网站，可以让Google，Bing等搜索引擎将所有内容编入索引，并通过其搜索API提供搜索结果。这对于大多数页面都是静态的网站（例如论坛）非常有效。但是在我的应用中，基本内容单位是用户帖子，这是整个网页的一小部分。我想要的搜索结果类型是针对这些单个博客帖子，而不是整个页面。例如，如果我搜索单词“ dog”，那么我想查看来自包含该单词的所有用户的博客文章。显然，该页面显示了所有带有“dog”一词的博客帖子。
本章的GitHub链接是：Browse，Zip，Diff。
全文搜索引擎简介 对全文搜索的支持没有像关系数据库那样标准化。有几个开源的全文本引擎：Elasticsearch，Apache Solr，Whoosh，Xapian，Sphinx等。似乎这还不够，有几个数据库还提供了与专用搜索引擎类似的搜索功能，例如我上面列举的那些。SQLite，MySQL和PostgreSQL都提供了一些搜索文本的支持，而MongoDB和CouchDB等NoSQL数据库也支持。
如果您想知道其中哪些可以在Flask应用中运行，答案就是所有这些！那是Flask的强项之一，，它在完成工作的同时不会自作主张。那么最好的选择是什么？
在专用搜索引擎列表中，Elasticsearch在我眼中相当受欢迎，部分原因是它在ELK栈中是用于索引日志的“E”，另两个是Logstash和Kibana。 使用某个关系数据库的搜索能力也是一个不错的选择，但是鉴于SQLAlchemy不支持此功能，我将不得不使用原始SQL语句来处理搜索，否则必须找到一个提供以下功能的包： 它提供一个文本搜索的高级接口，并与SQLAlchemy共存。
基于以上分析，我将使用Elasticsearch，但我将以一种非常容易切换到另一个搜索引擎的方式来实现所有文本索引和搜索功能。 你可以用其他搜索引擎的替换我的实现，只需在单个模块中重写一些函数即可。
安装Elasticsearch 有多种安装Elasticsearch的方法，包括一键式安装程序，包含您自己需要安装的二进制文件的zip文件，甚至是Docker镜像。该文档有一个“安装”页面，其中包含所有这些选项的详细信息。如果您使用的是Linux，则可能会有一个可用于您的发行版的软件包。如果您使用Mac并安装了Homebrew，则只需运行brew install elasticsearch即可。
在计算机上安装Elasticsearch之后，您可以在浏览器的地址栏通过输入http://localhost:9200来验证它是否正在运行，预期的返回结果是JSON格式的服务基本信息。。
由于我将通过Python管理Elasticsearch，因此我还将使用Python客户端库：
(venv) $ pip install elasticsearch 您可能还需要更新您的requirements.txt文件：
(venv) $ pip freeze &gt; requirements.txt Elasticsearch教程 首先，我将从Python shell向您展示使用Elasticsearch的基础知识。这将帮助您熟悉此服务，以便您可以理解我稍后将讨论的实现部分。
要创建与Elasticsearch的连接，请创建class的实例Elasticsearch，并将连接URL作为参数传递：
&gt;&gt;&gt; from elasticsearch import Elasticsearch &gt;&gt;&gt; es = Elasticsearch(&#39;http://localhost:9200&#39;) Elasticsearch中的数据被写入索引。与关系数据库不同，数据只是一个JSON对象。以下示例将一个包含text字段的对象写入名为my_index的索引：
&gt;&gt;&gt; es.index(index=&#39;my_index&#39;, id=1, body={&#39;text&#39;: &#39;this is a test&#39;}) 如果需要，索引可以存储不同类型的文档，在本处，可以根据不同的格式将doc_type参数设置为不同的值。 我要将所有文档存储为相同的格式，因此我将文档类型设置为索引名称。
对于存储的每个文档，Elasticsearch使用了一个唯一的ID来索引含有数据的JSON对象。
让我们在该索引上存储第二个文档：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/cfac9a4418d889ce0b0f3f369f91e833/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-20T14:38:20+08:00" />
<meta property="article:modified_time" content="2021-03-20T14:38:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Flask Mega-Tutorial V2.0 第16章：全文搜索</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>最近在Flask Web Development作者博客看到第二版Flask Mega-Tutorial已在2017年底更新，现翻译给大家参考，希望帮助大家学习flask。</p> 
</blockquote> 
<p>这是Flask Mega-Tutorial系列的第十六章，其中我将为Microblog添加全文搜索功能。</p> 
<p>供您参考，以下是本系列文章的列表。</p> 
<ul><li><a href="https://blog.csdn.net/gh254172840/article/details/81409498">第1章：Hello, World！</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410270">第2章：模板</a> </li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410281">第3章：Web表单</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410292">第4章：数据库</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410296">第5章：用户登录</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410299">第6章：配置文件页面和头像</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410299">第7章：错误处理</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410311">第8章：关注与被关注</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410319">第9章：分页</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410325">第10章：电子邮件支持</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410332">第11章：整容</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410334">第12章：日期和时间</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410340">第13章：I18n和L10n</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410341">第14章：Ajax</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410350">第15章：大型应用程序结构</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410355">第16章：全文搜索</a>（本文）</li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410357">第17章：在Linux上部署</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410363">第18章：在Heroku上部署</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410368">第19章：Docker容器上的部署</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410372">第20章：一些JavaScript Magic</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410382">第21章：用户通知</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410386">第22章：后台工作</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410391">第23章：应用程序编程接口（API）</a></li></ul> 
<p><em>注意1：如果您正在寻找本教程的旧版本，请<a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world-legacy" rel="nofollow">在此处</a>。</em></p> 
<p><em>注意2：如果您想在此博客上支持我的工作，或者只是没有耐心等待每周的文章，我将提供完整的本教程版本，打包成电子书或视频集。欲了解更多信息，请访问<a href="https://courses.miguelgrinberg.com/" rel="nofollow">courses.miguelgrinberg.com</a>。</em></p> 
<p>本章的目的是为Microblog实现搜索功能，以便用户可以使用自然语言找到有趣的帖子。对于许多类型的网站，可以让Google，Bing等搜索引擎将所有内容编入索引，并通过其搜索API提供搜索结果。这对于大多数页面都是静态的网站（例如论坛）非常有效。但是在我的应用中，基本内容单位是用户帖子，这是整个网页的一小部分。我想要的搜索结果类型是针对这些单个博客帖子，而不是整个页面。例如，如果我搜索单词“ dog”，那么我想查看来自包含该单词的所有用户的博客文章。显然，该页面显示了所有带有“dog”一词的博客帖子。</p> 
<p><em>本章的GitHub链接是：<a href="https://github.com/miguelgrinberg/microblog/tree/v0.16">Browse</a>，<a href="https://github.com/miguelgrinberg/microblog/archive/v0.16.zip">Zip</a>，<a href="https://github.com/miguelgrinberg/microblog/compare/v0.15...v0.16">Diff</a>。</em></p> 
<hr> 
<h3><span style="color:#333333;">全文搜索引擎简介</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">对全文搜索的支持没有像关系数据库那样标准化。有几个开源的全文本引擎：<a href="https://www.elastic.co/products/elasticsearch" rel="nofollow">Elasticsearch</a>，<a href="http://lucene.apache.org/solr/" rel="nofollow">Apache Solr</a>，<a href="http://whoosh.readthedocs.io/" rel="nofollow">Whoosh</a>，<a href="https://xapian.org/" rel="nofollow">Xapian</a>，<a href="http://sphinxsearch.com/" rel="nofollow">Sphinx</a>等。似乎这还不够，有几个数据库还提供了与专用搜索引擎类似的搜索功能，例如我上面列举的那些。<a href="https://www.sqlite.org/" rel="nofollow">SQLite</a>，<a href="https://www.mysql.com/" rel="nofollow">MySQL</a>和<a href="https://www.postgresql.org/" rel="nofollow">PostgreSQL</a>都提供了一些搜索文本的支持，而<a href="https://www.mongodb.com/" rel="nofollow">MongoDB</a>和<a href="http://couchdb.apache.org/" rel="nofollow">CouchDB</a>等NoSQL数据库也支持。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">如果您想知道其中哪些可以在Flask应用中运行，答案就是所有这些！那是Flask的强项之一，</span>，它在完成工作的同时不会自作主张<span style="color:#333333;">。那么最好的选择是什么？</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">在专用搜索引擎列表中，Elasticsearch在我眼中相当受欢迎，</span>部分原因是它在ELK栈中是用于索引日志的“E”，另两个是Logstash和Kibana。 使用某个关系数据库的搜索能力也是一个不错的选择<span style="color:#333333;">，但是鉴于SQLAlchemy不支持此功能，我将不得不使用原始SQL语句来处理搜索，否则必须找到一个提供以下功能的包：</span> 它提供一个文本搜索的高级接口，并与SQLAlchemy共存<span style="color:#333333;">。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">基于以上分析，我将使用Elasticsearch，</span>但我将以一种非常容易切换到另一个搜索引擎的方式来实现所有文本索引和搜索功能。 你可以用其他搜索引擎的替换我的实现，只需在单个模块中重写一些函数即可<span style="color:#333333;">。</span></p> 
<h3><span style="color:#333333;">安装Elasticsearch</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">有多种安装Elasticsearch的方法，包括一键式安装程序，包含您自己需要安装的二进制文件的zip文件，甚至是Docker镜像。该文档有一个“<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/install-elasticsearch.html" rel="nofollow">安装”</a>页面，其中包含所有这些选项的详细信息。如果您使用的是Linux，则可能会有一个可用于您的发行版的软件包。如果您使用Mac并安装了Homebrew，则只需运行<code>brew install elasticsearch</code>即可。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">在计算机上安装Elasticsearch之后，您可以在浏览器的地址栏通过输入<code>http://localhost:9200</code>来验证它是否正在运行，</span>预期的返回结果是JSON格式的服务基本信息。<span style="color:#333333;">。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">由于我将通过Python管理Elasticsearch，因此我还将使用Python客户端库：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">(venv) $ pip install elasticsearch</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">您可能还需要更新您的<em>requirements.txt</em>文件：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">(venv) $ pip freeze &gt; requirements.txt</code></pre> 
<h3><span style="color:#333333;">Elasticsearch教程</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">首先，我将从Python shell向您展示使用Elasticsearch的基础知识。这将帮助您熟悉此服务，以便您可以理解我稍后将讨论的实现部分。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">要创建与Elasticsearch的连接，请创建class的实例<code>Elasticsearch</code>，并将连接URL作为参数传递：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">&gt;&gt;&gt; from elasticsearch import Elasticsearch
&gt;&gt;&gt; es = Elasticsearch('http://localhost:9200')</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">Elasticsearch中的数据被写入<em>索引</em>。与关系数据库不同，数据只是一个<a href="http://www.json.org/" rel="nofollow">JSON</a>对象。</span>以下示例将一个包含<code>text</code>字段的对象写入名为<code>my_index</code>的索引：</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">&gt;&gt;&gt; es.index(index='my_index', id=1, body={'text': 'this is a test'})</code></pre> 
<p style="margin-left:0px;">如果需要，索引可以存储不同类型的文档，在本处，可以根据不同的格式将<code>doc_type</code>参数设置为不同的值。 我要将所有文档存储为相同的格式，因此我将文档类型设置为索引名称。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">对于存储的每个文档，</span>Elasticsearch使用了一个唯一的ID来索引含有数据的JSON对象<span style="color:#333333;">。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">让我们在该索引上存储第二个文档：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">&gt;&gt;&gt; es.index(index='my_index', id=2, body={'text': 'a second test'})</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">现在此索引中有两个文档，我可以发出自由格式的搜索。在此示例中，我将搜索<code>this test</code>：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">&gt;&gt;&gt; es.search(index='my_index', body={'query': {'match': {'text': 'this test'}}})</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">调用<code>es.search()</code>的响应是带有搜索结果的Python字典：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">{
    'took': 1,
    'timed_out': False,
    '_shards': {'total': 5, 'successful': 5, 'skipped': 0, 'failed': 0},
    'hits': {
        'total': 2, 
        'max_score': 0.5753642, 
        'hits': [
            {
                '_index': 'my_index',
                '_type': 'my_index',
                '_id': '1',
                '_score': 0.5753642,
                '_source': {'text': 'this is a test'}
            },
            {
                '_index': 'my_index',
                '_type': 'my_index',
                '_id': '2',
                '_score': 0.25316024,
                '_source': {'text': 'a second test'}
            }
        ]
    }
}</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">在这里，您可以看到搜索返回了两个文档，每个文档都有一个指定的分数。得分最高的文档包含我搜索的两个词，另一个文档仅包含一个。您会看到，即使最好的结果也得分不高，因为单词与文本不完全匹配。</span></p> 
<p style="margin-left:0px;">现在，如果我搜索单词<code>second</code>，结果如下：</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">&gt;&gt;&gt; es.search(index='my_index', body={'query': {'match': {'text': 'second'}}})
{
    'took': 1,
    'timed_out': False,
    '_shards': {'total': 5, 'successful': 5, 'skipped': 0, 'failed': 0},
    'hits': {
        'total': 1,
        'max_score': 0.25316024,
        'hits': [
            {
                '_index': 'my_index',
                '_type': 'my_index',
                '_id': '2',
                '_score': 0.25316024,
                '_source': {'text': 'a second test'}
            }
        ]
    }
}</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">我的得分仍然很低，因为我的搜索与该文档中的文本不匹配，但是由于两个文档中只有一个包含单词“ second”，因此另一个文档根本没有显示。</span></p> 
<p style="margin-left:0px;">Elasticsearch查询对象有更多的选项，并且很好地进行了<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-body.html" rel="nofollow">文档化</a>，其中包含诸如分页和排序这样的和关系数据库一样的功能。</p> 
<p style="margin-left:0px;">随意<span style="color:#333333;">向该索引添加更多条目，然后尝试不同的搜索。完成实验后，可以使用以下命令删除索引：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">&gt;&gt;&gt; es.indices.delete('my_index')</code></pre> 
<h3><span style="color:#333333;">Elasticsearch配置</span></h3> 
<p style="margin-left:0px;">将Elasticsearch集成到本应用是展现Flask魅力的绝佳范例<span style="color:#333333;">。</span>这是一个与Flask没有任何关系的服务和Python包，然而，我将从配置开始将它们恰如其分地集成，我先在<code>app.config </code>模块中实现这样的操作：</p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>config.py：Elasticsearch</em>配置。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">class Config(object):
    # ...
    ELASTICSEARCH_URL = os.environ.get('ELASTICSEARCH_URL')</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">与许多其他配置条目一样，Elasticsearch的连接URL将来自环境变量。如果未定义变量，则将设置设置为<code>None</code>，并将其用作禁用Elasticsearch的标志。这主要是为了方便起见，因此在处理应用时，尤其是在运行单元测试时，不必强制Elasticsearch</span>服务启动和运行<span style="color:#333333;">。因此，要确保服务的可用性，我需要直接在终端中定义环境变量<code>ELASTICSEARCH_URL</code>，或者将其添加到<em>.env</em>文件中，如下所示：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">ELASTICSEARCH_URL=http://localhost:9200</code></pre> 
<p style="margin-left:0px;">使用Elasticsearch面临着非Flask插件如何使用的挑战<span style="color:#333333;">。</span>我不能像在上面的例子中那样在全局范围内创建Elasticsearch实例，因为要初始化它<span style="color:#333333;">，我需要访问<code>app.config</code>，该属性仅在调用<code>create_app()</code>函数后可用。因此，我决定在应用工厂函数中为<code>app</code>实例添加一个属性<code>elasticsearch</code>：</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / __ init__.py：Elasticsearch</em>实例。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python"># ...
from elasticsearch import Elasticsearch

# ...

def create_app(config_class=Config):
    app = Flask(__name__)
    app.config.from_object(config_class)

    # ...
    app.elasticsearch = Elasticsearch([app.config['ELASTICSEARCH_URL']]) \
        if app.config['ELASTICSEARCH_URL'] else None

    # ...</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">向<code>app</code>实例添加新属性似乎有些奇怪，但是Python对象在结构上并不严格，可以随时向其添加新属性。您可能还考虑的另一种方法，</span>就是定义一个从<code>Flask</code>派生的子类（可以叫<code>Microblog</code>），然后在它的<code>__init__()</code>函数中定义<code>elasticsearch</code>属性。</p> 
<p style="margin-left:0px;">请留意我设计的<a href="https://docs.python.org/3/reference/expressions.html#conditional-expressions" rel="nofollow">条件表达式</a>，如果Elasticsearch服务的URL在环境变量中未定义，则赋值<code>None</code>给<code>app.elasticsearch</code>。</p> 
<h3><span style="color:#333333;">全文搜索抽象化</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">就像我在本章的简介中所说的那样，我想轻松地从Elasticsearch切换到其他搜索引擎，并且我也不想为搜索博客文章专门编写此功能，我希望设计一种解决方案，以便将来如果需要使用，我可以轻松扩展到其他模型。由于所有这些原因，</span>我决定将搜索功能<em>抽象化</em><span style="color:#333333;">。</span>我的想法是以通用条件来设计特性，所以不会假设<code>Post</code>模型是唯一需要编制索引的模型，也不会假设Elasticsearch是唯一选择的搜索引擎。 但是如果我不能对任何事情做出任何假设，我是不可能完成这项工作的！</p> 
<p style="margin-left:0px;"><span style="color:#333333;">我需要做的第一件事，是以某种方式找到一种通用的方式来指示要对哪个模型以及哪个字段或哪个字段进行索引。我要说的是，任何需要索引的模型都需要定义一个<code>__searchable__</code>类属性，该属性列出需要包含在索引中的字段。对于<code>Post</code>模型，这些是更改：</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / models.py</em>：向</span>Post模型添加一个__searchable__属性。</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">class Post(db.Model):
    __searchable__ = ['body']
    # ...</code></pre> 
<p style="margin-left:0px;">需要说明的是，这个模型需要有<code>body</code>字段才能被索引。 不过，为了清楚地确保这一点，我添加的这个<code>__searchable__</code>属性只是一个变量，它没有任何关联的行为。 它只会帮助我以通用的方式编写索引函数。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">我将在<em>app / search.py</em>模块中编写所有与Elasticsearch索引进行交互的代码。</span> 这么做是为了将所有Elasticsearch代码限制在这个模块中<span style="color:#333333;">。本应用的其余部分将使用此新模块中的函数来访问索引，而不会直接访问Elasticsearch。这很重要，因为如果有一天我决定不再喜欢Elasticsearch并想要切换到其他引擎，那么我要做的就是重写此模块中的函数，该应用程将继续像以前一样工作。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">对于本应用，我决定需要三个与文本索引相关的支持功能：我需要向全文索引添加条目，我需要从索引中删除条目（假设有一天我将支持删除博客文章），以及我需要执行搜索查询。下面是<em>app / search.py</em>模块，</span>它使用我在Python控制台中向你展示的功能实现Elasticsearch的这三个函数：</p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / search.py</em>：搜索函数。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">from flask import current_app

def add_to_index(index, model):
    if not current_app.elasticsearch:
        return
    payload = {}
    for field in model.__searchable__:
        payload[field] = getattr(model, field)
    current_app.elasticsearch.index(index=index, id=model.id, body=payload)

def remove_from_index(index, model):
    if not current_app.elasticsearch:
        return
    current_app.elasticsearch.delete(index=index, id=model.id)

def query_index(index, query, page, per_page):
    if not current_app.elasticsearch:
        return [], 0
    search = current_app.elasticsearch.search(
        index=index,
        body={'query': {'multi_match': {'query': query, 'fields': ['*']}},
              'from': (page - 1) * per_page, 'size': per_page})
    ids = [int(hit['_id']) for hit in search['hits']['hits']]
    return ids, search['hits']['total']['value']</code></pre> 
<p style="margin-left:0px;">这些函数都是通过检查<code>app.elasticsearch</code>是否为<code>None</code>开始的，如果是<code>None</code>，则不做任何事情就返回。 当Elasticsearch服务器未配置时，应用会在没有搜索功能的状态下继续运行，不会出现任何错误。 这都是为了方便开发或运行单元测试。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">这些函数接受索引名称作为参数。在传递给Elasticsearch的所有调用中，都使用该名称作为索引名称以及文档类型，就像在Python控制台示例中所做的那样。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">从索引添加和删除条目的函数将SQLAlchemy模型作为第二个参数。<code>add_to_index()</code>函数使用我添加到模型中的类变量<code>__searchable__</code>来构建插入到索引中的文档。回想一下，Elasticsearch文档还需要一个唯一的标识符。为此，我使用了SQLAlchemy模型的字段<code>id</code>，</span>该字段正好是唯一的<span style="color:#333333;">。在运行搜索时，对SQLAlchemy和Elasticsearch使用相同的<code>id</code>值非常有用，因为它允许我链接两个数据库中的条目。我上面没有提到的是，</span>试添加一个带有现有id的条目，那么Elasticsearch会用新的条目替换旧条目，所以<code>add_to_index()</code>可以用于新建和修改对象。</p> 
<p style="margin-left:0px;">在<code>remove_from_index()</code>中的<code>es.delete()</code>函数，我之前没有展示过。 这个函数删除存储在给定<code>id</code>下的文档。 下面是使用相同<code>id</code>链接两个数据库中条目的便利性的一个很好的例子。<span style="color:#333333;">个数据库中的条目。</span></p> 
<p style="margin-left:0px;"><code>query_index()</code>函数使用索引名称和文本进行搜索，通过分页控件，还可以像Flask-SQLAlchemy结果那样对搜索结果进行分页<span style="color:#333333;">。您已经从Python控制台中看到了<code>es.search()</code>函数的用法示例。</span> 我在这里发布的调用非常相似，但不是使用<code>match</code>查询类型，而是使用<code>multi_match</code>，它可以跨多个字段进行搜索。 通过传递<code>*</code>的字段名称，我告诉Elasticsearch查看所有字段，所以基本上我就是搜索了整个索引。 这对于使该函数具有通用性很有用，因为不同的模型在索引中可以具有不同的字段名称。</p> 
<p><code>es.search()</code>查询的<code>body</code>参数还包含分页参数。 <code>from</code>和<code>size</code>参数控制整个结果集的哪些子集需要被返回。 Elasticsearch没有像Flask-SQLAlchemy那样提供一个很好的Pagination对象，所以我必须使用分页数学逻辑来计算<code>from</code>值。</p> 
<p><code>query_index()</code>函数中的<code>return</code>语句有点复杂。 它返回两个值：第一个是搜索结果的<code>id</code>元素列表，第二个是结果总数。 两者都从<code>es.search()</code>函数返回的Python字典中获得。 用于获取ID列表的表达式，被称为<em>列表推导式</em>，是Python语言的一个奇妙功能，它允许你将列表从一种格式转换为另一种格式。 在本例，我使用列表推导式从Elasticsearch提供的更大的结果列表中提取<code>id</code>值。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">这太令人困惑了吗？也许从Python控制台进行这些功能的演示可以帮助您更多地了解它们。在以下会话中，我将数据库中的所有帖子手动添加到Elasticsearch索引中。在我的测试数据库中，我有一些帖子，其中包含数字</span>“one”，“two”， “three”， “four” 和“five”，<span style="color:#333333;">，因此我将其用作搜索查询。您可能需要调整查询以匹配数据库的内容：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">&gt;&gt;&gt; from app.search import add_to_index, remove_from_index, query_index
&gt;&gt;&gt; for post in Post.query.all():
...     add_to_index('posts', post)
&gt;&gt;&gt; query_index('posts', 'one two three four five', 1, 100)
([15, 13, 12, 4, 11, 8, 14], 7)
&gt;&gt;&gt; query_index('posts', 'one two three four five', 1, 3)
([15, 13, 12], 7)
&gt;&gt;&gt; query_index('posts', 'one two three four five', 2, 3)
([4, 11, 8], 7)
&gt;&gt;&gt; query_index('posts', 'one two three four five', 3, 3)
([14], 7)</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">我发出的查询返回了七个结果。</span> 当我以每页100项查询第1页时，我得到了全部的七项，但接下来的三个例子显示了我如何以与Flask-SQLAlchemy类似的方式对结果进行分页，当然，结果是ID列表而不是SQLAlchemy对象。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">如果您想保持数据整洁，请尝试进行以下操作以删除<code>posts</code>索引：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">&gt;&gt;&gt; app.elasticsearch.indices.delete('posts')</code></pre> 
<h3>集成SQLAlchemy到搜索</h3> 
<p style="margin-left:0px;"><span style="color:#333333;">我在上一节中向您展示的解决方案很不错，但是仍然存在一些问题。最明显的问题是结果以数字ID列表的形式出现。这非常不方便，我需要SQLAlchemy模型，以便可以将它们传递给模板进行渲染，并且需要一种用数据库中的相应模型替换该数字列表的方法。第二个问题是此解决方案要求应用在添加或删除帖子时显式发出索引调用，</span>这并非不可行，但并不理想<span style="color:#333333;">，</span>因为在SQLAlchemy侧进行更改时错过索引调用的情况是不容易被检测到的，每当发生这种情况时，两个数据库就会越来越不同步，并且你可能在一段时间内都不会注意到。 更好的解决方案是在SQLAlchemy数据库进行更改时自动触发这些调用。</p> 
<p style="margin-left:0px;">用对象替换ID的问题可以通过创建一个从数据库读取这些对象的SQLAlchemy查询来解决。 这在实践中听起来很容易，但是使用单个查询来高效地实现它实际上有点棘手。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">对于自动触发索引更改的问题，我决定从SQLAlchemy<em>事件</em>驱动对Elasticsearch索引的更新。SQLAlchemy提供了可以通知应用的大量<a href="http://docs.sqlalchemy.org/en/latest/core/event.html" rel="nofollow">事件</a>。例如，每次提交会话时，</span>我都可以定义一个由SQLAlchemy调用的函数，并且在该函数中，我可以将SQLAlchemy会话中的更新应用于Elasticsearch索引。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">为了实现这两个问题的解决方案，我将编写一个<em>mixin</em>类。还记得<em>mixin</em>类吗？在<a href="https://blog.csdn.net/gh254172840/article/details/81410296">第5章中</a>，我将Flask-Login中的<code>UserMixin</code>类添加到<code>User</code>模型中，以提供Flask-Login所需的一些功能。为了获得搜索支持，我将定义自己的<code>SearchableMixin</code>类，将其附加到模型后，它便可以自动管理关联的全文本索引。mixin类将充当SQLAlchemy和Elasticsearch世界之间的“胶水”层，为我上面提到的两个问题提供解决方案。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">让我先告诉您实现，然后我将介绍一些有趣的细节。请注意，这利用了几种高级技术，因此您需要仔细研究此代码以完全理解它。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / models.py：SearchableMixin</em>类。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">from app.search import add_to_index, remove_from_index, query_index

class SearchableMixin(object):
    @classmethod
    def search(cls, expression, page, per_page):
        ids, total = query_index(cls.__tablename__, expression, page, per_page)
        if total == 0:
            return cls.query.filter_by(id=0), 0
        when = []
        for i in range(len(ids)):
            when.append((ids[i], i))
        return cls.query.filter(cls.id.in_(ids)).order_by(
            db.case(when, value=cls.id)), total

    @classmethod
    def before_commit(cls, session):
        session._changes = {
            'add': list(session.new),
            'update': list(session.dirty),
            'delete': list(session.deleted)
        }

    @classmethod
    def after_commit(cls, session):
        for obj in session._changes['add']:
            if isinstance(obj, SearchableMixin):
                add_to_index(obj.__tablename__, obj)
        for obj in session._changes['update']:
            if isinstance(obj, SearchableMixin):
                add_to_index(obj.__tablename__, obj)
        for obj in session._changes['delete']:
            if isinstance(obj, SearchableMixin):
                remove_from_index(obj.__tablename__, obj)
        session._changes = None

    @classmethod
    def reindex(cls):
        for obj in cls.query:
            add_to_index(cls.__tablename__, obj)</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">这个mixin类中有四个函数，都是类方法。</span>复习一下，类方法是与类相关联的特殊方法，而不是实例的<span style="color:#333333;">。请注意，我如何将常规实例方法中使用的<code>self</code>参数重命名为<code>cls</code>，以明确表明此方法将接收类而不是实例作为其第一个参数。例如，一旦附加到<code>Post</code>模型，上面的<code>search()</code>方法将被调用为<code>Post.search()</code>，而不必将<code>Post类</code>实例化。</span></p> 
<p style="margin-left:0px;"><code>search()</code>类方法封装来自<em>app/search.py​​</em>的<code>query_index()</code>函数以将对象ID列表替换成实例对象。你可以看到这个函数做的第一件事就是调用<code>query_index()</code>，并传递<code>cls .__tablename__</code>作为索引名称。这将是一个约定，所有索引都将用Flask-SQLAlchemy模型关联的表名。该函数返回结果ID列表和结果总数。通过它们的ID检索对象列表的SQLAlchemy查询基于SQL语言的<code>CASE</code>语句，该语句需要用于确保数据库中的结果与给定ID的顺序相同。<span style="color:#333333;">这很重要，因为Elasticsearch查询返回的结果按相关性从高到低排序。如果您想了解有关此查询工作方式的更多信息，可以查阅此<a href="https://stackoverflow.com/a/6332081/904393" rel="nofollow">StackOverflow问题</a>的公认答案。该<code>search()</code>函数返回替换ID列表的查询，</span>以及搜索结果的总数<span style="color:#333333;">。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><code>before_commit()</code>和<code>after_commit()</code>方法分别对应来自SQLAlchemy的两个事件，</span>这两个事件分别在提交发生之前和之后触发<span style="color:#333333;">。</span>事前处理功能很有用，因为会话还没有提交，所以我可以查看并找出将要添加，修改和删除的对象，如<code>session.new</code>，<code>session.dirty</code>和<code>session.deleted</code><span style="color:#333333;">。在提交会话之后，这些对象将不再可用，因此我需要在提交之前保存它们。我正在使用<code>session._changes</code></span>字典将这些对象写入会话提交后仍然存在的地方<span style="color:#333333;">，因为一旦提交会话，我将使用它们来更新Elasticsearch索引。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">当调用<code>after_commit()</code>处理程序，该会话已经成功提交，</span>因此这是在Elasticsearch端进行更新的适当时间<span style="color:#333333;">。</span>session对象具有<code>before_commit()</code>中添加的_changes变量，所以现在我可以迭代需要被添加，修改和删除的对象，并对<em>app/search.py</em>中的索引函数进行相应的调用<span style="color:#333333;"><code>SearchableMixin</code></span>。</p> 
<p style="margin-left:0px;"><span style="color:#333333;"><code>reindex()</code>类方法是一种简单的辅助方法，您</span>可以使用它来刷新所有数据的索引<span style="color:#333333;">。您看到我从上面的Python shell会话中执行了类似的操作，以将所有帖子初始加载到测试索引中。使用此方法后，我可以调用<code>Post.reindex()</code>将数据库中的所有帖子添加到搜索索引。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">在类定义之后，我对SQLALchemy的function进行了两次调用<code>db.event.listen()</code>。请注意，这些调用不在类内部，而是在类内部。这两个语句的目的是设置事件处理程序，使SQLAlchemy分别在每次提交之前和之后调用<code>before_commit()</code>和<code>after_commit()</code>方法。</span></p> 
<p style="margin-left:0px;">为了将<code>SearchableMixin</code>类整合到<code>Post</code>模型中，我必须将它作为<code>Post</code>的基类，并且还需要监听<span style="color:#333333;">commit</span>之前和之后的事件：</p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / models.py</em>：将SearchableMixin类添加到Post模型中。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">class Post(SearchableMixin, db.Model):
    # ...</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">现在，该<code>Post</code>模型将自动维护帖子的全文搜索索引。我可以使用该<code>reindex()</code>方法来初始化数据库中当前所有帖子的索引：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">&gt;&gt;&gt; Post.reindex()</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">而且我可以通过运行<code>Post.search()</code>来搜索使用SQLAlchemy模型的帖子。在以下示例中，</span>我要求查询第一页的五个元素：</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">&gt;&gt;&gt; query, total = Post.search('one two three four five', 1, 5)
&gt;&gt;&gt; total
7
&gt;&gt;&gt; query.all()
[&lt;Post five&gt;, &lt;Post two&gt;, &lt;Post one&gt;, &lt;Post one more&gt;, &lt;Post one&gt;]</code></pre> 
<h3><span style="color:#333333;">搜索表单</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">这非常激烈。我</span> 我上面做的保持通用性的工作涉及到几个高级主题，因此可能需要一些时间才能完全理解。 现在我有一套完整的系统来处理用户动态的自然语言搜索。 所以现在需要做的是将所有这些功能与应用集成在一起。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">基于Web搜索的一种相当标准的方法是将搜索词<code>q</code>作为URL的查询字符串中的参数。例如，如果您想在Google上搜索<code>Python</code>，并且想节省几秒钟，则只需在浏览器的地址栏中键入以下URL，即可直接转到结果：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint">https://www.google.com/search?q=python</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">允许将搜索完全封装在URL中是一件很不错的事，因为可以与其他人共享这些内容，他们只需单击链接即可访问搜索结果。</span></p> 
<p style="margin-left:0px;">请允许我向你介绍一种区别于以前的Web表单的处理方式<span style="color:#333333;">。我已经使用<code>POST</code>请求为应用提交表单数据，但是要实现上述搜索，表单提交将必须以<code>GET</code>请求发送，这是一种请求方法。当您</span>在浏览器中输入网址或点击链接时，就是GET请求。<span style="color:#333333;">另一个有趣的区别是搜索表单将出现在导航栏中，因此它需要出现在应用的所有页面中。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">这是搜索表单类，仅包含<code>q</code>文本字段：</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / main / forms.py</em>：搜索表单。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">from flask import request

class SearchForm(FlaskForm):
    q = StringField(_l('Search'), validators=[DataRequired()])

    def __init__(self, *args, **kwargs):
        if 'formdata' not in kwargs:
            kwargs['formdata'] = request.args
        if 'csrf_enabled' not in kwargs:
            kwargs['csrf_enabled'] = False
        super(SearchForm, self).__init__(*args, **kwargs)</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">该<code>q</code>字段无须解释，因为它与我过去使用的其他文本字段相似。对于此表单，我不需要“提交”按钮。对于具有文本字段的表单，当您按Enter键并将焦点放在该字段上时，浏览器将提交该表单，因此不需要按钮。我还添加了一个<code>__init__</code>构造函数，</span>它提供了<code>formdata</code>和<code>csrf_enabled</code>参数的值（如果调用者没有提供它们的话）<span style="color:#333333;">。<code>formdata</code>参数确定Flask-WTF从何处获取表单提交。</span>缺省情况是使用<span style="color:#333333;"> <code>request.form</code>，这是Flask放置通过<code>POST</code>请求提交的表单值的位置。通过<code>GET</code>请求提交的表单在查询字符串中传递字段值，因此我需要将Flask-WTF指向<code>request.args</code>，这是Flask写查询字符串参数的地方。您还记得，表单默认情况下添加了CSRF保护，并包含一个CSRF令牌，令牌通过模板中的<code>form.hidden_tag()</code>构造添加到表单中。为了使可点击的搜索链接正常工作，需要禁用CSRF，因此我将<code>csrf_enabled</code>设置为<code>False，</code></span>以便Flask-WTF知道它需要忽略此表单的CSRF验证。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">由于我需要在所有页面上都显示此表单，因此无论用户正在查看的哪个页面，我都需要创建<code>SearchForm</code>类的实例。唯一的要求是用户已登录，因为对于匿名用户，我目前不显示任何内容。我将向您展示一个非常有用的技巧，</span>与其在每个路由中创建表单对象，然后将表单传递给所有模板，当你需要在整个应用中实现一个功能时，可以消除重复代码<span style="color:#333333;">。在<a href="https://blog.csdn.net/gh254172840/article/details/81410299">第6章中</a>，我已经使用过<code>before_request</code>处理程序，来记录每个用户的上次访问时间。我要做的就是在相同的函数中创建搜索表单，但是有一点区别：</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / main / routes.py</em>：在before_request处理程序中实例化搜索表单。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">from flask import g
from app.main.forms import SearchForm

@bp.before_app_request
def before_request():
    if current_user.is_authenticated:
        current_user.last_seen = datetime.utcnow()
        db.session.commit()
        g.search_form = SearchForm()
    g.locale = str(get_locale())</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">在这里，当经过身份验证的用户时，我会创建搜索表单类的实例。当然，我需要将此表单对象持久化，直到可以在请求结束时将其渲染为止，因此我需要将其存储在某个位置。那个地方就是Flask提供的<code>g</code>容器。Flask提供的<code>g</code>变量是应用</span>可以存储需要在整个请求期间持续存在的数据的地方<span style="color:#333333;">。在这里，我将表单存储在<code>g.search_form</code>中，因此，当请求前置处理程序结束并且Flask调用用于处理请求的URL的视图函数时，该<code>g</code>对象将是相同的，并且仍将附加表单。重要的是，要注意<code>g</code>变量对于每个请求和每个客户端都是特定的，因此，即使您的Web服务器一次为不同的客户端处理多个请求，您仍然可以依赖于<code>g</code>充当每个请求的私有存储，而无须担心其他请求同时发生时产生冲突。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">下一步是将表单渲染到页面。我在上面说过，我希望所有页面都使用此表单，因此更有意义的是将其渲染为导航栏的一部分。实际上，这很简单，因为模板也可以看到存储在<code>g</code>变量中的数据，</span>所以我不需要在所有<code>render_template()</code>调用中将表单作为显式模板参数添加进去<span style="color:#333333;">。这是我可以在基本模板中渲染表单的方法：</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / templates / base.html</em>：在导航栏中渲染搜索表单。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-html">            ...
            &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt;
                &lt;ul class="nav navbar-nav"&gt;
                    ... home and explore links ...
                &lt;/ul&gt;
                {% if g.search_form %}
                &lt;form class="navbar-form navbar-left" method="get"
                        action="{<!-- -->{ url_for('main.search') }}"&gt;
                    &lt;div class="form-group"&gt;
                        {<!-- -->{ g.search_form.q(size=20, class='form-control',
                            placeholder=g.search_form.q.label.text) }}
                    &lt;/div&gt;
                &lt;/form&gt;
                {% endif %}
                ...</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">仅在<code>g.search_form</code>定义时才渲染该表单。此检查是必需的，因为某些页面（例如错误页面）可能没有定义。这种形式与我之前所做的形式略有不同。我将<code>method</code>属性设置为<code>get</code>，</span>因为我希望表单数据作为查询字符串，通过<code>GET</code>请求提交<span style="color:#333333;">。另外，我创建的其他表单的<code>action</code>属性为空，</span>因为它们被提交到渲染表单的同一页面。 而这个表单很特殊，因为它出现在所有页面中，所以我需要明确告诉它需要提交的地方，这是专门用于处理搜索的新路由。</p> 
<h3><span style="color:#333333;">搜索视图功能</span></h3> 
<p style="margin-left:0px;">完成搜索功能的最后一项功能是接收搜索表单的视图函数。<span style="color:#333333;">该视图函数将附加到<em>/search</em>路由，以便您可以像Google一样发送带有</span> <em><a href="http://localhost:5000/search?q=search-words" rel="nofollow">http://localhost:5000/search?q=search-words</a></em><span style="color:#333333;">的搜索请求。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / main / routes.py</em>：搜索视图函数。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">@bp.route('/search')
@login_required
def search():
    if not g.search_form.validate():
        return redirect(url_for('main.explore'))
    page = request.args.get('page', 1, type=int)
    posts, total = Post.search(g.search_form.q.data, page,
                               current_app.config['POSTS_PER_PAGE'])
    next_url = url_for('main.search', q=g.search_form.q.data, page=page + 1) \
        if total &gt; page * current_app.config['POSTS_PER_PAGE'] else None
    prev_url = url_for('main.search', q=g.search_form.q.data, page=page - 1) \
        if page &gt; 1 else None
    return render_template('search.html', title=_('Search'), posts=posts,
                           next_url=next_url, prev_url=prev_url)</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">您已经看到，在其他表单中，我使用了<code>form.validate_on_submit()</code>方法来检查表单提交是否有效。不幸的是，该方法仅适用于通过<code>POST</code>请求提交的表单，因此对于此表单，我需要使用<code>form.validate()，</code>仅验证字段值而不检查数据如何提交。如果验证失败，那是因为用户提交了一个空的搜索表单，因此在这种情况下，我只重定向到显示所有博客文章的浏览页面。</span></p> 
<p style="margin-left:0px;"><code>SearchableMixin</code>类中的<code>Post.search()</code>方法用于获取搜索结果列表<span style="color:#333333;">。分页的处理方式与索引和浏览页的处理方式非常相似，但是如果没有Flask-SQLAlchemy的<code>Pagination</code>对象的帮助，则生成下一个和上一个链接会有些棘手。</span>这是从<code>Post.search()</code>返回的结果总数的用途所在。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">计算完搜索结果和分页链接页面后，剩下的就是用所有这些数据渲染模板。我本来可以找到一种方法，来重用<em>index.html</em>模板以显示搜索结果，但是由于存在一些差异，我决定利用<em>_post</em>来创建专用于显示搜索结果的专用<em>search.html</em>模板，</span> 以 <em>_post.html</em> 子模板的优势来渲染搜索结果<span style="color:#333333;">：</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / templates / search.html</em>：搜索结果模板。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-html">{% extends "base.html" %}

{% block app_content %}
    &lt;h1&gt;{<!-- -->{ _('Search Results') }}&lt;/h1&gt;
    {% for post in posts %}
        {% include '_post.html' %}
    {% endfor %}
    &lt;nav aria-label="..."&gt;
        &lt;ul class="pager"&gt;
            &lt;li class="previous{% if not prev_url %} disabled{% endif %}"&gt;
                &lt;a href="{<!-- -->{ prev_url or '#' }}"&gt;
                    &lt;span aria-hidden="true"&gt;&amp;larr;&lt;/span&gt;
                    {<!-- -->{ _('Previous results') }}
                &lt;/a&gt;
            &lt;/li&gt;
            &lt;li class="next{% if not next_url %} disabled{% endif %}"&gt;
                &lt;a href="{<!-- -->{ next_url or '#' }}"&gt;
                    {<!-- -->{ _('Next results') }}
                    &lt;span aria-hidden="true"&gt;&amp;rarr;&lt;/span&gt;
                &lt;/a&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/nav&gt;
{% endblock %}</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">如果上一个和下一个链接的渲染逻辑有些混乱，则可能查看有关<a href="https://getbootstrap.com/docs/3.3/components/#pagination" rel="nofollow">分页组件</a>的Bootstrap文档会有所帮助。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><img alt="搜索结果" src="https://images2.imgbox.com/32/e8/a54zMOBy_o.png"></span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">你怎么认为？这章很紧张，我介绍了一些相当先进的技术。本章中的某些概念可能需要花一些时间才能理解。最重要的一点是，如果您要使用与Elasticsearch不同的搜索引擎，则您需要做的就是重新实现<em>app / search.py</em>其中的三个功能。通过此工作的另一个重要好处是，</span>，如果我需要为另外的数据库模型添加搜索支持，我可以简单地通过向它添加<code>SearchableMixin</code>类，为<code>__searchable__</code>属性填写要索引的字段列表和SQLAlchemy事件处理程序的监听即可。 我认为这些努力是值得的，因为从现在起，处理全文索引将会变得十分容易。</p> 
<hr> 
<p>原文链接：<a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xvi-full-text-search" rel="nofollow">https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xvi-full-text-search</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6905434ef96b343ed6d10fda5b8c5faf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C#02 （字符串  数组 ）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8e6a918bc4f15f2d3e8923082356405a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java反射技术--获取私有属性和方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>