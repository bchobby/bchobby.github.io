<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android S 12 行为变更：所有应用 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android S 12 行为变更：所有应用" />
<meta property="og:description" content="Android 12 平台包含一些行为变更，这些变更可能会影响您的应用。以下行为变更将影响在 Android 12 上运行的所有应用，无论采用哪种 targetSdkVersion 都不例外。您应该测试您的应用，然后根据需要进行修改，以适当地支持这些变更。
此外，请务必查看仅影响以 Android 12 为目标平台的应用的行为变更列表。
用户体验 拉伸滚动效果 在搭载 Android 12 及更高版本的设备上，滚动事件的视觉行为发生了变化。
在 Android 11 及更低版本中，滚动事件会使视觉元素发光。在 Android 12 及更高版本中，发生拖动事件时，视觉元素会拉伸和反弹；发生快速滑动事件时，它们会快速滑动和反弹。
如需了解详情，请参阅动画演示滚动手势指南。
应用启动画面 如果您之前在 Android 11 或更低版本中实现了自定义启动画面，则需要将您的应用迁移到 SplashScreen API，以确保它从 Android 12 开始正确显示。如果不迁移您的应用，则可能会导致应用启动体验变差或出乎预期。
如需了解相关说明，请参阅将现有的启动画面实现迁移到 Android 12。
此外，从 Android 12 开始，在所有应用的冷启动和温启动期间，系统始终会应用新的 Android 系统默认启动画面。 默认情况下，此系统默认启动画面由应用的启动器图标元素和主题的 windowBackground（如果是单色）构成。
如需了解详情，请参阅启动画面开发者指南。
网络 intent 解析 从 Android 12（API 级别 31）开始，仅当您的应用获准处理某个通用网络 intent 中包含的特定网域时，该网络 intent 才会解析为应用中的 activity。如果您的应用未获准处理相应的网域，则该网络 intent 会解析为用户的默认浏览器应用。
应用可通过执行以下某项操作来获准处理相应的网域：
使用 Android App Links 验证网域。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/d0c70dd3d0c22203bd8cf8bd24e86108/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-28T15:28:29+08:00" />
<meta property="article:modified_time" content="2022-01-28T15:28:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android S 12 行为变更：所有应用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Android 12 平台包含一些行为变更，这些变更可能会影响您的应用。以下行为变更将影响在 Android 12 上运行的<em>所有应用</em>，无论采用哪种 <code>targetSdkVersion</code> 都不例外。您应该测试您的应用，然后根据需要进行修改，以适当地支持这些变更。</p> 
<p>此外，请务必查看<a href="https://developer.android.com/about/versions/12/behavior-changes-12?hl=zh-cn" rel="nofollow" title="仅影响以 Android 12 为目标平台的应用的行为变更">仅影响以 Android 12 为目标平台的应用的行为变更</a>列表。</p> 
<h3 id="user_experience">用户体验</h3> 
<h4 id="overscroll">拉伸滚动效果</h4> 
<p>在搭载 Android 12 及更高版本的设备上，<a href="https://developer.android.com/training/gestures/scroll?hl=zh-cn#term" rel="nofollow" title="滚动事件">滚动事件</a>的视觉行为发生了变化。</p> 
<p>在 Android 11 及更低版本中，滚动事件会使视觉元素发光。在 Android 12 及更高版本中，发生拖动事件时，视觉元素会拉伸和反弹；发生快速滑动事件时，它们会快速滑动和反弹。</p> 
<p>如需了解详情，请参阅<a href="https://developer.android.com/training/gestures/scroll?hl=zh-cn" rel="nofollow" title="动画演示滚动手势">动画演示滚动手势</a>指南。</p> 
<h4 id="splash-screen-migration">应用启动画面</h4> 
<p>如果您之前在 Android 11 或更低版本中实现了自定义启动画面，则需要将您的应用迁移到 <code>SplashScreen</code> API，以确保它从 Android 12 开始正确显示。如果不迁移您的应用，则可能会导致应用启动体验变差或出乎预期。</p> 
<p>如需了解相关说明，请参阅<a href="https://developer.android.com/guide/topics/ui/splash-screen/migrate?hl=zh-cn" rel="nofollow" title="将现有的启动画面实现迁移到 Android 12">将现有的启动画面实现迁移到 Android 12</a>。</p> 
<p>此外，从 Android 12 开始，在所有应用的<a href="https://developer.android.com/topic/performance/vitals/launch-time?hl=zh-cn#cold" rel="nofollow" title="冷启动">冷启动</a>和<a href="https://developer.android.com/topic/performance/vitals/launch-time?hl=zh-cn#warm" rel="nofollow" title="温启动">温启动</a>期间，系统始终会应用新的 <a href="https://developer.android.com/about/versions/12/features/splash-screen?hl=zh-cn" rel="nofollow" title="Android 系统默认启动画面">Android 系统默认启动画面</a>。 默认情况下，此系统默认启动画面由应用的启动器图标元素和主题的 <a href="https://developer.android.com/topic/performance/vitals/launch-time?hl=zh-cn#solutions-3" rel="nofollow" title="windowBackground">windowBackground</a>（如果是单色）构成。</p> 
<p>如需了解详情，请参阅<a href="https://developer.android.com/guide/topics/ui/splash-screen?hl=zh-cn" rel="nofollow" title="启动画面开发者指南">启动画面开发者指南</a>。</p> 
<h4 id="web-intent-resolution">网络 intent 解析</h4> 
<p>从 Android 12（API 级别 31）开始，仅当您的应用获准处理某个通用网络 intent 中包含的特定网域时，该网络 intent 才会解析为应用中的 activity。如果您的应用未获准处理相应的网域，则该网络 intent 会解析为用户的默认浏览器应用。</p> 
<p>应用可通过执行以下某项操作来获准处理相应的网域：</p> 
<ul><li> <p>使用 <a href="https://developer.android.com/training/app-links/verify-site-associations?hl=zh-cn" rel="nofollow" title="Android App Links">Android App Links</a> 验证网域。</p> <p>在以 Android 12 或更高版本为目标平台的应用中，系统更改了其<a href="https://developer.android.com/training/app-links/verify-site-associations?hl=zh-cn#auto-verification" rel="nofollow" title="自动验证">自动验证</a>应用的 Android App Links 的方式。在应用的 <a href="https://developer.android.com/training/app-links/verify-site-associations?hl=zh-cn#add-intent-filters" rel="nofollow" title="intent 过滤器">intent 过滤器</a>中，检查是否包含 <code>BROWSABLE</code> 类别并支持 <code>https</code> 方案。</p> <p>在 Android 12 或更高版本中，您可以<a href="https://developer.android.com/training/app-links/verify-site-associations?hl=zh-cn#manual-verification" rel="nofollow" title="手动验证">手动验证</a>应用的 Android App Links，来测试此更新后的逻辑将如何影响您的应用。</p> </li><li> <p>在系统设置中<a href="https://developer.android.com/training/app-links/verify-site-associations?hl=zh-cn#request-user-associate-app-with-domain" rel="nofollow" title="请求用户将您的应用与网域相关联">请求用户将您的应用与网域相关联</a>。</p> </li></ul> 
<p>如果您的应用调用网络 intent，不妨考虑添加一个提示或对话框，要求用户确认操作。</p> 
<h4 id="immersive-mode-improvements">沉浸模式下的手势导航改进</h4> 
<p>Android 12 整合了现有行为，让用户可以<a href="https://developer.android.com/training/system-ui/immersive?hl=zh-cn#immersive-consolidated-behavior" rel="nofollow" title="在沉浸模式下更轻松地执行手势导航命令">在沉浸模式下更轻松地执行手势导航命令</a>。此外，Android 12 还为<a href="https://developer.android.com/training/system-ui/immersive?hl=zh-cn#sticky-immersive-compat-android11-lower" rel="nofollow" title="粘性沉浸模式提供了向后兼容性行为">粘性沉浸模式提供了向后兼容性行为</a>。</p> 
<h4 id="displaymetrics">Display#getRealSize 和 getRealMetrics：废弃和限制</h4> 
<p>Android 设备有许多不同的外形规格，如大屏设备、平板电脑和可折叠设备。为了针对每种设备适当地呈现内容，您的应用需要确定屏幕或显示屏尺寸。随着时间的推移，Android 提供了不同的 API 来检索这些信息。在 Android 11 中，我们引入了 <a href="https://developer.android.com/reference/android/view/WindowMetrics?hl=zh-cn" rel="nofollow" title="WindowMetrics">WindowMetrics</a> API 并废弃了以下方法：</p> 
<ul><li><a href="https://developer.android.com/reference/android/view/Display?hl=zh-cn#getSize%28android.graphics.Point%29" rel="nofollow" title="Display.getSize()">Display.getSize()</a></li><li><a href="https://developer.android.com/reference/android/view/Display?hl=zh-cn#getMetrics%28android.util.DisplayMetrics%29" rel="nofollow" title="Display.getMetrics()">Display.getMetrics()</a></li></ul> 
<p>在 Android 12 中，我们继续建议使用 <code>WindowMetrics</code>，并且正在逐步废弃以下方法：</p> 
<ul><li><a href="https://developer.android.com/reference/android/view/Display?hl=zh-cn#getRealSize%28android.graphics.Point%29" rel="nofollow" title="Display.getRealSize()">Display.getRealSize()</a></li><li><a href="https://developer.android.com/reference/android/view/Display?hl=zh-cn#getRealMetrics%28android.util.DisplayMetrics%29" rel="nofollow" title="Display.getRealMetrics()">Display.getRealMetrics()</a></li></ul> 
<p>为了缓解应用使用 Display API 检索应用边界的行为，Android 12 限制了 API 为不完全可调整大小的应用返回的值。这可能会对将此信息与 <code>MediaProjection</code> 一起使用的应用产生影响。</p> 
<p>应用应使用 <code>WindowMetrics</code> API 查询其窗口的边界，并使用 <a href="https://developer.android.com/reference/android/content/res/Configuration?hl=zh-cn#densityDpi" rel="nofollow" title="Configuration.densityDpi">Configuration.densityDpi</a> 查询当前的密度。</p> 
<p>为了与较低的 Android 版本实现更广泛的兼容性，您可以使用 Jetpack <a href="https://developer.android.com/jetpack/androidx/releases/window?hl=zh-cn" rel="nofollow" title="WindowManager">WindowManager</a> 库，它包含一个 <a href="https://developer.android.com/reference/androidx/window/layout/WindowMetrics?hl=zh-cn" rel="nofollow" title="WindowMetrics">WindowMetrics</a> 类，该类支持 Android 4.0（API 级别 14）及更高版本。</p> 
<p>关于如何使用 WindowMetrics 的示例</p> 
<p>首先，确保应用的 activity <a href="https://developer.android.com/guide/topics/ui/multi-window?hl=zh-cn" rel="nofollow" title="完全可调整大小">完全可调整大小</a>。</p> 
<p>activity 应依赖于来自 activity 上下文的 <code>WindowMetrics</code> 来执行任何与界面相关的工作，尤其是 <a href="https://developer.android.com/reference/android/view/WindowManager?hl=zh-cn#getCurrentWindowMetrics%28%29" rel="nofollow" title="WindowManager.getCurrentWindowMetrics()">WindowManager.getCurrentWindowMetrics()</a> 或 Jetpack 的 <a href="https://developer.android.com/reference/androidx/window/layout/WindowMetricsCalculator?hl=zh-cn#computeCurrentWindowMetrics%28android.app.Activity%29" rel="nofollow" title="WindowMetricsCalculator.computeCurrentWindowMetrics()">WindowMetricsCalculator.computeCurrentWindowMetrics()</a>。</p> 
<p>如果您的应用创建了 <code>MediaProjection</code>，则必须正确地调整边界的大小，因为投影会捕获运行投影仪应用的显示分区。</p> 
<p>如果应用完全可调整大小，则 activity 上下文会返回正确的边界，如下所示：</p> 
<p><a href="https://developer.android.com/about/versions/12/behavior-changes-all?hl=zh-cn#kotlin" rel="nofollow" id="aria-tab-kotlin" title="Kotlin">Kotlin</a><a href="https://developer.android.com/about/versions/12/behavior-changes-all?hl=zh-cn#java" rel="nofollow" id="aria-tab-java" title="Java">Java</a></p> 
<p></p> 
<pre>WindowMetrics projectionMetrics = activityContext
      .getSystemService(WindowManager.class).getMaximumWindowMetrics();
</pre> 
<p>如果应用并非完全可调整大小，则它必须从 <code>WindowContext</code> 实例进行查询，并使用 <a href="https://developer.android.com/reference/android/view/WindowManager?hl=zh-cn#getMaximumWindowMetrics%28%29" rel="nofollow" title="WindowManager.getMaximumWindowMetrics()">WindowManager.getMaximumWindowMetrics()</a> 或 Jetpack 方法 <a href="https://developer.android.com/reference/androidx/window/layout/WindowMetricsCalculator?hl=zh-cn#computeMaximumWindowMetrics%28android.app.Activity%29" rel="nofollow" title="WindowMetricsCalculator.computeMaximumWindowMetrics()">WindowMetricsCalculator.computeMaximumWindowMetrics()</a> 检索 activity 边界的 <code>WindowMetrics</code>。</p> 
<p><a href="https://developer.android.com/about/versions/12/behavior-changes-all?hl=zh-cn#kotlin" rel="nofollow" title="Kotlin">Kotlin</a><a href="https://developer.android.com/about/versions/12/behavior-changes-all?hl=zh-cn#java" rel="nofollow" title="Java">Java</a></p> 
<p></p> 
<pre>Context windowContext = context.createWindowContext(mContext.getDisplay(),
      WindowManager.LayoutParams.TYPE_APPLICATION, null);
WindowMetrics projectionMetrics = windowContext.getSystemService(WindowManager.class)
      .getMaximumWindowMetrics();
</pre> 
<p><strong>注意</strong>：任何使用 <code>MediaProjection</code> 的库也应遵循这些建议，并查询相应的<code>WindowMetrics</code>。</p> 
<h4 id="multi-window-mode">多窗口模式下的所有应用</h4> 
<p>Android 12 将多窗口模式作为标准行为。</p> 
<p>在大屏设备 (sw &gt;= 600dp) 中，所有应用都将在多窗口模式下运行，无论应用配置为何。如果 <a href="https://developer.android.com/guide/topics/manifest/application-element?hl=zh-cn#resizeableActivity" rel="nofollow" title='resizeableActivity="false"'>resizeableActivity="false"</a>，应用会在必要时进入兼容模式，以适应显示屏尺寸。</p> 
<p>在小屏设备 (sw &lt; 600dp) 中，系统会检查 activity 的 <a href="https://developer.android.com/reference/android/content/pm/ActivityInfo.WindowLayout?hl=zh-cn#attr_android:minWidth" rel="nofollow" title="minWidth">minWidth</a> 和 <a href="https://developer.android.com/reference/android/content/pm/ActivityInfo.WindowLayout?hl=zh-cn#attr_android:minHeight" rel="nofollow" title="minHeight">minHeight</a>，来确定 activity 能否在多窗口模式下运行。如果 <a href="https://developer.android.com/guide/topics/manifest/application-element?hl=zh-cn#resizeableActivity" rel="nofollow" title='resizeableActivity="false"'>resizeableActivity="false"</a>，则无论最小宽度和高度如何，应用都无法在多窗口模式下运行。</p> 
<p>如需了解详情，请参阅<a href="https://developer.android.com/guide/topics/ui/multi-window?hl=zh-cn" rel="nofollow" title="多窗口模式支持">多窗口模式支持</a>。</p> 
<h4 id="camera-preview">大屏设备上的相机预览</h4> 
<p>相机应用通常假定设备的屏幕方向和相机预览的宽高比呈固定关系。但是，大屏设备类型（例如可折叠设备）和显示模式（例如多窗口和多屏幕）挑战着这一假设。</p> 
<p>在 Android 12 上，请求特定屏幕方向且不可调整大小 (<code>resizeableActivity="false"</code>) 的相机应用会自动进入边衬区人像模式，从而确保相机预览的屏幕方向和宽高比正确。在可折叠设备和其他具有相机硬件抽象层 (<a href="https://source.android.com/devices/camera?hl=zh-cn" rel="nofollow" title="HAL">HAL</a>) 的设备上，会对相机输出应用额外的旋转以补偿相机传感器方向，并会剪裁相机输出以匹配应用相机预览的宽高比。无论设备屏幕方向如何以及设备是处于折叠状态还是展开状态，剪裁和额外的旋转可确保应用正确呈现相机预览。</p> 
<h4 id="foreground-service-notification-delay">前台服务通知的用户体验延迟</h4> 
<p>除了<a href="https://developer.android.com/guide/components/foreground-services?hl=zh-cn#notification-immediate" rel="nofollow" title="一些例外情况">一些例外情况</a>之外，为了为短时间运行的<a href="https://developer.android.com/guide/components/foreground-services?hl=zh-cn" rel="nofollow" title="前台服务">前台服务</a>提供流畅体验，搭载 Android 12 或更高版本的设备可以将前台服务通知的显示延迟 10 秒。此更改使某些短期任务可在显示通知之前完成。</p> 
<h3 id="performance">性能</h3> 
<h4 id="restrictive-app-standby-bucket">受限应用待机模式存储分区</h4> 
<p>Android 11（API 级别 30）引入了<a href="https://developer.android.com/topic/performance/appstandby?hl=zh-cn#restricted-bucket" rel="nofollow" title="受限存储分区">受限存储分区</a>作为应用待机模式存储分区。从 Android 12 开始，此存储分区默认处于活跃状态。在所有存储分区中，受限存储分区的优先级最低（限制最高）。存储分区按优先级从高到低的顺序排列如下：</p> 
<ol><li>活跃：应用目前正在使用中，或者最近刚刚使用过。</li><li>工作集：会定期使用应用。</li><li>常用：会经常使用应用，但不是每天都使用。</li><li>极少使用：不经常使用应用。</li><li>受限：应用会消耗大量的系统资源，或表现出不良行为。</li></ol> 
<p>除了使用模式之外，系统还会考虑应用的行为，以决定是否要将您的应用放在受限存储分区中。</p> 
<p>如果您的应用更负责地使用系统资源，就不太可能被放在受限存储分区中。此外，如果用户直接与您的应用互动，系统会将其放在一个限制较少的存储分区中。</p> 
<p>检查您的应用是否在受限存储分区中</p> 
<p>如需检查系统是否已将您的应用放在受限存储分区中，请调用 <a href="https://developer.android.com/reference/android/app/usage/UsageStatsManager?hl=zh-cn#getAppStandbyBucket%28%29" rel="nofollow" title="getAppStandbyBucket()">getAppStandbyBucket()</a>。如果此方法的返回值为 <code>STANDBY_BUCKET_RESTRICTED</code>，则您的应用在受限存储分区中。</p> 
<p>测试受限存储分区行为</p> 
<p>如需测试您的应用在系统将其放在受限存储分区中时的行为，您可以手动将您的应用移至该存储分区。为此，请在终端窗口中运行以下命令：</p> 
<p></p> 
<pre>adb shell am set-standby-bucket PACKAGE_NAME restricted
</pre> 
<h3 id="security-privacy">安全和隐私设置</h3> 
<h4 id="mic-camera-toggles">麦克风和摄像头切换开关</h4> 
<p>在搭载 Android 12 或更高版本的受支持设备上，用户可以通过按一个切换开关选项，为设备上的所有应用启用和停用摄像头和麦克风使用权限。用户可以从<a href="https://support.google.com/android/answer/9083864?hl=zh-cn" rel="nofollow" title="快捷设置">快捷设置</a>访问可切换的选项（如图 1 所示），也可以从系统设置中的“隐私设置”屏幕访问。</p> 
<p>详细了解这些<a href="https://developer.android.com/training/permissions/explaining-access?hl=zh-cn#toggles" rel="nofollow" title="切换开关">切换开关</a>以及如何检查您的应用是否遵循了关于 <a href="https://developer.android.com/reference/android/Manifest.permission?hl=zh-cn#CAMERA" rel="nofollow" title="CAMERA">CAMERA</a> 和 <a href="https://developer.android.com/reference/android/Manifest.permission?hl=zh-cn#RECORD_AUDIO" rel="nofollow" title="RECORD_AUDIO">RECORD_AUDIO</a> 权限的最佳实践。</p> 
<h4 id="mic-camera-indicators">麦克风和摄像头指示标志</h4> 
<p>在搭载 Android 12 或更高版本的设备上，当应用使用麦克风或相机时，图标会出现在状态栏中。</p> 
<p>详细了解这些<a href="https://developer.android.com/training/permissions/explaining-access?hl=zh-cn#indicators" rel="nofollow" title="指标">指标</a>以及如何检查您的应用是否遵循了关于 <a href="https://developer.android.com/reference/android/Manifest.permission?hl=zh-cn#CAMERA" rel="nofollow" title="CAMERA">CAMERA</a> 和 <a href="https://developer.android.com/reference/android/Manifest.permission?hl=zh-cn#RECORD_AUDIO" rel="nofollow" title="RECORD_AUDIO">RECORD_AUDIO</a> 权限的最佳实践。</p> 
<p></p> 
<p></p> 
<h4 id="permission-package-visibility">权限软件包可见性</h4> 
<p>在搭载 Android 12 或更高版本的设备上，根据应用对其他应用的<a href="https://developer.android.com/training/package-visibility?hl=zh-cn" rel="nofollow" title="软件包可见性">软件包可见性</a>，以 Android 11（API 级别 30）或更高版本为目标平台且调用以下某种方法的应用会收到一组过滤后的结果：</p> 
<ul><li><a href="https://developer.android.com/reference/android/content/pm/PackageManager?hl=zh-cn#getAllPermissionGroups%28int%29" rel="nofollow" title="getAllPermissionGroups()">getAllPermissionGroups()</a></li><li><a href="https://developer.android.com/reference/android/content/pm/PackageManager?hl=zh-cn#getPermissionGroupInfo%28java.lang.String,%20int%29" rel="nofollow" title="getPermissionGroupInfo()">getPermissionGroupInfo()</a></li><li><a href="https://developer.android.com/reference/android/content/pm/PackageManager?hl=zh-cn#getPermissionInfo%28java.lang.String,%20int%29" rel="nofollow" title="getPermissionInfo()">getPermissionInfo()</a></li><li><a href="https://developer.android.com/reference/android/content/pm/PackageManager?hl=zh-cn#queryPermissionsByGroup%28java.lang.String,%20int%29" rel="nofollow" title="queryPermissionsByGroup()">queryPermissionsByGroup()</a></li></ul> 
<h4 id="bouncy-castle">移除了 BouncyCastle 实现</h4> 
<p>Android 12 移除了之前弃用的加密算法的许多 <a href="https://www.bouncycastle.org/" rel="nofollow" title="BouncyCastle">BouncyCastle</a> 实现，包括所有 AES 算法。系统改用这些算法的 <a href="https://github.com/google/conscrypt" title="Conscrypt">Conscrypt</a> 实现。</p> 
<p>如果符合以下任何条件，则此变更会影响您的应用：</p> 
<ul><li><strong>您的应用使用 512 位的密钥大小</strong>。Conscrypt 不支持此密钥大小。如有必要，请更新您应用的加密逻辑以使用其他密钥大小。</li><li> <p><strong>您的应用将无效的密钥大小与 <code>KeyGenerator</code> 一起使用</strong>。与 BouncyCastle 相比，Conscrypt 的 <a href="https://developer.android.com/reference/javax/crypto/KeyGenerator?hl=zh-cn" rel="nofollow" title="KeyGenerator">KeyGenerator</a> 实现会对密钥参数执行额外的验证。例如，Conscrypt 不允许您的应用生成 64 位 AES 密钥，因为 AES 仅支持 128 位、192 位和 256 位密钥。</p> <p>BouncyCastle 允许生成大小无效的密钥，但如果稍后这些密钥与 <a href="https://developer.android.com/reference/javax/crypto/Cipher?hl=zh-cn" rel="nofollow" title="Cipher">Cipher</a> 一起使用，验证会失败。如果使用 Conscrypt，验证失败的时间会更早。</p> </li><li> <p><strong>您使用并非 12 字节的大小初始化伽罗瓦/计数器模式 (GCM) 加密</strong>。Conscrypt 的 <a href="https://developer.android.com/reference/javax/crypto/spec/GCMParameterSpec?hl=zh-cn" rel="nofollow" title="GcmParameterSpec">GcmParameterSpec</a> 实现要求初始化为 12 字节，这是 NIST 推荐的做法。</p> </li></ul> 
<h4 id="clipboard-access-notifications">剪贴板访问通知</h4> 
<p>在 Android 12 及更高版本中，当某个应用首次调用 <a href="https://developer.android.com/reference/android/content/ClipboardManager?hl=zh-cn#getPrimaryClip%28%29" rel="nofollow" title="getPrimaryClip()">getPrimaryClip()</a> 以<a href="https://developer.android.com/guide/topics/text/copy-paste?hl=zh-cn#Pasting" rel="nofollow" title="从另一个应用访问剪辑数据">从另一个应用访问剪辑数据</a>时，会弹出一个消息框消息，通知用户对剪贴板的访问。</p> 
<p>消息框消息内的文本包含以下格式：<code>APP pasted from your clipboard.</code></p> 
<p><strong>注意</strong>：您的应用可能会调用 <a href="https://developer.android.com/reference/android/content/ClipboardManager?hl=zh-cn#getPrimaryClipDescription%28%29" rel="nofollow" title="getPrimaryClipDescription()">getPrimaryClipDescription()</a> 以接收有关<a href="https://developer.android.com/guide/topics/text/copy-paste?hl=zh-cn#ClipClasses" rel="nofollow" title="剪贴板上当前数据的信息">剪贴板上当前数据的信息</a>。当您的应用调用此方法时，系统不会显示消息框消息。</p> 
<p>有关剪辑说明中文本的信息</p> 
<p>在 Android 12 及更高版本中，<code>getPrimaryClipDescription()</code> 可以检测到以下详细信息：</p> 
<ul><li>使用 <a href="https://developer.android.com/reference/android/content/ClipDescription?hl=zh-cn#isStyledText%28%29" rel="nofollow" title="isStyledText()">isStyledText()</a> 检测样式化文本。</li><li>使用 <a href="https://developer.android.com/reference/android/content/ClipDescription?hl=zh-cn#getConfidenceScore%28java.lang.String%29" rel="nofollow" title="getConfidenceScore()">getConfidenceScore()</a> 检测文本的不同分类，如网址。</li></ul> 
<h4 id="close-system-dialogs">应用无法关闭系统对话框</h4> 
<p>为了加强用户与应用和系统互动时的控制，从 Android 12 开始，弃用了 <a href="https://developer.android.com/reference/android/content/Intent?hl=zh-cn#ACTION_CLOSE_SYSTEM_DIALOGS" rel="nofollow" title="ACTION_CLOSE_SYSTEM_DIALOGS">ACTION_CLOSE_SYSTEM_DIALOGS</a> intent 操作。除了<a href="https://developer.android.com/about/versions/12/behavior-changes-all?hl=zh-cn#close-system-dialogs-exceptions" rel="nofollow" title="一些特殊情况">一些特殊情况</a>之外，当应用尝试<a href="https://developer.android.com/guide/components/intents-filters?hl=zh-cn" rel="nofollow" title="调用包含此操作的 intent">调用包含此操作的 intent</a> 时，系统会基于应用的目标 SDK 版本执行以下操作之一：</p> 
<ul><li>如果应用以 Android 12 或更高版本为目标平台，则会发生 <a href="https://developer.android.com/reference/java/lang/SecurityException?hl=zh-cn" rel="nofollow" title="SecurityException">SecurityException</a>。</li><li> <p>如果应用以 Android 11（API 级别 30）或更低版本为目标平台，则系统不会执行 intent，并且 <a href="https://developer.android.com/studio/command-line/logcat?hl=zh-cn" rel="nofollow" title="Logcat">Logcat</a> 中会显示以下消息：</p> <p></p> <pre>E ActivityTaskManager Permission Denial: \
android.intent.action.CLOSE_SYSTEM_DIALOGS broadcast from \
com.package.name requires android.permission.BROADCAST_CLOSE_SYSTEM_DIALOGS, \
dropping broadcast.
</pre> </li></ul> 
<p>例外情况</p> 
<p>在以下情况下，应用仍然可以在 Android 12 或更高版本上关闭系统对话框：</p> 
<ul><li>您的应用运行的是<a href="https://developer.android.com/training/testing/unit-testing/instrumented-unit-tests?hl=zh-cn" rel="nofollow" title="插桩测试">插桩测试</a>。</li><li> <p>您的应用以 Android 11 或更低版本为目标平台，并在<a href="https://material.io/design/platform-guidance/android-notifications#behavior" rel="nofollow" title="抽屉式通知栏">抽屉式通知栏</a>顶部显示一个窗口。</p> <p><strong>注意</strong>：如果您的应用以 Android 12 为目标平台，在这种情况下您无需使用 <code>ACTION_CLOSE_SYSTEM_DIALOGS</code>。这是因为，如果在窗口位于抽屉式通知栏的顶部时您的应用调用 <a href="https://developer.android.com/reference/android/content/Context?hl=zh-cn#startActivity%28android.content.Intent%29" rel="nofollow" title="startActivity()">startActivity()</a>，系统会自动关闭抽屉式通知栏。</p> </li><li> <p>您的应用以 Android 11 或更低版本为目标平台。此外，用户已与通知互动，可能使用了通知的<a href="https://developer.android.com/training/notify-user/build-notification?hl=zh-cn#Actions" rel="nofollow" title="操作按钮">操作按钮</a>，您的应用正在处理<a href="https://developer.android.com/guide/components/services?hl=zh-cn" rel="nofollow" title="服务">服务</a>或<a href="https://developer.android.com/guide/components/broadcasts?hl=zh-cn" rel="nofollow" title="广播接收器">广播接收器</a>来响应该用户操作。</p> </li><li> <p>您的应用以 Android 11 或更低版本为目标平台并且具有有效的<a href="https://developer.android.com/guide/topics/ui/accessibility/service?hl=zh-cn" rel="nofollow" title="无障碍服务">无障碍服务</a>。如果您的应用以 Android 12 为目标平台并且想要关闭通知栏，请改用 <a href="https://developer.android.com/reference/android/accessibilityservice/AccessibilityService?hl=zh-cn#GLOBAL_ACTION_DISMISS_NOTIFICATION_SHADE" rel="nofollow" title="GLOBAL_ACTION_DISMISS_NOTIFICATION_SHADE">GLOBAL_ACTION_DISMISS_NOTIFICATION_SHADE</a> 无障碍操作。</p> </li></ul> 
<h4 id="untrusted-touch-events">不受信任的触摸事件被屏蔽</h4> 
<p>为了维持系统安全并保持良好的用户体验，Android 12 会阻止应用使用<a href="https://developer.android.com/training/gestures?hl=zh-cn" rel="nofollow" title="触摸事件">触摸事件</a>，使用触摸事件时叠加层会以不安全的方式遮掩应用。 换言之，系统会屏蔽穿透某些窗口的触摸操作，但<a href="https://developer.android.com/about/versions/12/behavior-changes-all?hl=zh-cn#untrusted-touch-events-exceptions" rel="nofollow" title="有一些例外情况">有一些例外情况</a>。</p> 
<p>受影响的应用</p> 
<p>此变更会影响选择让触摸操作穿透其窗口的应用，例如使用 <a href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams?hl=zh-cn#FLAG_NOT_TOUCHABLE" rel="nofollow" title="FLAG_NOT_TOUCHABLE">FLAG_NOT_TOUCHABLE</a> 标志。包括但不限于以下示例：</p> 
<ul><li>需要 <a href="https://developer.android.com/reference/android/Manifest.permission?hl=zh-cn#SYSTEM_ALERT_WINDOW" rel="nofollow" title="SYSTEM_ALERT_WINDOW">SYSTEM_ALERT_WINDOW</a> 权限并使用 <code>FLAG_NOT_TOUCHABLE</code> 标志的叠加层，例如使用 <a href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams?hl=zh-cn#TYPE_APPLICATION_OVERLAY" rel="nofollow" title="TYPE_APPLICATION_OVERLAY">TYPE_APPLICATION_OVERLAY</a> 的窗口。</li><li>使用 <code>FLAG_NOT_TOUCHABLE</code> 标志的 activity 窗口。</li></ul> 
<p>例外情况</p> 
<p>在以下情况下，允许执行“穿透”触摸操作：</p> 
<ul><li><strong>应用中的互动</strong>。您的应用会显示叠加层，并且只有当用户与您的应用进行互动时才会显示叠加层。</li><li> <p><strong>可信窗口</strong>。包括但不限于以下窗口：</p> 
  <ul><li><a href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams?hl=zh-cn#TYPE_ACCESSIBILITY_OVERLAY" rel="nofollow" title="无障碍窗口">无障碍窗口</a></li><li><a href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams?hl=zh-cn#TYPE_INPUT_METHOD" rel="nofollow" title="输入法 (IME) 窗口">输入法 (IME) 窗口</a></li><li><a href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams?hl=zh-cn#FLAG_NOT_TOUCHABLE" rel="nofollow" title="Google 助理窗口">Google 助理窗口</a></li></ul><p><strong>注意</strong>：类型为 <a href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams?hl=zh-cn#TYPE_APPLICATION_OVERLAY" rel="nofollow" title="TYPE_APPLICATION_OVERLAY">TYPE_APPLICATION_OVERLAY</a> 的窗口<strong>不受</strong>信任。</p> </li><li> <p><strong>不可见窗口</strong>。窗口的根视图是 <a href="https://developer.android.com/reference/android/view/View?hl=zh-cn#GONE" rel="nofollow" title="GONE">GONE</a> 或 <a href="https://developer.android.com/reference/android/view/View?hl=zh-cn#INVISIBLE" rel="nofollow" title="INVISIBLE">INVISIBLE</a>。</p> </li><li> <p><strong>全透明窗口</strong>。窗口的 <a href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams?hl=zh-cn#alpha" rel="nofollow" title="alpha">alpha</a> 属性为 0.0。</p> </li><li> <p><strong>足够半透明的系统警报窗口</strong>。当组合后的不透明度小于或等于系统针对触摸的最大遮掩不透明度时，系统会将一组系统警报窗口视为足够半透明。在 Android 12 中，默认最大不透明度为 0.8。</p> </li></ul> 
<p>检测不受信任的触摸操作是否被屏蔽</p> 
<p>如果系统屏蔽触摸操作，<a href="https://developer.android.com/studio/command-line/logcat?hl=zh-cn" rel="nofollow" title="Logcat">Logcat</a> 会记录以下消息：</p> 
<p></p> 
<pre><code>Untrusted touch due to occlusion by PACKAGE_NAME
</code></pre> 
<p>测试变更</p> 
<p>在搭载 Android 12 或更高版本的设备上，不受信任的触摸功能默认被屏蔽。如需允许不受信任的触摸操作，请在终端窗口中运行以下 <a href="https://developer.android.com/studio/command-line/adb?hl=zh-cn" rel="nofollow" title="ADB 命令">ADB 命令</a>：</p> 
<p></p> 
<pre># A specific app
adb shell am compat disable BLOCK_UNTRUSTED_TOUCHES com.example.app

# All apps
# If you'd still like to see a Logcat message warning when a touch would be
# blocked, use 1 instead of 0.
adb shell settings put global block_untrusted_touches 0
</pre> 
<p>如需将行为还原为默认设置（不受信任的触摸操作被屏蔽），请运行以下命令：</p> 
<p></p> 
<pre># A specific app
adb shell am compat reset BLOCK_UNTRUSTED_TOUCHES com.example.app

# All apps
adb shell settings put global block_untrusted_touches 2
</pre> 
<h3 id="activity-lifecycle">activity 生命周期</h3> 
<h4 id="back-press">按下“返回”按钮时，不再完成根启动器 activity</h4> 
<p>Android 12 更改了在按下“返回”按钮时系统对为其任务根的启动器 activity 的默认处理方式。在以前的版本中，系统会在按下“返回”按钮时完成这些 activity。在 Android 12 中，现在系统会将 activity 及其任务移到后台，而不是完成 activity。当使用主屏幕按钮或手势从应用中导航出应用时，新行为与当前行为一致。</p> 
<p><strong>注意</strong>：系统仅会将新行为应用于为其任务根的启动器 activity，即使用 <a href="https://developer.android.com/reference/android/content/Intent?hl=zh-cn#ACTION_MAIN" rel="nofollow" title="ACTION_MAIN">ACTION_MAIN</a> 和 <a href="https://developer.android.com/reference/android/content/Intent?hl=zh-cn#CATEGORY_LAUNCHER" rel="nofollow" title="CATEGORY_LAUNCHER">CATEGORY_LAUNCHER</a> 声明 <a href="https://developer.android.com/reference/android/content/IntentFilter?hl=zh-cn" rel="nofollow" title="intent 过滤器">intent 过滤器</a>的 activity。对于其他 activity，在按下“返回”按钮时，系统会像以前一样完成 activity。</p> 
<p>对于大多数应用而言，此变更意味着使用“返回”按钮退出应用的用户可以更快地从<a href="https://developer.android.com/topic/performance/vitals/launch-time?hl=zh-cn#warm" rel="nofollow" title="温状态">温状态</a>恢复应用，而不必从<a href="https://developer.android.com/topic/performance/vitals/launch-time?hl=zh-cn#cold" rel="nofollow" title="冷状态">冷状态</a>完全重启应用。</p> 
<p>建议您针对此变更测试您的应用。如果您的应用目前替换 <a href="https://developer.android.com/reference/android/app/Activity?hl=zh-cn#onBackPressed%28%29" rel="nofollow" title="onBackPressed()">onBackPressed()</a> 来处理返回导航并完成 <code>Activity</code>，请更新您的实现来调用 <code>super.onBackPressed()</code> 而不是完成 Activity。调用 <code>super.onBackPressed()</code> 可在适当时将 activity 及其任务移至后台，并可为不同应用中的用户提供更一致的导航体验。</p> 
<p>另请注意，通常，我们建议您使用 AndroidX Activity API <a href="https://developer.android.com/guide/navigation/navigation-custom-back?hl=zh-cn" rel="nofollow" title="提供自定义返回导航">提供自定义返回导航</a>，而不是替换 <code>onBackPressed()</code>。如果没有组件拦截系统按下“返回”按钮，AndroidX Activity API 会自动遵循适当的系统行为。</p> 
<h3 id="graphics">图形和图片</h3> 
<h4 id="refresh-rate">改进了刷新率切换</h4> 
<p>在 Android 12 中，无论显示屏是否支持无缝过渡到新的刷新率，都会发生使用 <a href="https://developer.android.com/reference/android/view/Surface?hl=zh-cn#setFrameRate%28float,%20int,%20boolean%29" rel="nofollow" title="setFrameRate()">setFrameRate()</a> 实现的刷新率变化；无缝过渡是指没有任何视觉中断，比如一两秒钟的黑屏。以前，如果显示屏不支持无缝过渡，它在调用 <code>setFrameRate()</code> 后通常会继续使用同一刷新率。您可以调用 <a href="https://developer.android.com/reference/android/view/Display.Mode?hl=zh-cn#getAlternativeRefreshRates%28%29" rel="nofollow" title="getAlternativeRefreshRates()">getAlternativeRefreshRates()</a> 来提前确定向新刷新率的过渡是否有可能是无缝过渡。通常，会在刷新率切换完成后调用回调 <a href="https://developer.android.com/reference/android/hardware/display/DisplayManager.DisplayListener?hl=zh-cn#onDisplayChanged%28int%29" rel="nofollow" title="onDisplayChanged()">onDisplayChanged()</a>，但对于某些外接显示屏，会在非无缝过渡期间调用该回调。</p> 
<p>以下示例说明了您可以如何实现此行为：</p> 
<p><a href="https://developer.android.com/about/versions/12/behavior-changes-all?hl=zh-cn#kotlin" rel="nofollow" title="Kotlin">Kotlin</a><a href="https://developer.android.com/about/versions/12/behavior-changes-all?hl=zh-cn#java" rel="nofollow" title="Java">Java</a></p> 
<p></p> 
<pre>// Determine whether the transition will be seamless.
// Non-seamless transitions may cause a 1-2 second black screen.
Display display = context.getDisplay(); // API 30+
Display.Mode mode = display.getMode();
float[] refreshRates = mode.getAlternativeRefreshRates();
boolean willbeSeamless = Arrays.asList(refreshRates).contains(newRefreshRate);

// Set the frame rate even if the transition will not be seamless.
surface.setFrameRate(newRefreshRate, FRAME_RATE_COMPATIBILITY_FIXED_SOURCE, CHANGE_FRAME_RATE_ALWAYS);
</pre> 
<h3 id="connectivity">连接性</h3> 
<h4 id="passpoint-updates">Passpoint 更新</h4> 
<p>Android 12 中添加了以下 API：</p> 
<ul><li><a href="https://developer.android.com/reference/android/net/wifi/WifiManager?hl=zh-cn#isPasspointTermsAndConditionsSupported%28%29" rel="nofollow" title="isPasspointTermsAndConditionsSupported()">isPasspointTermsAndConditionsSupported()</a>：“条款及条件”是一项 <a href="https://developer.android.com/guide/topics/connectivity/passpoint?hl=zh-cn" rel="nofollow" title="Passpoint">Passpoint</a> 功能，允许网络部署将不安全的强制门户（使用开放网络）替换为安全的 Passpoint 网络。当要求用户接受条款及条件时，系统会向用户显示一条通知。如果应用建议的 Passpoint 网络受条款及条件制约，应用必须先调用此 API，以确保设备支持该功能。如果设备不支持该功能，就不能连接到此网络，并且必须建议一个替代网络或旧网络。</li><li> <p><a href="https://developer.android.com/reference/android/net/wifi/WifiManager?hl=zh-cn#isDecoratedIdentitySupported%28%29" rel="nofollow" title="isDecoratedIdentitySupported()">isDecoratedIdentitySupported()</a>：对带有前缀修饰的网络进行身份验证时，修饰的身份前缀允许网络运营商更新网络访问标识符 (NAI)，以通过 AAA 网络内的多个代理执行显式路由（如需详细了解这一点，请参阅 <a href="https://datatracker.ietf.org/doc/html/rfc7542" rel="nofollow" title="RFC 7542">RFC 7542</a>）。</p> <p>Android 12 实现了此功能，以符合 <a href="https://wballiance.com/wp-content/uploads/2021/03/WBA-PPS-MO-Extensions-v1.0.0.pdf" rel="nofollow" title="PPS-MO 扩展的 WBA 规范">PPS-MO 扩展的 WBA 规范</a>。如果应用建议的 Passpoint 网络需要修饰的身份，应用必须先调用此 API，以确保设备支持该功能。如果设备不支持该功能，身份就不会进行修饰，并且对网络的身份验证可能会失败。</p> </li></ul> 
<p>如需创建 Passpoint 建议，应用必须使用 <a href="https://developer.android.com/reference/android/net/wifi/hotspot2/PasspointConfiguration?hl=zh-cn" rel="nofollow" title="PasspointConfiguration">PasspointConfiguration</a>、<a href="https://developer.android.com/reference/android/net/wifi/hotspot2/pps/Credential?hl=zh-cn" rel="nofollow" title="Credential">Credential</a> 和 <a href="https://developer.android.com/reference/android/net/wifi/hotspot2/pps/HomeSp?hl=zh-cn" rel="nofollow" title="HomeSp">HomeSp</a> 类。这些类描述了 <a href="https://www.wi-fi.org/downloads-registered-guest/Passpoint_Specification_Package_v3.2.zip/35974" rel="nofollow" title="Wi-Fi Alliance Passpoint 规范">Wi-Fi Alliance Passpoint 规范</a>中定义的 Passpoint 配置文件。</p> 
<p>如需了解详情，请参阅<a href="https://developer.android.com/guide/topics/connectivity/wifi-suggest?hl=zh-cn" rel="nofollow" title="适用于互联网连接的 Wi-Fi 建议 API">适用于互联网连接的 Wi-Fi 建议 API</a>。</p> 
<h3 id="non-sdk-restrictions">更新后的非 SDK 接口限制</h3> 
<p>Android 12 包含更新后的受限制非 SDK 接口列表（基于与 Android 开发者之间的协作以及最新的内部测试）。在限制使用非 SDK 接口之前，我们会尽可能确保有可用的公开替代方案。</p> 
<p>如果您的应用并非以 Android 12 为目标平台，其中一些变更可能不会立即对您产生影响。然而，虽然您目前仍可以使用一些非 SDK 接口（<a href="https://developer.android.com/guide/app-compatibility/restrictions-non-sdk-interfaces?hl=zh-cn#list-names" rel="nofollow" title="具体取决于应用的目标 API 级别">具体取决于应用的目标 API 级别</a>），但只要您使用任何非 SDK 方法或字段，终归存在导致应用出问题的显著风险。</p> 
<p>如果您不确定自己的应用是否使用了非 SDK 接口，则可以<a href="https://developer.android.com/guide/app-compatibility/restrictions-non-sdk-interfaces?hl=zh-cn#test-for-non-sdk" rel="nofollow" title="测试您的应用">测试您的应用</a>来进行确认。如果您的应用依赖于非 SDK 接口，您应该开始计划迁移到 SDK 替代方案。然而，我们知道某些应用具有使用非 SDK 接口的有效用例。如果您无法为应用中的某项功能找到使用非 SDK 接口的替代方案，应<a href="https://developer.android.com/guide/app-compatibility/restrictions-non-sdk-interfaces?hl=zh-cn#feature-request" rel="nofollow" title="请求新的公共 API">请求新的公共 API</a>。</p> 
<p>如需详细了解此 Android 版本中的变更，请参阅 <a href="https://developer.android.com/about/versions/12/non-sdk-12?hl=zh-cn" rel="nofollow" title="Android 12 中有关限制非 SDK 接口的更新">Android 12 中有关限制非 SDK 接口的更新</a>。如需全面了解有关非 SDK 接口的详细信息，请参阅<a href="https://developer.android.com/guide/app-compatibility/restrictions-non-sdk-interfaces?hl=zh-cn" rel="nofollow" title="对非 SDK 接口的限制">对非 SDK 接口的限制</a>。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/10f0ebb51438baf1dc10c9b0d81e57d5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">No matching distribution found for panda（cmd中安装panda时报错）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ba01c51763b77d6b0dc4efa738021e70/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux内核的ip头校验和测试</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>