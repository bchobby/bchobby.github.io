<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mysql性能优化2 设计规范 设计原则 结构优化 拆分 配置优化 执行顺序 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mysql性能优化2 设计规范 设计原则 结构优化 拆分 配置优化 执行顺序" />
<meta property="og:description" content="一、MYSQL数据库设计规范 1、数据库命名规范 a、采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’_&#39;组成;
b、命名简洁明确(长度不能超过30个字符);
c、例如：user, stat, log, 也可以wifi_user, wifi_stat, wifi_log给数据库加个前缀;
d、除非是备份数据库可以加0-9的自然数：user_db_20151210;
2、数据库表名命名规范 a、采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’‘组成;
b、命名简洁明确,多个单词用下划线’&#39;分隔;
例如：user_login, user_profile, user_detail, user_role, user_role_relation,
user_role_right, user_role_right_relation
注：表前缀’user_&#39;可以有效的把相同关系的表显示在一起;
3、数据库表字段名命名规范 a、采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’‘组成;
b、命名简洁明确,多个单词用下划线’&#39;分隔;
例如：user_login表字段 user_id, user_name, pass_word, eamil, tickit, status, mobile, add_time;
c、每个表中必须有自增主键,add_time(默认系统时间)
d、表与表之间的相关联字段名称要求尽可能的相同;
4、数据库表字段类型规范 用尽量少的存储空间来存数一个字段的数据;
例如：能使用int就不要使用varchar、char,能用varchar(16)就不要使用varchar(256);
IP地址最好使用int类型;
固定长度的类型最好使用char,例如：邮编;
能使用tinyint就不要使用smallint,int;
最好给每个字段一个默认值,最好不能为null;
5、数据库表索引规范 命名简洁明确,例如：user_login表user_name字段的索引应为user_name_index唯一索引;
为每个表创建一个主键索引;
为每个表创建合理的索引;
建立复合索引请慎重;
6、简单熟悉数据库范式 1、第一范式(1NF)：字段值具有原子性,不能再分(所有关系型数据库系统都满足第一范式);
例如：姓名字段,其中姓和名是一个整体,如果区分姓和名那么必须设立两个独立字段;
2、第二范式(2NF)：一个表必须有主键,即每行数据都能被唯一的区分;
备注：必须先满足第一范式;
3、第三范式(3NF)：一个表中不能包涵其他相关表中非关键字段的信息,即数据表不能有沉余字段;
备注：必须先满足第二范式;
备注：往往我们在设计表中不能遵守第三范式,因为合理的沉余字段将会给我们减少join的查询;
例如：相册表中会添加图片的点击数字段,在相册图片表中也会添加图片的点击数字段;
二、MYSQL数据库设计原则 1、核心原则 不在数据库做运算;
cpu计算务必移至业务层;
控制列数量(字段少而精,字段数建议在20以内);
平衡范式与冗余(效率优先；往往牺牲范式)
拒绝3B(拒绝大sql语句：big sql、拒绝大事务：big transaction、拒绝大批量：big batch);
2、字段类原则 用好数值类型(用合适的字段类型节约空间);" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/d0dc634d741a215481276664d3bd1d7c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-22T15:47:13+08:00" />
<meta property="article:modified_time" content="2019-06-22T15:47:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mysql性能优化2 设计规范 设计原则 结构优化 拆分 配置优化 执行顺序</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="MYSQL_0"></a>一、MYSQL数据库设计规范</h2> 
<h3><a id="1_2"></a>1、数据库命名规范</h3> 
<p>a、采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’_'组成;<br> b、命名简洁明确(长度不能超过30个字符);<br> c、例如：user, stat, log, 也可以wifi_user, wifi_stat, wifi_log给数据库加个前缀;<br> d、除非是备份数据库可以加0-9的自然数：user_db_20151210;</p> 
<h3><a id="2_9"></a>2、数据库表名命名规范</h3> 
<p>a、采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’<em>‘组成;<br> b、命名简洁明确,多个单词用下划线’</em>'分隔;<br> 例如：user_login, user_profile, user_detail, user_role, user_role_relation,<br> user_role_right, user_role_right_relation<br> 注：表前缀’user_'可以有效的把相同关系的表显示在一起;</p> 
<h3><a id="3_17"></a>3、数据库表字段名命名规范</h3> 
<p>a、采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’<em>‘组成;<br> b、命名简洁明确,多个单词用下划线’</em>'分隔;<br> 例如：user_login表字段 user_id, user_name, pass_word, eamil, tickit, status, mobile, add_time;<br> c、每个表中必须有自增主键,add_time(默认系统时间)<br> d、表与表之间的相关联字段名称要求尽可能的相同;</p> 
<h3><a id="4_25"></a>4、数据库表字段类型规范</h3> 
<p>用尽量少的存储空间来存数一个字段的数据;<br> 例如：能使用int就不要使用varchar、char,能用varchar(16)就不要使用varchar(256);<br> IP地址最好使用int类型;<br> 固定长度的类型最好使用char,例如：邮编;<br> 能使用tinyint就不要使用smallint,int;<br> 最好给每个字段一个默认值,最好不能为null;</p> 
<h3><a id="5_34"></a>5、数据库表索引规范</h3> 
<p>命名简洁明确,例如：user_login表user_name字段的索引应为user_name_index唯一索引;<br> 为每个表创建一个主键索引;<br> 为每个表创建合理的索引;<br> 建立复合索引请慎重;</p> 
<h3><a id="6_41"></a>6、简单熟悉数据库范式</h3> 
<p>1、第一范式(1NF)：字段值具有原子性,不能再分(所有关系型数据库系统都满足第一范式);<br> 例如：姓名字段,其中姓和名是一个整体,如果区分姓和名那么必须设立两个独立字段;</p> 
<p>2、第二范式(2NF)：一个表必须有主键,即每行数据都能被唯一的区分;<br> 备注：必须先满足第一范式;<br> 3、第三范式(3NF)：一个表中不能包涵其他相关表中非关键字段的信息,即数据表不能有沉余字段;<br> 备注：必须先满足第二范式;<br> 备注：往往我们在设计表中不能遵守第三范式,因为合理的沉余字段将会给我们减少join的查询;<br> 例如：相册表中会添加图片的点击数字段,在相册图片表中也会添加图片的点击数字段;</p> 
<h2><a id="MYSQL_53"></a>二、MYSQL数据库设计原则</h2> 
<h3><a id="1_55"></a>1、核心原则</h3> 
<p>不在数据库做运算;<br> cpu计算务必移至业务层;<br> 控制列数量(字段少而精,字段数建议在20以内);<br> 平衡范式与冗余(效率优先；往往牺牲范式)<br> 拒绝3B(拒绝大sql语句：big sql、拒绝大事务：big transaction、拒绝大批量：big batch);</p> 
<h3><a id="2_63"></a>2、字段类原则</h3> 
<p>用好数值类型(用合适的字段类型节约空间);<br> 字符转化为数字(能转化的最好转化,同样节约空间、提高查询性能);<br> 避免使用NULL字段(NULL字段很难查询优化、NULL字段的索引需要额外空间、NULL字段的复合索引无效);<br> 少用text类型(尽量使用varchar代替text字段);</p> 
<h3><a id="3_70"></a>3、索引类原则</h3> 
<p>合理使用索引(改善查询,减慢更新,索引一定不是越多越好);<br> 字符字段必须建前缀索引;<br> 不在索引做列运算;<br> innodb主键推荐使用自增列(主键建立聚簇索引,主键不应该被修改,字符串不应该做主键)(理解Innodb的索引保存结构就知道了);<br> 不用外键(由程序保证约束);</p> 
<h3><a id="4sql_78"></a>4、sql类原则</h3> 
<p>sql语句尽可能简单(一条sql只能在一个cpu运算,大语句拆小语句,减少锁时间,一条大sql可以堵死整个库);<br> 简单的事务;<br> 避免使用trig/func(触发器、函数不用客户端程序取而代之);<br> 不用select <em>(消耗cpu,io,内存,带宽,这种程序不具有扩展性);<br> OR改写为IN(or的效率是n级别);<br> OR改写为UNION(mysql的索引合并很弱智);<br> select id from t where phone = ’159′ or name = ‘john’;<br> =&gt;<br> select id from t where phone=’159′<br> union<br> select id from t where name=’jonh’<br> 避免负向%;<br> 慎用count(</em>);<br> limit高效分页(limit越大，效率越低);<br> 使用union all替代union(union有去重开销);<br> 少用连接join;<br> 使用group by;<br> 请使用同类型比较;<br> 打散批量更新;</p> 
<h2><a id="_100"></a>三、数据库结构的优化</h2> 
<h3><a id="1_102"></a>1、选择合适的数据类型</h3> 
<p>1、数据类型选择<br> 数据类型的选择，重点在于“合适”二字，如何确定选择的数据类型是否合适了？<br> 1、使用可以存下你的数据的最小的数据类型。（时间类型数据：可以使用varchar类型，可以使用int类型，也可以使用时间戳类型）<br> 2、使用简单的数据类型，int要比varchar类型在mysql处理上简单。（int类型存储时间是最好的选择）<br> 3、尽可能的使用not null定义字段。（innodb的特性所决定，非not null的值，需要额外的在字段存储，同时也会增加IO和存储的开销）<br> 4、尽量少用text类型，非用不可时最好考虑分表。</p> 
<h3><a id="2_111"></a>2、案例</h3> 
<pre><code>案例一：int类型存储时间-时间转换
	使用int来存储日期时间，利用FROM_UNIXTIME(),UNIX_TIMESTAMP()两个函数来进行转换。
</code></pre> 
<p>创建表：</p> 
<pre><code>create table test(
id int auto_increment not null,
timestr int ,
primary key(id)
);
</code></pre> 
<p>导入数据：</p> 
<pre><code>insert into test (timestr) values (unix_timestamp('2018-05-29 16:00:00'));
</code></pre> 
<p>查询数据：如下图所示：<img src="https://images2.imgbox.com/32/9a/2WmybICk_o.png" alt="在这里插入图片描述"><br> 时间进行转换：</p> 
<pre><code>select FROM_UNIXTIME(timestr) from test;
</code></pre> 
<p><img src="https://images2.imgbox.com/67/d9/Pd7wfGq6_o.png" alt="在这里插入图片描述"><br> 结论：<br> 1、unix_timestamp()函数是将日期格式的数据转换为int类型<br> 2、FROM_UNIXTIME(timestr)函数是将int类型转换为时间格式<br> 案例二：ip地址的存储<br> 在我们的外部应用中，都要记录ip地址，大部分场合都是varchar（15）进行存储，就需要15个字节进行存储，但是bigint只需要8个字节进行存储，当数据量很大的时候（千万级别的数据），相差7个字节，但是不能小看这7个字节，给大家算一下。<img src="https://images2.imgbox.com/e2/d9/zzGKA9RS_o.png" alt="在这里插入图片描述">一个字段就多这么多，那如果我们这样的字段需要上万个字段了？是需要很多的存储空间的。<br> 使用bigint（8）来存储ip地址，利用INET_ATON(),INET_NTOA()两个函数来进行转换。<br> 创建表：</p> 
<pre><code>create table sessions(
id int auto_increment not null,
ipaddress bigint,
primary key (id)
);
</code></pre> 
<p>导入数据：</p> 
<pre><code>insert into sessions (ipaddress)values (inet_aton('192.168.0.1'));
</code></pre> 
<p>转换：</p> 
<pre><code>select inet_ntoa(ipaddress) from sessions;  
</code></pre> 
<p><img src="https://images2.imgbox.com/c7/0f/K1H61Z77_o.png" alt="在这里插入图片描述"><br> 检索:<img src="https://images2.imgbox.com/a7/7d/OgGv9X6U_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_158"></a>2、数据库表的范式化优化</h3> 
<p><strong>1、表范式化</strong><br> 范式化是指数据库设计的规范，目前说道范式化一般是指第三设计范式。也就是要求数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式。<img src="https://images2.imgbox.com/08/2e/GUOTD7M1_o.png" alt="在这里插入图片描述"><br> 存在以下传递函数依赖关系：<br> （商品名称）-&gt;（分类）-&gt;（分类描述）<br> 也就是说存在非关键字段 “分类描述”对关键字段“商品名称”的传递函数依赖。</p> 
<p>不符合第三范式要求的表存在以下问题：<br> 1、数据冗余：（分类，分类描述）对于每一个商品都会进行记录。<br> 2、数据的插入异常<br> 3、数据的更新异常<br> 4、数据的删除异常（删除所有数据，分类和分类描述都会删除，没有所有的记录）</p> 
<p>如何转换成符合第三范式的表（拆分表）：<br> 将原来的不符合第三范式的表拆分为3个表<br> 商品表、分类表、分类和商品的关系表<img src="https://images2.imgbox.com/70/bb/uYYds0xO_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_176"></a>2、反范式化</h3> 
<p>反范式化是指为了查询效率的考虑把原本符合第三范式的表“适当”的增加冗余，以达到优化查询效率的目的，反范式化是一种以空间来换取时间的操作。<img src="https://images2.imgbox.com/55/d4/pdAtvdx2_o.png" alt="在这里插入图片描述"><br> 如何查询订单信息？</p> 
<pre><code>select b.用户名，b.电话，b.地址，a.订单ID，sum（c.商品价格*c.商品数量）as 订单价格
from 订单表 as a
join 用户表 as b on a.用户ID=b.订单ID
join 订单商品表 as c on c.订单ID=b.订单ID
group by b.用户名，b.电话，b.地址，a.订单ID
</code></pre> 
<p>对于这样的表结构，对于sum（），group by会产生临时表，增加IO量。我们怎么优化都效率不高，那我们怎么样才能让它效率高了，就需要一些字段进行冗余。<br> <img src="https://images2.imgbox.com/3e/de/RR4wL1lI_o.png" alt="在这里插入图片描述"><br> 订单表中增加了冗余字段，那SQL该怎么写了？</p> 
<pre><code>select a.用户名，a.电话，a.地址，a.订单ID,a.订单价格 
from 订单表 as a
</code></pre> 
<p>说明：表结构的设计直接涉及到SQL的查询效率及优化。</p> 
<h2><a id="3_198"></a>3、数据库表的垂直拆分</h2> 
<h3><a id="1_200"></a>1、垂直拆分定义</h3> 
<pre><code>所谓的垂直拆分，就是把原来一个有很多列的表拆分成多个表，这解决了表的宽度问题。
</code></pre> 
<h3><a id="2_204"></a>2、垂直拆分原则</h3> 
<p>通常垂直拆分可以按以下原则进行：<br> 1、把不常用的字段表单独存放到一个表中。<br> 2、把大字段独立存放到一个表中。<br> 3、把经常一起使用的字段放到一起。<br> 例子：以film表为例<img src="https://images2.imgbox.com/ef/46/AI0hXsdl_o.png" alt="在这里插入图片描述"><br> 在该表中，title和description这两个字段占空间比较大，况且在使用频率也比较低，因此可以将其提取出来，将上面的一个达标垂直拆分为两个表（film和film_ext）：如下所示：<br> 1、<img src="https://images2.imgbox.com/7c/3d/koXVmgD3_o.png" alt="在这里插入图片描述"><br> 2、<img src="https://images2.imgbox.com/a4/c8/bOCuXQQ6_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4_215"></a>4、数据库表的水平拆分</h3> 
<p><strong>1、为什么水平拆分</strong><br> 表的水平拆分是为了解决单表数据量过大的问题，水平拆分的表每一个表的结构都是完全一致的，以下面的peyment表为例来说明</p> 
<pre><code>desc payment;
</code></pre> 
<p><img src="https://images2.imgbox.com/12/01/eMFD357a_o.png" alt="在这里插入图片描述"></p> 
<pre><code>show create table payment;
</code></pre> 
<pre><code>CREATE TABLE `payment` (
  `payment_id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,
  `customer_id` smallint(5) unsigned NOT NULL,
  `staff_id` tinyint(3) unsigned NOT NULL,
  `rental_id` int(11) DEFAULT NULL,
  `amount` decimal(5,2) NOT NULL,
  `payment_date` datetime NOT NULL,
  `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`payment_id`),
  KEY `idx_fk_staff_id` (`staff_id`),
  KEY `idx_fk_customer_id` (`customer_id`),
  KEY `fk_payment_rental` (`rental_id`),
  KEY `inx_paydate` (`payment_date`),
  CONSTRAINT `fk_payment_customer` FOREIGN KEY (`customer_id`) REFERENCES `customer` (`customer_id`) ON UPDATE CASCADE,
  CONSTRAINT `fk_payment_rental` FOREIGN KEY (`rental_id`) REFERENCES `rental` (`rental_id`) ON DELETE SET NULL ON UPDATE CASCADE,
  CONSTRAINT `fk_payment_staff` FOREIGN KEY (`staff_id`) REFERENCES `staff` (`staff_id`) ON UPDATE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=16050 DEFAULT CHARSET=utf8
</code></pre> 
<h3><a id="2_251"></a>2、水平不拆分原因</h3> 
<pre><code>如果单表的数据量达到上亿条，那么这时候我们尽管加了完美的索引，查询效率低，写入的效率也相应的降低。
</code></pre> 
<h3><a id="3N_255"></a>3、如何将数据平均分为N份</h3> 
<pre><code>通常水平拆分的方法为：
</code></pre> 
<p>1、对customer_id进行hash运算，如果要拆分为5个表则使用mod（customer_id，5）取出0-4个值。<br> 2、针对不动的hashid把数据存储到不同的表中。</p> 
<h3><a id="4_261"></a>4、水平拆分面临的挑战</h3> 
<p>1、夸分区表进行数据查询<br> 前端业务统计：<br> 业务上给不同的用户返回不同的业务信息，对分区表没有大的挑战。<br> 2、统计及后台报表操作<br> 但是对后台进行报表统计时，数据量比较大，后台统计时效性比较低，后台就用汇总表，将前后台的表拆分开。</p> 
<h2><a id="_270"></a>四、数据库系统配置优化</h2> 
<h3><a id="1_272"></a>1、定义</h3> 
<p>数据库是基于操作系统的，目前大多数MySQL都是安装在linux系统之上，所以对于操作系统的一些参数配置也会影响到MySQL的性能，下面就列出一些常用的系统配置。</p> 
<h3><a id="2_276"></a>2、优化配置参数-操作系统</h3> 
<p>优化包括操作系统的优化及MySQL的优化<br> 1、操作系统的优化<br> 网络方面的配置，要修改/etc/sysctl.conf<br> 1、增加tcp支持的队列数<br> net.ipv4.tcp_max_syn_backlog = 65535//<br> 2、减少断开连接时，资源回收(tcp有连接状态)</p> 
<pre><code>net.ipv4.tcp_max_tw_buckets = 8000 //
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_fin_timeout = 10
</code></pre> 
<p>说明： TCP是有连接状态，通过netstat查看连接状态，经常会看到timeout状态或者timewait状态连接，为了加快timewait状态的连接回收，就需要调整上面的四个参数，保持TCP连接数在一个适当的状态。</p> 
<h3><a id="2_292"></a>2、打开文件数的限制</h3> 
<pre><code>打开文件数的限制，可以使用ulimit –a查看目录的各个限制，可以修改/etc/security/limits.conf文件，增加以下内容以修改打开文件数量的限制（永久生效）
</code></pre> 
<p>*Soft nofile 65535<br> *Hard nofile 65535<br> 如果一次有效，就要使用ulimit –n 65535即可。（默认情况是1024）</p> 
<p>除此之外最好在MySQL服务器上关闭iptables，selinux等防火墙软件。</p> 
<h3><a id="3_MySQL_301"></a>3、优化配置参数- MySQL配置文件优化</h3> 
<p>1、MySQL配置文件修改<br> Mysql可以通过启动时指定参数和使用配置文件两种方法进行配置，在大多数情况下配置文件位于/etc/my.cnf 或者是 /etc/mysql/my.cnf在Windows系统配置文件可以是位于C://windows//my.ini文件，MySQL查找配置文件的顺序可以通过以下方法获得。</p> 
<pre><code>/usr/sbin/mysqld --verbose --help | grep -A 1 'default options'
</code></pre> 
<p>执行后的结果如下图所示：<br> <img src="https://images2.imgbox.com/b4/1e/j9W8Rt2h_o.png" alt="在这里插入图片描述"><br> 注意：如果存在多个位置存在配置文件，则后面的会覆盖前面的。</p> 
<h3><a id="2MySQL_312"></a>2、MySQL配置文件-常用参数说明</h3> 
<p><strong>1、连接请求的变量</strong><br> 1、max_connections<br> MySQL的最大连接数，增加该值增加mysqld 要求的文件描述符的数量。如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多，介于MySQL会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。<br> 数值过小会经常出现ERROR 1040: Too many connections错误，可以过’conn%’通配符查看当前状态的连接数量，以定夺该值的大小。<br> show variables like ‘max_connections’ 最大连接数<br> show status like ‘max_used_connections’响应的连接数<br> 如下：</p> 
<pre><code>show variables like 'max_connections';
</code></pre> 
<p><img src="https://images2.imgbox.com/92/48/VDDOsKRz_o.png" alt="在这里插入图片描述"></p> 
<pre><code>show variables like 'max_used_connections';
</code></pre> 
<p><img src="https://images2.imgbox.com/8a/32/QnJFO90a_o.png" alt="在这里插入图片描述"></p> 
<p>说明：理想值设置为多大才合适了？<br> max_used_connections / max_connections * 100% （理想值≈ 85%）<br> 如果max_used_connections跟max_connections相同 那么就是max_connections设置过低或者超过服务器负载上限了，低于10%则设置过大。</p> 
<h3><a id="2back_log_334"></a>2、back_log</h3> 
<p>MySQL能暂存的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，这就起作用。如果MySQL的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。<br> back_log值指出在MySQL暂时停止回答新请求之前的短时间内有多少个请求可以被存在堆栈中。只有如果期望在一个短时间内有很多连接，你需要增加它，换句话说，这值对到来的TCP/IP连接的侦听队列的大小。<br> 当观察你主机进程列表（mysql&gt; show full processlist），发现大量264084 | unauthenticated user | <a href="http://xxx.xxx.xxx.xxx" rel="nofollow">xxx.xxx.xxx.xxx</a> | NULL | Connect | NULL | login | NULL 的待连接进程时，就要加大back_log 的值了。<br> 默认数值是50，可调优为128，对于Linux系统设置范围为小于512的整数。</p> 
<p>mysql&gt; show full processlist;<br> ±—±-----±----------±-------±--------±-----±------±----------------------+<br> | Id | User | Host | db | Command | Time | State | Info |<br> ±—±-----±----------±-------±--------±-----±------±----------------------+<br> | 54 | root | localhost | sakila | Query | 0 | init | show full processlist |<br> ±—±-----±----------±-------±--------±-----±------±----------------------+<br> 1 row in set (0.00 sec)</p> 
<h3><a id="3interactive_timeout_349"></a>3、interactive_timeout</h3> 
<p>一个交互连接在被服务器在关闭前等待行动的秒数。一个交互的客户被定义为对mysql_real_connect()使用CLIENT_INTERACTIVE 选项的客户。<br> 默认数值是28800，可调优为7200。</p> 
<h3><a id="2_354"></a>2、缓冲区变量</h3> 
<p><strong>1、全局缓冲：</strong><br> 1、key_buffer_size<br> key_buffer_size指定索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度。通过检查状态值Key_read_requests和Key_reads，可以知道key_buffer_size设置是否合理。比例key_reads / key_read_requests应该尽可能的低，至少是1:100，1:1000更好（上述状态值可以使用SHOW STATUS LIKE ‘key_read%’获得）。<br> key_buffer_size只对MyISAM表起作用。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值。可以使用检查状态值created_tmp_disk_tables得知详情。<br> 举例如下：</p> 
<pre><code>show variables like 'key_buffer_size';
</code></pre> 
<p><img src="https://images2.imgbox.com/b9/43/dp79unjW_o.png" alt="在这里插入图片描述"><br> key_buffer_size为512MB，我们再看一下key_buffer_size的使用情况：</p> 
<pre><code>show global status like 'key_read%';
</code></pre> 
<p><img src="https://images2.imgbox.com/8c/47/eeF2Qbl6_o.png" alt="在这里插入图片描述"><br> 一共有27813678764个索引读取请求，有6798830个请求在内存中没有找到直接从硬盘读取索引，计算索引未命中缓存的概率：<br> key_cache_miss_rate ＝Key_reads / Key_read_requests * 100%，设置在1/1000左右较好<br> 默认配置数值是8388600(8M)，主机有4GB内存，可以调优值268435456(256MB)。<br> <strong>2、query_cache_size</strong><br> 使用查询缓冲，MySQL将查询结果存放在缓冲区中，今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。通过检查状态值Qcache_*，可以知道query_cache_size设置是否合理（上述状态值可以使用SHOW STATUS LIKE ‘Qcache%’获得）。如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，如果Qcache_hits的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果Qcache_hits的值不大，则表明你的查询重复率很低，这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入SQL_NO_CACHE可以明确表示不使用查询缓冲。<br> 与查询缓冲有关的参数还有query_cache_type、query_cache_limit、query_cache_min_res_unit。<br> query_cache_type指定是否使用查询缓冲，可以设置为0、1、2，该变量是SESSION级的变量。<br> query_cache_limit指定单个查询能够使用的缓冲区大小，缺省为1M。<br> query_cache_min_res_unit是在4.1版本以后引入的，它指定分配缓冲区空间的最小单位，缺省为4K。检查状态值Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多，这就表明查询结果都比较小，此时需要减小query_cache_min_res_unit。<br> 举例如下：</p> 
<pre><code>show global status like 'qcache%';
</code></pre> 
<p><img src="https://images2.imgbox.com/cc/35/GgoHvu55_o.png" alt="在这里插入图片描述"><br> 查询缓存碎片率= Qcache_free_blocks / Qcache_total_blocks * 100%<br> 如果查询缓存碎片率超过20%，可以用FLUSH QUERY CACHE整理缓存碎片，或者试试减小query_cache_min_res_unit，如果你的查询都是小数据量的话。<br> 查询缓存利用率= (query_cache_size – Qcache_free_memory) / query_cache_size * 100%<br> 查询缓存利用率在25%以下的话说明query_cache_size设置的过大，可适当减小；查询缓存利用率在80％以上而且Qcache_lowmem_prunes &gt; 50的话说明query_cache_size可能有点小，要不就是碎片太多。<br> 查询缓存命中率= (Qcache_hits – Qcache_inserts) / Qcache_hits * 100%<br> 示例服务器查询缓存碎片率＝20.46％，查询缓存利用率＝62.26％，查询缓存命中率＝1.94％，命中率很差，可能写操作比较频繁吧，而且可能有些碎片。<br> <strong>3、record_buffer_size</strong><br> 每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，你可能想要增加该值。</p> 
<p>默认数值是131072(128K)，可改为16773120 (16M)</p> 
<p><strong>4、read_rnd_buffer_size</strong><br> 随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。一般可设置为16M<br> <strong>5、sort_buffer_size</strong><br> 每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUP BY操作。<br> 默认数值是2097144(2M)，可改为16777208 (16M)。<br> <strong>6、join_buffer_size</strong><br> 联合查询操作所能使用的缓冲区大小。<br> record_buffer_size，read_rnd_buffer_size，sort_buffer_size，join_buffer_size为每个线程独占，也就是说，如果有100个线程连接，则占用为16M*100<br> <strong>7、table_cache</strong><br> 表高速缓存的大小。每当MySQL访问一个表时，如果在表缓冲区中还有空间，该表就被打开并放入其中，这样可以更快地访问表内容。通过检查峰值时间的状态值Open_tables和Opened_tables，可以决定是否需要增加table_cache的值。如果你发现open_tables等于table_cache，并且opened_tables在不断增长，那么你就需要增加table_cache的值了（上述状态值可以使用SHOW STATUS LIKE ‘Open%tables’获得）。注意，不能盲目地把table_cache设置成很大的值。如果设置得太高，可能会造成文件描述符不足，从而造成性能不稳定或者连接失败。<br> 1G内存机器，推荐值是128－256。内存在4GB左右的服务器该参数可设置为256M或384M。</p> 
<p><strong>8、max_heap_table_size</strong><br> 用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个变量支持动态改变，即set @max_heap_table_size=#<br> 这个变量和tmp_table_size一起限制了内部内存表的大小。如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。<br> <strong>9、tmp_table_size</strong><br> 通过设置tmp_table_size选项来增加一张临时表的大小，例如做高级GROUP BY操作生成的临时表。如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果，建议尽量优化查询，要确保查询过程中生成的临时表在内存中，避免临时表过大导致生成基于硬盘的MyISAM表。</p> 
<pre><code>show global status like 'created_tmp%';
</code></pre> 
<p><img src="https://images2.imgbox.com/f7/29/PAc46Oqx_o.png" alt="在这里插入图片描述"><br> 每次创建临时表，Created_tmp_tables增加，如果临时表大小超过tmp_table_size，则是在磁盘上创建临时表，Created_tmp_disk_tables也增加,Created_tmp_files表示MySQL服务创建的临时文件文件数，比较理想的配置是：<br> Created_tmp_disk_tables / Created_tmp_tables * 100% &lt;= 25%比如上面的服务器Created_tmp_disk_tables / Created_tmp_tables * 100% ＝1.20%，应该相当好了<br> 默认为16M，可调到64-256最佳，线程独占，太大可能内存不够I/O堵塞<br> <strong>10、thread_cache_size</strong><br> 可以复用的保存在中的线程的数量。如果有，新的线程从缓存中取得，当断开连接的时候如果有空间，客户的线置在缓存中。如果有很多新的线程，为了提高性能可以这个变量值。<br> 通过比较 Connections和Threads_created状态的变量，可以看到这个变量的作用。默认值为110，可调优为80。<br> <strong>11、thread_concurrency</strong><br> 推荐设置为服务器 CPU核数的2倍，例如双核的CPU, 那么thread_concurrency的应该为4；2个双核的cpu, thread_concurrency的值应为8。默认为8<br> <strong>12、wait_timeout</strong><br> 指定一个请求的最大连接时间，对于4GB左右内存的服务器可以设置为5-10。</p> 
<h2><a id="3InnoDB_424"></a>3、配置InnoDB的几个变量</h2> 
<p><strong>1、innodb_buffer_pool_size</strong><br> 对于InnoDB表来说，innodb_buffer_pool_size的作用就相当于key_buffer_size对于MyISAM表的作用一样。InnoDB使用该参数指定大小的内存来缓冲数据和索引。对于单独的MySQL数据库服务器，最大可以把该值设置成物理内存的80%。<br> 根据MySQL手册，对于2G内存的机器，推荐值是1G（50%）。<br> show status like ‘innodb%’;<br> <strong>2、innodb_flush_log_at_trx_commit</strong><br> 主要控制了innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，取值分别为0、1、2三个。0，表示当事务提交时，不做日志写入操作，而是每秒钟将log buffer中的数据写入日志文件并flush磁盘一次；1，则在每秒钟或是每次事物的提交都会引起日志文件写入、flush磁盘的操作，确保了事务的ACID；设置为2，每次事务提交引起写入日志文件的动作，但每秒钟完成一次flush磁盘操作。<br> 实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。<br> 根据MySQL手册，在允许丢失最近部分事务的危险的前提下，可以把该值设为0或2。<br> <strong>3、innodb_log_buffer_size</strong><br> log缓存大小，一般为1-8M，默认为1M，对于较大的事务，可以增大缓存大小。可设置为4M或8M。<br> <strong>4、innodb_additional_mem_pool_size</strong><br> 该参数指定InnoDB用来存储数据字典和其他内部数据结构的内存池大小。缺省值是1M。通常不用太大，只要够用就行，应该与表结构的复杂度有关系。如果不够用，MySQL会在错误日志中写入一条警告信息。<br> 根据MySQL手册，对于2G内存的机器，推荐值是20M，可适当增加。<br> innodb_thread_concurrency=8<br> 推荐设置为 2*(NumCPUs+NumDisks)，默认一般为8</p> 
<pre><code>[client]
port = 3306
socket = /tmp/mysql.sock
[mysqld]
port = 3306
socket = /tmp/mysql.sock
basedir = /usr/local/mysql
datadir = /data/mysql
pid-file = /data/mysql/mysql.pid
user = mysql
bind-address = 0.0.0.0
server-id = 1 #表示是本机的序号为1,一般来讲就是master的意思
</code></pre> 
<p>5、skip-name-resolve</p> 
<pre><code># 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，
# 则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求
#skip-networking

back_log = 600
# MySQL能有的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，这就起作用，
# 然后主线程花些时间(尽管很短)检查连接并且启动一个新线程。back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。
# 如果期望在一个短时间内有很多连接，你需要增加它。也就是说，如果MySQL的连接数据达到max_connections时，新来的请求将会被存在堆栈中，
# 以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。
# 另外，这值（back_log）限于您的操作系统对到来的TCP/IP连接的侦听队列的大小。
# 你的操作系统在这个队列大小上有它自己的限制（可以检查你的OS文档找出这个变量的最大值），试图设定back_log高于你的操作系统的限制将是无效的。

max_connections = 1000
# MySQL的最大连接数，如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多，介于MySQL会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。可以过’conn%’通配符查看当前状态的连接数量，以定夺该值的大小。

max_connect_errors = 6000
# 对于同一主机，如果有超出该参数值个数的中断错误连接，则该主机将被禁止连接。如需对该主机进行解禁，执行：FLUSH HOST。

open_files_limit = 65535
# MySQL打开的文件描述符限制，默认最小1024;当open_files_limit没有被配置的时候，比较max_connections*5和ulimit -n的值，哪个大用哪个，
# 当open_file_limit被配置的时候，比较open_files_limit和max_connections*5的值，哪个大用哪个。

table_open_cache = 128
# MySQL每打开一个表，都会读入一些数据到table_open_cache缓存中，当MySQL在这个缓存中找不到相应信息时，才会去磁盘上读取。默认值64
# 假定系统有200个并发连接，则需将此参数设置为200*N(N为每个连接所需的文件描述符数目)；
# 当把table_open_cache设置为很大时，如果系统处理不了那么多文件描述符，那么就会出现客户端失效，连接不上

max_allowed_packet = 4M
# 接受的数据包大小；增加该变量的值十分安全，这是因为仅当需要时才会分配额外内存。例如，仅当你发出长查询或MySQLd必须返回大的结果行时MySQLd才会分配更多内存。
# 该变量之所以取较小默认值是一种预防措施，以捕获客户端和服务器之间的错误信息包，并确保不会因偶然使用大的信息包而导致内存溢出。

binlog_cache_size = 1M
# 一个事务，在没有提交的时候，产生的日志，记录到Cache中；等到事务提交需要提交的时候，则把日志持久化到磁盘。默认binlog_cache_size大小32K

max_heap_table_size = 8M
# 定义了用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个变量支持动态改变

tmp_table_size = 16M
# MySQL的heap（堆积）表缓冲大小。所有联合在一个DML指令内完成，并且大多数联合甚至可以不用临时表即可以完成。
# 大多数临时表是基于内存的(HEAP)表。具有大的记录长度的临时表 (所有列的长度的和)或包含BLOB列的表存储在硬盘上。
# 如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。还可以通过设置tmp_table_size选项来增加临时表的大小。也就是说，如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果

read_buffer_size = 2M
# MySQL读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySQL会为它分配一段内存缓冲区。read_buffer_size变量控制这一缓冲区的大小。
# 如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能

read_rnd_buffer_size = 8M
# MySQL的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，
# MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大

sort_buffer_size = 8M
# MySQL执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。
# 如果不能，可以尝试增加sort_buffer_size变量的大小

join_buffer_size = 8M
# 联合查询操作所能使用的缓冲区大小，和sort_buffer_size一样，该参数对应的分配内存也是每连接独享

thread_cache_size = 8
# 这个值（默认8）表示可以重新利用保存在缓存中线程的数量，当断开连接时如果缓存中还有空间，那么客户端的线程将被放到缓存中，
# 如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程，
# 增加这个值可以改善系统性能.通过比较Connections和Threads_created状态的变量，可以看到这个变量的作用。(–&gt;表示要调整的值)
# 根据物理内存设置规则如下：
# 1G —&gt; 8
# 2G —&gt; 16
# 3G —&gt; 32
# 大于3G —&gt; 64

query_cache_size = 8M
#MySQL的查询缓冲大小（从4.0.1开始，MySQL提供了查询缓冲机制）使用查询缓冲，MySQL将SELECT语句和查询结果存放在缓冲区中，
# 今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。根据MySQL用户手册，使用查询缓冲最多可以达到238%的效率。
# 通过检查状态值’Qcache_%’，可以知道query_cache_size设置是否合理：如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，
# 如果Qcache_hits的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果Qcache_hits的值不大，则表明你的查询重复率很低，
# 这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入SQL_NO_CACHE可以明确表示不使用查询缓冲

query_cache_limit = 2M
#指定单个查询能够使用的缓冲区大小，默认1M

key_buffer_size = 4M
#指定用于索引的缓冲区大小，增加它可得到更好处理的索引(对所有读和多重写)，到你能负担得起那样多。如果你使它太大，
# 系统将开始换页并且真的变慢了。对于内存在4GB左右的服务器该参数可设置为384M或512M。通过检查状态值Key_read_requests和Key_reads，
# 可以知道key_buffer_size设置是否合理。比例key_reads/key_read_requests应该尽可能的低，
# 至少是1:100，1:1000更好(上述状态值可以使用SHOW STATUS LIKE ‘key_read%’获得)。注意：该参数值设置的过大反而会是服务器整体效率降低

ft_min_word_len = 4
# 分词词汇最小长度，默认4

transaction_isolation = REPEATABLE-READ
# MySQL支持4种事务隔离级别，他们分别是：
# READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE.
# 如没有指定，MySQL默认采用的是REPEATABLE-READ，ORACLE默认的是READ-COMMITTED

log_bin = mysql-bin
binlog_format = mixed
expire_logs_days = 30 #超过30天的binlog删除
log_error = /data/mysql/mysql-error.log #错误日志路径
slow_query_log = 1
long_query_time = 1 #慢查询时间 超过1秒则为慢查询
slow_query_log_file = /data/mysql/mysql-slow.log
performance_schema = 0
explicit_defaults_for_timestamp
#lower_case_table_names = 1 #不区分大小写
skip-external-locking #MySQL选项以避免外部锁定。该选项默认开启
default-storage-engine = InnoDB #默认存储引擎

innodb_file_per_table = 1
# InnoDB为独立表空间模式，每个数据库的每个表都会生成一个数据空间
# 独立表空间优点：
# 1．每个表都有自已独立的表空间。
# 2．每个表的数据和索引都会存在自已的表空间中。
# 3．可以实现单表在不同的数据库中移动。
# 4．空间可以回收（除drop table操作处，表空不能自已回收）
# 缺点：
# 单表增加过大，如超过100G
# 结论：
# 共享表空间在Insert操作上少有优势。其它都没独立表空间表现好。当启用独立表空间时，请合理调整：innodb_open_files

innodb_open_files = 500
# 限制Innodb能打开的表的数据，如果库里的表特别多的情况，请增加这个。这个值默认是300

innodb_buffer_pool_size = 64M
# InnoDB使用一个缓冲池来保存索引和原始数据, 不像MyISAM.
# 这里你设置越大,你在存取表里面数据时所需要的磁盘I/O越少.
# 在一个独立使用的数据库服务器上,你可以设置这个变量到服务器物理内存大小的80%
# 不要设置过大,否则,由于物理内存的竞争可能导致操作系统的换页颠簸.
# 注意在32位系统上你每个进程可能被限制在 2-3.5G 用户层面内存限制,
# 所以不要设置的太高.

innodb_write_io_threads = 4
innodb_read_io_threads = 4

# innodb使用后台线程处理数据页上的读写 I/O(输入输出)请求,根据你的 CPU 核数来更改,默认是4
# 注:这两个参数不支持动态改变,需要把该参数加入到my.cnf里，修改完后重启MySQL服务,允许值的范围从 1-64

innodb_thread_concurrency = 0
# 默认设置为 0,表示不限制并发数，这里推荐设置为0，更好去发挥CPU多核处理能力，提高并发量

innodb_purge_threads = 1
# InnoDB中的清除操作是一类定期回收无用数据的操作。在之前的几个版本中，清除操作是主线程的一部分，这意味着运行时它可能会堵塞其它的数据库操作。
# 从MySQL5.5.X版本开始，该操作运行于独立的线程中,并支持更多的并发数。用户可通过设置innodb_purge_threads配置参数来选择清除操作是否使用单
# 独线程,默认情况下参数设置为0(不使用单独线程),设置为 1 时表示使用单独的清除线程。建议为1

innodb_flush_log_at_trx_commit = 2
# 0：如果innodb_flush_log_at_trx_commit的值为0,log buffer每秒就会被刷写日志文件到磁盘，提交事务的时候不做任何操作（执行是由mysql的master thread线程来执行的。
# 主线程中每秒会将重做日志缓冲写入磁盘的重做日志文件(REDO LOG)中。不论事务是否已经提交）默认的日志文件是ib_logfile0,ib_logfile1
# 1：当设为默认值1的时候，每次提交事务的时候，都会将log buffer刷写到日志。
# 2：如果设为2,每次提交事务都会写日志，但并不会执行刷的操作。每秒定时会刷到日志文件。要注意的是，并不能保证100%每秒一定都会刷到磁盘，这要取决于进程的调度。
# 每次事务提交的时候将数据写入事务日志，而这里的写入仅是调用了文件系统的写入操作，而文件系统是有 缓存的，所以这个写入并不能保证数据已经写入到物理磁盘
# 默认值1是为了保证完整的ACID。当然，你可以将这个配置项设为1以外的值来换取更高的性能，但是在系统崩溃的时候，你将会丢失1秒的数据。
# 设为0的话，mysqld进程崩溃的时候，就会丢失最后1秒的事务。设为2,只有在操作系统崩溃或者断电的时候才会丢失最后1秒的数据。InnoDB在做恢复的时候会忽略这个值。
# 总结
# 设为1当然是最安全的，但性能页是最差的（相对其他两个参数而言，但不是不能接受）。如果对数据一致性和完整性要求不高，完全可以设为2，如果只最求性能，例如高并发写的日志服务器，设为0来获得更高性能

innodb_log_buffer_size = 2M
# 此参数确定些日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，但意外的故障将会丢失数据。MySQL开发人员建议设置为1－8M之间

innodb_log_file_size = 32M
# 此参数确定数据日志文件的大小，更大的设置可以提高性能，但也会增加恢复故障数据库所需的时间

innodb_log_files_in_group = 3
# 为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3

innodb_max_dirty_pages_pct = 90
# innodb主线程刷新缓存池中的数据，使脏数据比例小于90%

innodb_lock_wait_timeout = 120
# InnoDB事务在被回滚之前可以等待一个锁定的超时秒数。InnoDB在它自己的锁定表中自动检测事务死锁并且回滚事务。InnoDB用LOCK TABLES语句注意到锁定设置。默认值是50秒

bulk_insert_buffer_size = 8M
# 批量插入缓存大小， 这个参数是针对MyISAM存储引擎来说的。适用于在一次性插入100-1000+条记录时， 提高效率。默认值是8M。可以针对数据量的大小，翻倍增加。

myisam_sort_buffer_size = 8M
# MyISAM设置恢复表之时使用的缓冲区的尺寸，当在REPAIR TABLE或用CREATE INDEX创建索引或ALTER TABLE过程中排序 MyISAM索引分配的缓冲区

myisam_max_sort_file_size = 10G
# 如果临时文件会变得超过索引，不要使用快速排序索引方法来创建一个索引。注释：这个参数以字节的形式给出

myisam_repair_threads = 1
# 如果该值大于1，在Repair by sorting过程中并行创建MyISAM表索引(每个索引在自己的线程内)

interactive_timeout = 28800
# 服务器关闭交互式连接前等待活动的秒数。交互式客户端定义为在mysql_real_connect()中使用CLIENT_INTERACTIVE选项的客户端。默认值：28800秒（8小时）

wait_timeout = 28800
# 服务器关闭非交互连接之前等待活动的秒数。在线程启动时，根据全局wait_timeout值或全局interactive_timeout值初始化会话wait_timeout值，
# 取决于客户端类型(由mysql_real_connect()的连接选项CLIENT_INTERACTIVE定义)。参数默认值：28800秒（8小时）
# MySQL服务器所支持的最大连接数是有上限的，因为每个连接的建立都会消耗内存，因此我们希望客户端在连接到MySQL Server处理完相应的操作后，
# 应该断开连接并释放占用的内存。如果你的MySQL Server有大量的闲置连接，他们不仅会白白消耗内存，而且如果连接一直在累加而不断开，
# 最终肯定会达到MySQL Server的连接上限数，这会报’too many connections’的错误。对于wait_timeout的值设定，应该根据系统的运行情况来判断。
# 在系统运行一段时间后，可以通过show processlist命令查看当前系统的连接状态，如果发现有大量的sleep状态的连接进程，则说明该参数设置的过大，
# 可以进行适当的调整小些。要同时设置interactive_timeout和wait_timeout才会生效。

[mysqldump]
quick
max_allowed_packet = 16M #服务器发送和接受的最大包长度
[myisamchk]
key_buffer_size = 8M
sort_buffer_size = 8M
read_buffer = 4M
write_buffer = 4M
</code></pre> 
<p>附录：<br> 1、查看innodb的相关参数信息</p> 
<pre><code>show variables like 'innodb%';
</code></pre> 
<p><img src="https://images2.imgbox.com/ab/2c/7JMGn0QS_o.png" alt="在这里插入图片描述">2、查看innodb的相关参数状态</p> 
<pre><code>show status like 'innodb%';
</code></pre> 
<p><img src="https://images2.imgbox.com/31/61/WCjU2yaI_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="MySQL_672"></a>五、MySQL的执行顺序</h2> 
<p>MySQL的语句一共分为11步，如下图所标注的那样，最先执行的总是FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。<img src="https://images2.imgbox.com/e9/2b/VoxpHtQD_o.png" alt="在这里插入图片描述"></p> 
<p>下面我们来具体分析一下查询处理的每一个阶段<br> 1.FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1<br> 2.ON: 对虚表VT1进行ON筛选，只有那些符合的行才会被记录在虚表VT2中。<br> 3.JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。<br> 4.WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合的记录才会被插入到虚拟表VT4中。<br> 5.GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.<br> 6.CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6.<br> 7.HAVING： 对虚拟表VT6应用having过滤，只有符合的记录才会被 插入到虚拟表VT7中。</p> 
<h2><a id="MySQL_685"></a>六、MySQL执行引擎介绍（了解）</h2> 
<h3><a id="1MyISAM_687"></a>1、MyISAM存储引擎</h3> 
<p>不支持事务、也不支持外键，优势是访问速度快，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表<br> 支持3种不同的存储格式，分别是：静态表；动态表；压缩表<br> 静态表：<br> 表中的字段都是非变长字段，这样每个记录都是固定长度的，优点存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多（因为存储时会按照列的宽度定义补足空格）ps：在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。<br> 动态表：<br> 记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能<br> 压缩表：<br> 因为每个记录是被单独压缩的，所以只有非常小的访问开支</p> 
<h3><a id="2InnoDB_698"></a>2、InnoDB存储引擎</h3> 
<p>该存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM引擎，写的处理效率会差一些，并且会占用更多的磁盘空间以保留数据和索引。<br> InnoDB存储引擎的特点：支持自动增长列，支持外键约束</p> 
<h3><a id="3MEMORY_703"></a>3、MEMORY存储引擎</h3> 
<p>Memory存储引擎使用存在于内存中的内容来创建表。每个memory表只实际对应一个磁盘文件，格式是.frm。memory类型的表访问非常的快，因为它的数据是放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失掉。<br> MEMORY存储引擎的表可以选择使用BTREE索引或者HASH索引，两种不同类型的索引有其不同的使用范围<br> Hash索引优点：<br> Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。<br> Hash索引缺点：<br> 那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；<br> Memory类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果，。对存储引擎为memory的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，所以一定要对下次重新启动服务后如何获得这些修改后的数据有所考虑。</p> 
<h3><a id="4MERGE_713"></a>4、MERGE存储引擎</h3> 
<p>Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，更新，删除操作，这些操作实际上是对内部的MyISAM表进行的。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/73d182fae22ad8e3ef52e14508a362b3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nginx配置https服务</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0585b6caf9ea3aa21b23be87fe690054/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用 idea查看类关系图形</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>