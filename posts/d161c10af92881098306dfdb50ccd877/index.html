<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Rust实战系列-Rust介绍 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Rust实战系列-Rust介绍" />
<meta property="og:description" content="“
学习资料：rust in action[1]
1. Rust 安装 curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh source&#34;$HOME/.cargo/env&#34; 2. hello world 创建 hello 项目 mkdir rust_tmp &amp;&amp; cd rust_tmp cargo new hello cd hello cargo run 看到这样的输出，就表示已经成功运行了 Rust 项目，尽管还没写任何代码。接下来看看发生了什么。
Cargo Cargo 是一个同时提供项目构建和软件包管理功能的工具。也就是说，Cargo 执行 rustc（Rust 编译器）将 Rust 代码转换为可执行的二进制文件或共享库。cargo new会创建一个遵循标准模板的项目，目录结构如下：
Cargo.toml：描述项目的元数据信息（项目名，版本，依赖）
[package] name = &#34;hello&#34; version = &#34;0.1.0&#34; edition = &#34;2021&#34; # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html [dependencies] src：源码目录，Rust 的源码文件扩展名为 ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/d161c10af92881098306dfdb50ccd877/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-19T23:11:05+08:00" />
<meta property="article:modified_time" content="2022-08-19T23:11:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Rust实战系列-Rust介绍</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/99/2b/E2qXf8H7_o.png" alt="请添加图片描述"></p> 
<blockquote> 
 <p>“</p> 
 <p>学习资料：rust in action[1]</p> 
</blockquote> 
<h3><a id="1_Rust__6"></a>1. Rust 安装</h3> 
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source"$HOME/.cargo/env"


</code></pre> 
<h3><a id="2_hello_world_16"></a>2. hello world</h3> 
<ul><li>创建 hello 项目</li></ul> 
<pre><code>mkdir rust_tmp &amp;&amp; cd rust_tmp
cargo new hello
cd hello
cargo run


</code></pre> 
<p><img src="https://images2.imgbox.com/43/c6/1SOZRdO0_o.png" alt="图片"></p> 
<p>看到这样的输出，就表示已经成功运行了 Rust 项目，尽管还没写任何代码。接下来看看发生了什么。</p> 
<ul><li>Cargo</li></ul> 
<p>Cargo 是一个同时提供项目构建和软件包管理功能的工具。也就是说，Cargo 执行 rustc（Rust 编译器）将 Rust 代码转换为可执行的二进制文件或共享库。<code>cargo new</code>会创建一个遵循标准模板的项目，目录结构如下：</p> 
<p><img src="https://images2.imgbox.com/10/eb/rO6Ov9yX_o.png" alt="图片"></p> 
<p><strong>Cargo.toml</strong>：描述项目的元数据信息（项目名，版本，依赖）</p> 
<pre><code>[package]
name = "hello"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]


</code></pre> 
<p><strong>src</strong>：源码目录，Rust 的源码文件扩展名为 .rs</p> 
<p>创建好项目后，运行 cargon run 命令启动项目，这个过程完成了很多工作。</p> 
<p>当敲下 cargon run 命令准备 run 项目时，实际上并没有可以 run 的内容，因此，cargon 会以 debug 模式编译项目，编译生成的可执行文件位于：target/debug/hello，然后执行这个文件，输出我们看到的内容：“Hello, world!”。</p> 
<p>编译之后，项目的目录结构发生了变化，在根目录多了 Cargo.lock 文件和 target 目录，它们都是通过 cargon 进行管理的，不需要人工修改。</p> 
<blockquote> 
 <p>“</p> 
 <p>Cargo.lock 指定了所有依赖项的确切版本号，这样，在 Cargo.toml 被修改之前，项目编译过程都会以相同的方式进行。</p> 
</blockquote> 
<h3><a id="3__Rust__69"></a>3. 第一个 Rust 项目</h3> 
<p>目标：输出不同语言的 hello world，理解 Rust 的两个特性：易于迭代和原生支持 Unicode。</p> 
<p>直接修改 hello 项目中 src/main.rs 的内容：</p> 
<pre><code>fn main() {
    println!("Hello, world!");

    let southern_germany = "Grüß Gott!";
    let japan = "ハロー・ワールド";
    let china = "你好，世界！";

    let regions = [southern_germany, japan, china];

    for region in regions.iter() {
        println!("{}", &amp;region);
    }

}


</code></pre> 
<ul><li> <p>感叹号表示引用了一个宏</p> </li><li> <p>Rust 中的变量赋值，更恰当的称呼是变量绑定，使用 let 关键字</p> </li><li> <p>原生支持 Unicode，不需要考虑乱码问题</p> </li><li> <p>使用方括号表示数组</p> </li><li> <p>很多数据类型可以通过 iter()返回迭代器</p> </li><li> <p>&amp;表示取出地址的值</p> </li></ul> 
<p>修改后，项目的执行结果：</p> 
<p><img src="https://images2.imgbox.com/7d/4a/b1KsglYY_o.png" alt="图片"></p> 
<h3><a id="4__112"></a>4. 文本处理</h3> 
<p>接下来，通过实例了解 Rust 的文本处理能力。主要包括以下特性：</p> 
<ul><li> <p>常见的控制流机制：包括 for 循环和 continue 关键字</p> </li><li> <p>函数语法：虽然 Rust 不是面向对象的，因为它不支持继承，但它继承了面向对象语言的这个特点</p> </li><li> <p>高级编程：函数可以同时接受和返回函数。例如，实例第 19 行包括一个闭包，也被称为匿名函数或 λ（lambda）函数</p> </li><li> <p>类型注解：虽然用得不多，但偶尔也需要这些注解提示编译器（第 28 行）</p> </li><li> <p>有条件地编译：编译项目时，不会编译第 22-24 行的内容</p> </li><li> <p>隐式返回：Rust 提供了一个 return 关键字，但它通常被省略了</p> </li></ul> 
<pre><code>fn main() {                 // &lt;1&gt;
    let penguin_data = "\
    common name,length (cm)
    Little penguin,33
    Yellow-eyed penguin,65
    Fiordland penguin,60
    Invalid,data
    ";

    let records = penguin_data.lines();    // &lt;2&gt;

    for (i, record) in records.enumerate() {   // &lt;3&gt;
      if i == 0 || record.trim().len() == 0 {  // &lt;4&gt;
        continue;
      }

      let fields: Vec&lt;_&gt; = record     // &lt;5&gt;
        .split(',')                   // &lt;6&gt;
        .map(|field| field.trim())    // &lt;7&gt;
        .collect();                   // &lt;8&gt;

      ifcfg!(debug_assertions) {              // &lt;9&gt;
        eprintln!("debug: {:?} -&gt; {:?}",
                   record, fields);            // &lt;10&gt;
      }

      let name = fields[0];                    // &lt;11&gt;
      ifletOk(length) = fields[1].parse::&lt;f32&gt;() { // &lt;12&gt;
          println!("{}, {}cm", name, length);        // &lt;13&gt;
      }
    }
  }


</code></pre> 
<ol><li> <p>可执行项目必须有一个 main 函数</p> </li><li> <p>将字符串按行拆分成切片</p> </li><li> <p>遍历每行字符串，i 是下标，record 是 item</p> </li><li> <p>跳过表头和空行</p> </li><li> <p>Vec 类型是向量的简称,向量是一种数组，在需要时可以动态扩展。下划线要求编译器推断出向量的元素类型。即变量名 fields，类型为 Vec，Vec 中元素类型 Rust 推导。</p> </li><li> <p>将 record 拆分成子字符串数组（以 逗号 为分隔符）</p> </li><li> <p>对于循环，可以使用高级函数，这里去掉空白字符。map()对 split 出来的每个子字符串应用函数 term()，field 临时变量表示每个子字符串（个人理解，不一定对）</p> </li><li> <p>Collects 迭代的结果并保存到向量 fields 中</p> </li><li> <p>这个代码块是为了调试，感叹号 ! 表示宏调用，宏类似于函数，返回代码而不是值，通常用于简化常见的模式</p> </li><li> <p>打印到标准错误输出， {:?} 语法请求这两种数据类型的默认调试格式作为输出</p> </li><li> <p>Rust 支持用整数下标对集合进行索引</p> </li><li> <p>将字符串解析为 f32（单精度浮点数）类型，parse 可以将字符串解析为任何实现了 FromStr trait 的类型（在 Rust 中，为了安全起见，不允许隐式的数据类型转换），使用 Ok()函数是为了在 if 的条件中创建 length 变量并进行赋值操作</p> </li><li> <p>打印到 stdout，{} 语法表示 Rust 应该使用用户自定义的方法来输出字符串的值，而不是用 {:?} 来显示调试结果</p> </li></ol> 
<p>运行项目的输出结果：</p> 
<p><img src="https://images2.imgbox.com/33/f0/YIRnfVMZ_o.png" alt="图片"></p> 
<p>可以看到有输出以 debug 开头的行，通过 --release 参数去掉这部分调试内容。</p> 
<p><img src="https://images2.imgbox.com/e5/93/mMGPeDaK_o.png" alt="图片"></p> 
<p>可以通过 -q（quiet） 来进一步减少输出信息：</p> 
<p><img src="https://images2.imgbox.com/f5/34/4l6VcX4b_o.png" alt="图片"></p> 
<blockquote> 
 <p>“</p> 
 <p>严格来说，rustc 才是 Rust 编译器，但我们并没有使用它来编译项目，cargon 代替我们调用 rustc ，简化编译过程。如果希望查看 rustc 编译过程的详细信息，使用 --verbose 或 -v 参数。（需要保证目标文件未被编译，如果已经编译则没有对应输出）</p> 
 <p>rustc：管理 Rust 源代码的编译</p> 
 <p>rustup：管理 Rust 的安装</p> 
</blockquote> 
<h3><a id="5_Rust__214"></a>5. Rust 的目标：安全</h3> 
<blockquote> 
 <p>“</p> 
 <p>we need a safer systems programming language[2]</p> 
</blockquote> 
<p>Rust 不受以下情况的影响：</p> 
<ul><li> <p>空悬指针（dangling pointers）：对程序运行过程中变得无效的数据进行实时引用（指针被释放后，仍然引用原来的内存）</p> </li><li> <p>数据竞争（data race）：由于外部环境的变化，无法确定程序在运行过程中的行为（非线程安全的情况下，多线程对同一个地址空间进行写操作）</p> </li><li> <p>缓存溢出（Buffer overflow）：试图访问一个只有 6 个元素数组的第 12 个元素</p> </li><li> <p>迭代器失效（Iterator invalidation）：已经迭代的内容被中途修改后导致的问题（python 中遇到过这种问题）</p> </li></ul> 
<p>当程序在调试模式下被编译时，Rust 也会对整数溢出进行保护。</p> 
<blockquote> 
 <p>“</p> 
 <p>什么是整数溢出：整数只能代表有限的一组数字；这些数字在内存中占用固定的长度。整数溢出是指当整数达到其极限时发生的情况。</p> 
</blockquote> 
<ul><li>空悬指针的示例代码</li></ul> 
<pre><code>#[derive(Debug)]// &lt;1&gt;
enum Cereal {       // &lt;2&gt;
    Barley, Millet, Rice,
    Rye, Spelt, Wheat,
}

fn main() {
    letmut grains: Vec&lt;Cereal&gt; = vec![];   // &lt;3&gt;
    grains.push(Cereal::Rye);               // &lt;4&gt;
    drop(grains);                           // &lt;5&gt;

    println!("{:?}", grains);               // &lt;6&gt;
}


</code></pre> 
<ol><li> <p>允许 println! 打印 Cereal 枚举</p> </li><li> <p>枚举是一种有固定数量有效值的类型</p> </li><li> <p>初始化空的向量（数组）grains</p> </li><li> <p>向 grains 添加元素</p> </li><li> <p>删除向量 grains 和其中的内容</p> </li><li> <p>尝试访问被删除的值</p> </li></ol> 
<p>代码中，Vec是用一个指向底层数组的内部指针实现的，尝试编译项目会出错：</p> 
<p><img src="https://images2.imgbox.com/f5/6b/R5tYhT3R_o.png" alt="图片"></p> 
<ul><li>数据竞争的示例代码</li></ul> 
<pre><code>use std::thread;                          // &lt;1&gt;

fn main() {
    letmut data = 100;

    thread::spawn(|| { data = 500; });    // &lt;2&gt;
    thread::spawn(|| { data = 1000; });   // &lt;2&gt;

    println!("{}", data);
}


</code></pre> 
<ol><li> <p>导入 thread 标准库</p> </li><li> <p>thread::spawn() 产生一个新的线程，thread::spawn()的闭合由竖条和大括号表示（例如，|| {…}）</p> </li></ol> 
<p>使用 cargo 编译不会通过。</p> 
<ul><li>缓存溢出的示例代码</li></ul> 
<pre><code>fn main() {
  let fruit = vec!['🥝', '🍌', '🍇'];

  let buffer_overflow = fruit[4];    // &lt;1&gt;

  assert_eq!(buffer_overflow, '🍉')  // &lt;2&gt;
}


</code></pre> 
<ol><li> <p>这行代码会出现 panic</p> </li><li> <p>assert_eq!() 的两边必须相等，否则程序 panic</p> </li></ol> 
<p>使用 cargo 编译不会通过。</p> 
<ul><li>迭代器失效的示例代码</li></ul> 
<pre><code>fn main() {
  letmut letters = vec![            // &lt;1&gt;
      "a", "b", "c"
  ];

  for letter in letters {
      println!("{}", letter);
      letters.push(letter.clone());  // &lt;2&gt;
  }
}


</code></pre> 
<ol><li> <p>初始化一个向量并允许修改（mut）</p> </li><li> <p>创建 letter 的副本并追加到 letters 的末尾</p> </li></ol> 
<p>使用 cargo 编译不会通过。</p> 
<h3><a id="6_Rust__348"></a>6. Rust 的目标：生产力</h3> 
<p>在有选择的情况下，Rust 更倾向于选择对开发者来说最容易的选项。例如，在一个应该使用等于判断（==）的表达式中使用赋值（=）符号。</p> 
<pre><code>fn main() {
    let a = 10;

    if a = 10 {
        println!("a equals ten");
    }
}


</code></pre> 
<p>这段代码是不能编译通过（C 语言没有这种能力）的，Rust 编译器会生成错误：</p> 
<p><img src="https://images2.imgbox.com/f3/c3/K5UQnRIY_o.png" alt="图片"></p> 
<p>if 接收的不是一个整数，它接收的是一个赋值的结果。在 Rust 中，这是一个空白类型：()</p> 
<p>Rust 提供了许多人性化的特点，包括泛型、复杂数据类型、模式匹配和闭包。</p> 
<p>cargo 为 Rust 程序员提供了这些命令：</p> 
<ul><li> <p>cargo init：创建一个 Rust 项目框架</p> </li><li> <p>cargo build：下载依赖项并编译代码</p> </li><li> <p>cargo run：功能与 cargo build 相同，编译好之后会运行生成的可执行文件</p> </li><li> <p>cargo doc：为当前项目中的每个依赖关系建立 HTML 文档</p> </li></ul> 
<h3><a id="7_Rust__384"></a>7. Rust 的目标：资源控制</h3> 
<p>从代码层面提升性能时，对内存访问、内存布局和特定 CPU 指令的控制都非常重要。</p> 
<ul><li> <p>有时，必须要管理某些操作的方式</p> </li><li> <p>有时，数据存储在栈中而不是堆上可能很重要</p> </li><li> <p>有时，为一个共享值添加引用计数可能很有意义</p> </li><li> <p>通常，将引用传递给函数是有意义的</p> </li><li> <p>偶尔，为一个特定的访问模式创建一个自己的指针类型可能很有用</p> </li></ul> 
<p>对于大多数情况，Rust 使用了合理的默认值，与它的 “零成本抽象”理念一致。</p> 
<p>以下代码描述了多种创建整数值的方式，每种形式都提供了不同的语义和运行时特性：</p> 
<pre><code>use std::rc::Rc;
use std::sync::{Arc, Mutex};

fn main() {
    let a = 10;                       // &lt;1&gt;
    let b = Box::new(20);             // &lt;2&gt;
    let c = Rc::new(Box::new(30));    // &lt;3&gt;
    let d = Arc::new(Mutex::new(40)); // &lt;4&gt;

    println!("a: {:?}, b: {:?}, c: {:?}, d: {:?}", a, b, c, d);
}


</code></pre> 
<ol><li> <p>存储在栈中</p> </li><li> <p>存储在堆中，也叫 boxed integer</p> </li><li> <p>boxed integer 被包裹在引用计数器中</p> </li><li> <p>整数被包裹在原子引用计数器中，并受到互斥锁的保护</p> </li></ol> 
<h3><a id="8_Rust__429"></a>8. Rust 的特征：性能</h3> 
<p>Rust 充分发挥计算机的可用性能，Rust 不依赖 GC（垃圾收集器）来保证内存安全。</p> 
<p>硬件 CPU 的性能是固定的，因此，为了使软件的运行速度更快，需要减少 CPU 完成的工作，在 Rust 中，这个过程由编译器完成，尽可能减小程序的大小和运行速度。</p> 
<ul><li> <p>默认提供有利于缓存的数据结构：通常，在 Rust 程序中使用数组保存数据，而不是由指针创建的深度嵌套树结构。这被称为面向数据编程。</p> </li><li> <p>先进的软件包管理器：cargo 的出现使我们很容易构建有许多依赖关系的大型项目。</p> </li><li> <p>函数静态调度：除非明确要求动态调度，函数默认静态调度，这使得编译器可以大量优化代码，有时甚至可以完全消除函数调用带来的开销。</p> </li></ul> 
<h3><a id="9_Rust__443"></a>9. Rust 的特征：并发</h3> 
<p>事实证明，要求计算机同时完成多件事情对软件工程师来说是很困难的。从操作系统层面考虑，如果程序员在并发访问的时候出现错误，会导致两个独立执行的线程可以任意破坏对方线程。Rust 对安全的强调跨越了独立线程的界限，允许程序员可以随意使用并发编程特性。</p> 
<h3><a id="10_Rust__448"></a>10. Rust 的特征：内存效率</h3> 
<p>Rust 使你能够创建需要最小内存的程序。如果需要，程序员可以使用固定大小的结构，并清楚地知道每个 byte 是如何被管理的。使用高级数据结构，如迭代和泛型，只会产生最小的运行开销。</p> 
<h3><a id="11_Rust__453"></a>11. Rust 的不足</h3> 
<ul><li>循环数据结构</li></ul> 
<p>在 Rust 中很难对任意图结构这样的循环数据进行建模，实现一个双向链表是本科计算机科学水平的问题，但 Rust 的安全检查使得其很难实现。</p> 
<ul><li>编译时间</li></ul> 
<p>Rust 在编译代码时比它的同类语言要慢。它有一个复杂的编译器工具链，它接收多个中间表示，并向 LLVM 编译器发送大量代码。Rust 程序的“编译单元”不是一个单独的文件，而是一个完整的包。由于包可以包含多个模块，这些模块可以是非常大的编译单元。</p> 
<ul><li>严格性</li></ul> 
<p>在使用 Rust 编程时，除非一切都是正确的，否则程序不会编译。编译器是严格的，但很有帮助。</p> 
<ul><li>语言的尺寸</li></ul> 
<p>Rust 有一个复杂的类型系统，可以通过多种方式访问值，还有一个与强制转换对象生命期相匹配的权限系统。对于这些访问方式，程序员有选择负担。</p> 
<ul><li>炒作</li></ul> 
<p>用 Rust 编写的软件也不能完全避免安全问题。2015 年，随着 Rust 知名度的提高，SSL/TLS 的实现（即 OpenSSL 和苹果自己的 fork）被发现有严重的安全漏洞。这两个漏洞被非正式地称为 "Heartbleed “和 “goto fail”，为测试 Rust 声称的内存安全提供了机会。在这两个案例中，Rust 很可能起到了帮助作用，但仍然有可能写出存在类似问题的 Rust 代码。”</p> 
<p><strong>Heartbleed</strong> 是由于不正确地重复使用缓冲区造成的。缓冲区是内存中预留的用于接收输入数据的空间。如果缓冲区的内容在两次写入之间没有被清擦除，那么数据就会从前一次读取泄漏到下一次。如果缓冲区存储的是密钥等信息，将会对安全性造成严重破坏。</p> 
<p>为什么会出现这种情况呢？为了追求性能，程序通常会重复使用缓冲区，从而减少向操作系统申请内存的频率。以下是示例代码：</p> 
<pre><code>let buffer = &amp;mut[0u8; 1024];  // &lt;1&gt;

read_secrets(&amp;user1, buffer);  // &lt;2&gt;
store_secrets(buffer);

read_secrets(&amp;user2, buffer);  // &lt;3&gt;
store_secrets(buffer);


</code></pre> 
<ol><li> <p>将一个引用（&amp;）与一个包含 1024 个初始化为 0 的无符号 8 位整数（u8）的可变（mut）数组（[…]）绑定到变量缓冲区</p> </li><li> <p>用 user1 对象的字节来填充缓冲区</p> </li><li> <p>此时，buffer 仍然包含来自 user1 的数据，这些数据可能被 user2 覆盖，也可能不被覆盖</p> </li></ol> 
<p><strong>goto fail</strong> 是由程序员错误使用 C 语言设计造成的问题（C 编译器没有检查出这个缺陷）造成的。被设计用来验证加密密钥对的函数最终跳过了所有检查。以下是该函数的部分内容：</p> 
<pre><code>static OSStatus
// line break OK below? original exceeded 76 char limit
SSLVerifySignedServerKeyExchange(SSLContext *ctx, bool isRsa,
                                 SSLBuffer signedParams,
                                 uint8_t *signature, UInt16 signatureLen)
{
    OSStatus        err;

    ...

    // need line break below at 55 char max (because line contains annotation)
    if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;serverRandom)) != 0)
        goto fail;
    if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) != 0)    // &lt;1&gt;
        goto fail;
        goto fail;    // &lt;2&gt;
    if ((err = SSLHashSHA1.final(&amp;hashCtx, &amp;hashOut)) != 0)
        goto fail;

    err = sslRawVerify(ctx,
                       ctx-&gt;peerPubKey,
                       dataToSign,              /* plaintext \*/
                       dataToSignLen,           /* plaintext length \*/
                       signature,
                       signatureLen);
        if(err) {
        sslErrorLog("SSLDecodeSignedServerKeyExchange: sslRawVerify "
                    "returned %d\n", (int)err);
        goto fail;
    }

fail:
    SSLFreeBuffer(&amp;signedHashes);
    SSLFreeBuffer(&amp;hashCtx);
    return err;    // &lt;4&gt;

}


</code></pre> 
<ol><li> <p>第一个 goto 在 if 判断为 true 时执行</p> </li><li> <p>当第一个 goto 判断为 false 时，err 的值为 0，此时会执行第二个 goto 语句，从而跳过 SSLHashSHA1.final() 和对 sslRawVerify() 的调用（重要）</p> </li><li> <p>返回值为 0，通过验证（实际上没有执行 SSLHashSHA1.final() 和 sslRawVerify()）</p> </li></ol> 
<h3><a id="12__555"></a>12. 应用场景</h3> 
<ul><li>命令行程序</li></ul> 
<p>Rust 为创建命令行程序提供了三个主要优势：最小的启动时间、低内存消耗和容易部署。由于 Rust 不需要初始化解释器（Python, Ruby, …）或虚拟机（Java, C#, …），程序可以快速开始运行。</p> 
<p>在 Rust 中，许多类型只作为编译器的提示而存在，在运行的程序中根本不占用内存。</p> 
<p>用 Rust 编写的程序默认是作为静态二进制文件编译，避免了对共享库的依赖。</p> 
<ul><li>数据处理</li></ul> 
<p>由于对内存使用的控制和极短的启动时间，Rust 擅长处理文本和其他形式的数据内容。Rust 也是多个搜索引擎、数据处理引擎和日志解析系统的实现基础，提供了创建高吞吐量的数据管道的能力，而且内存占用率低且稳定。</p> 
<ul><li>扩展应用</li></ul> 
<p>Rust 非常适合扩展用动态语言编写的程序。这使得 JNI（Java Native Interface）扩展、C 扩展或 Rust 中的 Erlang/Elixir NIFs（本地实现的函数）成为可能。</p> 
<ul><li>资源受限的环境</li></ul> 
<p>物联网（IoT）时代的到来意味着数十亿不安全的设备暴露在网络中。通常情况下，物联网设备的固件更新频率很低，因此，从一开始就尽可能地保证这些设备的安全是至关重要的，Rust 可以发挥重要作用。</p> 
<ul><li>服务器端的应用</li></ul> 
<p>大多数用 Rust 编写的应用程序运行在服务器上，通常位于操作系统和应用程序之间。例如：npm 包注册表，sled（嵌入式数据库）</p> 
<ul><li>面向用户的软件</li></ul> 
<p>Rust 的设计中没有任何阻止其被部署到面向用户软件开发中内容。Servo，作为 Rust 早期开发的网络浏览器引擎，就是一个面向用户的应用程序。</p> 
<ul><li>桌面应用程序</li></ul> 
<p>桌面应用程序通常很复杂，难以设计，也难以支持。由于 Rust 的部署方式符合人机工程学原理，而且很严谨，很可能成为许多应用程序的选择。</p> 
<ul><li>移动端软件</li></ul> 
<p>Android 和 IOS 都提供了让 "本地应用程序"在系统上运行的能力，这是为了让用 C++编写的应用程序，如游戏，能够被部署到手机上。Rust 能够通过相同的接口与手机交互，没有额外的时间开销。</p> 
<ul><li>web 网站</li></ul> 
<p>浏览器供应商正在开发一种叫做 WebAssembly（Wasm）的标准，有望成为许多语言的编译器目标，Rust 就是其中一个。将一个 Rust 项目移植到浏览器上只需要两个额外的命令行命令。</p> 
<ul><li>系统编程</li></ul> 
<p>许多大型程序都是用 Rust 实现的，包括编译器（Rust 本身）、视频游戏引擎和操作系统。Rust 社区包括解析器生成器、数据库和文件格式的开发者。</p> 
<h4><a id="_612"></a>参考资料</h4> 
<p>[1] rust in action: <em>https://livebook.manning.com/book/rust-in-action</em></p> 
<p>[2] we need a safer systems programming language: <em>https://msrc-blog.microsoft.com/2019/07/18/we-need-a-safer-systems-programming-language/</em></p> 
<p><img src="https://images2.imgbox.com/94/ad/GiPmcAmX_o.png" alt="图片"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1c021db6b0768df2db58c3202f7cc166/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">istio和sdp(软件定义边界)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6987242ee2f643b17e6690d2b92f15d1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c&#43;&#43; GUI应用---吃豆人游戏(Visual Studio 2019)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>