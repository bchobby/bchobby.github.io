<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>QT之XML文件解析DOM - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="QT之XML文件解析DOM" />
<meta property="og:description" content="Qt之XML文件解析(DOM) XML简介 ​ 和HTML的语法很相似，但不同之处在于： HTML 被设计用来显示数据，其关注的是数据的外观，XML 被设计用来传输和存储数据，其关注的是数据的内容，因此，XML主要用来作为数据的存储和共享。
​ XML文档是一种树的结构，从根部扩展到枝叶。以下是一个XML示例
&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;root&gt; &lt;!--写入矩形图元的信息--&gt; &lt;class name=&#34;Rect&#34;&gt; &lt;object name=&#34;obj1&#34;&gt; &lt;x1&gt;10&lt;/x1&gt; &lt;y1&gt;10&lt;/y1&gt; &lt;x2&gt;50&lt;/x2&gt; &lt;y1&gt;50&lt;/y1&gt; &lt;linewidth&gt;2&lt;/linewidth&gt; &lt;scale&gt;0&lt;/scale&gt; &lt;rotate&gt;0&lt;/rotate&gt; &lt;/object&gt; &lt;/class&gt; &lt;/root&gt; 其中第一行 是XML 声明。它定义 XML 的版本和所使用的编码格式，&lt;root&gt; &lt;/root&gt;为根节点的起始（在XML中可以自定义节点名称），&lt;class&gt; &lt;/class&gt;为子元素，其中name为其属性，值为Rect；每一个子元素都可以拥有子元素，故class的子元素为object，依次类推； 所有的元素都可以有文本内容和属性，如x1的文本为10，x2的文本为50。
DOM类介绍 Classes说明QDomAttr表示 QDomElement 的一个属性QDomCDATASection表示 XML CDATA 部分QDomCharacterData表示 DOM 中的通用字符串QDomComment表示 XML 注释QDomDocument表示一个 XML 文档QDomDocumentFragmentQDomNodes 树，不是完整的QDomDocumentQDomDocumentTypeDTD 在文档树中的表示QDomElement表示 DOM 树中的一个元素QDomEntity表示一个 XML 实体QDomEntityReference表示 XML 实体引用QDomImplementation有关 DOM 实现的功能的信息QDomNamedNodeMap包含可以按名称访问的节点集合QDomNodeDOM 树中所有节点的基类QDomNodeListQDomNode 对象列表QDomNotation表示 XML 表示法QDomProcessingInstruction表示 XML 处理指令QDomText表示解析的 XML 文档中的文本数据 其相关继承关系如下：
一个XML文档如果只做保存数据使用，那么以下XML的构成就足够使用了" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/d24761ce119681d2175094f784a9d99e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-26T20:30:09+08:00" />
<meta property="article:modified_time" content="2022-08-26T20:30:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">QT之XML文件解析DOM</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="QtXMLDOM_1"></a>Qt之XML文件解析(DOM)</h2> 
<h3><a id="XML_3"></a>XML简介</h3> 
<p>​ 和<strong>HTML</strong>的语法很相似，但不同之处在于： HTML 被设计用来显示数据，其关注的是数据的外观，XML 被设计用来传输和存储数据，其关注的是数据的内容，因此，XML主要用来作为数据的存储和共享。</p> 
<p>​ XML文档是一种树的结构，从根部扩展到枝叶。以下是一个XML示例</p> 
<pre><code class="prism language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">&gt;</span></span>
	<span class="token comment">&lt;!--写入矩形图元的信息--&gt;</span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Rect<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>object</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>obj1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
			<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>x1</span><span class="token punctuation">&gt;</span></span>10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>x1</span><span class="token punctuation">&gt;</span></span>
			<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>y1</span><span class="token punctuation">&gt;</span></span>10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>y1</span><span class="token punctuation">&gt;</span></span>
			<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>x2</span><span class="token punctuation">&gt;</span></span>50<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>x2</span><span class="token punctuation">&gt;</span></span>
			<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>y1</span><span class="token punctuation">&gt;</span></span>50<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>y1</span><span class="token punctuation">&gt;</span></span>
			<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>linewidth</span><span class="token punctuation">&gt;</span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>linewidth</span><span class="token punctuation">&gt;</span></span>
			<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scale</span><span class="token punctuation">&gt;</span></span>0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scale</span><span class="token punctuation">&gt;</span></span>
			<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rotate</span><span class="token punctuation">&gt;</span></span>0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rotate</span><span class="token punctuation">&gt;</span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>object</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>class</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>其中第一行 是XML 声明。它定义 XML 的版本和所使用的编码格式，<code>&lt;root&gt; &lt;/root&gt;</code>为根节点的起始（在XML中可以自定义节点名称），<code>&lt;class&gt; &lt;/class&gt;</code>为子元素，其中<code>name</code>为其属性，值为<code>Rect</code>；每一个子元素都可以拥有子元素，故<code>class</code>的子元素为<code>object</code>，依次类推； 所有的元素都可以有文本内容和属性，如x1的文本为10，x2的文本为50。</p> 
<h3><a id="DOM_29"></a>DOM类介绍</h3> 
<table><thead><tr><th>Classes</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://doc.qt.io/qt-6/qdomattr.html" rel="nofollow">QDomAttr</a></td><td>表示 QDomElement 的一个属性</td></tr><tr><td><a href="https://doc.qt.io/qt-6/qdomcdatasection.html" rel="nofollow">QDomCDATASection</a></td><td>表示 XML CDATA 部分</td></tr><tr><td><a href="https://doc.qt.io/qt-6/qdomcharacterdata.html" rel="nofollow">QDomCharacterData</a></td><td>表示 DOM 中的通用字符串</td></tr><tr><td><a href="https://doc.qt.io/qt-6/qdomcomment.html" rel="nofollow">QDomComment</a></td><td>表示 XML 注释</td></tr><tr><td><a href="https://doc.qt.io/qt-6/qdomdocument.html" rel="nofollow">QDomDocument</a></td><td>表示一个 XML 文档</td></tr><tr><td><a href="https://doc.qt.io/qt-6/qdomdocumentfragment.html" rel="nofollow">QDomDocumentFragment</a></td><td>QDomNodes 树，不是完整的QDomDocument</td></tr><tr><td><a href="https://doc.qt.io/qt-6/qdomdocumenttype.html" rel="nofollow">QDomDocumentType</a></td><td>DTD 在文档树中的表示</td></tr><tr><td><a href="https://doc.qt.io/qt-6/qdomelement.html" rel="nofollow">QDomElement</a></td><td>表示 DOM 树中的一个元素</td></tr><tr><td><a href="https://doc.qt.io/qt-6/qdomentity.html" rel="nofollow">QDomEntity</a></td><td>表示一个 XML 实体</td></tr><tr><td><a href="https://doc.qt.io/qt-6/qdomentityreference.html" rel="nofollow">QDomEntityReference</a></td><td>表示 XML 实体引用</td></tr><tr><td><a href="https://doc.qt.io/qt-6/qdomimplementation.html" rel="nofollow">QDomImplementation</a></td><td>有关 DOM 实现的功能的信息</td></tr><tr><td><a href="https://doc.qt.io/qt-6/qdomnamednodemap.html" rel="nofollow">QDomNamedNodeMap</a></td><td>包含可以按名称访问的节点集合</td></tr><tr><td><a href="https://doc.qt.io/qt-6/qdomnode.html" rel="nofollow">QDomNode</a></td><td>DOM 树中所有节点的基类</td></tr><tr><td><a href="https://doc.qt.io/qt-6/qdomnodelist.html" rel="nofollow">QDomNodeList</a></td><td>QDomNode 对象列表</td></tr><tr><td><a href="https://doc.qt.io/qt-6/qdomnotation.html" rel="nofollow">QDomNotation</a></td><td>表示 XML 表示法</td></tr><tr><td><a href="https://doc.qt.io/qt-6/qdomprocessinginstruction.html" rel="nofollow">QDomProcessingInstruction</a></td><td>表示 XML 处理指令</td></tr><tr><td><a href="https://doc.qt.io/qt-6/qdomtext.html" rel="nofollow">QDomText</a></td><td>表示解析的 XML 文档中的文本数据</td></tr></tbody></table> 
<p>其相关继承关系如下：</p> 
<p><img src="https://images2.imgbox.com/43/1b/f9hRRrR0_o.png" alt="在这里插入图片描述"></p> 
<p>一个XML文档如果只做保存数据使用，那么以下XML的构成就足够使用了</p> 
<p><img src="https://images2.imgbox.com/49/97/wBwjN2TR_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_61"></a>节点类型</h4> 
<p>在QDomNode中，对XML中各种参数的区分是通过NodeType枚举实现的</p> 
<pre><code class="prism language-c"><span class="token keyword">enum</span> <span class="token class-name">NodeType</span> <span class="token punctuation">{<!-- --></span>
    ElementNode               <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    AttributeNode             <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>
    TextNode                  <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>
    CDATASectionNode          <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span>
    EntityReferenceNode       <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span>
    EntityNode                <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span>
    ProcessingInstructionNode <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">,</span>
    CommentNode               <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">,</span>
    DocumentNode              <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">,</span>
    DocumentTypeNode          <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span>
    DocumentFragmentNode      <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">,</span>
    NotationNode              <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">,</span>
    BaseNode                  <span class="token operator">=</span> <span class="token number">21</span><span class="token punctuation">,</span><span class="token comment">// this is not in the standard</span>
    CharacterDataNode         <span class="token operator">=</span> <span class="token number">22</span> <span class="token comment">// this is not in the standard</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_84"></a>节点类型判断</h4> 
<p>可以通过以下函数对节点的<strong>类型</strong>进行判断</p> 
<pre><code class="prism language-c++">bool isAttr() const { return nodeType() == QDomNode::AttributeNode; }
bool isCDATASection() const { return nodeType() == QDomNode::CDATASectionNode; }
bool isDocumentFragment() const { return nodeType() == QDomNode::DocumentFragmentNode; }
bool isDocument() const { return nodeType() == QDomNode::DocumentNode; }
bool isDocumentType() const { return nodeType() == QDomNode::DocumentTypeNode; }
bool isElement() const { return nodeType() == QDomNode::ElementNode; }
bool isEntityReference() const { return nodeType() == QDomNode::EntityReferenceNode; }
bool isText() const{ const QDomNode::NodeType nt = nodeType();return (nt == QDomNode::TextNode)|| (nt == QDomNode::CDATASectionNode); }
bool isEntity() const { return nodeType() == QDomNode::EntityNode; }
bool isNotation() const { return nodeType() == QDomNode::NotationNode; }
bool isProcessingInstruction() const { return nodeType() == QDomNode::ProcessingInstructionNode; }
bool isCharacterData() const { const QDomNode::NodeType nt = nodeType();return (nt == QDomNode::CharacterDataNode)|| (nt == QDomNode::TextNode)
|| (nt == QDomNode::CommentNode); }
bool isComment() const { return nodeType() == QDomNode::CommentNode; }
</code></pre> 
<h4><a id="_105"></a>节点增删改</h4> 
<p>对于节点的操作主要有<strong>插入</strong>、<strong>替换</strong>、<strong>移除</strong>、<strong>追加</strong>等，相关API如下</p> 
<pre><code class="prism language-c++">QDomNodePrivate* insertBefore(QDomNodePrivate* newChild, QDomNodePrivate* refChild);
QDomNodePrivate* insertAfter(QDomNodePrivate* newChild, QDomNodePrivate* refChild);
QDomNodePrivate* replaceChild(QDomNodePrivate* newChild, QDomNodePrivate* oldChild);
QDomNodePrivate* removeChild(QDomNodePrivate* oldChild);
QDomNodePrivate* appendChild(QDomNodePrivate* newChild);
</code></pre> 
<h4><a id="_117"></a>节点创建</h4> 
<p><strong>创建</strong>节点有如下工厂函数可供使用</p> 
<pre><code class="prism language-c++">QDomElement createElement(const QString&amp; tagName);
QDomDocumentFragment createDocumentFragment();
QDomText createTextNode(const QString&amp; data);
QDomComment createComment(const QString&amp; data);
QDomCDATASection createCDATASection(const QString&amp; data);
QDomProcessingInstruction createProcessingInstruction(const QString&amp; target, const QString&amp; data);
QDomAttr createAttribute(const QString&amp; name);
QDomEntityReference createEntityReference(const QString&amp; name);
QDomNodeList elementsByTagName(const QString&amp; tagname) const;
QDomNode importNode(const QDomNode&amp; importedNode, bool deep);
QDomElement createElementNS(const QString&amp; nsURI, const QString&amp; qName);
QDomAttr createAttributeNS(const QString&amp; nsURI, const QString&amp; qName);
</code></pre> 
<h4><a id="_136"></a>节点查找</h4> 
<p>节点的<strong>查找</strong>。需要注意的是，虽然Qt提供了<code>elementById</code>这个方法，但是并没有去实现，所以是不可使用的。而通过<code>elementsByTagName</code>方法可以通过<code>name</code>返回所有名为<code>name</code>的节点，通过<code>elementsByTagNameNS</code>可以通过命名空间和名字一起使用得到指定的节点，同时在创建元素时使用<code>createElementNS</code>创建一个带有命名空间的元素即可。</p> 
<pre><code class="prism language-c++">QDomNodeList elementsByTagName(const QString&amp; tagname) const;
QDomNodeList elementsByTagNameNS(const QString&amp; nsURI, const QString&amp; localName);
QDomElement elementById(const QString&amp; elementId);
</code></pre> 
<h4><a id="_146"></a>节点复制</h4> 
<p>节点的<strong>复制</strong>，节点类通过隐式共享来共享数据，这样获取到节点指针后可以很方便的对数据进行修改。同时也可以对节点进行深拷贝。</p> 
<pre><code class="prism language-c++">QDomNode QDomNode::cloneNode(bool deep = true) const
</code></pre> 
<h4><a id="_154"></a>节点遍历</h4> 
<p>节点的<strong>遍历</strong>，从前往后遍历可以通过</p> 
<pre><code class="prism language-c++">QDomNode firstChild() const;
QDomNode nextSibling() const;
</code></pre> 
<p>从后往前遍历可以通过</p> 
<pre><code class="prism language-c++">QDomNode lastChild() const;
QDomNode previousSibling() const;
QDomNode parentNode() const;
</code></pre> 
<p>配合函数<code>namedItem()</code>可以进行更精确的遍历</p> 
<h4><a id="_173"></a>节点转化</h4> 
<p>节点的<strong>转化</strong>。将一个节点类型转化为另一种节点类型</p> 
<pre><code class="prism language-c++">QDomAttr toAttr() const;
QDomCDATASection toCDATASection() const;
QDomDocumentFragment toDocumentFragment() const;
QDomDocument toDocument() const;
QDomDocumentType toDocumentType() const;
QDomElement toElement() const;
QDomEntityReference toEntityReference() const;
QDomText toText() const;
QDomEntity toEntity() const;
QDomNotation toNotation() const;
QDomProcessingInstruction toProcessingInstruction() const;
QDomCharacterData toCharacterData() const;
QDomComment toComment() const;
</code></pre> 
<h4><a id="_193"></a>节点清除</h4> 
<p>节点的<strong>清除</strong></p> 
<pre><code class="prism language-c++">void clear();
</code></pre> 
<h4><a id="_201"></a>节点非空判断</h4> 
<p>节点的<strong>非空判断</strong></p> 
<pre><code class="prism language-c++">bool isNull() const;
</code></pre> 
<h4><a id="_209"></a>元素属性与文本</h4> 
<p>元素中可以有属性和文本，有关<strong>属性</strong>的操作主要有获取属性值，添加属性，移除属性和判断是否含有某个属性等，如下所示</p> 
<pre><code class="prism language-c++">QString attribute(const QString&amp; name, const QString&amp; defValue) const;
void setAttribute(const QString&amp; name, const QString&amp; value);
void removeAttribute(const QString&amp; name);
bool hasAttribute(const QString&amp; name);
</code></pre> 
<p><strong>文本</strong>似乎没有提供属性这样方便的方法，但是文本作为文本节点，其具有节点的操作方法也同样可以使用，属性也是如此。</p> 
<h4><a id="_222"></a>其它</h4> 
<ol><li> <p>要找出一个节点是否有子节点，可以使用<code>hasChildNodes()</code>或者通过<code>childNodes()</code>获取一个节点所有子节点的列表。</p> </li><li> <p>节点的名称和值（其含义取决于它的节点类型）分别由<code>nodeName()</code>和<code>nodeValue()</code>返回。节点的类型由<code>nodeType()</code>返回。Node的值可以通过<code>setNodeValue()</code>来设置。</p> </li><li> <p>通过<code>ownerDocument()</code>返回节点所属的文档</p> </li><li> <p>通过<code>normalize()</code>合并两个相邻的QDomText节点</p> </li><li> <p>通过<code>lineNumber()</code>和<code>columnNumber()</code>获取节点的行数和列数</p> </li><li> <p>XML文档保存通过函数，可以指定文本流，缩进以及编码方式</p> <pre><code class="prism language-c++">void QDomNode::save(QTextStream &amp;stream, int indent, QDomNode::EncodingPolicy encodingPolicy = QDomNode::EncodingFromDocument) const
</code></pre> </li></ol> 
<h3><a id="XML_242"></a>创建XML示例</h3> 
<p>使用DOM解析XML文档时，需要在<code>.pro</code>文件中添加</p> 
<pre><code>QT += xml
</code></pre> 
<p>代码示例：</p> 
<pre><code class="prism language-c++">void MainWindow::on_btnWrite_clicked()
{
    QString fileName = QFileDialog::getSaveFileName(this, "Save File",
                                                    "./untitled.xml","Xml(*.xml)");
    qDebug() &lt;&lt; fileName;

    QFile file(fileName);

    if (!file.open(QIODevice::ReadWrite | QIODevice::Truncate))
    {
        qDebug() &lt;&lt; "Save failed";
        return;
    }
    
    QDomDocument doc; /* 创建一个文档 */
    /* 创建并添加文档声明 */
    QDomProcessingInstruction  docStatement =
    doc.createProcessingInstruction("xml", "version=\"1.0\" encoding=\"UTF-8\"");
    doc.appendChild(docStatement);

    QDomElement root;   /* 根节点 */
    QDomElement _class; /* 根节点下的class属性 */
    QDomElement object; /* class下的object属性 */
    QDomElement x1;     /* object下的x1属性 */
    QDomElement y1;     /* object下的y1属性 */
    QDomComment comment;/* 注释 */
    QDomText text;      /* 文本 */

    /* 创建并在文档中添加一个根节点 */
    root = doc.createElement("root");
    doc.appendChild(root);

    /* 创建一个注释 */
    comment = doc.createComment("以下是矩形图元");
    root.appendChild(comment); /* 将注释追加在根节点后面 */

    /* 创建一个带有命名空间的元素 */
    _class = doc.createElementNS("rect", "class");
    root.appendChild(_class); /* 将元素追加在根节点后面 */
    _class.setAttribute("name", "Rect"); /* 为元素添加一个属性 */

    /* 创建一个元素 */
    object = doc.createElement("object");
    _class.appendChild(object); /* 将元素追加在class元素后面 */
    object.setAttribute("name", "obj1"); /* 为元素添加一个属性 */

    /* 创建一个元素 */
    x1 = doc.createElement("x1");
    object.appendChild(x1); /* 将元素追加在object元素后面 */

    /* 创建一个文本 */
    text = doc.createTextNode("10");
    x1.appendChild(text); /* 将文本追加在x1元素后面 */

    /* 创建一个元素 */
    object = doc.createElement("object");
    _class.appendChild(object); /* 将元素追加在class元素后面 */
    object.setAttribute("name", "obj2"); /* 为元素添加一个属性 */

    /* 创建一个元素 */
    x1 = doc.createElement("x1");
    object.appendChild(x1); /* 将元素追加在object元素后面 */

    /* 创建一个文本 */
    text = doc.createTextNode("20");
    x1.appendChild(text); /* 将文本追加在x1元素后面 */

    comment = doc.createComment("以下是线图元");
    root.appendChild(comment);
    _class = doc.createElementNS("line", "class");
    root.appendChild(_class);
    _class.setAttribute("name", "Line");
    text = doc.createTextNode("没有线图元");
    _class.appendChild(text);

    QTextStream stream(&amp;file);
    doc.save(stream, 4);
  
}
</code></pre> 
<p>所产生的xml文档：</p> 
<pre><code class="prism language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--以下是矩形图元--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Rect<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>object</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>obj1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>x1</span><span class="token punctuation">&gt;</span></span>10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>x1</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>object</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>object</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>obj2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>x1</span><span class="token punctuation">&gt;</span></span>20<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>x1</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>object</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>class</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--以下是线图元--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>line<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Line<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>没有线图元<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>class</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<h3><a id="XML_353"></a>读取XML示例</h3> 
<p>示例：</p> 
<pre><code class="prism language-c++">void MainWindow::on_btnRead_clicked()
{
    QString fileName = QFileDialog::getOpenFileName(this, "Save this file As"
                                                    , "./", "Xml(*.xml)");
    qDebug() &lt;&lt; fileName;

    QFile file(fileName);

    if (!file.open(QIODevice::ReadOnly))
    {
        qDebug() &lt;&lt; "Save failed";
        return;
    }
	QDomDocument doc; /* 创建一个文档 */
	doc.setContent(&amp;file, true); /* 设置doc的内容来自文件，并且支持命名空间 */
	/* 查找命名空间是rect且名字为class的节点 */
	QDomNodeList nodeList = doc.elementsByTagNameNS("rect", "class");
	qDebug() &lt;&lt; nodeList.size();
	
	QDomNode node = nodeList.at(0); /* 因为实际只有一个，这里直接取第0个元素即可 */
	QDomElement domElement;
	if(node.isElement()) /* 判断是否是元素，然后转化为元素节点 */
		domElement = node.toElement();
	
	/* 获取obj1和obj2中的x1的值 */
	QDomNode cnode;
	cnode = domElement.firstChild();
	
	for(cnode = domElement.firstChild(); cnode.isNull()==false; cnode = cnode.nextSibling())
	{
		if(cnode.isElement())
		{
			QDomElement dElement = cnode.toElement();
			qDebug() &lt;&lt; dElement.attribute("name"); // obj1,obj2
			
			for(QDomNode cnode2 = dElement.firstChild(); cnode2.isNull()==false; cnode2 = cnode2.nextSibling())
			{
				QDomText tDom = cnode2.firstChild().toText(); /* 把元素x1,y1的第一个子节点转化为文本类节点 */
				qDebug() &lt;&lt; cnode2.nodeName() &lt;&lt; ":" &lt;&lt; tDom.data();
			}
			
		}
	}
    
}
</code></pre> 
<p>打印输出：</p> 
<pre><code>1
"obj1"
"x1" : "10"
"obj2"
"x1" : "20"
</code></pre> 
<h3><a id="XML_415"></a>增删XML示例</h3> 
<p>示例代码：</p> 
<pre><code class="prism language-c++">void MainWindow::on_btnAddAndRemove_clicked()
{
    QString fileName = QFileDialog::getOpenFileName(this, "Save this file As"
                                                    , "./", "Xml(*.xml)");
    qDebug() &lt;&lt; fileName;

    QFile file(fileName);

    if (!file.open(QIODevice::ReadOnly))
    {
        qDebug() &lt;&lt; "Save failed";
        return;
    }
    QDomDocument doc; /* 创建一个文档 */
    doc.setContent(&amp;file, true); /* 设置doc的内容来自文件，并且支持命名空间 */
    file.close();

    /* 查找命名空间是rect且名字为class的节点 */
    QDomNodeList nodeList = doc.elementsByTagNameNS("rect", "class");
    qDebug() &lt;&lt; nodeList.size();

    QDomNode node = nodeList.at(0); /* 因为实际只有一个，这里直接取第0个元素即可 */
    QDomElement domElement;
    if(node.isElement()) /* 判断是否是元素，然后转化为元素节点 */
        domElement = node.toElement();

    QDomNode last_node = domElement.lastChild(); /* 获取class的子节点中的最后一个节点 */

    /* 创建一个新的元素 obj3 */
    QDomElement new_object = doc.createElement("object");
    new_object.setAttribute("name", "obj3");
    QDomElement new_x1 = doc.createElement("x1");
    new_object.appendChild(new_x1);
    QDomText new_text = doc.createTextNode("50");
    new_x1.appendChild(new_text);
    QDomElement new_y1 = doc.createElement("y1");
    new_object.appendChild(new_y1);
    new_text = doc.createTextNode("80");
    new_y1.appendChild(new_text);
    /* 通过追加或者插入的方式将新的节点加入 */
//    domElement.appendChild(new_object);
    domElement.insertAfter(new_object, last_node);


    /* 删除 class Line元素 */
    QDomNode root = doc.documentElement();
    QDomNode oldNode = doc.elementsByTagNameNS("line", "class").at(0);
    root.removeChild(oldNode);

    if (!file.open(QIODevice::WriteOnly | QIODevice::Truncate))
    {
        qDebug() &lt;&lt; "Save failed";
        return;
    }
    QTextStream stream(&amp;file);
    doc.save(stream, 4);

    file.close();
}
</code></pre> 
<p>依然以写入的文档作为示例，经过增加一个子节点<code>obj3</code>和删除一个命名空间为<code>line</code>的<code>class</code>节点后的结果为：</p> 
<pre><code class="prism language-xml"><span class="token prolog">&lt;?xml version='1.0' encoding='UTF-8'?&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--以下是矩形图元--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Rect<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>object</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>obj1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>x1</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>x1</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>object</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>object</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>obj2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>x1</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>20<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>x1</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>object</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>object</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>obj3<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>x1</span><span class="token punctuation">&gt;</span></span>50<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>x1</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>y1</span><span class="token punctuation">&gt;</span></span>80<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>y1</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>object</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>class</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--以下是线图元--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">&gt;</span></span>

</code></pre> 
<p>需要注意的是再次写入的时候，程序自动在旧的元素上增添了命名空间。</p> 
<h3><a id="XML_506"></a>修改XML示例</h3> 
<p>示例代码：以修改元素<code>obj1</code>的<code>x1</code>的文本为例，假如修改为100</p> 
<pre><code class="prism language-c++">void MainWindow::on_btnModify_clicked()
{
    QString fileName = QFileDialog::getOpenFileName(this, "Save this file As"
                                                    , "./", "Xml(*.xml)");
    qDebug() &lt;&lt; fileName;

    QFile file(fileName);

    if (!file.open(QIODevice::ReadOnly))
    {
        qDebug() &lt;&lt; "Save failed";
        return;
    }
    QDomDocument doc; /* 创建一个文档 */
    if(!doc.setContent(&amp;file, true)) /* 设置doc的内容来自文件，并且支持命名空间 */
    {
        file.close();
        return;
    }
    file.close();
    /* 查找命名空间是rect且名字为object的节点 */
    QDomNodeList nodeList = doc.elementsByTagNameNS("rect", "object");
    qDebug() &lt;&lt; nodeList.size(); /* 会获取到3个 */

    for (int i = 0; i &lt; nodeList.size(); i++) {
        QDomElement objDom;
        if(nodeList.at(i).isElement())
            objDom = nodeList.at(i).toElement();

        if(QString::compare(objDom.attribute("name"), "obj1") == 0)
        {
            /* 找到x1节点下的节点，因为只有一个，直接用firstChild，转化为文本节点类型，之后设置参数 */
            objDom.elementsByTagName("x1").at(0).firstChild().toText().setData("100");
        }
    }

    QDomNode node = nodeList.at(0); /* 因为实际只有一个，这里直接取第0个元素即可 */
    QDomElement domElement;
    if(node.isElement()) /* 判断是否是元素，然后转化为元素节点 */
        domElement = node.toElement(); /* 获取obj1的节点 */

    QDomNode node1 = domElement.elementsByTagName("x1").at(0);
    QDomText domText;
    if(node.isText()) /* 判断是否是元素，然后转化为元素节点 */
        domText = node.toText(); /* 获取obj1的节点 */
    domText.setData("100");

    if (!file.open(QIODevice::WriteOnly | QIODevice::Truncate))
    {
        qDebug() &lt;&lt; "Save failed";
        return;
    }
    QTextStream stream(&amp;file);
    doc.save(stream, 4);

    file.close();
}
</code></pre> 
<p>依然以写入的XML文档作为示例，修改后的文件为：</p> 
<pre><code class="prism language-xml"><span class="token prolog">&lt;?xml version='1.0' encoding='UTF-8'?&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--以下是矩形图元--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Rect<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>object</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>obj1<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>x1</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>100<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>x1</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>object</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>object</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>obj2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>x1</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>20<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>x1</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>object</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>class</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--以下是线图元--&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>line<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Line<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>没有线图元<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>class</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<h3><a id="_589"></a>总结</h3> 
<p>​ 以DOM方式对xml文件进行解析，可以进行对文件进行修改，这是SAX做不到的，但是其读写并没有SAX方便，两者结合，以SAX方式进行一次性读取，以DOM方式进行写入和修改应该是个不错的方式。</p> 
<h3><a id="_593"></a>参考</h3> 
<ol><li><a href="http://t.csdn.cn/BCh6u" rel="nofollow">XML文件详解</a></li><li><a href="https://doc.qt.io/qt-6/qtxml-module.html#details" rel="nofollow">Qt XML C++ Classes</a></li></ol>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/00601a4e0f70326aa0c8b8b7a7cd296b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于宏`uvm_info和$display的区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5c5dc1e7c60d9132872f84830a8e0f60/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">简单易懂CDN 的技术原理！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>