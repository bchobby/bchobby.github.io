<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ElasticSearch入门篇 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ElasticSearch入门篇" />
<meta property="og:description" content="本章将介绍：ElasticSearch的作用，搭建elasticsearch的环境（Windows/Linux），ElasticSearch集群的搭建，可视化客户端插件elasticsearch-head的安装及使用，对IK分词器的安装及使用；本章介绍的ElasticSearch操作基于Restful形式（使用http请求的形式）
笔记记录
1.ElasticSearch简介 Elaticsearch，简称为es， es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本
身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。es也使用Java开发并使用Lucene作为其核心来实
现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得
简单。
1.1ElasticSearch的使用案例 2013年初，GitHub抛弃了Solr，采取ElasticSearch 来做PB级的搜索。 “GitHub使用ElasticSearch搜索20TB
的数据，包括13亿文件和1300亿行代码”维基百科：启动以elasticsearch为基础的核心搜索架构SoundCloud：“SoundCloud使用ElasticSearch为1.8亿用户提供即时而精准的音乐搜索服务”百度：百度目前广泛使用ElasticSearch作为文本数据分析，采集百度所有服务器上的各类指标数据及用户自定义数据，通过对各种数据进行多维分析展示，辅助定位分析实例异常或业务层面异常。目前覆盖百度内部20多个业务线（包括casio、云分析、网盟、预测、文库、直达号、钱包、风控等），单集群最大100台机器，200个ES节点，每天导入30TB&#43;数据新浪使用ES 分析处理32亿条实时日志阿里使用ES 构建挖财自己的日志采集和分析体系 1.2 ElasticSearch与solr的对比 Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能;Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式；Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供；Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch 安装 ElasticSearch不做过多介绍
下面直接介绍ElasticSearch概念
3.ES相关概念 3.1 概述（重要） Elasticsearch是面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅
仅是存储，还会索引(index)每个文档的内容使之可以被搜索。在Elasticsearch中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。Elasticsearch比传统关系型数据库如下：
Relational DB ‐&gt; Databases ‐&gt; Tables ‐&gt; Rows ‐&gt; Columns
Elasticsearch ‐&gt; Indices ‐&gt; Types ‐&gt; Documents ‐&gt; Fields
3.2 核心概念 1）index索引- 一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。可类比mysql中的数据库
2）type类型 在一个索引中，你可以定义一种或多种类型。一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。比如说，我们假设你运营一个博客平台并且将你所有的数据存储到一个索引中。在这个索引中，你可以为用户数据定义一个类型，为博客数据定义另一个类型，当然，也可以为评论数据定义另一个类型。 可类比mysql中的表
3)Filed字段 相当于是数据表的字段，对文档数据根据不同属性进行的分类标识 。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/d4084dccad44be33c35f3b7da86df3f6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-18T14:42:54+08:00" />
<meta property="article:modified_time" content="2023-07-18T14:42:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ElasticSearch入门篇</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="background-color:#cccccc;">本章将介绍：ElasticSearch的作用，搭建elasticsearch的环境（Windows/Linux），ElasticSearch集群的搭建，可视化客户端插件elasticsearch-head的安装及使用，对IK分词器的安装及使用；本章介绍的ElasticSearch操作基于Restful形式（使用http请求的形式）</span></p> 
<p>笔记记录</p> 
<h2 id="1elasticsearch简介">1.ElasticSearch简介</h2> 
<p><span style="background-color:#cccccc;">Elaticsearch，简称为es， es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本</span><br><span style="background-color:#cccccc;">身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。es也使用Java开发并使用Lucene作为其核心来实</span><br><span style="background-color:#cccccc;">现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得</span><br><span style="background-color:#cccccc;">简单。</span></p> 
<h3 id="11elasticsearch的使用案例">1.1ElasticSearch的使用案例</h3> 
<ul><li>2013年初，GitHub抛弃了Solr，采取ElasticSearch 来做PB级的搜索。 “GitHub使用ElasticSearch搜索20TB<br> 的数据，包括13亿文件和1300亿行代码”</li><li>维基百科：启动以elasticsearch为基础的核心搜索架构</li><li>SoundCloud：“SoundCloud使用ElasticSearch为1.8亿用户提供即时而精准的音乐搜索服务”</li><li>百度：百度目前广泛使用ElasticSearch作为文本数据分析，采集百度所有服务器上的各类指标数据及用户自定义数据，通过对各种数据进行多维分析展示，辅助定位分析实例异常或业务层面异常。目前覆盖百度内部20多个业务线（包括casio、云分析、网盟、预测、文库、直达号、钱包、风控等），单集群最大100台机器，200个ES节点，每天导入30TB+数据</li><li>新浪使用ES 分析处理32亿条实时日志</li><li>阿里使用ES 构建挖财自己的日志采集和分析体系</li></ul> 
<h2 id="12-elasticsearch与solr的对比">1.2 ElasticSearch与solr的对比</h2> 
<ul><li>Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能;</li><li>Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式；</li><li>Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供；</li><li>Solr 在传统的搜索应用中表现好于 Elasticsearch，但在<strong>处理实时搜索应用时效率明显低于 Elasticsearch</strong></li></ul> 
<p>安装 ElasticSearch不做过多介绍</p> 
<p>下面直接介绍ElasticSearch概念</p> 
<h2 id="3es相关概念">3.ES相关概念</h2> 
<h3 id="31-概述重要">3.1 概述（重要）</h3> 
<p>Elasticsearch是面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅<br> 仅是存储，还会索引(index)每个文档的内容使之可以被搜索。在Elasticsearch中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。Elasticsearch比传统关系型数据库如下：</p> 
<blockquote> 
 <p>Relational DB ‐&gt; Databases ‐&gt; Tables ‐&gt; Rows ‐&gt; Columns<br> Elasticsearch ‐&gt; Indices ‐&gt; Types ‐&gt; Documents ‐&gt; Fields</p> 
</blockquote> 
<h3 id="32-核心概念">3.2 核心概念</h3> 
<h5 id="1index索引-">1）index索引-</h5> 
<blockquote> 
 <p>一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。<strong>可类比mysql中的数据库</strong></p> 
</blockquote> 
<h5 id="2type类型">2）type类型</h5> 
<blockquote> 
 <p>在一个索引中，你可以定义一种或多种类型。一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。比如说，我们假设你运营一个博客平台并且将你所有的数据存储到一个索引中。在这个索引中，你可以为用户数据定义一个类型，为博客数据定义另一个类型，当然，也可以为评论数据定义另一个类型。 <strong>可类比mysql中的表</strong></p> 
</blockquote> 
<h5 id="3filed字段">3)Filed字段</h5> 
<blockquote> 
 <p>相当于是数据表的字段，对文档数据根据不同属性进行的分类标识 。</p> 
</blockquote> 
<h5 id="4映射mapping">4）映射mapping</h5> 
<blockquote> 
 <p>mapping是处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分析器、是否被索引等等，这些都是映射里面可以设置的，其它就是处理es里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。<strong>相当于mysql中的创建表的过程，设置主键外键等等</strong></p> 
</blockquote> 
<h5 id="5document文档">5）document文档</h5> 
<blockquote> 
 <p>一个文档是一个可被索引的基础信息单元。比如，你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以JSON（Javascript Object Notation）格式来表示，而JSON是一个到处存在的互联网数据交互格式。在一个index/type里面，你可以存储任意多的文档。注意，尽管一个文档，物理上存在于一个索引之中，文档必须被索引/赋予一个索引的type。 <strong>插入索引库以文档为单位，类比与数据库中的一行数据</strong></p> 
</blockquote> 
<h5 id="6集群cluster">6）集群cluster</h5> 
<blockquote> 
 <p>一个集群就是由一个或多个节点组织在一起，它们共同持有整个的数据，并一起提供索引和搜索功能。一个集群由 一个唯一的名字标识，这个名字默认就是“elasticsearch”。这个名字是重要的，因为一个节点只能通过指定某个集 群的名字，来加入这个集群。</p> 
</blockquote> 
<h5 id="7节点node">7）节点node</h5> 
<blockquote> 
 <p>一个节点是集群中的一个服务器，作为集群的一部分，它存储数据，参与集群的索引和搜索功能。和集群类似，一 个节点也是由一个名字来标识的，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的 时候赋予节点。这个名字对于管理工作来说挺重要的，因为在这个管理过程中，你会去确定网络中的哪些服务器对 应于Elasticsearch集群中的哪些节点。</p> 
</blockquote> 
<blockquote> 
 <p>一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫 做“elasticsearch”的集群中，这意味着，如果你在你的网络中启动了若干个节点，并假定它们能够相互发现彼此， 它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。</p> 
</blockquote> 
<blockquote> 
 <p>在一个集群里，只要你想，可以拥有任意多个节点。而且，如果当前你的网络中没有运行任何Elasticsearch节点， 这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群。</p> 
</blockquote> 
<h5 id="8分片和复制-shardsreplicas">8）分片和复制 shards&amp;replicas</h5> 
<blockquote> 
 <p>一个索引可以存储超出单个结点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，这些份就叫做分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。分片很重要，主要有两方面的原因： 1）允许你水平分割/扩展你的内容容量。 2）允许你在分片（潜在地，位于多个节点上）之上进行分布式的、并行的操作，进而提高性能/吞吐量。</p> 
</blockquote> 
<blockquote> 
 <p>至于一个分片怎样分布，它的文档怎样聚合回搜索请求，是完全由Elasticsearch管理的，对于作为用户的你来说，这些都是透明的。</p> 
</blockquote> 
<blockquote> 
 <p>在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。</p> 
</blockquote> 
<blockquote> 
 <p>复制之所以重要，有两个主要原因： 在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。扩展你的搜索量/吞吐量，因为搜索可以在所有的复制上并行运行。总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。</p> 
</blockquote> 
<blockquote> 
 <p>默认情况下，Elasticsearch中的每个索引被分片5个主分片和1个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有5个主分片和另外5个复制分片（1个完全拷贝），这样的话每个索引总共就有10个分片。</p> 
</blockquote> 
<h2 id="4elasticsearch客户端操作">4.ElasticSearch客户端操作</h2> 
<p>上述部分为理论部分，实际开发中，主要有三种方式可以作为es服务的客户端：</p> 
<ul><li>使用elasticsearch-head插件</li><li>使用elasticsearch提供的Restful接口直接访问</li><li>使用elasticsearch提供的API进行访问</li></ul> 
<h3 id="41使用restful接口直接访问">4.1使用Restful接口直接访问</h3> 
<p>我们需要使用http请求，介绍两款接口测试工具：postman和Talend API tester。</p> 
<ul><li>Talend API tester安装：</li></ul> 
<p>这是一款chrome插件，无需下载；</p> 
<p><img alt="es08" src="https://images2.imgbox.com/40/46/D7elXl4Q_o.png"></p> 
<ul><li>Postman安装：</li></ul> 
<p>Postman官网：<a href="https://www.getpostman.com/" rel="nofollow" title="https://www.getpostman.com">https://www.getpostman.com</a></p> 
<p><img alt="es09" src="https://images2.imgbox.com/2e/b7/EM3Vf7F0_o.png"></p> 
<h3 id="42使用talend-api-tester进行es客户端操作">4.2使用Talend API tester进行es客户端操作。</h3> 
<h5 id="1elasticsearch的接口语法">1）Elasticsearch的接口语法</h5> 
<blockquote> 
 <p>curl ‐X&lt;VERB&gt; '&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;' ‐d '&lt;BODY&gt;'</p> 
</blockquote> 
<p>其中：</p> 
<p><img alt="es10" src="https://images2.imgbox.com/46/a0/e6WzrJ5F_o.png"></p> 
<h5 id="2创建索引库index并添加映射mapping------put">2）创建索引库index并添加映射mapping------PUT</h5> 
<p>请求体：</p> 
<blockquote> 
 <p>article：type类型；相当于这个索引库中有张表叫做article下面定义的这张表中的字段的定义，</p> 
 <p>字段默认为不索引的；</p> 
 <p>analyzer：分词器使用标准分词器</p> 
 <p> </p> 
</blockquote> 
<pre><code class="hljs">{
    "mappings": {
        "article": {
            "properties": {
                "id": {
                    "type": "long",
                    "store": true,
                    "index": "not_analyzed"
                },
                "title": {
                    "type": "text",
                    "store": true,
                    "index": "analyzed",
                    "analyzer": "standard"
                },
                "content": {
                    "type": "text",
                    "store": true,
                    "index": "analyzed",
                    "analyzer": "standard"
                }
            }
        }
    }
}</code></pre> 
<p><img alt="es11" src="https://images2.imgbox.com/59/a5/Pk7VF86N_o.png"></p> 
<p>在可视化工具elasticsearch-head中查看：</p> 
<p><img alt="es12" src="https://images2.imgbox.com/e4/be/bvBC7Owq_o.png"></p> 
<h5 id="3先创建索引index再添加mapping-----put">3）先创建索引index，再添加mapping ----PUT</h5> 
<p>我们可以在创建索引时设置mapping信息，当然也可以先创建索引然后再设置mapping。<br> 在上一个步骤中不设置maping信息，直接使用put方法创建一个索引，然后设置mapping信息。<br> 请求的url：</p> 
<blockquote> 
 <p>PUT http://127.0.0.1:9200/hello2/article/_mapping</p> 
</blockquote> 
<p>请求体：</p> 
<pre><code class="hljs">{
     "article": {
            "properties": {
                "id": {
                    "type": "long",
                    "store": true,
                    "index": "not_analyzed"
                },
                "title": {
                    "type": "text",
                    "store": true,
                    "index": "analyzed",
                    "analyzer": "standard"
                },
                "content": {
                    "type": "text",
                    "store": true,
                    "index": "analyzed",
                    "analyzer": "standard"
                }
            }
        }
}</code></pre> 
<p><img alt="es13" src="https://images2.imgbox.com/40/01/nZK33l7X_o.png"></p> 
<h5 id="4删除索引index-----delete">4)删除索引index ----DELETE</h5> 
<p>请求URL:</p> 
<blockquote> 
 <p>DELETE http://127.0.0.1:9200/hello2 </p> 
</blockquote> 
<p><img alt="es14" src="https://images2.imgbox.com/29/32/7c0XG5fh_o.png"></p> 
<h5 id="5创建文档document向索引库中添加内容---post">5)创建文档document（向索引库中添加内容）---POST</h5> 
<p>请求URL:</p> 
<blockquote> 
 <p>POST http://127.0.0.1:9200/hello/article/1 </p> 
</blockquote> 
<p>请求体：</p> 
<pre><code class="hljs">{
    "id": 1,
    "title": "ElasticSearch是一个基于Lucene的搜索服务器",
    "content": "它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。"
}</code></pre> 
<p><img alt="es15" src="https://images2.imgbox.com/2d/b6/L035hLYb_o.png"></p> 
<p>在elasticsearch-head中查看：</p> 
<p><img alt="es16" src="https://images2.imgbox.com/c4/36/iulRwWVv_o.png"></p> 
<p><strong>注意，一般我们将_id与id赋相同值。</strong></p> 
<h5 id="6修改document内容----post">6）修改document内容----POST</h5> 
<p>请求URL:</p> 
<blockquote> 
 <p>POST http://127.0.0.1:9200/hello/article/1</p> 
</blockquote> 
<p><img alt="es17" src="https://images2.imgbox.com/82/76/DtrBhmDg_o.png"></p> 
<p>在elasticsearch-head中查看：</p> 
<p><img alt="es18" src="https://images2.imgbox.com/d6/fb/4eVAWiwX_o.png"></p> 
<h5 id="7删除文档document---delete">7)删除文档document---DELETE</h5> 
<p>请求URL:</p> 
<blockquote> 
 <p>DELETE http://127.0.0.1:9200/hello/article/2</p> 
</blockquote> 
<p><img alt="es19" src="https://images2.imgbox.com/4c/11/ichkxdEM_o.png"></p> 
<h5 id="8查询文档document-----get">8)查询文档document-----GET</h5> 
<p>查询文档有三种方式：</p> 
<ul><li>根据id查询；</li><li>根据关键词查询</li><li>根据输入的内容先分词，再查询</li></ul> 
<h6 id="i根据id查询">i.根据id查询</h6> 
<p>请求URL：</p> 
<blockquote> 
 <p>GET http://127.0.0.1:9200/hello/article/1</p> 
</blockquote> 
<p><img alt="es20" src="https://images2.imgbox.com/ab/64/H5OSAwuq_o.png"></p> 
<h6 id="ii根据关键字查询-term查询">ii.根据关键字查询-term查询</h6> 
<p>请求URL：</p> 
<blockquote> 
 <p>POST http://127.0.0.1:9200/hello/article/_search </p> 
</blockquote> 
<p>请求体：</p> 
<pre><code class="hljs">{
    "query": {
        "term": {
            "title": "搜"
        }
    }
}</code></pre> 
<p><img alt="es21" src="https://images2.imgbox.com/96/8e/Fn56LxL4_o.png"></p> 
<h6 id="iii查询文档-querystring查询">iii.查询文档-querystring查询</h6> 
<p>请求URL：</p> 
<blockquote> 
 <p>POST http://127.0.0.1:9200/hello/article/_search </p> 
</blockquote> 
<p>请求体：</p> 
<pre><code class="hljs">{
    "query": {
        "query_string": {
            "default_field": "title",
            "query": "搜索服务器"
        }
    }
}</code></pre> 
<blockquote> 
 <p>指定：<br> 在哪个字段上进行查询；<br> 要查询的内容是什么；</p> 
 <p></p> 
 <p>它会把查询内容先进行分词，再进行查询</p> 
</blockquote> 
<p><img alt="es22" src="https://images2.imgbox.com/c4/6c/krSVXJ8y_o.png"></p> 
<h3 id="43使用elasticsearch-head进行es客户端操作">4.3使用elasticsearch-head进行es客户端操作</h3> 
<p>在elasticsearch-head中集成了http请求的工具，可以提供复查查询：<br><img alt="es27" src="https://images2.imgbox.com/63/3b/mlvCVcLg_o.png"></p> 
<h2 id="5ik分词器和elasticsearch集成使用">5.IK分词器和Elasticsearch集成使用</h2> 
<p>上述分词器使用的是标准分词器，其对中文分词不是很友好，例如对我是程序员进行分词得到：</p> 
<blockquote> 
 <p>GET http://127.0.0.1:9200/_analyze?analyzer=standard&amp;pretty=true&amp;text=我是程序员</p> 
</blockquote> 
<pre><code class="hljs">"tokens":[
{"token": "我", "start_offset": 0, "end_offset": 1, "type": "&lt;IDEOGRAPHIC&gt;",…},
{"token": "是", "start_offset": 1, "end_offset": 2, "type": "&lt;IDEOGRAPHIC&gt;",…},
{"token": "程", "start_offset": 2, "end_offset": 3, "type": "&lt;IDEOGRAPHIC&gt;",…},
{"token": "序", "start_offset": 3, "end_offset": 4, "type": "&lt;IDEOGRAPHIC&gt;",…},
{"token": "员", "start_offset": 4, "end_offset": 5, "type": "&lt;IDEOGRAPHIC&gt;",…}
]</code></pre> 
<p>我们希望达到的分词是：我、是、程序、程序员。</p> 
<p>支持中文的分词器有很多，word分词器，庖丁解牛，Ansj分词器，下面注意说IK分词器的使用。</p> 
<h3 id="51ik分词器的安装">5.1IK分词器的安装</h3> 
<p>1）下载地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases" title="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p> 
<p>2）解压，将解压后的elasticsearch文件夹拷贝到elasticsearch-5.6.8\plugins下，并重命名文件夹为analysis-ik （其他名字也可以，目的是不要重名）</p> 
<p>3）重新启动ElasticSearch，即可加载IK分词器</p> 
<p><img alt="es23" src="https://images2.imgbox.com/9d/34/wfENQAEI_o.png"></p> 
<h3 id="52ik分词器测试">5.2IK分词器测试</h3> 
<p>IK提供两种分词ik_smart和ik_max_word</p> 
<p>其中ik_smart为最少切分，ik_max_word为最细粒度划分。</p> 
<p>下面测试一下：</p> 
<ul><li>最小切分：在浏览器输入地址：</li></ul> 
<blockquote> 
 <p> GET http://127.0.0.1:9200/_analyze?analyzer=ik_smart&amp;pretty=true&amp;text=我是程序员</p> 
</blockquote> 
<p>返回结果：</p> 
<pre><code class="hljs">"tokens":[
{"token": "我", "start_offset": 0, "end_offset": 1, "type": "CN_CHAR",…},
{"token": "是", "start_offset": 1, "end_offset": 2, "type": "CN_CHAR",…},
{"token": "程序员", "start_offset": 2, "end_offset": 5, "type": "CN_WORD",…}
]</code></pre> 
<ul><li>最新切分：在浏览器输入地址：</li></ul> 
<blockquote> 
 <p>GET http://127.0.0.1:9200/_analyze?analyzer=ik_max_word&amp;pretty=true&amp;text=我是程序员</p> 
</blockquote> 
<p>返回结果：</p> 
<pre><code class="hljs">"tokens":[
{"token": "我", "start_offset": 0, "end_offset": 1, "type": "CN_CHAR",…},
{"token": "是", "start_offset": 1, "end_offset": 2, "type": "CN_CHAR",…},
{"token": "程序员", "start_offset": 2, "end_offset": 5, "type": "CN_WORD",…},
{"token": "程序", "start_offset": 2, "end_offset": 4, "type": "CN_WORD",…},
{"token": "员", "start_offset": 4, "end_offset": 5, "type": "CN_CHAR",…}
]</code></pre> 
<h2 id="6elasticsearch集群">6.ElasticSearch集群</h2> 
<blockquote> 
 <p>ES集群是一个 P2P类型(使用 gossip 协议)的分布式系统，除了集群状态管理以外，其他所有的请求都可以发送到集群内任意一台节点上，这个节点可以自己找到需要转发给哪些节点，并且直接跟这些节点通信。所以，从网络架构及服务配置上来说，构建集群所需要的配置极其简单。在 Elasticsearch 2.0 之前，无阻碍的网络下，所有配置了相同 cluster.name 的节点都自动归属到一个集群中。2.0 版本之后，基于安全的考虑避免开发环境过于随便造成的麻烦，从 2.0 版本开始，默认的自动发现方式改为了单播(unicast)方式。配置里提供几台节点的地址，ES 将其视作gossip router 角色，借以完成集群的发现。由于这只是 ES 内一个很小的功能，所以 gossip router 角色并不需要单独配置，每个 ES 节点都可以担任。所以，采用单播方式的集群，各节点都配置相同的几个节点列表作为 router即可。</p> 
</blockquote> 
<p>集群中节点数量没有限制，一般大于等于2个节点就可以看做是集群了。一般处于高性能及高可用方面来</p> 
<p>虑一般集群中的节点数量都是3个及3个以上 .</p> 
<h3 id="61-集群的搭建windows">6.1 集群的搭建（Windows）</h3> 
<h5 id="1准备三台elasticsearch服务器">1）准备三台elasticsearch服务器：</h5> 
<p><img alt="es24" src="https://images2.imgbox.com/a3/17/7fQVd9Kk_o.png"></p> 
<h5 id="2修改每台服务器的配置">2）修改每台服务器的配置</h5> 
<p>修改\comf\elasticsearch.yml配置文件：</p> 
<pre><code class="hljs">#Node节点1：

http.cors.enabled: true
http.cors.allow-origin: "*"
#节点1的配置信息：
#集群名称，保证唯一
cluster.name: my-elasticsearch
#节点名称，必须不一样
node.name: node-1
#必须为本机的ip地址
network.host: 127.0.0.1
#服务端口号，在同一机器下必须不一样
http.port: 9201
#集群间通信端口号，在同一机器下必须不一样
transport.tcp.port: 9301
#设置集群自动发现机器ip集合
discovery.zen.ping.unicast.hosts: ["127.0.0.1:9301","127.0.0.1:9302","127.0.0.1:9303"]

#Node节点2：

http.cors.enabled: true
http.cors.allow-origin: "*"
#节点1的配置信息：
#集群名称，保证唯一
cluster.name: my-elasticsearch
#节点名称，必须不一样
node.name: node-2
#必须为本机的ip地址
network.host: 127.0.0.1
#服务端口号，在同一机器下必须不一样
http.port: 9202
#集群间通信端口号，在同一机器下必须不一样
transport.tcp.port: 9302
#设置集群自动发现机器ip集合
discovery.zen.ping.unicast.hosts: ["127.0.0.1:9301","127.0.0.1:9302","127.0.0.1:9303"]

#Node节点3：

http.cors.enabled: true
http.cors.allow-origin: "*"
#节点1的配置信息：
#集群名称，保证唯一
cluster.name: my-elasticsearch
#节点名称，必须不一样
node.name: node-3
#必须为本机的ip地址
network.host: 127.0.0.1
#服务端口号，在同一机器下必须不一样
http.port: 9203
#集群间通信端口号，在同一机器下必须不一样
transport.tcp.port: 9303
#设置集群自动发现机器ip集合
discovery.zen.ping.unicast.hosts: ["127.0.0.1:9301","127.0.0.1:9302","127.0.0.1:9303"]</code></pre> 
<p> </p> 
<h5 id="3启动各个节点服务器">3.启动各个节点服务器</h5> 
<p>可以分别启动每个服务器下的elasticsearch.bat，我这里使用的是windows下的批处理文件：</p> 
<p>新建一个elasticsearch_cluster_start.bat文件，然后添加下面内容：</p> 
<p>格式为：start "需要启动的文件名" "文件的路径" &amp;表示启动A后继续执行。</p> 
<blockquote> 
 <p>start "elasticsearch.bat" "F:\Soft\ES-cluster\cluster01\bin\elasticsearch.bat" &amp; start "elasticsearch.bat" "F:\Soft\ES-cluster\cluster02\bin\elasticsearch.bat" &amp; start "elasticsearch.bat" "F:\Soft\ES-cluster\cluster03\bin\elasticsearch.bat"</p> 
</blockquote> 
<p>关于Windows的批处理在本章就不细说了。</p> 
<h5 id="4集群测试">4.集群测试</h5> 
<blockquote> 
 <p>只要连接集群中的任意节点，其操作方式与单机版本基本相同，改变的仅仅是存储的结构。</p> 
</blockquote> 
<p><strong>添加索引和映射</strong></p> 
<blockquote> 
 <p>PUT http://127.0.0.1:9201/hello</p> 
</blockquote> 
<p>请求体：</p> 
<pre><code class="hljs">{
    "mappings": {
    "article": {
        "properties": {
            "id": {
                "type": "long",
                "store": true,
                 "index": "not_analyzed"
            },
            "title": {
                "type": "text",
                "store": true,
                "index": true,
                "analyzer": "ik_smart"
            },
            "content": {
                "type": "text",
                "store": true,
                "index": true,
                "analyzer": "ik_smart"
            }
        }
    }
    }
}</code></pre> 
<p>返回结果：</p> 
<pre><code class="hljs">{
"acknowledged": true,
"shards_acknowledged": true,
"index": "hello"
}</code></pre> 
<p><strong>添加文档</strong></p> 
<blockquote> 
 <p>POST http://127.0.0.1:9201/hello/article/1</p> 
</blockquote> 
<p> 请求体：</p> 
<pre><code class="hljs">{
"id":1,
"title":"ElasticSearch是一个基于Lucene的搜索服务器",
"content":"它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。"
}</code></pre> 
<p>返回值：</p> 
<pre><code class="hljs">{
"_index": "hello",
"_type": "article",
"_id": "1",
"_version": 1,
"result": "created",
"_shards":{
"total": 2,
"successful": 2,
"failed": 0
},
"created": true
}</code></pre> 
<p>在elasticsearch-head中查看：</p> 
<p><img alt="es25" src="https://images2.imgbox.com/3d/3a/8q8st2yh_o.png"></p> 
<p><img alt="es26" src="https://images2.imgbox.com/e4/7f/HiH7GwQB_o.png"></p> 
<h2 id="7elasticsearch安装linux">7.ElasticSearch安装（Linux）</h2> 
<h5 id="1保证你已经安装了java环境">1）保证你已经安装了java环境</h5> 
<p>可以直接把windows中的copy过去，不用安装，解压即可。</p> 
<blockquote> 
 <p>tar -zxf elasticsearch-6.3.2.tar.gz</p> 
</blockquote> 
<h5 id="2修改配置文件">2)修改配置文件</h5> 
<ul><li>修改conf\jvm.option文件</li></ul> 
<pre><code class="hljs">将#-Xms2g                                  
  #-Xmx2g修改成为：
-Xms340m
-Xmx340m
否则因为虚拟机内存不够无法启动</code></pre> 
<ul><li>修改conf\elasticsearch.yml文件</li></ul> 
<pre><code class="hljs">#elasticsearch-5.6.8\config\elasticsearch.yml中末尾加入：
http.cors.enabled: true
http.cors.allow-origin: "*"
network.host: 127.0.0.1
目的是使ES支持跨域请求</code></pre> 
<h5 id="3启动">3）启动</h5> 
<p><strong>注意：在linux环境下不支持root用户直接启动（理由是安全问题）</strong></p> 
<ul><li>添加用户：</li></ul> 
<pre><code class="hljs">[root@coderxz bin]# useradd rxz -p rongxianzhao
[root@coderxz bin]# chown -R rxz:rxz /usr/local/elasticsearch/*
[root@coderxz bin]# su rxz</code></pre> 
<p>执行:</p> 
<blockquote> 
 <p>#注意：切换为非root用户执行哦 [rxz@coderxz bin]$ ./elasticsearch</p> 
</blockquote> 
<p>查看运行状态</p> 
<pre><code class="hljs">检测是否运行：jps （显示所有的Java进程pid的命令）
	              ps aux|grep elasticsearch
				  [root@coderxz ~]# curl -X GET 'http://localhost:9200'</code></pre> 
<h5 id="4配置外网访问9200端口--需要开放服务器的端口">4)配置外网访问9200端口 需要开放服务器的端口</h5> 
<blockquote> 
 <p>修改配置文件 config/elasticsearch.yml</p> 
 <p>network.host: 0.0.0.0</p> 
</blockquote> 
<h5 id="5后台启动">5)后台启动</h5> 
<blockquote> 
 <p>如果你在服务器上安装Elasticsearch，而你想在本地机器上进行开发，这时候，你很可能需要在关闭终端的时候，让Elasticsearch继续保持运行。最简单的方法就是使用nohup。先按<strong>Ctrl + C</strong>，停止当前运行的Elasticsearch，改用下面的命令运行Elasticsearch。</p> 
</blockquote> 
<blockquote> 
 <p>nohup ./bin/elasticsearch&amp;</p> 
</blockquote>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9da65f21f822a65d90312d4bd4dbac68/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">kali密码攻击之在线攻击hydra</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/61c39f16482c11e61cad2beae5040300/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VMWare 虚拟机如何扩展磁盘空间并挂载到已存在的根目录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>