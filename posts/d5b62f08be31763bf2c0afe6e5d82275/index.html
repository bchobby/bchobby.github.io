<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring Security 0auth2 认证服务器和资源服务器实现 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring Security 0auth2 认证服务器和资源服务器实现" />
<meta property="og:description" content="一，OAuth2开放授权协议/标准 OAuth（开放授权）是⼀个开放协议/标准，允许⽤户授权第三⽅应⽤访问他们存储在另外的服务提供者
上的信息，⽽不需要将⽤户名和密码提供给第三⽅应⽤或分享他们数据的所有内容。
允许⽤户授权第三⽅应⽤访问他们存储在另外的服务提供者上的信息，⽽不需要将⽤户名和密码提供给
第三⽅应⽤或分享他们数据的所有内容
client_id ：客户端id（QQ最终相当于⼀个认证授权服务器，木瓜餐饮就相当于⼀个客户端了，所以会
给 ⼀个客户端id），相当于账号
secret：相当于密码
资源所有者（Resource Owner）：可以理解为⽤户⾃⼰
客户端（Client）：我们想登陆的⽹站或应⽤，⽐如淘宝
认证服务器（Authorization Server）：可以理解为微信或者QQ
资源服务器（Resource Server）：可以理解为微信或者QQ
二、什么情况下需要使用OAuth2 第三⽅授权登录的场景：⽐如，我们经常登录⼀些⽹站或者应⽤的时候，可以选择使⽤第三⽅授权登录
的⽅式，⽐如：微信授权登录、QQ授权登录、微博授权登录等，这是典型的 OAuth2 使⽤场景。
单点登录的场景：如果项⽬中有很多微服务或者公司内部有很多服务，可以专⻔做⼀个认证中⼼（充当
认证平台⻆⾊），所有的服务都要到这个认证中⼼做认证，只做⼀次登录，就可以在多个授权范围内的
服务中⾃由串⾏。
OAuth2的颁发Token授权⽅式
1）授权码（authorization-code）2）密码式（password）提供⽤户名&#43;密码换取token令牌
3）隐藏式（implicit） 4）客户端凭证（client credentials）
授权码模式使⽤到了回调地址，是最复杂的授权⽅式，微博、微信、QQ等第三⽅登录就是这种模式。我
们说接⼝对接中常使⽤的password密码模式（提供⽤户名&#43;密码换取token）。
三、Spring Cloud OAuth2 &#43; JWT 实现 Spring Cloud OAuth2 是 Spring Cloud 体系对OAuth2协议的实现，可以⽤来做多个微服务的统⼀认证
（验证身份合法性）授权（验证权限）。通过向OAuth2服务（统⼀认证授权服务）发送某个类型的
grant_type进⾏集中认证和授权，从⽽获得access_token（访问令牌），⽽这个token是受其他微服务
信任的。
注意：使⽤OAuth2解决问题的本质是，引⼊了⼀个认证授权层，认证授权层连接了资源的拥有者，在
授权层⾥⾯，资源的拥有者可以给第三⽅应⽤授权去访问我们的某些受保护资源
1，授权服务器 1，pom 导入
&lt;!--导入spring cloud oauth2依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.security.oauth.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-autoconfigure&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-autoconfigure&lt;/artifactId&gt; &lt;version&gt;2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/d5b62f08be31763bf2c0afe6e5d82275/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-07T22:49:43+08:00" />
<meta property="article:modified_time" content="2023-02-07T22:49:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring Security 0auth2 认证服务器和资源服务器实现</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h2 style=""><span class="kdocs-bold" style="font-weight:bold;">一，OAuth2开放授权协议/标准</span></h2> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;">OAuth（开放授权）是⼀个开放协议/标准，允许⽤户授权第三⽅应⽤访问他们存储在另外的服务提供者</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;">上的信息，⽽不需要将⽤户名和密码提供给第三⽅应⽤或分享他们数据的所有内容。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">允许⽤户授权第三⽅应⽤访问他们存储在另外的服务提供者上的信息，⽽不需要将⽤户名和密码提供给</span></span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">第三⽅应⽤或分享他们数据的所有内容</span></span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1166px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:51.457973%;height:0;"> 
    <img src="https://images2.imgbox.com/31/e3/e8iLrpC0_o.png" style="margin-left:;display:block;width:1166px;margin-top:-51.457973%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">client_id </span>：客户端id（QQ最终相当于⼀个认证授权服务器，木瓜餐饮就相当于⼀个客户端了，所以会</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;">给 ⼀个客户端id），相当于账号</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">secret：</span>相当于密码</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">资源所有者（Resource Owner）：</span>可以理解为⽤户⾃⼰</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">客户端（Client）：</span>我们想登陆的⽹站或应⽤，⽐如淘宝</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">认证服务器（Authorization Server）：</span>可以理解为微信或者QQ</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">资源服务器（Resource Server）：</span>可以理解为微信或者QQ</span></p> 
 <h2 style=""><span class="kdocs-bold" style="font-weight:bold;">二、什么情况下需要使用OAuth2</span></h2> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">第三⽅授权登录的场景：</span>⽐如，我们经常登录⼀些⽹站或者应⽤的时候，可以选择使⽤第三⽅授权登录</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;">的⽅式，⽐如：微信授权登录、QQ授权登录、微博授权登录等，这是典型的 OAuth2 使⽤场景。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">单点登录的场景：</span>如果项⽬中有很多微服务或者公司内部有很多服务，可以专⻔做⼀个认证中⼼（充当</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;">认证平台⻆⾊），所有的服务都要到这个认证中⼼做认证，只做⼀次登录，就可以在多个授权范围内的</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;">服务中⾃由串⾏。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">OAuth2的颁发Token授权⽅式</span></span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;">1）授权码（authorization-code）2）密码式（password）提供⽤户名+密码换取token令牌</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;">3）隐藏式（implicit） </span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;">4）客户端凭证（client credentials）</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">授权码模式使⽤到了回调地址，是最复杂的授权⽅式，微博、微信、QQ等第三⽅登录就是这种模式。我</span></span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">们说接⼝对接中常使⽤的password密码模式（提供⽤户名+密码换取token）。</span></span></p> 
 <h2 style=""><span class="kdocs-bold" style="font-weight:bold;">三、Spring Cloud OAuth2 + JWT 实现</span></h2> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;">Spring Cloud OAuth2 是 Spring Cloud 体系对OAuth2协议的实现，可以⽤来做多个微服务的统⼀认证</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;">（验证身份合法性）授权（验证权限）。通过向OAuth2服务（统⼀认证授权服务）发送某个类型的</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;">grant_type进⾏集中认证和授权，从⽽获得access_token（访问令牌），⽽这个token是受其他微服务</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;">信任的。</span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">注意：使⽤OAuth2解决问题的本质是，引⼊了⼀个认证授权层，认证授权层连接了资源的拥有者，在</span></span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">授权层⾥⾯，资源的拥有者可以给第三⽅应⽤授权去访问我们的某些受保护资源</span></span></p> 
 <h4 style="">1，授权服务器</h4> 
 <p style="">1，pom 导入</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">&lt;!--导入spring cloud oauth2依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;
            &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.security.oauth.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-security-oauth2-autoconfigure&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security.oauth.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-oauth2-autoconfigure&lt;/artifactId&gt;
            &lt;version&gt;2.1.11.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--引入security对oauth2的支持--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;
            &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;</code></pre> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">package com.mugua.oauth.config;


import com.mugua.oauth.service.CustomUserDetailsService;
import com.mugua.oauth.service.impl.CustomTokenServices;
import com.mugua.oauth.translator.CustomWebResponseExceptionTranslator;
import com.mugua.oauth.wrapper.CustomUserDetailsByNameServiceWrapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.jwt.crypto.sign.MacSigner;
import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.client.JdbcClientDetailsService;
import org.springframework.security.oauth2.provider.token.TokenStore;
import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.store.JwtTokenStore;
import org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationProvider;

import javax.sql.DataSource;
import java.util.Arrays;

@Configuration
@EnableAuthorizationServer
@RefreshScope
public class OauthServerConfig extends AuthorizationServerConfigurerAdapter {

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private DataSource dataSource;

    @Autowired
    private CustomUserDetailsService usersService;

    @Autowired
    private CustomWebResponseExceptionTranslator customWebResponseExceptionTranslator;

    /**
     * jwt签名密钥
     */
    @Value("${spring.sign.key}")
    private String signKey;

    /**
     * 设置令牌过期时间，一般大厂会设置为2个小时 单位为秒
     */
    @Value("${token.time.tokenValidity}")
    private String tokenValidity;

    /**
     * 设置刷新令牌的有效时间  3天
     */
    @Value("${token.time.refreshTokenValidity}")
    private String refreshTokenValidity;

    /**
     * 认证服务器最终是以api对外提供服务（校验合法性，并且生成令牌，校验令牌等）
     * 那么，以api接口方式对外的话，就必然涉及到接口的访问权限，需要在这这里进行配置
     */
    @Override
    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
        super.configure(security);
        //相当于打开endpoint访问的接口开关，这样的话后期就能访问该接口
        security
                //允许客户端表单认证
                //主要是让/oauth/token支持client_id和client_secret做登陆认证如果开启了allowFormAuthenticationForClients，那么就在BasicAuthenticationFilter之前
                //添加ClientCredentialsTokenEndpointFilter,使用ClientDetailsUserDetailsService来进行登陆认证
                //这个如果配置支持allowFormAuthenticationForClients的，且url中有client_id和client_secret的会走ClientCredentialsTokenEndpointFilter来保护
                //如果没有支持allowFormAuthenticationForClients或者有支持但是url中没有client_id和client_secret的，走basic认证保护
                .allowFormAuthenticationForClients()
                //开启端口/oauth/token_key的访问权限（允许） 可以理解为生成令牌
                .tokenKeyAccess("permitAll()")
                //开启端口/oauth/check_token的访问权限（允许）  可以理解为校验令牌
                .checkTokenAccess("permitAll()");

    }

    /**
     * 客户端详情，比如client_id,secret
     * 比如这个服务就如果QQ平台，腾讯邮箱作为客户端，需要QQ平台进行认证授权登录认证等，
     * 提前需要到QQ平台注册，QQ平台会给QQ邮箱
     * 颁发client_id等必要参数，表明客户端是谁
     */
    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        super.configure(clients);
        // 从内存中加载客户端详情改为从数据库中加载客户端详情
        clients.withClientDetails(createJdbcClientDetailsService());
    }


    @Bean
    public JdbcClientDetailsService createJdbcClientDetailsService() {
        return new JdbcClientDetailsService(dataSource);
    }


    /**
     * 认证服务器是玩转token，那么这里配置token令牌管理相关（token此时就是一个字符串当下的token需要在服务器端存储)
     */
    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
        super.configure(endpoints);
        endpoints
                //指定token存储方法
                .tokenStore(tokenStore())
                //token服务的一个描述，可以认为是token生成的细节的描述，比如有效时间等
                .tokenServices(customTokenServices())
                .reuseRefreshTokens(true)
                //指定认证管理器，随后注入一个到当前类
                .authenticationManager(authenticationManager)
                .userDetailsService(usersService)
                //异常翻译处理
                .exceptionTranslator(customWebResponseExceptionTranslator)
                //请求类型
                .allowedTokenEndpointRequestMethods(HttpMethod.GET, HttpMethod.POST);

    }

    /**
     * 该方法用于创建tokenStore对象（令牌存储对象）token以什么形式存储
     */
    public TokenStore tokenStore() {
        //使用jwt令牌
        return new JwtTokenStore(jwtAccessTokenConverter());
    }

    /**
     * 返回jwt令牌转换器（帮助我们⽣成jwt令牌的）在这⾥，我们可以把签名密钥传递进去给转换器对象
     */
    public JwtAccessTokenConverter jwtAccessTokenConverter() {
        //签名密钥
        JwtAccessTokenConverter jwtAccessTokenConverter = new JwtAccessTokenConverter();
        jwtAccessTokenConverter.setSigningKey(signKey);
        //验证时使⽤的密钥，和签名密钥保持⼀致
        jwtAccessTokenConverter.setVerifier(new MacSigner(signKey));
        return jwtAccessTokenConverter;
    }

    public CustomTokenServices customTokenServices() {
        CustomTokenServices tokenServices = new CustomTokenServices();
        //令牌存在哪里
        tokenServices.setTokenStore(tokenStore());
        //开启令牌刷新
        tokenServices.setSupportRefreshToken(true);
        tokenServices.setReuseRefreshToken(true);
        tokenServices.setClientDetailsService(createJdbcClientDetailsService());
        //针对jwt令牌的添加
        tokenServices.setTokenEnhancer(jwtAccessTokenConverter());
        // 设置自定义的CustomUserDetailsByNameServiceWrapper
        if (usersService != null) {
            PreAuthenticatedAuthenticationProvider provider = new PreAuthenticatedAuthenticationProvider();
            provider.setPreAuthenticatedUserDetailsService(new CustomUserDetailsByNameServiceWrapper(usersService));
            tokenServices.setAuthenticationManager(new ProviderManager(Arrays.asList(provider)));
        }
        //设置令牌过期时间，一般大厂会设置为2个小时 单位为秒
        tokenServices.setAccessTokenValiditySeconds(Integer.parseInt(tokenValidity));
        //设置刷新令牌的有效时间  //3天
        tokenServices.setRefreshTokenValiditySeconds(Integer.parseInt(refreshTokenValidity));
        return tokenServices;
    }

}
</code></pre> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">package com.mugua.oauth.service;

import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;

/**
 * 继承原来的UserDetailsService新增自定义方法
 *
 * @author liwenchao
 */
public interface CustomUserDetailsService extends UserDetailsService {

    UserDetails loadUserByUsername(String username, String userType) throws UsernameNotFoundException;

    @Override
    default UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        return null;
    }

}</code></pre> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">package com.mugua.oauth.translator;

import com.mugua.oauth.entity.DmpResult;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.oauth2.common.exceptions.*;
import org.springframework.security.oauth2.provider.error.WebResponseExceptionTranslator;
import org.springframework.stereotype.Component;

/**
 * 异常翻译
 * 就返回了500 没有返回具体的参数code码
 *
 * @author lwc
 */
@Slf4j
@Component
@SuppressWarnings("all")
public class CustomWebResponseExceptionTranslator implements WebResponseExceptionTranslator {

    @Override
    public ResponseEntity&lt;?&gt; translate(Exception e) {
        ResponseEntity.BodyBuilder status = ResponseEntity.status(HttpStatus.BAD_REQUEST);
        String code = null;
        String message = "认证失败";
        log.error(message, e);
        if (e instanceof UnsupportedGrantTypeException) {
            code = String.valueOf(((UnsupportedGrantTypeException) e).getHttpErrorCode());
            message = "不支持该认证类型";
            return status.body(DmpResult.data(code, message));
        }
        if (e instanceof InvalidTokenException
                &amp;&amp; StringUtils.containsIgnoreCase(e.getMessage(), "Invalid refresh token (expired)")) {
            code = String.valueOf(((InvalidTokenException) e).getHttpErrorCode());
            message = "刷新令牌已过期，请重新登录";
            status = ResponseEntity.status(HttpStatus.UNAUTHORIZED);
            return status.body(DmpResult.data(code, message));
        }
        if (e instanceof InvalidScopeException) {
            code = String.valueOf(((InvalidScopeException) e).getHttpErrorCode());
            message = "不是有效的scope值";
            return status.body(DmpResult.data(code, message));
        }
        if (e instanceof RedirectMismatchException) {
            code = String.valueOf(((RedirectMismatchException) e).getHttpErrorCode());
            message = "redirect_uri值不正确";
            return status.body(DmpResult.data(code, message));
        }
        if (e instanceof BadClientCredentialsException) {
            code = String.valueOf(((BadClientCredentialsException) e).getHttpErrorCode());
            message = "client值不合法";
            status = ResponseEntity.status(HttpStatus.UNAUTHORIZED);
            return status.body(DmpResult.data(code, message));
        }
        if (e instanceof UnsupportedResponseTypeException) {
            code = String.valueOf(((UnsupportedResponseTypeException) e).getHttpErrorCode());
            String codeMessage = StringUtils.substringBetween(e.getMessage(), "[", "]");
            message = codeMessage + "不是合法的response_type值";
            return status.body(DmpResult.data(code, message));
        }
        if (e instanceof InvalidGrantException) {
            code = String.valueOf(((InvalidGrantException) e).getHttpErrorCode());
            if (StringUtils.containsIgnoreCase(e.getMessage(), "Invalid refresh token")) {
                message = "refresh token无效";
                return status.body(DmpResult.data(code, message));
            }
            if (StringUtils.containsIgnoreCase(e.getMessage(), "Invalid authorization code")) {
                code = String.valueOf(((InvalidGrantException) e).getHttpErrorCode());
                String codeMessage = StringUtils.substringAfterLast(e.getMessage(), ": ");
                message = "授权码" + codeMessage + "不合法";
                return status.body(DmpResult.data(code, message));
            }
            if (StringUtils.containsIgnoreCase(e.getMessage(), "locked")) {
                message = "用户已被锁定，请联系管理员";
                return status.body(DmpResult.data(code, message));
            }
            message = "用户名或密码错误";
            return status.body(DmpResult.data(code, message));
        }

        if (e instanceof UsernameNotFoundException) {
            message = e.getMessage();
            code = String.valueOf(HttpStatus.UNAUTHORIZED.value());
            return status.body(DmpResult.data(code, message));
        }
        //没翻译到的用默认
        if (e instanceof Exception) {
            code = String.valueOf(HttpStatus.INTERNAL_SERVER_ERROR.value());
            return status.body(DmpResult.data(code, message));
        }
        code = String.valueOf(HttpStatus.INTERNAL_SERVER_ERROR.value());
        return status.body(DmpResult.data(code, message));
    }
}
</code></pre> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">/*
 * Copyright 2002-2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.mugua.oauth.wrapper;

import com.mugua.oauth.service.CustomUserDetailsService;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.security.authentication.AbstractAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.AuthenticationUserDetailsService;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.util.Assert;

import java.util.Map;

/**
 * This implementation for AuthenticationUserDetailsService wraps a regular Spring
 * Security UserDetailsService implementation, to retrieve a UserDetails object based on
 * the user name contained in an &lt;tt&gt;Authentication&lt;/tt&gt; object.
 *
 * @author Ruud Senden
 * @author Scott Battaglia
 * @since 2.0
 */
public class CustomUserDetailsByNameServiceWrapper&lt;T extends Authentication&gt; implements AuthenticationUserDetailsService&lt;T&gt;, InitializingBean {

    private CustomUserDetailsService userDetailsService = null;

    /**
     * Constructs an empty wrapper for compatibility with Spring Security 2.0.x's method
     * of using a setter.
     */
    public CustomUserDetailsByNameServiceWrapper() {
        // constructor for backwards compatibility with 2.0
    }

    /**
     * Constructs a new wrapper using the supplied
     * {@link org.springframework.security.core.userdetails.UserDetailsService} as the
     * service to delegate to.
     *
     * @param userDetailsService the UserDetailsService to delegate to.
     */
    public CustomUserDetailsByNameServiceWrapper(final CustomUserDetailsService userDetailsService) {
        Assert.notNull(userDetailsService, "userDetailsService cannot be null.");
        this.userDetailsService = userDetailsService;
    }

    /**
     * Check whether all required properties have been set.
     *
     * @see org.springframework.beans.factory.InitializingBean#afterPropertiesSet()
     */
    @Override
    public void afterPropertiesSet() {
        Assert.notNull(this.userDetailsService, "UserDetailsService must be set");
    }

    /**
     * Get the UserDetails object from the wrapped UserDetailsService implementation
     */
    @Override
    public UserDetails loadUserDetails(T authentication) throws UsernameNotFoundException {
        // ----------添加自定义的内容----------
        AbstractAuthenticationToken principal = (AbstractAuthenticationToken) authentication.getPrincipal();
        Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) principal.getDetails();
        String userType = map.get("userType");
        // ----------添加自定义的内容----------
        return this.userDetailsService.loadUserByUsername(authentication.getName(), userType); // 使用自定义的userDetailsService
    }

    /**
     * Set the wrapped UserDetailsService implementation
     *
     * @param aUserDetailsService The wrapped UserDetailsService to set
     */
    public void setUserDetailsService(CustomUserDetailsService aUserDetailsService) {
        this.userDetailsService = aUserDetailsService;
    }
}
</code></pre> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">package com.mugua.oauth.encoder;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.mugua.oauth.utils.DecodeUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.nio.charset.StandardCharsets;
import java.util.Base64;

/**
 * @author liwenchao
 */
@Slf4j
public class CustomPasswordEncoder implements PasswordEncoder {

    /**
     * 加密(外面调用一般在注册的时候加密前端传过来的密码保存进数据库)
     * 注册不在这里进行所以这里暂时不进行操作保持明文
     * rawPassword == userNotFoundPassword 防止计时攻击
     *
     * @param rawPassword 前端传过来的密码
     */
    @Override
    public String encode(CharSequence rawPassword) {
        return rawPassword.toString();
    }

    /**
     * 加密前后对比(一般用来比对前端提交过来的密码和数据库存储密码, 也就是明文和密文的对比)
     *
     * @param rawPassword     前端传过来的密码
     * @param encodedPassword 数据库取出的密码
     */
    @Override
    public boolean matches(CharSequence rawPassword, String encodedPassword) {
        if (rawPassword == null) {
            throw new IllegalArgumentException("rawPassword cannot be null");
        }
        if (encodedPassword == null || encodedPassword.length() == 0) {
            log.info("Empty encoded password");
            return false;
        }
        //判断是否base64
        boolean b = DecodeUtils.checkBase64(rawPassword.toString());
        if (!b) {
            return rawPassword.toString().equalsIgnoreCase(encodedPassword);
        }
        String passwordJson = null;
        try {
            passwordJson = new String(Base64.getDecoder().decode(rawPassword.toString()), StandardCharsets.UTF_8);
        } catch (Exception e) {
            log.error("rawPassword {} decoder fail", passwordJson);
        }
        JSONObject jsonObject = JSON.parseObject(passwordJson);
        String type = jsonObject.getString("p1");
        String password = jsonObject.getString("p2");
        if("webDefault".equalsIgnoreCase(type)){
            return true;
        }
        JSONObject json = JSON.parseObject(encodedPassword);
        String returnPwd = json.getString("p2");
        String salt = json.getString("p3");
        return  !"default".equalsIgnoreCase(type) || DecodeUtils.matchesForUser(password, returnPwd, salt);
    }
}
</code></pre> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">/*
 * Copyright 2004, 2005, 2006 Acegi Technology Pty Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.mugua.oauth.provider;

import com.mugua.oauth.service.CustomUserDetailsService;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.InternalAuthenticationServiceException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsPasswordService;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.util.Assert;

import java.util.Map;

/**
 * An {@link AuthenticationProvider} implementation that retrieves user details from a
 * {@link UserDetailsService}.
 *
 * @author Ben Alex
 * @author Rob Winch
 */
public class CustomAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider {
    // ~ Static fields/initializers
    // =====================================================================================

    /**
     * The plaintext password used to perform
     * PasswordEncoder#matches(CharSequence, String)}  on when the user is
     * not found to avoid SEC-2056.
     */
    private static final String USER_NOT_FOUND_PASSWORD = "userNotFoundPassword";

    // ~ Instance fields
    // ================================================================================================

    private PasswordEncoder passwordEncoder;

    /**
     * The password used to perform
     * {@link PasswordEncoder#matches(CharSequence, String)} on when the user is
     * not found to avoid SEC-2056. This is necessary, because some
     * {@link PasswordEncoder} implementations will short circuit if the password is not
     * in a valid format.
     */
    private volatile String userNotFoundEncodedPassword;

    private CustomUserDetailsService userDetailsService;

    private UserDetailsPasswordService userDetailsPasswordService;

    public CustomAuthenticationProvider() {
        setPasswordEncoder(PasswordEncoderFactories.createDelegatingPasswordEncoder());
    }

    // ~ Methods
    // ========================================================================================================

    @Override
    @SuppressWarnings("deprecation")
    protected void additionalAuthenticationChecks(UserDetails userDetails,
                                                  UsernamePasswordAuthenticationToken authentication)
            throws AuthenticationException {
        if (authentication.getCredentials() == null) {
            logger.debug("Authentication failed: no credentials provided");

            throw new BadCredentialsException(messages.getMessage(
                    "AbstractUserDetailsAuthenticationProvider.badCredentials",
                    "Bad credentials"));
        }

        String presentedPassword = authentication.getCredentials().toString();

        if (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) {
            logger.debug("Authentication failed: password does not match stored value");

            throw new BadCredentialsException(messages.getMessage(
                    "AbstractUserDetailsAuthenticationProvider.badCredentials",
                    "Bad credentials"));
        }
    }

    @Override
    protected void doAfterPropertiesSet() {
        Assert.notNull(this.userDetailsService, "A UserDetailsService must be set");
    }

    @Override
    protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {
        this.prepareTimingAttackProtection();
        // 自定义添加
        Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) authentication.getDetails();
        try {
            // 自定义添加
            String userType = map.get("userType");
            // 自定义添加userType参数
            UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username, userType);
            if (loadedUser == null) {
                throw new InternalAuthenticationServiceException("UserDetailsService returned null, which is an interface contract violation");
            } else {
                return loadedUser;
            }
        } catch (UsernameNotFoundException ex) {
            mitigateAgainstTimingAttack(authentication);
            throw ex;
        } catch (InternalAuthenticationServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new InternalAuthenticationServiceException(ex.getMessage(), ex);
        }
    }

    @Override
    protected Authentication createSuccessAuthentication(Object principal,
                                                         Authentication authentication, UserDetails user) {
        boolean upgradeEncoding = this.userDetailsPasswordService != null
                &amp;&amp; this.passwordEncoder.upgradeEncoding(user.getPassword());
        if (upgradeEncoding) {
            String presentedPassword = authentication.getCredentials().toString();
            String newPassword = this.passwordEncoder.encode(presentedPassword);
            user = this.userDetailsPasswordService.updatePassword(user, newPassword);
        }
        return super.createSuccessAuthentication(principal, authentication, user);
    }

    private void prepareTimingAttackProtection() {
        if (this.userNotFoundEncodedPassword == null) {
            this.userNotFoundEncodedPassword = this.passwordEncoder.encode(USER_NOT_FOUND_PASSWORD);
        }
    }

    private void mitigateAgainstTimingAttack(UsernamePasswordAuthenticationToken authentication) {
        if (authentication.getCredentials() != null) {
            String presentedPassword = authentication.getCredentials().toString();
            this.passwordEncoder.matches(presentedPassword, this.userNotFoundEncodedPassword);
        }
    }

    /**
     * Sets the PasswordEncoder instance to be used to encode and validate passwords. If
     * not set, the password will be compared using {@link PasswordEncoderFactories#createDelegatingPasswordEncoder()}
     *
     * @param passwordEncoder must be an instance of one of the {@code PasswordEncoder}
     *                        types.
     */
    public void setPasswordEncoder(PasswordEncoder passwordEncoder) {
        Assert.notNull(passwordEncoder, "passwordEncoder cannot be null");
        this.passwordEncoder = passwordEncoder;
        this.userNotFoundEncodedPassword = null;
    }

    protected PasswordEncoder getPasswordEncoder() {
        return passwordEncoder;
    }

    public void setUserDetailsService(CustomUserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    protected CustomUserDetailsService getUserDetailsService() {
        return userDetailsService;
    }

    public void setUserDetailsPasswordService(
            UserDetailsPasswordService userDetailsPasswordService) {
        this.userDetailsPasswordService = userDetailsPasswordService;
    }
}
</code></pre> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">package com.mugua.oauth.utils;

import com.alibaba.nacos.common.utils.Md5Utils;
import org.apache.shiro.crypto.hash.SimpleHash;

import java.nio.charset.StandardCharsets;
import java.util.Base64;

/**
 * @author liwenchao
 */
public class DecodeUtils {

    /**
     * 解密原业务线账户密码是否正确的方法
     */
    public static boolean matchesForUser(String paramPwd, String userPwd, String salt) {
        //拿到用户密码（明文）进行三次md5
        for (int i = 0; i &lt; 3; i++) {
            paramPwd = Md5Utils.getMD5(paramPwd.getBytes(StandardCharsets.UTF_8));
        }
        SimpleHash md5 = new SimpleHash("MD5", paramPwd, salt, 5);
        return md5.toString().equalsIgnoreCase(userPwd);
    }

    /**
     * 解密openid方式密码
     * @param paramPwd
     * @param userPwd
     * @return
     */
    public static boolean matchesForEquals(String paramPwd,String userPwd){
        return paramPwd.trim().equalsIgnoreCase(userPwd);
    }

    /**
     * 判断字符串是否为base64编码
     * Ascii码说明：共95个可读字符
     * 0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符）
     * 32～126(共95个)是字符(32是空格），其中48～57为0到9十个阿拉伯数字。
     * 65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等。
     */
    public static boolean checkBase64(String str) {
        //使用正则来判断是否符合base64编码的特征（但是无法排除类似于root这种特殊情况）
        String base64Pattern = "^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)$";
        boolean isLegal = str.matches(base64Pattern);
        if (isLegal) {
            //对于某些字符可能符合base64编码特征，但是却不是base64编码格式，进行进一步判断，如果解码后含有乱码（即Ascii码不在32~126）,
            //说明虽然符合base64编码特征，但是不是base64编码,如：root
            try {
                String decStr = new String(Base64.getDecoder().decode(str.getBytes()), StandardCharsets.UTF_8);
                char[] passArr = decStr.toCharArray();
                for (char c : passArr) {
                    if (charToByteAscii2(c) &lt; 32 || charToByteAscii2(c) &gt; 126) {
                        return false;
                    }
                }
            } catch (Exception e) {
                return false;
            }
        } else {
            return false;
        }
        return true;
    }

    private static byte charToByteAscii2(char ch) {
        return (byte) ch;
    }
}
</code></pre> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">package com.mugua.oauth.entity;


import com.fasterxml.jackson.annotation.JsonIgnore;

import java.io.Serializable;

/**
 * 普通返回
 *
 * @author lwc
 */
public class DmpResult&lt;T&gt; implements Serializable {

    private static final long serialVersionUID = 771836922595187944L;

    //返回数据

    protected T data;
    //返回错误码

    protected String code;
    //返回消息

    protected String msg;

    public DmpResult() {
    }

    public DmpResult(T t, String code, String msg) {
        this.data = t;
        this.code = code;
        this.msg = msg;
    }

    /**
     * 成功返回的默认方法
     */
    public static DmpResult success() {
        return new DmpResult(null, StatusCodeEnum.SUC.getCode(), "result_success");
    }

    public static DmpResult success(String msg) {
        return new DmpResult(null, StatusCodeEnum.SUC.getCode(), msg);
    }

    /**
     * 数据返回的默认方法
     */
    public static &lt;T&gt; DmpResult data(T t) {
        return new DmpResult(t, StatusCodeEnum.SUC.getCode(), "result_success");
    }

    public static &lt;T&gt; DmpResult data(T t, String msg) {
        return new DmpResult(t, StatusCodeEnum.SUC.getCode(), msg);
    }

    public static DmpResult data(String retCode, String msg) {
        return new DmpResult(null, retCode, msg);
    }

    /**
     * 错误的默认方法
     */
    public static DmpResult failed() {
        return new DmpResult(null, StatusCodeEnum.ERROR.getCode(), "result_fail");
    }

    public static DmpResult failed(String msg) {
        return new DmpResult(null, StatusCodeEnum.ERROR.getCode(), msg);
    }

    public static DmpResult failed(StatusCodeEnum statusCodeEnum) {
        return new DmpResult(null, statusCodeEnum.getCode(), "result_fail");
    }

    public static DmpResult failed(StatusCodeEnum statusCodeEnum, String msg) {
        return new DmpResult(null, statusCodeEnum.getCode(), msg);
    }

    public static DmpResult status(boolean status) {
        return status ? success() : failed();
    }

    @JsonIgnore
    public Boolean isSuccess() {
        return StatusCodeEnum.SUC.getCode().equals(this.code);
    }

    @JsonIgnore
    public Boolean isRetData() {
        return isSuccess() &amp;&amp; this.getData() != null;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }

    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }
}
</code></pre> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">package com.mugua.oauth.entity;

/**
 * 新增枚举字段需要按照范围来申请
 * &lt;p&gt;
 *
 * @author liwenchao
 */
public enum StatusCodeEnum {

    // 成功
    SUC("200", "result_success"),
    // 失败
    ERROR("500", "result_fail"),
    ;

    //值
    private String code;

    //描述
    private String desc;

    StatusCodeEnum(String code, String desc) {
        this.code = code;
        this.desc = desc;
    }

    public String getCode() {
        return code;
    }

    public String getDesc() {
        return desc;
    }

}
</code></pre> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">package com.mugua.oauth.config;

import com.mugua.oauth.encoder.CustomPasswordEncoder;
import com.mugua.oauth.provider.CustomAuthenticationProvider;
import com.mugua.oauth.service.impl.UsersServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.password.PasswordEncoder;


@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private UsersServiceImpl usersService;

    /**
     * 注册一个认证管理器对象给容器
     */
    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    /**
     * 密码编码对象（暂不对密码进行加密处理）,如果有加密就直接往容器里面扔，就不用这个了
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new CustomPasswordEncoder();
    }

    /**
     * 处理用户名和密码的验证事宜
     * 1.客户端传递username和password 参数到认证服务器
     * 2.username 和password 会存在数据库中
     * 3.根据用户表中的数据，验证当前传递过来的用户信息的合法性
     */
    @Override
    protected void configure(AuthenticationManagerBuilder authenticationManagerBuilder) throws Exception {
        //实例化一个用户对象（相当于数据表中的一条用户记录）
        authenticationManagerBuilder.authenticationProvider(customAuthenticationProvider());
    }

    /**
     * 用户信息提供者
     */
    @Bean(name = "customAuthenticationProvider")
    public AuthenticationProvider customAuthenticationProvider() {
        CustomAuthenticationProvider customAuthenticationProvider = new CustomAuthenticationProvider();
        //实例化一个用户对象（相当于数据表中的一条用户记录）
        customAuthenticationProvider.setUserDetailsService(usersService);
        customAuthenticationProvider.setHideUserNotFoundExceptions(false);
        customAuthenticationProvider.setPasswordEncoder(passwordEncoder());
        return customAuthenticationProvider;
    }

}
</code></pre> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">package com.mugua.oauth.config;

import org.springframework.beans.factory.ObjectProvider;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.HttpMessageConverter;

import java.util.stream.Collectors;

/**
 * @author liwenchao
 */
@Configuration
public class MessageConverterConfig {

    @Bean
    @ConditionalOnMissingBean
    public HttpMessageConverters messageConverters(ObjectProvider&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {
        return new HttpMessageConverters(converters.orderedStream().collect(Collectors.toList()));
    }

}
</code></pre> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">/*
 Navicat Premium Data Transfer

 Source Server         : nj-cdb-aaxjptkx.sql.tencentcdb.com
 Source Server Type    : MySQL
 Source Server Version : 50736
 Source Host           : nj-cdb-aaxjptkx.sql.tencentcdb.com:63901
 Source Schema         : oauth

 Target Server Type    : MySQL
 Target Server Version : 50736
 File Encoding         : 65001

 Date: 07/02/2023 22:26:59
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for oauth_client_details
-- ----------------------------
DROP TABLE IF EXISTS `oauth_client_details`;
CREATE TABLE `oauth_client_details` (
  `client_id` varchar(48) NOT NULL COMMENT '主键,必须唯一,不能为空.\n用于唯一标识每一个客户端(client); 在注册时必须填写(也可由服务端自动生成).\n对于不同的grant_type,该字段都是必须的. 在实际应用中的另一个名称叫appKey,与client_id是同一个概念.',
  `resource_ids` varchar(256) DEFAULT NULL COMMENT '客户端所能访问的资源id集合,多个资源时用逗号(,)分隔,如: "unity-resource,mobile-resource".\n该字段的值必须来源于与security.xml中标签‹oauth2:resource-server的属性resource-id值一致. 在security.xml配置有几个‹oauth2:resource-server标签, 则该字段可以使用几个该值.\n在实际应用中, 我们一般将资源进行分类,并分别配置对应的‹oauth2:resource-server,如订单资源配置一个‹oauth2:resource-server, 用户资源又配置一个‹oauth2:resource-server. 当注册客户端时,根据实际需要可选择资源id,也可根据不同的注册流程,赋予对应的资源id.',
  `client_secret` varchar(256) DEFAULT NULL COMMENT '用于指定客户端(client)的访问密匙; 在注册时必须填写(也可由服务端自动生成).\n对于不同的grant_type,该字段都是必须的. 在实际应用中的另一个名称叫appSecret,与client_secret是同一个概念.',
  `scope` varchar(256) DEFAULT NULL COMMENT '指定客户端申请的权限范围,可选值包括read,write,trust;若有多个权限范围用逗号(,)分隔,如: "read,write".\nscope的值与security.xml中配置的‹intercept-url的access属性有关系. 如‹intercept-url的配置为\n‹intercept-url pattern="/m/**" access="ROLE_MOBILE,SCOPE_READ"/&gt;\n则说明访问该URL时的客户端必须有read权限范围. write的配置值为SCOPE_WRITE, trust的配置值为SCOPE_TRUST.\n在实际应该中, 该值一般由服务端指定, 常用的值为read,write.',
  `authorized_grant_types` varchar(256) DEFAULT NULL COMMENT '指定客户端支持的grant_type,可选值包括authorization_code,password,refresh_token,implicit,client_credentials, 若支持多个grant_type用逗号(,)分隔,如: "authorization_code,password".\n在实际应用中,当注册时,该字段是一般由服务器端指定的,而不是由申请者去选择的,最常用的grant_type组合有: "authorization_code,refresh_token"(针对通过浏览器访问的客户端); "password,refresh_token"(针对移动设备的客户端).\nimplicit与client_credentials在实际中很少使用.',
  `web_server_redirect_uri` varchar(256) DEFAULT NULL COMMENT '客户端的重定向URI,可为空, 当grant_type为authorization_code或implicit时, 在Oauth的流程中会使用并检查与注册时填写的redirect_uri是否一致. 下面分别说明:\n当grant_type=authorization_code时, 第一步 从 spring-oauth-server获取 ''code''时客户端发起请求时必须有redirect_uri参数, 该参数的值必须与 web_server_redirect_uri的值一致. 第二步 用 ''code'' 换取 ''access_token'' 时客户也必须传递相同的redirect_uri.\n在实际应用中, web_server_redirect_uri在注册时是必须填写的, 一般用来处理服务器返回的code, 验证state是否合法与通过code去换取access_token值.\n在spring-oauth-client项目中, 可具体参考AuthorizationCodeController.java中的authorizationCodeCallback方法.\n当grant_type=implicit时通过redirect_uri的hash值来传递access_token值.如:\nhttp://localhost:7777/spring-oauth-client/implicit#access_token=dc891f4a-ac88-4ba6-8224-a2497e013865&amp;token_type=bearer&amp;expires_in=43199\n然后客户端通过JS等从hash值中取到access_token值.',
  `authorities` varchar(256) DEFAULT NULL COMMENT '指定客户端所拥有的Spring Security的权限值,可选, 若有多个权限值,用逗号(,)分隔, 如: "ROLE_UNITY,ROLE_USER".\n对于是否要设置该字段的值,要根据不同的grant_type来判断, 若客户端在Oauth流程中需要用户的用户名(username)与密码(password)的(authorization_code,password),\n则该字段可以不需要设置值,因为服务端将根据用户在服务端所拥有的权限来判断是否有权限访问对应的API.\n但如果客户端在Oauth流程中不需要用户信息的(implicit,client_credentials),\n则该字段必须要设置对应的权限值, 因为服务端将根据该字段值的权限来判断是否有权限访问对应的API.\n(请在spring-oauth-client项目中来测试不同grant_type时authorities的变化)',
  `access_token_validity` int(11) DEFAULT NULL COMMENT '设定客户端的access_token的有效时间值(单位:秒),可选, 若不设定值则使用默认的有效时间值(60 * 60 * 12, 12小时).\n在服务端获取的access_token JSON数据中的expires_in字段的值即为当前access_token的有效时间值.\n在项目中, 可具体参考DefaultTokenServices.java中属性accessTokenValiditySeconds.\n在实际应用中, 该值一般是由服务端处理的, 不需要客户端自定义.',
  `refresh_token_validity` int(11) DEFAULT NULL COMMENT '设定客户端的refresh_token的有效时间值(单位:秒),可选, 若不设定值则使用默认的有效时间值(60 * 60 * 24 * 30, 30天).\n若客户端的grant_type不包括refresh_token,则不用关心该字段 在项目中, 可具体参考DefaultTokenServices.java中属性refreshTokenValiditySeconds.\n\n在实际应用中, 该值一般是由服务端处理的, 不需要客户端自定义.',
  `additional_information` varchar(4096) DEFAULT NULL COMMENT '这是一个预留的字段,在Oauth的流程中没有实际的使用,可选,但若设置值,必须是JSON格式的数据,如:\n{"country":"CN","country_code":"086"}\n按照spring-security-oauth项目中对该字段的描述\nAdditional information for this client, not need by the vanilla OAuth protocol but might be useful, for example,for storing descriptive information.\n(详见ClientDetails.java的getAdditionalInformation()方法的注释)在实际应用中, 可以用该字段来存储关于客户端的一些其他信息,如客户端的国家,地区,注册时的IP地址等等.',
  `autoapprove` varchar(256) DEFAULT NULL COMMENT '设置用户是否自动Approval操作, 默认值为 ''false'', 可选值包括 ''true'',''false'', ''read'',''write''.\n该字段只适用于grant_type="authorization_code"的情况,当用户登录成功后,若该值为''true''或支持的scope值,则会跳过用户Approve的页面, 直接授权.\n该字段与 trusted 有类似的功能, 是 spring-security-oauth2 的 2.0 版本后添加的新属性.',
  PRIMARY KEY (`client_id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of oauth_client_details
-- ----------------------------
BEGIN;
INSERT INTO `oauth_client_details` VALUES ('mugua123', 'release,s-supply-chain-service,server-linux-service,s-supply-chain-crm,pay-gateway-service,consumption-report-statistics,marketing-activities', 'abcxyz', 'all', 'password,refresh_token', NULL, NULL, 6048000, 6048000, NULL, NULL);
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
</code></pre> 
 <h4 style="">2，资源服务器</h4> 
 <p style="">pom</p> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;
            &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.security.oauth.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-security-oauth2-autoconfigure&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security.oauth.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-oauth2-autoconfigure&lt;/artifactId&gt;
            &lt;version&gt;2.1.11.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--引入security对oauth2的支持--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;
            &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;</code></pre> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">package com.mugua.release.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.jwt.crypto.sign.MacSigner;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.token.RemoteTokenServices;
import org.springframework.security.oauth2.provider.token.TokenStore;
import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.store.JwtTokenStore;

/**
 * @Description
 * @Author lwc
 * @Data 2022/8/29 22:26
 */
@Configuration
@EnableResourceServer //开启资源服务器功能
@EnableWebSecurity  //开启web访问安全
public class ResourceServerConfiger extends ResourceServerConfigurerAdapter {

//    private String sign_key = "imugua20220829"; //jwt签名密钥
    private String sign_key = "ee7dcc6cad12f7d7ef9642e680fdbc4d"; //jwt签名密钥


    /**
     * @Description 该⽅法⽤于定义资源服务器向远程认证服务器发起请求，进⾏token校验
     * 等事宜
     * @Param resources
     * @Return
     * @Author lwc
     * @Date  22:29
     */
    @Override
    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {
        /*// 设置当前资源服务的资源id
        resources.resourceId("release");
        // 定义token服务对象（token校验就应该靠token服务对象）
        RemoteTokenServices remoteTokenServices = new RemoteTokenServices();
        // 校验端点/接⼝设置
        remoteTokenServices.setCheckTokenEndpointUrl("http://localhost:9999/oauth/check_token");
        // 携带客户端id和客户端安全码
        remoteTokenServices.setClientId("clientmugua");
        remoteTokenServices.setClientSecret("zbcxyz");

        resources.tokenServices(remoteTokenServices);*/

        //使用jwt令牌
        resources.resourceId("release").tokenStore(tokenStore()).stateless(true);//无状态设置
    }

    /**
     * @Description 场景：⼀个服务中可能有很多资源（API接⼝）
     *  * 某⼀些API接⼝，需要先认证，才能访问
     *  * 某⼀些API接⼝，压根就不需要认证，本来就是对外开放的接⼝
     *  * 我们就需要对不同特点的接⼝区分对待（在当前configure⽅法中
     * 完成），设置是否需要经过认证
     * @Param http
     * @Return 
     * @Author lwc
     * @Date  22:59
     */
    @Override
    public void configure(HttpSecurity http) throws Exception{
        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED).and().authorizeRequests()
                .antMatchers("/release/**").authenticated() //需要认证
                .antMatchers("/demo/**").authenticated() //需要认证
                .anyRequest().permitAll(); //其余不需要认证
    }

   /**
    * @Description 该⽅法⽤于创建tokenStore对象（令牌存储对象）
    *  token以什么形式存储
    * @Param
    * @Return {@link TokenStore}
    * @Author lwc
    * @Date  23:14
    */
    public TokenStore tokenStore(){
        //return new InMemoryTokenStore();
        // 使⽤jwt令牌
        return new JwtTokenStore(jwtAccessTokenConverter());
    }


  /**
   * @Description  * 返回jwt令牌转换器（帮助我们⽣成jwt令牌的）
   *      * 在这⾥，我们可以把签名密钥传递进去给转换器对象
   * @Param
   * @Return {@link JwtAccessTokenConverter}
   * @Author lwc
   * @Date  23:14
   */
    public JwtAccessTokenConverter jwtAccessTokenConverter() {
        JwtAccessTokenConverter jwtAccessTokenConverter = new JwtAccessTokenConverter();
        jwtAccessTokenConverter.setSigningKey(sign_key); // 签名密钥
        jwtAccessTokenConverter.setVerifier(new MacSigner(sign_key)); // 验证时使⽤的密钥，
                                            // 和签名密钥保持⼀致3.3.5 从数据库加载Oauth2客户端信息
                                             // 创建数据表并初始化数据（表名及字段保持固定）
        return jwtAccessTokenConverter;
    }
}
</code></pre> 
 <pre class="kdocs-plaintext"><code class="language-plaintext">获取token AND 刷新token
http://地址:端口/oauth/token?
client_secret=abcxyz&amp;grant_type=password&amp;username=muguauser&amp;password=iuxyzds&amp;client_id=mugua123

获取token携带的参数
client_id：客户端id
password：密码客户单密码
grant_type：指定使⽤哪种颁发类型，password
username：⽤户名
password：密码
</code></pre> 
 <h4 style="">三<span class="kdocs-bold" style="font-weight:bold;">、验证</span></h4> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1018px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:58.939095%;height:0;"> 
    <img src="https://images2.imgbox.com/c9/84/oHaZ1aTw_o.png" style="margin-left:;display:block;width:1018px;margin-top:-58.939095%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">刷新token</span></span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:871px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:68.88634%;height:0;"> 
    <img src="https://images2.imgbox.com/cb/52/qXQ4aZQb_o.png" style="margin-left:;display:block;width:871px;margin-top:-68.88634%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">这里是没有指定用户名和密码的，并把grant_type改为了refresh_token</span></span></p> 
 <p style=""><span class="kdocs-fontSize" style="font-size:15pt;"><span class="kdocs-bold" style="font-weight:bold;">验证token</span></span></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:961px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:62.434963%;height:0;"> 
    <img src="https://images2.imgbox.com/74/8a/3BqYCvNO_o.png" style="margin-left:;display:block;width:961px;margin-top:-62.434963%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f665b710c61b89dd69446dd5524c98bf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">cmd有效，vscode无效——node : 无法将“node”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。 请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d4bee6f7f8bd0cceb515871cd9b0645c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小知识点：Airflow 安装部署</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>