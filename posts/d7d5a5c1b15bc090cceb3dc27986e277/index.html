<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>对称加密和非对称加密、公钥和私钥、单向认证和双向认证、数字签名、数字证书、根证书 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="对称加密和非对称加密、公钥和私钥、单向认证和双向认证、数字签名、数字证书、根证书" />
<meta property="og:description" content="文章目录 1. 什么是公钥和私钥？2. 加密算法2.1 对称加密2.2 非对称加密2.2.1 非对称加密的重要性质2.2.2 非对称加密算法应用2.2.2.1 应用1 加密通信2.2.2.1.1 单向认证和双向认证 2.2.2.1 应用2 数字签名 3. 数字签名3.1 数字签名用法演示3.1.1 最简单用法(校验数据的完整性)2.1.2 复杂用法(校验数据的完整性) 3.2 数字签名存在问题 4. 数字证书(Digital Certificate)4.1 创建数字证书4.1.1 举例，CA如何给我们签发一个有效证书和服务器如何发送证书： 4.2 数字证书究竟解决了什么问题4.2.1 如何攻击数字证书呢 参考： 1. 什么是公钥和私钥？ 摘自《什么是公钥和私钥？》
公钥（Public Key）与私钥（Private Key）是通过加密算法得到的一个密钥对（即一个公钥和一个私钥，也就是非对称加密方式）。
公钥可对会话进行加密、验证数字签名，只有使用对应的私钥才能解密会话数据，从而保证数据传输的安全性。公钥是密钥对外公开的部分，私钥则是非公开的部分，由用户(一般是服务端)自行保管。
公钥和私钥起初均存储在服务器端。 私钥是非公开的，因此仅存放在服务端，而且要避免被窃取，比如存在某网站A的服务器端；公钥是大家都可以获取的，一般是用在客户端，客户端的公钥是从哪来的呢？需要从服务器端获得，比如浏览器就是 一个客户端，当访问网站的时候，需要通过握手协议从网站侧获取
通过加密算法得到的密钥对可以保证在世界范围内是唯一的。使用密钥对的时候，如果用其中一个密钥加密一段数据，只能使用密钥对中的另一个密钥才能解密数据。例如：用公钥加密的数据必须用对应的私钥才能解密；如果用私钥进行加密也必须使用对应的公钥才能解密，否则将无法成功解密。
2. 加密算法 摘自：《什么是非对称加密？》
密码学中有两种技术：一种叫对称加密，另外一种叫非对称加密。
这次咱们主要聊聊非对称加密，因为公钥和私钥就是非对称加密的成果，但是为了更好的理解非对称加密，我们也会简单介绍对称加密
2.1 对称加密 采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。
在对称加密算法中常用的算法有：DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK等。
基本逻辑是这样。如果 Alice 想把一个信息传递给 Bob 。比如信息是一个数字 m ，Alice 不能把这个数字直接传递给 Bob ，因为互联网是一个不安全的环境，很容易被窃听。所以她可以通过一个加密算法，比如，通过给 m 加上一个数字 e ，得到一个数字 c ，这个 c 就叫做密文。这样 Bob 拿到密文 c ，再减去 e 就可以得到信息 m 了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/d7d5a5c1b15bc090cceb3dc27986e277/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-08T14:33:34+08:00" />
<meta property="article:modified_time" content="2023-02-08T14:33:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">对称加密和非对称加密、公钥和私钥、单向认证和双向认证、数字签名、数字证书、根证书</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1__1" rel="nofollow">1. 什么是公钥和私钥？</a></li><li><a href="#2__12" rel="nofollow">2. 加密算法</a></li><li><ul><li><a href="#21__18" rel="nofollow">2.1 对称加密</a></li><li><a href="#22__36" rel="nofollow">2.2 非对称加密</a></li><li><ul><li><a href="#221__41" rel="nofollow">2.2.1 非对称加密的重要性质</a></li><li><a href="#222__56" rel="nofollow">2.2.2 非对称加密算法应用</a></li><li><ul><li><a href="#2221_1__57" rel="nofollow">2.2.2.1 应用1 加密通信</a></li><li><ul><li><a href="#22211__72" rel="nofollow">2.2.2.1.1 单向认证和双向认证</a></li></ul> 
     </li><li><a href="#2221_2__83" rel="nofollow">2.2.2.1 应用2 数字签名</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#3__88" rel="nofollow">3. 数字签名</a></li><li><ul><li><a href="#31__125" rel="nofollow">3.1 数字签名用法演示</a></li><li><ul><li><a href="#311__133" rel="nofollow">3.1.1 最简单用法(校验数据的完整性)</a></li><li><a href="#212__139" rel="nofollow">2.1.2 复杂用法(校验数据的完整性)</a></li></ul> 
   </li><li><a href="#32__163" rel="nofollow">3.2 数字签名存在问题</a></li></ul> 
  </li><li><a href="#4_Digital_Certificate_186" rel="nofollow">4. 数字证书(Digital Certificate)</a></li><li><ul><li><a href="#41__193" rel="nofollow">4.1 创建数字证书</a></li><li><ul><li><a href="#411_CA_249" rel="nofollow">4.1.1 举例，CA如何给我们签发一个有效证书和服务器如何发送证书：</a></li></ul> 
   </li><li><a href="#42__315" rel="nofollow">4.2 数字证书究竟解决了什么问题</a></li><li><ul><li><a href="#421__346" rel="nofollow">4.2.1 如何攻击数字证书呢</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_361" rel="nofollow">参考：</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1__1"></a>1. 什么是公钥和私钥？</h2> 
<p>摘自<a href="https://help.aliyun.com/knowledge_detail/42216.html" rel="nofollow">《什么是公钥和私钥？》</a></p> 
<p>公钥（Public Key）与私钥（Private Key）是通过加密算法得到的一个<code>密钥对</code>（即一个公钥和一个私钥，也就是<code>非对称加密方式</code>）。</p> 
<p>公钥可对会话进行加密、验证数字签名，只有使用对应的私钥才能解密会话数据，从而保证数据传输的安全性。公钥是密钥对外公开的部分，私钥则是非公开的部分，由用户(一般是服务端)自行保管。</p> 
<blockquote> 
 <p>公钥和私钥起初均存储在服务器端。 私钥是非公开的，因此仅存放在服务端，而且要避免被窃取，比如存在某网站A的服务器端；公钥是大家都可以获取的，一般是用在客户端，客户端的公钥是从哪来的呢？需要从服务器端获得，比如浏览器就是 一个客户端，当访问网站的时候，需要通过握手协议从网站侧获取</p> 
</blockquote> 
<p>通过加密算法得到的密钥对可以保证在世界范围内是唯一的。使用密钥对的时候，如果用其中一个密钥加密一段数据，只能使用密钥对中的另一个密钥才能解密数据。例如：用公钥加密的数据必须用对应的私钥才能解密；如果用私钥进行加密也必须使用对应的公钥才能解密，否则将无法成功解密。</p> 
<h2><a id="2__12"></a>2. 加密算法</h2> 
<p>摘自：<a href="https://zhuanlan.zhihu.com/p/53159565" rel="nofollow">《什么是非对称加密？》</a></p> 
<p><font color="blue">密码学中有两种技术：一种叫对称加密，另外一种叫非对称加密。</font></p> 
<p>这次咱们主要聊聊非对称加密，因为公钥和私钥就是非对称加密的成果，但是为了更好的理解非对称加密，我们也会简单介绍对称加密</p> 
<h3><a id="21__18"></a>2.1 对称加密</h3> 
<p>采用<code>单钥</code>密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。</p> 
<p>在对称加密算法中常用的算法有：DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK等。</p> 
<p>基本逻辑是这样。如果 Alice 想把一个信息传递给 Bob 。比如信息是一个数字 m ，Alice 不能把这个数字直接传递给 Bob ，因为互联网是一个不安全的环境，很容易被窃听。所以她可以通过一个加密算法，比如，通过给 m 加上一个数字 e ，得到一个数字 c ，这个 c 就叫做密文。这样 Bob 拿到密文 c ，再减去 e 就可以得到信息 m 了。</p> 
<p><img src="https://images2.imgbox.com/24/fa/SjgFyZJA_o.png" alt="在这里插入图片描述"><br> 因此，e就是对称加密算法中的密钥，并且<code>只存在私钥，没有公钥概念</code>。发送消息和接收消息二者持有的密钥是相同的。<font color="blue">简单来说，对称加密就是加密与解密的步骤或方法完全对称，只需把步骤逆过来就行，与非对称加密相比，这里加密和解密步骤是简单的逆过来，因此只使用一种是密钥就可以实现。</font></p> 
<p>比如，想要传递的 m 等于2，e 等于1，那么2+1得到密文就是3，3传递给 Bob 之后，Bob 用3-1得到信息 m 了。这个过程中，密文是可以放心的在互联网上传播的，被窃听了也没人能看懂。e 就是密钥，密钥如果一旦泄露了，通信过程就不安全了。当然实际中加密算法以及密钥都必须很复杂，不是简单的加一个数字，因为现在人们的解密手段其实也已经非常高超了。</p> 
<p><font color="blue">对称加密的优势是可以加密大段信息，这个是非对称加密做不到的，但是对称加密的问题在于如何能够安全的把密钥传递给对方。</font>因为如果 Alice 不能安全的把密钥传递给 Bob ，那么加密通信就实现不了。而如果不能实现加密通信，那又怎么可能安全的传递密钥呢，所以对称加密在互联网上使用，就有了这个鸡生蛋蛋生鸡的问题。非对称加密被发明出来，就是为了解决对称加密的这个最为致命的痛点。</p> 
<p>举例说明对称加密密钥传输的问题:<br> 由于单钥加密，同一个密钥既能加密，也能解密，那么必须谨慎的传播密钥，如果Alice 想把一个信息传递给 Bob ，用到了对称加密，那么密钥必须做到除了Alice和Bob之外，不能有第三个人知道。问题是如果Alice把密钥(其实就是一个字符串)拷贝到U盘，亲手把U盘拿给Bob，Bob再拷贝进电脑，这样是很安全的或者打电话也行，但是有没有考虑到网站对N个访问端，难道网站的开发者一个个的送U盘吗？显然不可取。但是如果直接通过网络发送密钥，很容易被窃取。</p> 
<h3><a id="22__36"></a>2.2 非对称加密</h3> 
<p>非对称加密也称公钥加密算法！</p> 
<p><font color="blue">非对称加密之所以不对称，指的就是加密用一个密钥，而解密的时候用的是另外一个密钥。因此，我们称之为公钥和私钥，顾名思义，公钥可以任意对外发布；而私钥必须由用户自行严格秘密保管，绝不透过任何途径向任何人提供，也不会透露给要通信的另一方，即使他被信任。</font></p> 
<h4><a id="221__41"></a>2.2.1 非对称加密的重要性质</h4> 
<p>1.加密的双向性。</p> 
<p><code>加密具有双向性</code>，即公钥和私钥中的任一个均可用作加密，此时另一个则用作解密。<br> <img src="https://images2.imgbox.com/02/3f/QdB5DMzX_o.png" alt="在这里插入图片描述"><br> <font color="blue">公钥加密，私钥解密；<br> <font color="blue">私钥加密，公钥解密；<br> <font color="blue">公钥加密，公钥无法解密！</font></font></font></p> 
<p>2.公钥无法推导出私钥</p> 
<p>必须确保<code>使用公钥无法推导出私钥</code>，至少妄想使用公钥推导私钥必须在计算上是不可行的，否则安全性将不复存在。</p> 
<p>虽然两个密钥在数学上相关，但如果知道了公钥，并不能凭此计算出私钥；因此公钥可以公开，任意向外发布；而私钥不公开，绝不透过任何途径向任何人提供。</p> 
<h4><a id="222__56"></a>2.2.2 非对称加密算法应用</h4> 
<h5><a id="2221_1__57"></a>2.2.2.1 应用1 加密通信</h5> 
<p>这个过程是这样的。<code>Bob 作为接收信息的一方</code>，首先要生成<code>一对密钥</code>，一个叫做公钥，意思就是可以公开出去的密钥。另外一个叫做私钥，也就是要私密保存的。</p> 
<blockquote> 
 <p><font color="blue">注意：这个场景特指bob作为接收方，不是发送方！确切来说，这个是<code>单向认证</code>的例子。在单向认证的场景下，如果bob作为发送方的话，只能用私钥加密(这样公钥可以解密)，这样接收方张三李四都持有公钥的话，可以互相窃取消息进行解密，这样是不安全的，本来发给张三的消息，李四可以窃取。如果要解密此问题，就要用到双向认证！</font></p> 
</blockquote> 
<p>注意这一对儿密钥是有天然的数学联系的，不然也不可能用公钥加密后能用私钥解密。具体这个联系是什么，可以参考 RSA 算法 ，我们这里就不展开了。接下来，Bob 把自己的公钥传递给 Alice ，Alice 用 Bob 的公钥去加密信息 m 得到密文 c 。Bob 拿到密文 c 之后，用私钥解c得到m，注意这里就体现出来不对称了，因为 Bob 解密用的不是公钥，而是自己的私钥。</p> 
<p><img src="https://images2.imgbox.com/89/02/N1aSrvL5_o.png" alt="在这里插入图片描述"></p> 
<p>咱们思考一下这个过程里面的安全性。暴露在互联网上的首先是公钥，然后是密文，非对称加密的算法本身是公开的。但是即使公钥和密文算法都被攻击者拿到，他也不能解密拿到信息的（因为只能用私钥解，私钥仅被Bob 持有）。所以整个过程是安全的。</p> 
<p><font color="blue">甲方只能用其私钥解密由其公钥加密后的任何信息。 非对称加密算法的保密性比较好，它消除了最终用户<code>交换密钥</code>的需要。</font></p> 
<h6><a id="22211__72"></a>2.2.2.1.1 单向认证和双向认证</h6> 
<p>前文2.2.2.1 应用1 加密通信提到单向认证和双向认证概念，我们来分析下：</p> 
<p>这个场景特指bob作为接收方，不是发送方！确切来说，这个是<code>单向认证</code>的例子。在单向认证的场景下，bob制作私钥和公钥，发布公钥，作为消息接收方，是安全的；</p> 
<p>如果bob作为发送方的话，只能用私钥加密(为了保证接收方可以用公钥进行解密)，这样接收方张三李四都持有公钥的话，可以互相窃取消息进行解密，这样是不安全的，本来发给张三的消息，李四可以窃取。</p> 
<p><strong>如果要解决此问题，就要用到双向认证！</strong></p> 
<p>此时张三也制作私钥和公钥，持有私钥，并把公钥发布给bob，如果bob想发消息给张三，就用张三提供的公钥加密，张三收到消息后，用张三的私钥进行解码，这样，李四即使获得bob的公钥、张三的公钥、bob发给张三的消息，也无法解密！</p> 
<h5><a id="2221_2__83"></a>2.2.2.1 应用2 数字签名</h5> 
<p>非对称加密的另一个重要应用：数字签名</p> 
<p>我们会在数字签名章节单独讲述</p> 
<h2><a id="3__88"></a>3. 数字签名</h2> 
<p>数字签名（又称公钥数字签名）是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。</p> 
<p>它是一种<code>类似写在纸上的普通的物理签名</code>，但是使用了<code>公钥加密</code>领域的技术来实现的，用于鉴别数字信息的方法。</p> 
<p>一套数字签名通常定义两种互补的运算，一个用于签名，另一个用于验证。数字签名是非对称密钥加密技术与数字摘要技术的应用。</p> 
<p>是不是有点模糊，没关系，举了例子就立马清晰了。</p> 
<p>在&lt;2.2.2.1 应用1 加密通信&gt;章节讲诉的例子，Alice 发送消息给bob，那么如果张三也发消息给bob的话，那么，bob如何区分消息的发送者是Alice 还是张三呢？简单，加个数字签名就行了！</p> 
<p>数字签名就像我们写在信上的签名，是消息内容主体之外的另一个信息。</p> 
<p><strong>由定义可知数字签名的作用包含2种：</strong></p> 
<p>a）验证数据来源。</p> 
<p>b）验证数据完整性。</p> 
<p><strong>报文摘要:</strong><br> 数字签名会用到报文摘要技术，我们先来介绍下报文摘要。</p> 
<p><font color="blue">报文摘要：将报文按双方约定的HASH算法计算得到一个固定位数的报文摘要。在数学上保证只要改动报文中任何一位，重新计算出的报文摘要值就会与原先的值不相符。这样就保证了报文的不可更改性。</font></p> 
<p>假如将一段报文“abcd”进行摘要计算，其hash值为"efgh"，反复计算多次，其结果必然一致。一旦改动后，其值必不一致，如果将第一个字母a篡改为’y’，那么其结果必然不等于"efgh"，因此，利用这种特性，可以用来验证内容是否被篡改。</p> 
<p><font color="orange">将该<code>报文摘要值</code>用<code>发送者的私钥加密</code>就得到报文的数字签名。</font></p> 
<p>总结来说：<br> F(M) = D E(D)=S<br> F是单向散列函数:即如果已知x，很容易计算F(x)，但已知F(x)，却很难算出x</p> 
<p>数字签名就是用私钥将摘要加密的结果，这样能够保证数据的完整性、放篡改、以及不可抵赖性。</p> 
<p><img src="https://images2.imgbox.com/1d/dc/jHw2IC9J_o.png" alt="在这里插入图片描述"><br> 由上图，基于明文，采用单向哈希算法，可以得到摘要H，用发送方(甲方)的私钥进行加密后，得到一个数字签名。将来用甲方的公钥解开数字签名，就能得到H</p> 
<h3><a id="31__125"></a>3.1 数字签名用法演示</h3> 
<p>数字签名的作用包含2种：</p> 
<p>a）验证数据来源。</p> 
<p>b）验证数据完整性。</p> 
<p>我们仅展示验证数据完整性。</p> 
<h4><a id="311__133"></a>3.1.1 最简单用法(校验数据的完整性)</h4> 
<p>乙方把接收到的发送方的明文用单向哈希函数取得摘要值后，与甲方的公钥解密甲方的数字签名而得到的摘要值进行比较，如果一样说明信息完整，未受篡改，如果不一样说明受到篡改。</p> 
<p>这里假设明文不经处理，和签名直接发送给乙方，并且乙方持有甲方的公钥。<br> <img src="https://images2.imgbox.com/7c/87/FdQvoXBB_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="212__139"></a>2.1.2 复杂用法(校验数据的完整性)</h4> 
<p>与前面的相比，这里的复杂之处在于明文也会被加密，多了一个步骤，需要用私钥先把密文解析为明文，其余步骤相同<br> <img src="https://images2.imgbox.com/68/b2/PErguYRs_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>应用数字签名时，需要发送者，例如Alice ，也需要生成一对密钥，一个公钥，一个私钥。公钥发布给bob，私钥要私藏。</p> 
</blockquote> 
<p>简单解释，把A对应Alice ，B对应bob：</p> 
<p>A：将明文Text进行摘要运算后得到<code>摘要</code>（消息完整性）H，再将摘要H用A的私钥加密（身份认证），得到<code>数字签名</code>S，将<code>密文</code>M（用B的公钥对明文加密）和<code>数字签名</code>S一块发给B。</p> 
<blockquote> 
 <p>注意：1.数字签名是用Alice 的私钥，因此任何人都能获取Alice 的公钥，把数字签名S解密<br> 2.密文是用bob的公钥，M无法被第三方破解，因此只有bob有私钥才能解，也就是说密文可以替换成乱七八糟的，但是无法篡改，因为没有办法获取原文，怎么改其中的一个字符？<br> 3.数字签名包含摘要运算，这个摘要的值是为了验证密文是否被替换的，原理是即如果已知x，很容易计算F(x)，多次计算结果不变。如果密文被改了，那么2次结算结果就不同。</p> 
</blockquote> 
<p>B：</p> 
<ol><li> <p>收到A的消息后，先将密文 M’（密文可能被篡改，因此多个一个单引号，因为使用的公钥加密的，因此，张三也可以获得公钥，可以伪造一段自己产生的明文，也用公钥加密后，替换原有消息中的密文） 用<code>自己的私钥解密</code>，得到<code>明文</code> Text’。</p> </li><li> <p>将<code>数字签名</code>用<code>A的公钥</code>进行解密后，得到原有的摘要H（签名是A的私钥，无法被修改，因此解密成功则说明A的身份被认证了，并且其内容就是之前的那个摘要H）。</p> </li><li> <p>    对明文Text’再次进行摘要运算，得到实际收到的摘要H’，<code>将两份摘要进行对比</code>，如果H=H’，则说明Text=Text’，消息没有被篡改（消息完整性），反之，说明消息内容被改过了。</p> </li></ol> 
<p>一举两得，既能验证身份，又能验证消息的完整性。</p> 
<h3><a id="32__163"></a>3.2 数字签名存在问题</h3> 
<p>数字签名存在问题：<code>中间人攻击</code></p> 
<blockquote> 
 <p><code>中间人攻击</code>(Man-in-the-MiddleAttack，简称“MITM攻击”)是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方 直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻 击中，攻击者可以拦截通讯双方的通话并插入新的内容。中间人攻击是一个(缺乏)相互认证的攻击。大多数的加密协议都专门加入了一些特殊的认证方法以阻止中间人攻击。例如，SSL协议可以验证参与通讯的一方或双方使用的证书是否是由权威的受信 任的数字证书认证机构颁发，并且能执行双向身份认证。</p> 
</blockquote> 
<p>把A对应Alice ，B对应bob，A要发信息给B：</p> 
<p>B如何安全的把自己的公钥发布给A，如果C截获B与A之间通信，把B的公钥换成C的公钥发给A，然后C冒充B与A进行通信，这个时候A是不知道他收到的数据是来自C的，可以实现中间人攻击。</p> 
<p>A收到C发送的消息不可怕，可怕的是A外发消息时，会用C的公钥加密，B在和坏人通信，B输入的密码等信息都被坏人用私钥解密而截获了。</p> 
<p>那么这里就要保证、不要使用坏人的公钥加密，那么<code>怎么知道将要访问的网站的真正公钥，而不是被坏人替换了假的公钥呢？</code>为了解决这个问题就出现了证书。</p> 
<p><font color="orange">注意：中间人攻击的特点是截获并替换，可以理解是在网络的中间替换，并不能替换已经下载至本地的正确的公钥，后者属于物理替换，比如中病毒了或机器被远程控制了才可以。为什么这么说，是因为《数字签名是什么？》作者阮一峰 (当然好多别的网站也有，毕竟都是翻译国外的)里面提到：</font></p> 
<pre><code class="prism language-bash">复杂的情况出现了。道格想欺骗苏珊，他<span class="token string">'偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。'</span>
此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，
用自己的私钥做成<span class="token string">"数字签名"</span>，写信给苏珊，让苏珊用假的鲍勃公钥进行解密
</code></pre> 
<p><font color="orange">这里面提到偷走电脑是非常不恰当的，也是导致难以理解数字证书的根本原因！因为既然能偷走电脑了，为何不能替换根证书？这样后续就可以替换网络中的数字证书，进而替换公钥了！</font></p> 
<h2><a id="4_Digital_Certificate_186"></a>4. 数字证书(Digital Certificate)</h2> 
<p>数字证书简称CA，它由权威机构给某网站颁发的一种认可凭证。<code>颁发证书机构它也有一对公钥和私钥</code>。</p> 
<p><font color="blue">证书机构用<code>它的私钥</code>将 <code>A的公钥</code> 和 一些A的信息 加密得到<code>数字证书</code>。然后A发送数据给B时，包含了三个部分：<code>原文+数字签名+数字证书</code></font></p> 
<p>如果数字证书是ok的，那么其内部存储的A的公钥就是ok的。</p> 
<h3><a id="41__193"></a>4.1 创建数字证书</h3> 
<p>企业申请的证书制作流程如下：<br> <img src="https://images2.imgbox.com/e9/15/ArmmmHHj_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>数字证书=证书内容(注意是明文)+数字签名</p> 
</blockquote> 
<p>如何验证内容是明文的？你可以尝试导出一个二进制的证书，用16进制查看，发限标记的地方是英文，是签发机构，说明是明文，否则应该看不到的：<br> <img src="https://images2.imgbox.com/1c/78/iW4BXyfl_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>Globalsign Root CA是Globalsign的根证书,GlobalSign的根证书是PKI生态系统中最古老,最受信任的根证书<br> <font color="green">注意：权威的证书机构，会先创建一个根证书，并发布出去，被集成进操作系统内。这个根证书的制作过程，和企业制作过程类似，只不过证书机构持有的私钥泄露了</font></p> 
</blockquote> 
<p><font color="blue">数字证书的结构分为内容(类似报文)+对内容产生的签名。</font>签名的作用是为了将来验证数字证书的。<br> 完整流程如下：<br> <img src="https://images2.imgbox.com/59/e0/XQI25Pp2_o.png" alt="在这里插入图片描述"></p> 
<p><strong>步骤1 ：</strong> 有一个权威的<code>证书签发机构</code>，称为<code>CA</code>——全球就那么几个公司比较权威啦，这个机构，先用RSA产生一对公私钥。</p> 
<p>私钥自己留着藏起来，你要是能偷到手就厉害了。利用这个私钥，创建一个根证书</p> 
<p><strong>步骤2：</strong> 先生成一个文件，文件内容大概是这样的：</p> 
<ul><li>公钥内容 ，对应下图的主体公钥信息</li><li>签发者ID—-谁签发的证书</li><li>Subject—-也就是这个证书签发给谁。</li><li>有效期</li><li>其他信息</li></ul> 
<p>以上内容都是明文。我们称为<code>内容P</code>，具体内容如下：<br> <img src="https://images2.imgbox.com/38/2c/h9R4Dgmz_o.png" alt="在这里插入图片描述"></p> 
<ul><li> <p>版本号<code>version</code>为证书的版本标识，目前最新版本为v3，若使用扩展项时，version=v3。</p> </li><li> <p>序列号<code>serialNumber</code>为证书的唯一标识，每张证书的序列号不同。</p> </li><li> <p>签名算法<code>signatureAlgorithm</code>和证书域中的签名算法相同。</p> <p>就是指的这个数字证书的数字签名所使用的加密算法，这样就可以使用证书发布机构的证书里面的公钥(<code>公钥可以支持多种算法，因此需要告知使用具体哪一种</code>)，根据这个算法对指纹进行解密。指纹的加密结果就是数字签名。</p> </li><li> <p>证书的签发者<code>issuer</code>是证书的颁发机构，是证书持有者的信任方。</p> </li><li> <p>主体<code>subject</code>也是证书持有者，是证书的所属实体。</p> </li><li> <p>有效期<code>validity</code>包含证书的生效日期和失效日期。</p> </li><li> <p>主体公钥信息<code>subjectPublicKeyInfo</code>表示证书持有者的公钥信息。</p> 
  <blockquote> 
   <p><code>假设我们自己的公司叫"ABC Company"，我们想申请证书，那么我们自己就要通过rsa算法生成公司的一对公钥和密钥，并且把公钥发送给机构，私钥自己保管</code></p> 
  </blockquote> </li><li> <p>主体唯一标识符<code>subjectUniqueID</code> 证书签发的唯一标识</p> </li><li> <p>签发者唯一标识符<code>issuerUniqueID</code>表示证书持有者的唯一标识。</p> </li><li> <p>扩展项<code>extensions</code>标识证书的扩展信息，可同时扩展多个信息。</p> </li></ul> 
<p><strong>步骤3：</strong> 然后使用hash算法，对内容P进行hash计算，得到一个<code>摘要</code>H</p> 
<p><strong>步骤4：</strong> 然后使用签发机构的私钥对H进行RSA加密，得到签名信息S。这个步骤称为签名，就是用私钥对某公开内容的hash值进行加密。</p> 
<p><strong>步骤5：</strong> 然后将内容P，S连成一个文件，这个文件就是所谓的数字证书了。所以数字证书里，包括证书持有者的身份信息，证书信息，证书持有人的公钥，以及机构的签名信息。</p> 
<p><font color="green">此时，企业证书都创建好了，那么怎么工作的呢？参见下面的示例</font></p> 
<h4><a id="411_CA_249"></a>4.1.1 举例，CA如何给我们签发一个有效证书和服务器如何发送证书：</h4> 
<p>举个例子方便大家理解，假设我们公司"ABC Company"花了1000块钱，向一个证书发布机"SecureTrust CA"为我们自己的公司"ABC Company"申请了一张证书。</p> 
<p>注意，这个证书发布机"SecureTrust CA"是一个大家公认并被一些权威机构接受的证书发布机构，我们的操作系统里面已经安装了"SecureTrust CA"的证书。</p> 
<p>"SecureTrust CA"在给我们发布证书时，把Issuer,Public key,Subject,Valid from,Valid to等信息以明文的形式写到证书里面，然后用一个指纹算法计算出这些数字证书内容的一个指纹(这里是指证书上的<code>数字签名</code>)，并把指纹和指纹算法用自己的私钥进行加密，然后和证书的内容一起发布，同时"SecureTrust CA"还会给一个我们公司"ABC Company"的私钥给到我们(当然建议我们自己公司创建私钥，把公钥提供给CA机构比较安全)。</p> 
<blockquote> 
 <p>例子中是公司自己的公钥私钥都有ca代办，当然建议我们自己公司创建私钥，把公钥提供给CA机构比较安全，因为CA发送私钥的万一出错呢？或者泄露呢？</p> 
</blockquote> 
<p>我们花了1000块钱买的这个证书的内容如下：</p> 
<pre><code class="prism language-bash">×××××××××××××××证书内容开始×××××××××××××××××

Issuer <span class="token builtin class-name">:</span> SecureTrust CA

Subject <span class="token builtin class-name">:</span> ABC Company

Valid from ： 某个日期

Valid to： 某个日期

Public Key <span class="token builtin class-name">:</span> 一串很长的数字

…… 其它的一些证书内容……


数字签名
</code></pre> 
<p>所以最后在我们使用https的时候究竟发生了什么：<br> <img src="https://images2.imgbox.com/64/e5/TbU09HLa_o.png" alt="在这里插入图片描述"></p> 
<ol><li> <p>客户端向一个需要https访问的网站发起请求。</p> </li><li><li> <p>服务器将证书发送给客户端，证书里面包含了服务器的公钥</p> </li><li> <p>客户端对证书进行校验<br> 这里要特别说一下客户端到底 如何来校验对方发过来的数字证书是否有效：</p> 
  <ul><li>首先在本地电脑寻找是否有这个服务器证书上的ca机构的<code>根证书</code>。如果有继续下一步，如果没有弹出警告。</li><li>使用ca机构根证书的公钥对服务器证书的数字签名进行解密，得到md1。</li><li>证书的内容是明文的，能得到签名算法<code>signatureAlgorithm</code>，利用公钥和相应的算法对明文再次计算摘要，得到md2。</li><li>将md1和md2对比看是否一样，如果一样则通过认证。</li></ul> </li><li> <p>校验成功之后，客户端会生成一个<code>随机串</code>然后使用服务器证书的公钥进行加密之后发送给服务器。</p> </li><li> <p>服务器通过使用自己的私钥解密得到这个随机值。</p> </li><li> <p>服务器从此开始使用这个随机值进行对称加密开始和客户端进行通信。</p> </li><li> <p>客户端拿到值用对称加密方式 使用随机值进行解密。</p> </li></ol> 
<p>为什么不一直使用非对称进行加密，而是在类似握手之后开始使用对称加密算法进行https通信：</p> 
<p>非对称加密的消耗和所需的计算以及时间远比对称加密消耗要大，所以在握手和认证之后，服务器和客户端就开始按照约定的随机串，对后续的数据传输进行加密。A如何把自己的数字证书发布给B，如果C截获A与B之间通信，把A的数字证书换成C的伪造的数字证书发给B，然后冒充A与B进行通信，这个时候B的根证书持有的CA的公钥无法打开数字证书，说明是假的</p> 
<p><strong>总结：</strong><br> <font color="blue">为了速度起见，客户端只在建立与服务器的连接时，使用非对称加密(利用数字证书中的服务器的公钥)，这个阶段是为了交换一个共享密钥。接下来的过程使用的是对称算法。</font></p> 
<p><font color="blue">回过头来，还记得文章开头上述非对称加密的作用吗？就是为了解决对称加密传输密钥容易被窃取的缺陷，而https没有粗暴的用非对称加密来替换对称加密，而是组合了这两种用法，利用非对称来传输对称加密的密钥！</font></p> 
<p><img src="https://images2.imgbox.com/14/0a/yG7720Sm_o.png" alt="在这里插入图片描述"></p> 
<p>再来个中文说明的图，意思差不多，但是更详尽：<br> <img src="https://images2.imgbox.com/52/da/elJZD6rA_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="42__315"></a>4.2 数字证书究竟解决了什么问题</h3> 
<p>还记得&lt;3.2 数字签名存在问题&gt;章节的问题吗，那么数字证书是怎么解决普通数字签名的问题的？</p> 
<p>首先我们回到主题，我们需要解决什么问题？问题就是“<code>如何确保本地持有的公钥是要访问的网站的真正公钥，而不是被坏人替换了假的公钥呢</code>”</p> 
<p>这里用到的是事先存储方法，<font color="blue">就是事先将这个网站的公钥放在一个地方P，并且信任这个地方P上的所有公钥。 将来只要浏览器能识别出公钥来自P，那么也会认可该公钥。</font></p> 
<p><font color="blue">于是存在某种机构，该机构不直接提供公钥，而是提供数字证书，把公钥放在证书内，将来只要浏览器识别数字证书是ok的，那么公钥自然也是ok的。</font></p> 
<p><font color="blue">那么如何识别数字证书呢？只要给数字证书加上防伪码就行了！这个防伪码就是数字证书上的数字签名(证书内容计算摘要，再用CA的私钥加密，只能CA的公钥能解密，CA的公钥内置于windows操作系统内)</font></p> 
<p>浏览器程序有一个证书选项，里面有“受信任的根证书颁发机构”，还有你的系统里的证书管理工具里也有信任的机构，机构列表来源就是根证书，安装一个根证书，机构列表就多个一条记录，在你装上系统或者下载浏览器的时候自带的，也可以后天安装。</p> 
<blockquote> 
 <p>一个根证书对应一家CA机构，<code>根证书内持有该CA的公钥</code>，这个公钥可以查看防伪码，公钥用于验证数字证书是否是其签发的；具体步骤就是再次计算内容的摘要，与证书中的摘要进行对比。</p> 
</blockquote> 
<p><font color="orange">注意：中间人攻击的特点是截获并替换，可以理解是在网络的中间替换，并不能替换已经下载至本地的正确的公钥，后者属于物理替换，比如中病毒了或机器被远程控制了才可以。为什么这么说，是因为《数字签名是什么？》作者阮一峰 (当然好多别的网站也有，毕竟都是翻译国外的)里面提到：</font></p> 
<pre><code class="prism language-bash">复杂的情况出现了。道格想欺骗苏珊，他<span class="token string">'偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。'</span>
此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，
用自己的私钥做成<span class="token string">"数字签名"</span>，写信给苏珊，让苏珊用假的鲍勃公钥进行解密
</code></pre> 
<p><font color="orange">这里面提到偷走电脑是非常不恰当的，也是导致难以理解数字证书的根本原因！因为既然能偷走电脑了，为何不能替换根证书？这样后续就可以替换网络中的数字证书，进而替换公钥了！</font></p> 
<p><font color="red">由上所知，预存在电脑上的根证书是不会被替换了(比如中病毒了或机器被远程控制了才可以)，那么访问网站时，网站提供的数字证书就是可验证的，进而网站的公钥一定是安全的！这样就解决了中间人的问题！</font></p> 
<p><font color="red">B尝试访问网站A，A把自己的申请的数字证书发布给B，如果C截获A与B之间通信，把A的数字证书换成C伪造的数字证书发给B，然后C冒充A与B进行通信，这个时候B本地的根证书持有CA的公钥，可以发现数字证书是假的！</font></p> 
<h4><a id="421__346"></a>4.2.1 如何攻击数字证书呢</h4> 
<p>这个问题很有意思，正好也可以加深我们的理解<br> 摘自<a href="https://blog.csdn.net/m0_45406092/article/details/121753697">《针对证书的攻击方法》</a></p> 
<p>一 在公钥注册之前攻击 // 除了内鬼，谁会知道你注册公钥的时刻去截获呢？<br> 二 注册相似人名进行攻击<br> 三 窃取认证机构的私钥进行攻击 //顶级黑客才行，毕竟有CA公司被攻破，也引发倒闭的前车之鉴，但是现存的几家CA，呵呵，想攻破，难于上青天<br> 四 攻击者伪装成认证机构进行攻击 //相对来说容易实现，只要让用户安装你的假根证书，让浏览器认为攻击者是合法的CA即可</p> 
<blockquote> 
 <p>因此，也提醒大家，在安装根证书时，需要小心再小心，当然即使是程序员，也难以区分根证书的！</p> 
</blockquote> 
<br> 
<h2><a id="_361"></a>参考：</h2> 
<p><a href="https://www.cnblogs.com/shijingjing07/p/5965792.html" rel="nofollow">《公钥与私钥，HTTPS详解》</a><br> <a href="https://www.cnblogs.com/dinglin1/p/9279831.html" rel="nofollow">《SSL证书原理讲解》</a> 参考数字证书交互方式<br> <a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" rel="nofollow">《数字签名是什么？》</a>作者 阮一峰 参考留言<br> <a href="https://www.cnblogs.com/gordon0918/p/5237717.html" rel="nofollow">Https协议简析及中间人攻击原理</a><br> <a href="https://blog.csdn.net/m0_45406092/article/details/121753697">《针对证书的攻击方法》</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3f5ee6088fd7ce14d01f0628d55567c0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Matlab绘图（第四节-三维曲线）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dedf74c97d0287196109d2ba31488b62/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微服务理解、Nacos与Eureka、Feign和Gateway</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>