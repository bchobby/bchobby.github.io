<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JavaScript 学习笔记 超详细（b站pink老师） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JavaScript 学习笔记 超详细（b站pink老师）" />
<meta property="og:description" content="权威网站： MDN
JavaScript权威网站： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript
目录
一、JavaScript基础
1.JavaScript介绍
1.1 JavaScript 是什么 1.2 JavaScript 书写位置
1.3 JavaScript 注释 1.4 JavaScript 结束符
1.5 JavaScript 输入输出语法
1.6 字面量
2.变量
2.1 变量是什么？
2.2 变量的基本使用
2.3 变量的本质
2.4 变量命名规则与规范
2.5变量拓展-let和var的区别
2.6变量拓展-数组
3.常量
4.数据类型
4.1 数据类型 – 数字类型（Number）
4.2 数据类型 – 字符串类型（string）
4.3数据类型 – 布尔类型（boolean）
4.4数据类型 – 未定义类型（undefined）
4.5数据类型 – null（空类型）
4.6控制台输出语句和检测数据类型
5.类型转换
5.1 为什么需要类型转换
5.2 隐式转换
5.3 显式转换
综合案例：用户订单信息案例
6.运算符
6.1 赋值运算符
6.2 一元运算符
6.3 比较运算符" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/dbe8cdf3cf5f25b72495c16168e028b5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-07T22:42:37+08:00" />
<meta property="article:modified_time" content="2023-06-07T22:42:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaScript 学习笔记 超详细（b站pink老师）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>权威网站： MDN</strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><strong><span style="color:#262626;"><strong>JavaScript权威网站： </strong></span></strong><strong><span style="color:#262626;"><strong>https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</strong></span></strong></strong></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81JavaScript%E5%9F%BA%E7%A1%80-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81JavaScript%E5%9F%BA%E7%A1%80" rel="nofollow">一、JavaScript基础</a></p> 
<p id="1.JavaScript%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#1.JavaScript%E4%BB%8B%E7%BB%8D" rel="nofollow">1.JavaScript介绍</a></p> 
<p id="1.1%20JavaScript%20%E6%98%AF%E4%BB%80%E4%B9%88%C2%A0-toc" style="margin-left:80px;"><a href="#1.1%20JavaScript%20%E6%98%AF%E4%BB%80%E4%B9%88%C2%A0" rel="nofollow">1.1 JavaScript 是什么 </a></p> 
<p id="1.2%20JavaScript%20%E4%B9%A6%E5%86%99%E4%BD%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#1.2%20JavaScript%20%E4%B9%A6%E5%86%99%E4%BD%8D%E7%BD%AE" rel="nofollow">1.2 JavaScript 书写位置</a></p> 
<p id="1.3%20JavaScript%20%E6%B3%A8%E9%87%8A%C2%A0-toc" style="margin-left:80px;"><a href="#1.3%20JavaScript%20%E6%B3%A8%E9%87%8A%C2%A0" rel="nofollow">1.3 JavaScript 注释 </a></p> 
<p id="1.4%20JavaScript%20%E7%BB%93%E6%9D%9F%E7%AC%A6-toc" style="margin-left:80px;"><a href="#1.4%20JavaScript%20%E7%BB%93%E6%9D%9F%E7%AC%A6" rel="nofollow">1.4 JavaScript 结束符</a></p> 
<p id="1.5%20JavaScript%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AF%AD%E6%B3%95-toc" style="margin-left:80px;"><a href="#1.5%20JavaScript%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AF%AD%E6%B3%95" rel="nofollow">1.5 JavaScript 输入输出语法</a></p> 
<p id="1.6%20%E5%AD%97%E9%9D%A2%E9%87%8F-toc" style="margin-left:80px;"><a href="#1.6%20%E5%AD%97%E9%9D%A2%E9%87%8F" rel="nofollow">1.6 字面量</a></p> 
<p id="2.%E5%8F%98%E9%87%8F-toc" style="margin-left:40px;"><a href="#2.%E5%8F%98%E9%87%8F" rel="nofollow">2.变量</a></p> 
<p id="2.1%20%E5%8F%98%E9%87%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:80px;"><a href="#2.1%20%E5%8F%98%E9%87%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">2.1 变量是什么？</a></p> 
<p id="2.2%20%E5%8F%98%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#2.2%20%E5%8F%98%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" rel="nofollow">2.2 变量的基本使用</a></p> 
<p id="2.3%20%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8-toc" style="margin-left:80px;"><a href="#2.3%20%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8" rel="nofollow">2.3 变量的本质</a></p> 
<p id="2.4%20%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E4%B8%8E%E8%A7%84%E8%8C%83-toc" style="margin-left:80px;"><a href="#2.4%20%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E4%B8%8E%E8%A7%84%E8%8C%83" rel="nofollow">2.4 变量命名规则与规范</a></p> 
<p id="2.5%E5%8F%98%E9%87%8F%E6%8B%93%E5%B1%95-let%E5%92%8Cvar%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#2.5%E5%8F%98%E9%87%8F%E6%8B%93%E5%B1%95-let%E5%92%8Cvar%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">2.5变量拓展-let和var的区别</a></p> 
<p id="2.6%E5%8F%98%E9%87%8F%E6%8B%93%E5%B1%95-%E6%95%B0%E7%BB%84-toc" style="margin-left:80px;"><a href="#2.6%E5%8F%98%E9%87%8F%E6%8B%93%E5%B1%95-%E6%95%B0%E7%BB%84" rel="nofollow">2.6变量拓展-数组</a></p> 
<p id="3.%E5%B8%B8%E9%87%8F-toc" style="margin-left:40px;"><a href="#3.%E5%B8%B8%E9%87%8F" rel="nofollow">3.常量</a></p> 
<p id="4.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#4.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" rel="nofollow">4.数据类型</a></p> 
<p id="4.1%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E2%80%93%20%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%EF%BC%88Number%EF%BC%89-toc" style="margin-left:80px;"><a href="#4.1%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E2%80%93%20%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%EF%BC%88Number%EF%BC%89" rel="nofollow">4.1 数据类型 – 数字类型（Number）</a></p> 
<p id="4.2%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E2%80%93%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%EF%BC%88string%EF%BC%89-toc" style="margin-left:80px;"><a href="#4.2%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E2%80%93%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%EF%BC%88string%EF%BC%89" rel="nofollow">4.2 数据类型 – 字符串类型（string）</a></p> 
<p id="4.3%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E2%80%93%20%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%EF%BC%88boolean%EF%BC%89-toc" style="margin-left:80px;"><a href="#4.3%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E2%80%93%20%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%EF%BC%88boolean%EF%BC%89" rel="nofollow">4.3数据类型 – 布尔类型（boolean）</a></p> 
<p id="4.4%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E2%80%93%20%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%EF%BC%88undefined%EF%BC%89-toc" style="margin-left:80px;"><a href="#4.4%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E2%80%93%20%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%EF%BC%88undefined%EF%BC%89" rel="nofollow">4.4数据类型 – 未定义类型（undefined）</a></p> 
<p id="4.5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E2%80%93%20null%EF%BC%88%E7%A9%BA%E7%B1%BB%E5%9E%8B%EF%BC%89-toc" style="margin-left:80px;"><a href="#4.5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E2%80%93%20null%EF%BC%88%E7%A9%BA%E7%B1%BB%E5%9E%8B%EF%BC%89" rel="nofollow">4.5数据类型 – null（空类型）</a></p> 
<p id="4.6%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#4.6%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" rel="nofollow">4.6控制台输出语句和检测数据类型</a></p> 
<p id="%C2%A05.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-toc" style="margin-left:40px;"><a href="#%C2%A05.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" rel="nofollow"> 5.类型转换</a></p> 
<p id="5.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-toc" style="margin-left:80px;"><a href="#5.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" rel="nofollow">5.1 为什么需要类型转换</a></p> 
<p id="5.2%20%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2-toc" style="margin-left:80px;"><a href="#5.2%20%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2" rel="nofollow">5.2 隐式转换</a></p> 
<p id="5.3%20%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2-toc" style="margin-left:80px;"><a href="#5.3%20%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2" rel="nofollow">5.3 显式转换</a></p> 
<p id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E7%94%A8%E6%88%B7%E8%AE%A2%E5%8D%95%E4%BF%A1%E6%81%AF%E6%A1%88%E4%BE%8B-toc" style="margin-left:40px;"><a href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E7%94%A8%E6%88%B7%E8%AE%A2%E5%8D%95%E4%BF%A1%E6%81%AF%E6%A1%88%E4%BE%8B" rel="nofollow">综合案例：用户订单信息案例</a></p> 
<p id="%C2%A06.%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:40px;"><a href="#%C2%A06.%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow"> 6.运算符</a></p> 
<p id="6.1%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px;"><a href="#6.1%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">6.1 赋值运算符</a></p> 
<p id="6.2%20%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px;"><a href="#6.2%20%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">6.2 一元运算符</a></p> 
<p id="6.3%20%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px;"><a href="#6.3%20%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">6.3 比较运算符</a></p> 
<p id="6.4%20%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px;"><a href="#6.4%20%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">6.4 逻辑运算符</a></p> 
<p id="%C2%A06.5%20%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7-toc" style="margin-left:80px;"><a href="#%C2%A06.5%20%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7" rel="nofollow"> 6.5 运算符优先级</a></p> 
<p id="7.%E8%AF%AD%E5%8F%A5-toc" style="margin-left:40px;"><a href="#7.%E8%AF%AD%E5%8F%A5" rel="nofollow">7.语句</a></p> 
<p id="7.1%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E5%8F%A5-toc" style="margin-left:80px;"><a href="#7.1%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E5%8F%A5" rel="nofollow">7.1 表达式语句</a></p> 
<p id="7.2%20%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%EF%BC%88%20if%E8%AF%AD%E5%8F%A5%E3%80%81%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81switch%E8%AF%AD%E5%8F%A5%20%EF%BC%89-toc" style="margin-left:80px;"><a href="#7.2%20%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%EF%BC%88%20if%E8%AF%AD%E5%8F%A5%E3%80%81%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81switch%E8%AF%AD%E5%8F%A5%20%EF%BC%89" rel="nofollow">7.2 分支语句（ if语句、三元运算符、switch语句 ）</a></p> 
<p id="7.3%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#7.3%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84" rel="nofollow">7.3 循环结构</a></p> 
<p id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E7%AE%80%E6%98%93ATM%E5%8F%96%E6%AC%BE%E6%9C%BA%E6%A1%88%E4%BE%8B-toc" style="margin-left:40px;"><a href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E7%AE%80%E6%98%93ATM%E5%8F%96%E6%AC%BE%E6%9C%BA%E6%A1%88%E4%BE%8B" rel="nofollow">综合案例：简易ATM取款机案例</a></p> 
<p id="8.for%E5%BE%AA%E7%8E%AF-toc" style="margin-left:40px;"><a href="#8.for%E5%BE%AA%E7%8E%AF" rel="nofollow">8.for循环</a></p> 
<p id="9.%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#9.%E6%95%B0%E7%BB%84" rel="nofollow">9.数组</a></p> 
<p id="9.1%20%E6%95%B0%E7%BB%84%E6%98%AF%E4%BB%80%E4%B9%88-toc" style="margin-left:80px;"><a href="#9.1%20%E6%95%B0%E7%BB%84%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">9.1 数组是什么</a></p> 
<p id="9.2%20%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#9.2%20%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" rel="nofollow">9.2 数组的基本使用</a></p> 
<p id="9.3%20%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84-toc" style="margin-left:80px;"><a href="#9.3%20%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84" rel="nofollow">9.3 操作数组</a></p> 
<p id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E6%9F%B1%E5%BD%A2%E5%9B%BE-toc" style="margin-left:40px;"><a href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E6%9F%B1%E5%BD%A2%E5%9B%BE" rel="nofollow">综合案例：根据数据生成柱形图</a></p> 
<p id="9.4%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#9.4%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" rel="nofollow">9.4 冒泡排序</a></p> 
<p id="9.5%20%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#9.5%20%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F" rel="nofollow">9.5 数组排序</a></p> 
<p id="10.%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#10.%E5%87%BD%E6%95%B0" rel="nofollow">10.函数</a></p> 
<p id="10.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#10.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%87%BD%E6%95%B0" rel="nofollow">10.1 为什么需要函数</a></p> 
<p id="10.2%20%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#10.2%20%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8" rel="nofollow">10.2 函数使用</a></p> 
<p id="10.3%20%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82-toc" style="margin-left:80px;"><a href="#10.3%20%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82" rel="nofollow">10.3 函数传参</a></p> 
<p id="10.4%20%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC-toc" style="margin-left:80px;"><a href="#10.4%20%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC" rel="nofollow">10.4 函数返回值</a></p> 
<p id="10.5%20%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A1%A5%E5%85%85-toc" style="margin-left:80px;"><a href="#10.5%20%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A1%A5%E5%85%85" rel="nofollow">10.5 函数细节补充</a></p> 
<p id="10.6%20%E4%BD%9C%E7%94%A8%E5%9F%9F-toc" style="margin-left:80px;"><a href="#10.6%20%E4%BD%9C%E7%94%A8%E5%9F%9F" rel="nofollow">10.6 作用域</a></p> 
<p id="10.7%C2%A0%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#10.7%C2%A0%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0" rel="nofollow">10.7 匿名函数</a></p> 
<p id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4%E6%A1%88%E4%BE%8B-toc" style="margin-left:40px;"><a href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4%E6%A1%88%E4%BE%8B" rel="nofollow">综合案例：转换时间案例</a></p> 
<p id="10.8%20%E9%80%BB%E8%BE%91%E4%B8%AD%E6%96%AD-toc" style="margin-left:80px;"><a href="#10.8%20%E9%80%BB%E8%BE%91%E4%B8%AD%E6%96%AD" rel="nofollow">10.8 逻辑中断</a></p> 
<p id="10.%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#10.%E5%AF%B9%E8%B1%A1" rel="nofollow">10.对象</a></p> 
<p id="10.1%C2%A0%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88-toc" style="margin-left:80px;"><a href="#10.1%C2%A0%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">10.1 对象是什么</a></p> 
<p id="10.2%20%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#10.2%20%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8" rel="nofollow">10.2 对象使用</a></p> 
<p id="10.2%20%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#10.2%20%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8" rel="nofollow">10.2 对象使用</a></p> 
<p id="10.3%C2%A0%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#10.3%C2%A0%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1" rel="nofollow">10.3 遍历对象</a></p> 
<p id="10.4%C2%A0%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#10.4%C2%A0%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1" rel="nofollow">10.4 内置对象</a></p> 
<p id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%A1%88%E4%BE%8B-toc" style="margin-left:40px;"><a href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%A1%88%E4%BE%8B" rel="nofollow">综合案例：学成在线页面渲染案例</a></p> 
<p id="%E6%8B%93%E5%B1%95-%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A-toc" style="margin-left:80px;"><a href="#%E6%8B%93%E5%B1%95-%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A" rel="nofollow">拓展-术语解释</a></p> 
<p id="%E6%8B%93%E5%B1%95-%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%C2%A0-toc" style="margin-left:80px;"><a href="#%E6%8B%93%E5%B1%95-%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%C2%A0" rel="nofollow">拓展- 基本数据类型和引用数据类型 </a></p> 
<p id="%E6%8B%93%E5%B1%95-%20%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E-toc" style="margin-left:80px;"><a href="#%E6%8B%93%E5%B1%95-%20%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E" rel="nofollow">拓展- 变量声明</a></p> 
<p id="%E4%BA%8C%E3%80%81Web%20APIs-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81Web%20APIs" rel="nofollow">二、Web APIs</a></p> 
<p id="1.%20Web%20API%20%E5%9F%BA%E6%9C%AC%E8%AE%A4%E7%9F%A5-toc" style="margin-left:40px;"><a href="#1.%20Web%20API%20%E5%9F%BA%E6%9C%AC%E8%AE%A4%E7%9F%A5" rel="nofollow">1. Web API 基本认知</a></p> 
<p id="1.1%20%E4%BD%9C%E7%94%A8%E5%92%8C%E5%88%86%E7%B1%BB-toc" style="margin-left:80px;"><a href="#1.1%20%E4%BD%9C%E7%94%A8%E5%92%8C%E5%88%86%E7%B1%BB" rel="nofollow">1.1 作用和分类</a></p> 
<p id="1.2%20%E4%BB%80%E4%B9%88%E6%98%AFDOM-toc" style="margin-left:80px;"><a href="#1.2%20%E4%BB%80%E4%B9%88%E6%98%AFDOM" rel="nofollow">1.2 什么是DOM</a></p> 
<p id="1.3%20DOM%E6%A0%91-toc" style="margin-left:80px;"><a href="#1.3%20DOM%E6%A0%91" rel="nofollow">1.3 DOM树</a></p> 
<p id="1.4%20DOM%E5%AF%B9%E8%B1%A1%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89-toc" style="margin-left:80px;"><a href="#1.4%20DOM%E5%AF%B9%E8%B1%A1%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89" rel="nofollow">1.4 DOM对象（重要）</a></p> 
<p id="2.%E8%8E%B7%E5%8F%96DOM%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#2.%E8%8E%B7%E5%8F%96DOM%E5%AF%B9%E8%B1%A1" rel="nofollow">2.获取DOM对象</a></p> 
<p id="2.1%20%E6%A0%B9%E6%8D%AECSS%E9%80%89%E6%8B%A9%E5%99%A8%E6%9D%A5%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0%20(%E9%87%8D%E7%82%B9)-toc" style="margin-left:80px;"><a href="#2.1%20%E6%A0%B9%E6%8D%AECSS%E9%80%89%E6%8B%A9%E5%99%A8%E6%9D%A5%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0%20%28%E9%87%8D%E7%82%B9%29" rel="nofollow">2.1 根据CSS选择器来获取DOM元素 (重点)</a></p> 
<p id="2.2%20%E5%85%B6%E4%BB%96%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px;"><a href="#2.2%20%E5%85%B6%E4%BB%96%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89" rel="nofollow">2.2 其他获取DOM元素方法（了解）</a></p> 
<p id="3.%20%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E5%86%85%E5%AE%B9%C2%A0-toc" style="margin-left:40px;"><a href="#3.%20%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E5%86%85%E5%AE%B9%C2%A0" rel="nofollow">3. 操作元素内容 </a></p> 
<p id="4.%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px;"><a href="#4.%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7" rel="nofollow">4.操作元素属性</a></p> 
<p id="4.1%20%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7-toc" style="margin-left:80px;"><a href="#4.1%20%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7" rel="nofollow">4.1 操作元素常用属性</a></p> 
<p id="4.2%20%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E6%A0%B7%E5%BC%8F%E5%B1%9E%E6%80%A7-toc" style="margin-left:80px;"><a href="#4.2%20%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E6%A0%B7%E5%BC%8F%E5%B1%9E%E6%80%A7" rel="nofollow">4.2 操作元素样式属性</a></p> 
<p id="%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%BD%AE%E6%92%AD%E5%9B%BE%E9%9A%8F%E6%9C%BA%E7%89%88-toc" style="margin-left:80px;"><a href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%BD%AE%E6%92%AD%E5%9B%BE%E9%9A%8F%E6%9C%BA%E7%89%88" rel="nofollow">案例：轮播图随机版</a></p> 
<p id="4.3%20%E6%93%8D%E4%BD%9C%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7-toc" style="margin-left:80px;"><a href="#4.3%20%E6%93%8D%E4%BD%9C%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7" rel="nofollow">4.3 操作表单元素属性</a></p> 
<p id="4.4%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7-toc" style="margin-left:80px;"><a href="#4.4%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7" rel="nofollow">4.4 自定义属性</a></p> 
<p id="5.%E5%AE%9A%E6%97%B6%E5%99%A8-%E9%97%B4%E6%AD%87%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#5.%E5%AE%9A%E6%97%B6%E5%99%A8-%E9%97%B4%E6%AD%87%E5%87%BD%E6%95%B0" rel="nofollow">5.定时器-间歇函数</a></p> 
<p id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%BD%AE%E6%92%AD%E5%9B%BE%E5%AE%9A%E6%97%B6%E5%99%A8%E7%89%88-toc" style="margin-left:40px;"><a href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%BD%AE%E6%92%AD%E5%9B%BE%E5%AE%9A%E6%97%B6%E5%99%A8%E7%89%88" rel="nofollow">综合案例：轮播图定时器版</a></p> 
<p id="6.%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%EF%BC%88%E7%BB%91%E5%AE%9A%EF%BC%89-toc" style="margin-left:40px;"><a href="#6.%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%EF%BC%88%E7%BB%91%E5%AE%9A%EF%BC%89" rel="nofollow">6.事件监听（绑定）</a></p> 
<p id="6.1%20%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC-toc" style="margin-left:80px;"><a href="#6.1%20%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC" rel="nofollow">6.1 事件监听</a></p> 
<p id="6.2%20%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E7%89%88%E6%9C%AC-toc" style="margin-left:80px;"><a href="#6.2%20%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E7%89%88%E6%9C%AC" rel="nofollow">6.2 事件监听版本</a></p> 
<p id="7.%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#7.%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B" rel="nofollow">7.事件类型</a></p> 
<p id="%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%BD%AE%E6%92%AD%E5%9B%BE%E5%AE%8C%E6%95%B4%E7%89%88-toc" style="margin-left:80px;"><a href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%BD%AE%E6%92%AD%E5%9B%BE%E5%AE%8C%E6%95%B4%E7%89%88" rel="nofollow">案例：轮播图完整版</a></p> 
<p id="8.%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#8.%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1" rel="nofollow">8.事件对象</a></p> 
<p id="8.1%20%E8%8E%B7%E5%8F%96%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#8.1%20%E8%8E%B7%E5%8F%96%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1" rel="nofollow">8.1 获取事件对象</a></p> 
<p id="8.2%20%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7-toc" style="margin-left:80px;"><a href="#8.2%20%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7" rel="nofollow">8.2 事件对象常用属性</a></p> 
<p id="9.%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#9.%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1" rel="nofollow">9.环境对象</a></p> 
<p id="10.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#10.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" rel="nofollow">10.回调函数</a></p> 
<p id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9ATab%E6%A0%8F%E5%88%87%E6%8D%A2-toc" style="margin-left:40px;"><a href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9ATab%E6%A0%8F%E5%88%87%E6%8D%A2" rel="nofollow">综合案例：Tab栏切换</a></p> 
<p id="%E9%87%8D%E7%82%B9%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%85%A8%E9%80%89%E6%96%87%E6%9C%AC%E6%A1%86-toc" style="margin-left:80px;"><a href="#%E9%87%8D%E7%82%B9%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%85%A8%E9%80%89%E6%96%87%E6%9C%AC%E6%A1%86" rel="nofollow">重点案例：全选文本框</a></p> 
<p id="11.%E4%BA%8B%E4%BB%B6%E6%B5%81-toc" style="margin-left:40px;"><a href="#11.%E4%BA%8B%E4%BB%B6%E6%B5%81" rel="nofollow">11.事件流</a></p> 
<p id="11.1%20%E4%BA%8B%E4%BB%B6%E6%B5%81%E5%92%8C%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><a href="#11.1%20%E4%BA%8B%E4%BB%B6%E6%B5%81%E5%92%8C%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5%E8%AF%B4%E6%98%8E" rel="nofollow">11.1 事件流和两个阶段说明</a></p> 
<p id="11.2%20%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7-toc" style="margin-left:80px;"><a href="#11.2%20%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7" rel="nofollow">11.2 事件捕获</a></p> 
<p id="11.3%20%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1-toc" style="margin-left:80px;"><a href="#11.3%20%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1" rel="nofollow">11.3 事件冒泡</a></p> 
<p id="11.4%20%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1-toc" style="margin-left:80px;"><a href="#11.4%20%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1" rel="nofollow">11.4 阻止冒泡</a></p> 
<p id="11.5%20%E8%A7%A3%E7%BB%91%E4%BA%8B%E4%BB%B6-toc" style="margin-left:80px;"><a href="#11.5%20%E8%A7%A3%E7%BB%91%E4%BA%8B%E4%BB%B6" rel="nofollow">11.5 解绑事件</a></p> 
<p id="%E6%8B%93%E5%B1%95%EF%BC%9A%E9%BC%A0%E6%A0%87%E7%BB%8F%E8%BF%87%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E4%B8%A4%E7%A7%8D%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#%E6%8B%93%E5%B1%95%EF%BC%9A%E9%BC%A0%E6%A0%87%E7%BB%8F%E8%BF%87%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E4%B8%A4%E7%A7%8D%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">拓展：鼠标经过事件的区别、两种注册事件的区别</a></p> 
<p id="12.%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98-toc" style="margin-left:40px;"><a href="#12.%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98" rel="nofollow">12.事件委托</a></p> 
<p id="%E6%A1%88%E4%BE%8B%EF%BC%9Atab%E6%A0%8F%E5%88%87%E6%8D%A2%E6%94%B9%E9%80%A0-toc" style="margin-left:80px;"><a href="#%E6%A1%88%E4%BE%8B%EF%BC%9Atab%E6%A0%8F%E5%88%87%E6%8D%A2%E6%94%B9%E9%80%A0" rel="nofollow">案例：tab栏切换改造</a></p> 
<p id="13.%E5%85%B6%E4%BB%96%E4%BA%8B%E4%BB%B6-toc" style="margin-left:40px;"><a href="#13.%E5%85%B6%E4%BB%96%E4%BA%8B%E4%BB%B6" rel="nofollow">13.其他事件</a></p> 
<p id="13.1%20%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6-toc" style="margin-left:80px;"><a href="#13.1%20%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6" rel="nofollow">13.1 页面加载事件</a></p> 
<p id="13.2%20%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6-toc" style="margin-left:80px;"><a href="#13.2%20%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6" rel="nofollow">13.2 页面滚动事件</a></p> 
<p id="13.3%20%E9%A1%B5%E9%9D%A2%E5%B0%BA%E5%AF%B8%E4%BA%8B%E4%BB%B6-toc" style="margin-left:80px;"><a href="#13.3%20%E9%A1%B5%E9%9D%A2%E5%B0%BA%E5%AF%B8%E4%BA%8B%E4%BB%B6" rel="nofollow">13.3 页面尺寸事件</a></p> 
<p id="13.4%20%E5%85%83%E7%B4%A0%E5%B0%BA%E5%AF%B8%E4%B8%8E%E4%BD%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#13.4%20%E5%85%83%E7%B4%A0%E5%B0%BA%E5%AF%B8%E4%B8%8E%E4%BD%8D%E7%BD%AE" rel="nofollow">13.4 元素尺寸与位置</a></p> 
<p id="%E6%80%BB%E7%BB%93%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:80px;"><a href="#%E6%80%BB%E7%BB%93%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">总结​编辑</a></p> 
<p id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E7%94%B5%E6%A2%AF%E5%AF%BC%E8%88%AA-toc" style="margin-left:80px;"><a href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E7%94%B5%E6%A2%AF%E5%AF%BC%E8%88%AA" rel="nofollow">综合案例：电梯导航</a></p> 
<p id="14.%20%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#14.%20%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1" rel="nofollow">14. 日期对象</a></p> 
<p id="14.1%20%E5%AE%9E%E4%BE%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#14.1%20%E5%AE%9E%E4%BE%8B%E5%8C%96" rel="nofollow">14.1 实例化</a></p> 
<p id="14.2%20%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#14.2%20%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95" rel="nofollow">14.2 日期对象方法</a></p> 
<p id="14.3%20%E6%97%B6%E9%97%B4%E6%88%B3-toc" style="margin-left:80px;"><a href="#14.3%20%E6%97%B6%E9%97%B4%E6%88%B3" rel="nofollow">14.3 时间戳</a></p> 
<p id="15.%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#15.%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C" rel="nofollow">15.节点操作</a></p> 
<p id="15.1%20DOM%E8%8A%82%E7%82%B9-toc" style="margin-left:80px;"><a href="#15.1%20DOM%E8%8A%82%E7%82%B9" rel="nofollow">15.1 DOM节点</a></p> 
<p id="15.2%20%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9-toc" style="margin-left:80px;"><a href="#15.2%20%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9" rel="nofollow">15.2 查找节点</a></p> 
<p id="15.3%20%E5%A2%9E%E5%8A%A0%E8%8A%82%E7%82%B9-toc" style="margin-left:80px;"><a href="#15.3%20%E5%A2%9E%E5%8A%A0%E8%8A%82%E7%82%B9" rel="nofollow">15.3 增加节点</a></p> 
<p id="15.4%20%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9-toc" style="margin-left:80px;"><a href="#15.4%20%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9" rel="nofollow">15.4 删除节点</a></p> 
<p id="16.%20M%E7%AB%AF%E4%BA%8B%E4%BB%B6-toc" style="margin-left:40px;"><a href="#16.%20M%E7%AB%AF%E4%BA%8B%E4%BB%B6" rel="nofollow">16. M端事件</a></p> 
<p id="17.%E6%8F%92%E4%BB%B6%C2%A0-toc" style="margin-left:40px;"><a href="#17.%E6%8F%92%E4%BB%B6%C2%A0" rel="nofollow">17.插件 </a></p> 
<p id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E8%A1%A8-toc" style="margin-left:40px;"><a href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E8%A1%A8" rel="nofollow">综合案例：学生信息表</a></p> 
<p id="18.%20%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81-toc" style="margin-left:40px;"><a href="#18.%20%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81" rel="nofollow">18. 重绘和回流</a></p> 
<p id="19.Window%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#19.Window%E5%AF%B9%E8%B1%A1" rel="nofollow">19.Window对象</a></p> 
<p id="19.1%20BOM-toc" style="margin-left:80px;"><a href="#19.1%20BOM" rel="nofollow">19.1 BOM</a></p> 
<p id="19.2%20%E5%AE%9A%E6%97%B6%E5%99%A8-%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#19.2%20%E5%AE%9A%E6%97%B6%E5%99%A8-%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0" rel="nofollow">19.2 定时器-延时函数</a></p> 
<p id="19.3%20JS%20%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-toc" style="margin-left:80px;"><a href="#19.3%20JS%20%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6" rel="nofollow">19.3 JS 执行机制</a></p> 
<p id="19.4%20location%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#19.4%20location%E5%AF%B9%E8%B1%A1" rel="nofollow">19.4 location对象</a></p> 
<p id="19.5%20navigator%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#19.5%20navigator%E5%AF%B9%E8%B1%A1" rel="nofollow">19.5 navigator对象</a></p> 
<p id="19.6%20histroy%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#19.6%20histroy%E5%AF%B9%E8%B1%A1" rel="nofollow">19.6 histroy对象</a></p> 
<p id="20.%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8-toc" style="margin-left:40px;"><a href="#20.%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8" rel="nofollow">20.本地存储</a></p> 
<p id="20.1%20%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#20.1%20%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E4%BB%8B%E7%BB%8D" rel="nofollow">20.1 本地存储介绍</a></p> 
<p id="20.2%20%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%88%86%E7%B1%BB-%20localStorage-toc" style="margin-left:80px;"><a href="#20.2%20%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%88%86%E7%B1%BB-%20localStorage" rel="nofollow">20.2 本地存储分类- localStorage</a></p> 
<p id="20.2%20%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%88%86%E7%B1%BB-%20sessionStorage-toc" style="margin-left:80px;"><a href="#20.2%20%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%88%86%E7%B1%BB-%20sessionStorage" rel="nofollow">20.2 本地存储分类- sessionStorage</a></p> 
<p id="20.3%20%E5%AD%98%E5%82%A8%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#20.3%20%E5%AD%98%E5%82%A8%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" rel="nofollow">20.3 存储复杂数据类型</a></p> 
<p id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%AD%A6%E7%94%9F%E5%B0%B1%E4%B8%9A%E4%BF%A1%E6%81%AF%E8%A1%A8%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%AD%A6%E7%94%9F%E5%B0%B1%E4%B8%9A%E4%BF%A1%E6%81%AF%E8%A1%A8%C2%A0" rel="nofollow">综合案例：学生就业信息表 </a></p> 
<p id="21.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:40px;"><a href="#21.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">21.正则表达式</a></p> 
<p id="21.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:80px;"><a href="#21.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">21.1 什么是正则表达式</a></p> 
<p id="21.2%20%E8%AF%AD%E6%B3%95-toc" style="margin-left:80px;"><a href="#21.2%20%E8%AF%AD%E6%B3%95" rel="nofollow">21.2 语法</a></p> 
<p id="21.3%20%E5%85%83%E5%AD%97%E7%AC%A6-toc" style="margin-left:80px;"><a href="#21.3%20%E5%85%83%E5%AD%97%E7%AC%A6" rel="nofollow">21.3 元字符</a></p> 
<p id="21.4%20%E4%BF%AE%E9%A5%B0%E7%AC%A6-toc" style="margin-left:80px;"><a href="#21.4%20%E4%BF%AE%E9%A5%B0%E7%AC%A6" rel="nofollow">21.4 修饰符</a></p> 
<p id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%B0%8F%E5%85%94%E9%B2%9C%E9%A1%B5%E9%9D%A2%E6%B3%A8%E5%86%8C-toc" style="margin-left:40px;"><a href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%B0%8F%E5%85%94%E9%B2%9C%E9%A1%B5%E9%9D%A2%E6%B3%A8%E5%86%8C" rel="nofollow">综合案例：小兔鲜页面注册</a></p> 
<p id="%E9%98%B6%E6%AE%B5%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%B0%8F%E5%85%94%E9%B2%9C%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2-toc" style="margin-left:40px;"><a href="#%E9%98%B6%E6%AE%B5%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%B0%8F%E5%85%94%E9%B2%9C%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2" rel="nofollow">阶段案例：小兔鲜登录页面</a></p> 
<p id="%E9%98%B6%E6%AE%B5%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%B0%8F%E5%85%94%E9%B2%9C%E9%A6%96%E9%A1%B5%E9%A1%B5%E9%9D%A2-toc" style="margin-left:40px;"><a href="#%E9%98%B6%E6%AE%B5%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%B0%8F%E5%85%94%E9%B2%9C%E9%A6%96%E9%A1%B5%E9%A1%B5%E9%9D%A2" rel="nofollow">阶段案例：小兔鲜首页页面</a></p> 
<p id="%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%94%BE%E5%A4%A7%E9%95%9C%E6%95%88%E6%9E%9C-toc" style="margin-left:40px;"><a href="#%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%94%BE%E5%A4%A7%E9%95%9C%E6%95%88%E6%9E%9C" rel="nofollow">实战案例：放大镜效果</a></p> 
<p id="%E4%B8%89%E3%80%81JS%E8%BF%9B%E9%98%B6-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81JS%E8%BF%9B%E9%98%B6" rel="nofollow">三、JS进阶</a></p> 
<p id="1.%E4%BD%9C%E7%94%A8%E5%9F%9F-toc" style="margin-left:40px;"><a href="#1.%E4%BD%9C%E7%94%A8%E5%9F%9F" rel="nofollow">1.作用域</a></p> 
<p id="1.1%20%E5%B1%80%E9%83%A8%E4%BD%9C%E7%94%A8%E5%9F%9F-toc" style="margin-left:80px;"><a href="#1.1%20%E5%B1%80%E9%83%A8%E4%BD%9C%E7%94%A8%E5%9F%9F" rel="nofollow">1.1 局部作用域</a></p> 
<p id="1.2%20%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F-toc" style="margin-left:80px;"><a href="#1.2%20%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F" rel="nofollow">1.2 全局作用域</a></p> 
<p id="1.3%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-toc" style="margin-left:80px;"><a href="#1.3%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE" rel="nofollow">1.3 作用域链</a></p> 
<p id="1.4%20JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-toc" style="margin-left:80px;"><a href="#1.4%20JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6" rel="nofollow">1.4 JS垃圾回收机制</a></p> 
<p id="%E6%8B%93%E5%B1%95-JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-%E7%AE%97%E6%B3%95%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><a href="#%E6%8B%93%E5%B1%95-JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-%E7%AE%97%E6%B3%95%E8%AF%B4%E6%98%8E" rel="nofollow">拓展-JS垃圾回收机制-算法说明</a></p> 
<p id="1.5%20%E9%97%AD%E5%8C%85-toc" style="margin-left:80px;"><a href="#1.5%20%E9%97%AD%E5%8C%85" rel="nofollow">1.5 闭包</a></p> 
<p id="1.6%20%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87-toc" style="margin-left:80px;"><a href="#1.6%20%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87" rel="nofollow">1.6 变量提升</a></p> 
<p id="2.%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6-toc" style="margin-left:40px;"><a href="#2.%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6" rel="nofollow">2.函数进阶</a></p> 
<p id="2.1%20%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87-toc" style="margin-left:80px;"><a href="#2.1%20%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87" rel="nofollow">2.1 函数提升</a></p> 
<p id="2.2%20%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#2.2%20%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0" rel="nofollow">2.2 函数参数</a></p> 
<p id="%E6%8B%93%E5%B1%95-%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6-toc" style="margin-left:80px;"><a href="#%E6%8B%93%E5%B1%95-%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6" rel="nofollow">拓展-展开运算符</a></p> 
<p id="2.3%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89-toc" style="margin-left:80px;"><a href="#2.3%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89" rel="nofollow">2.3 箭头函数（重要）</a></p> 
<p id="3.%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC-toc" style="margin-left:40px;"><a href="#3.%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC" rel="nofollow">3.解构赋值</a></p> 
<p id="3.1%20%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84-toc" style="margin-left:80px;"><a href="#3.1%20%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84" rel="nofollow">3.1 数组解构</a></p> 
<p id="%E6%B3%A8%E6%84%8F%EF%BC%9A%20js%20%E5%89%8D%E9%9D%A2%E5%BF%85%E9%A1%BB%E5%8A%A0%E5%88%86%E5%8F%B7%E6%83%85%E5%86%B5-toc" style="margin-left:80px;"><a href="#%E6%B3%A8%E6%84%8F%EF%BC%9A%20js%20%E5%89%8D%E9%9D%A2%E5%BF%85%E9%A1%BB%E5%8A%A0%E5%88%86%E5%8F%B7%E6%83%85%E5%86%B5" rel="nofollow">注意： js 前面必须加分号情况</a></p> 
<p id="3.2%20%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84-toc" style="margin-left:80px;"><a href="#3.2%20%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84" rel="nofollow">3.2 对象解构</a></p> 
<p id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%95%86%E5%93%81%E5%88%97%E8%A1%A8%E4%BB%B7%E6%A0%BC%E7%AD%9B%E9%80%89-toc" style="margin-left:40px;"><a href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%95%86%E5%93%81%E5%88%97%E8%A1%A8%E4%BB%B7%E6%A0%BC%E7%AD%9B%E9%80%89" rel="nofollow">综合案例：商品列表价格筛选</a></p> 
<p id="4.%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1-toc" style="margin-left:40px;"><a href="#4.%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1" rel="nofollow">4.深入对象</a></p> 
<p id="4.1%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#4.1%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F" rel="nofollow">4.1创建对象三种方式</a></p> 
<p id="4.2%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#4.2%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">4.2 构造函数</a></p> 
<p id="4.3%C2%A0%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98%26%E9%9D%99%E6%80%81%E6%88%90%E5%91%98-toc" style="margin-left:80px;"><a href="#4.3%C2%A0%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98%26%E9%9D%99%E6%80%81%E6%88%90%E5%91%98" rel="nofollow">4.3 实例成员&amp;静态成员</a></p> 
<p id="5.%E5%86%85%E7%BD%AE%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#5.%E5%86%85%E7%BD%AE%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">5.内置构造函数</a></p> 
<p id="5.1%20Object-toc" style="margin-left:80px;"><a href="#5.1%20Object" rel="nofollow">5.1 Object</a></p> 
<p id="5.2%20Array-toc" style="margin-left:80px;"><a href="#5.2%20Array" rel="nofollow">5.2 Array</a></p> 
<p id="5.3%20String-toc" style="margin-left:80px;"><a href="#5.3%20String" rel="nofollow">5.3 String</a></p> 
<p id="%E6%98%BE%E7%A4%BA%E8%B5%A0%E5%93%81%E7%BB%83%E4%B9%A0-toc" style="margin-left:80px;"><a href="#%E6%98%BE%E7%A4%BA%E8%B5%A0%E5%93%81%E7%BB%83%E4%B9%A0" rel="nofollow">显示赠品练习</a></p> 
<p id="5.4%20Number-toc" style="margin-left:80px;"><a href="#5.4%20Number" rel="nofollow">5.4 Number</a></p> 
<p id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%B1%95%E7%A4%BA-toc" style="margin-left:40px;"><a href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%B1%95%E7%A4%BA" rel="nofollow">综合案例：购物车展示</a></p> 
<p id="6.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-toc" style="margin-left:40px;"><a href="#6.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3" rel="nofollow">6.编程思想</a></p> 
<p id="6.1%20%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B-toc" style="margin-left:80px;"><a href="#6.1%20%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B" rel="nofollow">6.1 面向过程编程</a></p> 
<p id="6.2%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%20(oop)-toc" style="margin-left:80px;"><a href="#6.2%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%20%28oop%29" rel="nofollow">6.2 面向对象编程 (oop)</a></p> 
<p id="6.3%20%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AF%B9%E6%AF%94-toc" style="margin-left:80px;"><a href="#6.3%20%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AF%B9%E6%AF%94" rel="nofollow">6.3 面向过程和面向对象的对比</a></p> 
<p id="7.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E5%B0%81%E8%A3%85%E6%80%A7%EF%BC%89-toc" style="margin-left:40px;"><a href="#7.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E5%B0%81%E8%A3%85%E6%80%A7%EF%BC%89" rel="nofollow">7. 构造函数（封装性）</a></p> 
<p id="8.%E5%8E%9F%E5%9E%8B-toc" style="margin-left:40px;"><a href="#8.%E5%8E%9F%E5%9E%8B" rel="nofollow">8.原型</a></p> 
<p id="8.1%20%E5%8E%9F%E5%9E%8B-toc" style="margin-left:80px;"><a href="#8.1%20%E5%8E%9F%E5%9E%8B" rel="nofollow">8.1 原型</a></p> 
<p id="%C2%A08.2%20%E5%8E%9F%E5%9E%8B%20-%20this%E6%8C%87%E5%90%91-toc" style="margin-left:80px;"><a href="#%C2%A08.2%20%E5%8E%9F%E5%9E%8B%20-%20this%E6%8C%87%E5%90%91" rel="nofollow"> 8.2 原型 - this指向</a></p> 
<p id="8.3%20constructor%20%E5%B1%9E%E6%80%A7-toc" style="margin-left:80px;"><a href="#8.3%20constructor%20%E5%B1%9E%E6%80%A7" rel="nofollow">8.3 constructor 属性</a></p> 
<p id="8.4%20%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B-toc" style="margin-left:80px;"><a href="#8.4%20%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B" rel="nofollow">8.4 对象原型</a></p> 
<p id="8.5%C2%A0%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF-toc" style="margin-left:80px;"><a href="#8.5%C2%A0%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF" rel="nofollow">8.5 原型继承</a></p> 
<p id="8.6%20%E5%8E%9F%E5%9E%8B%E9%93%BE-toc" style="margin-left:80px;"><a href="#8.6%20%E5%8E%9F%E5%9E%8B%E9%93%BE" rel="nofollow">8.6 原型链</a></p> 
<p id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%B6%88%E6%81%AF%E6%8F%90%E7%A4%BA%E5%AF%B9%E8%B1%A1%E5%B0%81%E8%A3%85-toc" style="margin-left:40px;"><a href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%B6%88%E6%81%AF%E6%8F%90%E7%A4%BA%E5%AF%B9%E8%B1%A1%E5%B0%81%E8%A3%85" rel="nofollow">综合案例：消息提示对象封装</a></p> 
<p id="9.%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D-toc" style="margin-left:40px;"><a href="#9.%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D" rel="nofollow">9.深浅拷贝</a></p> 
<p id="9.1%20%E6%B5%85%E6%8B%B7%E8%B4%9D-toc" style="margin-left:80px;"><a href="#9.1%20%E6%B5%85%E6%8B%B7%E8%B4%9D" rel="nofollow">9.1 浅拷贝</a></p> 
<p id="9.2%20%E6%B7%B1%E6%8B%B7%E8%B4%9D-toc" style="margin-left:80px;"><a href="#9.2%20%E6%B7%B1%E6%8B%B7%E8%B4%9D" rel="nofollow">9.2 深拷贝</a></p> 
<p id="10.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-toc" style="margin-left:40px;"><a href="#10.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" rel="nofollow">10.异常处理</a></p> 
<p id="10.1%20throw%20%E6%8A%9B%E5%BC%82%E5%B8%B8%C2%A0-toc" style="margin-left:80px;"><a href="#10.1%20throw%20%E6%8A%9B%E5%BC%82%E5%B8%B8%C2%A0" rel="nofollow">10.1 throw 抛异常 </a></p> 
<p id="10.2%20try%2Fcatch%20%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF-toc" style="margin-left:80px;"><a href="#10.2%20try%2Fcatch%20%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF" rel="nofollow">10.2 try/catch 捕获错误信息</a></p> 
<p id="10.3%20debugger-toc" style="margin-left:80px;"><a href="#10.3%20debugger" rel="nofollow">10.3 debugger</a></p> 
<p id="11.%20%E5%A4%84%E7%90%86this%C2%A0-toc" style="margin-left:40px;"><a href="#11.%20%E5%A4%84%E7%90%86this%C2%A0" rel="nofollow">11. 处理this </a></p> 
<p id="11.1%20this%E6%8C%87%E5%90%91-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#11.1%20this%E6%8C%87%E5%90%91-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0" rel="nofollow">11.1 this指向-普通函数</a></p> 
<p id="11.1%20this%E6%8C%87%E5%90%91-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#11.1%20this%E6%8C%87%E5%90%91-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0" rel="nofollow">11.1 this指向-箭头函数</a></p> 
<p id="11.2%20%E6%94%B9%E5%8F%98this-toc" style="margin-left:80px;"><a href="#11.2%20%E6%94%B9%E5%8F%98this" rel="nofollow">11.2 改变this</a></p> 
<p id="12.%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-toc" style="margin-left:40px;"><a href="#12.%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" rel="nofollow">12. 性能优化</a></p> 
<p id="12.1%20%E9%98%B2%E6%8A%96%EF%BC%88debounce%EF%BC%89-toc" style="margin-left:80px;"><a href="#12.1%20%E9%98%B2%E6%8A%96%EF%BC%88debounce%EF%BC%89" rel="nofollow">12.1 防抖（debounce）</a></p> 
<p id="12.2%20%E8%8A%82%E6%B5%81%EF%BC%88throttle%EF%BC%89-toc" style="margin-left:80px;"><a href="#12.2%20%E8%8A%82%E6%B5%81%EF%BC%88throttle%EF%BC%89" rel="nofollow">12.2 节流（throttle）</a></p> 
<p id="Lodash%20%E5%BA%93%20%E5%AE%9E%E7%8E%B0%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96-toc" style="margin-left:80px;"><a href="#Lodash%20%E5%BA%93%20%E5%AE%9E%E7%8E%B0%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96" rel="nofollow">Lodash 库 实现节流和防抖</a></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91-toc" style="margin-left:80px;"><a href="#%E2%80%8B%E7%BC%96%E8%BE%91" rel="nofollow">​编辑</a></p> 
<p id="%E8%8A%82%E6%B5%81%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E9%A1%B5%E9%9D%A2%E6%89%93%E5%BC%80%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AE%B0%E5%BD%95%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%9A%84%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E4%BD%8D%E7%BD%AE%C2%A0-toc" style="margin-left:40px;"><a href="#%E8%8A%82%E6%B5%81%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E9%A1%B5%E9%9D%A2%E6%89%93%E5%BC%80%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AE%B0%E5%BD%95%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%9A%84%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E4%BD%8D%E7%BD%AE%C2%A0" rel="nofollow">节流综合案例：页面打开，可以记录上一次的视频播放位置 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81JavaScript%E5%9F%BA%E7%A1%80" style="text-align:left;"><strong><strong><span style="color:#ad2a26;"><strong>一、JavaScript基础</strong></span></strong></strong></h2> 
<h3 id="1.JavaScript%E4%BB%8B%E7%BB%8D" style="text-align:left;"><strong><strong><span style="color:#ad2a26;"><strong>1.JavaScript介绍</strong></span></strong></strong></h3> 
<h4 id="1.1%20JavaScript%20%E6%98%AF%E4%BB%80%E4%B9%88%C2%A0" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>1.1 JavaScript 是什么</strong></span></strong><strong> </strong></h4> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">1. JavaScript （是什么？） </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#ad2a26;">是一种运行在客户端（浏览器）的编程语言，实现人机交互效果。</span> </p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">2. 作用（做什么？） </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">– 网页特效 (监听用户的一些行为让网页作出对应的反馈) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">– 表单验证 (针对表单数据的合法性进行判断) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">– 数据交互 (获取后台的数据, 渲染到前端) </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">– 服务端编程 (node.js)</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">3. JavaScript的组成（有什么？） </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#be191c;"><strong><strong>●</strong></strong></span><span style="color:#b60206;"><strong> </strong>ECMAScript: </span><span style="color:#262626;">规定了js基础语法核心知识。 </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">比如：变量、分支语句、循环语句、对象等等 </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#be191c;"><strong><strong>●</strong></strong></span><span style="color:#b60206;"><strong> </strong>Web APIs : </span></p> 
<ul><li style="text-align:left;"><span style="color:#262626;">DOM 操作文档，比如对页面元素进行移动、大小、添加删除等操作 </span></li><li style="text-align:left;"><span style="color:#262626;">BOM 操作浏览器，比如页面弹窗，检测窗口宽度、存储数据到浏览器等等 </span></li></ul> 
<h4 id="1.2%20JavaScript%20%E4%B9%A6%E5%86%99%E4%BD%8D%E7%BD%AE" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>1.2 JavaScript 书写位置</strong></span></strong></h4> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#404040;"><strong>1. 内部 JavaScript</strong></span></strong><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#404040;">直接写在html文件里，用script标签包住 </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#c00000;"><strong>规范</strong></span></strong><span style="color:#404040;">：script标签写在&lt;/body&gt;上面 </span></p> 
<div> 
 <pre><code class="language-javascript">&lt;body&gt;
    &lt;!-- 内部 --&gt;
    &lt;script&gt;
        alert('努力，奋斗');
    &lt;/script&gt;
&lt;/body&gt;</code></pre> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><strong>注意事项</strong></strong>：</p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">将&lt;script&gt;放在</span><span style="color:#c00000;">HTML文件的底部</span><span style="color:#000000;">附近的原因是浏览器会按照代码在文件中的</span><span style="color:#c00000;">顺序加载</span><span style="color:#000000;">HTML。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">如果先加载的JavaScript期望修改其下方 HTML，那么它可能由于HTML尚未被加载而失效。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">因此，将JavaScript代码放在HTM页面的底部附近通常是最好的策略。</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#404040;"><strong>2. 外部 JavaScript </strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#404040;">代码写在以.js结尾的文件里 </span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#c00000;"><strong>语法</strong></span></strong><span style="color:#404040;">：通过script标签，引入到html页面中。</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="131" src="https://images2.imgbox.com/64/e4/BkGiSAY4_o.png" width="224"></p> 
 <pre><code class="language-javascript">&lt;body&gt;
    &lt;!-- 外部 --&gt;
    &lt;script src="./js/my.js"&gt;&lt;/script&gt;
&lt;/body&gt;</code></pre> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong><strong>注意事项</strong></strong>：</p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#c00000;">1. script标签中间无需写代码，否则会被忽略！ </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#000000;">2. 外部JavaScript会使代码更加有序，更易于复用，且没有了脚本的混合，HTML也会更加易读，因此这是个好的习惯。</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#404040;"><strong>3. 内联 JavaScript </strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#404040;">代码写在标签内部 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#c00000;"><strong>语法：</strong></span></strong></p> 
 <pre><code class="language-javascript">&lt;body&gt;
    &lt;button onclick="alert('努力，奋斗')"&gt;点击&lt;/button&gt;
&lt;/body&gt;</code></pre> 
 <h4 id="1.3%20JavaScript%20%E6%B3%A8%E9%87%8A%C2%A0" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>1.3 JavaScript 注释</strong></span></strong> </h4> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#be191c;">● 单行注释（//）</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>作用：</strong></span></strong><span style="color:#262626;">//右边这一行的代码会被忽略 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>快捷键：</strong></span></strong><span style="color:#262626;">ctrl + / </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#be191c;">● 块注释（/* */）</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>作用：</strong></span></strong><span style="color:#262626;">在/* 和 */ 之间的所有内容都会被忽略 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;"> </span><strong><span style="color:#262626;"><strong>快捷键：</strong></span></strong><span style="color:#262626;">shift + alt + A</span></p> 
 <h4 id="1.4%20JavaScript%20%E7%BB%93%E6%9D%9F%E7%AC%A6" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>1.4 JavaScript 结束符</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">● 结束符 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>作用： </strong></span></strong><span style="color:#262626;">使用英文的 ; 代表语句结束 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>实际情况： </strong></span></strong><span style="color:#262626;">实际开发中，</span><strong><span style="color:#ad2a26;"><strong>可写可不写</strong></span></strong><span style="color:#262626;">, 浏览器(JavaScript引擎)可以自动推断语句的结束位置 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>现状： </strong></span></strong><span style="color:#262626;">在实际开发中，越来越多的人主张，书写JavaScript代码时省略结束符 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#c00000;"><strong>约定：</strong></span></strong><span style="color:#c00000;">为了风格统一，结束符要么每句都写，要么每句都不写（按照团队要求）</span></p> 
 <h4 id="1.5%20JavaScript%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AF%AD%E6%B3%95" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>1.5 JavaScript 输入输出语法</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">输出和输入也可理解为人和计算机的交互，用户通过键盘、鼠标等向计算机输入信息，计算机处理后再展示结果给用户，这便是一次输入和输出的过程。</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>1.输出语法：</strong></span></strong> </p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#c00000;"><strong>语法1：</strong></span></strong><img alt="" height="36" src="https://images2.imgbox.com/11/7e/wVHuQvQc_o.png" width="423"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>作用：</strong></span></strong><span style="color:#262626;">向body内输出内容 </span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#262626;"><strong>注意：</strong></span></strong><span style="color:#262626;">如果输出的内容写的是标签，也会被解析成网页元素，如：</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="34" src="https://images2.imgbox.com/e1/dd/H0BsJBxu_o.png" width="525"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="60" src="https://images2.imgbox.com/f3/1c/L2N5axun_o.png" width="439"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#c00000;"><strong>语法2：</strong></span></strong><img alt="" height="29" src="https://images2.imgbox.com/98/a0/XGd9WxBl_o.png" width="194"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>作用：</strong></span></strong><span style="color:#262626;">页面弹出警告对话框 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#c00000;"><strong>语法3： </strong></span></strong><img alt="" height="35" src="https://images2.imgbox.com/7f/0b/79MIpDjh_o.png" width="321"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>作用：</strong></span></strong><span style="color:#262626;">控制台输出语法，程序员调试使用</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>2. 输入语法：</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#c00000;"><strong>语法： </strong></span></strong><img alt="" height="34" src="https://images2.imgbox.com/78/3a/kvgBTlEM_o.png" width="435"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>作用：</strong></span></strong><span style="color:#262626;">显示一个对话框，对话框中包含一条文字信息，用来提示用户输入文字</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>3.JavaScript 代码执行顺序： </strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#c00000;">按HTML文档流顺序执行JavaScript代码 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">alert() 和 prompt() 它们会跳过页面渲染先被执行</span></p> 
 <h4 id="1.6%20%E5%AD%97%E9%9D%A2%E9%87%8F" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>1.6 字面量</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">在计算机科学中，字面量（literal）是在计算机中描述 事/物 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">比如： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">我们工资是： 8000 此时8000就是数字字面量；'黑马程序员' 字符串字面量；还有接下来学的 [] 数组字面量 {} 对象字面量 等等</span></p> 
 <h3 id="2.%E5%8F%98%E9%87%8F"><span style="color:#be191c;">2.</span><strong><strong><span style="color:#ad2a26;"><strong>变量</strong></span></strong></strong></h3> 
 <h4 id="2.1%20%E5%8F%98%E9%87%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>2.1 变量是什么？</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>变量： </strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>● </strong></span></strong><span style="color:#262626;">白话：变量就是一个装东西的盒子。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>● </strong></span></strong><span style="color:#262626;">通俗：变量是计算机中用来</span><strong><span style="color:#262626;"><strong>存储数据</strong></span></strong><span style="color:#262626;">的“</span><span style="color:#c00000;">容器</span><span style="color:#262626;">”，它可以让计算机变得有记忆。</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>● </strong></span></strong><span style="color:#262626;">注意：</span><span style="color:#c00000;">变量不是数据本身，它们仅仅是一个用于存储数值的容器。可以理解为是一个个用来装东西的纸箱子。</span></p> 
 <h4 id="2.2%20%E5%8F%98%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>2.2 变量的基本使用</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>1. 声明变量：</strong></span></strong><strong> </strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">要想使用变量，首先需要创建变量（也称为声明变量或者定义变量） </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>语法：</strong></span></strong><img alt="" height="34" src="https://images2.imgbox.com/38/32/VohY4uOW_o.png" width="115"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">声明变量有两部分构成：声明关键字、变量名（标识） </span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#262626;">let 即关键字 (let: 允许、许可、让)，所谓关键字是系统提供的专门用来声明（定义）变量的词语</span></p> 
 <p> <strong><span style="color:#262626;"><strong>举例：let age</strong></span></strong></p> 
 <p><span style="color:#262626;">我们声明了一个age变量，age 即变量的名称，也叫标识符</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>2. 变量赋值：</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">定义了一个变量后，就能够初始化它（赋值）。在变量名之后跟上一个“=”，然后是数值。</span><img alt="" height="147" src="https://images2.imgbox.com/c9/7d/169tv0TZ_o.png" width="311"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">注意：是通过</span><span style="color:#c00000;">变量名</span><span style="color:#262626;">来获得变量里面的数据</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#262626;">简单点，也可以声明变量的时候直接完成赋值操作,这种操作也称为 变量</span><strong><span style="color:#c00000;"><strong>初始化</strong></span></strong><span style="color:#262626;">。</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="58" src="https://images2.imgbox.com/a6/f1/RoGxUl3E_o.png" width="418"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>3. 更新变量：</strong></span></strong><strong> </strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#262626;">变量赋值后，还可以通过简单地给它一个不同的值来更新它。</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="116" src="https://images2.imgbox.com/ca/c8/3yqNt2yC_o.png" width="415"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#262626;">注意： </span><strong><span style="color:#c00000;"><strong>let 不允许多次声明一个变量</strong></span></strong><span style="color:#262626;">。</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>4. 声明多个变量：</strong></span></strong><strong> </strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">变量赋值后，还可以通过简单地给它一个不同的值来更新它。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>语法：</strong></span></strong><span style="color:#262626;">多个变量中间用逗号隔开。</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><img alt="" height="86" src="https://images2.imgbox.com/e7/b1/mJOCuCTU_o.png" width="369"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#262626;"><strong>说明：</strong></span></strong><span style="color:#262626;">看上去代码长度更短，但并</span><strong><span style="color:#c00000;"><strong>不推荐</strong></span></strong><span style="color:#262626;">这样。为了更好的可读性，请一行只声明一个变量。</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="113" src="https://images2.imgbox.com/51/e1/cyEVS8uj_o.png" width="290"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#c00000;"><strong>变量案例：交换变量的值</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#262626;">核心思路：使用一个临时变量temp用来做中间存储。</span></p> 
 <pre><code class="language-javascript">&lt;body&gt;
  &lt;script&gt;
    let num1 = 'pink老师'
    let num2 = '周深'
    let temp
    // 都是把右边给左边
    temp = num1
    num1 = num2
    num2 = temp
    console.log(num1, num2)
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
 <h4 id="2.3%20%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>2.3 变量的本质</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>内存：</strong></span></strong><span style="color:#262626;">计算机中存储数据的地方，相当于一个空间 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>变量本质：</strong></span></strong><span style="color:#262626;">是程序在内存中申请的一块用来存放数据的小空间</span></p> 
 <h4 id="2.4%20%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E4%B8%8E%E8%A7%84%E8%8C%83" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>2.4 变量命名规则与规范</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>规则：</strong></span></strong><span style="color:#262626;">必须遵守，不遵守报错 (法律层面) </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>规范：</strong></span></strong><span style="color:#262626;">建议，不遵守不会报错，但不符合业内通识 （道德层面） </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#c00000;"><strong>1. 规则： </strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">不能用关键字。关键字：有特殊含义的字符，JavaScript内置的一些英语词汇。例如：let、var、if、for等 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">只能用下划线、字母、数字、$组成，且</span><strong><span style="color:#c00000;"><strong>数字不能开头</strong></span></strong> </p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">字母严格</span><span style="color:#c00000;">区分大小写</span><span style="color:#262626;">，如Age和age是不同的变量 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#c00000;"><strong>2. 规范： </strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">起名要有意义 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">遵守小驼峰命名法 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">第一个单词首字母小写，后面每个单词首字母大写。例：userName、myFirstName</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><img alt="" height="222" src="https://images2.imgbox.com/15/18/IsyNMGqM_o.png" width="314"></p> 
 <h4 id="2.5%E5%8F%98%E9%87%8F%E6%8B%93%E5%B1%95-let%E5%92%8Cvar%E7%9A%84%E5%8C%BA%E5%88%AB" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>2.5变量拓展-let和var的区别</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>let 和 var 区别： </strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">在较旧的JavaScript，使用关键字 var 来声明变量 ，而不是 let。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">var 现在开发中一般不再使用它，只是我们可能再老版程序中看到它。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">let 为了解决 var 的一些问题。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">var 声明: </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">○ 可以先使用 在声明 (不合理) </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">○ var 声明过的变量可以重复声明(不合理) </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">○ 比如变量提升、全局变量、没有块级作用域等等</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>结论：</strong></span></strong><span style="color:#c00000;">以后声明变量统一使用 let</span></p> 
 <h4 id="2.6%E5%8F%98%E9%87%8F%E6%8B%93%E5%B1%95-%E6%95%B0%E7%BB%84" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>2.6变量拓展-数组</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">● </span><span style="color:#404040;">数组 (Array)</span> <span style="color:#262626;">—— 一种将</span><strong><span style="color:#262626;"><strong>一组数据存储在单个变量名下</strong></span></strong><span style="color:#262626;">的优雅方式</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><img alt="" height="206" src="https://images2.imgbox.com/f5/80/JC3pYf3Y_o.png" width="410"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>2.6.1 数组的基本使用</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>1. 声明语法：let 数组名 = [数据1, 数据2, ..., 数据n]</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">○ </span><span style="color:#404040;">数组是按顺序保存，所以每个数据都有自己的编号 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">○ </span><span style="color:#404040;">计算机中的编号从0开始，第二个数据编号为1，以此类推 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">○ </span><span style="color:#404040;">在数组中，数据的编号也叫</span><strong><span style="color:#c00000;"><strong>索引或下标 </strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">○ </span><span style="color:#404040;">数组可以存储任意类型的数据</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#262626;"><strong>2.取值语法：数组名[下标]</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#404040;">通过下标取数据。取出来是什么类型的，就根据这种类型特点来访问。</span></p> 
 <p style="text-align:left;"><strong><span style="color:#262626;"><strong>3.一些术语：</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">● </span><strong><span style="color:#404040;"><strong>元素：</strong></span></strong><span style="color:#404040;">数组中保存的每个数据都叫数组元素 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">● </span><strong><span style="color:#404040;"><strong>下标：</strong></span></strong><span style="color:#404040;">数组中数据的编号 </span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#262626;">● </span><strong><span style="color:#404040;"><strong>长度：</strong></span></strong><span style="color:#404040;">数组中数据的个数，通过数组的</span><span style="color:#404040;">length</span><span style="color:#404040;">属性获得</span></p> 
 <pre><code class="language-javascript">let arr = ['刘德华', '张学友', '黎明', '郭富城', 'pink老师', 10]
console.log(arr.length)  // 6</code></pre> 
 <h3 id="3.%E5%B8%B8%E9%87%8F" style="text-align:left;"><strong><strong><span style="color:#ad2a26;"><strong>3.常量</strong></span></strong></strong></h3> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>概念：</strong></span></strong><span style="color:#262626;">使用 const 声明的变量称为“常量”。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>使用场景：</strong></span></strong><span style="color:#262626;">当某个变量永远</span><strong><span style="color:#262626;"><strong>不会改变</strong></span></strong><span style="color:#262626;">的时候，就可以使用 const 来声明，而不是let。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>命名规范：</strong></span></strong><span style="color:#262626;">和变量一致 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>常量使用：</strong></span></strong></p> 
 <pre><code class="language-javascript">// 1.常量 不允许更改值
    const PI = 3.14
    console.log(PI)</code></pre> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>注意： </strong></span></strong><span style="color:#c00000;">常量不允许重新赋值,声明的时候必须赋值（初始化） </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>小技巧：</strong></span></strong><span style="color:#c00000;">不需要重新赋值的数据使用const</span><strong> </strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#c00000;">const — 类似于 let ，但是变量的值无法被修改。</span></p> 
 <h3 id="4.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" style="text-align:justify;"><strong><span style="color:#ad2a26;"><strong>4.数据类型</strong></span></strong></h3> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>JS 数据类型整体分为两大类： </strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">● 基本数据类型 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">● 引用数据类型</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><img alt="" height="326" src="https://images2.imgbox.com/96/13/mbZxrOFB_o.png" width="830"></p> 
 <h4 id="4.1%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E2%80%93%20%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%EF%BC%88Number%EF%BC%89" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>4.1 数据类型 – 数字类型（Number） </strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">即我们数学中学习到的数字，可以是整数、小数、正数、负数。</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><img alt="" height="87" src="https://images2.imgbox.com/a3/11/ltd911V7_o.png" width="414"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">JavaScript 中的正数、负数、小数等 统一称为 数字类型。</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>注意事项：</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#ad2b26;">JS是弱数据类型，变量属于哪种类型，只有赋值之后我们才能确认 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#ad2b26;">Java是强数据类型 例如 int a = 3 必须是整数</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">数字可以有很多操作，比如，乘法 * 、除法 / 、加法 + 、减法 - 等等，所以经常和算术运算符一起。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">数学运算符也叫</span><strong><span style="color:#262626;"><strong>算术运算符</strong></span></strong><span style="color:#262626;">，主要包括加、减、乘、除、取余（求模）。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">➱ +：求和 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">➱ -：求差 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">➱ *：求积 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">➱ /：求商 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">➱ %：取模（取余数），开发中经常作为某个数字是否被整除 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">同时使用多个运算符编写程序时，会按着某种顺序先后执行，我们称为优先级。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">JavaScript</span><span style="color:#262626;">中优先级越高越先被执行，</span><span style="color:#c00000;">优先级相同时以书从左向右执行</span><span style="color:#262626;">。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">● 总结： </span><span style="color:#c00000;">先乘除取余，后加减，有小括号先算小括号里面的</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">NaN 代表一个计算错误。它是一个不正确的或者一个未定义的数学操作所得到的结果。</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><img alt="" height="40" src="https://images2.imgbox.com/22/2e/TQwoOE8G_o.png" width="491"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">NaN 是粘性的。任何对 NaN 的操作都会返回 NaN</span></p> 
 <h4 id="4.2%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E2%80%93%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%EF%BC%88string%EF%BC%89" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>4.2 数据类型 – 字符串类型（</strong></span></strong><strong><span style="color:#ad2a26;"><strong>string）</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#c00000;">通过单引号（ ''） 、双引号（ ""）或反引号( ` ) 包裹的数据都叫字符串</span><span style="color:#262626;">，单引号和双引号没有本质上的区别，推荐使用</span><span style="color:#c00000;">单引号</span><span style="color:#262626;">。</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>注意事项： </strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">1. 无论单引号或是双引号必须成对使用 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">2. 单引号/双引号可以互相嵌套，但是不以自已嵌套自已（</span><span style="color:#c00000;">口诀：外双内单，或者外单内双</span><span style="color:#262626;">） </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">3. 必要时可以使用转义符 \，输出单引号或双引号</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>字符串拼接</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>场景</strong></span></strong><span style="color:#262626;">： + 运算符 可以实现字符串的拼接。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#be191c;"><strong>口诀：数字相加，字符相连</strong></span></p> 
 <pre><code class="language-javascript">    let age = 25
    document.write('我今年' + age + '岁了')</code></pre> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>模板字符串 </strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>使用场景：</strong></span></strong><span style="color:#262626;">拼接字符串和变量 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">在没有它之前，要拼接变量比较麻烦</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><img alt="" height="31" src="https://images2.imgbox.com/f3/bc/MujoNGvz_o.png" width="457"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>语法：</strong></span></strong><span style="color:#c00000;">`` (反引号) </span><span style="color:#262626;">在英文输入模式下按键盘的tab键上方那个键（1左边那个键）。内容拼接变量时，用 </span><span style="color:#c00000;">${ } 包住变量</span></p> 
 <pre><code class="language-javascript">  &lt;script&gt;
    // // 模板字符串 外面用`` 里面 ${变量名}
    let uname = prompt('请输入您的姓名:')
    let age = prompt('请输入您的年龄:')
    document.write(`大家好，我叫${uname}， 我今年贵庚${age}岁了`)
  &lt;/script&gt;</code></pre> 
 <h4 id="4.3%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E2%80%93%20%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%EF%BC%88boolean%EF%BC%89" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>4.3数据类型 – 布尔类型（boolean）</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">表示肯定或否定时在计算机中对应的是布尔类型数据。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">它有两个固定的值true和false，表示肯定的数据用true（真），表示否定的数据用false（假）。</span></p> 
 <h4 id="4.4%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E2%80%93%20%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%EF%BC%88undefined%EF%BC%89" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>4.4数据类型 – 未定义类型（undefined）</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">未定义是比较特殊的类型，只有一个值undefined。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>什么情况出现未定义类型？ </strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#c00000;">只声明变量，不赋值的情况下，变量的默认值为undefined</span><span style="color:#262626;">，一般很少直接为某个变量赋值为undefined。</span></p> 
 <pre><code class="language-javascript">    // 未定义类型   弱数据类型   声明一个变量未赋值就是 undefined
    let num
    console.log(num)</code></pre> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>工作中的使用场景： </strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">我们开发中经常声明一个变量，等待传送过来的数据。如果我们不知道这个数据是否传递过来，此时我们</span><span style="color:#c00000;">可以通过检测这个变量是不是undefined，就判断用户是否有数据传递过来</span><span style="color:#262626;">。 </span></p> 
 <h4 id="4.5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%20%E2%80%93%20null%EF%BC%88%E7%A9%BA%E7%B1%BB%E5%9E%8B%EF%BC%89" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>4.5数据类型 – null（空类型）</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#262626;">JavaScript 中的 null 仅仅是一个代表“无”、“空”或“值未知”的特殊值</span></p> 
 <pre><code class="language-javascript">    //  null 空的
    let obj = null
    console.log(obj)</code></pre> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>null 和 undefined 区别： </strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">● undefined 表示没有赋值 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">● null 表示赋值了，但是内容为空 </span></p> 
 <pre><code class="language-javascript">    // 计算有区别
    console.log(undefined + 1)  // NaN
    console.log(null + 1) // 1</code></pre> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>null 开发中的使用场景： </strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">官方解释：把null作为尚未创建的对象 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">通俗解释：</span><span style="color:#c00000;">将来有个变量里面存放的是一个对象，但是对象还没创建好，可以先给个null</span></p> 
 <h4 id="4.6%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>4.6控制台输出语句和检测数据类型</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>1.控制台输出语句：</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">控制台语句经常用于测试结果来使用。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">数字型和布尔型颜色为蓝色，字符串和undefined颜色为灰色</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>2. </strong></span></strong><strong><span style="color:#c00000;"><strong>通过 typeof </strong></span></strong><strong><span style="color:#262626;"><strong>关键字检测数据类型</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">typeof 运算符可以返回被检测的数据类型。它支持两种语法形式： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#404040;">1. </span><span style="color:#262626;">作为运算符： </span><span style="color:#c00000;">typeof x </span><span style="color:#262626;">（常用的写法） </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#404040;">2. </span><span style="color:#262626;">函数形式： typeof(x) </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">换言之，有括号和没有括号，得到的结果是一样的，所以我们直接使用</span><span style="color:#c00000;">运算符</span><span style="color:#262626;">的写法。</span></p> 
 <p> <img alt="" height="350" src="https://images2.imgbox.com/6a/30/fSppgX4l_o.png" width="312"><img alt="" height="270" src="https://images2.imgbox.com/7c/a5/6Eq2Fo9A_o.png" width="337"></p> 
 <h3 id="%C2%A05.%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><strong> <span style="color:#ad2a26;">5.类型转换</span></strong></h3> 
 <h4 id="5.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>5.1 为什么需要类型转换</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">JavaScript是弱数据类型： JavaScript也不知道变量到底属于那种数据类型，只有赋值了才清楚。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">坑：</span><span style="color:#c00000;">使用表单、prompt 获取过来的数据默认是字符串类型的</span><span style="color:#262626;">，此时不能直接进行加法运算。</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">此时需要转换变量的数据类型。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">通俗来说，就是</span><span style="color:#c00000;">把一种数据类型的变量转换成我们需要的数据类型</span><span style="color:#262626;">。</span></p> 
 <h4 id="5.2%20%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>5.2 隐式转换</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>规则：</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#c00000;">1. + 号两边只要有一个是字符串，都会把另外一个转成字符串 </span></p> 
 <pre><code class="language-javascript">    console.log('pink' + 1) // pink1
    console.log(2 + 2)   // 4
    console.log(2 + '2') // 22</code></pre> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#c00000;">2. 除了+以外</span><span style="color:#262626;">的算术运算符 比如 </span><span style="color:#c00000;">- * / </span><span style="color:#262626;">等</span><span style="color:#c00000;">都会把数据转成数字类型</span></p> 
 <pre><code class="language-javascript">    console.log(2 - 2)    // 0
    console.log(2 - '2')  // 0 </code></pre> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>缺点： </strong></span></strong><span style="color:#262626;">转换类型不明确，靠经验才能总结 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>小技巧： </strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#c00000;">1. +号作为正号解析可以转换成数字型 </span></p> 
 <pre><code class="language-javascript">console.log(+'123')  // 转换为数字型 123</code></pre> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#c00000;">2.任何数据和字符串相加结果都是字符串</span></p> 
 <h4 id="5.3%20%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>5.3 显式转换</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">编写程序时过度依靠系统内部的隐式转换是不严禁的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>概念： </strong></span></strong><span style="color:#262626;">自己写代码告诉系统该转成什么类型 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>转换为数字型有三种方法：</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#be191c;"><strong>●</strong></span><span style="color:#262626;"><strong> </strong></span></strong><span style="color:#c00000;">Number(数据) </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">        转成数字类型 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">        如果字符串内容里有非数字，转换失败时结果为NaN（Not a Number）即不是一个数字 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">        NaN也是number类型的数据，代表非数字 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#be191c;"><strong>●</strong></span><span style="color:#262626;"><strong> </strong></span></strong><span style="color:#c00000;">parseInt(数据) 只保留整数 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#be191c;"><strong>●</strong></span><span style="color:#262626;"><strong> </strong></span></strong><span style="color:#c00000;">parseFloat(数据) 可以保留小数</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>转换为字符型: </strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#be191c;"><strong>●</strong></span><span style="color:#262626;"><strong> </strong></span></strong><span style="color:#c00000;">String(数据) </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#be191c;"><strong>●</strong></span><span style="color:#262626;"><strong> </strong></span></strong><span style="color:#c00000;">变量.toString(进制)</span></p> 
 <h3 id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E7%94%A8%E6%88%B7%E8%AE%A2%E5%8D%95%E4%BF%A1%E6%81%AF%E6%A1%88%E4%BE%8B" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>综合案例：用户订单信息案例</strong></span></strong></h3> 
 <p><img alt="" height="181" src="https://images2.imgbox.com/d4/bb/8YdX3XTR_o.png" width="830"></p> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        h2 {
            text-align: center;
        }
        table,
        th,
        td {
            border: 1px solid #000;
        }
        table {
            /* 合并相邻边框 */
            border-collapse: collapse;
            text-align: center;
            height: 80px;
            margin: 0 auto;
        }
        th {
            padding: 10px 30px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h2&gt;订单确认&lt;/h2&gt;
    &lt;script&gt;
        let price = +prompt('请输入商品价格：')
        let num = +prompt('请输入商品数量：')
        let address = prompt('请输入收货地址：')
        let total = price * num
        document.write(`
        &lt;table&gt;
            &lt;thead&gt;
                &lt;th&gt;商品名称&lt;/th&gt;
                &lt;th&gt;商品价格&lt;/th&gt;
                &lt;th&gt;商品数量&lt;/th&gt;
                &lt;th&gt;总价&lt;/th&gt;
                &lt;th&gt;收货地址&lt;/th&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td&gt;小米手机青春PLUS&lt;/td&gt;
                    &lt;td&gt;${price}元&lt;/td&gt;
                    &lt;td&gt;${num}&lt;/td&gt;
                    &lt;td&gt;${total}元&lt;/td&gt;
                    &lt;td&gt;${address}&lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
        `)
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
 <h3 id="%C2%A06.%E8%BF%90%E7%AE%97%E7%AC%A6"><strong><span style="color:#ad2a26;"><strong> 6.运算符</strong></span></strong></h3> 
 <h4 id="6.1%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>6.1 赋值运算符</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">赋值运算符</span><span style="color:#262626;">（</span><span style="color:#404040;">=</span><span style="color:#262626;">）</span><span style="color:#262626;">：对变量进行赋值的运算符 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#be191c;">=</span><span style="color:#404040;"> </span><span style="color:#c00000;">将等号右边的值赋予给左边, 要求左边必须是一个容器 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#404040;">其他赋值运算符：</span> <span style="color:#c00000;">+= </span><span style="color:#404040;">、-= 、*= 、/= 、%= </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">使用这些运算符可以在对变量赋值时进行快速操作</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><img alt="" height="167" src="https://images2.imgbox.com/55/f0/nfbrKEgK_o.png" width="485"></p> 
 <h4 id="6.2%20%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>6.2 一元运算符</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">众多的JavaScript的运算符可以根据所需表达式的个数，分为一元运算符、二元运算符、三元运算符。</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;"><strong>●</strong> <strong>自增（++）</strong></span><strong> </strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#404040;">作用：让变量的值</span> <span style="color:#c00000;">+1 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;">● 自减（--）</span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#404040;">作用：让变量的值</span> <span style="color:#c00000;">-1 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">● </span><strong><span style="color:#262626;"><strong>使用场景：</strong></span></strong><span style="color:#000000;">经常用于</span><span style="color:#c00000;">计数</span><span style="color:#000000;">来使用。 比如进</span><span style="color:#000000;">行10</span><span style="color:#000000;">次操作，用它来计算进行了多少次了</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">● </span><strong><span style="color:#262626;"><strong>自增运算符的用法：</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"> <strong><span style="color:#c00000;"><strong>前置自增：</strong></span>                                                        </strong><strong><span style="color:#c00000;"><strong>后置自增：</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><img alt="" height="55" src="https://images2.imgbox.com/26/76/0lLc3YkE_o.png" width="328"><img alt="" height="53" src="https://images2.imgbox.com/52/06/ZdqVxTlq_o.png" width="338"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">前置自增和后置自增的</span><strong><strong>区别</strong></strong>：</p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">前置自增：先自加再使用（记忆口诀：++在前</span><span style="color:#404040;"> </span><span style="color:#c00000;">先加</span><span style="color:#0d0016;">）</span></p> 
 <p> <img alt="" height="81" src="https://images2.imgbox.com/5d/c9/AFg7CH9s_o.png" width="500"></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#404040;">后置自增：先使用再自加（记忆口诀：</span><span style="color:#404040;">++</span><span style="color:#404040;">在后 </span><span style="color:#c00000;">后加</span><span style="color:#404040;">）</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="76" src="https://images2.imgbox.com/61/1a/LWSgiSlK_o.png" width="477"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#404040;"><strong>注意：</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#404040;">1. 前置自增和后置自增独立使用时二者并没有差别！ </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#c00000;">2. </span><span style="color:#c00000;">实际开发中，我们一般都是单独使用的，</span><span style="color:#c00000;">后置自增会使用相对较多</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;">拓展：</p> 
 <p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="89" src="https://images2.imgbox.com/2d/97/ftOVeH1j_o.png" width="426"></p> 
 <p style="margin-left:.0001pt;text-align:justify;">输出7</p> 
 <h4 id="6.3%20%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>6.3 比较运算符</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">使用场景：比较两个数据大小、是否相等</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">&gt;： 左边是否大于右边 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">&lt;： 左边是否小于右边 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">&gt;=： 左边是否大于或等于右边 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">&lt;=： 左边是否小于或等于右边 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#c00000;">==： 左右两边</span><strong><span style="color:#c00000;"><strong>值</strong></span></strong><span style="color:#c00000;">是否相等 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#c00000;">===： 左右两边是否</span><strong><span style="color:#c00000;"><strong>类型</strong></span></strong><span style="color:#c00000;">和</span><strong><span style="color:#c00000;"><strong>值</strong></span></strong><span style="color:#c00000;">都相等 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">!==： 左右两边是否不全等 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">比较运算符有隐式转换。</span><span style="color:#262626;">比较结果为boolean类型，即只会得到true或false。</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>= 和 == 和 === 对比</strong></span></strong><span style="color:#262626;">： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;">● </span></strong><span style="color:#262626;">= 单等是赋值 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;">● </span></strong><span style="color:#262626;">== 是判断 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;">● </span></strong><span style="color:#262626;">=== 是全等 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#c00000;"><strong>开发中判断是否相等，强烈推荐使用 === </strong></span></strong></p> 
 <p></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;">● </span></strong><span style="color:#262626;">字符串比较，是比较的字符对应的ASCII码 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">        从左往右依次比较，如果第一位一样再比较第二位，以此类推</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;">● </span></strong><span style="color:#262626;">NaN不等于任何值，包括它本身，涉及到NaN都是false </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;">● </span></strong><span style="color:#262626;">尽量不要比较小数，因为小数有精度问题</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;">● </span></strong><span style="color:#262626;">不同类型之间比较会发生隐式转换 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">        最终把数据隐式转换转成number类型再比较 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">        所以开发中，如果进行准确的比较我们</span><span style="color:#c00000;">更喜欢 === </span><span style="color:#262626;">或者 </span><span style="color:#c00000;">!==</span></p> 
 <h4 id="6.4%20%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>6.4 逻辑运算符</strong></span></strong></h4> 
 <p><img alt="" height="201" src="https://images2.imgbox.com/75/67/UvKs0ug5_o.png" width="831"></p> 
 <p><span style="color:#0d0016;">表达式1 &amp;&amp; 表达式2：表达式1为真，返回表达式2；表达式1为假，返回表达式1</span></p> 
 <p><span style="color:#0d0016;">表达式1  ||  表达式2：表达式1为真，返回表达式1；表达式1为假，返回表达式2</span></p> 
 <h4 id="%C2%A06.5%20%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"> <strong><span style="color:#ad2a26;"><strong>6.5 运算符优先级</strong></span></strong></h4> 
 <p><img alt="" height="377" src="https://images2.imgbox.com/e4/a0/iQ841ptB_o.png" width="829"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">一元运算符里面的</span><span style="color:#c00000;">逻辑非优先级很高。逻辑与比逻辑或优先级高。</span></p> 
 <h3 id="7.%E8%AF%AD%E5%8F%A5" style="text-align:justify;"><strong><span style="color:#ad2a26;"><strong>7.语句</strong></span></strong></h3> 
 <h4 id="7.1%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E5%8F%A5" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>7.1 表达式语句</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;">● </span></strong><span style="color:#262626;">表达式：</span><span style="color:#c00000;">表达式是可以被求值的代码，JavaScript 引擎会将其计算出一个结果</span><span style="color:#262626;">。</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;">● </span></strong><span style="color:#262626;">语句：</span><span style="color:#c00000;">语句是一段可以执行的代码</span><span style="color:#262626;">。</span><span style="color:#262626;">比如：prompt()可以弹出一个输入框，还有if语句、for循环语句等等</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>区别：</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#c00000;"><strong>表达式：</strong></span></strong><span style="color:#c00000;">因为表达式可被求值，所以它可以写在赋值语句的右侧。</span><span style="color:#000000;">如：num = 3 + 4 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#c00000;"><strong>语句：</strong></span></strong><span style="color:#c00000;">而语句不一定有值，所</span><span style="color:#c00000;">以比如alert()、for和break等</span><span style="color:#c00000;">语句就不能被用于赋值。 </span></p> 
 <h4 id="7.2%20%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%EF%BC%88%20if%E8%AF%AD%E5%8F%A5%E3%80%81%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81switch%E8%AF%AD%E5%8F%A5%20%EF%BC%89" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>7.2 分支语句（ if语句、三元运算符、switch语句 ）</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#ad2a26;">程序三大流程控制语句</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;">● </span></strong><span style="color:#262626;">以前我们写的代码，写几句就从上往下执行几句，这种叫<strong>顺序结构 </strong></span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;">● </span></strong><span style="color:#262626;">有的时候要根据条件选择执行代码，这种就叫<strong>分支结构 </strong></span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;">● </span></strong><span style="color:#262626;">某段代码被重复执行，就叫<strong>循环结构</strong></span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><img alt="" height="316" src="https://images2.imgbox.com/a6/51/nteexojf_o.png" width="830"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;">● </span></strong><span style="color:#262626;">分支语句可以让我们有</span><span style="color:#c00000;">选择性</span><span style="color:#262626;">的执行想要的代码 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;">● </span></strong><span style="color:#262626;">分支语句包含：</span><span style="color:#c00000;">if分支语句、</span><span style="color:#000000;">三元运算符、switch语句</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>7.2.1 if语句 </strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">if语句有三种使用：单分支、双分支、多分支 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;">● </span></strong><span style="color:#262626;">单分支 if 语法：</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><img alt="" height="114" src="https://images2.imgbox.com/27/46/mAuAdg9A_o.png" width="370"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#404040;">        括号内的条件为true</span><span style="color:#404040;">时，进入大括号里执行代码</span><span style="color:#404040;">；</span><span style="color:#404040;">小括号内的结果若不是布尔类型时，会发生隐式转换转为布尔类型</span><span style="color:#404040;">。</span><span style="color:#c00000;">除了0 所有的数字都为真，除了''所有的字符串都为真true</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#404040;">        如果大括号只有一个语句，大括号可以省略，但是不提倡这么做</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;">● </span></strong><span style="color:#262626;">双分支 if 语法：</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><img alt="" height="302" src="https://images2.imgbox.com/a2/45/ZjwNSMAk_o.png" width="382"></p> 
 <p><strong><span style="color:#262626;">● </span></strong><span style="color:#262626;">多分支 if 语法：</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>使用场景：</strong></span></strong><span style="color:#262626;">适合于有多个结果的时候，比如学习成绩可以分为： 优 良 中 差</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><img alt="" height="383" src="https://images2.imgbox.com/e3/ca/Rk5BYjCm_o.png" width="321"></p> 
 <p>先判断条件1，若满足条件1就执行代码1，其他不执行；若不满足则向下判断条件2，满足条件2执行代码2，其他不执行；若依然不满足继续往下判断，依次类推；若以上条件都不满足，执行else里的代码n </p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>7.2.2 三元运算符</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>使用场景： </strong></span></strong><span style="color:#262626;">其实是比if双分支更简单的写法，可以使用 三元表达式，一般用来取值</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>符号：</strong></span></strong><span style="color:#262626;">? 与 : 配合使用 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>语法：</strong></span></strong><img alt="" height="54" src="https://images2.imgbox.com/09/d1/ygYvoVyk_o.png" width="689"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2b26;">数字补0案例</span></strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#404040;">用户输入1个数，如果数字小于10，则前面进行补0， 比如09</span></p> 
 <pre><code class="language-javascript">  &lt;script&gt;
    // 1. 用户输入 
    let num = prompt('请您输入一个数字:')
    // 2. 判断输出- 小于10才补0
    num = num &lt; 10 ? 0 + num : num
    alert(num)
  &lt;/script&gt;</code></pre> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>7.2.3 </strong></span></strong><strong><span style="color:#ad2a26;"><strong>switch语句</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#404040;"><strong>语法：</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="402" src="https://images2.imgbox.com/bd/ee/G7PfoyNW_o.png" width="284"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><strong>释义：</strong></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;">找到跟小括号里数据<strong><strong>全等</strong></strong>的case值，并执行里面对应的代码，例：数据若跟值2全等，则执行代码2；若没有全等 <span style="color:#ad2b26;">=== </span>的则执行default里的代码 </p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2b26;"><strong>注意事项：</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#ad2b26;">1. switch case语句一般用于等值判断,不适合于区间判断 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#ad2b26;">2. switch case一般需要配合break关键字使用，没有break会造成case穿透</span></p> 
 <p style="margin-left:.0001pt;text-align:justify;"><strong><span style="color:#ad2b26;">简单计算器案例</span></strong></p> 
 <pre><code class="language-javascript">&lt;script&gt;
    // 1.用户输入  2个数字 +  操作符号  + - *  / 
    let num1 = +prompt('请您输入第一个数字:')
    let num2 = +prompt('请您输入第二个数字:')
    let sp = prompt('请您输入 + - * / 其中一个:')
    // 2. 判断输出
    switch (sp) {
      case '+':
        alert(`两个数的加法操作是${num1 + num2}`)
        break
      case '-':
        alert(`两个数的减法操作是${num1 - num2}`)
        break
      case '*':
        alert(`两个数的乘法操作是${num1 * num2}`)
        break
      case '/':
        alert(`两个数的除法操作是${num1 / num2}`)
        break
      default:
        alert(`请输入+-*/`)
    } 
  &lt;/script&gt;</code></pre> 
 <h4 id="7.3%20%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>7.3 循环结构</strong></span></strong></h4> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>7.3.1 断点调试</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">作用</span><span style="color:#404040;">：学习时可以帮助更好的理解代码运行，工作时可以更快找到bug </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">浏览器打开调试界面 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#404040;">        1. 按F12打开开发者工具 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#404040;">        2. 点到sources一栏 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#404040;">        3. 选择代码文件，添加断点并刷新 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">断点：在某句代码上加的标记就叫断点，当程序执行到这句有标记的代码时会停下来</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><img alt="" height="249" src="https://images2.imgbox.com/01/26/XM67NbLV_o.png" width="746"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>7.3.2 while 循环</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#c00000;"><strong>while循环</strong></span></strong><span style="color:#262626;">就是在</span><span style="color:#c00000;">满足条件</span><span style="color:#262626;">期间，重复执行某些代码。</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>1. while 循环基本语法：</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><img alt="" height="158" src="https://images2.imgbox.com/65/60/AXv6b8Ar_o.png" width="417"></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><strong>释义： </strong></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;">跟if语句很像，都要满足小括号里的条件为true才会进入<span style="color:#c00000;">循环体</span>执行代码。while大括号里代码执行完毕后不会跳出，而是继续回到小括号里判断条件是否满足，若满足又执行大括号里的代码，然后再回到小括号判断条件，直到括号内条件不满足，即跳出。</p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>2. while 循环三要素： </strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">循环的本质就是以某个变量为起始值，然后不断产生变化量，慢慢靠近终止条件的过程。 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">所以，</span><span style="color:#c00000;">while循环需要具备三要素</span><span style="color:#262626;">： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#404040;">1. </span><span style="color:#262626;">变量起始值</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#404040;">2. </span><span style="color:#262626;">终止条件（没有终止条件，循环会一直执行，造成死循环） </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#404040;">3. </span><span style="color:#262626;">变量变化量（用自增或者自减）</span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>3 循环退出</strong></span></strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">循环结束： </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">● </span><span style="color:#404040;">break：退出循环 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">● </span><span style="color:#404040;">continue：结束本次循环，继续下次循环 </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><strong><strong>区别：</strong></strong><strong> </strong></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">● </span><span style="color:#404040;">continue退出本次循环，一般用于排除或者跳过某一个选项的时候, 可以使用continue </span></p> 
 <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">● </span><span style="color:#404040;">break退出整个循环，一般用于结果已经得到, 后续的循环不需要的时候可以使用</span></p> 
 <h3 id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E7%AE%80%E6%98%93ATM%E5%8F%96%E6%AC%BE%E6%9C%BA%E6%A1%88%E4%BE%8B" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2b26;"><strong>综合案例：简易ATM取款机案例</strong></span></strong></h3> 
 <pre><code class="language-javascript">&lt;script&gt;
    // 1. 开始循环 输入框写到 循环里面
    // 3. 准备一个总的金额
    let money = 100
    while (true) {
      let re = +prompt(`
        请您选择操作：
        1.存钱
        2.取钱
        3.查看余额
        4.退出
        `)
      // 2. 如果用户输入的 4 则退出循环， break  写到if 里面，没有写到switch里面， 因为4需要break退出循环
      if (re === 4) {
        break
      }
      // 4. 根据输入做操作
      switch (re) {
        case 1:
          // 存钱
          let cun = +prompt('请输入存款金额')
          money = money + cun
          break
        case 2:
          // 存钱
          let qu = +prompt('请输入取款金额')
          money = money - qu
          break
        case 3:
          // 存钱
          alert(`您的银行卡余额是${money}`)
          break
      }
    }
  &lt;/script&gt;</code></pre> 
</div> 
<h3 id="8.for%E5%BE%AA%E7%8E%AF"><strong><span style="color:#ad2a26;"><strong>8.for循环</strong></span></strong></h3> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>1. for循环语法 </strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#404040;"><strong>作用：</strong></span></strong><span style="color:#404040;">重复执行代码 </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#404040;"><strong>好处：</strong></span></strong><span style="color:#404040;">把声明起始值、循环条件、变化值写到一起，让人一目了然，</span><span style="color:#262626;">它是最常使用的循环形式</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="145" src="https://images2.imgbox.com/c5/2f/eqgXk20l_o.png" width="706"></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>2. 退出循环 </strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">● </span><span style="color:#404040;">continue退出本次循环，</span><span style="color:#262626;">一般用于排除或者跳过某一个选项的时候,可以使用continue</span> </p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">● </span><span style="color:#404040;">break退出整个for循环，</span><span style="color:#262626;">一般用于结果已经得到, 后续的循环不需要的时候可以使用 </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#404040;"><strong>了解： </strong></span></strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#404040;">1. </span><span style="color:#262626;">while(true) 来构造“无限”循环，需要使用break退出循环。 </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#404040;">2. for(;;) 也可以来</span><span style="color:#262626;">构造“无限”循环，同样需要使用break退出循环。</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>for循环和while循环的区别：</strong></span></strong><strong> </strong></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">● 当如果明确了循环的次数的时候推荐使用for循环 </span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">● 当不明确循环的次数的时候推荐使用while循环</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#262626;"><strong>3. for 循环嵌套：</strong></span></strong><span style="color:#404040;">一个循环里再套一个循环，一般用在for循环里</span></p> 
<p style="margin-left:.0001pt;text-align:left;"><img alt="" height="275" src="https://images2.imgbox.com/62/19/4gBFGgb8_o.png" width="739"></p> 
<p style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>案例：九九乘法表</strong></span></strong></p> 
<pre><code class="language-javascript">  &lt;script&gt;
    // 1. 外层循环控制行数
    for (let i = 1; i &lt;= 9; i++) {
      // 2. 里层循环控制列数
      for (let j = 1; j &lt;= i; j++) {
        document.write(`&lt;span&gt;${j} X ${i} = ${i * j}&lt;/span&gt;`)
      }
      // 换行
      document.write('&lt;br&gt;')
    }
  &lt;/script&gt;</code></pre> 
<h3 id="9.%E6%95%B0%E7%BB%84"><span style="color:#be191c;">9.</span><strong><span style="color:#be191c;"><strong>数</strong></span><span style="color:#ad2a26;"><strong>组</strong></span></strong></h3> 
<h4 id="9.1%20%E6%95%B0%E7%BB%84%E6%98%AF%E4%BB%80%E4%B9%88" style="margin-left:.0001pt;text-align:left;"><strong><span style="color:#ad2a26;"><strong>9.1 数组是什么</strong></span></strong></h4> 
<div> 
 <span style="color:#404040;">数组：(Array)是一种可以按顺序保存数据的</span> 
 <span style="color:#c00000;">数据类型</span> 
</div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#c00000;">场景：如果有多个数据可以用数组保存起来，然后放到一个变量中，管理非常方便</span> 
 </div> 
 <div></div> 
 <div> 
  <h4 id="9.2%20%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><strong><span style="color:#ad2a26;">9.2 数组的基本使用</span></strong></h4> 
  <div> 
   <span style="color:#262626;"><strong>1. 声明语法：</strong></span> 
  </div> 
  <div></div> 
  <div> 
   <img alt="" height="40" src="https://images2.imgbox.com/b2/e6/eXh0s2x3_o.png" width="464"> 
  </div> 
  <div></div> 
  <div> 
   <img alt="" height="44" src="https://images2.imgbox.com/29/20/KsjcXEst_o.png" width="631"> 
  </div> 
  <div></div> 
  <div> 
   <p style="margin-left:.0001pt;text-align:left;">数组是按顺序保存，所以每个数据都有自己的编号</p> 
   <p style="margin-left:.0001pt;text-align:left;">计算机中的编号从0开始，所以小明的编号为0，小刚编号为1，以此类推</p> 
   <p style="margin-left:.0001pt;text-align:left;">在数组中，数据的编号也叫<strong><span style="color:#c00000;"><strong>索引或下标 </strong></span></strong></p> 
   <p style="margin-left:.0001pt;text-align:left;">数组可以存储任意类型的数据</p> 
   <div> 
    <div> 
     <span style="color:#262626;"><strong>2. 取值语法：数组名[下标]</strong></span> 
    </div> 
    <div></div> 
    <div> 
     <div> 
      <span style="color:#404040;">通过下标取数据，取出来是什么类型的，就根据这种类型特点来访问</span> 
     </div> 
     <div></div> 
     <div> 
      <div> 
       <span style="color:#404040;"><strong>3. 一些术语： </strong></span> 
      </div> 
      <div></div> 
      <div> 
       <span style="color:#404040;">元素：数组中保存的每个数据都叫数组元素 </span> 
      </div> 
      <div></div> 
      <div> 
       <span style="color:#404040;">下标：数组中数据的编号 </span> 
      </div> 
      <div></div> 
      <div> 
       <span style="color:#404040;">长度：数组中数据的个数，通过数组的length属性获得</span> 
      </div> 
      <div></div> 
      <div> 
       <div> 
        <span style="color:#c00000;"><strong>4. 遍历数组(重点)</strong></span> 
       </div> 
       <div></div> 
       <div> 
        <div> 
         <span style="color:#262626;">用循环把数组中每个元素都访问到,一般会用for循环遍历 </span> 
        </div> 
        <div></div> 
        <div> 
         <span style="color:#404040;">语法：</span> 
        </div> 
        <div></div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
  <div> 
   <img alt="" height="116" src="https://images2.imgbox.com/4d/86/mPVTaWi3_o.png" width="608"> 
  </div> 
  <div></div> 
  <div> 
   <h4 id="9.3%20%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84"><span style="color:#ad2a26;">9.3 操作数组</span></h4> 
  </div> 
  <div> 
   <span style="color:#262626;">数组本质是数据集合, 操作数据无非就是 </span> 
   <span style="color:#c00000;">增 删 改 查</span> 
  </div> 
  <div></div> 
  <div> 
   <span style="color:#262626;"><strong>语法：</strong></span> 
  </div> 
  <div></div> 
  <div> 
   <img alt="" height="433" src="https://images2.imgbox.com/b5/c5/DO5JGXS5_o.png" width="1099"> 
  </div> 
  <p><strong> <span style="color:#ad2a26;">操作数组-新增</span></strong></p> 
  <div> 
   <span style="color:#c00000;">arr.push() </span> 
   <span style="color:#262626;">方法将一个或多个元素添加到数组的<strong>末尾</strong>，并返回该数组的新长度 </span> 
   <span style="color:#c00000;">(重点)</span> 
  </div> 
  <div></div> 
  <div> 
   <div> 
    <span style="color:#262626;"><strong>语法：</strong></span> 
    <img alt="" height="41" src="https://images2.imgbox.com/6a/ae/LKCMD46x_o.png" width="426"> 
   </div> 
   <div></div> 
   <p><img alt="" height="95" src="https://images2.imgbox.com/58/6b/Y6Fa6tZK_o.png" width="569"></p> 
   <div> 
    <span style="color:#c00000;">arr.unshift(新增的内容) </span> 
    <span style="color:#262626;">方法将一个或多个元素添加到数组的</span> 
    <span style="color:#262626;"><strong>开头</strong></span> 
    <span style="color:#262626;">，并返回该数组的新长度 </span> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#262626;"><strong>语法：</strong></span> 
    <img alt="" height="43" src="https://images2.imgbox.com/fe/37/TLFiHy5e_o.png" width="466"> 
   </div> 
   <div></div> 
   <div> 
    <img alt="" height="93" src="https://images2.imgbox.com/30/55/snRqgJ0H_o.png" width="575"> 
   </div> 
   <div></div> 
   <p><strong><span style="color:#ad2a26;">操作数组-删除</span> </strong></p> 
   <p><span style="color:#c00000;">arr. pop() </span><span style="color:#262626;">方法从数组中删除<strong>最后一个</strong>元素，并返回该元素的值</span></p> 
   <p><strong><span style="color:#262626;">语法：arr.pop()</span></strong></p> 
   <p><img alt="" height="113" src="https://images2.imgbox.com/9d/62/I7cjLZtg_o.png" width="463"></p> 
   <div> 
    <span style="color:#c00000;">arr. shift() </span> 
    <span style="color:#262626;">方法从数组中删除<strong>第一个</strong>元素，并返回该元素的值</span> 
   </div> 
   <div></div> 
   <div> 
    <div> 
     <span style="color:#262626;"><strong>语法：arr.shift()</strong></span> 
    </div> 
    <div></div> 
    <div> 
     <img alt="" height="116" src="https://images2.imgbox.com/51/08/8Pujzewr_o.png" width="504"> 
    </div> 
    <div></div> 
    <p><span style="color:#c00000;">数组. splice() </span><span style="color:#262626;">方法 删除指定元素</span></p> 
    <p><strong><span style="color:#262626;">语法：数组.splice(start, deleteCount, item1, item2, ..., itemN)</span></strong></p> 
    <p><span style="color:#262626;">从start开始删除deleteCount个数组元素，并从start处开始添加item（item可加可不加）</span></p> 
    <div> 
     <span style="color:#262626;"><strong>使用场景： </strong></span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#404040;">1. </span> 
     <span style="color:#262626;">随机抽奖，中奖的用户就需要从数组里面删除，不允许重复抽奖 </span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#404040;">2. </span> 
     <span style="color:#262626;">点击删除按钮，相关的数据会从商品数据中删除</span> 
    </div> 
    <div></div> 
    <p><span style="color:#262626;"><strong>语法：</strong></span></p> 
    <p><img alt="" height="111" src="https://images2.imgbox.com/c7/59/GhvyEur3_o.png" width="510"></p> 
    <div> 
     <span style="color:#0d0016;">解释：</span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#c00000;">start 起始位置：</span> 
     <span style="color:#0d0016;">指定修改的开始位置（从0计数） </span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#c00000;">deleteCount： </span> 
     <span style="color:#0d0016;">表示要移除的数组元素的个数。可选的，如果省略则默认从指定的起始位置删 </span> 
    </div> 
    <div> 
     <span style="color:#0d0016;">除到最后。</span> 
    </div> 
    <div></div> 
    <h3 id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E6%9F%B1%E5%BD%A2%E5%9B%BE"><span style="color:#be191c;">综合案例：根据数据生成柱形图</span></h3> 
   </div> 
   <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        * {
            margin: 0;
            padding: 0;
        }

        .box {
            display: flex;
            width: 700px;
            height: 300px;
            border-left: 1px solid pink;
            border-bottom: 1px solid pink;
            margin: 100px auto;
            justify-content: space-around;
            align-items: flex-end;
            text-align: center;
        }

        .box&gt;div {
            display: flex;
            width: 50px;
            background-color: pink;
            flex-direction: column;
            justify-content: space-between;
        }

        .box div span {

            margin-top: -20px;
        }

        .box div h4 {
            margin-bottom: -35px;
            width: 70px;
            margin-left: -10px;
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;script&gt;
        // 1. 四次弹框效果
        // 声明一个新的数组
        let arr = []
        for (let i = 1; i &lt;= 4; i++) {
            // let num = prompt(`请输入第${i}季度的数据:`)
            // arr.push(num)
            arr.push(prompt(`请输入第${i}季度的数据:`))
            // push记得加小括号，不是等号赋值的形式
        }
        // console.log(arr)  ['123','135','345','234']
        // 盒子开头
        document.write(` &lt;div class="box"&gt;`)

        // 盒子中间 利用循环的形式  跟数组有关系
        for (let i = 0; i &lt; arr.length; i++) {
            document.write(`
              &lt;div style="height: ${arr[i]}px;"&gt;
                &lt;span&gt;${arr[i]}&lt;/span&gt;
                &lt;h4&gt;第${i + 1}季度&lt;/h4&gt;
              &lt;/div&gt;          
            `)
        }
        // 盒子结尾
        document.write(` &lt;/div&gt;`)
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
   <h4 id="9.4%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span style="color:#ad2a26;">9.4 冒泡排序</span></h4> 
  </div> 
  <div> 
   <div> 
    <span style="color:#262626;">冒泡排序是一种简单的排序算法。 </span> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#262626;">它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访</span> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#262626;">数列的工作是重 复地进行直到没有再需要交换，也就是说该数列已经排序完成。 </span> 
   </div> 
   <div></div> 
   <div> 
    <img alt="" height="362" src="https://images2.imgbox.com/84/0e/dtD3l1tZ_o.png" width="677"> 
   </div> 
   <div> 
    <h4 id="9.5%20%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><strong><span style="color:#ad2a26;">9.5 数组排序 </span></strong></h4> 
    <div> 
     <span style="color:#c00000;">数组. sort() 方法可以排序</span> 
    </div> 
    <div></div> 
    <div> 
     <pre><code class="language-javascript">let arr = [4, 2, 5, 1, 3]
// 1.升序排列写法
arr.sort(function (a, b) {
return a - b
})
console.log(arr) // [1, 2, 3, 4, 5]
// 降序排列写法
arr.sort(function (a, b) {
return b - a
})
console.log(arr) // [5, 4, 3, 2, 1]</code></pre> 
     <h3 id="10.%E5%87%BD%E6%95%B0"><span style="color:#c00000;">10.函数</span></h3> 
    </div> 
   </div> 
   <h4 id="10.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%87%BD%E6%95%B0"><span style="color:#ad2a26;">10.1 为什么需要函数</span></h4> 
   <div> 
    <span style="color:#262626;"><strong>函数： </strong>function，是被设计为</span> 
    <span style="color:#c00000;">执行特定任务</span> 
    <span style="color:#262626;">的代码</span> 
   </div> 
   <div></div> 
   <div> 
    <div> 
     <span style="color:#262626;"><strong>说明：</strong>函数可以把具有相同或相似逻辑的代码“包裹”起来，通过函数调用执行这些被“包裹”的代码逻辑，这么做的优势是有利于</span> 
     <span style="color:#c00000;">精简代码方便复用</span> 
     <span style="color:#be191c;">，提高开发效率</span> 
     <span style="color:#262626;">。 </span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#262626;">比如我们前面使用的 alert() 、 prompt() 和 console.log() 都是一些 js </span> 
     <strong><span style="color:#262626;">函数</span></strong> 
     <span style="color:#262626;">，只不过已经封装好了，我们直接使用的。</span> 
    </div> 
    <div></div> 
    <h4 id="10.2%20%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8"><span style="color:#ad2a26;">10.2 函数使用</span></h4> 
    <div> 
     <span style="color:#262626;"><strong>函数的声明语法</strong>：</span> 
    </div> 
    <div></div> 
    <div> 
     <img alt="" height="130" src="https://images2.imgbox.com/37/24/OAwjrOv1_o.png" width="356"> 
    </div> 
    <div></div> 
    <div> 
     <div> 
      <span style="color:#0d0016;"><strong>函数名命名规范</strong>：</span> 
     </div> 
     <div></div> 
     <div> 
      <span style="color:#0d0016;">和变量命名基本一致；尽量小驼峰式命名法；前缀应该为动词。命名建议：常用动词约定</span> 
     </div> 
     <div></div> 
     <div> 
      <img alt="" height="287" src="https://images2.imgbox.com/37/8a/gFe0t2Ud_o.png" width="727"> 
     </div> 
     <div></div> 
     <p><strong><span style="color:#262626;">函数的调用语法：函数名()</span></strong></p> 
     <div> 
      <span style="color:#262626;">注意：声明（定义）的函数必须调用才会真正被执行，使用 () 调用函数</span> 
     </div> 
     <div></div> 
     <div> 
      <img alt="" height="118" src="https://images2.imgbox.com/8b/e8/BOqAV2NZ_o.png" width="1054"> 
     </div> 
     <div></div> 
    </div> 
    <p><span style="color:#404040;">我们曾经使用的 alert() , parseInt() 这种名字后面跟小括号的本质都是函数的调用</span></p> 
    <div> 
     <strong><span style="color:#262626;">函数体：</span></strong> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#262626;">函数体是函数的构成部分，它负责将相同或相似代码“包裹”起来，直到函数调用时函数体内的代码才会被执行。函数的功能代码都要写在函数体当中。</span> 
    </div> 
    <div></div> 
    <div> 
     <div> 
      <span style="color:#be191c;"><strong>函数的复用代码和循环重复代码有什么不同？ </strong></span> 
     </div> 
     <div></div> 
     <div> 
      <span style="color:#262626;">● </span> 
      <span style="color:#000000;">循环代码写完即执行，不能很方便控制执行位置。</span> 
     </div> 
     <div> 
      <span style="color:#262626;">● 函数的复用代码可</span> 
      <span style="color:#000000;">随时调用，随时执行，可重复调用。</span> 
     </div> 
     <div></div> 
     <div> 
      <h4 id="10.3%20%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82"><span style="color:#ad2a26;">10.3 函数传参</span></h4> 
     </div> 
    </div> 
    <div> 
     <span style="color:#262626;">若函数完成功能需要调用者传入数据，那就需要有参数的函数。</span> 
     <span style="color:#c00000;">这样可以极大提高函数的灵活性。</span> 
    </div> 
    <div></div> 
    <div> 
     <div> 
      <strong><span style="color:#262626;">声明语法：</span></strong> 
     </div> 
     <div></div> 
     <div> 
      <img alt="" height="121" src="https://images2.imgbox.com/a4/96/F5BkUpV6_o.png" width="405"> 
     </div> 
     <div></div> 
     <div> 
      <div> 
       <strong><span style="color:#404040;">参数列表：</span></strong> 
       <span style="color:#0d0016;">传入数据列表；声明这个函数需要传入几个数据；多个数据用逗号隔开。</span> 
      </div> 
      <div></div> 
      <div> 
       <div> 
        <strong><span style="color:#262626;">调用语法：函数名(传递的参数列表)</span></strong> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#0d0016;">调用函数时，需要传入几个数据就写几个，用逗号隔开。</span> 
       </div> 
       <div></div> 
       <div> 
        <img alt="" height="190" src="https://images2.imgbox.com/e6/46/TQyMitex_o.png" width="509"> 
       </div> 
       <div></div> 
       <p><img alt="" height="345" src="https://images2.imgbox.com/ed/b5/svJuCo0U_o.png" width="523"></p> 
       <div> 
        <span style="color:#262626;"><strong>形参：</strong>声明函数时写在函数名右边小括号里的叫形参（形式上的参数） </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#262626;"><strong>实参：</strong>调用函数时写在函数名右边小括号里的叫实参（实际上的参数） </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#c00000;">形参可以理解为是</span> 
        <span style="color:#262626;">在这个函数内声明的</span> 
        <span style="color:#c00000;">变量</span> 
        <span style="color:#262626;">（比如 num1 = 10）实参可以理解为是给这个变量赋值 </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#c00000;">开发中尽量保持形参和实参个数一致 </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#262626;">我们曾经使用过的 alert('打印'), parseInt('11'), Number('11') 本质上都是函数调用的传参。</span> 
       </div> 
       <div></div> 
       <div></div> 
       <div> 
        <div> 
         <span style="color:#000000;">形参： 可以看做变量，但是如果一个变量不给值，</span> 
         <span style="color:#be191c;">默认是 undefined</span> 
         <span style="color:#000000;"> </span> 
        </div> 
        <div></div> 
        <div> 
         <span style="color:#000000;">但是如果做用户不输入实参，刚才的案例则出现 undefined + undefined 结果是 NaN </span> 
        </div> 
        <div></div> 
        <div> 
         <span style="color:#000000;">可以改进下，用户不输入实参，可以给 </span> 
         <span style="color:#c00000;"><strong>形参默认值</strong></span> 
         <span style="color:#000000;">，默认为 0, 这样程序更严谨，可以如下操作：</span> 
        </div> 
        <div></div> 
        <div> 
         <img alt="" height="158" src="https://images2.imgbox.com/72/67/OEZ9ktBP_o.png" width="424"> 
        </div> 
        <div></div> 
       </div> 
       <p> <span style="color:#c00000;">这个默认值只会在缺少实参参数传递时才会被执行，所以有参数会优先执行传递过来的实参, 否则默认为undefined</span></p> 
       <h4 id="10.4%20%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><strong><span style="color:#ad2a26;">10.4 函数返回值</span></strong></h4> 
       <div> 
        <span style="color:#404040;">有</span> 
        <span style="color:#be191c;">返回值</span> 
        <span style="color:#404040;">函数的概念： 当调用某个函数，这个函数会返回一个结果出来。</span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#262626;">当函数需要返回数据出去时，用</span> 
        <span style="color:#be191c;">return</span> 
        <span style="color:#262626;">关键字。这样</span> 
        <span style="color:#000000;">对执行结果的扩展性更高，可以让其他的程序使用这个结果。</span> 
       </div> 
       <div> 
        <div></div> 
        <div> 
         <strong><span style="color:#262626;">语法：return 数据</span></strong> 
        </div> 
        <div></div> 
        <div> 
         <img alt="" height="194" src="https://images2.imgbox.com/3e/b5/5XKhPjik_o.png" width="413"> 
        </div> 
        <div></div> 
        <div> 
         <div> 
          <span style="color:#404040;">在函数体中使用 return 关键字能将内部的执行结果交给函数外部使用。return 后面代码不会再被执行，会立即结束当前函数，所以 </span> 
          <span style="color:#c00000;">return 后面的数据不要换行写。</span> 
          <span style="color:#be191c;">return函数可以没有 return</span> 
          <span style="color:#404040;">，这种情况</span> 
          <span style="color:#be191c;"><strong>函数默认返回值为 undefined</strong></span> 
          <span style="color:#404040;">。</span> 
         </div> 
         <div></div> 
         <div> 
          <h4 id="10.5%20%E5%87%BD%E6%95%B0%E7%BB%86%E8%8A%82%E8%A1%A5%E5%85%85"><span style="color:#ad2a26;">10.5 函数细节补充</span></h4> 
         </div> 
         <div> 
          <div> 
           <span style="color:#262626;">● 两个相同的函数后面的会覆盖前面的函数 </span> 
          </div> 
          <div></div> 
          <div> 
           <span style="color:#262626;">● 在Javascript中 实参的个数和形参的个数可以不一致 </span> 
          </div> 
          <div></div> 
          <div> 
           <span style="color:#262626;">        如果形参过多 会自动填上undefined (了解即可) </span> 
          </div> 
          <div> 
           <span style="color:#262626;">        如果实参过多 那么多余的实参会被忽略 (函数内部有一个arguments，里面装着所有的实参) </span> 
          </div> 
          <div></div> 
          <div> 
           <span style="color:#262626;">● 函数一旦碰到return就不会在往下执行了，函数的结束用return</span> 
          </div> 
          <div></div> 
          <div> 
           <div> 
            <strong><span style="color:#c00000;">break的结束和return结束有什么区别？</span></strong> 
           </div> 
           <div></div> 
           <div> 
            <span style="color:#262626;">● </span> 
            <span style="color:#be191c;">break用来跳出整个语句块，结束当前循环的执行。</span>另外我们要特别注意， 
            <span style="color:#be191c;">break语句总是跳出自己所在的那一层循环。</span>当两个for循环嵌套时，如果break语句位于内层的for循环，它只会跳出内层的for循环，但不会跳出外层的for循环。 
           </div> 
           <div></div> 
           <div> 
            <span style="color:#262626;">● </span> 
            <span style="color:#be191c;">return并不是专门用来结束循环的关键字，但它可以用来结束一个方法或循环，而且还能返回return中的值。</span>当一个方法执行到return语句时，该方法就会被结束。与break和continue不同的是， 
            <span style="color:#be191c;">return是直接结束整个方法</span>，不管这个return处在多少层的循环之内。 
           </div> 
           <div></div> 
           <div> 
            <h4 id="10.6%20%E4%BD%9C%E7%94%A8%E5%9F%9F"><span style="color:#be191c;"><strong>10.6 作用域</strong></span></h4> 
            <div> 
             <span style="color:#000000;">通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的</span> 
             <span style="color:#c00000;">可用性的代码范围</span> 
             <span style="color:#000000;">就是这个名字的</span> 
             <span style="color:#c00000;"><strong>作用域</strong></span> 
             <span style="color:#000000;">。 </span> 
            </div> 
            <div></div> 
            <div> 
             <span style="color:#000000;">作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。</span> 
            </div> 
           </div> 
           <div></div> 
           <div> 
            <img alt="" height="334" src="https://images2.imgbox.com/37/3b/2UrQCFo0_o.png" width="501"> 
           </div> 
           <div></div> 
           <p> <span style="color:#262626;">在JavaScript中，根据作用域的不同，变量可以分为：</span></p> 
           <p><img alt="" height="337" src="https://images2.imgbox.com/31/ab/TJ0RnJYH_o.png" width="457"></p> 
           <div> 
            <strong><span style="color:#000000;">特殊情况： </span></strong> 
           </div> 
           <div></div> 
           <div> 
            <span style="color:#be191c;">1.如果函数内部，变量没有声明，直接赋值</span> 
            <span style="color:#000000;">，也当</span> 
            <span style="color:#c00000;">全局变量</span> 
            <span style="color:#000000;">看，但是强烈不推荐 </span> 
           </div> 
           <div></div> 
           <div> 
            <span style="color:#000000;">2.但是有一种情况，函数内部的形参可以看做是局部变量。</span> 
           </div> 
           <div></div> 
           <div> 
            <div> 
             <strong><span style="color:#ad2a26;">变量的访问原则：</span></strong> 
            </div> 
            <div></div> 
            <div> 
             <span style="color:#262626;">只要是代码，就至少有一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。</span> 
            </div> 
            <div> 
             <span style="color:#000000;">访问原则：</span> 
             <span style="color:#c00000;"><strong>在能够访问到的情况下 先局部， 局部没有在找全局</strong></span> 
            </div> 
            <div></div> 
            <div> 
             <p><strong><span style="color:#be191c;">作用域链：</span></strong><span style="color:#000000;">采取</span><span style="color:#c00000;"><strong>就近原则</strong></span><span style="color:#000000;">的方式来查找变量最终的值</span></p> 
             <pre><code class="language-javascript">  &lt;script&gt;
    let a = 1
    function fn1() {
        let a = 2
        let b = '22'
        fn2()
        function fn2() {
          let a = 3
          fn3()
          function fn3() {
            let a = 4
            console.log(a) //a的值 ?
            console.log(b) //b的值 ?
          }
        }
    }
    fn1()
  &lt;/script&gt;</code></pre> 
            </div> 
            <p> a 的值为4，b的值为 ‘22’</p> 
            <h4 id="10.7%C2%A0%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span style="color:#be191c;">10.7 匿名函数</span></h4> 
            <p><img alt="" height="238" src="https://images2.imgbox.com/9c/dd/UHOLXMP4_o.png" width="628"></p> 
            <p></p> 
            <div> 
             <span style="color:#262626;"><strong>匿名函数：</strong></span> 
             <span style="color:#000000;">没有名字的函数, 无法直接使用。 </span> 
            </div> 
            <div></div> 
            <div> 
             <span style="color:#000000;"><strong>使用方式（有两种）：</strong>1.函数表达式   2.立即执行函数。</span> 
            </div> 
            <div></div> 
            <div> 
             <div> 
              <span style="color:#262626;"><strong>1. 函数表达式 </strong></span> 
             </div> 
             <div></div> 
             <div> 
              <span style="color:#000000;">将匿名函数赋值给一个变量，并且通过变量名称进行调用 我们将这个称为</span> 
              <span style="color:#c00000;"><strong>函数表达式 </strong></span> 
             </div> 
             <div></div> 
             <div> 
              <span style="color:#404040;"><strong>语法：</strong></span> 
             </div> 
             <div></div> 
             <div> 
              <img alt="" height="141" src="https://images2.imgbox.com/f8/15/tg7nb0w0_o.png" width="550"> 
             </div> 
             <div></div> 
             <div> 
              <div> 
               <span style="color:#404040;"><strong>调用：</strong></span> 
              </div> 
              <div></div> 
              <div> 
               <img alt="" height="49" src="https://images2.imgbox.com/d9/30/CoEZSSC3_o.png" width="347"> 
              </div> 
              <div></div> 
              <div> 
               <span style="color:#404040;">其中函数的形参和实参使用跟具名函数一致。</span> 
              </div> 
              <div></div> 
              <div> 
               <strong>函数表达式要求必须先声明，再调用。</strong> 
              </div> 
              <div></div> 
              <div> 
               <img alt="" height="66" src="https://images2.imgbox.com/80/d8/ueLyXOBZ_o.png" width="479"> 
              </div> 
              <div></div> 
              <div>
                运行结果为：程序报错  
              </div> 
              <div></div> 
              <div> 
               <div> 
                <span style="color:#262626;"><strong>2. 立即执行函数 </strong></span> 
               </div> 
               <div></div> 
               <div> 
                <span style="color:#000000;">场景介绍: 避免全局变量之间的污染 </span> 
               </div> 
               <div></div> 
               <div> 
                <span style="color:#404040;"><strong>语法：</strong></span> 
               </div> 
              </div> 
             </div> 
             <p><img alt="" height="269" src="https://images2.imgbox.com/01/14/ku2L8pxm_o.png" width="579"></p> 
             <p><span style="color:#404040;"><strong>注意：</strong> </span><span style="color:#be191c;">多个立即执行函数要用 ; 隔开</span><span style="color:#404040;">，要不然会报错</span> </p> 
             <h3 id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4%E6%A1%88%E4%BE%8B"><span style="color:#be191c;">综合案例：转换时间案例</span></h3> 
             <div> 
              <span style="color:#262626;">用户输入秒数，可以自动转换为时分秒</span> 
             </div> 
             <div></div> 
             <div> 
              <div> 
               <span style="color:#262626;"><strong>计算公式：计算时分秒 </strong></span> 
              </div> 
              <div></div> 
              <div> 
               <span style="color:#262626;">小时： h = parseInt(总秒数 / 60 / 60 % 24) </span> 
              </div> 
              <div></div> 
              <div> 
               <span style="color:#262626;">分钟： m = parseInt(总秒数 / 60 % 60 ) </span> 
              </div> 
              <div></div> 
              <div> 
               <span style="color:#262626;">秒数: s = parseInt(总秒数 % 60)</span> 
              </div> 
              <div></div> 
              <div> 
               <pre><code class="language-javascript">  &lt;script&gt;
    // 1. 用户输入
    let second = +prompt('请输入秒数:')
    // 2.封装函数
    function getTime(t) {
      // 3. 转换 
      let h = parseInt(t / 60 / 60 % 24)
      let m = parseInt(t / 60 % 60)
      let s = parseInt(t % 60)
      h = h &lt; 10 ? '0' + h : h
      m = m &lt; 10 ? '0' + m : m
      s = s &lt; 10 ? '0' + s : s
      return `转换完毕之后是${h}小时${m}分${s}秒`
    }
    let str = getTime(second)
    document.write(str)
  &lt;/script&gt;</code></pre> 
               <h4 id="10.8%20%E9%80%BB%E8%BE%91%E4%B8%AD%E6%96%AD"><span style="color:#be191c;"><strong>10.8 逻辑中断</strong></span></h4> 
               <div> 
                <span style="color:#404040;">开发中，还会见到以下的写法：</span> 
               </div> 
               <div></div> 
               <div> 
                <img alt="" height="233" src="https://images2.imgbox.com/9d/89/dMKl9kEX_o.png" width="528"> 
               </div> 
               <div></div> 
               <div> 
                <span style="color:#404040;">其实类似参数的默认值写法</span>  
               </div> 
               <div></div> 
               <div> 
                <div> 
                 <span style="color:#404040;"><strong>1. 逻辑运算符里的短路</strong></span> 
                </div> 
                <div></div> 
                <div> 
                 <div> 
                  <span style="color:#262626;"><strong>短路：</strong>只存在于 &amp;&amp; 和 || 中，当满足一定条件会让右边代码不执行</span> 
                 </div> 
                 <div></div> 
                 <div> 
                  <img alt="" height="172" src="https://images2.imgbox.com/eb/c1/ZXtvY7oe_o.png" width="1170"> 
                 </div> 
                 <div></div> 
                 <div> 
                  <span style="color:#404040;"><strong>原因：</strong>通过左边能得到整个式子的结果，因此没必要再判断右边 </span> 
                 </div> 
                 <div></div> 
                 <div> 
                  <span style="color:#404040;"><strong>运算结果：</strong>无论 &amp;&amp; 还是 || ，运算结果都是最后被执行的表达式值，一般用在变量赋值</span> 
                 </div> 
                 <div></div> 
                 <div> 
                  <p><span style="color:#0d0016;">表达式1 &amp;&amp; 表达式2：表达式1为真，返回表达式2；表达式1为假，返回表达式1</span></p> 
                  <p><span style="color:#0d0016;">表达式1  ||  表达式2：表达式1为真，返回表达式1；表达式1为假，返回表达式2</span></p> 
                 </div> 
                 <div> 
                  <span style="color:#404040;"><strong>2. 转换为Boolean型</strong></span> 
                 </div> 
                 <div></div> 
                 <div> 
                  <div> 
                   <span style="color:#262626;"><strong>显示转换： </strong>Boolean(内容) </span> 
                  </div> 
                  <div></div> 
                  <div> 
                   <span style="color:#c00000;"><strong>记忆</strong></span> 
                   <span style="color:#c00000;">： </span> 
                   <span style="color:#c00000;"><strong>‘’ 、0、undefined、null、false、NaN 转换为布尔值后都是false, 其余则为 true</strong></span> 
                  </div> 
                  <div></div> 
                  <div> 
                   <img alt="" height="230" src="https://images2.imgbox.com/54/9d/QeaHBGMd_o.png" width="661"> 
                  </div> 
                  <div></div> 
                  <div> 
                   <div> 
                    <span style="color:#262626;"><strong>隐式转换： </strong></span> 
                   </div> 
                   <div></div> 
                   <div> 
                    <span style="color:#404040;">1. </span> 
                    <span style="color:#262626;">有字符串的加法 “” + 1 ，结果是 “1” </span> 
                   </div> 
                   <div></div> 
                   <div> 
                    <span style="color:#404040;">2. </span> 
                    <span style="color:#262626;">减法 - （像大多数数学运算一样）只能用于数字，它会使空字符串 "" 转换为 0 </span> 
                   </div> 
                   <div></div> 
                   <div> 
                    <span style="color:#404040;">3. </span> 
                    <span style="color:#262626;">null 经过数字转换之后会变为 0 </span> 
                   </div> 
                   <div></div> 
                   <div> 
                    <span style="color:#404040;">4. </span> 
                    <span style="color:#262626;">undefined 经过数字转换之后会变为 NaN</span> 
                   </div> 
                   <div></div> 
                   <div> 
                    <img alt="" height="311" src="https://images2.imgbox.com/52/06/39qelX0x_o.png" width="1200"> 
                   </div> 
                   <div></div> 
                   <h3 id="10.%E5%AF%B9%E8%B1%A1"><span style="color:#be191c;">10.对象</span></h3> 
                   <h4 id="10.1%C2%A0%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88"><span style="color:#ad2a26;">10.1 对象是什么</span></h4> 
                   <div> 
                    <span style="color:#262626;">对象（object）：JavaScript 里的一种数据类型。</span> 
                   </div> 
                   <div></div> 
                   <div> 
                    <span style="color:#262626;">可以理解为是一种</span> 
                    <span style="color:#be191c;">无序的数据集合</span> 
                    <span style="color:#262626;">， 注意数组是有序的数据集合。</span> 
                    <span style="color:#be191c;">用来描述某个事物</span> 
                    <span style="color:#262626;">，例如描述一个人，人有姓名、年龄、性别等信息、还有吃饭睡觉打代码等功能。</span> 
                    <span style="color:#be191c;">如果用多个变量保存则比较散，用对象比较统一。</span> 
                   </div> 
                   <div></div> 
                   <div> 
                    <img alt="" height="219" src="https://images2.imgbox.com/7e/dd/OuIFlrXd_o.png" width="442"> 
                   </div> 
                   <div></div> 
                   <div> 
                    <h4 id="10.2%20%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8"><span style="color:#ad2a26;">10.2 对象使用</span></h4> 
                   </div> 
                   <p><span style="color:#262626;"><strong>1. 对象声明语法</strong></span></p> 
                   <p><img alt="" height="37" src="https://images2.imgbox.com/2b/0a/lJy6PS2E_o.png" width="265"><img alt="" height="36" src="https://images2.imgbox.com/c8/e2/xJhB1lDS_o.png" width="356"> </p> 
                   <div> 
                    <span style="color:#262626;"><strong>2. 对象由属性和方法组成 </strong></span> 
                   </div> 
                   <div></div> 
                   <div> 
                    <span style="color:#262626;"><strong>属性：</strong>信息或叫</span> 
                    <span style="color:#be191c;">特征</span> 
                    <span style="color:#262626;">（名词）。 比如 手机尺寸、颜色、重量等… </span> 
                   </div> 
                   <div></div> 
                   <div> 
                    <span style="color:#262626;"><strong>方法：</strong>功能或叫</span> 
                    <span style="color:#be191c;">行为</span> 
                    <span style="color:#262626;">（动词）。 比如 手机打电话、发短信、玩游戏…</span> 
                   </div> 
                   <div></div> 
                   <div> 
                    <img alt="" height="185" src="https://images2.imgbox.com/d9/6d/t6rDKqzx_o.png" width="376"> 
                   </div> 
                   <div></div> 
                   <div> 
                    <div> 
                     <span style="color:#262626;"><strong>3. 属性 </strong></span> 
                    </div> 
                    <div></div> 
                    <div> 
                     <span style="color:#262626;">数据描述性的信息称为属性，如人的姓名、身高、年龄、性别等，一般是名词性的。</span> 
                    </div> 
                    <div></div> 
                    <div> 
                     <img alt="" height="219" src="https://images2.imgbox.com/7a/f9/C784kqYf_o.png" width="442"> 
                    </div> 
                    <div></div> 
                    <div> 
                     <div> 
                      <span style="color:#262626;">● 属性都是成对出现的，包括</span> 
                      <span style="color:#be191c;">属性名</span> 
                      <span style="color:#262626;">和</span> 
                      <span style="color:#be191c;">值</span> 
                      <span style="color:#262626;">，它们之间使用英文 </span> 
                      <span style="color:#c00000;">: </span> 
                      <span style="color:#262626;">分隔 </span> 
                     </div> 
                     <div> 
                      <span style="color:#262626;">● 多个属性之间使用英文 </span> 
                      <span style="color:#c00000;">, </span> 
                      <span style="color:#262626;">分隔 </span> 
                     </div> 
                     <div> 
                      <span style="color:#262626;">● 属性就是依附在对象上的变量（外面是变量，对象内是属性） </span> 
                     </div> 
                     <div> 
                      <span style="color:#262626;">● 属性名可以使用 "" 或 ''，</span> 
                      <span style="color:#c00000;">一般情况下省略</span> 
                      <span style="color:#262626;">，除非名称遇到特殊符号如空格、中横线等</span> 
                     </div> 
                     <div></div> 
                     <div> 
                      <span style="color:#262626;"><strong>4.对象中的方法</strong></span> 
                     </div> 
                     <div></div> 
                     <div> 
                      <span style="color:#262626;">数据行为性的信息称为方法，如跑步、唱歌等，一般是动词性的，其本质是函数。</span> 
                     </div> 
                     <div></div> 
                     <div> 
                      <img alt="" height="288" src="https://images2.imgbox.com/13/dc/5THBz257_o.png" width="612"> 
                     </div> 
                     <div></div> 
                     <div> 
                      <div> 
                       <span style="color:#262626;">● 方法是由方法名和函数两部分构成，它们之间使用 : 分隔 </span> 
                      </div> 
                      <div> 
                       <span style="color:#262626;">● 多个属性之间使用英文 , 分隔 </span> 
                      </div> 
                      <div> 
                       <span style="color:#262626;">● 方法是依附在对象中的函数 </span> 
                      </div> 
                      <div> 
                       <span style="color:#262626;">●  方法名可以使用 "" 或 ''，一般情况下省略，除非名称遇到特殊符号如空格、中横线等</span> 
                      </div> 
                     </div> 
                     <h4><span style="color:#ad2a26;">10.2 对象使用</span></h4> 
                    </div> 
                   </div> 
                   <p><span style="color:#262626;">对象本质是无序的数据集合, 操作数据无非就是 </span><span style="color:#c00000;">增 删 改 查</span></p> 
                   <p><img alt="" height="499" src="https://images2.imgbox.com/47/56/lCzhtpWP_o.png" width="1200"></p> 
                   <p><span style="color:#0d0016;"><strong>查询对象：</strong></span></p> 
                   <p><span style="color:#c00000;">1. 对象名.属性</span></p> 
                   <div> 
                    <span style="color:#262626;">声明对象，并添加了若干属性后，可以使用 . 获得对象中属性对应的值，我称之为属性访问。 </span> 
                   </div> 
                   <div></div> 
                   <div> 
                    <span style="color:#262626;">简单理解就是获得对象里面的属性值。</span> 
                   </div> 
                   <div></div> 
                   <div> 
                    <img alt="" height="339" src="https://images2.imgbox.com/33/27/iPDxNd1F_o.png" width="485"> 
                   </div> 
                   <div></div> 
                   <div> 
                    <span style="color:#be191c;">2. 对象[‘属性’] （ ‘’ 或 "" 都可以）</span> 
                   </div> 
                   <div></div> 
                   <div> 
                    <div> 
                     <span style="color:#262626;">对于多词属性或则 - 等属性，点操作就不能用了。</span> 
                    </div> 
                    <div></div> 
                    <div> 
                     <img alt="" height="268" src="https://images2.imgbox.com/d1/2e/Dd5D2s4x_o.png" width="695"> 
                    </div> 
                    <p><img alt="" height="36" src="https://images2.imgbox.com/3a/9f/BeqEMbYD_o.png" width="605">  </p> 
                    <div> 
                     <span style="color:#262626;">[ ] 语法里面的值如果不添加引号 默认会当成变量解析 </span> 
                    </div> 
                    <div></div> 
                    <div> 
                     <span style="color:#262626;"><strong>总结： </strong>没有必要的时候直接使用点语法, 在需要解析变量的时候使用 [] 语法</span> 
                    </div> 
                    <div></div> 
                   </div> 
                   <div> 
                    <strong>修改属性：</strong> 
                    <span style="color:#c00000;">对象名.属性 = 新值</span> 
                   </div> 
                   <div></div> 
                   <div> 
                    <span style="color:#0d0016;"><strong>增加属性：</strong></span> 
                    <span style="color:#c00000;">对象名.新属性 = 新值</span> 
                   </div> 
                   <div></div> 
                   <div> 
                    <span style="color:#0d0016;"><strong>删除属性：</strong></span> 
                    <span style="color:#c00000;">delete 对象名.属性</span> 
                   </div> 
                   <div></div> 
                   <div> 
                    <strong>方法调用：</strong> 
                    <span style="color:#262626;">声明对象，并添加了若干方法后，可以使用 . 调用对象中函数，称之为方法调用。</span> 
                   </div> 
                   <div></div> 
                   <div> 
                    <span style="color:#262626;">也可以添加形参和实参。</span> 
                   </div> 
                   <div></div> 
                   <div> 
                    <h4 id="10.3%C2%A0%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1"><span style="color:#ad2a26;">10.3 遍历对象</span></h4> 
                    <p><img alt="" height="316" src="https://images2.imgbox.com/9e/8b/QCEn3cA9_o.png" width="583"></p> 
                    <div> 
                     <span style="color:#0d0016;">一般不用这种方式遍历数组、主要是用来遍历对象 </span> 
                    </div> 
                    <div></div> 
                    <div> 
                     <span style="color:#0d0016;">for in语法中的 k 是一个变量, 在循环的过程中依次代表对象的属性名 </span> 
                    </div> 
                    <div></div> 
                    <div> 
                     <span style="color:#0d0016;">由于 k 是变量, 所以必须使用 [ ] 语法解析 </span> 
                    </div> 
                    <div></div> 
                    <div> 
                     <span style="color:#0d0016;"><strong>一定记住：</strong></span> 
                     <span style="color:#404040;"> </span> 
                     <span style="color:#c00000;"><strong>k </strong></span> 
                     <span style="color:#404040;">是获得对象的</span> 
                     <span style="color:#c00000;"><strong>属性名</strong></span> 
                     <span style="color:#404040;">， </span> 
                     <span style="color:#c00000;"><strong>对象名[k] </strong></span> 
                     <span style="color:#404040;">是获得 </span> 
                     <span style="color:#c00000;"><strong>属性值</strong></span> 
                    </div> 
                    <div></div> 
                    <div> 
                     <span style="color:#be191c;">案例：渲染学生信息表</span> 
                    </div> 
                   </div> 
                   <div></div> 
                   <div> 
                    <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        table {
            width: 600px;
            text-align: center;
        }

        table,
        th,
        td {
            border: 1px solid #ccc;
            border-collapse: collapse;
        }

        caption {
            font-size: 18px;
            margin-bottom: 10px;
            font-weight: 700;
        }

        tr {
            height: 40px;
            cursor: pointer;
        }

        table tr:nth-child(1) {
            background-color: #ddd;
        }

        table tr:not(:first-child):hover {
            background-color: #eee;
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;h2&gt;学生信息&lt;/h2&gt;
    &lt;p&gt;将数据渲染到页面中...&lt;/p&gt;

    &lt;table&gt;
        &lt;caption&gt;学生列表&lt;/caption&gt;
        &lt;tr&gt;
            &lt;th&gt;序号&lt;/th&gt;
            &lt;th&gt;姓名&lt;/th&gt;
            &lt;th&gt;年龄&lt;/th&gt;
            &lt;th&gt;性别&lt;/th&gt;
            &lt;th&gt;家乡&lt;/th&gt;
        &lt;/tr&gt;
        &lt;!-- script写到这里 --&gt;
        &lt;script&gt;
            // 1. 数据准备
            let students = [
                { name: '小明', age: 18, gender: '男', hometown: '河北省' },
                { name: '小红', age: 19, gender: '女', hometown: '河南省' },
                { name: '小刚', age: 17, gender: '男', hometown: '山西省' },
                { name: '小丽', age: 18, gender: '女', hometown: '山东省' },
                { name: '晓强', age: 16, gender: '女', hometown: '蓝翔技校' }
            ]
            // 2. 渲染页面
            for (let i = 0; i &lt; students.length; i++) {
                document.write(`
                &lt;tr&gt;
                    &lt;td&gt;${i + 1}&lt;/td&gt;
                    &lt;td&gt;${students[i].name}&lt;/td&gt;
                    &lt;td&gt;${students[i].age}&lt;/td&gt;
                    &lt;td&gt;${students[i].gender}&lt;/td&gt;
                    &lt;td&gt;${students[i].hometown}&lt;/td&gt;
                &lt;/tr&gt;
                `)
            }
        &lt;/script&gt;
    &lt;/table&gt;

&lt;/body&gt;


&lt;/html&gt;</code></pre> 
                    <h4 id="10.4%C2%A0%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><strong><span style="color:#ad2a26;">10.4 内置对象</span></strong></h4> 
                    <p><span style="color:#0d0016;"><strong>1.内置对象是什么？</strong></span></p> 
                   </div> 
                   <div> 
                    <div> 
                     <span style="color:#262626;">JavaScript 内部提供的对象，包含各种属性和方法给开发者调用。</span> 
                    </div> 
                    <div></div> 
                    <div> 
                     <span style="color:#262626;">思考：我们之前用过内置对象吗？ </span> 
                    </div> 
                    <div></div> 
                    <div> 
                     <span style="color:#262626;">document.write() 、console.log()</span> 
                    </div> 
                    <div></div> 
                    <div> 
                     <span style="color:#0d0016;"><strong>2.内置对象-Math</strong></span> 
                    </div> 
                    <div></div> 
                    <div> 
                     <div> 
                      <span style="color:#262626;"><strong>介绍：</strong></span> 
                      <span style="color:#262626;">Math对象是JavaScript提供的一个“数学”对象 </span> 
                     </div> 
                     <div></div> 
                     <div> 
                      <span style="color:#262626;"><strong>作用：</strong></span> 
                      <span style="color:#262626;">提供了一系列做数学运算的方法 </span> 
                     </div> 
                     <div></div> 
                     <div> 
                      <span style="color:#262626;">Math对象包含的方法有： </span> 
                     </div> 
                     <div></div> 
                     <div> 
                      <span style="color:#262626;">● random：生成0-1之间的随机数（包含0不包括1） </span> 
                     </div> 
                     <div></div> 
                     <div> 
                      <span style="color:#262626;">● ceil：向上取整 </span> 
                     </div> 
                     <div></div> 
                     <div> 
                      <span style="color:#262626;">● floor：向下取整 </span> 
                     </div> 
                     <div></div> 
                     <div> 
                      <span style="color:#262626;">● max：找最大数 </span> 
                     </div> 
                     <div></div> 
                     <div> 
                      <span style="color:#262626;">● min：找最小数 </span> 
                     </div> 
                     <div></div> 
                     <div> 
                      <span style="color:#262626;">● pow：幂运算 </span> 
                     </div> 
                     <div></div> 
                     <div> 
                      <span style="color:#262626;">● abs：绝对值 </span> 
                     </div> 
                     <div></div> 
                     <div> 
                      <div> 
                       <span style="color:#ad2a26;">生成任意范围随机数</span> 
                      </div> 
                      <div> 
                       <div></div> 
                       <div> 
                        <span style="color:#262626;">Math.random() 随机数函数， 返回一个0 - 1之间，并且包括0不包括1的随机小数 [0, 1） </span> 
                       </div> 
                       <div></div> 
                       <div> 
                        <span style="color:#262626;">如何生成0-10的随机数呢？     </span> 
                        <span style="color:#267f99;">Math</span> 
                        <span style="color:#000000;">.</span> 
                        <span style="color:#795e26;">floor</span> 
                        <span style="color:#000000;">(</span> 
                        <span style="color:#267f99;">Math</span> 
                        <span style="color:#000000;">.</span> 
                        <span style="color:#795e26;">random</span> 
                        <span style="color:#000000;">() * (</span> 
                        <span style="color:#098658;">10 </span> 
                        <span style="color:#000000;">+ </span> 
                        <span style="color:#098658;">1</span> 
                        <span style="color:#000000;">))</span> 
                       </div> 
                       <div></div> 
                       <div> 
                        <span style="color:#262626;">如何生成5-10的随机数？         </span> 
                        <span style="color:#267f99;">Math</span> 
                        <span style="color:#000000;">.</span> 
                        <span style="color:#795e26;">floor</span> 
                        <span style="color:#000000;">(</span> 
                        <span style="color:#267f99;">Math</span> 
                        <span style="color:#000000;">.</span> 
                        <span style="color:#795e26;">random</span> 
                        <span style="color:#000000;">() * (</span> 
                        <span style="color:#098658;">5 </span> 
                        <span style="color:#000000;">+ </span> 
                        <span style="color:#098658;">1</span> 
                        <span style="color:#000000;">)) + 5</span> 
                       </div> 
                       <div></div> 
                       <div> 
                        <span style="color:#262626;">如何生成N-M之间的随机数？  </span> 
                        <span style="color:#267f99;">Math</span> 
                        <span style="color:#000000;">.</span> 
                        <span style="color:#795e26;">floor</span> 
                        <span style="color:#000000;">(</span> 
                        <span style="color:#267f99;">Math</span> 
                        <span style="color:#000000;">.</span> 
                        <span style="color:#795e26;">random</span> 
                        <span style="color:#000000;">() * (</span> 
                        <span style="color:#098658;">M - N </span> 
                        <span style="color:#000000;">+ </span> 
                        <span style="color:#098658;">1</span> 
                        <span style="color:#000000;">)) + N</span> 
                       </div> 
                       <div></div> 
                       <div> 
                        <span style="color:#be191c;">案例：</span> 
                        <span style="color:#ad2a26;">猜数字游戏（限定次数）</span> 
                       </div> 
                       <div></div> 
                       <div> 
                        <pre><code class="language-javascript">  &lt;script&gt;
    // 1. 随机生成一个数字 1~10
    // 取到 N ~ M 的随机整数
    function getRandom(N, M) {
      return Math.floor(Math.random() * (M - N + 1)) + N
    }
    let random = getRandom(1, 10)
    // 2. 设定三次  三次没猜对就直接退出
    let flag = true  // 开关变量 
    for (let i = 1; i &lt;= 3; i++) {
      let num = +prompt('请输入1~10之间的一个数字:')
      if (num &gt; random) {
        alert('您猜大了，继续')
      } else if (num &lt; random) {
        alert('您猜小了，继续')
      } else {
        flag = false
        alert('猜对了，真厉害')
        break
      }
    }
    // 写到for的外面来
    if (flag) {
      alert('次数已经用完')
    }
  &lt;/script&gt;</code></pre> 
                        <p><span style="color:#be191c;">案例：</span><span style="color:#ad2a26;">生成随机颜色</span></p> 
                        <div> 
                         <span style="color:#262626;">如果参数传递的是true或者无参数，则输出 一个随机十六进制的颜色</span> 
                        </div> 
                        <div></div> 
                        <div> 
                         <span style="color:#262626;">如果参数传递的是false，则输出 一个随机rgb的颜色</span> 
                        </div> 
                        <div></div> 
                        <div> 
                         <pre><code class="language-javascript">  &lt;script&gt;
    // 1. 自定义一个随机颜色函数
    function getRandomColor(flag = true) {
      if (flag) {
        // 3. 如果是true 则返回 #ffffff
        let str = '#'
        let arr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']
        // 利用for循环随机抽6次 累加到 str里面
        for (let i = 1; i &lt;= 6; i++) {
          // 每次要随机从数组里面抽取一个  
          // random 是数组的索引号 是随机的
          let random = Math.floor(Math.random() * arr.length)
          str += arr[random]
        }
        return str

      } else {
        // 4. 否则是 false 则返回 rgb(255,255,255)
        let r = Math.floor(Math.random() * 256)  // 255
        let g = Math.floor(Math.random() * 256)  // 255
        let b = Math.floor(Math.random() * 256)  // 255
        return `rgb(${r},${g},${b})`
      }

    }
    // 2. 调用函数 getRandomColor(布尔值)
    console.log(getRandomColor(false))
    console.log(getRandomColor(true))
    console.log(getRandomColor())

  &lt;/script&gt;</code></pre> 
                         <h3 id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%A1%88%E4%BE%8B"><span style="color:#be191c;">综合案例：学成在线页面渲染案例</span></h3> 
                         <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;学车在线首页&lt;/title&gt;
    &lt;link rel="stylesheet" href="./css/style.css"&gt;
    &lt;style&gt;

    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;

    &lt;!-- 4. box核心内容区域开始 --&gt;
    &lt;div class="box w"&gt;
        &lt;div class="box-hd"&gt;
            &lt;h3&gt;精品推荐&lt;/h3&gt;
            &lt;a href="#"&gt;查看全部&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class="box-bd"&gt;
            &lt;ul class="clearfix"&gt;
                &lt;!-- &lt;li&gt;
                    &lt;a href="#"&gt;
                        &lt;img src="images/course01.png" alt=""&gt;
                        &lt;h4&gt;
                            Think PHP 5.0 博客系统实战项目演练
                        &lt;/h4&gt;
                        &lt;div class="info"&gt;
                            &lt;span&gt;高级&lt;/span&gt; • &lt;span&gt;1125&lt;/span&gt;人在学习
                        &lt;/div&gt;
                    &lt;/a&gt;
                &lt;/li&gt; --&gt;
                &lt;script&gt;
                    let data = [
                        {
                            src: 'images/course01.png',
                            title: 'Think PHP 5.0 博客系统实战项目演练',
                            num: 1125
                        },
                        {
                            src: 'images/course02.png',
                            title: 'Android 网络动态图片加载实战',
                            num: 357
                        },
                        {
                            src: 'images/course03.png',
                            title: 'Angular2大前端商城实战项目演练',
                            num: 22250
                        },
                        {
                            src: 'images/course04.png',
                            title: 'AndroidAPP实战项目演练',
                            num: 389
                        },
                        {
                            src: 'images/course05.png',
                            title: 'UGUI源码深度分析案例',
                            num: 124
                        },
                        {
                            src: 'images/course06.png',
                            title: 'Kami2首页界面切换效果实战演练',
                            num: 432
                        },
                        {
                            src: 'images/course07.png',
                            title: 'UNITY 从入门到精通实战案例',
                            num: 888
                        },
                        {
                            src: 'images/course08.png',
                            title: 'Cocos 深度学习你不会错过的实战',
                            num: 590
                        },
                        {
                            src: 'images/course04.png',
                            title: '自动添加的模块',
                            num: 1000
                        }
                    ]

                    for (let i = 0; i &lt; data.length; i++) {
                        document.write(`
                        &lt;li&gt;
                            &lt;a href="#"&gt;
                                &lt;img src=${data[i].src} title="${data[i].title}"&gt;
                                &lt;h4&gt;
                                   ${data[i].title}
                                &lt;/h4&gt;
                                &lt;div class="info"&gt;
                                    &lt;span&gt;高级&lt;/span&gt; • &lt;span&gt;${data[i].num}&lt;/span&gt;人在学习
                                &lt;/div&gt;
                            &lt;/a&gt;
                        &lt;/li&gt;
                      `)
                    }
                &lt;/script&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;

&lt;/body&gt;

&lt;/html&gt;</code></pre> 
                         <p>附：style.css</p> 
                         <pre><code class="language-css">* {
    margin: 0;
    padding: 0;
}
.w {
    width: 1200px;
    margin: auto;
}
body {
    background-color: #f3f5f7;
}
li {
    list-style: none;
}
a {
    text-decoration: none;
}
.clearfix:before,.clearfix:after {
    content:"";
    display:table; 
  }
  .clearfix:after {
    clear:both;
  }
  .clearfix {
     *zoom:1;
  }   
 

.box {
    margin-top: 30px;
}
.box-hd {
    height: 45px;
}
.box-hd h3 {
    float: left;
    font-size: 20px;
    color: #494949;
}
.box-hd a {
    float: right;
    font-size: 12px;
    color: #a5a5a5;
    margin-top: 10px;
    margin-right: 30px;
}
/* 把li 的父亲ul 修改的足够宽一行能装开5个盒子就不会换行了 */
.box-bd ul {
    width: 1225px;
}
.box-bd ul li {
    position: relative;
    top: 0;
    float: left;
    width: 228px;
    height: 270px;
    background-color: #fff;
    margin-right: 15px;
    margin-bottom: 15px;
    transition: all .3s;
   
}
.box-bd ul li a {
    display: block;
}
.box-bd ul li:hover {
    top: -8px;
    box-shadow: 0 15px 30px rgb(0 0 0 / 10%);
}
.box-bd ul li img {
    width: 100%;
}
.box-bd ul li h4 {
    margin: 20px 20px 20px 25px;
    font-size: 14px;
    color: #050505;
    font-weight: 400;
}
.box-bd .info {
    margin: 0 20px 0 25px;
    font-size: 12px;
    color: #999;
}
.box-bd .info span {
    color: #ff7c2d;
}
</code></pre> 
                         <h4 id="%E6%8B%93%E5%B1%95-%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A"><span style="color:#ad2a26;">拓展-术语解释</span></h4> 
                         <p><img alt="" height="548" src="https://images2.imgbox.com/93/d8/Yc5vcggA_o.png" width="1200"></p> 
                         <h4 id="%E6%8B%93%E5%B1%95-%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%C2%A0"><span style="color:#ad2a26;">拓展- 基本数据类型和引用数据类型</span> </h4> 
                         <div> 
                          <span style="color:#262626;">简单类型又叫做基本数据类型或者</span> 
                          <span style="color:#ff0000;">值类型</span> 
                          <span style="color:#262626;">，复杂类型又叫做</span> 
                          <span style="color:#ff0000;">引用类型</span> 
                          <span style="color:#262626;">。 </span> 
                         </div> 
                         <div></div> 
                         <div> 
                          <span style="color:#262626;">● 值类型：简单数据类型/基本数据类型，在存储时变量中存储的是</span> 
                          <span style="color:#be191c;">值本身</span> 
                          <span style="color:#262626;">，因此叫做值类型 </span> 
                         </div> 
                         <div> 
                          <span style="color:#262626;">string ，number，boolean，undefined，null </span> 
                         </div> 
                         <div></div> 
                         <div> 
                          <span style="color:#262626;">● 引用类型：复杂数据类型，在存储时变量中存储的仅仅是</span> 
                          <span style="color:#be191c;">地址（引用）</span> 
                          <span style="color:#262626;">，因此叫做引用数据类型 </span> 
                         </div> 
                         <div> 
                          <span style="color:#262626;">通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等</span> 
                         </div> 
                         <div></div> 
                         <div> 
                          <span style="color:#ff0000;">简单数据类型存放到栈里面，引用数据类型存放到堆里面。</span> 
                         </div> 
                         <div></div> 
                         <div> 
                          <img alt="" height="372" src="https://images2.imgbox.com/69/45/pJ3v4mY7_o.jpg" width="618"> 
                         </div> 
                         <div> 
                          <span style="color:#be191c;">简单数据类型传参</span>，是把 
                          <span style="color:#be191c;">值</span>复制给形参，在方法内部对形参做任何改变， 
                          <span style="color:#be191c;">不影响外部变量</span>。 
                         </div> 
                         <div></div> 
                         <div> 
                          <span style="color:#be191c;">复杂数据类型传参</span>，把变量在栈空间里保存的堆地址复制给了形参，形参和实参保存同一个堆地址， 
                          <span style="color:#be191c;">操作的是同一个对象</span>。 
                         </div> 
                         <div></div> 
                         <h4 id="%E6%8B%93%E5%B1%95-%20%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span style="color:#ad2a26;">拓展- 变量声明</span></h4> 
                         <div> 
                          <span style="color:#ad2b26;">变量声明：</span> 
                          <span style="color:#262626;">有了变量先给const，如果发现它后面是要被修改的，再改为let</span> 
                         </div> 
                         <div></div> 
                         <div> 
                          <div> 
                           <span style="color:#262626;">const 声明的值不能更改，而且const声明变量的时候需要里面进行初始化。</span> 
                           <span style="color:#262626;">但是</span> 
                           <span style="color:#be191c;">对于引用数据类型</span> 
                           <span style="color:#262626;">，</span> 
                           <span style="color:#be191c;">const声明的变量，里面存的不是值，是<strong>地址</strong></span> 
                           <span style="color:#262626;">。</span> 
                          </div> 
                          <div></div> 
                          <div> 
                           <span style="color:#c00000;">建议数组和对象使用 const 来声明。</span> 
                          </div> 
                          <div> 
                           <img alt="" height="358" src="https://images2.imgbox.com/ae/cb/kBZKS6J0_o.png" width="1150"> 
                          </div> 
                          <p> <img alt="" height="486" src="https://images2.imgbox.com/9b/6e/tMGfcegl_o.png" width="1200"></p> 
                          <p></p> 
                         </div> 
                         <h2 id="%E4%BA%8C%E3%80%81Web%20APIs"><span style="color:#be191c;">二、Web APIs</span></h2> 
                         <h3 id="1.%20Web%20API%20%E5%9F%BA%E6%9C%AC%E8%AE%A4%E7%9F%A5"><span style="color:#ad2b26;">1. Web API </span><span style="color:#ad2b26;">基本认知</span></h3> 
                         <h4 id="1.1%20%E4%BD%9C%E7%94%A8%E5%92%8C%E5%88%86%E7%B1%BB"><span style="color:#ad2b26;">1.1 </span><span style="color:#ad2a26;">作用和分类</span></h4> 
                         <p style="margin-left:.0001pt;text-align:left;"><span style="color:#be191c;">Web API是浏览器</span><span style="color:#262626;">提供的一套操作</span><span style="color:#be191c;">浏览器功能</span><span style="color:#262626;">和</span><span style="color:#be191c;">页面元素</span><span style="color:#262626;">的</span><span style="color:#be191c;">API</span><span style="color:#262626;">(BOM和DOM)。</span></p> 
                         <div> 
                          <span style="color:#262626;">作用: 就是使用 JS 去操作 html 和浏览器 </span> 
                         </div> 
                         <div></div> 
                         <div> 
                          <span style="color:#262626;">分类：</span> 
                          <span style="color:#c00000;">DOM </span> 
                          <span style="color:#262626;">(文档对象模型)、</span> 
                          <span style="color:#c00000;">BOM</span> 
                          <span style="color:#262626;">（浏览器对象模型）</span> 
                         </div> 
                         <div> 
                          <img alt="" height="551" src="https://images2.imgbox.com/01/8b/ZPScfiu6_o.png" width="559"> 
                         </div> 
                         <div></div> 
                         <h4 id="1.2%20%E4%BB%80%E4%B9%88%E6%98%AFDOM"><span style="color:#ad2b26;">1.2 </span><span style="color:#ad2a26;">什么是DOM</span></h4> 
                         <div> 
                          <span style="color:#262626;">DOM（Document Object Model——</span> 
                          <span style="color:#c00000;">文档对象模型</span> 
                          <span style="color:#262626;">）是用来呈现以及与任意 HTML 或 XML文档交互的API。即DOM是浏览器提供的一套专门用来 </span> 
                          <span style="color:#c00000;"><strong>操作网页内容 </strong></span> 
                          <span style="color:#262626;">的功能。</span> 
                         </div> 
                         <div></div> 
                         <div> 
                          <span style="color:#262626;"><strong>DOM作用：</strong>开发网页内容特效和实现用户交互</span> 
                         </div> 
                         <div></div> 
                         <h4 id="1.3%20DOM%E6%A0%91"><span style="color:#ad2b26;">1.3 </span><span style="color:#ad2a26;">DOM树</span></h4> 
                         <div> 
                          <span style="color:#262626;">将 HTML 文档以树状结构直观的表现出来，称之为文档树或 DOM 树。</span> 
                         </div> 
                         <div></div> 
                         <div> 
                          <strong><span style="color:#262626;">作用：</span></strong> 
                          <span style="color:#c00000;">文档树直观的体现了标签与标签之间的关系</span> 
                         </div> 
                         <div></div> 
                         <div> 
                          <img alt="" height="297" src="https://images2.imgbox.com/c7/42/hgCudIfe_o.png" width="724"> 
                         </div> 
                         <div></div> 
                         <div> 
                          <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">文档：一个页面就是一个文档，DOM中使用document表示 </span></p> 
                          <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">元素：页面中的所有标签都是元素，DOM中使用element表示 </span></p> 
                          <p style="margin-left:.0001pt;text-align:left;"><span style="color:#262626;">节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示 </span></p> 
                          <p style="margin-left:.0001pt;text-align:left;"><span style="color:#be191c;"><strong><strong>DOM 把以上内容都看做是对象</strong></strong></span></p> 
                          <h4 id="1.4%20DOM%E5%AF%B9%E8%B1%A1%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span style="color:#ad2b26;">1.4 </span><span style="color:#ad2a26;">DOM对象（重要）</span></h4> 
                         </div> 
                         <div> 
                          <span style="color:#262626;"><strong>● DOM 对象：</strong>浏览器根据 html 标签生成的</span> 
                          <span style="color:#c00000;">JS对象 </span> 
                         </div> 
                         <div></div> 
                         <div> 
                          <span style="color:#262626;">所有的标签属性都可以在这个对象上面找到，修改这个对象的属性会自动映射到标签身上。</span> 
                         </div> 
                         <div></div> 
                         <div> 
                          <span style="color:#262626;">● <strong>DOM 的核心思想：</strong>把网页内容当做</span> 
                          <span style="color:#c00000;">对象</span> 
                          <span style="color:#262626;">来处理 </span> 
                         </div> 
                         <div></div> 
                         <div> 
                          <span style="color:#262626;">● <strong>document 对象：</strong>是 DOM 提供的一个</span> 
                          <span style="color:#c00000;"><strong>对象，</strong></span> 
                          <span style="color:#000000;">网页所有内容都在document里面。</span> 
                         </div> 
                         <div></div> 
                         <div> 
                          <span style="color:#262626;">document 提供的属性和方法都是</span> 
                          <span style="color:#c00000;"><strong>用来访问和操作网页内</strong></span> 
                          <span style="color:#c00000;"><strong>容的。</strong></span> 
                          <span style="color:#262626;">例：document.write() </span> 
                         </div> 
                         <div></div> 
                         <h3 id="2.%E8%8E%B7%E5%8F%96DOM%E5%AF%B9%E8%B1%A1"><span style="color:#ad2b26;">2.获取DOM对象</span></h3> 
                         <div> 
                          <span style="color:#be191c;"><strong>查找元素DOM元素就是利用 JS 选择页面中标签元素</strong></span> 
                         </div> 
                         <div></div> 
                         <div> 
                          <h4 id="2.1%20%E6%A0%B9%E6%8D%AECSS%E9%80%89%E6%8B%A9%E5%99%A8%E6%9D%A5%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0%20(%E9%87%8D%E7%82%B9)"><span style="color:#ad2b26;">2.1 根据CSS选择器来获取DOM元素 (重点)</span></h4> 
                          <p><strong><span style="color:#262626;">1. 选择匹配的第一个元素</span></strong></p> 
                         </div> 
                         <div> 
                          <p><span style="color:#262626;"><strong>语法：</strong></span></p> 
                          <pre><code class="language-javascript">document.querySelector('css选择器')</code></pre> 
                          <div> 
                           <span style="color:#262626;"><strong>参数: </strong>包含一个或多个有效的CSS选择器 </span> 
                           <span style="color:#c00000;"><strong>字符串</strong></span> 
                           <span style="color:#be191c;"><strong> </strong>选择器需要加符号，如类名 .box，id名 #nav</span> 
                          </div> 
                          <div></div> 
                          <div> 
                           <span style="color:#000000;"><strong>返回值：</strong> 返回CSS选择器匹配的</span> 
                           <span style="color:#c00000;">第一个元素</span> 
                           <span style="color:#000000;">（HTMLElement对象），如果没有匹配则返回 null。</span> 
                          </div> 
                          <div></div> 
                          <div> 
                           <span style="color:#000000;">获取的元素可直接修改。</span> 
                          </div> 
                          <div></div> 
                          <div> 
                           <pre><code class="language-html">&lt;body&gt;
  &lt;div class="box"&gt;123&lt;/div&gt;
  &lt;div class="box"&gt;abc&lt;/div&gt;
  &lt;ul class="nav"&gt;
    &lt;li&gt;测试1&lt;/li&gt;
    &lt;li&gt;测试2&lt;/li&gt;
    &lt;li&gt;测试3&lt;/li&gt;
  &lt;/ul&gt;
  &lt;script&gt;
    // 获取匹配的第一个元素
    // const box = document.querySelector('div')  // 123
    const box = document.querySelector('.box')    //123
    console.log(box)
    // 获取 ul 第一个小 li
    // const li = document.querySelector('ul li')
    const li = document.querySelector('ul li:first-child')
    console.log(li)
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
                           <div> 
                            <strong><span style="color:#262626;">2. 选择匹配的多个元素 </span></strong> 
                           </div> 
                           <div></div> 
                           <div> 
                            <p><span style="color:#262626;"><strong>语法：</strong></span></p> 
                            <pre><code class="language-javascript">document.querySelectorAll('css选择器')</code></pre> 
                            <div> 
                             <span style="color:#262626;"><strong>参数: </strong> 包含一个或多个有效的CSS选择器 </span> 
                             <span style="color:#c00000;"><strong>字符串 </strong></span> 
                            </div> 
                            <div></div> 
                            <div> 
                             <span style="color:#000000;"><strong>返回值： </strong>CSS选择器匹配的 </span> 
                             <span style="color:#c00000;">NodeList 对象集合</span> 
                            </div> 
                            <div></div> 
                            <div> 
                             <div> 
                              <span style="color:#000000;">获取的对象集合不可以直接修改， 只能通过遍历的方式依次给里面的元素做修改。</span> 
                             </div> 
                             <div></div> 
                            </div> 
                            <div> 
                             <pre><code class="language-html">&lt;body&gt;
  &lt;ul class="nav"&gt;
    &lt;li&gt;测试1&lt;/li&gt;
    &lt;li&gt;测试2&lt;/li&gt;
    &lt;li&gt;测试3&lt;/li&gt;
  &lt;/ul&gt;
  &lt;script&gt;
    const lis = document.querySelectorAll('.nav li')
    console.log(lis)
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
                             <div> 
                              <span style="color:#000000;">querySelectAll() 得到的是一个</span> 
                              <span style="color:#c00000;"><strong>伪数组</strong></span> 
                              <span style="color:#000000;">：</span> 
                              <span style="color:#be191c;">有长度有索引号，但是没有 pop() push() 等数组方法</span> 
                              <span style="color:#000000;">。</span> 
                             </div> 
                             <div></div> 
                             <div> 
                              <span style="color:#000000;">想要得到里面的每一个对象，则需要遍历（for）的方式获得。</span> 
                             </div> 
                             <div></div> 
                             <div> 
                              <pre><code class="language-javascript">    const lis = document.querySelectorAll('.nav li')
    for (let i = 0; i &lt; lis.length; i++) {
      console.log(lis[i]) // 每一个小li对象
    }</code></pre> 
                              <div> 
                               <strong><span style="color:#000000;">注意事项：</span></strong> 
                              </div> 
                              <div></div> 
                              <div> 
                               <span style="color:#000000;">哪怕只有一个元素，通过querySelectAll() 获取过来的也是一个</span> 
                               <span style="color:#c00000;"><strong>伪数组</strong></span> 
                               <span style="color:#000000;">，里面只有一个元素而已。</span> 
                              </div> 
                              <div></div> 
                              <div> 
                               <span style="color:#000000;">若要修改可通过 </span> 
                               <span style="color:#be191c;">变量名[0]</span> 
                               <span style="color:#000000;"> 进行修改。</span> 
                              </div> 
                              <div></div> 
                              <div> 
                               <pre><code class="language-javascript">&lt;body&gt;
  &lt;p id="nav"&gt;导航栏&lt;/p&gt;
  &lt;script&gt;
    const p = document.querySelectorAll('#nav')
    p[0].style.color = 'red'
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
                               <div> 
                                <strong><span style="color:#000000;">querySelector() 和 querySelectorAll() 的区别：</span></strong> 
                               </div> 
                               <div></div> 
                               <div> 
                                <span style="color:#262626;"><strong>● </strong></span> 
                                <span style="color:#000000;">querySelector()只能选择一个元素， 可以直接操作。</span> 
                               </div> 
                               <div></div> 
                               <div> 
                                <span style="color:#262626;"><strong>● </strong></span> 
                                <span style="color:#000000;">querySelectorAll() 可以选择多个元素，得到的是伪数组，需要遍历得到每一个元素。</span> 
                               </div> 
                               <div></div> 
                               <h4 id="2.2%20%E5%85%B6%E4%BB%96%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><strong><span style="color:#ad2b26;">2.2 其他获取DOM元素方法（了解）</span></strong></h4> 
                               <p><img alt="" height="286" src="https://images2.imgbox.com/94/02/r4gcV4Fg_o.png" width="789"></p> 
                               <p><strong><span style="color:#be191c;">获取特殊元素</span></strong></p> 
                               <p style="text-align:left;"><span style="color:#262626;">1. 获取body元素：</span><span style="color:#be191c;">doucumnet.body</span><span style="color:#ff0000;"> </span><span style="color:#262626;">// 返回</span><span style="color:#262626;">body元素对象</span></p> 
                               <p style="text-align:left;"><span style="color:#262626;">2. 获取html元素：</span><span style="color:#be191c;">document.documentElement</span><span style="color:#ff0000;"> </span><span style="color:#262626;">// 返回html元素对象 </span></p> 
                               <h3 id="3.%20%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E5%86%85%E5%AE%B9%C2%A0"><span style="color:#c00000;">3. 操作元素内容</span> </h3> 
                               <div> 
                                <span style="color:#262626;">DOM对象都是根据标签生成的，所以操作标签本质上就是操作DOM对象。</span> 
                               </div> 
                               <div></div> 
                               <div> 
                                <span style="color:#262626;">如果想要修改标签元素的里面的</span> 
                                <span style="color:#c00000;"><strong>内容</strong></span> 
                                <span style="color:#262626;">，则可以使用两种方式： </span> 
                               </div> 
                               <div></div> 
                               <div> 
                                <span style="color:#404040;"><strong>1. 元素innerText 属性</strong></span> 
                               </div> 
                               <div></div> 
                               <div> 
                                <div> 
                                 <span style="color:#404040;">将文本内容添加/更新到任意标签位置。</span> 
                                 <span style="color:#262626;">显示纯文本，</span> 
                                 <span style="color:#be191c;">不解析标签</span> 
                                 <span style="color:#262626;">。</span> 
                                 <pre><code class="language-html">&lt;body&gt;
  &lt;div class="box"&gt;我是文字的内容&lt;/div&gt;
  &lt;script&gt;
    // 1. 获取元素
    const box = document.querySelector('.box')
    // 2. 修改文字内容  对象.innerText 属性
    box.innerText = '我是一个盒子'  // 修改文字内容
    // box.innerText = '&lt;strong&gt;我是一个盒子&lt;/strong&gt;'  // 不解析标签
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
                                 <div> 
                                  <span style="color:#404040;"><strong>2. 元素.innerHTML 属性 </strong></span> 
                                 </div> 
                                 <div></div> 
                                 <div> 
                                  <span style="color:#404040;">将文本内容添加/更新到任意标签位置。</span> 
                                  <span style="color:#be191c;">会解析标签</span> 
                                  <span style="color:#262626;">，多标签建议使用模板字符</span>。 
                                  <pre><code class="language-html">&lt;body&gt;
  &lt;div class="box"&gt;我是文字的内容&lt;/div&gt;
  &lt;script&gt;
    // 获取元素
    const box = document.querySelector('.box')
    // innerHTML 解析标签
    // box.innerHTML = '我要更换'
    box.innerHTML = '&lt;strong&gt;我要更换&lt;/strong&gt;'
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
                                  <div> 
                                   <span style="color:#c00000;">如果还在纠结到底用谁，可以选择innerHTML</span> 
                                  </div> 
                                  <div></div> 
                                  <div> 
                                   <span style="color:#be191c;">案例：</span> 
                                   <span style="color:#ad2a26;">年会抽奖</span> 
                                   <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
  &lt;title&gt;年会抽奖&lt;/title&gt;
  &lt;style&gt;
    .wrapper {
      width: 840px;
      height: 420px;
      background: url(./images/bg01.jpg) no-repeat center / cover;
      padding: 100px 250px;
      box-sizing: border-box;
    }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div class="wrapper"&gt;
    &lt;strong&gt;传智教育年会抽奖&lt;/strong&gt;
    &lt;h1&gt;一等奖：&lt;span id="one"&gt;???&lt;/span&gt;&lt;/h1&gt;
    &lt;h3&gt;二等奖：&lt;span id="two"&gt;???&lt;/span&gt;&lt;/h3&gt;
    &lt;h5&gt;三等奖：&lt;span id="three"&gt;???&lt;/span&gt;&lt;/h5&gt;
  &lt;/div&gt;
  &lt;script&gt;
    // 1.声明数组
    const personArr = ['周杰伦', '刘德华', '周星驰', 'Pink老师', '张学友']
    // 2. 先做一等奖
    // 2.1 随机数 数组的下标
    const random = Math.floor(Math.random() * personArr.length)
    // console.log(personArr[random])
    // 2.2 获取one 元素 
    const one = document.querySelector('#one')
    // 2.3 把名字给 one
    one.innerHTML = personArr[random]
    // 2.4 删除数组这个名字
    personArr.splice(random, 1)
    // console.log(personArr)


    // 3. 二等奖
    // 2.1 随机数 数组的下标
    const random2 = Math.floor(Math.random() * personArr.length)
    // console.log(personArr[random])
    // 2.2 获取one 元素 
    const two = document.querySelector('#two')
    // 2.3 把名字给 one
    two.innerHTML = personArr[random2]
    // 2.4 删除数组这个名字
    personArr.splice(random2, 1)

    // 4. 三等奖
    // 2.1 随机数 数组的下标
    const random3 = Math.floor(Math.random() * personArr.length)
    // console.log(personArr[random])
    // 2.2 获取one 元素 
    const three = document.querySelector('#three')
    // 2.3 把名字给 one
    three.innerHTML = personArr[random3]
    // 2.4 删除数组这个名字
    personArr.splice(random3, 1)
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
                                   <h3 id="4.%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span style="color:#c00000;">4.操作元素属性</span></h3> 
                                   <h4 id="4.1%20%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span style="color:#ad2a26;">4.1 操作元素常用属性</span></h4> 
                                   <div> 
                                    <span style="color:#262626;">还可以通过 JS 设置/修改标签元素属性，比如通过 src更换 图片 </span> 
                                   </div> 
                                   <div></div> 
                                   <div> 
                                    <span style="color:#404040;">最常见的属性比如： href、title、src 等 </span> 
                                   </div> 
                                   <div></div> 
                                   <div> 
                                    <span style="color:#404040;"><strong>语法：</strong></span> 
                                    <span style="color:#be191c;"><strong>对象.属性 = 值</strong></span> 
                                    <pre><code class="language-html">&lt;body&gt;
  &lt;img src="./images/1.webp" alt=""&gt;
  &lt;script&gt;
    // 1. 获取图片元素
    const img = document.querySelector('img')
    // 2. 修改图片对象的属性   对象.属性 = 值
    img.src = './images/2.webp'
    img.title = 'pink老师的艺术照'
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
                                    <h4 id="4.2%20%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E6%A0%B7%E5%BC%8F%E5%B1%9E%E6%80%A7"><span style="color:#ad2a26;">4.2 操作元素</span><span style="color:#c00000;"><strong>样式</strong></span><span style="color:#ad2a26;">属性</span></h4> 
                                   </div> 
                                  </div> 
                                 </div> 
                                </div> 
                               </div> 
                               <div> 
                                <div> 
                                 <span style="color:#262626;">还可以通过 JS 设置/修改标签元素的样式属性。 </span> 
                                </div> 
                                <div></div> 
                                <div> 
                                 <span style="color:#262626;">比如通过 轮播图小圆点自动更换颜色样式；点击按钮可以滚动图片，移动的图片的位置 left 等等</span> 
                                </div> 
                                <div></div> 
                                <div> 
                                 <div> 
                                  <span style="color:#000000;"><strong>1.通过 style 属性操作CSS </strong></span> 
                                 </div> 
                                 <div></div> 
                                 <div> 
                                  <span style="color:#262626;"><strong>语法：</strong></span> 
                                  <span style="color:#be191c;"><strong>对象.style.样式属性 = 值</strong></span> 
                                 </div> 
                                 <div></div> 
                                 <div> 
                                  <img alt="" height="191" src="https://images2.imgbox.com/4b/20/EMokxVwM_o.png" width="646"> 
                                 </div> 
                                 <div></div> 
                                 <div> 
                                  <div> 
                                   <span style="color:#0d0016;"><strong>注意： </strong></span> 
                                  </div> 
                                  <div> 
                                   <span style="color:#515151;">1. 修改样式通过</span> 
                                   <span style="color:#c00000;">style</span> 
                                   <span style="color:#515151;">属性引出 </span> 
                                  </div> 
                                  <div> 
                                   <span style="color:#515151;">2. </span> 
                                   <span style="color:#515151;">如果属性有</span> 
                                   <span style="color:#515151;">-</span> 
                                   <span style="color:#515151;">连接符，需要转换为</span> 
                                   <span style="color:#c00000;">小驼峰</span> 
                                   <span style="color:#515151;">命名法 </span> 
                                  </div> 
                                  <div> 
                                   <span style="color:#515151;">3. 赋值的时候，需要的时候不要忘记加</span> 
                                   <span style="color:#c00000;">css单位</span> 
                                  </div> 
                                  <div> 
                                   <span style="color:#be191c;">4.JS修改style样式操作，产生的是行内样式，CSS权重比较高</span> 
                                  </div> 
                                  <div></div> 
                                  <div> 
                                   <strong>2. 操作类名(className) 操作CSS</strong> 
                                  </div> 
                                  <div> 
                                   <div></div> 
                                   <div> 
                                    <span style="color:#000000;">如果修改的样式比较多，直接通过style属性修改比较繁琐，我们可以通过借助于css类名的形式。可以同时修改多个样式。</span> 
                                   </div> 
                                   <div></div> 
                                   <div> 
                                    <span style="color:#262626;"><strong>语法：</strong></span> 
                                    <span style="color:#be191c;"><strong>元素.className = 'css类名'</strong></span> 
                                   </div> 
                                   <div></div> 
                                   <div> 
                                    <div> 
                                     <span style="color:#262626;"><strong>注意： </strong></span> 
                                    </div> 
                                    <div> 
                                     <span style="color:#404040;">1. </span> 
                                     <span style="color:#262626;">由于 class 是关键字, 所以使用 </span> 
                                     <span style="color:#be191c;">className </span> 
                                     <span style="color:#262626;">去代替 </span> 
                                    </div> 
                                    <div> 
                                     <span style="color:#404040;">2. </span> 
                                     <span style="color:#262626;">className 是使用新值</span> 
                                     <span style="color:#c00000;">换</span> 
                                     <span style="color:#262626;">旧值, 如果需要添加一个类，需要保留之前的类名，</span> 
                                     <span style="color:#000000;">直接使用 className 赋值会覆盖以前的类名。</span> 
                                    </div> 
                                    <div></div> 
                                    <div> 
                                     <span style="color:#000000;"><strong>3. </strong></span> 
                                     <span style="color:#262626;"><strong>通过 classList 操作类控制CSS</strong></span> 
                                    </div> 
                                    <div></div> 
                                    <div>
                                      为了解决className 容易覆盖以前的类名，我们可以通过classList方式追加和删除类名。 
                                    </div> 
                                    <div> 
                                     <div></div> 
                                     <div> 
                                      <span style="color:#262626;"><strong>语法：</strong></span> 
                                     </div> 
                                     <div></div> 
                                     <div> 
                                      <img alt="" height="263" src="https://images2.imgbox.com/3d/06/XsvfHMOn_o.png" width="640"> 
                                     </div> 
                                     <div></div> 
                                     <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;style&gt;
    .box {
      width: 200px;
      height: 200px;
      color: #333;
    }

    .active {
      color: red;
      background-color: pink;
    }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div class="box active"&gt;文字&lt;/div&gt;
  &lt;script&gt;
    // 通过classList添加
    // 1. 获取元素
    const box = document.querySelector('.box')
    // 2. 修改样式
    // 2.1 追加类 add() 类名不加点，并且是字符串
    // box.classList.add('active')
    // 2.2 删除类  remove() 类名不加点，并且是字符串
    // box.classList.remove('box')
    // 2.3 切换类  toggle()  有还是没有啊， 有就删掉，没有就加上
    box.classList.toggle('active')
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
                                     <h4 id="%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%BD%AE%E6%92%AD%E5%9B%BE%E9%9A%8F%E6%9C%BA%E7%89%88"><strong><span style="color:#be191c;">案例：</span><span style="color:#ad2a26;">轮播图随机版</span></strong></h4> 
                                     <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
  &lt;title&gt;轮播图点击切换&lt;/title&gt;
  &lt;style&gt;
    * {
      box-sizing: border-box;
    }

    .slider {
      width: 560px;
      height: 400px;
      overflow: hidden;
    }

    .slider-wrapper {
      width: 100%;
      height: 320px;
    }

    .slider-wrapper img {
      width: 100%;
      height: 100%;
      display: block;
    }

    .slider-footer {
      height: 80px;
      background-color: rgb(100, 67, 68);
      padding: 12px 12px 0 12px;
      position: relative;
    }

    .slider-footer .toggle {
      position: absolute;
      right: 0;
      top: 12px;
      display: flex;
    }

    .slider-footer .toggle button {
      margin-right: 12px;
      width: 28px;
      height: 28px;
      appearance: none;
      border: none;
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
    }

    .slider-footer .toggle button:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .slider-footer p {
      margin: 0;
      color: #fff;
      font-size: 18px;
      margin-bottom: 10px;
    }

    .slider-indicator {
      margin: 0;
      padding: 0;
      list-style: none;
      display: flex;
      align-items: center;
    }

    .slider-indicator li {
      width: 8px;
      height: 8px;
      margin: 4px;
      border-radius: 50%;
      background: #fff;
      opacity: 0.4;
      cursor: pointer;
    }

    .slider-indicator li.active {
      width: 12px;
      height: 12px;
      opacity: 1;
    }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div class="slider"&gt;
    &lt;div class="slider-wrapper"&gt;
      &lt;img src="./images/slider01.jpg" alt="" /&gt;
    &lt;/div&gt;
    &lt;div class="slider-footer"&gt;
      &lt;p&gt;对人类来说会不会太超前了？&lt;/p&gt;
      &lt;ul class="slider-indicator"&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class="toggle"&gt;
        &lt;button class="prev"&gt;&amp;lt;&lt;/button&gt;
        &lt;button class="next"&gt;&amp;gt;&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;script&gt;
    // 1. 初始数据
    const sliderData = [
      { url: './images/slider01.jpg', title: '对人类来说会不会太超前了？', color: 'rgb(100, 67, 68)' },
      { url: './images/slider02.jpg', title: '开启剑与雪的黑暗传说！', color: 'rgb(43, 35, 26)' },
      { url: './images/slider03.jpg', title: '真正的jo厨出现了！', color: 'rgb(36, 31, 33)' },
      { url: './images/slider04.jpg', title: '李玉刚：让世界通过B站看到东方大国文化', color: 'rgb(139, 98, 66)' },
      { url: './images/slider05.jpg', title: '快来分享你的寒假日常吧~', color: 'rgb(67, 90, 92)' },
      { url: './images/slider06.jpg', title: '哔哩哔哩小年YEAH', color: 'rgb(166, 131, 143)' },
      { url: './images/slider07.jpg', title: '一站式解决你的电脑配置问题！！！', color: 'rgb(53, 29, 25)' },
      { url: './images/slider08.jpg', title: '谁不想和小猫咪贴贴呢！', color: 'rgb(99, 72, 114)' },
    ]

    // 1. 需要一个随机数 
    const random = parseInt(Math.random() * sliderData.length)
    // console.log(sliderData[random])
    // 2. 把对应的数据渲染到标签里面
    // 2.1 获取图片
    const img = document.querySelector('.slider-wrapper img')
    // 2.2. 修改图片路径  =  对象.url
    img.src = sliderData[random].url
    // 3. 把p里面的文字内容更换
    // 3.1 获取p
    const p = document.querySelector('.slider-footer p')
    // 3.2修改p
    p.innerHTML = sliderData[random].title
    // 4. 修改背景颜色
    const footer = document.querySelector('.slider-footer')
    footer.style.backgroundColor = sliderData[random].color
    // 5. 小圆点
    const li = document.querySelector(`.slider-indicator li:nth-child(${random + 1})`)
    // 让当前这个小li 添加 active这个类
    li.classList.add('active')
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
                                     <h4 id="4.3%20%E6%93%8D%E4%BD%9C%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span style="color:#ad2a26;">4.3 操作表单元素属性</span></h4> 
                                     <p><span style="color:#262626;">表单很多情况也需要修改属性，比如点击眼睛，可以看到密码，本质是把表单类型转换为文本框。</span></p> 
                                     <div> 
                                      <span style="color:#000000;"><strong>获取: </strong>DOM对象.属性名 </span> 
                                     </div> 
                                     <div></div> 
                                     <div> 
                                      <span style="color:#000000;"><strong>设置: </strong>DOM对象.属性名 = 新值</span> 
                                     </div> 
                                     <div></div> 
                                     <div> 
                                      <div> 
                                       <span style="color:#262626;">表单属性中添加就有效果，移除就没有效果，一律使用布尔值表示。如果为true代表添加了该属性， 如果是false 代表移除了该属性。比如： disabled、checked、selected</span> 
                                       <pre><code class="language-html">&lt;body&gt;
  &lt;button&gt;点击&lt;/button&gt;
  &lt;script&gt;
    // 1.获取
    const button = document.querySelector('button')
    // console.log(button.disabled)  // 默认false 不禁用
    button.disabled = true   // 禁用按钮
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
                                      </div> 
                                      <h4 id="4.4%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7"><span style="color:#ad2a26;">4.4 自定义属性</span></h4> 
                                      <div> 
                                       <span style="color:#262626;"><strong>标准属性: </strong></span> 
                                       <span style="color:#262626;">标签天生自带的属性，比如class、id、title等, 可以直接使用点语法操作。比如： disabled、checked、 selected </span> 
                                      </div> 
                                      <div></div> 
                                      <div> 
                                       <span style="color:#262626;"><strong>自定义属性： </strong>在html5中推出来了专门的data-自定义属性，在标签上一律</span> 
                                       <span style="color:#be191c;">以data-开头</span> 
                                       <span style="color:#262626;">，在DOM对象上一律以</span> 
                                       <span style="color:#be191c;">dataset对象</span> 
                                       <span style="color:#262626;">方式获取。</span> 
                                      </div> 
                                      <div></div> 
                                      <div> 
                                       <img alt="" height="274" src="https://images2.imgbox.com/b9/6a/g9sk0gBS_o.png" width="770"> 
                                      </div> 
                                      <div></div> 
                                      <h3 id="5.%E5%AE%9A%E6%97%B6%E5%99%A8-%E9%97%B4%E6%AD%87%E5%87%BD%E6%95%B0"><span style="color:#c00000;">5.定时器-间歇函数</span></h3> 
                                      <p><span style="color:#262626;">网页中经常会需要一种功能：每隔一段时间需要</span><span style="color:#c00000;">自动</span><span style="color:#262626;">执行一段代码，不需要我们手动去触发。</span></p> 
                                      <p><span style="color:#262626;">例如：网页中的倒计时。要实现这种需求，需要定时器函数。</span></p> 
                                      <p><span style="color:#262626;">定时器函数可以开启和关闭定时器，</span><span style="color:#000000;">可以根据时间自动重复执行某些代码</span><span style="color:#262626;">。</span></p> 
                                      <p><span style="color:#262626;"><strong>1. 开启定时器</strong></span></p> 
                                      <pre><code class="language-javascript">setInterval(函数, 间隔时间)</code></pre> 
                                     </div> 
                                    </div> 
                                   </div> 
                                  </div> 
                                 </div> 
                                </div> 
                               </div> 
                              </div> 
                             </div> 
                            </div> 
                           </div> 
                          </div> 
                         </div> 
                        </div> 
                       </div> 
                      </div> 
                     </div> 
                    </div> 
                   </div> 
                  </div> 
                 </div> 
                </div> 
               </div> 
              </div> 
             </div> 
            </div> 
           </div> 
          </div> 
         </div> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<div> 
 <span style="color:#262626;"><strong>作用：</strong>每隔一段时间调用这个函数 </span> 
</div> 
<div></div> 
<div> 
 <div> 
  <strong><span style="color:#595959;">注意： </span></strong> 
 </div> 
 <div> 
  <span style="color:#595959;">1. 函数名字</span> 
  <span style="color:#c00000;"><strong>不需要加括号 </strong></span> 
 </div> 
 <div> 
  <span style="color:#c00000;"><strong>2. 定时器返回的是一个id数字</strong></span> 
 </div> 
 <p><span style="color:#262626;">3. 间隔时间单位是毫秒（1s = 1000ms）</span></p> 
 <pre><code class="language-javascript">  &lt;script&gt;
    // setInterval(函数, 间隔时间)
    // 1.直接写匿名函数
    // setInterval(function () {
    //   console.log('一秒执行一次')
    // }, 1000)
    // 2.调用函数，只写函数名，不要加小括号
    function fn() {
      console.log('一秒执行一次')
    }
    let n = setInterval(fn, 1000)
    // setInterval('fn()', 1000)
  &lt;/script&gt;</code></pre> 
 <div> 
  <span style="color:#262626;"><strong>2. 关闭定时器</strong></span> 
 </div> 
 <div> 
  <pre><code class="language-javascript">let 变量名 = setInterval(函数, 间隔时间)
clearInterval(变量名)</code></pre> 
  <div> 
   <span style="color:#262626;">一般不会刚创建就停止，而是满足一定条件再停止。</span> 
  </div> 
  <div></div> 
  <div> 
   <span style="color:#be191c;">案例：</span> 
   <span style="color:#ad2a26;">阅读注册协议</span> 
  </div> 
  <div> 
   <pre><code class="language-javascript">&lt;body&gt;
    &lt;textarea name="" id="" cols="30" rows="10"&gt;
        用户注册协议
        欢迎注册成为京东用户！在您注册过程中，您需要完成我们的注册流程并通过点击同意的形式在线签署以下协议，请您务必仔细阅读、充分理解协议中的条款内容后再点击同意（尤其是以粗体或下划线标识的条款，因为这些条款可能会明确您应履行的义务或对您的权利有所限制）。
        【请您注意】如果您不同意以下协议全部或任何条款约定，请您停止注册。您停止注册后将仅可以浏览我们的商品信息但无法享受我们的产品或服务。如您按照注册流程提示填写信息，阅读并点击同意上述协议且完成全部注册流程后，即表示您已充分阅读、理解并接受协议的全部内容，并表明您同意我们可以依据协议内容来处理您的个人信息，并同意我们将您的订单信息共享给为完成此订单所必须的第三方合作方（详情查看
    &lt;/textarea&gt;
    &lt;br&gt;
    &lt;button class="btn" disabled&gt;我已经阅读用户协议(5)&lt;/button&gt;
    &lt;script&gt;
        // 1. 获取元素
        const btn = document.querySelector('.btn')
        // console.log(btn.innerHTML)  butto按钮特殊用innerHTML
        // 2. 倒计时
        let i = 5
        // 2.1 开启定时器
        let n = setInterval(function () {
            i--
            btn.innerHTML = `我已经阅读用户协议(${i})`
            if (i === 0) {
                clearInterval(n)  // 关闭定时器
                // 定时器停了，我就可以开按钮
                btn.disabled = false
                btn.innerHTML = '同意'
            }
        }, 1000)
    &lt;/script&gt;
&lt;/body&gt;</code></pre> 
  </div> 
 </div> 
</div> 
<h3 id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%BD%AE%E6%92%AD%E5%9B%BE%E5%AE%9A%E6%97%B6%E5%99%A8%E7%89%88"><span style="color:#be191c;">综合案例：轮播图定时器版</span></h3> 
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
  &lt;title&gt;轮播图点击切换&lt;/title&gt;
  &lt;style&gt;
    * {
      box-sizing: border-box;
    }

    .slider {
      width: 560px;
      height: 400px;
      overflow: hidden;
    }

    .slider-wrapper {
      width: 100%;
      height: 320px;
    }

    .slider-wrapper img {
      width: 100%;
      height: 100%;
      display: block;
    }

    .slider-footer {
      height: 80px;
      background-color: rgb(100, 67, 68);
      padding: 12px 12px 0 12px;
      position: relative;
    }

    .slider-footer .toggle {
      position: absolute;
      right: 0;
      top: 12px;
      display: flex;
    }

    .slider-footer .toggle button {
      margin-right: 12px;
      width: 28px;
      height: 28px;
      appearance: none;
      border: none;
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
    }

    .slider-footer .toggle button:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .slider-footer p {
      margin: 0;
      color: #fff;
      font-size: 18px;
      margin-bottom: 10px;
    }

    .slider-indicator {
      margin: 0;
      padding: 0;
      list-style: none;
      display: flex;
      align-items: center;
    }

    .slider-indicator li {
      width: 8px;
      height: 8px;
      margin: 4px;
      border-radius: 50%;
      background: #fff;
      opacity: 0.4;
      cursor: pointer;
    }

    .slider-indicator li.active {
      width: 12px;
      height: 12px;
      opacity: 1;
    }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div class="slider"&gt;
    &lt;div class="slider-wrapper"&gt;
      &lt;img src="./images/slider01.jpg" alt="" /&gt;
    &lt;/div&gt;
    &lt;div class="slider-footer"&gt;
      &lt;p&gt;对人类来说会不会太超前了？&lt;/p&gt;
      &lt;ul class="slider-indicator"&gt;
        &lt;li class="active"&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class="toggle"&gt;
        &lt;button class="prev"&gt;&amp;lt;&lt;/button&gt;
        &lt;button class="next"&gt;&amp;gt;&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;script&gt;
    // 1. 初始数据
    const sliderData = [
      { url: './images/slider01.jpg', title: '对人类来说会不会太超前了？', color: 'rgb(100, 67, 68)' },
      { url: './images/slider02.jpg', title: '开启剑与雪的黑暗传说！', color: 'rgb(43, 35, 26)' },
      { url: './images/slider03.jpg', title: '真正的jo厨出现了！', color: 'rgb(36, 31, 33)' },
      { url: './images/slider04.jpg', title: '李玉刚：让世界通过B站看到东方大国文化', color: 'rgb(139, 98, 66)' },
      { url: './images/slider05.jpg', title: '快来分享你的寒假日常吧~', color: 'rgb(67, 90, 92)' },
      { url: './images/slider06.jpg', title: '哔哩哔哩小年YEAH', color: 'rgb(166, 131, 143)' },
      { url: './images/slider07.jpg', title: '一站式解决你的电脑配置问题！！！', color: 'rgb(53, 29, 25)' },
      { url: './images/slider08.jpg', title: '谁不想和小猫咪贴贴呢！', color: 'rgb(99, 72, 114)' },
    ]
    // 1. 获取元素 
    const img = document.querySelector('.slider-wrapper img')
    const p = document.querySelector('.slider-footer p')
    let i = 0  // 信号量 控制图片的张数
    // 2. 开启定时器
    setInterval(function () {
      i++
      // 无缝衔接位置  一共八张图片，到了最后一张就是 8， 数组的长度就是 8
      if (i &gt;= sliderData.length) {
        i = 0
      }
      // 更换图片路径  
      img.src = sliderData[i].url
      // 把字写到 p里面
      p.innerHTML = sliderData[i].title
      // 小圆点
      // 先删除以前的active
      document.querySelector('.slider-indicator .active').classList.remove('active')
      // 只让当前li添加active
      document.querySelector(`.slider-indicator li:nth-child(${i + 1})`).classList.add('active')
    }, 1000)

  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
<h3 id="6.%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%EF%BC%88%E7%BB%91%E5%AE%9A%EF%BC%89"><strong><span style="color:#c00000;">6.事件监听（绑定）</span></strong></h3> 
<h4 id="6.1%20%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span style="color:#ad2a26;">6.1 事件监听</span></h4> 
<p><strong><span style="color:#262626;">什么是事件？ </span></strong></p> 
<div> 
 <span style="color:#262626;">事件是在编程时系统内发生的</span> 
 <span style="color:#c00000;"><strong>动作</strong></span> 
 <span style="color:#262626;">或者发生的事情。比如用户在网页上</span> 
 <span style="color:#c00000;"><strong>单击</strong></span> 
 <span style="color:#262626;">一个按钮 </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#262626;"><strong>什么是事件监听？ </strong></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#262626;">就是让程序检测是否有事件产生，一旦有事件触发，就立即调用一个函数做出响应，也称为</span> 
 <span style="color:#be191c;">绑定事件或者注册事件，</span> 
 <span style="color:#262626;">比如鼠标经过显示下拉菜单，比如点击可以播放轮播图等等。</span> 
</div> 
<div></div> 
<div> 
 <strong><span style="color:#262626;">语法：</span></strong> 
 <pre><code class="language-javascript">元素对象.addEventListener('事件类型', 要执行的函数)</code></pre> 
 <div> 
  <strong><span style="color:#be191c;">事件监听三要素： </span></strong> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#262626;"><strong>事件源： </strong>事件被触发的对象</span> 
  <span style="color:#262626;">。dom元素被事件触发了，要获取dom元素</span> 
 </div> 
 <div> 
  <span style="color:#262626;"><strong>事件类型： </strong></span> 
  <span style="color:#262626;">用什么方式触发，比如鼠标单击 click、鼠标经过 mouseover 等 </span> 
 </div> 
 <div> 
  <span style="color:#262626;"><strong>事件调用的函数： </strong></span> 
  <span style="color:#262626;">要做什么事</span> 
 </div> 
 <div></div> 
 <div> 
  <img alt="" height="238" src="https://images2.imgbox.com/ed/38/MJbHjo8A_o.png" width="576"> 
 </div> 
 <div></div> 
 <div> 
  <div> 
   <span style="color:#0d0016;"><strong>注意： </strong></span> 
  </div> 
  <div> 
   <span style="color:#0d0016;">1. 事件类型要</span> 
   <span style="color:#c00000;">加引号 </span> 
  </div> 
  <div> 
   <span style="color:#c00000;">2. 函数是点击之后再去执行，每次点击都会执行一次</span> 
  </div> 
  <div></div> 
  <div> 
   <strong><span style="color:#c00000;">案例：随机点名</span></strong> 
   <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        * {
            margin: 0;
            padding: 0;
        }

        h2 {
            text-align: center;
        }

        .box {
            width: 600px;
            margin: 50px auto;
            display: flex;
            font-size: 25px;
            line-height: 40px;
        }

        .qs {

            width: 450px;
            height: 40px;
            color: red;

        }

        .btns {
            text-align: center;
        }

        .btns button {
            width: 120px;
            height: 35px;
            margin: 0 50px;
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;h2&gt;随机点名&lt;/h2&gt;
    &lt;div class="box"&gt;
        &lt;span&gt;名字是：&lt;/span&gt;
        &lt;div class="qs"&gt;这里显示姓名&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="btns"&gt;
        &lt;button class="start"&gt;开始&lt;/button&gt;
        &lt;button class="end"&gt;结束&lt;/button&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // 数据数组
        const arr = ['马超', '黄忠', '赵云', '关羽', '张飞']
        // 定时器的全局变量
        let timerId = 0
        // 随机号要全局变量
        let random = 0
        // 业务1.开始按钮模块
        const qs = document.querySelector('.qs')
        // 1.1 获取开始按钮对象
        const start = document.querySelector('.start')
        // 1.2 添加点击事件
        start.addEventListener('click', function () {
            timerId = setInterval(function () {
                // 随机数
                random = parseInt(Math.random() * arr.length)
                // console.log(arr[random])
                qs.innerHTML = arr[random]
            }, 35)
            // 如果数组里面只有一个值了，还需要抽取吗？  不需要  让两个按钮禁用就可以
            if (arr.length === 1) {
                // start.disabled = true
                // end.disabled = true
                start.disabled = end.disabled = true
            }
        })

        // 2. 关闭按钮模块
        const end = document.querySelector('.end')
        end.addEventListener('click', function () {
            clearInterval(timerId)
            // 结束了，可以删除掉当前抽取的那个数组元素
            arr.splice(random, 1)
            console.log(arr)
        })
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
   <h4 id="6.2%20%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E7%89%88%E6%9C%AC"><span style="color:#ad2a26;">6.2 事件监听版本</span></h4> 
   <div> 
    <span style="color:#262626;">事件源.on事件 = function() { } </span> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#262626;">事件源.addEventListener(事件， 事件处理函数) </span> 
   </div> 
   <div></div> 
   <div> 
    <strong><span style="color:#262626;">区别： </span></strong> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#262626;">on方式会被覆盖，</span> 
    <span style="color:#c00000;">addEventListener</span> 
    <span style="color:#262626;">方式可绑定多次，拥有事件更多特性，推荐使用</span> 
   </div> 
   <div></div> 
   <h3 id="7.%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span style="color:#ad2a26;">7.事件类型</span></h3> 
   <p><img alt="" height="423" src="https://images2.imgbox.com/43/ee/OXqc6SHr_o.png" width="1200"></p> 
   <h4 id="%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%BD%AE%E6%92%AD%E5%9B%BE%E5%AE%8C%E6%95%B4%E7%89%88"><span style="color:#be191c;">案例：轮播图完整版</span></h4> 
   <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
  &lt;title&gt;轮播图点击切换&lt;/title&gt;
  &lt;style&gt;
    * {
      box-sizing: border-box;
    }

    .slider {
      width: 560px;
      height: 400px;
      overflow: hidden;
    }

    .slider-wrapper {
      width: 100%;
      height: 320px;
    }

    .slider-wrapper img {
      width: 100%;
      height: 100%;
      display: block;
    }

    .slider-footer {
      height: 80px;
      background-color: rgb(100, 67, 68);
      padding: 12px 12px 0 12px;
      position: relative;
    }

    .slider-footer .toggle {
      position: absolute;
      right: 0;
      top: 12px;
      display: flex;
    }

    .slider-footer .toggle button {
      margin-right: 12px;
      width: 28px;
      height: 28px;
      appearance: none;
      border: none;
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
    }

    .slider-footer .toggle button:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .slider-footer p {
      margin: 0;
      color: #fff;
      font-size: 18px;
      margin-bottom: 10px;
    }

    .slider-indicator {
      margin: 0;
      padding: 0;
      list-style: none;
      display: flex;
      align-items: center;
    }

    .slider-indicator li {
      width: 8px;
      height: 8px;
      margin: 4px;
      border-radius: 50%;
      background: #fff;
      opacity: 0.4;
      cursor: pointer;
    }

    .slider-indicator li.active {
      width: 12px;
      height: 12px;
      opacity: 1;
    }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div class="slider"&gt;
    &lt;div class="slider-wrapper"&gt;
      &lt;img src="./images/slider01.jpg" alt="" /&gt;
    &lt;/div&gt;
    &lt;div class="slider-footer"&gt;
      &lt;p&gt;对人类来说会不会太超前了？&lt;/p&gt;
      &lt;ul class="slider-indicator"&gt;
        &lt;li class="active"&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class="toggle"&gt;
        &lt;button class="prev"&gt;&amp;lt;&lt;/button&gt;
        &lt;button class="next"&gt;&amp;gt;&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;script&gt;
    // 1. 初始数据
    const data = [
      { url: './images/slider01.jpg', title: '对人类来说会不会太超前了？', color: 'rgb(100, 67, 68)' },
      { url: './images/slider02.jpg', title: '开启剑与雪的黑暗传说！', color: 'rgb(43, 35, 26)' },
      { url: './images/slider03.jpg', title: '真正的jo厨出现了！', color: 'rgb(36, 31, 33)' },
      { url: './images/slider04.jpg', title: '李玉刚：让世界通过B站看到东方大国文化', color: 'rgb(139, 98, 66)' },
      { url: './images/slider05.jpg', title: '快来分享你的寒假日常吧~', color: 'rgb(67, 90, 92)' },
      { url: './images/slider06.jpg', title: '哔哩哔哩小年YEAH', color: 'rgb(166, 131, 143)' },
      { url: './images/slider07.jpg', title: '一站式解决你的电脑配置问题！！！', color: 'rgb(53, 29, 25)' },
      { url: './images/slider08.jpg', title: '谁不想和小猫咪贴贴呢！', color: 'rgb(99, 72, 114)' },
    ]
    // 获取元素
    const img = document.querySelector('.slider-wrapper img')
    const p = document.querySelector('.slider-footer p')
    const footer = document.querySelector('.slider-footer')
    // 1. 右按钮业务
    // 1.1 获取右侧按钮 
    const next = document.querySelector('.next')
    let i = 0  // 信号量 控制播放图片张数
    // 1.2 注册点击事件
    next.addEventListener('click', function () {
      i++
      i = i &gt;= data.length ? 0 : i
      // 调用函数
      toggle()
    })

    // 2. 左侧按钮业务
    // 2.1 获取左侧按钮 
    const prev = document.querySelector('.prev')
    // 2.2 注册点击事件
    prev.addEventListener('click', function () {
      i--
      i = i &lt; 0 ? data.length - 1 : i
      // 调用函数
      toggle()
    })

    // 声明一个渲染的函数作为复用
    function toggle() {
      // 1.4 渲染对应的数据
      img.src = data[i].url
      p.innerHTML = data[i].title
      footer.style.backgroundColor = data[i].color
      // 1.5 更换小圆点    先移除原来的类名， 当前li再添加 这个 类名
      document.querySelector('.slider-indicator .active').classList.remove('active')
      document.querySelector(`.slider-indicator li:nth-child(${i + 1})`).classList.add('active')
    }

    // 3. 自动播放模块
    let timerId = setInterval(function () {
      // 利用js自动调用点击事件  click()  一定加小括号调用函数
      next.click()
    }, 1000)

    // 4. 鼠标经过大盒子，停止定时器
    const slider = document.querySelector('.slider')
    // 注册事件
    slider.addEventListener('mouseenter', function () {
      // 停止定时器
      clearInterval(timerId)
    })

    // 5. 鼠标离开大盒子，开启定时器
    // 注册事件
    slider.addEventListener('mouseleave', function () {
      // 停止定时器
      if (timerId) clearInterval(timerId)
      // 开启定时器
      timerId = setInterval(function () {
        // 利用js自动调用点击事件  click()  一定加小括号调用函数
        next.click()
      }, 1000)
    })
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
   <h3 id="8.%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span style="color:#be191c;">8.事件对象</span></h3> 
   <h4 id="8.1%20%E8%8E%B7%E5%8F%96%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span style="color:#ad2a26;">8.1 获取事件对象</span></h4> 
   <div> 
    <strong><span style="color:#262626;">事件对象是什么？</span></strong> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#be191c;">事件对象也是个对象，这个对象里有事件触发时的相关信息</span> 
    <span style="color:#262626;">。例如：鼠标点击事件中，事件对象就存了鼠标点在哪个位置等信息。</span> 
   </div> 
   <div></div> 
   <div> 
    <strong><span style="color:#262626;">使用场景：</span></strong> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#262626;">可以判断用户按下哪个键，比如按下回车键可以发布新闻 </span> 
   </div> 
   <div> 
    <span style="color:#262626;">可以判断鼠标点击了哪个元素，从而做相应的操作</span> 
   </div> 
   <div></div> 
   <div> 
    <div> 
     <strong><span style="color:#262626;">语法：</span></strong> 
    </div> 
    <div> 
     <img alt="" height="229" src="https://images2.imgbox.com/a5/70/6TupL3C9_o.png" width="1200"> 
    </div> 
    <div> 
     <span style="color:#be191c;">在事件绑定的回调函数的第一个参数就是事件对象</span> 
     <span style="color:#262626;">，一般命名为event、ev、e</span> 
    </div> 
    <div></div> 
    <h4 id="8.2%20%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span style="color:#ad2a26;">8.2 事件对象常用属性</span></h4> 
    <div> 
     <strong><span style="color:#262626;">部分常用属性：</span></strong> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#262626;">type：获取当前的事件类型 </span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#262626;">clientX/clientY：获取光标相对于浏览器可见窗口左上角的位置 </span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#262626;">offsetX/offsetY：获取光标相对于当前DOM元素左上角的位置 </span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#262626;">key：用户按下的键盘键的值，现在不提倡使用keyCode</span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#262626;">拓展：字符串.trim()  可去除字符串左右的空格</span> 
    </div> 
    <div></div> 
    <div> 
     <span style="color:#be191c;">案例：</span> 
     <span style="color:#b60206;">评论回车发布</span> 
     <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;评论回车发布&lt;/title&gt;
  &lt;style&gt;
    .wrapper {
      min-width: 400px;
      max-width: 800px;
      display: flex;
      justify-content: flex-end;
    }

    .avatar {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      overflow: hidden;
      background: url(./images/avatar.jpg) no-repeat center / cover;
      margin-right: 20px;
    }

    .wrapper textarea {
      outline: none;
      border-color: transparent;
      resize: none;
      background: #f5f5f5;
      border-radius: 4px;
      flex: 1;
      padding: 10px;
      transition: all 0.5s;
      height: 30px;
    }

    .wrapper textarea:focus {
      border-color: #e4e4e4;
      background: #fff;
      height: 50px;
    }

    .wrapper button {
      background: #00aeec;
      color: #fff;
      border: none;
      border-radius: 4px;
      margin-left: 10px;
      width: 70px;
      cursor: pointer;
    }

    .wrapper .total {
      margin-right: 80px;
      color: #999;
      margin-top: 5px;
      opacity: 0;
      transition: all 0.5s;
    }

    .list {
      min-width: 400px;
      max-width: 800px;
      display: flex;
    }

    .list .item {
      width: 100%;
      display: flex;
    }

    .list .item .info {
      flex: 1;
      border-bottom: 1px dashed #e4e4e4;
      padding-bottom: 10px;
    }

    .list .item p {
      margin: 0;
    }

    .list .item .name {
      color: #FB7299;
      font-size: 14px;
      font-weight: bold;
    }

    .list .item .text {
      color: #333;
      padding: 10px 0;
    }

    .list .item .time {
      color: #999;
      font-size: 12px;
    }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div class="wrapper"&gt;
    &lt;i class="avatar"&gt;&lt;/i&gt;
    &lt;textarea id="tx" placeholder="发一条友善的评论" rows="2" maxlength="200"&gt;&lt;/textarea&gt;
    &lt;button&gt;发布&lt;/button&gt;
  &lt;/div&gt;
  &lt;div class="wrapper"&gt;
    &lt;span class="total"&gt;0/200字&lt;/span&gt;
  &lt;/div&gt;
  &lt;div class="list"&gt;
    &lt;div class="item" style="display: none;"&gt;
      &lt;i class="avatar"&gt;&lt;/i&gt;
      &lt;div class="info"&gt;
        &lt;p class="name"&gt;zhuie&lt;/p&gt;
        &lt;p class="text"&gt;大家都辛苦啦，感谢各位大大的努力，能圆满完成真是太好了[笑哭][支持]&lt;/p&gt;
        &lt;p class="time"&gt;2023-05-17 20:33:21&lt;/p&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;script&gt;
    const tx = document.querySelector('#tx')
    const total = document.querySelector('.total')
    const item = document.querySelector('.item')
    const text = document.querySelector('.text')
    // 1. 当我们文本域获得了焦点，就让 total 显示出来
    tx.addEventListener('focus', function () {
      total.style.opacity = 1
    })
    // 2. 当我们文本域失去了焦点，就让 total 隐藏出来
    tx.addEventListener('blur', function () {
      total.style.opacity = 0
    })
    // 3. 检测用户输入
    tx.addEventListener('input', function () {
      // console.log(tx.value.length)  得到输入的长度
      total.innerHTML = `${tx.value.length}/200字`
    })

    // 4. 按下回车发布评论
    tx.addEventListener('keyup', function (e) {
      // 只有按下的是回车键，才会触发
      if (e.key === 'Enter') {
        // 如果用户输入的不为空就显示和打印
        if (tx.value.trim()) {
          item.style.display = 'block'
          // console.log(tx.value)  // 用户输入的内容
          text.innerHTML = tx.value
        }
        // 等我们按下回车，结束，清空文本域
        tx.value = ''
        // 按下回车之后，就要把 字符统计 复原
        total.innerHTML = '0/200字'
      }

    })
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
     <h3 id="9.%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1"><span style="color:#ad2b26;">9.环境对象</span></h3> 
     <div> 
      <span style="color:#404040;"><strong>环境对象：</strong></span> 
      <span style="color:#404040;">指的是函数内部特殊的</span> 
      <span style="color:#c00000;"><strong>变量 this</strong></span> 
      <span style="color:#404040;">，</span> 
      <span style="color:#be191c;">它代表着当前函数运行时所处的环境 </span> 
     </div> 
     <div></div> 
     <div> 
      <span style="color:#404040;"><strong>作用：</strong></span> 
      <span style="color:#404040;">弄清楚this的指向，可以让我们代码更简洁 </span> 
     </div> 
     <div></div> 
     <div> 
      <span style="color:#262626;">函数的调用方式不同，this 指代的对象也不同 </span> 
     </div> 
     <div> 
      <span style="color:#c00000;">【谁调用， this 就是谁】 </span> 
      <span style="color:#262626;">是判断 this 指向的粗略规则 </span> 
     </div> 
     <div> 
      <span style="color:#262626;">直接调用函数，其实相当于是 window.函数，所以 this 指代 window</span> 
     </div> 
     <div></div> 
     <h3 id="10.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span style="color:#ad2b26;">10.回调函数</span></h3> 
     <div> 
      <span style="color:#404040;">如果将函数 A 做为参数传递给函数 B 时，我们称函数 A 为</span> 
      <span style="color:#c00000;">回调函数 </span> 
     </div> 
     <div></div> 
     <div> 
      <span style="color:#404040;">简单理解： 当一个函数当做参数来传递给另外一个函数的时候，这个函数就是</span> 
      <span style="color:#c00000;">回调函数 </span> 
     </div> 
     <div></div> 
     <div> 
      <span style="color:#404040;">常见的使用场景：</span> 
      <img alt="" height="229" src="https://images2.imgbox.com/57/75/807eAJTH_o.png" width="753"> 
     </div> 
     <p><img alt="" height="159" src="https://images2.imgbox.com/36/79/Vl9hOPtL_o.png" width="861"></p> 
     <div> 
      <span style="color:#000000;">回调函数本质还是函数，只不过把它当成参数使用。使用匿名函数做为回调函数比较常见。</span> 
     </div> 
     <div></div> 
     <div> 
      <h3 id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9ATab%E6%A0%8F%E5%88%87%E6%8D%A2"><span style="color:#b60206;">综合案例：Tab栏切换</span></h3> 
      <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
  &lt;title&gt;tab栏切换&lt;/title&gt;
  &lt;style&gt;
    * {
      margin: 0;
      padding: 0;
    }

    .tab {
      width: 590px;
      height: 340px;
      margin: 20px;
      border: 1px solid #e4e4e4;
    }

    .tab-nav {
      width: 100%;
      height: 60px;
      line-height: 60px;
      display: flex;
      justify-content: space-between;
    }

    .tab-nav h3 {
      font-size: 24px;
      font-weight: normal;
      margin-left: 20px;
    }

    .tab-nav ul {
      list-style: none;
      display: flex;
      justify-content: flex-end;
    }

    .tab-nav ul li {
      margin: 0 20px;
      font-size: 14px;
    }

    .tab-nav ul li a {
      text-decoration: none;
      border-bottom: 2px solid transparent;
      color: #333;
    }

    .tab-nav ul li a.active {
      border-color: #e1251b;
      color: #e1251b;
    }

    .tab-content {
      padding: 0 16px;
    }

    .tab-content .item {
      display: none;
    }

    .tab-content .item.active {
      display: block;
    }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div class="tab"&gt;
    &lt;div class="tab-nav"&gt;
      &lt;h3&gt;每日特价&lt;/h3&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a class="active" href="javascript:;"&gt;精选&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="javascript:;"&gt;美食&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="javascript:;"&gt;百货&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="javascript:;"&gt;个护&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="javascript:;"&gt;预告&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
    &lt;div class="tab-content"&gt;
      &lt;div class="item active"&gt;&lt;img src="./images/tab00.png" alt="" /&gt;&lt;/div&gt;
      &lt;div class="item"&gt;&lt;img src="./images/tab01.png" alt="" /&gt;&lt;/div&gt;
      &lt;div class="item"&gt;&lt;img src="./images/tab02.png" alt="" /&gt;&lt;/div&gt;
      &lt;div class="item"&gt;&lt;img src="./images/tab03.png" alt="" /&gt;&lt;/div&gt;
      &lt;div class="item"&gt;&lt;img src="./images/tab04.png" alt="" /&gt;&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;script&gt;
    // 1. a 模块制作 要给 5个链接绑定鼠标经过事件
    // 1.1 获取 a 元素 
    const as = document.querySelectorAll('.tab-nav a')
    for (let i = 0; i &lt; as.length; i++) {
      // 要给 5个链接绑定鼠标经过事件
      as[i].addEventListener('mouseenter', function () {  // 鼠标经过
        // 排他思想  
        // 干掉别人 移除类active
        document.querySelector('.tab-nav .active').classList.remove('active')
        // 我登基 我添加类 active  this 当前的那个 a 
        this.classList.add('active')

        // 下面5个大盒子 一一对应  .item 
        // 干掉别人
        document.querySelector('.tab-content .active').classList.remove('active')
        // 对应序号的那个 item 显示 添加 active 类
        document.querySelector(`.tab-content .item:nth-child(${i + 1})`).classList.add('active')

      })
    }
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
      <p><span style="color:#be191c;">拓展：css伪类选择器checked（选择被勾选的复选框）</span></p> 
      <h4 id="%E9%87%8D%E7%82%B9%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%85%A8%E9%80%89%E6%96%87%E6%9C%AC%E6%A1%86"><span style="color:#be191c;">重点案例：</span><span style="color:#b60206;">全选文本框</span></h4> 
     </div> 
     <pre><code class="language-html">&lt;!DOCTYPE html&gt;

&lt;html&gt;

&lt;head lang="en"&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;style&gt;
    * {
      margin: 0;
      padding: 0;
    }

    table {
      border-collapse: collapse;
      border-spacing: 0;
      border: 1px solid #c0c0c0;
      width: 500px;
      margin: 100px auto;
      text-align: center;
    }

    th {
      background-color: #09c;
      font: bold 16px "微软雅黑";
      color: #fff;
      height: 24px;
    }

    td {
      border: 1px solid #d0d0d0;
      color: #404060;
      padding: 10px;
    }

    .allCheck {
      width: 80px;
    }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;th class="allCheck"&gt;
        &lt;input type="checkbox" name="" id="checkAll"&gt; &lt;span class="all"&gt;全选&lt;/span&gt;
      &lt;/th&gt;
      &lt;th&gt;商品&lt;/th&gt;
      &lt;th&gt;商家&lt;/th&gt;
      &lt;th&gt;价格&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;
        &lt;input type="checkbox" name="check" class="ck"&gt;
      &lt;/td&gt;
      &lt;td&gt;小米手机&lt;/td&gt;
      &lt;td&gt;小米&lt;/td&gt;
      &lt;td&gt;￥1999&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;
        &lt;input type="checkbox" name="check" class="ck"&gt;
      &lt;/td&gt;
      &lt;td&gt;小米净水器&lt;/td&gt;
      &lt;td&gt;小米&lt;/td&gt;
      &lt;td&gt;￥4999&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;
        &lt;input type="checkbox" name="check" class="ck"&gt;
      &lt;/td&gt;
      &lt;td&gt;小米电视&lt;/td&gt;
      &lt;td&gt;小米&lt;/td&gt;
      &lt;td&gt;￥5999&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
  &lt;script&gt;
    // 1. 获取大复选框
    const checkAll = document.querySelector('#checkAll')
    // 2. 获取所有的小复选框
    const cks = document.querySelectorAll('.ck')
    // 3. 点击大复选框  注册事件
    checkAll.addEventListener('click', function () {
      // 得到当前大复选框的选中状态
      // console.log(checkAll.checked)  // 得到 是 true 或者是 false
      // 4. 遍历所有的小复选框 让小复选框的checked  =  大复选框的 checked
      for (let i = 0; i &lt; cks.length; i++) {
        cks[i].checked = this.checked
      }
    })
    // 5. 小复选框控制大复选框
    for (let i = 0; i &lt; cks.length; i++) {
      // 5.1 给所有的小复选框添加点击事件
      cks[i].addEventListener('click', function () {
        // 判断选中的小复选框个数 是不是等于  总的小复选框个数
        // console.log(document.querySelectorAll('.ck:checked').length)
        // console.log(document.querySelectorAll('.ck:checked').length === cks.length)
        checkAll.checked = document.querySelectorAll('.ck:checked').length === cks.length
      })
    }
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
     <h3 id="11.%E4%BA%8B%E4%BB%B6%E6%B5%81"><span style="color:#c00000;">11.事件流</span></h3> 
     <h4 id="11.1%20%E4%BA%8B%E4%BB%B6%E6%B5%81%E5%92%8C%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5%E8%AF%B4%E6%98%8E"><span style="color:#ad2a26;">11.1 事件流和两个阶段说明</span></h4> 
     <div> 
      <div> 
       <span style="color:#c00000;">事件流</span> 
       <span style="color:#262626;">指的是事件完整执行过程中的流动路径。</span> 
      </div> 
      <div></div> 
      <div> 
       <img alt="" height="226" src="https://images2.imgbox.com/bd/ca/aZqparZU_o.png" width="445"> 
      </div> 
      <div> 
       <img alt="" height="241" src="https://images2.imgbox.com/44/92/ZXRLp1NT_o.png" width="444"> 
      </div> 
      <div> 
       <span style="color:#262626;">说明：假设页面里有个div，当触发事件时，会经历两个阶段，分别是捕获阶段、冒泡阶段 </span> 
      </div> 
      <div></div> 
      <div> 
       <span style="color:#262626;">简单来说：捕获阶段是从父到子，冒泡阶段是从子到父 </span> 
      </div> 
      <div></div> 
      <div> 
       <span style="color:#c00000;">实际工作都是使用事件冒泡为主。</span> 
      </div> 
      <div></div> 
      <h4 id="11.2%20%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7"><span style="color:#ad2a26;">11.2 事件捕获</span></h4> 
      <div> 
       <span style="color:#262626;"><strong>事件捕获概念： </strong>从DOM的根元素开始去执行对应的事件 (从外到里) </span> 
      </div> 
      <div></div> 
      <div> 
       <span style="color:#262626;"><strong>代码：</strong></span> 
       <span style="color:#be191c;">DOM.addEventListener(事件类型, 事件处理函数, 是否使用捕获机制)</span> 
      </div> 
      <div></div> 
      <div> 
       <div> 
        <span style="color:#262626;">说明： </span> 
       </div> 
       <div> 
        <span style="color:#262626;"><strong>● </strong>addEventListener第三个参数传入 </span> 
        <span style="color:#c00000;">true </span> 
        <span style="color:#262626;">代表是</span> 
        <span style="color:#be191c;">捕获阶段</span> 
        <span style="color:#262626;">触发（很少使用） </span> 
       </div> 
       <div> 
        <span style="color:#262626;"><strong>● </strong>若传入</span> 
        <span style="color:#b95514;">false</span> 
        <span style="color:#262626;">代表</span> 
        <span style="color:#be191c;">冒泡阶段</span> 
        <span style="color:#262626;">触发，默认就是false </span> 
       </div> 
       <div> 
        <span style="color:#262626;"><strong>● </strong>若是用 L0 事件监听，则只有冒泡阶段，没有捕获</span> 
       </div> 
       <div></div> 
       <h4 id="11.3%20%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span style="color:#ad2a26;">11.3 事件冒泡</span></h4> 
       <div> 
        <span style="color:#262626;"><strong>事件冒泡概念: </strong>当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为事件冒泡。</span> 
       </div> 
       <div> 
        <span style="color:#262626;"><strong>简单理解：</strong>当一个元素触发事件后，会依次向上调用所有父级元素的</span> 
        <span style="color:#c00000;">同名事件</span> 
        <span style="color:#0d0016;">。比如click事件</span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#262626;">事件冒泡是默认存在的。L2事件监听第三个参数是 false，或者默认都是冒泡。</span> 
       </div> 
       <div></div> 
       <h4 id="11.4%20%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1"><span style="color:#ad2a26;">11.4 阻止冒泡</span></h4> 
       <div> 
        <span style="color:#262626;"><strong>问题：</strong></span> 
        <span style="color:#262626;">因为默认就有冒泡模式的存在，所以容易导致事件影响到父级元素 </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#262626;"><strong>需求：</strong></span> 
        <span style="color:#262626;">若想把事件就限制在当前元素内，就需要阻止事件冒泡 </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#262626;"><strong>前提：</strong></span> 
        <span style="color:#262626;">阻止事件冒泡需要拿到事件对象 </span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#262626;"><strong>语法：</strong></span> 
        <span style="color:#be191c;">事件对象.stopPropagation()</span> 
       </div> 
       <div></div> 
       <div> 
        <div> 
         <span style="color:#262626;"><strong>注意：</strong></span> 
         <span style="color:#262626;">此方法可以阻断事件流动传播，不光在冒泡阶段有效，捕获阶段也有效</span> 
        </div> 
        <div></div> 
        <div> 
         <pre><code class="language-html">&lt;body&gt;
  &lt;div class="father"&gt;
    &lt;div class="son"&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;script&gt;
    const fa = document.querySelector('.father')
    const son = document.querySelector('.son')
    document.addEventListener('click', function () {
      alert('我是爷爷')
    })
    fa.addEventListener('click', function () {
      alert('我是爸爸')
    })
    son.addEventListener('click', function (e) {
      alert('我是儿子')
      // 阻止流动传播  事件对象.stopPropagation()
      e.stopPropagation()
    })

  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
         <div> 
          <span style="color:#262626;"><strong>我们某些情况下需要</strong></span> 
          <span style="color:#262626;">阻止</span> 
          <span style="color:#be191c;"><strong>默认行为</strong></span> 
          <span style="color:#262626;">的发生，比如 阻止 </span> 
          <span style="color:#262626;">链接的跳转，表单域跳转</span> 
         </div> 
         <div></div> 
         <div> 
          <span style="color:#262626;"><strong>语法：</strong></span> 
          <span style="color:#be191c;">e.preventDefault()</span> 
         </div> 
         <div></div> 
         <div> 
          <pre><code class="language-html">&lt;body&gt;
  &lt;form action="http://www.itcast.cn"&gt;
    &lt;input type="submit" value="免费注册"&gt;
  &lt;/form&gt;
  &lt;script&gt;
    const form = document.querySelector('form')
    form.addEventListener('submit', function (e) {
      // 阻止默认行为  提交
      e.preventDefault()
    })
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
         </div> 
         <h4 id="11.5%20%E8%A7%A3%E7%BB%91%E4%BA%8B%E4%BB%B6"><span style="color:#be191c;">1</span><span style="color:#ad2a26;">1.5 解绑事件</span></h4> 
         <div> 
          <span style="color:#262626;">on事件方式，直接使用null覆盖偶就可以实现事件的解绑 </span> 
         </div> 
         <div></div> 
         <div> 
          <span style="color:#262626;"><strong>语法：</strong></span> 
          <pre><code class="language-html">&lt;body&gt;
  &lt;button&gt;点击&lt;/button&gt;
  &lt;script&gt;
    const btn = document.querySelector('button')
    btn.onclick = function () {
      alert('点击了')
      // L0 事件移除解绑
      btn.onclick = null
    }
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
          <div> 
           <span style="color:#262626;">addEventListener方式必须使用：</span> 
          </div> 
          <div> 
           <span style="color:#be191c;">removeEventListener(事件类型, 事件处理函数, [获取捕获或者冒泡阶段]) </span> 
          </div> 
          <div> 
           <pre><code class="language-html">&lt;body&gt;
  &lt;button&gt;点击&lt;/button&gt;
  &lt;script&gt;
    const btn = document.querySelector('button')
    function fn() {
      alert('点击了')
    }
    btn.addEventListener('click', fn)
    // L2 事件移除解绑
    btn.removeEventListener('click', fn)
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
           <div> 
            <span style="color:#c00000;"><strong>注意：匿名函数无法被解绑</strong></span> 
           </div> 
           <div></div> 
           <div> 
            <h4 id="%E6%8B%93%E5%B1%95%EF%BC%9A%E9%BC%A0%E6%A0%87%E7%BB%8F%E8%BF%87%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E4%B8%A4%E7%A7%8D%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span style="color:#ad2a26;">拓展：鼠标经过事件的区别、<strong>两种注册事件的区别</strong></span></h4> 
            <div> 
             <strong><span style="color:#262626;">鼠标经过事件：</span></strong> 
            </div> 
            <div></div> 
            <div> 
             <span style="color:#262626;"><strong>● </strong>mouseover 和 mouseout 会有冒泡效果 </span> 
            </div> 
            <div> 
             <span style="color:#262626;"><strong>● </strong>mouseenter 和 mouseleave 没有冒泡效果 (推荐)</span> 
            </div> 
            <div></div> 
            <div> 
             <strong><span style="color:#0d0016;">两种注册事件：</span></strong> 
            </div> 
            <div></div> 
            <div> 
             <div> 
              <span style="color:#262626;"><strong>● </strong>传统on注册（L0） </span> 
             </div> 
             <div> 
              <span style="color:#262626;">同一个对象,后面注册的事件会覆盖前面注册(同一个事件) </span> 
             </div> 
             <div> 
              <span style="color:#262626;">直接使用null覆盖偶就可以实现事件的解绑 </span> 
             </div> 
             <div> 
              <span style="color:#262626;">都是冒泡阶段执行的 </span> 
             </div> 
             <div></div> 
             <div> 
              <span style="color:#262626;"><strong>● </strong>事件监听注册（L2） </span> 
             </div> 
             <div> 
              <span style="color:#262626;">语法: addEventListener(事件类型, 事件处理函数, 是否使用捕获) </span> 
             </div> 
             <div> 
              <span style="color:#262626;">后面注册的事件不会覆盖前面注册的事件(同一个事件) </span> 
             </div> 
             <div> 
              <span style="color:#262626;">可以通过第三个参数去确定是在冒泡或者捕获阶段执行 </span> 
             </div> 
             <div> 
              <span style="color:#262626;">必须使用removeEventListener(事件类型, 事件处理函数, 获取捕获或者冒泡阶段) </span> 
             </div> 
             <div> 
              <span style="color:#262626;">匿名函数无法被解绑</span> 
             </div> 
             <div></div> 
             <div> 
              <h3 id="12.%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span style="color:#c00000;">12.事件委托</span></h3> 
              <div> 
               <span style="color:#262626;">事件委托是利用事件流的特征解决一些开发需求的知识技巧。</span> 
              </div> 
              <div></div> 
              <div> 
               <span style="color:#000000;"><strong>优点：</strong>减少注册次数，可以提高程序性能。</span> 
              </div> 
              <div></div> 
              <div> 
               <span style="color:#000000;"><strong>原理：</strong>事件委托其实是利用</span> 
               <span style="color:#be191c;">事件冒泡</span> 
               <span style="color:#000000;">的特点。</span> 
               <span style="color:#be191c;">给</span> 
               <span style="color:#c00000;">父元素注册事件</span> 
               <span style="color:#000000;">，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件。</span> 
              </div> 
              <div></div> 
              <div> 
               <span style="color:#000000;"><strong>实现：</strong></span> 
               <span style="color:#be191c;">事件对象.target. tagName 可以获得真正触发事件的元素 </span> 
               <span style="color:#ffffff;">u</span> 
              </div> 
              <div> 
               <span style="color:#000000;">如：ul.addEventListener('click' , function(){}) </span> 
               <span style="color:#595959;">执行父级点击事件</span> 
              </div> 
              <div></div> 
              <h4 id="%E6%A1%88%E4%BE%8B%EF%BC%9Atab%E6%A0%8F%E5%88%87%E6%8D%A2%E6%94%B9%E9%80%A0"><span style="color:#be191c;">案例：t</span><span style="color:#ad2a26;">ab栏切换改造</span></h4> 
              <div> 
               <div> 
                <strong><span style="color:#262626;">思路： </span></strong> 
               </div> 
               <div> 
                <span style="color:#262626;">①：给 a的父级 注册点击事件，采取事件委托方式 </span> 
               </div> 
               <div> 
                <span style="color:#262626;">②：如果点击的是A , 则进行排他思想，删除添加类，注意判断的方式 利用 e.target.tagName</span> 
               </div> 
               <div> 
                <span style="color:#262626;">③：因为没有索引号了，所以这里我们可以自定义属性data-id，给5个链接添加序号</span> 
               </div> 
               <div> 
                <span style="color:#262626;">④：下面大盒子获取索引号的方式 e.target.dataset.id 号， 然后进行排他思想</span> 
                <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
  &lt;title&gt;tab栏切换&lt;/title&gt;
  &lt;style&gt;
    * {
      margin: 0;
      padding: 0;
    }

    .tab {
      width: 590px;
      height: 340px;
      margin: 20px;
      border: 1px solid #e4e4e4;
    }

    .tab-nav {
      width: 100%;
      height: 60px;
      line-height: 60px;
      display: flex;
      justify-content: space-between;
    }

    .tab-nav h3 {
      font-size: 24px;
      font-weight: normal;
      margin-left: 20px;
    }

    .tab-nav ul {
      list-style: none;
      display: flex;
      justify-content: flex-end;
    }

    .tab-nav ul li {
      margin: 0 20px;
      font-size: 14px;
    }

    .tab-nav ul li a {
      text-decoration: none;
      border-bottom: 2px solid transparent;
      color: #333;
    }

    .tab-nav ul li a.active {
      border-color: #e1251b;
      color: #e1251b;
    }

    .tab-content {
      padding: 0 16px;
    }

    .tab-content .item {
      display: none;
    }

    .tab-content .item.active {
      display: block;
    }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div class="tab"&gt;
    &lt;div class="tab-nav"&gt;
      &lt;h3&gt;每日特价&lt;/h3&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a class="active" href="javascript:;" data-id="0"&gt;精选&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="javascript:;" data-id="1"&gt;美食&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="javascript:;" data-id="2"&gt;百货&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="javascript:;" data-id="3"&gt;个护&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="javascript:;" data-id="4"&gt;预告&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
    &lt;div class="tab-content"&gt;
      &lt;div class="item active"&gt;&lt;img src="./images/tab00.png" alt="" /&gt;&lt;/div&gt;
      &lt;div class="item"&gt;&lt;img src="./images/tab01.png" alt="" /&gt;&lt;/div&gt;
      &lt;div class="item"&gt;&lt;img src="./images/tab02.png" alt="" /&gt;&lt;/div&gt;
      &lt;div class="item"&gt;&lt;img src="./images/tab03.png" alt="" /&gt;&lt;/div&gt;
      &lt;div class="item"&gt;&lt;img src="./images/tab04.png" alt="" /&gt;&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;script&gt;
    // 采取事件委托的形式 tab栏切换
    // 1. 获取 ul 父元素 因为 ul只有一个
    const ul = document.querySelector('.tab-nav ul')
    // 获取 5个 item 
    const items = document.querySelectorAll('.tab-content .item')
    // 2. 添加事件
    ul.addEventListener('click', function (e) {
      // console.log(e.target)  // e.target是我们点击的对象
      // 我们只有点击了 a 才会 进行 添加类和删除类操作 
      // console.log(e.target.tagName)  // e.target.tagName 点击那个对象的 标签名
      if (e.target.tagName === 'A') {
        // console.log('我选的是a')
        // 排他思想 ，先移除原来的active  
        document.querySelector('.tab-nav .active').classList.remove('active')
        //当前元素添加 active  是 e.target
        // this 指向ul 不能用this 
        e.target.classList.add('active')

        // 下面大盒子模块
        // console.log(e.target.dataset.id)
        // 获取的是字符串，需转换为数字
        const i = +e.target.dataset.id
        // 排他思想 ，先移除原来的active 
        document.querySelector('.tab-content .active').classList.remove('active')
        // 对应的大盒子 添加 active 
        // document.querySelector(`.tab-content .item:nth-child(${i + 1})`).classList.add('active')
        items[i].classList.add('active')
      }
    })
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
                <h3 id="13.%E5%85%B6%E4%BB%96%E4%BA%8B%E4%BB%B6"><span style="color:#be191c;">13.其他事件</span></h3> 
                <h4 id="13.1%20%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6"><span style="color:#ad2a26;">13.1 页面加载事件</span></h4> 
                <div> 
                 <strong><span style="color:#262626;">1.外部资源（如图片、外联CSS和JavaScript等）加载完毕时触发的事件 </span></strong> 
                </div> 
                <div></div> 
                <div> 
                 <span style="color:#262626;"><strong>原因：</strong>有些时候需要等页面资源全部处理完了做一些事情，老代码喜欢把 script 写在 head 中，这时候直接找 dom 元素找不到。</span> 
                </div> 
                <div></div> 
                <div> 
                 <span style="color:#262626;"><strong>事件名：</strong></span> 
                 <strong><span style="color:#be191c;">load </span></strong> 
                </div> 
                <div> 
                 <span style="color:#262626;">监听页面所有资源加载完毕：给 window 添加 load 事件</span> 
                </div> 
                <div> 
                 <img alt="" height="137" src="https://images2.imgbox.com/39/e2/WR9I7p1W_o.png" width="666"> 
                </div> 
                <div></div> 
                <div> 
                 <span style="color:#262626;"><strong>● </strong>注意：不光可以监听整个页面资源加载完毕，也可以针对某个资源绑定load事件</span> 
                </div> 
                <div></div> 
                <div> 
                 <div> 
                  <strong><span style="color:#262626;">2.当初始的HTML文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像等完全加载 </span></strong> 
                 </div> 
                 <div></div> 
                 <div> 
                  <span style="color:#262626;"><strong>事件名：</strong></span> 
                  <span style="color:#be191c;"><strong>DOMContentLoaded </strong></span> 
                 </div> 
                 <div> 
                  <span style="color:#262626;">监听页面DOM加载完毕：给 document 添加 DOMContentLoaded 事件</span> 
                 </div> 
                 <div> 
                  <img alt="" height="109" src="https://images2.imgbox.com/e8/77/jfmHp1qQ_o.png" width="828"> 
                 </div> 
                 <div></div> 
                 <h4 id="13.2%20%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6"><span style="color:#ad2a26;">13.2 页面滚动事件</span></h4> 
                 <div> 
                  <span style="color:#262626;"><strong>滚动条在滚动的时候持续触发的事件</strong>。很多网页需要检测用户把页面滚动到某个区域后做一些处理， 比如固定导航栏，比如返回顶部。</span> 
                 </div> 
                 <div></div> 
                 <div> 
                  <strong><span style="color:#262626;">事件名：</span><span style="color:#be191c;">scroll </span></strong> 
                 </div> 
                 <div> 
                  <span style="color:#262626;">监听整个页面滚动：</span> 
                  <img alt="" height="144" src="https://images2.imgbox.com/ce/ef/AENW3KBb_o.png" width="665"> 
                 </div> 
                 <div></div> 
                 <div> 
                  <span style="color:#262626;">一般给 window 或 document 添加 scroll 事件，监听某个元素的内部滚动直接给某个元素加即可。</span> 
                 </div> 
                 <div></div> 
                 <div> 
                  <div> 
                   <strong><span style="color:#ad2a26;">13.2 页面滚动事件-获取位置</span></strong> 
                  </div> 
                  <div></div> 
                  <div> 
                   <div> 
                    <span style="color:#be191c;">scrollLeft</span> 
                    <span style="color:#262626;"> 和 </span> 
                    <span style="color:#be191c;">scrollTop</span> 
                    <span style="color:#262626;">（属性）：</span> 
                   </div> 
                   <div> 
                    <span style="color:#262626;">获取被卷去的大小，获取元素内容往左、往上滚出去看不到的距离，这两个值是可</span> 
                    <span style="color:#c00000;"><strong>读写</strong></span> 
                    <span style="color:#262626;">的。</span> 
                    <img alt="" height="385" src="https://images2.imgbox.com/2c/cc/c95WVUDz_o.png" width="547"> 
                   </div> 
                   <div> 
                    <span style="color:#262626;">尽量在scroll事件里面获取被卷去的距离。</span> 
                   </div> 
                   <div></div> 
                   <div> 
                    <span style="color:#262626;">开发中，我们经常检测页面滚动的距离，比如页面滚动100像素，就可以显示一个元素，或者固定一个元素。</span> 
                    <pre><code class="language-javascript">&lt;script&gt;
    const div = document.querySelector('div')
    // 页面滚动事件
    window.addEventListener('scroll', function () {
      // 获取html元素写法  
      // document.documentElement  
      const n = document.documentElement.scrollTop
      if (n &gt;= 100) {
        div.style.display = 'block'
      } else {
        div.style.display = 'none'
      }
    })
  &lt;/script&gt;</code></pre> 
                    <p><strong>注意：<span style="color:#be191c;">document.documentElement</span></strong><span style="color:#000000;"><strong> </strong>    HTML文档返回对象为HTML元素</span><img alt="" height="131" src="https://images2.imgbox.com/04/78/hos33zpC_o.png" width="245"></p> 
                    <p><strong><span style="color:#ad2a26;">13.2 页面滚动事件-滚动到指定的坐标</span></strong></p> 
                   </div> 
                  </div> 
                 </div> 
                 <div> 
                  <span style="color:#262626;">scrollTo() 方法可把内容滚动到指定的坐标 </span> 
                 </div> 
                 <div></div> 
                 <div> 
                  <span style="color:#262626;"><strong>语法：</strong>元素.scrollTo(x, y)</span> 
                 </div> 
                 <div></div> 
                 <div> 
                  <strong><span style="color:#be191c;">案例：</span><span style="color:#ad2a26;">返回顶部</span></strong> 
                  <pre><code class="language-javascript">    &lt;script&gt;
        // 点击返回页面顶部
        const backTop = document.querySelector('#backTop')
        backTop.addEventListener('click', function () {
            // 可读写
            // document.documentElement.scrollTop = 0
            window.scrollTo(0, 0)
        })
    &lt;/script&gt;</code></pre> 
                  <h4 id="13.3%20%E9%A1%B5%E9%9D%A2%E5%B0%BA%E5%AF%B8%E4%BA%8B%E4%BB%B6"><span style="color:#c00000;">13.3 页面尺寸事件</span></h4> 
                  <p><span style="color:#262626;">会在窗口尺寸改变的时候触发事件：resize</span><img alt="" height="117" src="https://images2.imgbox.com/28/85/30c4XGH2_o.png" width="740"></p> 
                  <div> 
                   <strong><span style="color:#c00000;">13.3 页面尺寸事件-获取元素宽高</span></strong> 
                  </div> 
                  <div></div> 
                  <div> 
                   <span style="color:#262626;">获取元素的可见部分宽高（不包含边框，margin，滚动条等）: </span> 
                   <span style="color:#c00000;">clientWidth和clientHeight</span> 
                   <img alt="" height="308" src="https://images2.imgbox.com/74/81/J4hMmG5g_o.png" width="382"> 
                  </div> 
                  <p><strong><span style="color:#ad2a26;">案例：Rem基准值</span></strong><img alt="" height="350" src="https://images2.imgbox.com/50/3a/9mAzM6nn_o.png" width="672"></p> 
                  <h4 id="13.4%20%E5%85%83%E7%B4%A0%E5%B0%BA%E5%AF%B8%E4%B8%8E%E4%BD%8D%E7%BD%AE"><span style="color:#c00000;">13.4 元素尺寸与位置</span></h4> 
                  <div> 
                   <span style="color:#262626;">就是通过js的方式，得到</span> 
                   <span style="color:#c00000;">元素在页面中的位置</span> 
                  </div> 
                  <div></div> 
                  <div> 
                   <div> 
                    <span style="color:#262626;"><strong>● </strong></span> 
                    <strong><span style="color:#262626;">获取宽高：</span></strong> 
                    <span style="color:#be191c;">offsetWidth和offsetHeight </span> 
                    <span style="color:#0d0016;">（内容 + padding + border）</span> 
                   </div> 
                   <div> 
                    <span style="color:#262626;">获取元素的自身宽高、包含元素自身设置的宽高、padding、border。</span> 
                    <span style="color:#262626;">获取的是数值，方便计算。</span> 
                   </div> 
                   <div> 
                    <span style="color:#262626;"><strong>注意: </strong>获取的是可视宽高, 如果盒子是隐藏的,获取的结果是0 </span> 
                   </div> 
                   <div></div> 
                   <div> 
                    <span style="color:#262626;"><strong>● </strong></span> 
                    <strong><span style="color:#262626;">获取位置：</span></strong> 
                   </div> 
                   <div> 
                    <span style="color:#c00000;">1.offsetLeft和offsetTop </span> 
                   </div> 
                   <div> 
                    <span style="color:#262626;">获取元素距离自己</span> 
                    <span style="color:#be191c;">定位父级元素</span> 
                    <span style="color:#262626;">的左、上距离，</span> 
                    <span style="color:#000000;">如果都没有则以</span> 
                    <span style="color:#be191c;">文档左上角</span> 
                    <span style="color:#000000;">为准。</span> 
                   </div> 
                   <div> 
                    <span style="color:#c00000;">注意：offsetLeft和offsetTop 是只读属性</span> 
                   </div> 
                   <div> 
                    <img alt="" height="272" src="https://images2.imgbox.com/11/8a/VJHRqqfw_o.png" width="662"> 
                   </div> 
                   <p><strong><span style="color:#be191c;"> 案例：</span><span style="color:#b60206;">仿京东固定导航栏案例</span></strong></p> 
                   <pre><code class="language-html">&lt;body&gt;
    &lt;div class="header"&gt;我是顶部导航栏&lt;/div&gt;
    &lt;div class="content"&gt;
        &lt;div class="sk"&gt;秒杀模块&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="backtop"&gt;
        &lt;img src="./images/close2.png" alt=""&gt;
        &lt;a href="javascript:;"&gt;&lt;/a&gt;
    &lt;/div&gt;
    &lt;script&gt;
        const sk = document.querySelector('.sk')
        const header = document.querySelector('.header')
        // 页面滚动事件
        window.addEventListener('scroll', function () {
            // 当页面滚动到 秒杀模块的时候，就改变 头部的 top值
            // 页面被卷去的头部 &gt;=  秒杀模块的位置 offsetTop
            const n = document.documentElement.scrollTop
            header.style.top = n &gt;= sk.offsetTop ? 0 : '-80px'
        })
    &lt;/script&gt;
&lt;/body&gt;</code></pre> 
                  </div> 
                 </div> 
                </div> 
               </div> 
              </div> 
             </div> 
            </div> 
           </div> 
          </div> 
         </div> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<p><strong><span style="color:#b60206;">案例：实现bilibili 点击小滑块移动效果</span></strong></p> 
<pre><code class="language-javascript">  &lt;script&gt;
    // 1. 事件委托的方法 获取父元素 tabs-list
    const list = document.querySelector('.tabs-list')
    const line = document.querySelector('.line')
    // 2. 注册点击事件
    list.addEventListener('click', function (e) {
      // 只有点击了A 才有触发效果
      if (e.target.tagName === 'A') {
        // 得到当前点击元素的位置
        // console.log(e.target.offsetLeft)
        // 把我们点击的a链接盒子的位置  然后移动
        line.style.transform = `translateX(${e.target.offsetLeft}px)`
      }
    })
  &lt;/script&gt;</code></pre> 
<div> 
 <span style="color:#c00000;">2. </span> 
 <span style="color:#be191c;">element.getBoundingClientRect() </span> 
</div> 
<div> 
 <span style="color:#262626;">方法返回元素的大小及其相对于视口的位置 </span> 
</div> 
<div></div> 
<h4 id="%E6%80%BB%E7%BB%93%E2%80%8B%E7%BC%96%E8%BE%91"><span style="color:#c00000;">总结</span><img alt="" height="360" src="https://images2.imgbox.com/60/88/yfNh0hUS_o.png" width="1196"></h4> 
<h4 id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E7%94%B5%E6%A2%AF%E5%AF%BC%E8%88%AA"><span style="color:#b60206;">综合案例：电梯导航</span></h4> 
<pre><code class="language-javascript">  &lt;script&gt;
    // 第一大模块，页面滑动可以显示和隐藏
    (function () {
      // 获取元素
      const entry = document.querySelector('.xtx_entry')
      const elevator = document.querySelector('.xtx-elevator')
      // 1. 当页面滚动大于 300像素，就显示 电梯导航
      // 2. 给页面添加滚动事件
      window.addEventListener('scroll', function () {
        // 被卷去的头部大于 300 
        const n = document.documentElement.scrollTop
        elevator.style.opacity = n &gt;= entry.offsetTop ? 1 : 0
      })

      // 点击返回页面顶部
      const backTop = document.querySelector('#backTop')
      backTop.addEventListener('click', function () {
        // 可读写
        // document.documentElement.scrollTop = 0
        window.scrollTo(0, 0)
      })
    })();

    // 第二第三都放到另外一个执行函数里面
    (function () {
      // 2. 点击页面可以滑动 
      const list = document.querySelector('.xtx-elevator-list')
      list.addEventListener('click', function (e) {
        // console.log(11)
        if (e.target.tagName === 'A' &amp;&amp; e.target.dataset.name) {
          // 排他思想  
          // 先移除原来的类active 
          // 先获取这个active的对象
          const old = document.querySelector('.xtx-elevator-list .active')
          // console.log(old)
          // 判断 如果原来有active类的对象，就移除类，如果开始就没有对象，就不删除，所以不报错
          if (old) old.classList.remove('active')
          // 当前元素添加 active 
          e.target.classList.add('active')
          // 获得自定义属性  new   topic 
          // console.log(e.target.dataset.name)
          // 根据小盒子的自定义属性值 去选择 对应的大盒子
          // console.log(document.querySelector(`.xtx_goods_${e.target.dataset.name}`).offsetTop)
          // 获得对应大盒子的 offsetTop
          const top = document.querySelector(`.xtx_goods_${e.target.dataset.name}`).offsetTop
          // 让页面滚动到对应的位置
          document.documentElement.scrollTop = top

        }
      })

      // 3. 页面滚动，可以根据大盒子选 小盒子 添加 active 类
      window.addEventListener('scroll', function () {
        //  3.1  先移除类 
        // 先获取这个active的对象
        const old = document.querySelector('.xtx-elevator-list .active')
        // console.log(old)
        // 判断 如果原来有active类的对象，就移除类，如果开始就没有对象，就不删除，所以不报错
        if (old) old.classList.remove('active')
        // 3.2 判断页面当前滑动的位置，选择小盒子

        // 获取4个大盒子
        const news = document.querySelector('.xtx_goods_new')
        const popular = document.querySelector('.xtx_goods_popular')
        const brand = document.querySelector('.xtx_goods_brand')
        const topic = document.querySelector('.xtx_goods_topic')
        const n = document.documentElement.scrollTop
        if (n &gt;= news.offsetTop &amp;&amp; n &lt; popular.offsetTop) {
          // 选择第一个小盒子
          document.querySelector('[data-name=new]').classList.add('active')
        } else if (n &gt;= popular.offsetTop &amp;&amp; n &lt; brand.offsetTop) {
          document.querySelector('[data-name=popular]').classList.add('active')
        } else if (n &gt;= brand.offsetTop &amp;&amp; n &lt; topic.offsetTop) {
          document.querySelector('[data-name=brand]').classList.add('active')
        } else if (n &gt;= topic.offsetTop) {
          document.querySelector('[data-name=topic]').classList.add('active')
        }
      })
    })();
  &lt;/script&gt;</code></pre> 
<h3 id="14.%20%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1"><span style="color:#ad2a26;">14. 日期对象</span></h3> 
<div> 
 <span style="color:#262626;"><strong>日期对象：</strong>用来表示时间的对象 </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#404040;"><strong>作用：</strong>可以得到当前系统时间</span> 
</div> 
<div> 
 <div></div> 
 <h4 id="14.1%20%E5%AE%9E%E4%BE%8B%E5%8C%96"><span style="color:#ad2a26;">14.1 实例化 </span></h4> 
 <div> 
  <span style="color:#262626;"><strong>● </strong>在代码中发现了 new 关键字时，一般将这个操作称为</span> 
  <span style="color:#c00000;"><strong>实例化 </strong></span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#262626;"><strong>● </strong>创建一个时间对象并获取时间 </span> 
 </div> 
 <div></div> 
 <div> 
  <p><span style="color:#262626;">获得当前时间：</span></p> 
  <pre><code class="language-javascript">const date = new Date()</code></pre> 
 </div> 
</div> 
<p>获取指定时间：</p> 
<pre><code class="language-javascript">const date = new Date('2023-5-25')</code></pre> 
<h4 id="14.2%20%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span style="color:#ad2a26;">14.2 日期对象方法</span></h4> 
<p><span style="color:#262626;"><strong>使用场景：</strong>因为日期对象返回的数据我们不能直接使用，所以需要转换为实际开发中常用的格式</span><img alt="" height="454" src="https://images2.imgbox.com/cf/be/o4t1bXiU_o.png" width="1160"></p> 
<p><strong><span style="color:#b60206;">案例：页面显示时间</span> </strong></p> 
<pre><code class="language-html">&lt;body&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;script&gt;
    const div = document.querySelector('div')
    function getMyDate() {
      const date = new Date()
      let h = date.getHours()
      let m = date.getMinutes()
      let s = date.getSeconds()
      h = h &lt; 10 ? '0' + h : h
      m = m &lt; 10 ? '0' + m : m
      s = s &lt; 10 ? '0' + s : s
      return `今天是: ${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}号 ${h}:${m}:${s}`
    }

    div.innerHTML = getMyDate()
    setInterval(function () {
      div.innerHTML = getMyDate()
    }, 1000)
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
<h4 id="14.3%20%E6%97%B6%E9%97%B4%E6%88%B3"><span style="color:#ad2a26;">14.3 时间戳</span></h4> 
<div> 
 <span style="color:#262626;"><strong>● 使用场景： </strong>如果计算倒计时效果，前面方法无法直接计算，需要借助于时间戳完成 </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#262626;"><strong>● 时间戳：</strong>是指1970年01月01日00时00分00秒起至现在的</span> 
 <span style="color:#c00000;">毫秒数</span> 
 <span style="color:#262626;">，是一种特殊的计量时间的方式 </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#262626;"><strong>● 算法： </strong></span> 
</div> 
<div> 
 <span style="color:#262626;">将来的时间戳 - 现在的时间戳 = 剩余时间毫秒数</span> 
</div> 
<div> 
 <span style="color:#262626;">剩余时间毫秒数 转换为 剩余时间的 年月日时分秒 就是 倒计时时间 </span> 
</div> 
<div> 
 <span style="color:#262626;">比如：将来时间戳 2000ms - 现在时间戳 1000ms = 1000ms，1000ms 转换为就是 0小时0分1秒</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#262626;"><strong>● </strong><strong>三种方式获取时间戳：</strong></span> 
</div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#404040;">1. </span> 
  <span style="color:#262626;">使用 getTime() 方法</span> 
  <pre><code class="language-javascript">const date = new Date()
console.log(date.getTime())</code></pre> 
  <p><strong>2.简写 +new Date()</strong></p> 
  <p><span style="color:#c00000;">重点记住 +new Date() 因为可以返回当前时间戳或者指定的时间戳</span></p> 
  <pre><code class="language-javascript">console.log(+new Date())</code></pre> 
  <p><span style="color:#404040;">3. </span><span style="color:#262626;">使用 Date.now()</span></p> 
  <pre><code class="language-javascript">console.log(Date.now())</code></pre> 
 </div> 
 <div> 
  <span style="color:#262626;">无需实例化，</span> 
  <span style="color:#c00000;">但是只能得到当前的时间戳， 而前面两种可以返回指定时间的时间戳</span> 
 </div> 
 <div></div> 
 <div> 
  <strong><span style="color:#b60206;">案例：倒计时效果</span></strong> 
 </div> 
 <div> 
  <pre><code class="language-javascript">  &lt;script&gt;
    // 函数封装 getCountTime
    function getCountTime() {
      // 1. 得到当前的时间戳
      const now = +new Date()
      // 2. 得到将来的时间戳
      const last = +new Date('2022-4-1 18:30:00')
      // console.log(now, last)
      // 3. 得到剩余的时间戳 count  记得转换为 秒数
      const count = (last - now) / 1000
      // console.log(count)
      // 4. 转换为时分秒
      // h = parseInt(总秒数 / 60 / 60 % 24)      // 计算小时
      // m = parseInt(总秒数 / 60 % 60)           // 计算分数
      // s = parseInt(总秒数 % 60)                // 计算当前秒数
      // let d = parseInt(count / 60 / 60 / 24)  // 计算当前天数
      let h = parseInt(count / 60 / 60 % 24)
      h = h &lt; 10 ? '0' + h : h
      let m = parseInt(count / 60 % 60)
      m = m &lt; 10 ? '0' + m : m
      let s = parseInt(count % 60)
      s = s &lt; 10 ? '0' + s : s
      console.log(h, m, s)

      // 把时分秒写到对应的盒子里面
      document.querySelector('#hour').innerHTML = h
      document.querySelector('#minutes').innerHTML = m
      document.querySelector('#scond').innerHTML = s
    }
    // 先调用一次
    getCountTime()

    // 开启定时器
    setInterval(getCountTime, 1000)
  &lt;/script&gt;</code></pre> 
  <h3 id="15.%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C"><span style="color:#c00000;">15.节点操作</span></h3> 
  <h4 id="15.1%20DOM%E8%8A%82%E7%82%B9"><span style="color:#ad2a26;">15.1 DOM节点 </span></h4> 
  <div> 
   <span style="color:#262626;"><strong>DOM节点：</strong>DOM树里每一个内容都称之为节点</span> 
   <img alt="" height="244" src="https://images2.imgbox.com/11/59/9u0cv7Er_o.png" width="587"> 
  </div> 
  <div> 
   <strong><span style="color:#404040;">节点类型：</span></strong> 
  </div> 
  <div> 
   <span style="color:#be191c;"><strong>● </strong></span> 
   <span style="color:#c00000;"><strong>元素节点：</strong></span> 
   <span style="color:#262626;">所有的标签 比如 body、 div，html 是根节点 </span> 
  </div> 
  <div> 
   <span style="color:#262626;"><strong>● </strong>属性节点：所有的属性 比如 href </span> 
  </div> 
  <div> 
   <span style="color:#262626;"><strong>● </strong>文本节点：所有的文本 </span> 
  </div> 
  <div> 
   <span style="color:#262626;"><strong>● </strong>其他 </span> 
  </div> 
  <div></div> 
  <h4 id="15.2%20%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span style="color:#ad2a26;">15.2 查找节点</span></h4> 
  <p><span style="color:#262626;"><strong>节点关系：针对的找亲戚返回的都是对象 </strong>  父节点、子节点、兄弟节点</span></p> 
  <div> 
   <span style="color:#262626;"><strong>父节点查找：</strong></span> 
   <span style="color:#be191c;">parentNode</span> 
   <span style="color:#262626;"> 属性，返回最近一级的父节点 找不到返回为 null</span> 
  </div> 
  <div> 
   <span style="color:#262626;">例如：子元素.parentNode</span> 
  </div> 
  <div> 
   <div></div> 
   <div> 
    <span style="color:#262626;"><strong>子节点查找：</strong></span> 
    <span style="color:#be191c;">childNodes</span> 
    <span style="color:#262626;"> 属性，获得所有子节点、包括文本节点（空格、换行）、注释节点等 </span> 
   </div> 
   <div> 
    <span style="color:#c00000;"><strong>children 属性（重点）</strong></span> 
    <span style="color:#262626;">仅获得所有元素节点，返回的还是一个</span> 
    <span style="color:#be191c;">伪数组，</span> 
    <span style="color:#262626;">例如：父元素.children</span> 
   </div> 
   <div></div> 
   <div> 
    <div> 
     <span style="color:#262626;"><strong>兄弟关系查找： </strong></span> 
    </div> 
    <div> 
     <span style="color:#262626;">1. 下一个兄弟节点：</span> 
     <span style="color:#be191c;">nextElementSibling</span> 
     <span style="color:#262626;"> 属性 </span> 
    </div> 
    <div> 
     <span style="color:#262626;">2. 上一个兄弟节点：</span> 
     <span style="color:#be191c;">previousElementSibling</span> 
     <span style="color:#262626;"> 属性</span> 
    </div> 
    <div></div> 
    <h4 id="15.3%20%E5%A2%9E%E5%8A%A0%E8%8A%82%E7%82%B9"><span style="color:#ad2a26;">15.3 增加节点</span></h4> 
    <div> 
     <span style="color:#262626;"><strong>1.创建节点：</strong>创造出一个新的网页元素，再添加到网页内，一般先创建节点，然后插入节点 </span> 
    </div> 
    <div></div> 
    <div> 
     <strong><span style="color:#262626;">创建元素节点方法：</span></strong> 
     <pre><code class="language-javascript">document.createElement('标签名')</code></pre> 
     <div> 
      <span style="color:#262626;"><strong>2.追加节点：</strong>要想在界面看到，还得插入到某个父元素中 </span> 
     </div> 
     <div></div> 
     <div> 
      <span style="color:#404040;">（1）</span> 
      <span style="color:#262626;">插入到父元素的最后一个子元素：</span> 
      <span style="color:#be191c;">父元素.appendChild(要插入的元素)</span> 
      <p>（2）<span style="color:#262626;">插入到父元素中某个子元素的前面：</span><span style="color:#be191c;">父元素.insertBefore(要插入的元素,在哪个元素前面)</span></p> 
      <p><span style="color:#262626;"><strong>3.克隆节点：</strong></span><span style="color:#be191c;">元素.cloneNode(布尔值)</span></p> 
      <div> 
       <span style="color:#262626;">特殊情况下我们新增节点按如下操作： 复制一个原有的节点，把复制的节点放到指定的元素内部</span> 
      </div> 
      <div></div> 
      <div> 
       <div> 
        <span style="color:#262626;">cloneNode会克隆出一个跟原标签一样的元素，括号内传入布尔值。</span> 
       </div> 
       <div> 
        <span style="color:#262626;">若为true，则克隆时会包含后代节点一起克隆。若为false(默认)，则克隆时不包含后代节点。</span> 
       </div> 
       <div></div> 
       <h4 id="15.4%20%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span style="color:#ad2a26;">15.4 删除节点</span></h4> 
      </div> 
      <div> 
       <div> 
        <span style="color:#262626;">在 JavaScript 原生 DOM 操作中，要删除元素必须通过</span> 
        <span style="color:#c00000;">父元素删除。</span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#262626;"><strong>语法：</strong></span> 
        <span style="color:#be191c;">父元素.removeChlid(子元素)</span>， 
        <span style="color:#262626;">如不存在父子关系则删除不成功 </span> 
       </div> 
       <div> 
        <div></div> 
        <div> 
         <span style="color:#262626;">删除节点和隐藏节点（display:none） 是有区别的： </span> 
        </div> 
        <div> 
         <span style="color:#262626;">隐藏节点还是存在的，但是删除，则从html中删除节点</span> 
        </div> 
        <div></div> 
        <h3 id="16.%20M%E7%AB%AF%E4%BA%8B%E4%BB%B6"><span style="color:#ad2a26;">16. M端事件</span></h3> 
        <div> 
         <span style="color:#000000;">移动端也有自己独特的地方。比如</span> 
         <span style="color:#ff0000;">触屏事件 touch</span> 
         <span style="color:#000000;">（也称触摸事件），Android 和 IOS 都有。 </span> 
        </div> 
        <div></div> 
        <div> 
         <span style="color:#000000;">touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。 </span> 
        </div> 
        <div></div> 
        <div> 
         <span style="color:#000000;">常见的触屏事件如下：</span> 
         <img alt="" height="196" src="https://images2.imgbox.com/43/e7/2wJosbRy_o.png" width="972"> 
        </div> 
        <h3 id="17.%E6%8F%92%E4%BB%B6%C2%A0"><span style="color:#ad2a26;">17.插件</span> </h3> 
        <div> 
         <span style="color:#262626;"><strong>插件: </strong>就是别人写好的一些代码,我们只需要复制对应的代码,就可以直接实现对应的效果 </span> 
        </div> 
        <div></div> 
        <div> 
         <strong><span style="color:#262626;">学习插件的基本过程 </span></strong> 
        </div> 
        <div> 
         <span style="color:#404040;">1.</span> 
         <span style="color:#262626;">熟悉官网，了解这个插件可以完成什么需求   https://www.swiper.com.cn/ </span> 
        </div> 
        <div> 
         <span style="color:#404040;">2.</span> 
         <span style="color:#262626;">看在线演示，找到符合自己需求的demo    https://www.swiper.com.cn/demo/index.html </span> 
        </div> 
        <div> 
         <span style="color:#404040;">3.</span> 
         <span style="color:#262626;">查看基本使用流程    https://www.swiper.com.cn/usage/index.html </span> 
        </div> 
        <div> 
         <span style="color:#404040;">4.</span> 
         <span style="color:#262626;">查看APi文档，去配置自己的插件    https://www.swiper.com.cn/api/index.html </span> 
        </div> 
        <div> 
         <span style="color:#262626;">注意：多个swiper同时使用的时候， 类名需要注意区分</span> 
        </div> 
        <div></div> 
        <div> 
         <h3 id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E8%A1%A8"><span style="color:#b60206;">综合案例：学生信息表</span></h3> 
         <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt;
    &lt;title&gt;学生信息管理&lt;/title&gt;
    &lt;link rel="stylesheet" href="css/index.css" /&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;h1&gt;新增学员&lt;/h1&gt;
    &lt;form class="info" autocomplete="off"&gt;
        姓名：&lt;input type="text" class="uname" name="uname" /&gt;
        年龄：&lt;input type="text" class="age" name="age" /&gt;
        性别:
        &lt;select name="gender" class="gender"&gt;
            &lt;option value="男"&gt;男&lt;/option&gt;
            &lt;option value="女"&gt;女&lt;/option&gt;
        &lt;/select&gt;
        薪资：&lt;input type="text" class="salary" name="salary" /&gt;
        就业城市：&lt;select name="city" class="city"&gt;
            &lt;option value="北京"&gt;北京&lt;/option&gt;
            &lt;option value="上海"&gt;上海&lt;/option&gt;
            &lt;option value="广州"&gt;广州&lt;/option&gt;
            &lt;option value="深圳"&gt;深圳&lt;/option&gt;
            &lt;option value="曹县"&gt;曹县&lt;/option&gt;
        &lt;/select&gt;
        &lt;button class="add"&gt;录入&lt;/button&gt;
    &lt;/form&gt;

    &lt;h1&gt;就业榜&lt;/h1&gt;
    &lt;table&gt;
        &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;学号&lt;/th&gt;
                &lt;th&gt;姓名&lt;/th&gt;
                &lt;th&gt;年龄&lt;/th&gt;
                &lt;th&gt;性别&lt;/th&gt;
                &lt;th&gt;薪资&lt;/th&gt;
                &lt;th&gt;就业城市&lt;/th&gt;
                &lt;th&gt;操作&lt;/th&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
            &lt;!-- 
        &lt;tr&gt;
          &lt;td&gt;1001&lt;/td&gt;
          &lt;td&gt;欧阳霸天&lt;/td&gt;
          &lt;td&gt;19&lt;/td&gt;
          &lt;td&gt;男&lt;/td&gt;
          &lt;td&gt;15000&lt;/td&gt;
          &lt;td&gt;上海&lt;/td&gt;
          &lt;td&gt;
            &lt;a href="javascript:"&gt;删除&lt;/a&gt;
          &lt;/td&gt;
        &lt;/tr&gt; 
        --&gt;
        &lt;/tbody&gt;
    &lt;/table&gt;
    &lt;script&gt;
        // 获取元素
        const uname = document.querySelector('.uname')
        const age = document.querySelector('.age')
        const gender = document.querySelector('.gender')
        const salary = document.querySelector('.salary')
        const city = document.querySelector('.city')
        const tbody = document.querySelector('tbody')
        // 获取所有带有name属性的元素
        const items = document.querySelectorAll('[name]')
        // 声明一个空的数组， 增加和删除都是对这个数组进行操作
        const arr = []
        // 1. 录入模块
        // 1.1 表单提交事件
        const info = document.querySelector('.info')
        info.addEventListener('submit', function (e) {
            // 阻止默认行为 不跳转
            e.preventDefault()

            // 这里进行表单验证  如果不通过，直接中断，不需要添加数据
            // 先遍历循环
            for (let i = 0; i &lt; items.length; i++) {
                if (items[i].value === '') {
                    return alert('输入内容不能为空')
                }
            }

            // 创建新的对象
            const obj = {
                stuId: arr.length + 1,
                uname: uname.value,
                age: age.value,
                gender: gender.value,
                salary: salary.value,
                city: city.value
            }
            // console.log(obj)
            // 追加给数组里面
            arr.push(obj)
            // 清空表单   reset重置
            this.reset()
            // 调用渲染函数
            render()
        })

        // 2.渲染函数 因为增加和删除都需要渲染
        function render() {
            // 先清空tbody以前的行，把最新数组里面的数据渲染完毕
            tbody.innerHTML = ''
            // 遍历arr数组
            for (let i = 0; i &lt; arr.length; i++) {
                // 生成tr
                const tr = document.createElement('tr')
                tr.innerHTML = `
                    &lt;td&gt;${arr[i].stuId}&lt;/td&gt;
                    &lt;td&gt;${arr[i].uname}&lt;/td&gt;
                    &lt;td&gt;${arr[i].age}&lt;/td&gt;
                    &lt;td&gt;${arr[i].gender}&lt;/td&gt;
                    &lt;td&gt;${arr[i].salary}&lt;/td&gt;
                    &lt;td&gt;${arr[i].city}&lt;/td&gt;
                    &lt;td&gt;
                        &lt;a href="javascript:" date-id=${i}&gt;删除&lt;/a&gt;
                    &lt;/td&gt;
                `
                // 追加元素  父元素.appendChild(子元素)
                tbody.appendChild(tr)
            }
        }

        // 3.删除操作
        // 3.1 事件委托 tbody
        tbody.addEventListener('click', function (e) {
            if (e.target.tagName === 'A') {
                // 自己的想法 不利用自定义属性
                // arr.splice(e.target.stuId - 1, 1)
                // 得到当前元素的自定义属性 data-id
                // 删除arr数组对应的数据
                arr.splice(e.target.dataset.id, 1)
                // 重新渲染
                render()
            }
        })
    &lt;/script&gt;

&lt;/body&gt;

&lt;/html&gt;</code></pre> 
         <h3 id="18.%20%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81"><span style="color:#ad2a26;">18. 重绘和回流</span></h3> 
         <div> 
          <span style="color:#0d0016;">1. 浏览器是如何进行界面渲染的？</span> 
         </div> 
         <div> 
          <div> 
           <span style="color:#0d0016;">a.解析（Parser）HTML，生成DOM树(DOM Tree) </span> 
          </div> 
          <div> 
           <span style="color:#0d0016;">b.同时解析（Parser） CSS，生成样式规则 (Style Rules) </span> 
          </div> 
          <div> 
           <span style="color:#0d0016;">c.根据DOM树和样式规则，生成渲染树(Render Tree) </span> 
          </div> 
          <div> 
           <span style="color:#0d0016;">d.进行布局 Layout(回流/重排):根据生成的渲染树，得到节点的几何信息（位置，大小） </span> 
          </div> 
          <div> 
           <span style="color:#0d0016;">e.进行绘制 Painting(重绘): 根据计算和获取的信息进行整个页面的绘制 </span> 
          </div> 
          <div> 
           <span style="color:#0d0016;">f.Display: 展示在页面上</span> 
          </div> 
          <div></div> 
          <div> 
           <div> 
            <span style="color:#262626;"><strong>回流(重排) </strong></span> 
           </div> 
           <div> 
            <span style="color:#262626;">当 Render Tree 中部分或者全部元素的尺寸、结构、布局等发生改变时，浏览器就会重新渲染部分或全部文档的过程称为</span> 
            <span style="color:#be191c;">回流</span> 
            <span style="color:#262626;">。 </span> 
           </div> 
           <div></div> 
           <div> 
            <span style="color:#262626;"><strong>重绘 </strong></span> 
           </div> 
           <div> 
            <span style="color:#262626;">由于节点(元素)的样式的改变并不影响它在文档流中的位置和文档布局时(比如：color、background-color、outline等)，称为</span> 
            <span style="color:#be191c;">重绘</span> 
            <span style="color:#262626;">。 </span> 
           </div> 
           <div></div> 
           <div> 
            <span style="color:#c00000;"><strong>重绘不一定引起回流，而回流一定会引起重绘。</strong></span> 
           </div> 
           <div></div> 
           <h3 id="19.Window%E5%AF%B9%E8%B1%A1"><span style="color:#c00000;"><strong>19.</strong>Window</span><span style="color:#c00000;">对象</span></h3> 
           <h4 id="19.1%20BOM"><span style="color:#c00000;">19.1 BOM</span></h4> 
           <div> 
            <span style="color:#262626;">BOM(Browser Object Model ) 是浏览器对象模型。</span> 
           </div> 
           <div> 
            <img alt="" height="246" src="https://images2.imgbox.com/ed/32/KLFkqnrt_o.png" width="956"> 
           </div> 
           <p></p> 
           <div> 
            <span style="color:#262626;"><strong>● </strong>window对象是一个全局对象，也可以说是JavaScript中的顶级对象</span> 
           </div> 
           <div> 
            <span style="color:#262626;"><strong>● </strong>像document、alert()、console.log()这些都是window的属性,基本BOM属性和方法都是window的</span> 
           </div> 
           <div> 
            <span style="color:#262626;"><strong>● </strong>所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法 </span> 
           </div> 
           <div> 
            <span style="color:#262626;"><strong>● </strong>window对象下的属性和方法调用的时候可以省略window</span> 
           </div> 
           <div></div> 
           <h4 id="19.2%20%E5%AE%9A%E6%97%B6%E5%99%A8-%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0"><span style="color:#ad2a26;">19.2 定时器-延时函数</span></h4> 
           <div> 
            <span style="color:#262626;">JavaScript 内置的一个用来让代码延迟执行的函数，叫 </span> 
            <span style="color:#be191c;">setTimeout </span> 
           </div> 
           <div></div> 
           <div> 
            <span style="color:#262626;"><strong>语法：</strong></span> 
            <span style="color:#be191c;">setTimeout(回调函数,等待的毫秒数)</span> 
           </div> 
           <div></div> 
           <div> 
            <div> 
             <span style="color:#262626;">setTimeout 仅仅只执行一次，所以可以理解为就是把一段代码延迟执行, 平时省略window </span> 
            </div> 
            <div></div> 
            <div> 
             <span style="color:#262626;"><strong>清除延时函数</strong></span> 
             <span style="color:#262626;">：</span> 
             <pre><code class="language-javascript">let timer = setTimeout(回调函数,等待的毫秒数)
clearTimeout(timer)</code></pre> 
             <div> 
              <span style="color:#262626;"><strong>注意点：</strong></span> 
             </div> 
             <div> 
              <span style="color:#262626;">1.延时器需要等待,所以后面的代码先执行 </span> 
             </div> 
             <div> 
              <span style="color:#404040;">2.</span> 
              <span style="color:#262626;">每一次调用延时器都会产生一个新的延时器</span> 
             </div> 
             <div></div> 
             <div> 
              <div> 
               <span style="color:#262626;"><strong>两种定时器对比：</strong></span> 
               <span style="color:#262626;">执行的次数 </span> 
              </div> 
              <div> 
               <span style="color:#262626;"><strong>● </strong>延时函数: 执行一次 </span> 
              </div> 
              <div> 
               <span style="color:#262626;"><strong>● </strong>间歇函数:每隔一段时间就执行一次，除非手动清除</span> 
              </div> 
              <div></div> 
              <div> 
               <span style="color:#b60206;">案例：5秒钟之后消失的广告</span> 
               <pre><code class="language-html">&lt;body&gt;
  &lt;img src="./images/ad.png" alt=""&gt;
  &lt;script&gt;
    // 1.获取元素
    const img = document.querySelector('img')
    setTimeout(function () {
      img.style.display = 'none'
    }, 5000)
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
               <h4 id="19.3%20JS%20%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span style="color:#ad2a26;">19.3 JS 执行机制</span></h4> 
               <p><span style="color:#262626;">JavaScript 语言的一大特点就是</span><span style="color:#c00000;">单线程</span><span style="color:#262626;">，也就是说，</span><span style="color:#c00000;">同一个时间只能做一件事。 </span></p> 
               <div> 
                <span style="color:#262626;">这是因为 Javascript 这门脚本语言诞生的使命所致——JavaScript 是为处理页面中用户的交互，以及操作 DOM 而诞生的。比如我们对某个 DOM 元素进行添加和删除操作，不能同时进行。 应该先进行添加，之后再删除。 </span> 
               </div> 
               <div></div> 
               <div> 
                <span style="color:#262626;">单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是：如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</span> 
               </div> 
               <div></div> 
               <div> 
                <div> 
                 <span style="color:#262626;">为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程。于是，JS 中出现了</span> 
                 <span style="color:#c00000;">同步</span> 
                 <span style="color:#262626;">和</span> 
                 <span style="color:#c00000;">异步。</span> 
                </div> 
                <div></div> 
                <div> 
                 <div> 
                  <span style="color:#404040;"><strong>同步 </strong></span> 
                 </div> 
                 <div> 
                  <span style="color:#262626;">前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。</span> 
                 </div> 
                 <div> 
                  <span style="color:#262626;">比如做饭的同步做法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。 </span> 
                 </div> 
                 <div></div> 
                 <div> 
                  <span style="color:#404040;"><strong>异步 </strong></span> 
                 </div> 
                 <div> 
                  <span style="color:#262626;">你在做一件事情时，因为这件事情会花费很长时间，在做这件事时，还可以去处理其他事情。</span> 
                 </div> 
                 <div> 
                  <span style="color:#262626;">比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。 </span> 
                 </div> 
                 <div></div> 
                 <div> 
                  <span style="color:#c00000;"><strong>他们的本质区别： 这条流水线上各个流程的执行顺序不同。</strong></span> 
                 </div> 
                 <div></div> 
                 <div> 
                  <div> 
                   <span style="color:#404040;"><strong>同步任务 </strong></span> 
                  </div> 
                  <div> 
                   <span style="color:#262626;">同步任务都在主线程上执行，形成一个</span> 
                   <span style="color:#c00000;"><strong>执行栈。 </strong></span> 
                  </div> 
                  <div></div> 
                  <div> 
                   <span style="color:#404040;"><strong>异步任务 </strong></span> 
                  </div> 
                  <div> 
                   <span style="color:#262626;">JS 的异步是通过回调函数实现的。 </span> 
                  </div> 
                  <div> 
                   <span style="color:#262626;">一般而言，异步任务有以下三种类型: </span> 
                  </div> 
                  <div> 
                   <span style="color:#262626;">1、普通事件，如 click、resize 等 </span> 
                  </div> 
                  <div> 
                   <span style="color:#262626;">2、资源加载，如 load、error 等 </span> 
                  </div> 
                  <div> 
                   <span style="color:#262626;">3、定时器，包括 setInterval、setTimeout 等 </span> 
                  </div> 
                  <div> 
                   <span style="color:#262626;">异步任务相关添加到</span> 
                   <span style="color:#c00000;"><strong>任务队列</strong></span> 
                   <span style="color:#262626;">中（任务队列也称为消息队列）。</span> 
                  </div> 
                  <div></div> 
                  <div> 
                   <strong><span style="color:#ad2a26;">JS 执行机制</span></strong> 
                  </div> 
                  <div> 
                   <div> 
                    <span style="color:#262626;">1. 先执行</span> 
                    <span style="color:#c00000;">执行栈中的同步任务</span> 
                    <span style="color:#262626;">。 </span> 
                   </div> 
                   <div> 
                    <span style="color:#262626;">2</span> 
                    <span style="color:#000000;">. 异步任务放入任务队列中。 </span> 
                   </div> 
                   <div> 
                    <span style="color:#262626;">3. 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取</span> 
                    <span style="color:#c00000;">任务队列</span> 
                    <span style="color:#262626;">中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。 </span> 
                   </div> 
                   <div> 
                    <img alt="" height="446" src="https://images2.imgbox.com/bc/61/8DJLER1L_o.png" width="860"> 
                   </div> 
                   <p><img alt="" height="490" src="https://images2.imgbox.com/01/ca/okeee7HL_o.png" width="1143"></p> 
                   <div> 
                    <span style="color:#262626;">由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为</span> 
                    <span style="color:#c00000;">事件循环（event loop）</span> 
                    <span style="color:#262626;">。</span> 
                   </div> 
                   <div></div> 
                   <h4 id="19.4%20location%E5%AF%B9%E8%B1%A1"><span style="color:#ad2a26;">19.4 location对象</span></h4> 
                   <div> 
                    <div> 
                     <span style="color:#262626;">location 的数据类型是对象，它拆分并保存了 URL 地址的各个组成部分。</span> 
                    </div> 
                    <div></div> 
                    <div> 
                     <span style="color:#262626;"><strong>常用属性和方法： </strong></span> 
                    </div> 
                    <div> 
                     <span style="color:#262626;"><strong>● href </strong>属性获取完整的 URL 地址，对其赋值时用于地址的跳转 </span> 
                    </div> 
                    <div> 
                     <img alt="" height="123" src="https://images2.imgbox.com/a9/c1/i712ARS8_o.png" width="448"> 
                    </div> 
                    <div> 
                     <span style="color:#262626;"><strong>● search </strong>属性获取地址中携带的参数，符号 ？后面部分 </span> 
                    </div> 
                    <div> 
                     <span style="color:#262626;"><strong>● hash </strong>属性获取地址中的啥希值，符号 # 后面部分，经常用于不刷新页面，显示不同页面，比如 网易云音乐</span> 
                    </div> 
                    <div> 
                     <span style="color:#262626;"><strong>● reload </strong>方法用来刷新当前页面，传入参数 true 时表示强制刷新，如：</span>location.reload(true) 
                    </div> 
                    <div></div> 
                    <div> 
                     <span style="color:#b60206;">案例：5秒钟之后跳转的页面</span> 
                     <pre><code class="language-html">&lt;body&gt;
  &lt;a href="http://www.itcast.cn"&gt;支付成功&lt;span&gt;5&lt;/span&gt;秒钟之后跳转到首页&lt;/a&gt;
  &lt;script&gt;
    // 1. 获取元素
    const a = document.querySelector('a')
    // 2.开启定时器
    // 3. 声明倒计时变量
    let num = 5
    let timerId = setInterval(function () {
      num--
      a.innerHTML = `支付成功&lt;span&gt;${num}&lt;/span&gt;秒钟之后跳转到首页`
      // 如果num === 0 则停止定时器，并且完成跳转功能
      if (num === 0) {
        clearInterval(timerId)
        // 4. 跳转  location.href
        location.href = 'http://www.itcast.cn'
      }
    }, 1000)
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
                     <h4 id="19.5%20navigator%E5%AF%B9%E8%B1%A1"><span style="color:#ad2a26;">19.5 navigator对象</span></h4> 
                     <div> 
                      <div> 
                       <span style="color:#262626;">navigator的数据类型是对象，该对象下记录了浏览器自身的相关信息 </span> 
                      </div> 
                      <div></div> 
                      <div> 
                       <span style="color:#262626;"><strong>常用属性和方法： </strong>通过 userAgent 检测浏览器的版本及平台</span> 
                       <pre><code class="language-html">// 检测 userAgent（浏览器信息）
!(function () {
const userAgent = navigator.userAgent
// 验证是否为Android或iPhone
const android = userAgent.match(/(Android);?[\s\/]+([\d.]+)?/)
const iphone = userAgent.match(/(iPhone\sOS)\s([\d_]+)/)
// 如果是Android或iPhone，则跳转至移动站点
if (android || iphone) {
location.href = 'http://m.itcast.cn' }
})()</code></pre> 
                       <h4 id="19.6%20histroy%E5%AF%B9%E8%B1%A1"><span style="color:#ad2a26;">19.6 histroy对象</span></h4> 
                       <p></p> 
                       <div> 
                        <span style="color:#262626;">history 的数据类型是对象，主要管理历史记录， 该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等 </span> 
                       </div> 
                       <div></div> 
                       <div> 
                        <span style="color:#262626;"><strong>常用属性和方法</strong></span> 
                        <img alt="" height="240" src="https://images2.imgbox.com/70/d0/WeewGtfg_o.png" width="1199"> 
                       </div> 
                       <h3 id="20.%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span style="color:#c00000;">20.本地存储</span></h3> 
                       <h4 id="20.1%20%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E4%BB%8B%E7%BB%8D"><span style="color:#ad2a26;">20.1 本地存储介绍</span></h4> 
                       <div> 
                        <span style="color:#262626;">随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。 </span> 
                       </div> 
                       <div> 
                        <span style="color:#262626;">1、数据存储在</span> 
                        <span style="color:#c00000;">用户浏览器</span> 
                        <span style="color:#262626;">中 </span> 
                       </div> 
                       <div> 
                        <span style="color:#262626;">2、设置、读取方便、甚至页面刷新不丢失数据 </span> 
                       </div> 
                       <div> 
                        <span style="color:#262626;">3、容量较大，sessionStorage和localStorage约 5M 左右 </span> 
                       </div> 
                       <div> 
                        <span style="color:#262626;">常见的使用场景： </span> 
                        <span style="color:#0000ff;">https://todomvc.com/examples/vanilla-es6/ </span> 
                        <span style="color:#262626;">页面刷新数据不丢失</span> 
                       </div> 
                       <div></div> 
                       <h4 id="20.2%20%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%88%86%E7%B1%BB-%20localStorage"><span style="color:#ad2a26;">20.2 本地存储分类- localStorage</span></h4> 
                       <div> 
                        <span style="color:#262626;"><strong>作用: </strong></span> 
                        <span style="color:#262626;">可以将数据永久存储在本地(用户的电脑), 除非手动删除，否则关闭页面也会存在 </span> 
                       </div> 
                       <div></div> 
                       <div> 
                        <span style="color:#262626;"><strong>特性： </strong>可以多窗口（页面）共享（同一浏览器可以共享）、以键值对的形式存储使用</span> 
                       </div> 
                       <div></div> 
                       <div> 
                        <div> 
                         <span style="color:#262626;"><strong>语法: </strong></span> 
                        </div> 
                        <div> 
                         <span style="color:#262626;">存储数据：</span> 
                         <span style="color:#000000;">localStorage.setItem(key, value) </span> 
                        </div> 
                        <div> 
                         <div> 
                          <span style="color:#262626;">获取数据：</span> 
                          <span style="color:#000000;">localStorage.getItem(key) </span> 
                         </div> 
                         <div> 
                          <div> 
                           <span style="color:#000000;">删除数据：localStorage.removeItem(key)</span> 
                          </div> 
                          <div></div> 
                          <h4 id="20.2%20%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%88%86%E7%B1%BB-%20sessionStorage"><span style="color:#ad2a26;">20.2 本地存储分类- sessionStorage</span></h4> 
                          <div> 
                           <div> 
                            <span style="color:#262626;"><strong>特性： </strong></span> 
                           </div> 
                           <div> 
                            <span style="color:#262626;">生命周期为关闭浏览器窗口 </span> 
                           </div> 
                           <div> 
                            <span style="color:#262626;">在同一个窗口(页面)下数据可以共享 </span> 
                           </div> 
                           <div> 
                            <span style="color:#262626;">以键值对的形式存储使用 </span> 
                           </div> 
                           <div> 
                            <span style="color:#262626;">用法跟</span> 
                            <span style="color:#000000;">localStorage 基本相同</span> 
                           </div> 
                           <div></div> 
                           <div> 
                            <h4 id="20.3%20%E5%AD%98%E5%82%A8%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span style="color:#ad2a26;">20.3 存储复杂数据类型</span></h4> 
                            <div> 
                             <span style="color:#262626;">本地只能存储字符串,无法存储复杂数据类型。</span> 
                            </div> 
                            <div> 
                             <div></div> 
                             <div> 
                              <span style="color:#262626;"><strong>解决：</strong></span> 
                              <span style="color:#262626;">需要将复杂数据类型转换成JSON字符串,在存储到本地 </span> 
                             </div> 
                             <div></div> 
                             <div> 
                              <span style="color:#262626;"><strong>语法：JSON.stringify(复杂数据类型)</strong></span> 
                              <img alt="" height="581" src="https://images2.imgbox.com/33/31/rUF2blYH_o.png" width="1200"> 
                             </div> 
                             <p><span style="color:#262626;"><strong>问题：</strong>因为本地存储里面取出来的是字符串，不是对象，无法直接使用</span></p> 
                             <div> 
                              <span style="color:#262626;"><strong>解决：</strong></span> 
                              <span style="color:#262626;">把取出来的字符串转换为对象 </span> 
                             </div> 
                             <div></div> 
                             <div> 
                              <span style="color:#262626;"><strong>语法：JSON.parse(JSON字符串)</strong></span> 
                             </div> 
                             <p><img alt="" height="565" src="https://images2.imgbox.com/35/d0/S7GloJQs_o.png" width="1113"></p> 
                             <h3 id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%AD%A6%E7%94%9F%E5%B0%B1%E4%B8%9A%E4%BF%A1%E6%81%AF%E8%A1%A8%C2%A0"><span style="color:#b60206;"><strong>综合案例：学生就业信息表</strong></span> </h3> 
                             <div> 
                              <span style="color:#ad2a26;"><strong>拓展1：数组中map方法</strong></span> 
                             </div> 
                             <div></div> 
                             <div> 
                              <span style="color:#262626;"><strong>作用：</strong>迭代数组 </span> 
                             </div> 
                             <div> 
                              <span style="color:#262626;"><strong>语法：</strong></span> 
                              <pre><code class="language-javascript">const arr = ['red', 'blue', 'green']
    // map 方法也是遍历  处理数据  可以返回一个数组
    const newArr = arr.map(function (item, i) {
      // console.log(item)  // 数组元素  'red'
      // console.log(i)  // 下标
      return item + '老师'
    })
    console.log(newArr)  // ['red老师', 'blue老师', 'green老师']</code></pre> 
                              <div> 
                               <span style="color:#262626;"><strong>使用场景：</strong>map 可以处理数据，并且</span> 
                               <span style="color:#c00000;"><strong>返回新的数组</strong></span> 
                              </div> 
                              <div></div> 
                              <div> 
                               <div> 
                                <strong><span style="color:#ad2a26;">拓展2：数组中join方法 </span></strong> 
                               </div> 
                               <div></div> 
                               <div> 
                                <span style="color:#262626;"><strong>作用： </strong>join() 方法用于把数组中的所有元素转换一个字符串 </span> 
                               </div> 
                               <div></div> 
                               <div> 
                                <span style="color:#262626;"><strong>语法：</strong></span> 
                                <pre><code class="language-javascript">&lt;script&gt;
    const arr = ['red', 'blue', 'green']
    // 把数组元素转换为字符串
    console.log(arr.join(' ')) 
  &lt;/script&gt;</code></pre> 
                                <div> 
                                 <span style="color:#262626;"><strong>参数： </strong>数组元素是通过参数里面指定的分隔符进行分隔的</span> 
                                </div> 
                                <div></div> 
                                <div> 
                                 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt;
    &lt;title&gt;学生信息管理&lt;/title&gt;
    &lt;link rel="stylesheet" href="css/index.css" /&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;h1&gt;新增学员&lt;/h1&gt;
    &lt;form class="info" autocomplete="off"&gt;
        姓名：&lt;input type="text" class="uname" name="uname" /&gt;
        年龄：&lt;input type="text" class="age" name="age" /&gt;
        性别:
        &lt;select name="gender" class="gender"&gt;
            &lt;option value="男"&gt;男&lt;/option&gt;
            &lt;option value="女"&gt;女&lt;/option&gt;
        &lt;/select&gt;
        薪资：&lt;input type="text" class="salary" name="salary" /&gt;
        就业城市：&lt;select name="city" class="city"&gt;
            &lt;option value="北京"&gt;北京&lt;/option&gt;
            &lt;option value="上海"&gt;上海&lt;/option&gt;
            &lt;option value="广州"&gt;广州&lt;/option&gt;
            &lt;option value="深圳"&gt;深圳&lt;/option&gt;
            &lt;option value="曹县"&gt;曹县&lt;/option&gt;
        &lt;/select&gt;
        &lt;button class="add"&gt;录入&lt;/button&gt;
    &lt;/form&gt;

    &lt;h1&gt;就业榜&lt;/h1&gt;

    &lt;table&gt;
        &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;学号&lt;/th&gt;
                &lt;th&gt;姓名&lt;/th&gt;
                &lt;th&gt;年龄&lt;/th&gt;
                &lt;th&gt;性别&lt;/th&gt;
                &lt;th&gt;薪资&lt;/th&gt;
                &lt;th&gt;就业城市&lt;/th&gt;
                &lt;th&gt;操作&lt;/th&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
            &lt;!-- 
        &lt;tr&gt;
          &lt;td&gt;1001&lt;/td&gt;
          &lt;td&gt;欧阳霸天&lt;/td&gt;
          &lt;td&gt;19&lt;/td&gt;
          &lt;td&gt;男&lt;/td&gt;
          &lt;td&gt;15000&lt;/td&gt;
          &lt;td&gt;上海&lt;/td&gt;
          &lt;td&gt;
            &lt;a href="javascript:"&gt;删除&lt;/a&gt;
          &lt;/td&gt;
        &lt;/tr&gt; 
        --&gt;
        &lt;/tbody&gt;
    &lt;/table&gt;
    &lt;script&gt;
        // 参考数据
        const initData = [
            {
                stuId: 1001,
                uname: '欧阳霸天',
                age: 19,
                gender: '男',
                salary: '20000',
                city: '上海',
            }
        ]
        // localStorage.setItem('data', JSON.stringify(initData))
        // 1.渲染业务
        // 1.1 读取本地存储的数据   student-data  本地存储的命名
        // (1) 本地存储有数据则记得转换为对象然后存储到变量里面，后期用于渲染页面
        // (2) 如果没有数据，则用空数组来替代
        const arr = JSON.parse(localStorage.getItem('data')) || []
        // 1.2 利用map和join方法来渲染页面
        const tbody = document.querySelector('tbody')
        function render() {
            // (1) 利用map遍历数组，返回对应tr的数组
            const trArr = arr.map(function (ele, index) {
                return `
                &lt;tr&gt;
                    &lt;td&gt;${ele.stuId}&lt;/td&gt;
                    &lt;td&gt;${ele.uname}&lt;/td&gt;
                    &lt;td&gt;${ele.age}&lt;/td&gt;
                    &lt;td&gt;${ele.gender}&lt;/td&gt;
                    &lt;td&gt;${ele.salary}&lt;/td&gt;
                    &lt;td&gt;${ele.city}&lt;/td&gt;
                    &lt;td&gt;
                        &lt;a href="javascript:" data-id='${index}'&gt;删除&lt;/a&gt;
                    &lt;/td&gt;
                &lt;/tr&gt; 
                `
            })
            // (2) 把数组转换为字符串 join
            // (3) 把生成的字符串追加给tbody
            tbody.innerHTML = trArr.join('')
        }
        render()

        // 2.新增业务
        // 2.1 form表单注册提交事件，阻止默认行为
        const info = document.querySelector('.info')
        const uname = document.querySelector('.uname')
        const age = document.querySelector('.age')
        const salary = document.querySelector('.salary')
        const gender = document.querySelector('.gender')
        const city = document.querySelector('.city')
        info.addEventListener('submit', function (e) {
            e.preventDefault()
            // 2.2 非空判断
            if (!uname.value || !age.value || !salary.value) {
                return alert('输入内容不能为空')
            }
            // 2.3 给arr数组追加对象，里面存储 表单获取过来的数据
            arr.push({
                stuId: arr.length ? arr[arr.length - 1].stuId + 1 : 1,
                uname: uname.value,
                age: age.value,
                gender: gender.value,
                salary: salary.value,
                city: city.value,
            })
            // 2.4 渲染页面和重置表单reset()方法
            render()
            this.reset()
            // 2.5 把数组重新存入本地存储里面，记得转换为JSON字符串存储
            localStorage.setItem('data', JSON.stringify(arr))
        })

        // 3.删除业务
        // 3.1 采用事件委托形式，给tbody注册点击事件
        tbody.addEventListener('click', function (e) {
            if (e.target.tagName === 'A') {
                // 3.2 得到当前点击的索引号。渲染数据时，动态给a链接添加自定义属性data-id
                console.log(e.target.dataset.id)
                // 确认框confirm 确认是否要真的删除
                if (confirm('您确定要删除这条数据吗？')) {
                    // 3.3 根据索引号，利用splice删除数组这条数据
                    arr.splice(e.target.dataset.id, 1)
                    // 3.4 重新渲染页面
                    render()
                    // 3.5 把最新arr数组存入本地存储
                    localStorage.setItem('data', JSON.stringify(arr))
                }
            }
        })

    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre> 
                                 <h3 id="21.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span style="color:#c00000;">21.正则表达式</span></h3> 
                                 <h4 id="21.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span style="color:#ad2a26;">21.1 什么是正则表达式 </span></h4> 
                                 <div> 
                                  <span style="color:#be191c;">正则表达式</span> 
                                  <span style="color:#262626;">（Regular Expression）是用于</span> 
                                  <span style="color:#be191c;">匹配字符串中字符组合</span> 
                                  <span style="color:#262626;">的模式。在 JavaScript中，正则表达式也是对象。通常用来查找、替换那些符合正则表达式的文本，许多语言都支持正则表达式。 </span> 
                                 </div> 
                                 <div></div> 
                                 <div> 
                                  <div> 
                                   <span style="color:#262626;">正则表达式在 JavaScript中的<strong>使用场景</strong>： </span> 
                                  </div> 
                                  <div> 
                                   <span style="color:#404040;">1.</span> 
                                   <span style="color:#262626;">例如</span> 
                                   <span style="color:#fe2c24;">验证表单</span> 
                                   <span style="color:#262626;">：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文。</span> 
                                   <span style="color:#262626;">(</span> 
                                   <span style="color:#ff0000;">匹配</span> 
                                   <span style="color:#262626;">)<span style="color:#262626;"> </span>，比如用户名: /^[a-z0-9_-]{3,16}$/ </span> 
                                  </div> 
                                  <div> 
                                   <span style="color:#404040;">2.</span> 
                                   <span style="color:#262626;">过滤掉页面内容中的一些</span> 
                                   <span style="color:#fe2c24;">敏感词</span> 
                                   <span style="color:#262626;">(</span> 
                                   <span style="color:#ff0000;">替换</span> 
                                   <span style="color:#262626;">)</span> 
                                  </div> 
                                  <div> 
                                   <span style="color:#262626;">3.从字符串中获取我们想要的特定部分(</span> 
                                   <span style="color:#ff0000;">提取</span> 
                                   <span style="color:#262626;">)等 。</span> 
                                  </div> 
                                  <div></div> 
                                  <h4 id="21.2%20%E8%AF%AD%E6%B3%95"><span style="color:#ad2a26;">21.2 语法</span></h4> 
                                  <div> 
                                   <span style="color:#262626;"><strong>1. 定义正则表达式语法：</strong></span> 
                                   <span style="color:#be191c;">const 变量名 = /表达式/</span> 
                                  </div> 
                                  <div> 
                                   <div> 
                                    <span style="color:#262626;">其中 / / 是正则表达式字面量，比如：const reg = /前端/</span> 
                                   </div> 
                                   <div></div> 
                                   <div> 
                                    <div> 
                                     <span style="color:#262626;"><strong>2.判断是否有符合规则的字符串： </strong></span> 
                                    </div> 
                                    <div> 
                                     <span style="color:#c00000;"><strong>test() </strong></span> 
                                     <span style="color:#262626;">方法 用来查看正则表达式与指定的字符串是否匹配</span> 
                                    </div> 
                                    <div> 
                                     <span style="color:#262626;"><strong>语法：</strong></span> 
                                     <span style="color:#be191c;">regObj.test(被检测的字符串)  </span> 
                                     <div> 
                                      <span style="color:#262626;">如果正则表达式与指定的字符串匹配 ，返回true，否则false</span> 
                                     </div> 
                                     <pre><code class="language-javascript">&lt;script&gt;
    const str = '我们在学习前端，希望学习前端能高薪毕业'
    // 正则表达式使用：
    // 1. 定义规则
    const reg = /前端/
    // 2. 是否匹配
    console.log(reg.test(str))  // true
&lt;/script&gt;</code></pre> 
                                    </div> 
                                   </div> 
                                  </div> 
                                 </div> 
                                </div> 
                               </div> 
                              </div> 
                             </div> 
                            </div> 
                           </div> 
                          </div> 
                         </div> 
                        </div> 
                       </div> 
                      </div> 
                     </div> 
                    </div> 
                   </div> 
                  </div> 
                 </div> 
                </div> 
               </div> 
              </div> 
             </div> 
            </div> 
           </div> 
          </div> 
         </div> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<div> 
 <span style="color:#262626;"><strong>3.检索（查找）符合规则的字符串： </strong></span> 
</div> 
<div> 
 <span style="color:#c00000;"><strong>exec() </strong></span> 
 <span style="color:#262626;">方法 在一个指定字符串中执行一个搜索匹配 </span> 
</div> 
<div> 
 <span style="color:#262626;"><strong>语法：</strong></span> 
 <span style="color:#be191c;">regObj.exec(被检测的字符串)  </span> 
 <div> 
  <span style="color:#262626;">如果匹配成功，exec() 方法返回一个数组，否则返回null</span> 
 </div> 
 <pre><code class="language-javascript">&lt;script&gt;
    const str = '我们在学习前端，希望学习前端能高薪毕业'
    // 正则表达式使用：
    // 1. 定义规则
    const reg = /前端/
    // 2. exec()
    console.log(reg.exec(str))  // 返回数组
  &lt;/script&gt;</code></pre> 
 <p><img alt="" height="177" src="https://images2.imgbox.com/15/a7/TS2hY3UU_o.png" width="511"></p> 
 <div> 
  <strong><span style="color:#000000;">正则表达式检测查找 test方法和exec方法有什么区别？ </span></strong> 
 </div> 
 <div> 
  <span style="color:#262626;"><strong>● </strong></span> 
  <span style="color:#000000;">test方法 用于判断是否有符合规则的字符串，返回的是布尔值 找到返回true，否则false </span> 
 </div> 
 <div> 
  <span style="color:#262626;"><strong>● </strong></span> 
  <span style="color:#000000;">exec方法用于检索（查找）符合规则的字符串，找到返回数组，否则为 null</span> 
 </div> 
 <div></div> 
 <h4 id="21.3%20%E5%85%83%E5%AD%97%E7%AC%A6"><span style="color:#ad2a26;">21.3 元字符</span></h4> 
 <p><span style="color:#262626;"><strong>元字符(特殊字符）:</strong>是一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能。 </span></p> 
 <p><span style="color:#262626;">比如，规定用户只能输入英文26个英文字母，普通字符的话 abcdefghijklm….但是换成元字符写法： [a-z] </span></p> 
 <p><span style="color:#262626;"><strong>参考文档： </strong></span></p> 
 <div> 
  <span style="color:#262626;">MDN：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions </span> 
 </div> 
 <div> 
  <span style="color:#262626;">正则测试工具: </span> 
  <span style="color:#0000ff;">http://tool.oschina.net/regex</span> 
 </div> 
 <div></div> 
 <div> 
  <div> 
   <span style="color:#262626;">为了方便记忆和学习，我们对众多的元字符进行了分类： </span> 
  </div> 
  <div></div> 
  <div> 
   <strong><span style="color:#c00000;">1.边界符（表示位置，开头和结尾，必须用什么开头，用什么结尾） </span></strong> 
  </div> 
  <div></div> 
  <div> 
   <span style="color:#262626;">正则表达式中的边界符（位置符）用来</span> 
   <span style="color:#c00000;">提示字符所处的位置</span> 
   <span style="color:#262626;">，主要有两个字符</span> 
  </div> 
  <div> 
   <img alt="" height="174" src="https://images2.imgbox.com/7d/c9/GQN5emH0_o.png" width="1124"> 
  </div> 
  <p><span style="color:#be191c;">如果 ^ 和 $ 在一起，表示必须是精确匹配。</span> </p> 
  <pre><code class="language-javascript">&lt;script&gt;
    // 元字符
    // 1. 边界符
    console.log(/^哈/.test('哈')) // true
    console.log(/^哈/.test('哈哈')) // true
    console.log(/^哈/.test('二哈')) // false
    console.log(/^哈$/.test('哈')) // true  只有这种情况为true 否则全是false
    console.log(/^哈$/.test('哈哈')) // false
    console.log(/^哈$/.test('二哈')) // false
  &lt;/script&gt;</code></pre> 
  <div> 
   <span style="color:#be191c;"><strong>2.量词 （表示重复次数） </strong></span> 
  </div> 
  <div></div> 
  <div> 
   <span style="color:#262626;">量词用来 </span> 
   <span style="color:#c00000;">设定某个模式出现的次数</span> 
   <img alt="" height="376" src="https://images2.imgbox.com/da/dc/lp7M0nME_o.png" width="1111"> 
  </div> 
  <p><span style="color:#c00000;">注意： 逗号左右两侧千万不要出现空格</span></p> 
  <pre><code class="language-javascript">&lt;script&gt;
    // 元字符
    // 量词 * 类似 &gt;=0 次
    // console.log(/^哈$/.test('哈')) // true
    // console.log(/^哈*$/.test('')) // true
    // console.log(/^哈*$/.test('哈')) // true
    // console.log(/^哈*$/.test('哈哈')) // true
    // console.log(/^哈*$/.test('二哈很傻')) //  false
    // console.log(/^哈*$/.test('哈很傻')) //  false
    // console.log(/^哈*$/.test('哈很哈')) // false
    // console.log('------------------')

    // //  量词 + 类似 &gt;=1 次
    // console.log(/^哈$/.test('哈')) // true
    // console.log(/^哈+$/.test('')) // false
    // console.log(/^哈+$/.test('哈')) // true
    // console.log(/^哈+$/.test('哈哈')) // true
    // console.log(/^哈+$/.test('二哈很傻')) //  false
    // console.log(/^哈+$/.test('哈很傻')) //  false
    // console.log(/^哈+$/.test('哈很哈')) // false
    // console.log('------------------')

    // //  量词 ? 类似  0 || 1
    // console.log(/^哈?$/.test('')) // true
    // console.log(/^哈?$/.test('哈')) // true
    // console.log(/^哈?$/.test('哈哈')) // false
    // console.log(/^哈?$/.test('二哈很傻')) //  false
    // console.log(/^哈?$/.test('哈很傻')) //  false
    // console.log(/^哈?$/.test('哈很哈')) // false

    // 量词 {n} 写几，就必须出现几次
    console.log(/^哈{4}$/.test('哈'))
    console.log(/^哈{4}$/.test('哈哈'))
    console.log(/^哈{4}$/.test('哈哈哈'))
    console.log(/^哈{4}$/.test('哈哈哈哈'))
    console.log(/^哈{4}$/.test('哈哈哈哈哈'))
    console.log(/^哈{4}$/.test('哈哈哈哈哈哈'))
    console.log('------------------')

    // 量词 {n,}   &gt;=n
    console.log(/^哈{4,}$/.test('哈'))
    console.log(/^哈{4,}$/.test('哈哈'))
    console.log(/^哈{4,}$/.test('哈哈哈'))
    console.log(/^哈{4,}$/.test('哈哈哈哈'))
    console.log(/^哈{4,}$/.test('哈哈哈哈哈'))
    console.log(/^哈{4,}$/.test('哈哈哈哈哈哈'))
    console.log('------------------')

    // 量词 {n,m}  逗号左右两侧千万不能有空格    &gt;=n &amp;&amp; &lt;= m
    console.log(/^哈{4,6}$/.test('哈'))
    console.log(/^哈{4,6}$/.test('哈哈'))
    console.log(/^哈{4,6}$/.test('哈哈哈'))
    console.log(/^哈{4,6}$/.test('哈哈哈哈'))
    console.log(/^哈{4,6}$/.test('哈哈哈哈哈'))
    console.log(/^哈{4,6}$/.test('哈哈哈哈哈哈'))
    console.log(/^哈{4,6}$/.test('哈哈哈哈哈哈哈'))
    console.log('------------------')
   
  &lt;/script&gt;</code></pre> 
  <div> 
   <span style="color:#be191c;"><strong>3.字符类 （比如 \d 表示 0~9）</strong></span> 
  </div> 
  <div></div> 
  <div> 
   <div> 
    <span style="color:#404040;">（1） </span> 
    <strong><span style="color:#be191c;">[ ]</span></strong> 
    <span style="color:#262626;"> 匹配字符集合，后面的字符串只要包含[ ]中任意</span> 
    <span style="color:#c00000;"><strong>一个字符</strong></span> 
    <span style="color:#262626;">，都返回 true。</span> 
   </div> 
   <div> 
    <div> 
     <span style="color:#262626;">a.[ ] 里面加上 - 连字符，使用</span> 
     <span style="color:#be191c;">连字符 - 表示一个范围</span> 
     <span style="color:#262626;">。</span> 
    </div> 
    <div> 
     <div> 
      <span style="color:#262626;">比如： </span> 
     </div> 
     <div> 
      <span style="color:#262626;">        [a-z] 表示 </span> 
      <span style="color:#ff0000;">a 到 z </span> 
      <span style="color:#262626;">26个英文字母都可以 </span> 
     </div> 
     <div> 
      <span style="color:#262626;">        [a-zA-Z] 表示大小写都可以 </span> 
     </div> 
     <div> 
      <span style="color:#262626;">        [0-9] 表示 0~9 的数字都可以 </span> 
     </div> 
     <div> 
      <div> 
       <span style="color:#262626;">b.[ ] 里面加上 </span> 
       <span style="color:#be191c;">^ 取反符号 </span> 
      </div> 
      <div> 
       <span style="color:#262626;">比如： [^a-z] 匹配除了小写字母以外的字符 </span> 
      </div> 
      <div> 
       <span style="color:#be191c;">注意要写到中括号里面</span> 
       <pre><code class="language-javascript">  &lt;script&gt;
    // 元字符
    // 字符类   [abc]  只选1个
    console.log(/^[abc]$/.test('a'))  // true
    console.log(/^[abc]$/.test('b'))  // true
    console.log(/^[abc]$/.test('c'))  // true
    console.log(/^[abc]$/.test('ab'))  // false
    console.log(/^[abc]{2}$/.test('ab'))  // true
    console.log('------------------')

    // 字符类   [a-z]  只选1个
    console.log(/^[A-Z]$/.test('p'))  // false
    console.log(/^[A-Z]$/.test('P'))  // true
    console.log(/^[0-9]$/.test(2))  // true
    console.log(/^[a-zA-Z0-9]$/.test(2))  // true
    console.log(/^[a-zA-Z0-9]$/.test('p'))  // true
    console.log(/^[a-zA-Z0-9]$/.test('P'))  // true
    console.log('------------------')
  &lt;/script&gt;
</code></pre> 
      </div> 
      <div> 
       <div> 
        <span style="color:#262626;">（2） </span> 
        <strong><span style="color:#be191c;">. </span></strong> 
        <span style="color:#262626;">匹配除换行符之外的任何单个字符</span> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#262626;">（3）预定义：</span> 
        <span style="color:#262626;">指的是 </span> 
        <span style="color:#c00000;">某些常见模式的简写方式。</span> 
        <img alt="" height="489" src="https://images2.imgbox.com/f5/7e/H0U9SYAf_o.png" width="1099"> 
       </div> 
       <div></div> 
       <div> 
        <span style="color:#b60206;">案例：用户名验证案例</span> 
        <pre><code class="language-html">&lt;body&gt;
    &lt;input type="text"&gt;
    &lt;span&gt;&lt;/span&gt;
    &lt;script&gt;
        // 1. 准备正则
        const reg = /^[a-zA-Z0-9-_]{6,16}$/
        const input = document.querySelector('input')
        const span = input.nextElementSibling
        input.addEventListener('blur', function () {
            // console.log(reg.test(this.value))
            if (reg.test(this.value)) {
                span.innerHTML = '输入正确'
                span.className = 'right'
            } else {
                span.innerHTML = '请输入6~16位的英文数字下划线'
                span.className = 'error'
            }
        })
    &lt;/script&gt;
&lt;/body&gt;</code></pre> 
        <h4 id="21.4%20%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span style="color:#ad2a26;">21.4 修饰符</span></h4> 
        <p></p> 
        <div> 
         <span style="color:#262626;">修饰符约束正则执行的某些细节行为，如是否区分大小写、是否支持多行匹配等 </span> 
        </div> 
        <div></div> 
        <div> 
         <span style="color:#262626;"><strong>语法：</strong>/表达式/修饰符</span> 
        </div> 
        <div></div> 
        <div> 
         <div> 
          <strong><span style="color:#be191c;">i </span></strong> 
          <span style="color:#262626;">是单词 ignore 的缩写，</span> 
          <strong><span style="color:#be191c;">正则匹配时字母不区分大小写 </span></strong> 
         </div> 
         <div> 
          <span style="color:#be191c;"><strong>g </strong></span> 
          <span style="color:#262626;">是单词 global 的缩写，</span> 
          <span style="color:#be191c;"><strong>匹配所有满足正则表达式的结果</strong></span> 
         </div> 
         <div></div> 
         <div> 
          <div> 
           <span style="color:#262626;"><strong>替换 replace</strong></span> 
          </div> 
          <div></div> 
          <div> 
           <span style="color:#262626;"><strong>语法：</strong></span> 
           <span style="color:#be191c;">字符串.replace(/正则表达式/,'替换掉文本')</span> 
          </div> 
          <div></div> 
          <div> 
           <span style="color:#be191c;">案例：</span> 
           <span style="color:#b60206;">过滤敏感字</span> 
           <pre><code class="language-html">&lt;body&gt;
  &lt;textarea name="" id="" cols="30" rows="10"&gt;&lt;/textarea&gt;
  &lt;button&gt;发布&lt;/button&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;script&gt;
    const tx = document.querySelector('textarea')
    const btn = document.querySelector('button')
    const div = document.querySelector('div')
    btn.addEventListener('click', function () {
      // console.log(tx.value)
      div.innerHTML = tx.value.replace(/激情|基情/g, '**')
      tx.value = ''
    })
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
           <h3 id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%B0%8F%E5%85%94%E9%B2%9C%E9%A1%B5%E9%9D%A2%E6%B3%A8%E5%86%8C"><span style="color:#b60206;">综合案例：小兔鲜页面注册</span></h3> 
           <pre><code class="language-javascript">&lt;script&gt;
        (function () {
            // 1.发送短信验证码模块
            const code = document.querySelector('.code')
            let flag = true // 通过一个变量来控制   节流阀
            // 1.1 点击事件
            code.addEventListener('click', function () {
                if (flag) {
                    // flag取反，不能第二次点击
                    flag = false
                    let i = 5
                    code.innerHTML = `${i}秒后重新获取`
                    let timerId = setInterval(function () {
                        i--
                        // 这里不能用 this，定时器的调用者指向 window
                        code.innerHTML = `${i}秒后重新获取`
                        if (i === 0) {
                            // 清除定时器
                            clearInterval(timerId)
                            // 重新获取
                            code.innerHTML = `重新获取`
                            // 到时间了，可以开启flag 即可以点击了
                            flag = true
                        }
                    }, 1000)
                }
            })
        })();

        // 2. 验证的是用户名
        // 2.1 获取用户名表单
        const username = document.querySelector('[name=username]')
        // 2.2 使用change事件  值发生变化的时候
        username.addEventListener('change', verifyName)
        // 2.3 封装 verifyName 函数
        function verifyName() {
            const span = username.nextElementSibling
            // 2.4 定义规则  用户名
            const reg = /^[a-zA-Z0-9-_]{6,10}$/
            if (!reg.test(username.value)) {
                span.innerText = '输入不合法，请输入6~10位'
                return false
            }
            // 2.5 合法的 清空span
            span.innerText = ''
            return true
        }

        // 3. 验证的是手机号
        // 3.1 获取手机表单
        const phone = document.querySelector('[name=phone]')
        // 3.2 使用change事件  值发生变化的时候
        phone.addEventListener('change', verifyPhone)
        // 3.3 封装 verifyPhone 函数
        function verifyPhone() {
            const span = phone.nextElementSibling
            // 3.4 定义规则  手机号
            const reg = /^1(3\d|4[5-9]|5[0-35-9]|6[567]|7[0-8]|8\d|9[0-35-9])\d{8}$/
            if (!reg.test(phone.value)) {
                span.innerText = '输入不合法，请输入正确的11位手机号'
                return false
            }
            // 3.5 合法的 清空span
            span.innerText = ''
            return true
        }

        // 4. 验证的是验证码
        // 4.1 获取验证码表单
        const codeInput = document.querySelector('[name=code]')
        // 4.2 使用change事件  值发生变化的时候
        codeInput.addEventListener('change', verifyCode)
        // 4.3 封装 verifyCode 函数
        function verifyCode() {
            const span = codeInput.nextElementSibling
            // 4.4 定义规则  手机号
            const reg = /^\d{6}$/
            if (!reg.test(codeInput.value)) {
                span.innerText = '输入不合法，请输入6位数字'
                return false
            }
            // 4.5 合法的 清空span
            span.innerText = ''
            return true
        }

        // 5. 验证的是密码框
        // 5.1 获取密码框表单
        const password = document.querySelector('[name=password]')
        // 5.2 使用change事件  值发生变化的时候
        password.addEventListener('change', verifyPwd)
        // 5.3 封装 verifyPwd 函数
        function verifyPwd() {
            const span = password.nextElementSibling
            // 5.4 定义规则  手机号
            const reg = /^[a-zA-Z0-9-_]{6,20}$/
            if (!reg.test(password.value)) {
                span.innerText = '输入不合法，请输入6~20位数字'
                return false
            }
            // 5.5 合法的 清空span
            span.innerText = ''
            return true
        }

        // 6. 密码的再次验证
        // 6.1 获取再次验证表单
        const confirm = document.querySelector('[name=confirm]')
        // 6.2 使用change事件  值发生变化的时候
        confirm.addEventListener('change', verifyConfirm)
        // 6.3 封装 verifyConfirm 函数
        function verifyConfirm() {
            const span = confirm.nextElementSibling
            // 6.4 当前表单的值不等于密码框的值 就是错误的
            if (confirm.value !== password.value) {
                span.innerText = '两次密码输入不一致'
                return false
            }
            // 6.5 合法的 清空span
            span.innerText = ''
            return true
        }

        // 7. 同意模块
        const queren = document.querySelector('.icon-queren')
        queren.addEventListener('click', function () {
            // 切换类 toggle 原来有的就删除，没有的就添加
            this.classList.toggle('icon-queren2')
        })

        // 8.表单提交模块
        const form = document.querySelector('form')
        form.addEventListener('submit', function (e) {
            // 判断是否勾选同意模块 ，如果有 icon-queren2说明就勾选了，否则没勾选
            if (!queren.classList.contains('icon-queren2')) {
                alert('请勾选同意协议')
                // return 中止程序，但不阻止提交  所以要阻止提交
                e.preventDefault()
            }
            // 依次判断上面的每个框框是否通过，只有有一个没有通过就阻止
            // 因为每一个都要判断 所以要分开写 如果用 || 只会显示第一个不通过的错误信息
            if (!verifyName()) e.preventDefault()
            if (!verifyPhone()) e.preventDefault()
            if (!verifyCode()) e.preventDefault()
            if (!verifyPwd()) e.preventDefault()
            if (!verifyConfirm()) e.preventDefault()
        })
    &lt;/script&gt;</code></pre> 
           <h3 id="%E9%98%B6%E6%AE%B5%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%B0%8F%E5%85%94%E9%B2%9C%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2"><span style="color:#c00000;">阶段案例：</span><span style="color:#b60206;">小兔鲜登录页面</span></h3> 
           <pre><code class="language-javascript"> &lt;script&gt;
        // 1. tab栏切换 事件委托
        const tab_nav = document.querySelector('.tab-nav')
        const pane = document.querySelectorAll('.tab-pane')
        // 1.1 事件监听
        tab_nav.addEventListener('click', function (e) {
            if (e.target.tagName === 'A') {
                // 取消上一个active
                tab_nav.querySelector('.active').classList.remove('active')
                // 当前元素添加active
                e.target.classList.add('active')

                // 先干掉所有人 for循环
                for (let i = 0; i &lt; pane.length; i++) {
                    pane[i].style.display = 'none'
                }
                // 让对应序号的 pane 显示
                pane[e.target.dataset.id].style.display = 'block'
            }
        })

        // 点击提交模块
        const form = document.querySelector('form')
        const agree = document.querySelector('[name=agree]')
        const username = document.querySelector('[name=username]')
        form.addEventListener('submit', function (e) {
            e.preventDefault()
            // 判断是否勾选同意协议
            if (!agree.checked) {
                return alert('请勾选同意按钮')
            }

            // 记录用户名到本地存储
            localStorage.setItem('xtx-uname', username.value)
            // 跳转到首页
            location.href = './小兔鲜index.html'
        })
    &lt;/script&gt;</code></pre> 
           <h3 id="%E9%98%B6%E6%AE%B5%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%B0%8F%E5%85%94%E9%B2%9C%E9%A6%96%E9%A1%B5%E9%A1%B5%E9%9D%A2"><span style="color:#c00000;">阶段案例：</span><span style="color:#b60206;">小兔鲜首页页面</span></h3> 
           <pre><code class="language-javascript">&lt;script&gt;
        // 1. 获取第一个小li
        const li1 = document.querySelector('.xtx_navs li:first-child')
        const li2 = li1.nextElementSibling
        // 2.最好做个渲染函数 因为退出登录需要重新渲染
        function render() {
            // 2.1 读取本地存储的用户名
            const uname = localStorage.getItem('xtx-uname')
            // console.log(uname);
            if (uname) {
                li1.innerHTML = `&lt;a href="javascript:;"&gt;&lt;i class="iconfont icon-user"&gt; ${uname}&lt;/i&gt;&lt;/a&gt;`
                li2.innerHTML = `&lt;a href="javascript:;"&gt;退出登录&lt;/a&gt;`
            } else {
                li1.innerHTML = `&lt;a href="./小兔鲜login.html"&gt;请先登录&lt;/a&gt;`
                li2.innerHTML = `&lt;a href="./小兔鲜register.html"&gt;免费注册&lt;/a&gt;`
            }
        }
        render()    // 调用函数

        // 2.点击退出登录模块
        li2.addEventListener('click', function () {
            // 删除本地存储的数据
            localStorage.removeItem('xtx-uname')
            // 重新渲染
            render()
        })
    &lt;/script&gt;</code></pre> 
           <h3 id="%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%94%BE%E5%A4%A7%E9%95%9C%E6%95%88%E6%9E%9C"><span style="color:#be191c;">实战案例：放大镜效果</span></h3> 
           <pre><code class="language-javascript">&lt;script&gt;
        // 1. 获取三个盒子
        // 2. 小盒子 图片切换效果
        const small = document.querySelector('.small')
        //  中盒子
        const middle = document.querySelector('.middle')
        //  大盒子
        const large = document.querySelector('.large')
        // 2. 事件委托
        // mouseenter 没有冒泡，因此不能实现事件委托，需要使用 mouseover 通过事件冒泡触发 small
        small.addEventListener('mouseover', function (e) {
            if (e.target.tagName === 'IMG') {
                // 排他思想 干掉以前的active
                this.querySelector('.active').classList.remove('active')
                // 当前元素的爸爸添加 active
                e.target.parentNode.classList.add('active')
                // 拿到当前小图片的src
                // 让中等盒子里面的图片，src更换为小图片的src
                middle.querySelector('img').src = e.target.src
                // 大盒子更换背景图片
                large.style.backgroundImage = `url(${e.target.src})`
            }
        })

        // 3.鼠标经过中等盒子，显示隐藏大盒子
        middle.addEventListener('mouseenter', show)
        middle.addEventListener('mouseleave', hide)
        let timeId = null
        // 显示函数 显示大盒子
        function show() {
            // 先清除定时器
            clearTimeout(timeId)
            large.style.display = 'block'
        }
        // 隐藏函数 隐藏大盒子
        function hide() {
            timeId = setTimeout(function () {
                large.style.display = 'none'
            }, 200)
        }

        // 4.鼠标经过大盒子，显示隐藏大盒子
        large.addEventListener('mouseenter', show)
        large.addEventListener('mouseleave', hide)

        // 5.鼠标经过中等盒子，显示隐藏 黑色遮罩层
        const layer = document.querySelector('.layer')
        middle.addEventListener('mouseenter', function () {
            layer.style.display = 'block'
        })
        middle.addEventListener('mouseleave', function () {
            layer.style.display = 'none'
        })

        // 6.移动黑色遮罩盒子
        middle.addEventListener('mousemove', function (e) {
            // 鼠标在middle 盒子里面的坐标 = 鼠标在页面中的坐标 - middle 中等盒子的坐标 
            // middle 中等盒子的坐标 使用 getBoundingClientRect() 来获取相当于可视区的盒子坐标，不用 offsetLeft 和 offsetTop，因为这两个属性容易被带有定位的父级影响
            // 鼠标在页面中的坐标
            // console.log(e.pageX);
            // middle 中等盒子的坐标
            // console.log(middle.getBoundingClientRect().left);
            let x = e.pageX - middle.getBoundingClientRect().left - document.documentElement.scrollLeft
            let y = e.pageY - middle.getBoundingClientRect().top - document.documentElement.scrollTop
            // console.log(x, y);
            // 黑色遮罩移动在 middle 盒子内限制移动的距离
            if (x &gt;= 0 &amp;&amp; x &lt;= 400 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= 400) {
                // 黑色盒子不是一直移动的
                // 声明2个变量 黑色盒子移动的 mx my 变量
                let mx = 0, my = 0
                if (x &lt; 100) mx = 0
                if (x &gt;= 100 &amp;&amp; x &lt;= 300) mx = x - 100
                if (x &gt; 300) mx = 200

                if (y &lt; 100) my = 0
                if (y &gt;= 100 &amp;&amp; y &lt;= 300) my = y - 100
                if (y &gt; 300) my = 200

                layer.style.left = mx + 'px'
                layer.style.top = my + 'px'

                // 大盒子的背景图片要跟随中等盒子移动 存在的关系是 2倍
                large.style.backgroundPositionX = -2 * mx + 'px'
                large.style.backgroundPositionY = -2 * my + 'px'
            }
        })
    &lt;/script&gt;</code></pre> 
           <h2 id="%E4%B8%89%E3%80%81JS%E8%BF%9B%E9%98%B6"><span style="color:#be191c;">三、JS进阶</span></h2> 
           <h3 id="1.%E4%BD%9C%E7%94%A8%E5%9F%9F"><span style="color:#c00000;">1.作用域</span></h3> 
           <div> 
            <span style="color:#262626;">作用域（scope）规定了变量能够被访问的“范围”，离开了这个“范围”变量便不能被访问， </span> 
           </div> 
           <div></div> 
           <div> 
            <span style="color:#262626;">作用域分为： 局部作用域、</span> 
            <span style="color:#000000;">全局作用域</span> 
           </div> 
           <div></div> 
           <div> 
            <h4 id="1.1%20%E5%B1%80%E9%83%A8%E4%BD%9C%E7%94%A8%E5%9F%9F"><span style="color:#ad2a26;">1.1 局部作用域</span></h4> 
            <div> 
             <span style="color:#000000;">局部作用域分为函数作用域和块作用域。 </span> 
            </div> 
            <div></div> 
            <div> 
             <span style="color:#404040;"><strong>1. </strong></span> 
             <span style="color:#000000;"><strong>函数作用域： </strong></span> 
            </div> 
            <div> 
             <span style="color:#000000;">在函数内部声明的变量只能在函数内部被访问，外部无法直接访问。</span> 
             <img alt="" height="203" src="https://images2.imgbox.com/8b/17/rpDKlzb6_o.png" width="711"> 
            </div> 
            <div> 
             <strong><span style="color:#000000;">总结： </span></strong> 
            </div> 
            <div> 
             <span style="color:#000000;">1. 函数内部声明的变量，在函数外部无法被访问 </span> 
            </div> 
            <div> 
             <span style="color:#000000;">2. 函数的参数也是函数内部的局部变量 </span> 
            </div> 
            <div> 
             <span style="color:#000000;">3. 不同函数内部声明的变量无法互相访问 </span> 
            </div> 
            <div> 
             <span style="color:#000000;">4. 函数执行完毕后，函数内部的变量实际被清空了</span> 
            </div> 
            <p></p> 
            <div> 
             <span style="color:#000000;"><strong>2. 块作用域： </strong></span> 
            </div> 
            <div> 
             <span style="color:#000000;">在JavaScript中使用{ }包裹的代码称为代码块，代码块内部声明的变量外部将</span> 
             <span style="color:#c00000;">有可能</span> 
             <span style="color:#000000;">无法被访问。</span> 
             <img alt="" height="201" src="https://images2.imgbox.com/89/0f/euWQojnG_o.png" width="470"> 
            </div> 
            <div> 
             <strong><span style="color:#000000;">总结： </span></strong> 
            </div> 
            <div> 
             <span style="color:#000000;">1. let 声明的变量会产生块作用域，var 不会产生块作用域 </span> 
            </div> 
            <div> 
             <span style="color:#000000;">2. const 声明的常量也会产生块作用域 </span> 
            </div> 
            <div> 
             <span style="color:#000000;">3. 不同代码块之间的变量无法互相访问 </span> 
            </div> 
            <div> 
             <span style="color:#000000;">4. 推荐使用 let 或 const</span> 
            </div> 
            <div></div> 
            <h4 id="1.2%20%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F"><span style="color:#ad2a26;">1.2 全局作用域</span></h4> 
            <div> 
             <span style="color:#c00000;">&lt;script&gt; 标签 </span> 
             <span style="color:#262626;">和 </span> 
             <span style="color:#c00000;">.js 文件 </span> 
             <span style="color:#262626;">的【最外层】就是全局作用域，在此声明的变量在函数内部也可以被访问。 全局作用域中声明的变量，任何其它作用域都可以被访问。</span> 
             <img alt="" height="270" src="https://images2.imgbox.com/de/5f/KVy9kGbS_o.png" width="423"> 
            </div> 
            <div> 
             <strong><span style="color:#262626;">注意： </span></strong> 
            </div> 
            <div> 
             <span style="color:#262626;">1. 为 window 对象动态添加的属性默认也是全局的，不推荐！ </span> 
            </div> 
            <div> 
             <span style="color:#262626;">2. 函数中未使用任何关键字声明的变量为全局变量，不推荐！！！ </span> 
            </div> 
            <div> 
             <span style="color:#262626;">3. 尽可能少的声明全局变量，防止全局变量被污染</span> 
            </div> 
            <div></div> 
            <div> 
             <div> 
              <span style="color:#000000;">JavaScript 中的作用域是程序被执行时的底层机制，了解这一机制有助于规范代码书写习惯，避免因作用域导致的语法错误。</span> 
             </div> 
             <div></div> 
             <div> 
              <h4 id="1.3%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span style="color:#ad2a26;">1.3 作用域链</span></h4> 
              <div> 
               <span style="color:#000000;">作用域链本质上是底层的</span> 
               <span style="color:#c00000;">变量查找机制</span> 
               <span style="color:#000000;">。 </span> 
              </div> 
              <div></div> 
              <div> 
               <span style="color:#000000;">在函数被执行时，会</span> 
               <span style="color:#c00000;">优先查找当前</span> 
               <span style="color:#000000;">函数作用域中查找变量。如果当前作用域查找不到则会依次</span> 
               <span style="color:#c00000;">逐级查找父级作用域</span> 
               <span style="color:#000000;">直到全局作用域。</span> 
              </div> 
              <div> 
               <img alt="" height="515" src="https://images2.imgbox.com/a8/69/A4gOQGn2_o.png" width="289"> 
               <img alt="" height="246" src="https://images2.imgbox.com/61/60/JJeFcxJL_o.png" width="388"> 
              </div> 
              <div></div> 
              <div> 
               <strong><span style="color:#000000;">总结： </span></strong> 
              </div> 
              <div> 
               <span style="color:#000000;">1. 嵌套关系的作用域串联起来形成了作用域链 </span> 
              </div> 
              <div> 
               <span style="color:#000000;">2. 相同作用域链中按着</span> 
               <span style="color:#be191c;">从小到大</span> 
               <span style="color:#000000;">的规则查找变量 </span> 
              </div> 
              <div> 
               <span style="color:#000000;">3. </span> 
               <span style="color:#be191c;">子作用域能够访问父作用域，父级作用域无法访问子级作用域</span> 
              </div> 
              <div></div> 
              <h4 id="1.4%20JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span style="color:#ad2a26;">1.4 JS垃圾回收机制</span></h4> 
              <div> 
               <span style="color:#000000;"><strong>1. 什么是垃圾回收机制？ </strong></span> 
              </div> 
              <div></div> 
              <div> 
               <span style="color:#262626;">垃圾回收机制(Garbage Collection) 简称 GC </span> 
              </div> 
              <div> 
               <span style="color:#be191c;">JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。</span> 
              </div> 
              <div> 
               <span style="color:#262626;">正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题。</span> 
              </div> 
              <div> 
               <span style="color:#262626;">但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况。</span> 
              </div> 
              <div> 
               <span style="color:#be191c;">不再用到的内存，没有及时释放，</span> 
               <span style="color:#262626;">就叫做</span> 
               <strong><span style="color:#c00000;">内存泄漏。</span></strong> 
              </div> 
              <div></div> 
              <div> 
               <div> 
                <span style="color:#000000;"><strong>2.内存的生命周期 </strong></span> 
               </div> 
               <div></div> 
               <div> 
                <span style="color:#262626;">JS环境中分配的内存, 一般有如下生命周期： </span> 
               </div> 
               <div> 
                <span style="color:#be191c;">1. 内存分配</span> 
                <span style="color:#262626;">：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存 </span> 
               </div> 
               <div> 
                <span style="color:#be191c;">2. 内存使用</span> 
                <span style="color:#262626;">：即读写内存，也就是使用变量、函数等 </span> 
               </div> 
               <div> 
                <span style="color:#be191c;">3. 内存回收</span> 
                <span style="color:#262626;">：使用完毕，由垃圾回收自动回收不再使用的内存 </span> 
               </div> 
               <div> 
                <span style="color:#404040;">4. </span> 
                <span style="color:#262626;">说明：全局变量一般不会回收(关闭页面回收)； </span> 
                <span style="color:#262626;">一般情况下局部变量的值不用了, 会被自动回收</span> 
               </div> 
               <div></div> 
               <h4 id="%E6%8B%93%E5%B1%95-JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-%E7%AE%97%E6%B3%95%E8%AF%B4%E6%98%8E"><span style="color:#ad2a26;">拓展-JS垃圾回收机制-</span><span style="color:#ad2a26;"><strong>算法说明</strong></span></h4> 
               <div> 
                <strong><span style="color:#000000;">堆栈空间分配区别： </span></strong> 
               </div> 
               <div> 
                <span style="color:#000000;">1. 栈 (操作系统) : 由</span> 
                <span style="color:#c00000;">操作系统自动分配释放</span> 
                <span style="color:#000000;">函数的参数值、局部变量等，基本数据类型放到栈里面</span> 
               </div> 
               <div> 
                <span style="color:#000000;">2. 堆 (操作系统) : 一般</span> 
                <span style="color:#be191c;">由程序员分配释放</span> 
                <span style="color:#000000;">，若程序员不释放，由</span> 
                <span style="color:#c00000;">垃圾回收机制</span> 
                <span style="color:#000000;">回收。</span> 
                <span style="color:#c00000;">复杂数据类型</span> 
                <span style="color:#000000;">放到堆里面</span> 
               </div> 
               <div></div> 
               <div> 
                <span style="color:#262626;">两种常见的浏览器</span> 
                <span style="color:#c00000;">垃圾回收算法</span> 
                <span style="color:#262626;">: </span> 
                <span style="color:#c00000;">引用计数法 </span> 
                <span style="color:#262626;">和 </span> 
                <span style="color:#c00000;">标记清除法</span> 
               </div> 
               <div></div> 
               <div> 
                <div> 
                 <span style="color:#262626;"><strong>● </strong></span> 
                 <span style="color:#000000;"><strong>引用计数 </strong></span> 
                </div> 
                <div> 
                 <span style="color:#262626;">IE采用的引用计数算法, 定义“</span> 
                 <span style="color:#c00000;">内存不再使用</span> 
                 <span style="color:#262626;">”，就是看一个</span> 
                 <span style="color:#c00000;">对象</span> 
                 <span style="color:#262626;">是否有指向它的引用，没有引用了就回收对象。</span> 
                </div> 
                <div></div> 
                <div> 
                 <strong><span style="color:#262626;">算法： </span></strong> 
                </div> 
                <div> 
                 <span style="color:#404040;">1. </span> 
                 <span style="color:#262626;">跟踪记录被</span> 
                 <span style="color:#c00000;">引用的次数 </span> 
                </div> 
                <div> 
                 <span style="color:#404040;">2. </span> 
                 <span style="color:#262626;">如果被引用了一次，那么就记录次数1,多次引用会</span> 
                 <span style="color:#c00000;">累加 ++ </span> 
                </div> 
                <div> 
                 <span style="color:#404040;">3. </span> 
                 <span style="color:#262626;">如果减少一个引用就</span> 
                 <span style="color:#c00000;">减1 -- </span> 
                </div> 
                <div> 
                 <span style="color:#404040;">4. </span> 
                 <span style="color:#262626;">如果引用次数是</span> 
                 <span style="color:#c00000;">0 </span> 
                 <span style="color:#262626;">，则释放内存</span> 
                </div> 
                <div></div> 
                <div> 
                 <div> 
                  <span style="color:#262626;">但它却存在一个致命的问题：</span> 
                  <span style="color:#c00000;"><strong>嵌套引用</strong></span> 
                  <span style="color:#262626;">（循环引用） </span> 
                 </div> 
                 <div> 
                  <span style="color:#262626;">如果两个对象</span> 
                  <span style="color:#c00000;">相互引用</span> 
                  <span style="color:#262626;">，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。</span> 
                  <img alt="" height="228" src="https://images2.imgbox.com/fd/62/qRESBrX4_o.png" width="357"> 
                 </div> 
                 <p> <span style="color:#262626;">因为他们的引用次数永远不会是0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露</span></p> 
                 <div> 
                  <span style="color:#262626;"><strong>● </strong></span> 
                  <span style="color:#000000;"><strong>标记清除法 </strong></span> 
                 </div> 
                 <div> 
                  <span style="color:#262626;">现代的浏览器已经不再使用引用计数算法了。 </span> 
                 </div> 
                 <div> 
                  <span style="color:#262626;">现代浏览器通用的大多是基于</span> 
                  <span style="color:#c00000;">标记清除算法</span> 
                  <span style="color:#262626;">的某些改进算法，总体思想都是一致的。 </span> 
                 </div> 
                 <div></div> 
                 <div> 
                  <strong><span style="color:#000000;">核心： </span></strong> 
                 </div> 
                 <div> 
                  <span style="color:#404040;">1. </span> 
                  <span style="color:#262626;">标记清除算法将“不再使用的对象”定义为“</span> 
                  <span style="color:#c00000;">无法达到的对象</span> 
                  <span style="color:#262626;">”。 </span> 
                 </div> 
                 <div> 
                  <span style="color:#404040;">2. </span> 
                  <span style="color:#262626;">就是从</span> 
                  <span style="color:#c00000;">根部</span> 
                  <span style="color:#262626;">（在JS中就是全局对象）出发定时扫描内存中的对象。 凡是能从</span> 
                  <span style="color:#c00000;">根部到达</span> 
                  <span style="color:#262626;">的对象，都是还</span> 
                  <span style="color:#c00000;">需要使用</span> 
                  <span style="color:#262626;">的。 </span> 
                 </div> 
                 <div> 
                  <span style="color:#404040;">3. </span> 
                  <span style="color:#262626;">那些</span> 
                  <span style="color:#c00000;">无法</span> 
                  <span style="color:#262626;">由根部出发触及到的</span> 
                  <span style="color:#c00000;">对象被标记</span> 
                  <span style="color:#262626;">为不再使用，稍后进行</span> 
                  <span style="color:#c00000;">回收</span> 
                  <span style="color:#262626;">。</span> 
                 </div> 
                 <div></div> 
                 <div> 
                  <span style="color:#262626;">对于上面的例子，根部已经访问不到，所以自动清除</span> 
                 </div> 
                 <div></div> 
                 <h4 id="1.5%20%E9%97%AD%E5%8C%85"><span style="color:#ad2a26;">1.5 闭包</span></h4> 
                 <div> 
                  <span style="color:#000000;"><strong>概念：</strong>一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域 </span> 
                 </div> 
                 <div></div> 
                 <div> 
                  <strong><span style="color:#000000;">简单理解：</span></strong> 
                  <span style="color:#262626;"><strong>闭包 =  内层函数 + 外层函数的变量 </strong></span> 
                 </div> 
                 <div></div> 
                 <div> 
                  <div> 
                   <strong><span style="color:#000000;">闭包作用：</span></strong> 
                   <span style="color:#262626;">封闭数据，提供操作，外部也可以访问函数内部的变量 </span> 
                  </div> 
                  <div></div> 
                  <div> 
                   <strong><span style="color:#000000;">闭包的基本格式:</span></strong> 
                   <pre><code class="language-javascript">&lt;script&gt;
    // 简单的写法
    function outer() {
      let a = 10
      function fn() {
        console.log(a)
      }
      fn()
    }
    outer()
&lt;/script&gt;</code></pre> 
                   <pre><code class="language-javascript">&lt;script&gt;
    // 常见的闭包的形式   外部可以访问使用 函数内部的变量
    function outer() {
      let a = 100
      function fn() {
        console.log(a)
      }
      return fn
    }
    // outer()   ===  fn   ===  function fn() {}
    const fun = outer()
    // const fun = function fn() { }
    fun() // 调用函数
&lt;/script&gt;</code></pre> 
                   <pre><code class="language-javascript">&lt;script&gt;
    // 常见的写法2
    function outer() {
      let a = 100
      return function () {
        console.log(a)
      }
    }
    const fun = outer()
    fun() // 调用函数
&lt;/script&gt;</code></pre> 
                   <div> 
                    <span style="color:#be191c;">闭包应用：实现数据的私有 </span> 
                   </div> 
                   <div> 
                    <span style="color:#000000;">比如，我们要做个统计函数调用次数，函数调用一次，就++</span> 
                    <pre><code class="language-javascript">  &lt;script&gt;
    // 闭包的应用
    // 普通形式 统计函数调用的次数
    // let i = 0
    // function fn() {
    //   i++
    //   console.log(`函数被调用了${i}次`)
    // }
    //  因为 i 是全局变量，容易被修改
    // 闭包形式 统计函数调用的次数
    function count() {
      let i = 0
      function fn() {
        i++
        console.log(`函数被调用了${i}次`)
      }
      return fn
    }
    const fun = count()
  &lt;/script&gt;</code></pre> 
                    <p><img alt="" height="358" src="https://images2.imgbox.com/c9/31/xc65eiOf_o.png" width="361"></p> 
                    <p><span style="color:#0d0016;"><strong>闭包的作用：</strong></span></p> 
                    <p><span style="color:#000000;">1.封闭数据，实现数据私有，外部也可以访问函数内部的变量 </span></p> 
                    <div> 
                     <span style="color:#000000;">2.闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来</span> 
                    </div> 
                    <div></div> 
                    <div> 
                     <div> 
                      <span style="color:#be191c;">闭包可能引起的问题：<strong>内存泄漏</strong></span> 
                     </div> 
                     <div></div> 
                     <h4 id="1.6%20%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span style="color:#ad2a26;">1.6 变量提升</span></h4> 
                     <div> 
                      <span style="color:#262626;">变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问（仅存在于 </span> 
                      <span style="color:#be191c;">var </span> 
                      <span style="color:#262626;">声明变量） </span> 
                     </div> 
                     <div></div> 
                     <div> 
                      <strong><span style="color:#262626;">注意： </span></strong> 
                     </div> 
                     <div> 
                      <span style="color:#262626;">1. 变量在未声明即被访问时会报语法错误 </span> 
                     </div> 
                     <div> 
                      <span style="color:#262626;">2. 变量在var声明之前即被访问，变量的值为 undefined </span> 
                     </div> 
                     <div> 
                      <span style="color:#262626;">3. let/const 声明的变量不存在变量提升 </span> 
                     </div> 
                     <div> 
                      <span style="color:#262626;">4. 变量提升出现在相同作用域当中 </span> 
                     </div> 
                     <div> 
                      <span style="color:#262626;">5. </span> 
                      <span style="color:#c00000;">实际开发中推荐先声明再访问变量</span> 
                     </div> 
                     <div></div> 
                     <div> 
                      <div> 
                       <span style="color:#262626;"><strong>说明： </strong></span> 
                      </div> 
                      <div> 
                       <span style="color:#262626;">JS初学者经常花很多时间才能习惯变量提升，还经常出现一些意想不到的bug，正因为如此，ES6 引入了块级作用域，用let 或者 const声明变量，让代码写法更加规范和人性化。</span> 
                      </div> 
                      <div></div> 
                      <div> 
                       <div> 
                        <strong><span style="color:#000000;">变量提升的流程：</span></strong> 
                       </div> 
                       <div> 
                        <span style="color:#000000;">1.</span> 
                        <span style="color:#000000;">先把var 变量提升到当前作用域于最前面 </span> 
                       </div> 
                       <div> 
                        <span style="color:#000000;">2.</span> 
                        <span style="color:#000000;">只提升变量声明， 不提升变量赋值 </span> 
                       </div> 
                       <div> 
                        <span style="color:#000000;">3.</span> 
                        <span style="color:#000000;">然后依次执行代码 </span> 
                       </div> 
                       <div> 
                        <span style="color:#be191c;">不建议使用var声明变量</span> 
                       </div> 
                       <div></div> 
                       <h3 id="2.%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6"><span style="color:#c00000;">2.函数进阶</span></h3> 
                       <h4 id="2.1%20%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87"><span style="color:#ad2a26;">2.1 函数提升</span></h4> 
                       <p><span style="color:#262626;">函数提升与变量提升比较类似，是指函数在声明之前即可被调用。</span><img alt="" height="248" src="https://images2.imgbox.com/50/df/B4DrDUgx_o.png" width="1200"></p> 
                       <div> 
                        <strong><span style="color:#262626;">总结： </span></strong> 
                       </div> 
                       <div> 
                        <span style="color:#262626;">1. 函数提升能够使函数的声明调用更灵活 </span> 
                       </div> 
                       <div> 
                        <span style="color:#262626;">2. </span> 
                        <span style="color:#be191c;">函数表达式不存在提升的现象 </span> 
                       </div> 
                       <div> 
                        <span style="color:#262626;">3. 函数提升出现在相同作用域当中</span> 
                       </div> 
                       <div></div> 
                       <h4 id="2.2%20%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span style="color:#ad2a26;">2.2 函数参数</span></h4> 
                       <div> 
                        <span style="color:#262626;"><strong>1. 动态参数 </strong></span> 
                       </div> 
                       <div></div> 
                       <div> 
                        <p><span style="color:#c00000;">arguments </span><span style="color:#262626;">是</span><span style="color:#be191c;">函数内部内置</span><span style="color:#262626;">的</span><span style="color:#be191c;">伪数组</span><span style="color:#262626;">变量，它包含了调用函数时传入的所有实参</span></p> 
                        <p><span style="color:#000000;">arguments 动态参数的<strong>使用场景</strong>：当</span><span style="color:#be191c;">不确定传递多少个实参</span><span style="color:#000000;">的时候</span></p> 
                        <pre><code class="language-javascript">  &lt;script&gt;
    function getSum() {
      // arguments 动态参数 只存在于 函数里面
      // 是伪数组 里面存储的是传递过来的实参
      // console.log(arguments)  [2,3,4]
      let sum = 0
      for (let i = 0; i &lt; arguments.length; i++) {
        sum += arguments[i]
      }
      console.log(sum)
    }
    getSum(2, 3, 4)
    getSum(1, 2, 3, 4, 2, 2, 3, 4)
  &lt;/script&gt;</code></pre> 
                        <div> 
                         <strong><span style="color:#262626;">总结： </span></strong> 
                        </div> 
                        <div> 
                         <span style="color:#404040;">1. </span> 
                         <span style="color:#262626;">arguments 是一个</span> 
                         <span style="color:#be191c;">伪数组</span> 
                         <span style="color:#262626;">，只存在于函数中 </span> 
                        </div> 
                        <div> 
                         <span style="color:#404040;">2. </span> 
                         <span style="color:#262626;">arguments 的作用是</span> 
                         <span style="color:#be191c;">动态获取函数的实参 </span> 
                        </div> 
                        <div> 
                         <span style="color:#404040;">3. </span> 
                         <span style="color:#262626;">可以通过for循环依次得到传递过来的实参</span> 
                        </div> 
                        <div></div> 
                        <div> 
                         <span style="color:#262626;"><strong>2. 剩余参数</strong></span> 
                        </div> 
                        <div></div> 
                        <div> 
                         <p><span style="color:#262626;">剩余参数允许我们将一个</span><span style="color:#be191c;">不定数量的参数</span><span style="color:#262626;">表示为一个数组</span></p> 
                         <div> 
                          <span style="color:#000000;">剩余参数主要的<strong>使用场景</strong>：</span> 
                          <span style="color:#be191c;">用于获取多余的实参</span> 
                         </div> 
                         <pre><code class="language-javascript">  &lt;script&gt;
    function getSum(a, b, ...arr) {
      console.log(arr)  // 使用的时候不需要写 ...
    }
    getSum(2, 3)  // []
    getSum(1, 2, 3, 4, 5)  // [3,4,5]
  &lt;/script&gt;</code></pre> 
                         <p><strong><span style="color:#262626;">总结：</span></strong></p> 
                         <div> 
                          <span style="color:#262626;">1. ... 是语法符号，置于最末函数形参之前，用于获取</span> 
                          <span style="color:#c00000;">多余</span> 
                          <span style="color:#262626;">的实参 </span> 
                         </div> 
                         <div> 
                          <span style="color:#262626;">2. 借助 ... 获取的剩余实参，是个</span> 
                          <span style="color:#c00000;">真数组</span> 
                         </div> 
                         <div></div> 
                         <div> 
                          <div> 
                           <strong><span style="color:#000000;">剩余参数和动态参数区别：</span></strong> 
                           <span style="color:#000000;">动态参数是伪数组，剩余参数是真数组</span> 
                          </div> 
                         </div> 
                         <div> 
                          <span style="color:#262626;">开发中，还是提倡多使用 </span> 
                          <span style="color:#c00000;"><strong>剩余参数</strong></span> 
                         </div> 
                         <div></div> 
                         <h4 id="%E6%8B%93%E5%B1%95-%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6"><span style="color:#ad2a26;">拓展-展开运算符</span></h4> 
                         <p><span style="color:#262626;">展开运算符(…)，将一个数组进行展开，不会修改原数组</span></p> 
                         <p><span style="color:#262626;"><strong>典型运用场景： </strong></span><span style="color:#be191c;">求数组最大值(最小值)、合并数组等</span></p> 
                         <pre><code class="language-javascript">  &lt;script&gt;
    const arr1 = [1, 2, 3]
    // 展开运算符 可以展开数组
    // console.log(...arr)    // 1,2,3

    // 1 求数组最大值
    console.log(Math.max(...arr1)) // 3
    // console.log(Math.max(1, 2, 3))
    console.log(Math.min(...arr1)) // 1
    // 2. 合并数组
    const arr2 = [4, 5]
    const arr = [...arr1, ...arr2]
    console.log(arr)    // [1,2,3,4,5]
  &lt;/script&gt;</code></pre> 
                         <div> 
                          <strong><span style="color:#ad2a26;">展开运算符 or 剩余参数 </span></strong> 
                         </div> 
                         <div> 
                          <strong><span style="color:#262626;">剩余参数：</span></strong> 
                          <span style="color:#c00000;">函数参数使用，得到真数组 </span> 
                         </div> 
                         <div> 
                          <strong><span style="color:#262626;">展开运算符：</span></strong> 
                          <span style="color:#c00000;">数组中使用，</span> 
                          <span style="color:#be191c;">数组展开</span> 
                         </div> 
                         <div></div> 
                         <h4 id="2.3%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span style="color:#ad2a26;">2.3 箭头函数（重要）</span></h4> 
                         <div> 
                          <span style="color:#262626;"><strong>目的：</strong></span> 
                          <span style="color:#262626;">更简短的函数写法并且不绑定this，箭头函数的语法比函数表达式更简洁 </span> 
                         </div> 
                         <div></div> 
                         <div> 
                          <span style="color:#262626;"><strong>使用场景：</strong></span> 
                          <span style="color:#262626;">箭头函数更适用于那些本来</span> 
                          <span style="color:#c00000;">需要匿名函数的地方</span> 
                         </div> 
                         <div></div> 
                         <div> 
                          <strong><span style="color:#404040;">1. </span><span style="color:#000000;">基本语法</span></strong> 
                         </div> 
                         <div></div> 
                         <div> 
                          <span style="color:#262626;"><strong>语法1：基本写法</strong></span> 
                          <img alt="" height="267" src="https://images2.imgbox.com/63/45/t3N8Onyd_o.png" width="1200"> 
                         </div> 
                         <p><span style="color:#262626;"><strong>语法2：只有一个参数可以省略小括号</strong></span><img alt="" height="270" src="https://images2.imgbox.com/ae/3d/eS35TJCU_o.png" width="1200"> <span style="color:#262626;"><strong>语法3：如果函数体只有一行代码，可以写到一行上，并且无需写 return 直接返回值</strong></span><img alt="" height="264" src="https://images2.imgbox.com/04/e1/J81nfiLo_o.png" width="1200"> <span style="color:#262626;"><strong>语法4：加括号的函数体返回对象字面量表达式</strong></span><img alt="" height="254" src="https://images2.imgbox.com/b0/40/VWkhX6xa_o.png" width="1200"></p> 
                         <p><span style="color:#0d0016;"><strong>总结：</strong></span></p> 
                         <div> 
                          <span style="color:#000000;">1. 箭头函数属于表达式函数，因此不存在函数提升 </span> 
                         </div> 
                         <div> 
                          <span style="color:#000000;">2. 箭头函数只有一个参数时可以省略圆括号 () </span> 
                         </div> 
                         <div> 
                          <span style="color:#000000;">3. 箭头函数函数体只有一行代码时可以省略花括号 {}，并自动做为返回值被返回 </span> 
                         </div> 
                         <div> 
                          <span style="color:#000000;">4. 加括号的函数体返回对象字面量表达式</span> 
                         </div> 
                         <div></div> 
                         <div> 
                          <span style="color:#000000;"><strong>2. 箭头函数参数 </strong></span> 
                         </div> 
                         <div></div> 
                         <div> 
                          <div> 
                           <span style="color:#404040;">1. </span> 
                           <span style="color:#262626;">普通函数有arguments 动态参数 </span> 
                          </div> 
                          <div> 
                           <span style="color:#404040;">2. </span> 
                           <span style="color:#c00000;">箭头函数</span> 
                           <span style="color:#262626;">没有 arguments 动态参数，但是</span> 
                           <span style="color:#c00000;">有剩余参数 </span> 
                           <span style="color:#be191c;">..args</span> 
                           <pre><code class="language-javascript">  &lt;script&gt;
    // 1. 利用箭头函数来求和
    const getSum = (...arr) =&gt; {
      let sum = 0
      for (let i = 0; i &lt; arr.length; i++) {
        sum += arr[i]
      }
      return sum
    }
    const result = getSum(2, 3, 4)
    console.log(result) // 9
  &lt;/script&gt;</code></pre> 
                           <div> 
                            <span style="color:#000000;"><strong>3. 箭头函数 this</strong></span> 
                           </div> 
                           <div></div> 
                           <div> 
                            <span style="color:#c00000;">箭头函数不会创建自己的 this</span> 
                            <span style="color:#262626;">，它只会从自己的作用域链的上一层沿用 this。</span> 
                            <pre><code class="language-javascript">  &lt;script&gt;
    // 以前this的指向：  谁调用的这个函数，this 就指向谁
    // console.log(this)  // window
    // // 普通函数
    // function fn() {
    //   console.log(this)  // window
    // }
    // window.fn()
    // // 对象方法里面的this
    // const obj = {
    //   name: 'andy',
    //   sayHi: function () {
    //     console.log(this)  // obj
    //   }
    // }
    // obj.sayHi()

    // 2. 箭头函数的this  是上一层作用域的this 指向
    // const fn = () =&gt; {
    //   console.log(this)  // window
    // }
    // fn()
    // 对象方法箭头函数 this
    // const obj = {
    //   uname: 'pink老师',
    //   sayHi: () =&gt; {
    //     console.log(this)  // this 指向谁？ window
    //   }
    // }
    // obj.sayHi()

    const obj = {
      uname: 'pink老师',
      sayHi: function () {
        console.log(this)  // obj
        let i = 10
        const count = () =&gt; {
          console.log(this)  // obj 
        }
        count()
      }
    }
    obj.sayHi()

  &lt;/script&gt;</code></pre> 
                            <div> 
                             <span style="color:#000000;">在开发中【使用箭头函数前需要考虑函数中 this 的值】，事件回调函数使用箭头函数时，this 为全局的 window，因此 </span> 
                             <span style="color:#c00000;">DOM事件回调函数为了简便，还是不太推荐使用箭头函数</span> 
                            </div> 
                            <div></div> 
                            <h3 id="3.%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span style="color:#c00000;">3.解构赋值</span></h3> 
                            <p><span style="color:#262626;">解构赋值是一种快速为变量赋值的简洁语法，本质上仍然是为变量赋值。</span></p> 
                            <h4 id="3.1%20%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84"><span style="color:#ad2a26;">3.1 数组解构</span></h4> 
                            <div> 
                             <span style="color:#262626;">数组解构是将数组的单元值</span> 
                             <span style="color:#be191c;">快速批量赋值</span> 
                             <span style="color:#262626;">给一系列变量的</span> 
                             <span style="color:#be191c;">简洁语法</span> 
                             <span style="color:#262626;">。 </span> 
                            </div> 
                            <div></div> 
                            <div> 
                             <span style="color:#262626;"><strong>1.基本语法： </strong></span> 
                            </div> 
                            <div> 
                             <span style="color:#262626;">1. 赋值运算符 = 左侧的 [] 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量 </span> 
                            </div> 
                            <div> 
                             <span style="color:#262626;">2. 变量的顺序对应数组单元值的位置依次进行赋值操作</span> 
                             <pre><code class="language-javascript"> &lt;script&gt;
    // 数组解构 赋值
    const [max, min, avg] = [100, 60, 80]
    // // const max = arr[0]
    // // const min = arr[1]
    // // const avg = arr[2]
    console.log(max) // 100
    console.log(avg) // 80
  &lt;/script&gt;</code></pre> 
                             <div> 
                              <span style="color:#262626;"><strong>典型应用交互2个变量</strong></span> 
                              <pre><code class="language-javascript">  &lt;script&gt;
    // 交换2个变量的值
    let a = 1
    let b = 2;    // 这里必须有分号
    [b, a] = [a, b]
    console.log(a, b)
  &lt;/script&gt;</code></pre> 
                              <h4 id="%E6%B3%A8%E6%84%8F%EF%BC%9A%20js%20%E5%89%8D%E9%9D%A2%E5%BF%85%E9%A1%BB%E5%8A%A0%E5%88%86%E5%8F%B7%E6%83%85%E5%86%B5"><span style="color:#c00000;">注意： js 前面必须加分号情况</span></h4> 
                              <div> 
                               <span style="color:#404040;">1. </span> 
                               <span style="color:#262626;">立即执行函数</span> 
                              </div> 
                              <div> 
                               <img alt="" height="107" src="https://images2.imgbox.com/a0/6f/lrAiWUNQ_o.png" width="316"> 
                              </div> 
                              <p><span style="color:#404040;">2. </span><span style="color:#262626;">数组解构</span><img alt="" height="94" src="https://images2.imgbox.com/67/41/Qi8nlkD5_o.png" width="826"></p> 
                              <div> 
                               <span style="color:#262626;"><strong>2.变量多 单元值少的情况 </strong></span> 
                               <div> 
                                <span style="color:#262626;">变量的数量大于单元值数量时，多余的变量将被赋值为 </span> 
                                <span style="color:#be191c;">undefined</span> 
                               </div> 
                               <pre><code class="language-javascript">  &lt;script&gt;
    // 1. 变量多， 单元值少 ， undefined
    const [a, b, c, d] = [1, 2, 3]
    console.log(a) // 1
    console.log(b) // 2
    console.log(c) // 3
    console.log(d) // undefined
  &lt;/script&gt;</code></pre> 
                               <p><span style="color:#262626;"><strong>3.变量少 单元值多的情况</strong></span></p> 
                               <pre><code class="language-javascript">  &lt;script&gt;
    // 2. 变量少， 单元值多
    const [a, b] = [1, 2, 3]
    console.log(a) // 1
    console.log(b) // 2
  &lt;/script&gt;</code></pre> 
                               <p><span style="color:#262626;"><strong>4.利用剩余参数解决变量少 单元值多的情况</strong></span></p> 
                               <p><span style="color:#262626;">剩余参数</span><span style="color:#000000;">... 获取剩余单元值，但只能置于</span><span style="color:#be191c;">最末位</span><span style="color:#000000;">，</span><span style="color:#262626;">返回的还是一个</span><span style="color:#be191c;">数组</span></p> 
                               <pre><code class="language-javascript">  &lt;script&gt;
    // 3.  剩余参数 变量少， 单元值多
    const [a, b, ...c] = [1, 2, 3, 4]
    console.log(a) // 1
    console.log(b) // 2
    console.log(c) // [3, 4]  真数组
  &lt;/script&gt;</code></pre> 
                               <p><span style="color:#262626;"><strong>5.防止有undefined传递单元值的情况，可以设置默认值</strong></span></p> 
                               <p><span style="color:#262626;">允许初始化变量的默认值，且</span><span style="color:#be191c;">只有单元值为 undefined 时默认值才会生效</span></p> 
                               <pre><code class="language-javascript">  &lt;script&gt;
    // 4.  防止 undefined 传递
    const [a = 0, b = 0] = [1, 2]
    const [a = 0, b = 0] = []
    console.log(a) // 0
    console.log(b) // 0
  &lt;/script&gt;</code></pre> 
                               <p><span style="color:#262626;"><strong>6.按需导入，忽略某些返回值</strong></span></p> 
                               <pre><code class="language-javascript">  &lt;script&gt;
    // 5.  按需导入赋值
    const [a, b, , d] = [1, 2, 3, 4]
    console.log(a) // 1
    console.log(b) // 2
    console.log(d) // 4
  &lt;/script&gt;</code></pre> 
                               <p><span style="color:#262626;"><strong>7.支持多维数组的结构</strong></span></p> 
                               <pre><code class="language-javascript">  &lt;script&gt;
    // 多维数组解构
    // const [a, b, c] = [1, 2, [3, 4]]
    // console.log(a) // 1
    // console.log(b) // 2
    // console.log(c) // [3,4]

    const [a, b, [c, d]] = [1, 2, [3, 4]]
    console.log(a) // 1
    console.log(b) // 2
    console.log(c) // 3
    console.log(d) // 4
  &lt;/script&gt;</code></pre> 
                               <h4 id="3.2%20%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span style="color:#ad2a26;">3.2 对象解构</span></h4> 
                               <p><span style="color:#262626;">对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法。</span></p> 
                               <div> 
                                <span style="color:#404040;"><strong>1. </strong></span> 
                                <span style="color:#262626;"><strong>基本语法： </strong></span> 
                               </div> 
                               <div> 
                                <span style="color:#262626;">1. 赋值运算符 = 左侧的 {} 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量 </span> 
                               </div> 
                               <div> 
                                <span style="color:#262626;">2. 对象属性的值将被赋值给与属性名</span> 
                                <span style="color:#c00000;">相同的</span> 
                                <span style="color:#262626;">变量 </span> 
                               </div> 
                               <div> 
                                <span style="color:#262626;">3. 注意</span> 
                                <span style="color:#be191c;">解构的变量名不要和外面的变量名冲突</span> 
                                <span style="color:#262626;">否则报错 </span> 
                               </div> 
                               <div> 
                                <span style="color:#262626;">4.对象中找不到与变量名一致的属性时变量值为 undefined</span> 
                                <pre><code class="language-javascript">  &lt;script&gt;
    // 对象解构
    // const obj = {
    //   uname: 'pink老师',
    //   age: 18
    // }
    // 解构的语法
    const { uname, age } = {age: 18, uname: 'pink老师' }
    // 等价于 const uname =  obj.uname
    // 要求属性名和变量名必须一直才可以
    console.log(uname)
    console.log(age)
  &lt;/script&gt;</code></pre> 
                                <div> 
                                 <span style="color:#262626;"><strong>2. 给新的变量名赋值：</strong>可以从一个对象中提取变量并同时修改新的变量名</span> 
                                 <pre><code class="language-javascript">  &lt;script&gt;
    // 1. 对象解构的变量名 可以重新改名  旧变量名: 新变量名
    const { uname: username, age } = { uname: 'pink老师', age: 18 }
    console.log(username)
    console.log(age)
  &lt;/script&gt;</code></pre> 
                                 <div> 
                                  <span style="color:#262626;"><strong>3. 数组对象解构</strong></span> 
                                  <pre><code class="language-javascript">  &lt;script&gt;
    // 2. 解构数组对象
    const pig = [
      {
        uname: '佩奇',
        age: 6
      }
    ]
    const [{ uname, age }] = pig
    console.log(uname)
    console.log(age)
  &lt;/script&gt;</code></pre> 
                                  <div> 
                                   <span style="color:#c00000;"><strong>3. 多级对象解构</strong></span> 
                                   <pre><code class="language-javascript">  &lt;script&gt;
    // const pig = {
    //   name: '佩奇',
    //   family: {
    //     mother: '猪妈妈',
    //     father: '猪爸爸',
    //     sister: '乔治'
    //   },
    //   age: 6
    // }
    // // 多级对象解构
    // const { name, family: { mother, father, sister } } = pig
    // console.log(name)
    // console.log(mother)
    // console.log(father)
    // console.log(sister)

    const person = [
      {
        name: '佩奇',
        family: {
          mother: '猪妈妈',
          father: '猪爸爸',
          sister: '乔治'
        },
        age: 6
      }
    ]
    const [{ name, family: { mother, father, sister } }] = person
    console.log(name)
    console.log(mother)
    console.log(father)
    console.log(sister)
  &lt;/script&gt;</code></pre> 
                                   <div> 
                                    <strong><span style="color:#c00000;">渲染商品列表案例</span></strong> 
                                   </div> 
                                   <div> 
                                    <div></div> 
                                    <div> 
                                     <span style="color:#be191c;">遍历数组 forEach 方法（重点） </span> 
                                    </div> 
                                    <div> 
                                     <span style="color:#262626;">forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数 </span> 
                                    </div> 
                                    <div> 
                                     <span style="color:#404040;">主要使用场景： </span> 
                                     <span style="color:#404040;"><strong>遍历数组的每个元素 </strong></span> 
                                    </div> 
                                    <div> 
                                     <span style="color:#404040;"><strong>语法：</strong></span> 
                                     <img alt="" height="139" src="https://images2.imgbox.com/82/85/MJTSUaWQ_o.png" width="1104"> 
                                    </div> 
                                    <div> 
                                     <strong><span style="color:#262626;">注意： </span></strong> 
                                    </div> 
                                    <div> 
                                     <span style="color:#404040;">1. </span> 
                                     <span style="color:#262626;">forEach 主要是遍历数组 </span> 
                                    </div> 
                                    <div> 
                                     <span style="color:#404040;">2. </span> 
                                     <span style="color:#262626;">参数当前数组元素是必须要写的，索引号可选。</span> 
                                     <pre><code class="language-html">&lt;body&gt;
  &lt;div class="list"&gt;
    &lt;!-- &lt;div class="item"&gt;
      &lt;img src="" alt=""&gt;
      &lt;p class="name"&gt;&lt;/p&gt;
      &lt;p class="price"&gt;&lt;/p&gt;
    &lt;/div&gt; --&gt;
  &lt;/div&gt;
  &lt;script&gt;
    const goodsList = [
      {
        id: '4001172',
        name: '称心如意手摇咖啡磨豆机咖啡豆研磨机',
        price: '289.00',
        picture: 'https://yanxuan-item.nosdn.127.net/84a59ff9c58a77032564e61f716846d6.jpg',
      },
      {
        id: '4001594',
        name: '日式黑陶功夫茶组双侧把茶具礼盒装',
        price: '288.00',
        picture: 'https://yanxuan-item.nosdn.127.net/3346b7b92f9563c7a7e24c7ead883f18.jpg',
      },
      {
        id: '4001009',
        name: '竹制干泡茶盘正方形沥水茶台品茶盘',
        price: '109.00',
        picture: 'https://yanxuan-item.nosdn.127.net/2d942d6bc94f1e230763e1a5a3b379e1.png',
      },
      {
        id: '4001874',
        name: '古法温酒汝瓷酒具套装白酒杯莲花温酒器',
        price: '488.00',
        picture: 'https://yanxuan-item.nosdn.127.net/44e51622800e4fceb6bee8e616da85fd.png',
      },
      {
        id: '4001649',
        name: '大师监制龙泉青瓷茶叶罐',
        price: '139.00',
        picture: 'https://yanxuan-item.nosdn.127.net/4356c9fc150753775fe56b465314f1eb.png',
      },
      {
        id: '3997185',
        name: '与众不同的口感汝瓷白酒杯套组1壶4杯',
        price: '108.00',
        picture: 'https://yanxuan-item.nosdn.127.net/8e21c794dfd3a4e8573273ddae50bce2.jpg',
      },
      {
        id: '3997403',
        name: '手工吹制更厚实白酒杯壶套装6壶6杯',
        price: '99.00',
        picture: 'https://yanxuan-item.nosdn.127.net/af2371a65f60bce152a61fc22745ff3f.jpg',
      },
      {
        id: '3998274',
        name: '德国百年工艺高端水晶玻璃红酒杯2支装',
        price: '139.00',
        picture: 'https://yanxuan-item.nosdn.127.net/8896b897b3ec6639bbd1134d66b9715c.jpg',
      },
    ]

    // 1. 声明一个字符串变量
    let str = ''
    // 2. 遍历数据 
    goodsList.forEach(item =&gt; {
      // console.log(item)  // 可以得到每一个数组元素  对象 {id: '4001172'}
      // const {id} =  item  对象解构
      const { name, price, picture } = item
      str += `
      &lt;div class="item"&gt;
        &lt;img src=${picture} alt=""&gt;
        &lt;p class="name"&gt;${name}&lt;/p&gt;
        &lt;p class="price"&gt;${price}&lt;/p&gt;
      &lt;/div&gt;
      `
    })
    // 3.生成的 字符串 添加给 list 
    document.querySelector('.list').innerHTML = str
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
                                     <h3 id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%95%86%E5%93%81%E5%88%97%E8%A1%A8%E4%BB%B7%E6%A0%BC%E7%AD%9B%E9%80%89"><span style="color:#ad2a26;">综合案例：商品列表价格筛选</span></h3> 
                                     <p></p> 
                                     <div> 
                                      <strong><span style="color:#ad2a26;">筛选数组 filter 方法（重点） </span></strong> 
                                     </div> 
                                     <div> 
                                      <span style="color:#262626;">filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素 </span> 
                                     </div> 
                                     <div> 
                                      <span style="color:#404040;"><strong>主要使用场景：</strong> </span> 
                                      <span style="color:#c00000;"><strong>筛选数组符合条件的元素</strong></span> 
                                      <span style="color:#404040;"><strong>，并返回筛选之后元素的</strong></span> 
                                      <span style="color:#be191c;"><strong>新数组 </strong></span> 
                                     </div> 
                                     <div> 
                                      <span style="color:#404040;"><strong>语法：</strong></span> 
                                      <img alt="" height="140" src="https://images2.imgbox.com/11/63/iUcnpiIW_o.png" width="971"> 
                                     </div> 
                                     <div> 
                                      <span style="color:#262626;"><strong>返回值：</strong></span> 
                                      <span style="color:#262626;">返回</span> 
                                      <span style="color:#be191c;">数组</span> 
                                      <span style="color:#262626;">，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组 </span> 
                                     </div> 
                                     <div> 
                                      <span style="color:#404040;"><strong>参数：</strong></span> 
                                      <span style="color:#262626;">currentValue 必须写， index 可选 </span> 
                                     </div> 
                                     <div> 
                                      <span style="color:#404040;">因为返回新数组，所以</span> 
                                      <span style="color:#be191c;">不会影响原数组</span> 
                                      <pre><code class="language-html">&lt;body&gt;
    &lt;div class="filter"&gt;
        &lt;a data-index="1" href="javascript:;"&gt;0-100元&lt;/a&gt;
        &lt;a data-index="2" href="javascript:;"&gt;100-300元&lt;/a&gt;
        &lt;a data-index="3" href="javascript:;"&gt;300元以上&lt;/a&gt;
        &lt;a href="javascript:;"&gt;全部区间&lt;/a&gt;
    &lt;/div&gt;
    &lt;div class="list"&gt;
        &lt;!-- &lt;div class="item"&gt;
      &lt;img src="" alt=""&gt;
      &lt;p class="name"&gt;&lt;/p&gt;
      &lt;p class="price"&gt;&lt;/p&gt;
    &lt;/div&gt; --&gt;
    &lt;/div&gt;
    &lt;script&gt;
        // 初始化数据
        const goodsList = [
            {
                id: '4001172',
                name: '称心如意手摇咖啡磨豆机咖啡豆研磨机',
                price: '289.00',
                picture: 'https://yanxuan-item.nosdn.127.net/84a59ff9c58a77032564e61f716846d6.jpg',
            },
            {
                id: '4001594',
                name: '日式黑陶功夫茶组双侧把茶具礼盒装',
                price: '288.00',
                picture: 'https://yanxuan-item.nosdn.127.net/3346b7b92f9563c7a7e24c7ead883f18.jpg',
            },
            {
                id: '4001009',
                name: '竹制干泡茶盘正方形沥水茶台品茶盘',
                price: '109.00',
                picture: 'https://yanxuan-item.nosdn.127.net/2d942d6bc94f1e230763e1a5a3b379e1.png',
            },
            {
                id: '4001874',
                name: '古法温酒汝瓷酒具套装白酒杯莲花温酒器',
                price: '488.00',
                picture: 'https://yanxuan-item.nosdn.127.net/44e51622800e4fceb6bee8e616da85fd.png',
            },
            {
                id: '4001649',
                name: '大师监制龙泉青瓷茶叶罐',
                price: '139.00',
                picture: 'https://yanxuan-item.nosdn.127.net/4356c9fc150753775fe56b465314f1eb.png',
            },
            {
                id: '3997185',
                name: '与众不同的口感汝瓷白酒杯套组1壶4杯',
                price: '108.00',
                picture: 'https://yanxuan-item.nosdn.127.net/8e21c794dfd3a4e8573273ddae50bce2.jpg',
            },
            {
                id: '3997403',
                name: '手工吹制更厚实白酒杯壶套装6壶6杯',
                price: '100.00',
                picture: 'https://yanxuan-item.nosdn.127.net/af2371a65f60bce152a61fc22745ff3f.jpg',
            },
            {
                id: '3998274',
                name: '德国百年工艺高端水晶玻璃红酒杯2支装',
                price: '139.00',
                picture: 'https://yanxuan-item.nosdn.127.net/8896b897b3ec6639bbd1134d66b9715c.jpg',
            },
        ]

        // 1. 渲染函数  封装
        function render(arr) {
            // 声明空字符串
            let str = ''
            // 遍历数组
            arr.forEach(item =&gt; {
                // 解构
                const { name, picture, price } = item
                str += `
                &lt;div class="item"&gt;
                    &lt;img src=${picture} alt=""&gt;
                    &lt;p class="name"&gt;${name}&lt;/p&gt;
                    &lt;p class="price"&gt;${price}&lt;/p&gt;
                &lt;/div&gt;
                `
            })
            // 追加给 List
            document.querySelector('.list').innerHTML = str
        }
        render(goodsList)

        // 2.过滤筛选
        document.querySelector('.filter').addEventListener('click', e =&gt; {
            const { tagName, dataset } = e.target
            // 判断
            if (tagName === 'A') {
                // arr 返回的新数组
                let arr = goodsList
                if (dataset.index === '1') {
                    arr = goodsList.filter(item =&gt; item.price &gt; 0 &amp;&amp; item.price &lt;= 100)
                } else if (dataset.index === '2') {
                    arr = goodsList.filter(item =&gt; item.price &gt;= 100 &amp;&amp; item.price &lt;= 300)
                } else if (dataset.index === '3') {
                    arr = goodsList.filter(item =&gt; item.price &gt;= 300)
                }
                // 渲染函数
                render(arr)
            }
        })
    &lt;/script&gt;
&lt;/body&gt;</code></pre> 
                                      <h3 id="4.%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1"><span style="color:#c00000;">4.深入对象</span></h3> 
                                      <h4 id="4.1%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span style="color:#ad2a26;">4.1创建对象三种方式 </span></h4> 
                                      <p><span style="color:#404040;"><strong>1. </strong></span><span style="color:#262626;"><strong>利用对象字面量创建对象</strong></span></p> 
                                      <pre><code class="language-javascript">const o = {
    name:'字面量'
}</code></pre> 
                                      <div> 
                                       <span style="color:#404040;"><strong>2. </strong></span> 
                                       <span style="color:#262626;"><strong>利用 new Object 创建对象</strong></span> 
                                      </div> 
                                      <pre><code class="language-javascript">  &lt;script&gt;
    // const obj = new Object()
    // obj.uname = 'pink老师'
    // console.log(obj)
    const obj = new Object({ uname: 'pink' })
    console.log(obj)
  &lt;/script&gt;</code></pre> 
                                      <div> 
                                       <span style="color:#404040;"><strong>3. </strong></span> 
                                       <span style="color:#262626;"><strong>利用构造函数创建对象</strong></span> 
                                      </div> 
                                      <div></div> 
                                      <h4 id="4.2%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span style="color:#ad2a26;">4.2 构造函数 </span></h4> 
                                      <p><span style="color:#000000;"><strong>构造函数 ：</strong></span><span style="color:#262626;">是一种特殊的函数，主要用来初始化对象 </span></p> 
                                      <div> 
                                       <span style="color:#262626;"><strong>使用场景：</strong></span> 
                                       <span style="color:#262626;">常规的 {...} 语法允许创建一个对象。比如我们创建了佩奇的对象，继续创建乔治的对象还需要重新写一遍，此时可以通过</span> 
                                       <span style="color:#c00000;">构造函数</span> 
                                       <span style="color:#262626;">来</span> 
                                       <span style="color:#c00000;">快速创建多个类似的对象</span> 
                                       <span style="color:#262626;">。</span> 
                                      </div> 
                                      <div></div> 
                                      <div> 
                                       <div> 
                                        <span style="color:#262626;">构造函数在技术上是常规函数。 </span> 
                                       </div> 
                                       <div> 
                                        <span style="color:#262626;">不过有两个约定： </span> 
                                       </div> 
                                       <div> 
                                        <span style="color:#404040;">1. </span> 
                                        <span style="color:#262626;">它们的命名以</span> 
                                        <span style="color:#be191c;">大写字母开头</span> 
                                        <span style="color:#262626;">。 </span> 
                                       </div> 
                                       <div> 
                                        <span style="color:#404040;">2. </span> 
                                        <span style="color:#262626;">它们只能由 "</span> 
                                        <span style="color:#be191c;">new</span> 
                                        <span style="color:#262626;">" 操作符来执行。 </span> 
                                       </div> 
                                       <div></div> 
                                       <div> 
                                        <div> 
                                         <span style="color:#262626;"><strong>构造函数语法：</strong></span> 
                                         <span style="color:#262626;">大写字母开头的函数 </span> 
                                        </div> 
                                        <div></div> 
                                        <div> 
                                         <span style="color:#262626;"><strong>创建构造函数：</strong></span> 
                                         <pre><code class="language-javascript">  &lt;script&gt;
    // 创建一个猪 构造函数 
    function Pig(uname, age) {
      this.uname = uname
      this.age = age
    }

    // console.log(new Pig('佩奇', 6))
    // console.log(new Pig('乔治', 3))
    const p = new Pig('佩奇', 6)
    console.log(p)
  &lt;/script&gt;</code></pre> 
                                         <div> 
                                          <strong><span style="color:#262626;">说明： </span></strong> 
                                         </div> 
                                         <div> 
                                          <span style="color:#262626;">1. 使用 new 关键字调用函数的行为被称为</span> 
                                          <span style="color:#c00000;">实例化 </span> 
                                         </div> 
                                         <div> 
                                          <span style="color:#262626;">2. 实例化构造函数时没有参数时可以省略 () </span> 
                                         </div> 
                                         <div> 
                                          <span style="color:#262626;">3. </span> 
                                          <span style="color:#be191c;">构造函数内部无需写return，返回值即为新创建的对象，即自动返回创建的新对象</span> 
                                         </div> 
                                         <div> 
                                          <span style="color:#262626;">4. 构造函数内部的 return 返回的值无效，所以不要写return </span> 
                                         </div> 
                                         <div> 
                                          <span style="color:#262626;">5. new Object（） new Date（） 也是实例化构造函数</span> 
                                         </div> 
                                         <div></div> 
                                         <div> 
                                          <span style="color:#c00000;"><strong>实例化执行过程 </strong></span> 
                                         </div> 
                                         <div> 
                                          <div> 
                                           <span style="color:#262626;">1. 创建新对象 </span> 
                                          </div> 
                                          <div> 
                                           <span style="color:#262626;">2. 构造函数this指向新对象 </span> 
                                          </div> 
                                          <div> 
                                           <span style="color:#262626;">3. 执行构造函数代码，修改this，添加新的属性 </span> 
                                          </div> 
                                          <div> 
                                           <span style="color:#262626;">4. 返回新对象</span> 
                                          </div> 
                                          <div></div> 
                                          <h4 id="4.3%C2%A0%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98%26%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span style="color:#ad2a26;">4.3 </span><span style="color:#c00000;">实例成员&amp;静态成员</span></h4> 
                                          <div> 
                                           <span style="color:#000000;"><strong>实例成员： </strong></span> 
                                          </div> 
                                          <div> 
                                           <span style="color:#262626;">通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员。</span> 
                                           <img alt="" height="417" src="https://images2.imgbox.com/aa/db/O2chV7Df_o.png" width="410"> 
                                          </div> 
                                          <div> 
                                           <strong><span style="color:#262626;">说明： </span></strong> 
                                          </div> 
                                          <div> 
                                           <span style="color:#262626;">1. </span> 
                                           <span style="color:#c00000;">实例对象的属性和方法即为实例成员 </span> 
                                          </div> 
                                          <div> 
                                           <span style="color:#262626;">2. 为构造函数传入参数，动态创建</span> 
                                           <span style="color:#be191c;">结构相同但值不同</span> 
                                           <span style="color:#262626;">的对象 </span> 
                                          </div> 
                                          <div> 
                                           <span style="color:#262626;">3. 构造函数创建的实例对象</span> 
                                           <span style="color:#be191c;">彼此独立互不影响</span> 
                                           <span style="color:#262626;">。 </span> 
                                          </div> 
                                          <div></div> 
                                          <div> 
                                           <span style="color:#000000;"><strong>静态成员： </strong></span> 
                                          </div> 
                                          <div> 
                                           <span style="color:#262626;">构造函数的属性和方法被称为静态成员</span> 
                                          </div> 
                                          <div> 
                                           <img alt="" height="449" src="https://images2.imgbox.com/56/be/WfV5N2oP_o.png" width="409"> 
                                          </div> 
                                          <div> 
                                           <strong><span style="color:#262626;">说明： </span></strong> 
                                          </div> 
                                          <div> 
                                           <span style="color:#262626;">1. </span> 
                                           <span style="color:#be191c;">构造函数的属性和方法被称为静态成员 </span> 
                                          </div> 
                                          <div> 
                                           <span style="color:#262626;">2. 一般</span> 
                                           <span style="color:#be191c;">公共特征</span> 
                                           <span style="color:#262626;">的属性或方法静态成员设置为静态成员 </span> 
                                          </div> 
                                          <div> 
                                           <span style="color:#262626;">3. </span> 
                                           <span style="color:#be191c;">静态成员方法中的 this 指向构造函数本身 </span> 
                                          </div> 
                                          <div></div> 
                                          <h3 id="5.%E5%86%85%E7%BD%AE%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span style="color:#c00000;">5.内置构造函数 </span></h3> 
                                          <div> 
                                           <span style="color:#262626;">在 JavaScript 中</span> 
                                           <span style="color:#c00000;">最主要</span> 
                                           <span style="color:#262626;">的数据类型有 6 种： </span> 
                                          </div> 
                                          <div> 
                                           <span style="color:#262626;"><strong>基本数据类型： </strong>字符串、数值、布尔、undefined、null </span> 
                                          </div> 
                                          <div> 
                                           <span style="color:#262626;"><strong>引用类型: </strong>对象 </span> 
                                          </div> 
                                          <div></div> 
                                          <div> 
                                           <span style="color:#000000;">但是，我们会发现有些特殊情况：</span> 
                                           <img alt="" height="114" src="https://images2.imgbox.com/ab/83/5rQ8GGLM_o.png" width="455"> 
                                          </div> 
                                          <div> 
                                           <span style="color:#000000;">其实字符串、数值、布尔、等基本类型也都有专门的构造函数，这些我们称为</span> 
                                           <span style="color:#be191c;">包装类型</span> 
                                           <span style="color:#000000;">。 </span> 
                                          </div> 
                                          <div> 
                                           <span style="color:#262626;">JS中几乎所有的数据都可以基于构造函数创建。 </span> 
                                          </div> 
                                          <div> 
                                           <div> 
                                            <span style="color:#000000;"><strong>引用类型 </strong>：Object，Array，RegExp，Date 等 </span> 
                                           </div> 
                                           <div> 
                                            <span style="color:#000000;"><strong>包装类型 </strong>：String，Number，Boolean 等</span> 
                                           </div> 
                                           <div></div> 
                                           <h4 id="5.1%20Object"><span style="color:#ad2a26;">5.1 Object</span></h4> 
                                           <p><span style="color:#000000;">Object 是内置的构造函数，用于创建普通对象。 </span><img alt="" height="73" src="https://images2.imgbox.com/9c/72/HIIxsU8k_o.png" width="585"></p> 
                                           <p><span style="color:#000000;">但是推荐使用字面量方式声明对象，而不是 Object 构造函数</span></p> 
                                           <div> 
                                            <strong><span style="color:#000000;">三个常用静态方法（静态方法就是只有构造函数Object可以调用的）</span></strong> 
                                           </div> 
                                           <div></div> 
                                           <div> 
                                            <strong><span style="color:#be191c;">1.Object.keys</span></strong> 
                                            <span style="color:#262626;"> </span> 
                                           </div> 
                                           <div></div> 
                                           <div> 
                                            <div> 
                                             <span style="color:#262626;"><strong>作用：</strong></span> 
                                             <span style="color:#262626;">Object.keys 静态方法获取</span> 
                                             <span style="color:#be191c;">对象中所有属性（键） </span> 
                                            </div> 
                                            <div></div> 
                                            <div> 
                                             <span style="color:#262626;"><strong>语法：</strong></span> 
                                             <pre><code class="language-javascript">  &lt;script&gt;
    const o = { uname: 'pink', age: 18 }
    // 1.获得所有的属性名
    console.log(Object.keys(o))  //返回数组['uname', 'age']
  &lt;/script&gt;</code></pre> 
                                             <div> 
                                              <span style="color:#262626;"><strong>注意： </strong></span> 
                                              <span style="color:#262626;">返回的是一个</span> 
                                              <span style="color:#be191c;">数组</span> 
                                             </div> 
                                             <div></div> 
                                             <div> 
                                              <span style="color:#be191c;"><strong>2.Object.values</strong></span> 
                                             </div> 
                                             <div></div> 
                                             <div> 
                                              <div> 
                                               <span style="color:#262626;"><strong>作用：</strong></span> 
                                               <span style="color:#262626;">Object.values 静态方法获取</span> 
                                               <span style="color:#be191c;">对象中所有属性值 </span> 
                                              </div> 
                                              <div></div> 
                                              <div> 
                                               <span style="color:#262626;"><strong>语法：</strong></span> 
                                               <pre><code class="language-javascript">  &lt;script&gt;
    const o = { uname: 'pink', age: 18 }
    // 2. 获得所有的属性值
    console.log(Object.values(o))  //  ['pink', 18]
  &lt;/script&gt;</code></pre> 
                                               <div> 
                                                <span style="color:#262626;"><strong>注意： </strong></span> 
                                                <span style="color:#262626;">返回的是一个</span> 
                                                <span style="color:#be191c;">数组</span> 
                                               </div> 
                                               <div></div> 
                                               <div> 
                                                <div> 
                                                 <span style="color:#be191c;"><strong>3.Object. assign </strong></span> 
                                                </div> 
                                                <div></div> 
                                                <div> 
                                                 <div> 
                                                  <span style="color:#262626;"><strong>作用：</strong></span> 
                                                  <span style="color:#262626;">Object. assign 静态方法常用于</span> 
                                                  <span style="color:#be191c;">对象拷贝 </span> 
                                                 </div> 
                                                 <div></div> 
                                                 <div> 
                                                  <span style="color:#262626;"><strong>使用：</strong></span> 
                                                  <span style="color:#262626;">经常使用的场景给对象添加属性</span> 
                                                 </div> 
                                                 <div></div> 
                                                 <div> 
                                                  <span style="color:#262626;"><strong>语法：</strong></span> 
                                                  <pre><code class="language-javascript">  &lt;script&gt;
    const o = { uname: 'pink', age: 18 }
    // 3. 对象的拷贝
    // const oo = {}
    // Object.assign(oo, o)
    // console.log(oo)
    Object.assign(o, { gender: '女' })
    console.log(o)
  &lt;/script&gt;</code></pre> 
                                                  <h4 id="5.2%20Array"><span style="color:#ad2a26;">5.2 Array</span></h4> 
                                                  <p><span style="color:#262626;">Array 是内置的构造函数，用于创建数组。创建数组建议使用字面量创建，不用Array构造函数创建 </span><img alt="" height="77" src="https://images2.imgbox.com/58/0b/XWg78gUP_o.png" width="458"></p> 
                                                  <div> 
                                                   <span style="color:#262626;"><strong>1. 数组常见实例方法-核心方法</strong></span> 
                                                  </div> 
                                                  <div> 
                                                   <img alt="" height="272" src="https://images2.imgbox.com/ac/4e/98z47EUx_o.png" width="1200"> 
                                                  </div> 
                                                  <div> 
                                                   <span style="color:#262626;"><strong>作用：</strong></span> 
                                                   <span style="color:#be191c;"><strong>reduce</strong></span> 
                                                   <span style="color:#262626;"> 返回函数累计处理的结果，经常用于求和等 </span> 
                                                  </div> 
                                                  <div> 
                                                   <span style="color:#262626;"><strong>基本语法：</strong></span>arr.reduce(function(累计值, 当前元素){}, 起始值) 
                                                   <img alt="" height="60" src="https://images2.imgbox.com/ba/b8/9iCXyEqx_o.png" width="1200"> 
                                                  </div> 
                                                  <p><span style="color:#262626;"><strong>参数： </strong>起始值可以省略，如果写就作为第一次累计的起始值</span></p> 
                                                  <div> 
                                                   <span style="color:#262626;"><strong>累计值参数： </strong></span> 
                                                  </div> 
                                                  <div> 
                                                   <span style="color:#262626;">1. 如果有起始值，则以起始值为准开始累计， 累计值 = 起始值 </span> 
                                                  </div> 
                                                  <div> 
                                                   <span style="color:#262626;">2. 如果没有起始值， 则累计值以数组的第一个数组元素作为起始值开始累计 </span> 
                                                  </div> 
                                                  <div> 
                                                   <span style="color:#262626;">3. 后面每次遍历就会用后面的数组元素 累计到 </span> 
                                                   <span style="color:#c00000;">累计值 </span> 
                                                   <span style="color:#262626;">里面 （类似求和里面的 sum ）</span> 
                                                  </div> 
                                                  <div></div> 
                                                  <div> 
                                                   <span style="color:#262626;"><strong>使用场景：求和运算</strong></span> 
                                                   <pre><code class="language-javascript">  &lt;script&gt;
    const arr = [1, 2, 3]
    const re = arr.reduce((prev, item) =&gt; prev + item)
    console.log(re)
  &lt;/script&gt;</code></pre> 
                                                   <div> 
                                                    <span style="color:#262626;"><strong>2. 数组常见方法-其他方法</strong></span> 
                                                    <img alt="" height="498" src="https://images2.imgbox.com/65/93/b4sUSHrc_o.png" width="1134"> 
                                                   </div> 
                                                   <div></div> 
                                                   <div> 
                                                    <span style="color:#262626;"><strong>3. 数组常见方法- 伪数组转换为真数组 </strong></span> 
                                                   </div> 
                                                   <div> 
                                                    <span style="color:#262626;">静态方法 </span> 
                                                    <span style="color:#be191c;">Array.from()</span> 
                                                    <pre><code class="language-javascript">  &lt;script&gt;
    //  Array.from(lis) 把伪数组转换为真数组
    const lis = document.querySelectorAll('ul li')
    // console.log(lis)
    // lis.pop() 报错
    const liss = Array.from(lis)
    liss.pop()
    console.log(liss)
  &lt;/script&gt;</code></pre> 
                                                    <h4 id="5.3%20String"><span style="color:#ad2a26;">5.3 String </span></h4> 
                                                   </div> 
                                                   <div> 
                                                    <span style="color:#262626;">在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法。</span> 
                                                   </div> 
                                                   <div> 
                                                    <div> 
                                                     <span style="color:#262626;">之所以具有对象特征的原因是字符串、数值、布尔类型数据是 JavaScript 底层使用 Object 构造函数“包装”来的，被称为</span> 
                                                     <span style="color:#c00000;"><strong>包装类型</strong></span> 
                                                     <span style="color:#262626;">。</span> 
                                                    </div> 
                                                    <div></div> 
                                                    <div> 
                                                     <div> 
                                                      <span style="color:#262626;"><strong>1. 字符串常见实例方法</strong></span> 
                                                      <img alt="" height="640" src="https://images2.imgbox.com/33/65/Enh2X43h_o.png" width="1098"> 
                                                     </div> 
                                                     <pre><code class="language-javascript">  &lt;script&gt;
    //1. split 把字符串 转换为 数组  和 join() 相反
    // const str = 'pink,red'
    // const arr = str.split(',')
    // console.log(arr)
    // const str1 = '2022-4-8'
    // const arr1 = str1.split('-')
    // console.log(arr1)
    // 2. 字符串的截取   substring(开始的索引号[， 结束的索引号])
    // 2.1 如果省略 结束的索引号，默认取到最后
    // 2.2 结束的索引号不包含想要截取的部分
    // const str = '今天又要做核酸了'
    // console.log(str.substring(5, 7))  // [5,7)
    // 3. startsWith 判断是不是以某个字符开头
    // const str = 'pink老师上课中'
    // console.log(str.startsWith('pink'))
    // 4. includes 判断某个字符是不是包含在一个字符串里面
    const str = '我是pink老师'
    console.log(str.includes('pink')) // true
  &lt;/script&gt;</code></pre> 
                                                     <h4 id="%E6%98%BE%E7%A4%BA%E8%B5%A0%E5%93%81%E7%BB%83%E4%B9%A0"><span style="color:#c00000;">显示赠品练习</span></h4> 
                                                     <pre><code class="language-javascript"> &lt;script&gt;
    const gift = '50g的茶叶,清洗球'
    // 1. 把字符串拆分为数组
    // console.log(gift.split(',')) [,]
    // 2. 根据数组元素的个数，生成 对应 span标签
    // const str = gift.split(',').map(function (item) {
    //   return `&lt;span&gt;【赠品】 ${item}&lt;/span&gt; &lt;br&gt;`
    // }).join('')

    // // console.log(str)
    // document.querySelector('div').innerHTML = str
    document.querySelector('div').innerHTML = gift.split(',').map(item =&gt; `&lt;span&gt;【赠品】 ${item}&lt;/span&gt; &lt;br&gt;`).join('')
  &lt;/script&gt;</code></pre> 
                                                     <h4 id="5.4%20Number"><span style="color:#be191c;">5.4 Number </span></h4> 
                                                     <div> 
                                                      <span style="color:#262626;">Number 是内置的构造函数，用于创建数值 </span> 
                                                     </div> 
                                                     <div> 
                                                      <span style="color:#262626;"><strong>常用方法：</strong> </span> 
                                                      <span style="color:#be191c;"><strong>toFixed() </strong>设置保留小数位的长度</span> 
                                                      <pre><code class="language-javascript"> &lt;script&gt;
    // toFixed 方法可以让数字指定保留的小数位数
    const num = 10.923
    // console.log(num.toFixed())
    console.log(num.toFixed(1))
    const num1 = 10
    console.log(num1.toFixed(2))
  &lt;/script&gt;</code></pre> 
                                                      <h3 id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%B1%95%E7%A4%BA"><span style="color:#ad2a26;">综合案例：购物车展示</span></h3> 
                                                      <pre><code class="language-javascript">&lt;body&gt;
    &lt;div class="list"&gt;
        &lt;!-- &lt;div class="item"&gt;
      &lt;img src="https://yanxuan-item.nosdn.127.net/84a59ff9c58a77032564e61f716846d6.jpg" alt=""&gt;
      &lt;p class="name"&gt;称心如意手摇咖啡磨豆机咖啡豆研磨机 &lt;span class="tag"&gt;【赠品】10优惠券&lt;/span&gt;&lt;/p&gt;
      &lt;p class="spec"&gt;白色/10寸&lt;/p&gt;
      &lt;p class="price"&gt;289.90&lt;/p&gt;
      &lt;p class="count"&gt;x2&lt;/p&gt;
      &lt;p class="sub-total"&gt;579.80&lt;/p&gt;
    &lt;/div&gt; --&gt;
    &lt;/div&gt;
    &lt;div class="total"&gt;
        &lt;div&gt;合计：&lt;span class="amount"&gt;1000.00&lt;/span&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
        const goodsList = [
            {
                id: '4001172',
                name: '称心如意手摇咖啡磨豆机咖啡豆研磨机',
                price: 289.9,
                picture: 'https://yanxuan-item.nosdn.127.net/84a59ff9c58a77032564e61f716846d6.jpg',
                count: 2,
                spec: { color: '白色' }
            },
            {
                id: '4001009',
                name: '竹制干泡茶盘正方形沥水茶台品茶盘',
                price: 109.8,
                picture: 'https://yanxuan-item.nosdn.127.net/2d942d6bc94f1e230763e1a5a3b379e1.png',
                count: 3,
                spec: { size: '40cm*40cm', color: '黑色' }
            },
            {
                id: '4001874',
                name: '古法温酒汝瓷酒具套装白酒杯莲花温酒器',
                price: 488,
                picture: 'https://yanxuan-item.nosdn.127.net/44e51622800e4fceb6bee8e616da85fd.png',
                count: 1,
                spec: { color: '青色', sum: '一大四小' }
            },
            {
                id: '4001649',
                name: '大师监制龙泉青瓷茶叶罐',
                price: 139,
                picture: 'https://yanxuan-item.nosdn.127.net/4356c9fc150753775fe56b465314f1eb.png',
                count: 1,
                spec: { size: '小号', color: '紫色' },
                gift: '50g茶叶,清洗球,宝马, 奔驰'
            }
        ]

        // 1. 根据数据渲染页面
        document.querySelector('.list').innerHTML = goodsList.map(item =&gt; {
            // console.log(item)  // 每一条对象
            // 对象解构  item.price item.count
            const { picture, name, count, price, spec, gift } = item
            // 规格文字模块处理
            const text = Object.values(spec).join('/')
            // 计算小计模块 单价 * 数量  保留两位小数 
            // 注意精度问题，因为保留两位小数，所以乘以 100  最后除以100
            const subTotal = ((price * 100 * count) / 100).toFixed(2)
            // 处理赠品模块 '50g茶叶,清洗球'
            const str = gift ? gift.split(',').map(item =&gt; `&lt;span class="tag"&gt;【赠品】${item}&lt;/span&gt; `).join('') : ''
            return `
        &lt;div class="item"&gt;
          &lt;img src=${picture} alt=""&gt;
          &lt;p class="name"&gt;${name} ${str} &lt;/p&gt;
          &lt;p class="spec"&gt;${text} &lt;/p&gt;
          &lt;p class="price"&gt;${price.toFixed(2)}&lt;/p&gt;
          &lt;p class="count"&gt;x${count}&lt;/p&gt;
          &lt;p class="sub-total"&gt;${subTotal}&lt;/p&gt;
        &lt;/div&gt;
      `
        }).join('')

        // 3. 合计模块
        const total = goodsList.reduce((prev, item) =&gt; prev + (item.price * 100 * item.count) / 100, 0)
        // console.log(total)
        document.querySelector('.amount').innerHTML = total.toFixed(2)
    &lt;/script&gt;
&lt;/body&gt;
</code></pre> 
                                                      <h3 id="6.%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span style="color:#c00000;">6.编程思想</span></h3> 
                                                      <h4 id="6.1%20%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B"><span style="color:#ad2a26;">6.1 面向过程编程 </span></h4> 
                                                      <div> 
                                                       <span style="color:#c00000;"><strong>面向过程</strong></span> 
                                                       <span style="color:#262626;">就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。 </span> 
                                                      </div> 
                                                      <div> 
                                                       <div> 
                                                        <span style="color:#c00000;">面向过程，就是按照我们分析好了的步骤，按照步骤解决问题。 </span> 
                                                       </div> 
                                                       <div></div> 
                                                       <div> 
                                                        <h4 id="6.2%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%20(oop)"><span style="color:#ad2a26;">6.2 面向对象编程 (oop) </span></h4> 
                                                        <div> 
                                                         <span style="color:#c00000;"><strong>面向对象</strong></span> 
                                                         <span style="color:#262626;">是把事务分解成为一个个对象，然后由对象之间分工与合作。</span> 
                                                        </div> 
                                                        <div> 
                                                         <span style="color:#c00000;">面向对象是以对象功能来划分问题，而不是步骤。</span> 
                                                        </div> 
                                                        <div></div> 
                                                        <div> 
                                                         <div> 
                                                          <span style="color:#262626;">在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。 </span> 
                                                         </div> 
                                                         <div> 
                                                          <span style="color:#262626;">面向对象编程具有</span> 
                                                          <span style="color:#be191c;">灵活、代码可复用、容易维护和开发</span> 
                                                          <span style="color:#262626;">的优点，更适合多人合作的大型软件项目。 </span> 
                                                         </div> 
                                                         <div> 
                                                          <strong><span style="color:#262626;">面向对象的特性：</span></strong> 
                                                          <span style="color:#be191c;">封装性、继承性、多态性</span> 
                                                         </div> 
                                                         <div></div> 
                                                         <h4 id="6.3%20%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AF%B9%E6%AF%94"><span style="color:#ad2a26;">6.3 面向过程和面向对象的对比</span></h4> 
                                                         <p><img alt="" height="254" src="https://images2.imgbox.com/87/ff/C87cVFT4_o.png" width="1200"></p> 
                                                         <p><span style="color:#c00000;">前端不同于其他语言，面向过程更多</span></p> 
                                                         <h3 id="7.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E5%B0%81%E8%A3%85%E6%80%A7%EF%BC%89"><span style="color:#ad2a26;">7. 构造函数（封装性）</span></h3> 
                                                         <div> 
                                                          <span style="color:#262626;">封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装。 </span> 
                                                         </div> 
                                                         <div> 
                                                          <span style="color:#262626;">同样的将变量和函数组合到了一起并能通过 this 实现数据的共享，所不同的是借助构造函数创建出来的实例对象之间是彼此不影响的。</span> 
                                                         </div> 
                                                         <div> 
                                                          <div> 
                                                           <strong><span style="color:#262626;">总结： </span></strong> 
                                                          </div> 
                                                          <div> 
                                                           <span style="color:#262626;">1. 构造函数体现了</span> 
                                                           <span style="color:#be191c;">面向对象的封装特性 </span> 
                                                          </div> 
                                                          <div> 
                                                           <span style="color:#262626;">2. 构造函数实例创建的对象彼此独立、互不影响 </span> 
                                                          </div> 
                                                          <div></div> 
                                                          <div> 
                                                           <div> 
                                                            <span style="color:#262626;">面向对象编程的特性：比如封装性、继承性等，可以借助于构造函数来实现 </span> 
                                                           </div> 
                                                           <div> 
                                                            <span style="color:#262626;">但是</span> 
                                                            <span style="color:#c00000;">存在浪费内存的问题</span> 
                                                           </div> 
                                                           <div> 
                                                            <img alt="" height="244" src="https://images2.imgbox.com/2c/e9/7CHyXCf5_o.png" width="675"> 
                                                           </div> 
                                                           <h3 id="8.%E5%8E%9F%E5%9E%8B"><span style="color:#c00000;">8.原型</span></h3> 
                                                           <h4 id="8.1%20%E5%8E%9F%E5%9E%8B"><span style="color:#ad2a26;">8.1 原型</span></h4> 
                                                           <div> 
                                                            <span style="color:#262626;">构造函数通过原型分配的函数是所有对象所</span> 
                                                            <span style="color:#c00000;"><strong>共享的</strong></span> 
                                                            <span style="color:#c00000;">。 </span> 
                                                           </div> 
                                                           <div></div> 
                                                           <div> 
                                                            <span style="color:#262626;">JavaScript 规定，</span> 
                                                            <span style="color:#c00000;">每一个构造函数都有一个 prototype 属性</span> 
                                                            <span style="color:#262626;">，指向另一个对象，所以我们也称为原型对象。这个对象可以挂载函数，对象实例化不会多次创建原型上函数，</span> 
                                                            <span style="color:#be191c;">节约内存</span> 
                                                            <span style="color:#262626;">。</span> 
                                                           </div> 
                                                           <div> 
                                                            <span style="color:#c00000;">可以把那些不变的方法直接定义在 prototype 对象上，这样所有对象的实例都可以共享这些方法。 </span> 
                                                           </div> 
                                                           <div></div> 
                                                           <div> 
                                                            <span style="color:#c00000;">构造函数和原型对象中的 <strong>this</strong> 都指向 <strong>实例化的对象。</strong></span> 
                                                           </div> 
                                                           <div> 
                                                            <img alt="" height="167" src="https://images2.imgbox.com/fd/e9/FqVVhxh5_o.png" width="486"> 
                                                           </div> 
                                                           <h4 id="%C2%A08.2%20%E5%8E%9F%E5%9E%8B%20-%20this%E6%8C%87%E5%90%91"> <span style="color:#ad2a26;">8.2 原型 - this指向</span></h4> 
                                                           <p><span style="color:#c00000;">构造函数和原型对象中的this 都指向 <strong>实例化的对象</strong></span></p> 
                                                           <pre><code class="language-javascript">  &lt;script&gt;
    let that
    function Star(uname) {
      // that = this
      // console.log(this)
      this.uname = uname
    }
    // 原型对象里面的函数this指向的还是 实例对象 ldh
    Star.prototype.sing = function () {
      that = this
      console.log('唱歌')
    }
    // 实例对象 ldh   
    // 构造函数里面的 this 就是  实例对象  ldh
    const ldh = new Star('刘德华')
    ldh.sing()
    console.log(that === ldh)
  &lt;/script&gt;</code></pre> 
                                                           <h4 id="8.3%20constructor%20%E5%B1%9E%E6%80%A7"><span style="color:#ad2a26;">8.3 </span><span style="color:#c00000;">constructor 属性</span></h4> 
                                                           <div> 
                                                            <span style="color:#000000;">每个原型对象里面都有个constructor 属性（</span> 
                                                            <span style="color:#262626;">constructor 构造函数</span> 
                                                            <span style="color:#000000;">） </span> 
                                                           </div> 
                                                           <div> 
                                                            <span style="color:#000000;"><strong>作用：</strong></span> 
                                                            <span style="color:#262626;">该属性</span> 
                                                            <span style="color:#c00000;">指向</span> 
                                                            <span style="color:#262626;">该原型对象的</span> 
                                                            <span style="color:#c00000;">构造函数， 简单理解，就是指向我的爸爸（构造函数）</span> 
                                                            <img alt="" height="199" src="https://images2.imgbox.com/5a/b6/0cHe0KRn_o.png" width="892"> 
                                                           </div> 
                                                           <div> 
                                                            <span style="color:#000000;"><strong>使用场景： </strong></span> 
                                                           </div> 
                                                           <div> 
                                                            <span style="color:#262626;">如果有多个对象的方法，我们可以给原型对象采取对象形式赋值。</span> 
                                                           </div> 
                                                           <div> 
                                                            <span style="color:#262626;">但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了 </span> 
                                                           </div> 
                                                           <div> 
                                                            <span style="color:#262626;">此时，我们可以在修改后的原型对象中，</span> 
                                                            <span style="color:#be191c;">添加一个 constructor 指向原来的构造函数</span> 
                                                            <span style="color:#262626;">。</span> 
                                                            <pre><code class="language-javascript">  &lt;script&gt;
    // constructor  单词 构造函数

    // Star.prototype.sing = function () {
    //   console.log('唱歌')
    // }
    // Star.prototype.dance = function () {
    //   console.log('跳舞')
    // }
    function Star() {
    }
    // console.log(Star.prototype)
    Star.prototype = {
      // 从新指回创造这个原型对象的 构造函数
      constructor: Star,
      sing: function () {
        console.log('唱歌')
      },
      dance: function () {
        console.log('跳舞')
      },
    }
    console.log(Star.prototype)
    // console.log(Star.prototype.constructor)

    // const ldh = new Star()
    // console.log(Star.prototype.constructor === Star)
  &lt;/script&gt;</code></pre> 
                                                            <h4 id="8.4%20%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B"><span style="color:#ad2a26;">8.4 对象原型</span></h4> 
                                                            <p><span style="color:#c00000;">对象都会有一个属性<strong> __proto__</strong></span><span style="color:#be191c;"><strong> </strong>指向构造函数的 prototype 原型对象</span><span style="color:#262626;">，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __proto__ 原型的存在。</span><img alt="" height="321" src="https://images2.imgbox.com/d3/c9/1FEjZZ2n_o.png" width="594"></p> 
                                                            <div> 
                                                             <strong><span style="color:#000000;">注意： </span></strong> 
                                                            </div> 
                                                            <div> 
                                                             <span style="color:#000000;">__proto__ 是JS非标准属性 </span> 
                                                            </div> 
                                                            <div> 
                                                             <span style="color:#000000;">[[prototype]]和__proto__意义相同 </span> 
                                                            </div> 
                                                            <div> 
                                                             <span style="color:#000000;">用来表明当前实例对象指向哪个原型对象prototype </span> 
                                                            </div> 
                                                            <div> 
                                                             <span style="color:#404040;"> </span> 
                                                             <span style="color:#000000;">__proto__对象原型里面也有一个 </span> 
                                                             <span style="color:#262626;">constructor属性，</span> 
                                                             <span style="color:#c00000;">指向创建该实例对象的构造函数</span> 
                                                             <img alt="" height="325" src="https://images2.imgbox.com/e0/12/WrrRP6EU_o.png" width="616"> 
                                                            </div> 
                                                            <p><span style="color:#be191c;"><strong>总结（建议反复观看）：</strong></span></p> 
                                                            <div> 
                                                             <span style="color:#000000;">1. prototype是什么？哪里来的？ </span> 
                                                            </div> 
                                                            <div> 
                                                             <span style="color:#000000;">        原型（原型对象） </span> 
                                                            </div> 
                                                            <div> 
                                                             <span style="color:#000000;">        构造函数都自动有原型 </span> 
                                                            </div> 
                                                            <div></div> 
                                                            <div> 
                                                             <span style="color:#000000;">2. constructor属性在哪里？作用干啥的？ </span> 
                                                            </div> 
                                                            <div> 
                                                             <span style="color:#000000;">        prototype原型和对象原型__proto__里面都有 </span> 
                                                            </div> 
                                                            <div> 
                                                             <span style="color:#000000;">        都</span> 
                                                             <span style="color:#c00000;">指向</span> 
                                                             <span style="color:#000000;">创建实例对象/原型的</span> 
                                                             <span style="color:#c00000;">构造函数 </span> 
                                                            </div> 
                                                            <div></div> 
                                                            <div> 
                                                             <span style="color:#000000;">3. __proto__属性在哪里？指向谁？ </span> 
                                                            </div> 
                                                            <div> 
                                                             <span style="color:#000000;">        在实例对象里面 </span> 
                                                            </div> 
                                                            <div> 
                                                             <span style="color:#000000;">        指向原型 prototype</span> 
                                                            </div> 
                                                            <div></div> 
                                                           </div> 
                                                           <h4 id="8.5%C2%A0%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF"><strong><span style="color:#ad2a26;">8.5 原型继承</span></strong></h4> 
                                                           <div> 
                                                            <span style="color:#262626;">继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承的特性。 </span> 
                                                           </div> 
                                                           <div></div> 
                                                           <div> 
                                                            <span style="color:#c00000;"><strong>1. 封装-</strong></span> 
                                                            <span style="color:#262626;"><strong>抽取公共部分</strong></span> 
                                                           </div> 
                                                           <div> 
                                                            <span style="color:#c00000;"><strong>2. 继承-</strong></span> 
                                                            <span style="color:#262626;">让男人和女人都能<strong>继承</strong>人类<strong>公共的一些属性和方法</strong></span> 
                                                            <pre><code class="language-javascript">  &lt;script&gt;
    // 继续抽取   公共的部分放到原型上
    // const Person1 = {
    //   eyes: 2,
    //   head: 1
    // }
    // const Person2 = {
    //   eyes: 2,
    //   head: 1
    // }
    // 构造函数  new 出来的对象 结构一样，但是对象不一样
    function Person() {
      this.eyes = 2
      this.head = 1
    }
    // 女人  构造函数   继承  想要 继承 Person
    function Woman() {

    }
    // Woman 通过原型来继承 Person
    Woman.prototype = Person  // {eyes: 2, head: 1} 
    // 指回原来的构造函数
    Woman.prototype.constructor = Woman
  &lt;/script&gt;</code></pre> 
                                                            <div> 
                                                             <span style="color:#c00000;"><strong>3. 问题： </strong></span> 
                                                             <span style="color:#000000;">如果我们给女人添加了一个baby的方法，发现男人自动也添加这个方法</span> 
                                                            </div> 
                                                            <div> 
                                                             <span style="color:#c00000;"><strong>原因：</strong></span> 
                                                             <span style="color:#000000;">男人和女人都同时使用了同一个对象，根据引用类型的特点，他们指向同一个对象，修改一个就会都影响</span> 
                                                             <img alt="" height="401" src="https://images2.imgbox.com/5a/e9/9ATDFQi7_o.png" width="1180"> 
                                                            </div> 
                                                            <div> 
                                                             <span style="color:#c00000;"><strong>4. 解决： </strong></span> 
                                                            </div> 
                                                            <div> 
                                                             <span style="color:#000000;">需求：男人和女人不要使用同一个对象，但是不同对象里面包含相同的属性和方法 </span> 
                                                            </div> 
                                                            <div> 
                                                             <span style="color:#000000;">答案：构造函数    new 每次都会创建一个新的对象</span> 
                                                            </div> 
                                                            <div></div> 
                                                            <div> 
                                                             <span style="color:#c00000;"><strong>5. 继承写法完善</strong></span> 
                                                             <pre><code class="language-javascript">  &lt;script&gt;
    // 继续抽取   公共的部分放到原型上
    // 构造函数  new 出来的对象 结构一样，但是对象不一样
    function Person() {
      this.eyes = 2
      this.head = 1
    }
    // console.log(new Person)
    // 女人  构造函数   继承  想要 继承 Person
    function Woman() {

    }
    // Woman 通过原型来继承 Person
    // 父构造函数（父类）   子构造函数（子类）
    // 子类的原型 =  new 父类  
    Woman.prototype = new Person()   // {eyes: 2, head: 1} 
    // 指回原来的构造函数
    Woman.prototype.constructor = Woman

    // 给女人添加一个方法  生孩子
    Woman.prototype.baby = function () {
      console.log('宝贝')
    }
    const red = new Woman()
    console.log(red)
    // console.log(Woman.prototype)
    // 男人 构造函数  继承  想要 继承 Person
    function Man() {

    }
    // 通过 原型继承 Person
    Man.prototype = new Person()
    Man.prototype.constructor = Man
    const pink = new Man()
    console.log(pink)
  &lt;/script&gt;</code></pre> 
                                                             <h4 id="8.6%20%E5%8E%9F%E5%9E%8B%E9%93%BE"><span style="color:#ad2a26;">8.6 原型链</span></h4> 
                                                             <div> 
                                                              <span style="color:#000000;">基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对象的链状结构关系称为</span> 
                                                              <strong><span style="color:#be191c;">原型链</span></strong> 
                                                              <img alt="" height="466" src="https://images2.imgbox.com/94/a4/CJcxJnf7_o.png" width="996"> 
                                                             </div> 
                                                             <div> 
                                                              <div> 
                                                               <strong><span style="color:#ad2a26;">原型链-查找规则 </span></strong> 
                                                              </div> 
                                                              <div> 
                                                               <span style="color:#404040;">① </span> 
                                                               <span style="color:#262626;">当访问一个对象的属性（包括方法）时，首先查找这个</span> 
                                                               <span style="color:#c00000;">对象自身</span> 
                                                               <span style="color:#262626;">有没有该属性。 </span> 
                                                              </div> 
                                                              <div> 
                                                               <span style="color:#404040;">② </span> 
                                                               <span style="color:#262626;">如果没有就查找它的原型（也就是 __proto__指向的 </span> 
                                                               <span style="color:#c00000;">prototype 原型对象</span> 
                                                               <span style="color:#262626;">） </span> 
                                                              </div> 
                                                              <div> 
                                                               <span style="color:#404040;">③ </span> 
                                                               <span style="color:#262626;">如果还没有就查找原型对象的原型（</span> 
                                                               <span style="color:#c00000;">Object的原型对象</span> 
                                                               <span style="color:#262626;">） </span> 
                                                              </div> 
                                                              <div> 
                                                               <span style="color:#404040;">④ </span> 
                                                               <span style="color:#262626;">依此类推一直找到 Object 为止（</span> 
                                                               <span style="color:#c00000;">null</span> 
                                                               <span style="color:#262626;">） </span> 
                                                              </div> 
                                                              <div> 
                                                               <span style="color:#404040;">⑤ </span> 
                                                               <span style="color:#262626;">__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线 </span> 
                                                              </div> 
                                                              <div> 
                                                               <span style="color:#404040;">⑥ </span> 
                                                               <span style="color:#000000;">可以使用 </span> 
                                                               <span style="color:#be191c;">instanceof</span> 
                                                               <span style="color:#262626;"> 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</span> 
                                                               <pre><code class="language-javascript">  &lt;script&gt;
    // function Objetc() {}
    console.log(Object.prototype)
    console.log(Object.prototype.__proto__)

    function Person() {

    }
    const ldh = new Person()
    // console.log(ldh.__proto__ === Person.prototype)
    // console.log(Person.prototype.__proto__ === Object.prototype)
    console.log(ldh instanceof Person)
    console.log(ldh instanceof Object)
    console.log(ldh instanceof Array)
    console.log([1, 2, 3] instanceof Array)
    console.log(Array instanceof Object)
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
                                                               <h3 id="%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%B6%88%E6%81%AF%E6%8F%90%E7%A4%BA%E5%AF%B9%E8%B1%A1%E5%B0%81%E8%A3%85"><span style="color:#ad2a26;">综合案例：消息提示对象封装</span></h3> 
                                                               <pre><code class="language-html">&lt;body&gt;
    &lt;button id="delete"&gt;删除&lt;/button&gt;
    &lt;button id="login"&gt;登录&lt;/button&gt;

    &lt;!-- &lt;div class="modal"&gt;
    &lt;div class="header"&gt;温馨提示 &lt;i&gt;x&lt;/i&gt;&lt;/div&gt;
    &lt;div class="body"&gt;您没有删除权限操作&lt;/div&gt;
  &lt;/div&gt; --&gt;


    &lt;script&gt;
        // 1.  模态框的构造函数
        function Modal(title = '', message = '') {
            // 创建 modal 模拟框盒子
            // 1.1 创建 div 标签
            this.modalBox = document.createElement('div')
            // 1.2 给 div 标签添加类名为 modal
            this.modalBox.className = 'modal'
            // 1.3 modal 盒子内部填充 2个 div 标签并且修改文字内容
            this.modalBox.innerHTML = `
                &lt;div class="header"&gt;${title}&lt;i&gt;x&lt;/i&gt;&lt;/div&gt;
                &lt;div class="body"&gt;${message}&lt;/div&gt;
            `
        }

        // 2.给构造函数原型对象挂载 open 方法
        Modal.prototype.open = function () {
            // 先来判断页面中是否有 modal 盒子，如果有先删除，否则继续添加
            const box = document.querySelector('.modal')
            box &amp;&amp; box.remove()
            // 注意这个方法不要用箭头函数
            // 把刚才创建的 modalBox 显示到页面 body 中
            document.body.append(this.modalBox)

            // 要等着盒子显示出来，就可以绑定点击事件了
            this.modalBox.querySelector('i').addEventListener('click', () =&gt; {
                // 这个地方需要用到箭头函数
                // 这个 this 指向实例对象
                this.close()
            })
        }

        // 3. 关闭方法 挂载 到 模态框的构造函数原型身上
        Modal.prototype.close = function () {
            this.modalBox.remove()
        }

        // 4. 按钮点击
        document.querySelector('#delete').addEventListener('click', () =&gt; {
            const m = new Modal('温馨提示', '您没有权限删除')
            // 调用 打开方法
            m.open()
        })

        // 5. 按钮点击
        document.querySelector('#login').addEventListener('click', () =&gt; {
            const m = new Modal('友情提示', '您还么有注册账号')
            // 调用 打开方法
            m.open()
        })

    &lt;/script&gt;
&lt;/body&gt;</code></pre> 
                                                               <h3 id="9.%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span style="color:#c00000;">9.深浅拷贝</span></h3> 
                                                               <h4 id="9.1%20%E6%B5%85%E6%8B%B7%E8%B4%9D"><span style="color:#ad2a26;">9.1 浅拷贝 </span></h4> 
                                                               <p><span style="color:#262626;">浅拷贝：拷贝的是地址 </span></p> 
                                                               <div> 
                                                                <span style="color:#262626;"><strong>常见方法： </strong></span> 
                                                               </div> 
                                                               <div> 
                                                                <span style="color:#262626;">1. 拷贝对象：Object.assgin() / 展开运算符 {...obj} 拷贝对象 </span> 
                                                               </div> 
                                                               <div> 
                                                                <span style="color:#262626;">2.拷贝数组：Array.prototype.concat() 或者 [...arr]</span> 
                                                                <pre><code class="language-javascript">  &lt;script&gt;
    const obj = {
      uname: 'pink',
      age: 18,
      family: {
        baby: '小pink'
      }
    }
    // 浅拷贝
    // const o = { ...obj }
    // console.log(o)
    // o.age = 20
    // console.log(o)
    // console.log(obj)
    const o = {}
    Object.assign(o, obj)
    o.age = 20
    o.family.baby = '老pink'
    console.log(o)
    console.log(obj)
  &lt;/script&gt;</code></pre> 
                                                                <div> 
                                                                 <span style="color:#262626;">如果是</span> 
                                                                 <span style="color:#be191c;">简单数据类型拷贝值，引用数据类型拷贝的是地址</span> 
                                                                 <span style="color:#262626;"> (简单理解： 如果是单层对象，没问题，如果有多层就有问题) </span> 
                                                                </div> 
                                                                <div></div> 
                                                                <div> 
                                                                 <span style="color:#be191c;"><strong>总结：</strong></span> 
                                                                </div> 
                                                                <div> 
                                                                 <div> 
                                                                  <span style="color:#000000;">1. 直接赋值和浅拷贝有什么区别？ </span> 
                                                                 </div> 
                                                                 <div> 
                                                                  <span style="color:#000000;">        直接赋值的方法，只要是对象，都会相互影响，因为是直接拷贝对象栈里面的地址 </span> 
                                                                 </div> 
                                                                 <div> 
                                                                  <span style="color:#000000;">        浅拷贝如果是一层对象，不相互影响，如果出现多层对象拷贝还会相互影响 </span> 
                                                                 </div> 
                                                                 <div> 
                                                                  <span style="color:#000000;">2. 浅拷贝怎么理解？ </span> 
                                                                 </div> 
                                                                 <div> 
                                                                  <span style="color:#000000;">        拷贝对象之后，里面的属性值是简单数据类型直接拷贝值 </span> 
                                                                 </div> 
                                                                 <div> 
                                                                  <span style="color:#000000;">        如果属性值是引用数据类型则拷贝的是地址</span> 
                                                                 </div> 
                                                                 <div></div> 
                                                                 <h4 id="9.2%20%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span style="color:#ad2a26;">9.2 深拷贝 </span></h4> 
                                                                 <div> 
                                                                  <span style="color:#262626;">深拷贝：拷贝的是对象，不是地址 </span> 
                                                                 </div> 
                                                                 <div></div> 
                                                                 <div> 
                                                                  <span style="color:#262626;"><strong>常见方法： </strong></span> 
                                                                 </div> 
                                                                 <div></div> 
                                                                 <div> 
                                                                  <div> 
                                                                   <span style="color:#404040;"><strong>1. </strong></span> 
                                                                   <span style="color:#262626;"><strong>通过递归实现深拷贝 </strong></span> 
                                                                  </div> 
                                                                  <div> 
                                                                   <span style="color:#262626;"><strong>函数递归： </strong></span> 
                                                                  </div> 
                                                                  <div> 
                                                                   <span style="color:#c00000;">如果一个函数在内部可以调用其本身，那么这个函数就是递归函数 </span> 
                                                                  </div> 
                                                                  <div> 
                                                                   <span style="color:#262626;">简单理解:函数内部自己调用自己， 这个函数就是递归函数 </span> 
                                                                  </div> 
                                                                  <div> 
                                                                   <span style="color:#262626;">递归函数的作用和循环效果类似 </span> 
                                                                  </div> 
                                                                  <div> 
                                                                   <span style="color:#262626;">由于递归很容易发生“栈溢出”错误（stack overflow），所以</span> 
                                                                   <span style="color:#c00000;">必须要加退出条件 return</span> 
                                                                  </div> 
                                                                  <div></div> 
                                                                  <div> 
                                                                   <strong><span style="color:#262626;">利用递归函数实现 setTimeout 模拟 setInterval效果 </span></strong> 
                                                                   <pre><code class="language-html">&lt;body&gt;
  &lt;div&gt;&lt;/div&gt;
  &lt;script&gt;
    function getTime() {
      document.querySelector('div').innerHTML = new Date().toLocaleString()
      setTimeout(getTime, 1000)
    }
    getTime()
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
                                                                   <div> 
                                                                    <span style="color:#262626;"><strong>通过递归函数实现深拷贝（简版）</strong></span> 
                                                                    <pre><code class="language-javascript">  &lt;script&gt;
    const obj = {
      uname: 'pink',
      age: 18,
      hobby: ['乒乓球', '足球'],
      family: {
        baby: '小pink'
      }
    }
    const o = {}
    // 拷贝函数
    function deepCopy(newObj, oldObj) {
      debugger
      for (let k in oldObj) {
        // 处理数组的问题  一定先写数组再写对象 不能颠倒  因为数组属于对象
        if (oldObj[k] instanceof Array) {
          newObj[k] = []
          //  newObj[k] 接收 []  hobby
          //  oldObj[k]   ['乒乓球', '足球']
          deepCopy(newObj[k], oldObj[k])
        } else if (oldObj[k] instanceof Object) {
          newObj[k] = {}
          deepCopy(newObj[k], oldObj[k])
        }
        else {
          //  k  属性名 uname age    oldObj[k]  属性值  18
          // newObj[k]  === o.uname  给新对象添加属性
          newObj[k] = oldObj[k]
        }
      }
    }
    deepCopy(o, obj) // 函数调用  两个参数 o 新对象  obj 旧对象
    console.log(o)
    o.age = 20
    o.hobby[0] = '篮球'
    o.family.baby = '老pink'
    console.log(obj)
    console.log([1, 23] instanceof Object)
  &lt;/script&gt;</code></pre> 
                                                                    <div> 
                                                                     <p><span style="color:#262626;"><strong>2. js库lodash里面cloneDeep内部实现了深拷贝</strong></span></p> 
                                                                     <p><span style="color:#262626;"><strong>lodash官网：</strong></span><a href="https://www.lodashjs.com/" rel="nofollow" title="Lodash 简介 | Lodash中文文档 | Lodash中文网">Lodash 简介 | Lodash中文文档 | Lodash中文网</a></p> 
                                                                     <pre><code class="language-javascript">&lt;body&gt;
  &lt;!-- 先引用 --&gt;
  &lt;script src="./lodash.min.js"&gt;&lt;/script&gt;
  &lt;script&gt;
    const obj = {
      uname: 'pink',
      age: 18,
      hobby: ['乒乓球', '足球'],
      family: {
        baby: '小pink'
      }
    }
    const o = _.cloneDeep(obj)
    console.log(o)
    o.family.baby = '老pink'
    console.log(obj)
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
                                                                     <div> 
                                                                      <span style="color:#c00000;"><strong>3. 通过JSON.stringify()实现</strong></span> 
                                                                      <pre><code class="language-javascript">  &lt;script&gt;
    const obj = {
      uname: 'pink',
      age: 18,
      hobby: ['乒乓球', '足球'],
      family: {
        baby: '小pink'
      }
    }
    // 把对象转换为 JSON 字符串
    // console.log(JSON.stringify(obj))
    const o = JSON.parse(JSON.stringify(obj))
    console.log(o)
    o.family.baby = '123'
    console.log(obj)
  &lt;/script&gt;</code></pre> 
                                                                      <p><span style="color:#be191c;"><strong>总结：</strong></span></p> 
                                                                      <div> 
                                                                       <strong><span style="color:#000000;">实现深拷贝三种方式：</span></strong> 
                                                                      </div> 
                                                                      <div> 
                                                                       <span style="color:#000000;">1.自己利用递归函数书写深拷贝 </span> 
                                                                      </div> 
                                                                      <div> 
                                                                       <span style="color:#000000;">2.利用js库 lodash里面的 _.cloneDeep() </span> 
                                                                      </div> 
                                                                      <div> 
                                                                       <span style="color:#000000;">3.利用JSON字符串转换</span> 
                                                                      </div> 
                                                                      <div> 
                                                                       <div></div> 
                                                                       <h3 id="10.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span style="color:#c00000;">10.异常处理</span></h3> 
                                                                       <h4 id="10.1%20throw%20%E6%8A%9B%E5%BC%82%E5%B8%B8%C2%A0"><span style="color:#be191c;">10.1 throw 抛异常 </span></h4> 
                                                                       <p><span style="color:#0d0016;">异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行。</span></p> 
                                                                       <p><img alt="" height="179" src="https://images2.imgbox.com/54/24/Bx8QJFtE_o.png" width="347"><img alt="" height="149" src="https://images2.imgbox.com/f3/3d/UB9a4kA8_o.png" width="335"></p> 
                                                                       <p><span style="color:#333333;"><strong>总结：</strong><br> 1. throw 抛出异常信息，</span><span style="color:#be191c;">程序也会终止执行</span><br><span style="color:#333333;">2. throw 后面跟的是错误提示信息<br> 3. </span><span style="color:#be191c;">Error 对象配合 throw 使用</span><span style="color:#333333;">，能够设置更详细的错误信息</span></p> 
                                                                       <h4 id="10.2%20try%2Fcatch%20%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF"><span style="color:#be191c;"><strong>10.2 try/catch</strong> 捕获错误信息</span></h4> 
                                                                       <p><span style="color:#0d0016;">我们可以通过try / catch 捕获错误信息（浏览器提供的错误信息） </span></p> 
                                                                       <pre><code class="language-html">&lt;body&gt;
  &lt;p&gt;123&lt;/p&gt;
  &lt;script&gt;
    function fn() {
      try {
        // 可能发送错误的代码 要写到 try
        const p = document.querySelector('.p')
        p.style.color = 'red'
      } catch (err) {
        // 拦截错误，提示浏览器提供的错误信息，但是不中断程序的执行
        console.log(err.message)
        throw new Error('你看看，选择器错误了吧')
        // 需要加return 中断程序
        return
      }
      finally {
        // 不管你程序对不对，一定会执行的代码
        alert('弹出对话框')
      }
      console.log(11)
    }
    fn()
  &lt;/script&gt;
&lt;/body&gt;
</code></pre> 
                                                                       <p><span style="color:#0d0016;"><strong>总结：</strong><br> 1. try...catch 用于捕获错误信息<br> 2. 将预估</span><span style="color:#be191c;">可能发生错误的代码写在 try 代码段</span><span style="color:#0d0016;">中<br> 3. 如果 try 代码段中出现错误后，会执行 catch 代码段，并截获到错误信息，</span><span style="color:#be191c;">利用catch的参数可以调用错误信息</span><br><span style="color:#0d0016;">4. finally 不管是否有错误，都会执行</span></p> 
                                                                       <h4 id="10.3%20debugger"><span style="color:#be191c;">10.3 debugger</span></h4> 
                                                                       <p>debugger：停止 JavaScript 的执行，相当于设置断点。<img alt="" height="314" src="https://images2.imgbox.com/20/eb/jsaYjhTB_o.png" width="1200"></p> 
                                                                       <h3 id="11.%20%E5%A4%84%E7%90%86this%C2%A0"><span style="color:#be191c;">11. 处理this</span> </h3> 
                                                                       <p>this 是 JavaScript 最具“魅惑”的知识点，不同的应用场合 this 的取值可能会有意想不到的结果，在此我们对以往学习过的关于【 this 默认的取值】情况进行归纳和总结。</p> 
                                                                       <h4 id="11.1%20this%E6%8C%87%E5%90%91-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span style="color:#be191c;">11.1 this指向-普通函数</span></h4> 
                                                                       <p><span style="color:#0d0016;">普通函数的调用方式决定了 this 的值，即</span><span style="color:#be191c;">【谁调用 this 的值指向谁】</span></p> 
                                                                       <p><span style="color:#333333;">普通函数没有明确调用者时 this 值为 window，严格模式下没有调用者时 this 的值为 undefined</span></p> 
                                                                       <h4 id="11.1%20this%E6%8C%87%E5%90%91-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span style="color:#be191c;">11.1 this指向-箭头函数</span></h4> 
                                                                       <p><span style="color:#0d0016;">箭头函数中的 this 与普通函数完全不同，不受调用方式的影响，事实上<strong>箭头函数中并不存在 this</strong><br> 1. 箭头函数会默认帮我们绑定外层 this 的值，所以在</span><span style="color:#be191c;">箭头函数中 this 的值和外层的 this 是一样的</span><br><span style="color:#0d0016;">2.箭头函数中的this引用的就是最近作用域中的this<br> 3.向外层作用域中，一层一层查找this，直到有this的定义</span></p> 
                                                                       <p><span style="color:#0d0016;"><strong>注意情况1：</strong><br> 在开发中【使用箭头函数前需要考虑函数中 this 的值】，事件回调函数使用箭头函数时，this 为全局的 window，因此</span><span style="color:#be191c;">DOM事件回调函数如果里面需要DOM对象的this，则不推荐使用箭头函数</span></p> 
                                                                       <p><span style="color:#0d0016;"><strong>注意情况2：</strong></span><br><span style="color:#0d0016;">同样由于箭头函数 this 的原因，</span><span style="color:#be191c;">基于原型的面向对象也不推荐采用箭头函数</span></p> 
                                                                       <p><span style="color:#0d0016;"><strong>总结：</strong><br> 1. 函数内不存在this，沿用上一级的。过程：向外层作用域中一层一层查找this，直到有this的定义<br> 2.<strong>不适用：</strong></span><span style="color:#be191c;"><strong>构造函数，原型函数，dom事件函数</strong></span><span style="color:#0d0016;">等等<br> 3. <strong>适用：</strong></span><span style="color:#be191c;"><strong>需要使用上层this的地方</strong></span><br><span style="color:#0d0016;">4. 使用正确的话，它会在很多地方带来方便，后面我们会大量使用慢慢体会</span></p> 
                                                                       <h4 id="11.2%20%E6%94%B9%E5%8F%98this"><span style="color:#be191c;">11.2 改变this</span></h4> 
                                                                       <p><span style="color:#0d0016;"><strong>1. call() –了解</strong><br> 使用 call 方法调用函数，同时指定被调用函数中 this 的值<br><strong>语法：</strong></span><span style="color:#be191c;">fun.call(thisArg, arg1, arg2, ...) </span><br><span style="color:#262626;"><strong>● </strong></span><span style="color:#0d0016;">thisArg：在 fun 函数运行时指定的 this 值</span><br><span style="color:#262626;"><strong>● </strong></span><span style="color:#0d0016;">arg1，arg2：传递的其他参数<br><strong>返回值就是函数的返回值</strong>，因为它就是调用函数</span></p> 
                                                                       <pre><code class="language-javascript">  &lt;script&gt;
    const obj = {
      uname: 'pink'
    }
    function fn(x, y) {
      console.log(this) // window
      console.log(x + y)
    }
    // 1. 调用函数  
    // 2. 改变 this 指向
    fn.call(obj, 1, 2)
  &lt;/script&gt;</code></pre> 
                                                                       <p><strong>2. apply()-理解</strong><br> 使用 apply 方法调用函数，同时指定被调用函数中 this 的值<br><strong>语法：</strong><span style="color:#be191c;">fun.apply(thisArg, [argsArray])</span><br><span style="color:#262626;"><strong>● </strong></span>thisArg：在fun函数运行时指定的 this 值<br><span style="color:#262626;"><strong>● </strong></span>argsArray：传递的值，<strong>必须包含在数组里面</strong><br><strong>返回值就是函数的返回值</strong>，因为它就是调用函数<br> 因此 <strong>apply 主要跟数组有关系</strong>，比如使用 Math.max() 求数组的最大值</p> 
                                                                       <pre><code class="language-javascript">  &lt;script&gt;
    const obj = {
      age: 18
    }
    function fn(x, y) {
      console.log(this) // {age: 18}
      console.log(x + y)
    }
    // 1. 调用函数
    // 2. 改变this指向 
    //  fn.apply(this指向谁, 数组参数)
    fn.apply(obj, [1, 2])
    // 3. 返回值   本身就是在调用函数，所以返回值就是函数的返回值

    // 使用场景： 求数组最大值
    // const max = Math.max(1, 2, 3)
    // console.log(max)
    const arr = [100, 44, 77]
    const max = Math.max.apply(Math, arr)
    const min = Math.min.apply(null, arr)
    console.log(max, min)
    // 使用场景： 求数组最大值
    console.log(Math.max(...arr))
  &lt;/script&gt;
</code></pre> 
                                                                       <p><span style="color:#0d0016;"><strong>call和apply的区别：</strong></span><br><span style="color:#262626;"><strong>● </strong></span><span style="color:#0d0016;">都是调用函数，都能改变this指向</span><br><span style="color:#262626;"><strong>● </strong></span><span style="color:#0d0016;">参数不一样，apply传递的必须是数组</span></p> 
                                                                       <p><span style="color:#be191c;"><strong>3. bind()-重点</strong></span><br><span style="color:#0d0016;">bind() 方法不会调用函数。但是能改变函数内部this 指向<br><strong>语法：</strong></span><span style="color:#be191c;">fun.bind(thisArg, arg1, arg2, ...)</span><br><span style="color:#262626;"><strong>● </strong></span><span style="color:#0d0016;"> thisArg：在 fun 函数运行时指定的 this 值</span><br><span style="color:#262626;"><strong>● </strong></span><span style="color:#0d0016;"> arg1，arg2：传递的其他参数<br><strong>返回</strong></span><span style="color:#be191c;"><strong>由指定的 this 值和初始化参数改造的 原函数拷贝 （新函数）</strong></span><br><span style="color:#0d0016;">因此当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind，比如改变定时器内部的this指向</span></p> 
                                                                       <pre><code class="language-html">&lt;body&gt;
  &lt;button&gt;发送短信&lt;/button&gt;
  &lt;script&gt;
    const obj = {
      age: 18
    }
    function fn() {
      console.log(this)
    }

    // 1. bind 不会调用函数 
    // 2. 能改变this指向
    // 3. 返回值是个函数，  但是这个函数里面的this是更改过的obj
    const fun = fn.bind(obj)
    // console.log(fun) 
    fun()

    // 需求，有一个按钮，点击里面就禁用，2秒钟之后开启
    document.querySelector('button').addEventListener('click', function () {
      // 禁用按钮
      this.disabled = true
      window.setTimeout(function () {
        // 在这个普通函数里面，我们要this由原来的window 改为 btn
        this.disabled = false
      }.bind(this), 2000)   // 这里的this 和 btn 一样
    })
  &lt;/script&gt;
&lt;/body&gt;
</code></pre> 
                                                                       <p><span style="color:#be191c;"><strong>call apply bind 总结</strong></span><br><span style="color:#0d0016;"><strong>相同点：</strong>都可以改变函数内部的this指向.<br><strong>区别点：</strong><br><strong>● </strong> call 和 apply 会调用函数, 并且改变函数内部this指向.<br><strong>● </strong> call 和 apply 传递的参数不一样, call 传递参数 aru1, aru2..形式 apply 必须数组形式[arg]<br><strong>● </strong> bind 不会调用函数, 可以改变函数内部this指向.<br><strong>主要应用场景：</strong><br><strong>● </strong> call 调用函数并且可以传递参数<br><strong>● </strong> apply 经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值<br><strong>● </strong> bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向</span></p> 
                                                                       <h3 id="12.%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span style="color:#be191c;">12. 性能优化</span></h3> 
                                                                       <h4 id="12.1%20%E9%98%B2%E6%8A%96%EF%BC%88debounce%EF%BC%89"><span style="color:#be191c;">12.1 防抖（debounce）</span></h4> 
                                                                       <p><strong><span style="color:#0d0016;">所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</span></strong></p> 
                                                                       <p><span style="color:#0d0016;"><strong>开发使用场景- 搜索框防抖</strong><br> 假设输入就可以发送请求，但是不能每次输入都去发送请求，输入比较快发送请求会比较多<br> 我们设定一个时间，假如300ms， 当输入第一个字符时候，300ms后发送请求，但是在200ms的时候又输入了一个字符，则需要再等300ms 后发送请求</span></p> 
                                                                       <p><span style="color:#be191c;"><strong>案例：利用防抖来处理-鼠标滑过盒子显示文字</strong></span></p> 
                                                                       <pre><code class="language-html">&lt;body&gt;
  &lt;div class="box"&gt;&lt;/div&gt;
  &lt;script&gt;
    const box = document.querySelector('.box')
    let i = 1  // 让这个变量++
    // 鼠标移动函数
    function mouseMove() {
      box.innerHTML = ++i
      // 如果里面存在大量操作 dom 的情况，可能会卡顿
    }
    // 防抖函数
    function debounce(fn, t) {
      let timeId
      return function () {
        // 如果有定时器就清除
        if (timeId) clearTimeout(timeId)
        // 开启定时器 200
        timeId = setTimeout(function () {
          fn()
        }, t)
      }
    }
    // box.addEventListener('mousemove', mouseMove)
    box.addEventListener('mousemove', debounce(mouseMove, 200))
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
                                                                       <h4 id="12.2%20%E8%8A%82%E6%B5%81%EF%BC%88throttle%EF%BC%89"><span style="color:#be191c;">12.2 节流（throttle）</span></h4> 
                                                                       <p><strong>所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数</strong></p> 
                                                                       <p><strong>开发使用场景 – 小米轮播图点击效果 、 鼠标移动、页面尺寸缩放resize、滚动条滚动</strong>可以加节流</p> 
                                                                       <p><span style="color:#be191c;"><strong>案例：利用节流来处理-鼠标滑过盒子显示文字</strong></span></p> 
                                                                       <pre><code class="language-html">&lt;body&gt;
  &lt;div class="box"&gt;&lt;/div&gt;
  &lt;script&gt;
    const box = document.querySelector('.box')
    let i = 1  // 让这个变量++
    // 鼠标移动函数
    function mouseMove() {
      box.innerHTML = ++i
      // 如果里面存在大量操作 dom 的情况，可能会卡顿
    }
    // 节流函数 throttle 
    function throttle(fn, t) {
      // 起始时间
      let startTime = 0
      return function () {
        // 得到当前的时间
        let now = Date.now()
        // 判断如果大于等于 500 采取调用函数
        if (now - startTime &gt;= t) {
          // 调用函数
          fn()
          // 起始的时间 = 现在的时间   写在调用函数的下面 
          startTime = now
        }
      }
    }
    box.addEventListener('mousemove', throttle(mouseMove, 500)
  &lt;/script&gt;
&lt;/body&gt;</code></pre> 
                                                                       <p><span style="color:#0d0016;"><strong>总结：</strong></span></p> 
                                                                       <p><span style="color:#0d0016;"><strong>1.节流和防抖的区别是？</strong><br> ●  <strong> </strong>节流：就是指连续触发事件但是在 n 秒中只执行一次函数,比如可以利用节流实现 1s之内 只能触发一次鼠标移动事件<br> ●  防抖：如果在 n 秒内又触发了事件，则会重新计算函数执行时间<br><strong>2. 节流和防抖的使用场景是？<br> ● </strong> 节流：鼠标移动，页面尺寸发生变化，滚动条滚动等开销比较大的情况下<br> ●  防抖：搜索框输入，设定每次输入完毕n秒后发送请求，如果期间还有输入，则从新计算时间</span></p> 
                                                                       <h4 id="Lodash%20%E5%BA%93%20%E5%AE%9E%E7%8E%B0%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96"><span style="color:#be191c;">Lodash 库 实现节流和防抖</span></h4> 
                                                                       <h4 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="558" src="https://images2.imgbox.com/fb/ab/J2WTq2SD_o.png" width="798"></h4> 
                                                                       <h3 id="%E8%8A%82%E6%B5%81%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%9A%E9%A1%B5%E9%9D%A2%E6%89%93%E5%BC%80%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AE%B0%E5%BD%95%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%9A%84%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E4%BD%8D%E7%BD%AE%C2%A0"><span style="color:#be191c;">节流综合案例：页面打开，可以记录上一次的视频播放位置 </span></h3> 
                                                                       <p><span style="color:#0d0016;"><strong>两个事件:</strong><br> ①：ontimeupdate 事件在视频/音频（audio/video）当前的播放位置发送改变时触发<br> ②：onloadeddata 事件在当前帧的数据加载完成且还没有足够的数据播放视频/音频（audio/video）的下一帧时触发</span></p> 
                                                                       <pre><code class="language-html">&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;a href="http://pip.itcast.cn"&gt;
                &lt;img src="https://pip.itcast.cn/img/logo_v3.29b9ba72.png" alt="" /&gt;
            &lt;/a&gt;
        &lt;/div&gt;
        &lt;div class="video"&gt;
            &lt;video src="https://v.itheima.net/LapADhV6.mp4" controls&gt;&lt;/video&gt;
        &lt;/div&gt;
        &lt;div class="elevator"&gt;
            &lt;a href="javascript:;" data-ref="video"&gt;视频介绍&lt;/a&gt;
            &lt;a href="javascript:;" data-ref="intro"&gt;课程简介&lt;/a&gt;
            &lt;a href="javascript:;" data-ref="outline"&gt;评论列表&lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        // 1. 获取元素  要对视频进行操作
        const video = document.querySelector('video')
        video.ontimeupdate = _.throttle(() =&gt; {
            // console.log(video.currentTime)  获得当前的视频时间
            // 把当前的时间存储到本地存储
            localStorage.setItem('currentTime', video.currentTime)
        }, 1000)

        // 打开页面触发事件，就从本地存储里面取出记录的时间，赋值给 video.currentTime
        video.onloadeddata = () =&gt; {
            video.currentTime = localStorage.getItem('currentTime') || 0
        }
    &lt;/script&gt;
&lt;/body&gt;
</code></pre> 
                                                                      </div> 
                                                                     </div> 
                                                                    </div> 
                                                                   </div> 
                                                                  </div> 
                                                                 </div> 
                                                                </div> 
                                                               </div> 
                                                              </div> 
                                                             </div> 
                                                            </div> 
                                                           </div> 
                                                          </div> 
                                                         </div> 
                                                        </div> 
                                                       </div> 
                                                      </div> 
                                                     </div> 
                                                    </div> 
                                                   </div> 
                                                  </div> 
                                                 </div> 
                                                </div> 
                                               </div> 
                                              </div> 
                                             </div> 
                                            </div> 
                                           </div> 
                                          </div> 
                                         </div> 
                                        </div> 
                                       </div> 
                                      </div> 
                                     </div> 
                                    </div> 
                                   </div> 
                                  </div> 
                                 </div> 
                                </div> 
                               </div> 
                              </div> 
                             </div> 
                            </div> 
                           </div> 
                          </div> 
                         </div> 
                        </div> 
                       </div> 
                      </div> 
                     </div> 
                    </div> 
                   </div> 
                  </div> 
                 </div> 
                </div> 
               </div> 
              </div> 
             </div> 
            </div> 
           </div> 
          </div> 
         </div> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e9fb3f74d074c3a3ad8ffd9e03ae3c6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Redis 之 UNLINK 命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5adee0ea74f97df1e2f6af0ccc16e6f8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringBoot整合Ip2region获取IP地址和定位</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>