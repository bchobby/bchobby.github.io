<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JavaEE基础 ——— 关于线程的那些事 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JavaEE基础 ——— 关于线程的那些事" />
<meta property="og:description" content="目录
一、什么是进程
二、进程的调度
1.描述一个进程
2.组织若干个进程
3.并发和并行
4.进程的状态
5.优先级 6.记账信息 7.虚拟地址空间 8.进程之间的通信 三.线程与进程 1. 线程是什么？
2.线程的作用 3.进程和线程的区别 四.线程的创建 方法一：Thread类继承
方法二：实现Runnable接口
其他变形
变形1：匿名内部类创建Thread子类对象
变形2：匿名内部类创建Runnable子类对象
变形3：lambda 表达式创建 Runnable 子类对象
拓展：多线程的优势
五.Thread类及其常见方法 常见的构造方法
常见属性
启动一个线程 中断一个线程
等待一个线程 获取当前现象的引用 休眠当前线程 一、什么是进程 每个应用程序运行于现代操作系统之上时，操作系统会提供一种抽象，好像系统上只有这个程序在运行，所有的硬件资源都被这个程序在使用。这种假象是通过抽象了一个进程的概念来完成的，进程可以说是计算机科学中最重要和最成功的概念之一。
进程是操作系统对一个正在运行的程序的一种抽象，换言之，可以把进程看做程序的一次运行过程；同时，在操作系统内部，进程是操作系统进行资源分配的基本单位。
二、进程的调度 1.描述一个进程 明确出一个进程上面的一些相关属性。就比如：形容一个学校的学生，你需要学校姓名，班级、专业等。
2.组织若干个进程 使用一些数据结构（例如链表），把很多描述进程的信息放在一起，方便进行增删改查。
较为典型的就是使用双向链表来把每个进程的PCB给串起来。因为操作系统的类型的不同，内部实现不尽相同。因此我们以 linux 系统为例进行讨论。linux组织进程的方式就是用双向链表来把每个进程的PCB给串起来。或者说，所谓的“创建进程”，就是先创建出 PCB，然后把 PCB 添加到双向链表中，所谓的“销毁进程”，就是找到链表上的某个PCB，将它从链表上移除。而“查看任务管理器”，就是遍历链表，找到我们想要的那一个PCB后，取出相关资料。
有了上述这些基础之后，我们就可以来聊一聊进程是怎么调度的了。 打开任务管理器，我们会发现我们的计算机上有许多任务在正在运行，那么我们的CPU又是如何管理运行他们的？
3.并发和并行 我们首先来明确两个概念：并发和并行
并发：微观上看，假设现在有ABCD四个任务，而我们的CPU并不是让这四个任务同时运行的，CPU先是运行一会A，再运行一会B再运行一会C.......那么循环运行的同时，CPU又在ABCD四个任务之间切换地非常快，那么我们从宏观的角度去看就好像是让ABCD四个任务在同时运行，这就是并发。
并发：单个核心 按照串行的方式 执行多个任务，但是只要它切换的足够快，从宏观来看就好像是多个任务在同时执行一样。
并行：现在有ABCD四个任务，我们的CPU让这四个任务同时运行，这就是并行。
并行：多个核心执行多个任务
从我们人的角度其实是区分不了并发和并行的，因此我们在写代码的时候也不去具体区分这两个词。我们平时常说的并发编程就是包含了 “并发” 和 “并行”的统称。
到这里我们就知道，所谓的进程调度就是让有限的CPU核数，去执行更多的任务。
4.进程的状态 1、就绪状态
2、阻塞状态 / 睡眠状态，暂时不去CPU 上调度执行" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/dbed78b82c0d933c0e291ed5a7e25f1b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-31T16:31:38+08:00" />
<meta property="article:modified_time" content="2022-03-31T16:31:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaEE基础 ——— 关于线程的那些事</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B" rel="nofollow">一、什么是进程</a></p> 
<p id="%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6" rel="nofollow">二、进程的调度</a></p> 
<p id="1.%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B-toc" style="margin-left:40px;"><a href="#1.%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B" rel="nofollow">1.描述一个进程</a></p> 
<p id="2.%E7%BB%84%E7%BB%87%E8%8B%A5%E5%B9%B2%E4%B8%AA%E8%BF%9B%E7%A8%8B-toc" style="margin-left:40px;"><a href="#2.%E7%BB%84%E7%BB%87%E8%8B%A5%E5%B9%B2%E4%B8%AA%E8%BF%9B%E7%A8%8B" rel="nofollow">2.组织若干个进程</a></p> 
<p id="3.%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C-toc" style="margin-left:40px;"><a href="#3.%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C" rel="nofollow">3.并发和并行</a></p> 
<p id="4.%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81-toc" style="margin-left:40px;"><a href="#4.%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81" rel="nofollow">4.进程的状态</a></p> 
<p id="5.%E4%BC%98%E5%85%88%E7%BA%A7%C2%A0-toc" style="margin-left:40px;"><a href="#5.%E4%BC%98%E5%85%88%E7%BA%A7%C2%A0" rel="nofollow">5.优先级 </a></p> 
<p id="6.%E8%AE%B0%E8%B4%A6%E4%BF%A1%E6%81%AF%C2%A0-toc" style="margin-left:40px;"><a href="#6.%E8%AE%B0%E8%B4%A6%E4%BF%A1%E6%81%AF%C2%A0" rel="nofollow">6.记账信息 </a></p> 
<p id="7.%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%C2%A0-toc" style="margin-left:40px;"><a href="#7.%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%C2%A0" rel="nofollow">7.虚拟地址空间 </a></p> 
<p id="8.%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%C2%A0-toc" style="margin-left:40px;"><a href="#8.%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%C2%A0" rel="nofollow">8.进程之间的通信 </a></p> 
<p id="%E4%B8%89.%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%C2%A0" rel="nofollow">三.线程与进程 </a></p> 
<p id="1.%C2%A0%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px;"><a href="#1.%C2%A0%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">1. 线程是什么？</a></p> 
<p id="2.%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%9C%E7%94%A8%C2%A0-toc" style="margin-left:40px;"><a href="#2.%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%9C%E7%94%A8%C2%A0" rel="nofollow">2.线程的作用 </a></p> 
<p id="3.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%C2%A0-toc" style="margin-left:40px;"><a href="#3.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%C2%A0" rel="nofollow">3.进程和线程的区别 </a></p> 
<p id="%E5%9B%9B.%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%C2%A0" rel="nofollow">四.线程的创建 </a></p> 
<p id="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9AThread%E7%B1%BB%E7%BB%A7%E6%89%BF-toc" style="margin-left:40px;"><a href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9AThread%E7%B1%BB%E7%BB%A7%E6%89%BF" rel="nofollow">方法一：Thread类继承</a></p> 
<p id="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3" rel="nofollow">方法二：实现Runnable接口</a></p> 
<p id="%C2%A0%E5%85%B6%E4%BB%96%E5%8F%98%E5%BD%A2-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%85%B6%E4%BB%96%E5%8F%98%E5%BD%A2" rel="nofollow"> 其他变形</a></p> 
<p id="%E5%8F%98%E5%BD%A21%EF%BC%9A%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%88%9B%E5%BB%BAThread%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BD%A21%EF%BC%9A%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%88%9B%E5%BB%BAThread%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1" rel="nofollow">变形1：匿名内部类创建Thread子类对象</a></p> 
<p id="%E5%8F%98%E5%BD%A22%EF%BC%9A%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%88%9B%E5%BB%BARunnable%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BD%A22%EF%BC%9A%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%88%9B%E5%BB%BARunnable%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1" rel="nofollow">变形2：匿名内部类创建Runnable子类对象</a></p> 
<p id="%E5%8F%98%E5%BD%A23%EF%BC%9Alambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%9B%E5%BB%BA%20Runnable%20%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#%E5%8F%98%E5%BD%A23%EF%BC%9Alambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%9B%E5%BB%BA%20Runnable%20%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1" rel="nofollow">变形3：lambda 表达式创建 Runnable 子类对象</a></p> 
<p id="%E6%8B%93%E5%B1%95%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF-toc" style="margin-left:40px;"><a href="#%E6%8B%93%E5%B1%95%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF" rel="nofollow">拓展：多线程的优势</a></p> 
<p id="%E4%BA%94.Thread%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%BA%94.Thread%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%C2%A0" rel="nofollow">五.Thread类及其常见方法 </a></p> 
<p id="%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" rel="nofollow">常见的构造方法</a></p> 
<p id="%C2%A0%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7" rel="nofollow"> 常见属性</a></p> 
<p id="%C2%A0%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%C2%A0" rel="nofollow"> 启动一个线程 </a></p> 
<p id="%C2%A0%E4%B8%AD%E6%96%AD%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%C2%A0%E4%B8%AD%E6%96%AD%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B" rel="nofollow"> 中断一个线程</a></p> 
<p id="%E7%AD%89%E5%BE%85%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%C2%A0-toc" style="margin-left:40px;"><a href="#%E7%AD%89%E5%BE%85%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%C2%A0" rel="nofollow">等待一个线程 </a></p> 
<p id="%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%8E%B0%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%C2%A0-toc" style="margin-left:40px;"><a href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%8E%B0%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%C2%A0" rel="nofollow">获取当前现象的引用 </a></p> 
<p id="%E4%BC%91%E7%9C%A0%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%C2%A0-toc" style="margin-left:40px;"><a href="#%E4%BC%91%E7%9C%A0%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%C2%A0" rel="nofollow">休眠当前线程 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<p> </p> 
<h2 id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B">一、什么是进程</h2> 
<p>每个应用程序运行于现代操作系统之上时，操作系统会提供一种抽象，好像系统上只有这个程序在运行，所有的硬件资源都被这个程序在使用。这种假象是通过抽象了一个进程的概念来完成的，进程可以说是计算机科学中最重要和最成功的概念之一。</p> 
<p><strong>进程是操作系统对一个正在运行的程序的一种抽象，换言之，可以把进程看做程序的一次运行过程；同时，在操作系统内部，<span style="color:#a2e043;">进程是操作系统进行资源分配的基本单位</span>。</strong></p> 
<h2 id="%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><strong>二、进程的调度</strong></h2> 
<h3 id="1.%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><strong>1.描述一个进程</strong></h3> 
<blockquote> 
 <p>明确出一个进程上面的一些相关属性。就比如：形容一个学校的学生，你需要学校姓名，班级、专业等。</p> 
</blockquote> 
<h3 id="2.%E7%BB%84%E7%BB%87%E8%8B%A5%E5%B9%B2%E4%B8%AA%E8%BF%9B%E7%A8%8B">2.组织若干个进程</h3> 
<blockquote> 
 <p>使用一些数据结构（例如链表），把很多描述进程的信息放在一起，方便进行增删改查。</p> 
</blockquote> 
<blockquote> 
 <p>较为典型的就是使用双向链表来把每个进程的PCB给串起来。因为操作系统的类型的不同，内部实现不尽相同。因此我们以 linux 系统为例进行讨论。linux组织进程的方式就是用双向链表来把每个进程的PCB给串起来。或者说，所谓的“创建进程”，就是先创建出 PCB，然后把 PCB 添加到双向链表中，所谓的“销毁进程”，就是找到链表上的某个PCB，将它从链表上移除。而“查看任务管理器”，就是遍历链表，找到我们想要的那一个PCB后，取出相关资料。</p> 
</blockquote> 
<p><strong>有了上述这些基础之后，我们就可以来聊一聊进程是怎么调度的了。 </strong></p> 
<p>打开任务管理器，我们会发现我们的计算机上有许多任务在正在运行，那么我们的CPU又是如何管理运行他们的？</p> 
<h3 id="3.%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C">3.并发和并行</h3> 
<p>我们首先来明确两个概念：<span style="color:#fe2c24;">并发</span>和<span style="color:#fe2c24;">并行</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>并发</strong>：微观上看，假设现在有ABCD四个任务，而我们的CPU并不是让这四个任务同时运行的，CPU先是运行一会A，再运行一会B再运行一会C.......那么循环运行的同时，CPU又在ABCD四个任务之间切换地非常快，那么我们从宏观的角度去看就好像是让ABCD四个任务在同时运行，这就是并发。</span></p> 
 <p><span style="color:#fe2c24;">并发：单个核心 按照串行的方式 执行多个任务，但是只要它切换的足够快，从宏观来看就好像是多个任务在同时执行一样。</span></p> 
</blockquote> 
<blockquote> 
 <p> <span style="color:#0d0016;"><strong>并行</strong>：现在有ABCD四个任务，我们的CPU让这四个任务同时运行，这就是并行。</span></p> 
 <p><span style="color:#fe2c24;">并行：多个核心执行多个任务</span></p> 
</blockquote> 
<p><strong> 从我们人的角度其实是区分不了并发和并行的，因此我们在写代码的时候也不去具体区分这两个词。我们平时常说的并发编程就是包含了 “并发” 和 “并行”的统称。</strong></p> 
<p><strong>到这里我们就知道，所谓的进程调度就是</strong><strong>让有限的CPU核数，去执行更多的任务。</strong></p> 
<h3 id="4.%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><strong>4.进程的状态</strong></h3> 
<blockquote> 
 <p>1、就绪状态<br> 2、阻塞状态 / 睡眠状态，暂时不去CPU 上调度执行</p> 
</blockquote> 
<h3 id="5.%E4%BC%98%E5%85%88%E7%BA%A7%C2%A0">5.优先级 </h3> 
<blockquote> 
 <p>我们计算机上有很多的进程，那么先给谁分配资源，后给谁分配资源；以及给谁分的多，给谁分的少。这一点，操作系统给进程分配时间也是类似的。有的进程优先级高，有的进程优先级低。</p> 
</blockquote> 
<h3 id="6.%E8%AE%B0%E8%B4%A6%E4%BF%A1%E6%81%AF%C2%A0">6.记账信息 </h3> 
<blockquote> 
 <p>CPU可以根据记账信息来灵活调整调整它的一个资源的分配策略。先统计好这里面每个进程当前所吃的资源，然后再根据这里面的统计结果，来去对那些分配特别少，特别不均衡的进程，做出一些补偿。</p> 
</blockquote> 
<h3 id="7.%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%C2%A0">7.虚拟地址空间 </h3> 
<blockquote> 
 <p>由于某个进程出现了bug，导致该进程崩溃了，那么是否会影响到其它进程呢？<br> 事实上某个单个进程发生崩溃，其它进程是不会受到影响的。这就是“进程的独立性”，而做到各个进程不相互干扰的功臣就是<span style="color:#fe2c24;">虚拟地址空间</span></p> 
</blockquote> 
<p>拿我们身边的一个例子来说：疫情期间假如有一栋楼被封锁了，假设这栋楼外部只有一条路能走，那么如果出现了一例阳性（进程崩溃）那么所有走这条路的人都有被感染的风险。</p> 
<p>那么我们在不考虑实际的情况下，假设楼里一共住着20个人，那么我们在楼外开辟20条互不干扰的道路，每一个人都有一条独立的路。那么，在这种情况下，如果二十人当中出现一例阳性，那么其他人感染的风险也会大大下降。</p> 
<h3 id="8.%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%C2%A0">8.进程之间的通信 </h3> 
<p>但现代的应用，要完成一个复杂的业务需求，往往无法通过一个进程独立完成，总是需要进程和进程进行配合地达到应用的目的，如此，进程之间就需要有进行“信息交换“的需求。进程间通信的需求就应运而生</p> 
<blockquote> 
 <p>通过“公共空间”进行交互。（进程A 先将数据放入公共空间，进程B随后再去取，这样就完成了进程之间的交互）</p> 
</blockquote> 
<h2 id="%E4%B8%89.%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%C2%A0">三.线程与进程 </h2> 
<h3 id="1.%C2%A0%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">1. 线程是什么？</h3> 
<blockquote> 
 <p>一个线程就是一个 <span style="color:#fe2c24;">"执行流"</span>. 每个线程之间都可以按照顺讯执行自己的代码. 多个线程之间 "同时" 执行着多份代码。</p> 
</blockquote> 
<p>为了方便理解我们可以举这样一个例子： </p> 
<blockquote> 
 <p>一家公司要去银行办理业务，既要进行财务转账，又要进行福利发放，还得进行缴社保。如果只有张三一个会计就会忙不过来，耗费的时间特别长。为了让业务更快的办理好，张三又找来两位同事李四、王五一起来帮助他，三个人分别负责一个事情，分别申请一个号码进行排队，自此就有了三个执行流共同完成任务，但本质上他们都是为了办理一家公司的业务。此时，我们就把这种情况称为多线程，将一个大任务分解成不同小任务，交给不同执行流就分别排队执行。其中李四、王五都是张三叫来的，所以张三一般被称为主线程（Main Thread）。</p> 
</blockquote> 
<h3 id="2.%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%9C%E7%94%A8%C2%A0">2.线程的作用 </h3> 
<blockquote> 
 <p>1.单核 CPU 的发展遇到了瓶颈. 要想提高算力, 就需要多核 CPU. 而并发编程能更充分利用多核 CPU资源。<br> 2.有些任务场景需要 "等待 IO", 为了让等待 IO 的时间能够去做一些其他的工作, 也需要用到并发编程。</p> 
</blockquote> 
<h3 id="3.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%C2%A0">3.进程和线程的区别 </h3> 
<blockquote> 
 <p>1.进程是包含线程的，每一个进程至少有一个线程，即主线程</p> 
 <p>2.进程和进程之间不共享内存空间，而同一个进程的线程共享同一个内存空间</p> 
 <p>3.进程是系统分配资源的最小单位，线程是系统调度的最小单位</p> 
</blockquote> 
<h2 id="%E5%9B%9B.%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%C2%A0">四.线程的创建 </h2> 
<h3 id="%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9AThread%E7%B1%BB%E7%BB%A7%E6%89%BF">方法一：Thread类继承</h3> 
<pre><code>class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("方法一");//线程需要执行的任务
    }
}
public class Main {
    public static void main(String[] args) {
        Thread t = new MyThread();//创建实例
        t.start();//启动线程
    }
}</code></pre> 
<h3 id="%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3">方法二：实现Runnable接口</h3> 
<pre><code>class MyRun implements Runnable {
    @Override
    public void run() {
        System.out.println("方法二");
    }
}
public class Main {
    public static void main(String[] args) {
        Thread t = new Thread(new MyRun());
        t.start();
    }
}</code></pre> 
<h3 id="%C2%A0%E5%85%B6%E4%BB%96%E5%8F%98%E5%BD%A2"> 其他变形</h3> 
<h4 id="%E5%8F%98%E5%BD%A21%EF%BC%9A%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%88%9B%E5%BB%BAThread%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1">变形1：匿名内部类创建Thread子类对象</h4> 
<pre><code>    public static void main(String[] args) {
        Thread t = new Thread() {
            @Override
            public void run() {
                System.out.println("变形1");
            }
        };
        t.start();
    }</code></pre> 
<h4 id="%E5%8F%98%E5%BD%A22%EF%BC%9A%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%88%9B%E5%BB%BARunnable%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1">变形2：匿名内部类创建Runnable子类对象</h4> 
<pre><code>    public static void main(String[] args) {
        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("变形2");
            }
        });
        t.start();
    }</code></pre> 
<h4 id="%E5%8F%98%E5%BD%A23%EF%BC%9Alambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%9B%E5%BB%BA%20Runnable%20%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1">变形3：lambda 表达式创建 Runnable 子类对象</h4> 
<pre><code>    public static void main(String[] args) {
        Thread t = new Thread(() -&gt; {
            System.out.println("变形3");
        });
        t.start();
    }</code></pre> 
<h3 id="%E6%8B%93%E5%B1%95%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF">拓展：多线程的优势</h3> 
<blockquote> 
 <p>我们用一个例子来看一下多线程并发执行和我们平时串行之间的差异：</p> 
 <p>代码一：串行执行一个数字自增一百亿次，记录其执行时间</p> 
 <p>代码二：并发执行实现一百亿次自增，记录执行时间</p> 
</blockquote> 
<p><strong> 代码一：</strong></p> 
<pre><code>    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        int num = 0;
        for(int i = 0; i &lt; 500000; i++) {
            num++;
        }
        for(int i = 0; i &lt; 500000; i++) {
            num++;
        }
        System.out.println(num);
        long end = System.currentTimeMillis();
        System.out.println(end - start);
    }</code></pre> 
<p><strong> 执行时间：</strong></p> 
<p><img alt="" height="275" src="https://images2.imgbox.com/c7/a3/k3b4hFj3_o.png" width="584"></p> 
<p></p> 
<p></p> 
<p><strong>代码二： </strong></p> 
<pre><code>    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new MyThread2();
        long start = System.currentTimeMillis();
        t1.start();//启动线程一

        Thread t2 = new MyThread2();
        t2.start();//启动线程二

        //保证线程全部完成
        t1.join();
        t2.join();
        long end = System.currentTimeMillis();
        System.out.println(MyThread2.num);
        System.out.println("执行时间：" + (end - start) + "毫秒");
    }

class MyThread2 extends Thread {
    public static long num;
    private static Object o = new Object();
    @Override
    public void run() {
        synchronized (o) {
            for(long i = 0; i &lt; 50_0000_0000L; i++) {
                num++;
            }
        }
    }
}</code></pre> 
<p> <img alt="" height="364" src="https://images2.imgbox.com/42/a0/GrS0tv3A_o.png" width="828"></p> 
<p> 从上述两个代码和执行结果我们可以看到：使用多线程之后程序的运行效率有了明显的提升，但是要注意的是：<span style="color:#fe2c24;">并不是一味地使用多线程就可以提高运行效率，创建线程也需要一定的时间，如果代码本身执行时间是低于创建线程时间的，那么使用多线程反而会起到反效果</span><span style="color:#0d0016;">。</span> </p> 
<h2 id="%E4%BA%94.Thread%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%C2%A0"><strong>五.Thread类及其常见方法 </strong></h2> 
<blockquote> 
 <p> Thread 类是 JVM 用来管理线程的一个类，换句话说，每个线程都有一个唯一的 Thread 对象与之关联。每个执行流，也需要有一个对象来描述，而 Thread 类的对象就是用来描述一个线程执行流的，JVM 会将这些 Thread 对象组织起来，用于线程调度，线程管理。</p> 
</blockquote> 
<h3 id="%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">常见的构造方法</h3> 
<blockquote> 
 <table><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>Thread()</td><td>创建线程对象</td></tr><tr><td>Thread(Runnable target)</td><td>使用 Runnable 对象创建线程对象</td></tr><tr><td>Thread(String name)</td><td>创建线程对象，并命名</td></tr><tr><td>Thread(Runnable target, String name)</td><td>使用 Runnable 对象创建线程对象，并命名</td></tr><tr><td>Thread(ThreadGroup group,<br> Runnable target)</td><td>线程可以被用来分组管理，分好的组即为线程组，这<br> 个目前我们了解即可</td></tr></tbody></table> 
</blockquote> 
<h3 id="%C2%A0%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7"> 常见属性</h3> 
<blockquote> 
 <p>1. ID ：是线程的唯一标识，不同线程不会重复<br> 2.名称：是各种调试工具用到<br> 3.状态：表示线程当前所处的一个情况<br> 4.优先级：优先级高的线程理论上来说更容易被调度到<br> 5.后台线程：需要记住一点：JVM会在一个进程的所有非后台线程结束后，才会结束运行。<br> 6.是否存活： run 方法是否运行结束了</p> 
</blockquote> 
<h3 id="%C2%A0%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%C2%A0"> 启动一个线程 </h3> 
<blockquote> 
 <p> 之前我们已经看到了如何通过覆写 run 方法创建一个线程对象，但线程对象被创建出来并不意味着线程就开始运行了。覆写 run 方法是提供给线程要做的事情的指令清单。线程对象可以认为是把 李四、王五叫过来了，而调用 start() 方法，就是喊一声：”行动起来！“，线程才真正独立去执行了。</p> 
</blockquote> 
<pre><code>    public static void main(String[] args) {
        Thread t = new Thread(() -&gt; {
            System.out.println("任务");
        });
        t.start();
    }</code></pre> 
<h3 id="%C2%A0%E4%B8%AD%E6%96%AD%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B"> 中断一个线程</h3> 
<blockquote> 
 <table><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>public void interrupt()</td><td>中断对象关联的线程，如果线程正在阻塞，则以异常方式通知，<br> 否则设置标志位</td></tr><tr><td>public static boolean<br> interrupted()</td><td>判断当前线程的中断标志位是否设置，调用后清除标志位</td></tr><tr><td>public boolean<br> isInterrupted()</td><td>判断对象关联的线程的标志位是否设置，调用后不清除标志位</td></tr></tbody></table> 
</blockquote> 
<h3 id="%E7%AD%89%E5%BE%85%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%C2%A0">等待一个线程 </h3> 
<blockquote> 
 <table><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>public void join()</td><td>等待线程结束</td></tr><tr><td>public void join(long millis)</td><td>等待线程结束，最多等 millis 毫秒</td></tr><tr><td>public void join(long millis, int nanos)</td><td>同理，但可以更高精度</td></tr></tbody></table> 
</blockquote> 
<h3 id="%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%8E%B0%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%C2%A0">获取当前现象的引用 </h3> 
<blockquote> 
 <table><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>public static Thread currentThread();</td><td>返回当前线程对象的引用</td></tr></tbody></table> 
</blockquote> 
<h3 id="%E4%BC%91%E7%9C%A0%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%C2%A0">休眠当前线程 </h3> 
<blockquote> 
 <table><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>public static void sleep(long millis) throws InterruptedException</td><td>休眠当前线程 millis<br> 毫秒</td></tr><tr><td>public static void sleep(long millis, int nanos) throws<br> InterruptedException</td><td>可以更高精度的休眠</td></tr></tbody></table> 
</blockquote> 
<p><span style="color:#a2e043;"><strong> 以上就是今天的全部内容了，觉得有帮助的话就请点一个赞再走吧！</strong></span></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3412964d77bb1962f1433ac188ef0791/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mac查看Android动态库依赖</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/32c4cbc709e3c1c6c455b702653d6327/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">黑苹果无网络</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>