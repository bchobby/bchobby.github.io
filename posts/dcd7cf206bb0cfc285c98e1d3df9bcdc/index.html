<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>sheng的学习笔记-Zookeeper框架原理 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="sheng的学习笔记-Zookeeper框架原理" />
<meta property="og:description" content="目录
ZK介绍和搭建
zk基础知识
znode-常用命令
znode-数据结构
zk中znode的结构：
zk中节点znode类型-持久节点和持久序号节点
临时节点用于服务发现原理图
ZK客户端Curator：
Curator介绍：
maven配置pom.xml文件
ZK持久化机制​
快照数据
事务日志
数据相关过程
初始化
数据同步 小结：
ZK权限
权限设置：
ZK锁
zk锁的类型：
ZooKeeper分布式锁的原理
（一） ZooKeeper的每一个节点，都是一个天然的顺序发号器。
（二） ZooKeeper节点的递增有序性，可以确保锁的公平 （三）ZooKeeper的节点监听机制，可以保障占有锁的传递有序而且高效
（四）ZooKeeper的节点监听机制，能避免羊群效应
图解：分布式锁的抢占过程
客户端A发起一个加锁请求
客户端B过来排队
客户端B开启监听客户端A
客户端B抢锁成功
分布式锁的基本思路
curator代码
对比ZooKeeper分布式锁和redis锁：
ZK的watch机制
ZK集群
ZK集群搭建
创建myid文件
修改zoo.cfg文件
启动服务
客户端连接
ZK集群原理
ZK服务器节点（非znode）分为3种角色：
ZBA协议
选举leader过程：
选票数据格式：
选举流程简介：
选举规则：
运行过程中检测主节点宕机
选举流程代码解析
ZK中NIO和BIO应用：
ZK介绍和搭建 ZooKeeper 是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。
Zookeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心(提供发布订阅服务)。 服务生产者将自己提供的服务注册到Zookeeper中心，服务的消费者在进行服务调用的时候先到Zookeeper中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。
ZK官网：
Welcome to The Apache Software Foundation!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/dcd7cf206bb0cfc285c98e1d3df9bcdc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-03T16:57:59+08:00" />
<meta property="article:modified_time" content="2022-02-03T16:57:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">sheng的学习笔记-Zookeeper框架原理</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="ZK%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%90%AD%E5%BB%BA-toc" style="margin-left:0px;"><a href="#ZK%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%90%AD%E5%BB%BA" rel="nofollow">ZK介绍和搭建</a></p> 
<p id="zk%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-toc" style="margin-left:0px;"><a href="#zk%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" rel="nofollow">zk基础知识</a></p> 
<p id="znode-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-toc" style="margin-left:40px;"><a href="#znode-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" rel="nofollow">znode-常用命令</a></p> 
<p id="znode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#znode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">znode-数据结构</a></p> 
<p id="zk%E4%B8%ADznode%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%9A-toc" style="margin-left:80px;"><a href="#zk%E4%B8%ADznode%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%9A" rel="nofollow">zk中znode的结构：</a></p> 
<p id="%C2%A0zk%E4%B8%AD%E8%8A%82%E7%82%B9znode%E7%B1%BB%E5%9E%8B-%E6%8C%81%E4%B9%85%E8%8A%82%E7%82%B9%E5%92%8C%E6%8C%81%E4%B9%85%E5%BA%8F%E5%8F%B7%E8%8A%82%E7%82%B9-toc" style="margin-left:40px;"><a href="#%C2%A0zk%E4%B8%AD%E8%8A%82%E7%82%B9znode%E7%B1%BB%E5%9E%8B-%E6%8C%81%E4%B9%85%E8%8A%82%E7%82%B9%E5%92%8C%E6%8C%81%E4%B9%85%E5%BA%8F%E5%8F%B7%E8%8A%82%E7%82%B9" rel="nofollow"> zk中节点znode类型-持久节点和持久序号节点</a></p> 
<p id="%E4%B8%B4%E6%97%B6%E8%8A%82%E7%82%B9%E7%94%A8%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8E%9F%E7%90%86%E5%9B%BE-toc" style="margin-left:80px;"><a href="#%E4%B8%B4%E6%97%B6%E8%8A%82%E7%82%B9%E7%94%A8%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8E%9F%E7%90%86%E5%9B%BE" rel="nofollow">临时节点用于服务发现原理图</a></p> 
<p id="ZK%E5%AE%A2%E6%88%B7%E7%AB%AFCurator%EF%BC%9A-toc" style="margin-left:40px;"><a href="#ZK%E5%AE%A2%E6%88%B7%E7%AB%AFCurator%EF%BC%9A" rel="nofollow">ZK客户端Curator：</a></p> 
<p id="Curator%E4%BB%8B%E7%BB%8D%EF%BC%9A-toc" style="margin-left:80px;"><a href="#Curator%E4%BB%8B%E7%BB%8D%EF%BC%9A" rel="nofollow">Curator介绍：</a></p> 
<p id="maven%E9%85%8D%E7%BD%AEpom.xml%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#maven%E9%85%8D%E7%BD%AEpom.xml%E6%96%87%E4%BB%B6" rel="nofollow">maven配置pom.xml文件</a></p> 
<p id="ZK%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6-toc" style="margin-left:0px;"><a href="#ZK%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6" rel="nofollow">ZK持久化机制</a><a href="#%E2%80%8B" rel="nofollow">​</a></p> 
<p id="%E5%BF%AB%E7%85%A7%E6%95%B0%E6%8D%AE-toc" style="margin-left:40px;"><a href="#%E5%BF%AB%E7%85%A7%E6%95%B0%E6%8D%AE" rel="nofollow">快照数据</a></p> 
<p id="%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97-toc" style="margin-left:40px;"><a href="#%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97" rel="nofollow">事务日志</a></p> 
<p id="%C2%A0%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E8%BF%87%E7%A8%8B-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E8%BF%87%E7%A8%8B" rel="nofollow"> 数据相关过程</a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">初始化</a></p> 
<p id="%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%C2%A0-toc" style="margin-left:80px;"><a href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%C2%A0" rel="nofollow">数据同步 </a></p> 
<p id="%E5%B0%8F%E7%BB%93%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%B0%8F%E7%BB%93%EF%BC%9A" rel="nofollow">小结：</a></p> 
<p id="ZK%E6%9D%83%E9%99%90-toc" style="margin-left:0px;"><a href="#ZK%E6%9D%83%E9%99%90" rel="nofollow">ZK权限</a></p> 
<p id="%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE%EF%BC%9A" rel="nofollow">权限设置：</a></p> 
<p id="ZK%E9%94%81-toc" style="margin-left:0px;"><a href="#ZK%E9%94%81" rel="nofollow">ZK锁</a></p> 
<p id="zk%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%9A-toc" style="margin-left:40px;"><a href="#zk%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%9A" rel="nofollow">zk锁的类型：</a></p> 
<p id="ZooKeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#ZooKeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86" rel="nofollow">ZooKeeper分布式锁的原理</a></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89%20ZooKeeper%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A4%A9%E7%84%B6%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%8F%91%E5%8F%B7%E5%99%A8%E3%80%82-toc" style="margin-left:80px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89%20ZooKeeper%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A4%A9%E7%84%B6%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%8F%91%E5%8F%B7%E5%99%A8%E3%80%82" rel="nofollow">（一） ZooKeeper的每一个节点，都是一个天然的顺序发号器。</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89%20ZooKeeper%E8%8A%82%E7%82%B9%E7%9A%84%E9%80%92%E5%A2%9E%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%A1%AE%E4%BF%9D%E9%94%81%E7%9A%84%E5%85%AC%E5%B9%B3%C2%A0-toc" style="margin-left:80px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89%20ZooKeeper%E8%8A%82%E7%82%B9%E7%9A%84%E9%80%92%E5%A2%9E%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%A1%AE%E4%BF%9D%E9%94%81%E7%9A%84%E5%85%AC%E5%B9%B3%C2%A0" rel="nofollow">（二） ZooKeeper节点的递增有序性，可以确保锁的公平 </a></p> 
<p id="%EF%BC%88%E4%B8%89%EF%BC%89ZooKeeper%E7%9A%84%E8%8A%82%E7%82%B9%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BF%9D%E9%9A%9C%E5%8D%A0%E6%9C%89%E9%94%81%E7%9A%84%E4%BC%A0%E9%80%92%E6%9C%89%E5%BA%8F%E8%80%8C%E4%B8%94%E9%AB%98%E6%95%88-toc" style="margin-left:80px;"><a href="#%EF%BC%88%E4%B8%89%EF%BC%89ZooKeeper%E7%9A%84%E8%8A%82%E7%82%B9%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BF%9D%E9%9A%9C%E5%8D%A0%E6%9C%89%E9%94%81%E7%9A%84%E4%BC%A0%E9%80%92%E6%9C%89%E5%BA%8F%E8%80%8C%E4%B8%94%E9%AB%98%E6%95%88" rel="nofollow">（三）ZooKeeper的节点监听机制，可以保障占有锁的传递有序而且高效</a></p> 
<p id="%EF%BC%88%E5%9B%9B%EF%BC%89ZooKeeper%E7%9A%84%E8%8A%82%E7%82%B9%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6%EF%BC%8C%E8%83%BD%E9%81%BF%E5%85%8D%E7%BE%8A%E7%BE%A4%E6%95%88%E5%BA%94-toc" style="margin-left:80px;"><a href="#%EF%BC%88%E5%9B%9B%EF%BC%89ZooKeeper%E7%9A%84%E8%8A%82%E7%82%B9%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6%EF%BC%8C%E8%83%BD%E9%81%BF%E5%85%8D%E7%BE%8A%E7%BE%A4%E6%95%88%E5%BA%94" rel="nofollow">（四）ZooKeeper的节点监听机制，能避免羊群效应</a></p> 
<p id="图解分布式锁的抢占过程-toc" style="margin-left:40px;"><a href="#%E5%9B%BE%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%8A%A2%E5%8D%A0%E8%BF%87%E7%A8%8B" rel="nofollow">图解：分布式锁的抢占过程</a></p> 
<p id="autoid-h2-3-0-0-toc" style="margin-left:80px;"><a href="#autoid-h2-3-0-0" rel="nofollow">客户端A发起一个加锁请求</a></p> 
<p id="%C2%A0%E5%AE%A2%E6%88%B7%E7%AB%AFB%E8%BF%87%E6%9D%A5%E6%8E%92%E9%98%9F-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%AE%A2%E6%88%B7%E7%AB%AFB%E8%BF%87%E6%9D%A5%E6%8E%92%E9%98%9F" rel="nofollow"> 客户端B过来排队</a></p> 
<p id="%C2%A0%E5%AE%A2%E6%88%B7%E7%AB%AFB%E5%BC%80%E5%90%AF%E7%9B%91%E5%90%AC%E5%AE%A2%E6%88%B7%E7%AB%AFA-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%AE%A2%E6%88%B7%E7%AB%AFB%E5%BC%80%E5%90%AF%E7%9B%91%E5%90%AC%E5%AE%A2%E6%88%B7%E7%AB%AFA" rel="nofollow"> 客户端B开启监听客户端A</a></p> 
<p id="autoid-h2-6-0-0-toc" style="margin-left:80px;"><a href="#autoid-h2-6-0-0" rel="nofollow">客户端B抢锁成功</a></p> 
<p id="分布式锁的基本实现-toc" style="margin-left:40px;"><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0" rel="nofollow">分布式锁的基本思路</a></p> 
<p id="curator%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#curator%E4%BB%A3%E7%A0%81" rel="nofollow">curator代码</a></p> 
<p id="%E5%AF%B9%E6%AF%94ZooKeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8Credis%E9%94%81%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E5%AF%B9%E6%AF%94ZooKeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8Credis%E9%94%81%EF%BC%9A" rel="nofollow">对比ZooKeeper分布式锁和redis锁：</a></p> 
<p id="ZK%E7%9A%84watch%E6%9C%BA%E5%88%B6-toc" style="margin-left:0px;"><a href="#ZK%E7%9A%84watch%E6%9C%BA%E5%88%B6" rel="nofollow">ZK的watch机制</a></p> 
<p id="ZK%E9%9B%86%E7%BE%A4-toc" style="margin-left:0px;"><a href="#ZK%E9%9B%86%E7%BE%A4" rel="nofollow">ZK集群</a></p> 
<p id="ZK%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA-toc" style="margin-left:40px;"><a href="#ZK%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA" rel="nofollow">ZK集群搭建</a></p> 
<p id="%E5%88%9B%E5%BB%BAmyid%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#%E5%88%9B%E5%BB%BAmyid%E6%96%87%E4%BB%B6" rel="nofollow">创建myid文件</a></p> 
<p id="%C2%A0%E4%BF%AE%E6%94%B9zoo.cfg%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%BF%AE%E6%94%B9zoo.cfg%E6%96%87%E4%BB%B6" rel="nofollow"> 修改zoo.cfg文件</a></p> 
<p id="%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1-toc" style="margin-left:80px;"><a href="#%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1" rel="nofollow">启动服务</a></p> 
<p id="%C2%A0%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5" rel="nofollow"> 客户端连接</a></p> 
<p id="ZK%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#ZK%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86" rel="nofollow">ZK集群原理</a></p> 
<p id="ZK%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8A%82%E7%82%B9%EF%BC%88%E9%9D%9Eznode%EF%BC%89%E5%88%86%E4%B8%BA3%E7%A7%8D%E8%A7%92%E8%89%B2%EF%BC%9A-toc" style="margin-left:80px;"><a href="#ZK%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8A%82%E7%82%B9%EF%BC%88%E9%9D%9Eznode%EF%BC%89%E5%88%86%E4%B8%BA3%E7%A7%8D%E8%A7%92%E8%89%B2%EF%BC%9A" rel="nofollow">ZK服务器节点（非znode）分为3种角色：</a></p> 
<p id="ZBA%E5%8D%8F%E8%AE%AE-toc" style="margin-left:80px;"><a href="#ZBA%E5%8D%8F%E8%AE%AE" rel="nofollow">ZBA协议</a></p> 
<p id="%E9%80%89%E4%B8%BEleader%E8%BF%87%E7%A8%8B%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E9%80%89%E4%B8%BEleader%E8%BF%87%E7%A8%8B%EF%BC%9A" rel="nofollow">选举leader过程：</a></p> 
<p id="%E9%80%89%E7%A5%A8%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E9%80%89%E7%A5%A8%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%EF%BC%9A" rel="nofollow">选票数据格式：</a></p> 
<p id="%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B%EF%BC%9A" rel="nofollow">选举流程简介：</a></p> 
<p id="%C2%A0%E9%80%89%E4%B8%BE%E8%A7%84%E5%88%99%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%C2%A0%E9%80%89%E4%B8%BE%E8%A7%84%E5%88%99%EF%BC%9A" rel="nofollow"> 选举规则：</a></p> 
<p id="%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%A3%80%E6%B5%8B%E4%B8%BB%E8%8A%82%E7%82%B9%E5%AE%95%E6%9C%BA-toc" style="margin-left:80px;"><a href="#%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%A3%80%E6%B5%8B%E4%B8%BB%E8%8A%82%E7%82%B9%E5%AE%95%E6%9C%BA" rel="nofollow">运行过程中检测主节点宕机</a></p> 
<p id="%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90-toc" style="margin-left:80px;"><a href="#%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90" rel="nofollow">选举流程代码解析</a></p> 
<p id="ZK%E4%B8%ADNIO%E5%92%8CBIO%E5%BA%94%E7%94%A8%EF%BC%9A-toc" style="margin-left:40px;"><a href="#ZK%E4%B8%ADNIO%E5%92%8CBIO%E5%BA%94%E7%94%A8%EF%BC%9A" rel="nofollow">ZK中NIO和BIO应用：</a></p> 
<hr id="hr-toc"> 
<ul><li> <h2 id="ZK%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%90%AD%E5%BB%BA">ZK介绍和搭建</h2> </li></ul> 
<p><strong>ZooKeeper 是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</strong></p> 
<p><strong>Zookeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心(提供发布订阅服务)。</strong> 服务生产者将自己提供的服务注册到Zookeeper中心，服务的消费者在进行服务调用的时候先到Zookeeper中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。<br>  </p> 
<p>ZK官网：</p> 
<p><a href="https://www.apache.org/" rel="nofollow" title="Welcome to The Apache Software Foundation!">Welcome to The Apache Software Foundation!</a></p> 
<p>下载后可以看到bin和conf目录，下载目录如下(注意，要下bin文件，如果下载源码，运行会报错）：</p> 
<p><img alt="" height="357" src="https://images2.imgbox.com/ae/39/5vTm9xh3_o.png" width="340"></p> 
<p></p> 
<p> 在conf中有zoo_sample.cfg，这是示例配置，拷贝出一个zoo.cfg（程序默认的配置文件），文件和内容如下：</p> 
<p><img alt="" height="191" src="https://images2.imgbox.com/c4/c4/afeYDg3i_o.png" width="364"></p> 
<blockquote> 
 <p># The number of milliseconds of each tick<br> tickTime=2000<br> # The number of ticks that the initial <br> # synchronization phase can take<br> initLimit=10<br> # The number of ticks that can pass between <br> # sending a request and getting an acknowledgement<br> syncLimit=5<br> # the directory where the snapshot is stored.<br> # do not use /tmp for storage, /tmp here is just <br> # example sakes.<br> dataDir=/tmp/zookeeper    <span style="color:#fe2c24;">#此处改为自己的路径</span><br> # the port at which the clients will connect<br> clientPort=2181<br> # the maximum number of client connections.<br> # increase this if you need to handle more clients<br> #maxClientCnxns=60<br> #<br> # Be sure to read the maintenance section of the <br> # administrator guide before turning on autopurge.<br> #<br> # http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance<br> #<br> # The number of snapshots to retain in dataDir<br> #autopurge.snapRetainCount=3<br> # Purge task interval in hours<br> # Set to "0" to disable auto purge feature<br> #autopurge.purgeInterval=1</p> 
 <p>## Metrics Providers<br> #<br> # https://prometheus.io Metrics Exporter<br> #metricsProvider.className=org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider<br> #metricsProvider.httpPort=7000<br> #metricsProvider.exportJvmInfo=true</p> 
 <p></p> 
</blockquote> 
<p> 配置文件简单解析<br> 　　1.tickTime：这个时间是作为 zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。<br> 　　2.dataDir：顾名思义就是 zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。<br> 　　3.clientPort：这个端口就是客户端连接 zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</p> 
<p>然后运行bin/zkServer.cmd （这是windows的，如果是linux,运行zkServer.sh），双击或者在bash中运行都行</p> 
<p><img alt="" height="784" src="https://images2.imgbox.com/c6/ae/wpXyIqup_o.png" width="1200"></p> 
<p><img alt="" height="214" src="https://images2.imgbox.com/0f/28/1y9xbJ6z_o.png" width="997"></p> 
<p> 服务和端口都起来了，用客户端连接一下</p> 
<p><img alt="" height="409" src="https://images2.imgbox.com/93/72/p5DNq7NQ_o.png" width="1200"></p> 
<p></p> 
<h2 id="zk%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">zk基础知识</h2> 
<h3 id="znode-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">znode-常用命令</h3> 
<blockquote> 
 <p>[zk: localhost:2181(CONNECTED) 0] ls /     <span style="color:#fe2c24;"> //查看节点</span><br> [zookeeper]<br> [zk: localhost:2181(CONNECTED) 1] create /test1    <span style="color:#fe2c24;">// 创建节点</span><br> Created /test1<br> [zk: localhost:2181(CONNECTED) 2] ls /<br> [test1, zookeeper]<br> [zk: localhost:2181(CONNECTED) 3] create /test1/sub1    <span style="color:#fe2c24;">// 创建子节点</span><br> Created /test1/sub1<br> [zk: localhost:2181(CONNECTED) 4] ls /<br> [test1, zookeeper]<br> [zk: localhost:2181(CONNECTED) 5] create /test2 abc     <span style="color:#fe2c24;">// 创建节点，并放入数据</span><br> Created /test2<br> [zk: localhost:2181(CONNECTED) 6] get /test2     <span style="color:#fe2c24;">// 获取节点数据</span><br> abc</p> 
 <p>[zk: localhost:2181(CONNECTED) 29] create /test1/sub1/sub2   <br> Created /test1/sub1/sub2<br> [zk: localhost:2181(CONNECTED) 30] ls -R /test1  <span style="color:#fe2c24;"> //-R参数递归查询，看到所有子节点</span><br> /test1<br> /test1/sub1<br> /test1/sub1/sub2</p> 
 <p></p> 
 <p>[zk: localhost:2181(CONNECTED) 33] delete /test1  <span style="color:#fe2c24;"> //删除节点，但节点内有子节点，删除失败</span><br> Node not empty: /test1<br> [zk: localhost:2181(CONNECTED) 34] deleteall /test1  <span style="color:#fe2c24;"> // 删除节点和其内子节点</span><br> [zk: localhost:2181(CONNECTED) 35] ls /test2<br> []<br> [zk: localhost:2181(CONNECTED) 36] delete -v 1 /test2  <span style="color:#fe2c24;"> //根据版本号删除节点，版本号错误删除失败,目前版本号是0，<strong>乐观锁删除，用于高并发</strong></span><br> version No is not valid : /test2<br> [zk: localhost:2181(CONNECTED) 37] get -s /test2<br> abc<br> cZxid = 0x12<br> ctime = Thu Jan 27 18:13:11 CST 2022<br> mZxid = 0x12<br> mtime = Thu Jan 27 18:13:11 CST 2022<br> pZxid = 0x12<br><strong>cversion = 0</strong><br><span style="color:#ff9900;">dataVersion = 0</span><br> aclVersion = 0<br> ephemeralOwner = 0x0<br> dataLength = 3<br> numChildren = 0</p> 
 <p>[zk: localhost:2181(CONNECTED) 38] set /test2 aaa   <span style="color:#fe2c24;">//设置节点数据为aaa</span></p> 
 <p>[zk: localhost:2181(CONNECTED) 42] get -s /test2<br> aaa<br> cZxid = 0x12<br> ctime = Thu Jan 27 18:13:11 CST 2022<br> mZxid = 0x1f<br> mtime = Thu Jan 27 20:54:39 CST 2022<br> pZxid = 0x12<br> cversion = 0<br><span style="color:#ff9900;">dataVersion = 1   //此处版本号变为1</span><br> aclVersion = 0<br> ephemeralOwner = 0x0<br> dataLength = 3<br> numChildren = 0</p> 
</blockquote> 
<p></p> 
<blockquote> 
 <p> [zk: localhost:2181(CONNECTED) 7] get -s /test2   <span style="color:#fe2c24;">// 获取节点详细信息</span><br> abc<br> cZxid = 0x12    <span style="color:#fe2c24;">//节点创建时的zxid.</span><br> ctime = Thu Jan 27 18:13:11 CST 2022    <span style="color:#fe2c24;">//节点创建时的时间戳</span><br> mZxid = 0x12  <span style="color:#fe2c24;"> //节点最新一次更新发生时的zxid</span><br> mtime = Thu Jan 27 18:13:11 CST 2022   <span style="color:#fe2c24;"> //节点最新一次更新发生时的时间戳</span><br> pZxid = 0x12<br> cversion = 0   <span style="color:#fe2c24;"> // 其子节点的更新次数</span><br> dataVersion = 0    <span style="color:#fe2c24;">//节点数据的更新次数</span><br> aclVersion = 0   <span style="color:#fe2c24;">// 节点ACL(授权信息)的更新次数</span><br> ephemeralOwner = 0x0    <span style="color:#fe2c24;">// 如果该节点为ephemeral节点, ephemeralOwner值表示与该节点绑定的session id. 如果该节点不是ephemeral节点, ephemeralOwner值为0</span><br> dataLength = 3  <span style="color:#fe2c24;"> // 节点数据的字节数</span><br> numChildren = 0  <span style="color:#fe2c24;">//子节点个数</span></p> 
</blockquote> 
<h3 id="znode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">znode-数据结构</h3> 
<p>ZK中数据是保存在节点中，节点是znode，多个znode组成一个树的目录结构，如下图</p> 
<p><img alt="" height="348" src="https://images2.imgbox.com/e4/50/1L2HxGR7_o.png" width="744"></p> 
<p>不同于树的节点，znode的饮用方式是路径引用，类似文件路径：</p> 
<blockquote> 
 <p>/动物/猫</p> 
 <p>/汽车/宝马 </p> 
</blockquote> 
<h4 id="zk%E4%B8%ADznode%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%9A">zk中znode的结构：</h4> 
<blockquote> 
 <p>data:保存数据</p> 
 <p>acl:权限，定义了什么样的用户能够操作这个节点，且能够进行怎样的操作</p> 
 <ul><li>        CREATE(r)：创建子节点的权限</li><li>        DELETE(d)：删除节点的权限</li><li>        READ(r)：读取节点数据的权限</li><li>        WRITE(w)：修改节点数据的权限</li><li>        ADMIN(a)：设置子节点权限的权限 </li></ul> 
 <p>stat:描述当前znode的元数据</p> 
 <p>child:当前节点的子节点</p> 
</blockquote> 
<p>具体实现：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d0/04/3k4d8IRA_o.png"></p> 
<ol><li>DataTree 中 nodes 是 Map，表示所有的 ZK 节点，那其内部 key 是：ZNode 的唯一标识 <code>path</code> 作为 key</li><li>ephemerals 是Map，用于存储临时节点，临时节点是跟 Session 绑定的，sessionId 作为 key</li></ol> 
<p></p> 
<h3 id="%C2%A0zk%E4%B8%AD%E8%8A%82%E7%82%B9znode%E7%B1%BB%E5%9E%8B-%E6%8C%81%E4%B9%85%E8%8A%82%E7%82%B9%E5%92%8C%E6%8C%81%E4%B9%85%E5%BA%8F%E5%8F%B7%E8%8A%82%E7%82%B9"> zk中节点znode类型-持久节点和持久序号节点</h3> 
<blockquote> 
 <p>[zk: localhost:2181(CONNECTED) 8] create /test3  <span style="color:#fe2c24;">// 默认是持久节点</span><br> Created /test3<br> [zk: localhost:2181(CONNECTED) 9] create /test3  <span style="color:#fe2c24;">//创建同名持久节点报错</span><br> Node already exists: /test3<br> [zk: localhost:2181(CONNECTED) 10] create -s /test3  <span style="color:#fe2c24;">//持久顺序节点</span><br> Created /test30000000003<br> [zk: localhost:2181(CONNECTED) 11] ls /<br> [test1, test2, test3, test30000000003, zookeeper]<br> [zk: localhost:2181(CONNECTED) 12] create -s /test3<br> Created /test30000000004<br> [zk: localhost:2181(CONNECTED) 13] ls /<br> [test1, test2, test3, test30000000003, test30000000004, zookeeper]<br> [zk: localhost:2181(CONNECTED) 14] create -e /test5 <span style="color:#fe2c24;"> //创建临时节点，关闭当前会话，重新开个会话，节点就没了</span><br> Created /test5<br> [zk: localhost:2181(CONNECTED) 15] ls /<br> [test1, test2, test3, test30000000003, test30000000004, test5, zookeeper]</p> 
 <p>[zk: localhost:2181(CONNECTED) 26] create -e -s /test6   <span style="color:#fe2c24;">//创建临时序号节点</span><br> Created /test60000000006<br> [zk: localhost:2181(CONNECTED) 27] ls /<br> [test1, test2, test3, test30000000003, test30000000004, test60000000006, zookeep<br> er]</p> 
</blockquote> 
<p><img alt="" height="123" src="https://images2.imgbox.com/9e/0d/pUbvLFKt_o.png" width="753"></p> 
<p> <img alt="" height="170" src="https://images2.imgbox.com/ae/f4/hwwlHkAa_o.png" width="752"></p> 
<p></p> 
<ul><li><strong>持久节点</strong>（PERSISTENT）：session断联、服务端重启还在；可以创建子节点，子节点可以临时也可以持久；不能同名</li><li><strong>持久顺序节点</strong>（PERSISTENT_SEQUENTIAL）：session断联、服务端重启还在；可以创建子节点，子节点可以临时也可以持久；同名节点会在后面添加上序号，根据先后顺序，会在节点后带一个数值，越后执行数值越大，适用于分布式的应用场景，单调递增</li><li><strong>临时节点</strong>（EPHEMERAL） ：session链接断开后自动删除，通过这个特性，<strong><span style="color:#fe2c24;">zk可以实现服务注册和发现的效果</span></strong>；不能创建子节点；不能同名</li><li><strong>临时顺序节点</strong>（EPHEMERAL_SEQUENTIAL） ：session链接断开就没了；不能创建子节点；同名节点会在后面添加上序号，<strong><span style="color:#fe2c24;">适用于临时的分布式锁</span></strong></li><li><span style="color:#0d0016;"><strong>Container节点</strong>（3.5.3版本后增加）：容器节点，当容器没有任何子节点，会被zk定期删除（默认60s）,容器节点用于存放子节点</span></li><li><strong>TTL节点</strong>：可以指定节点到期时间，到期后被zk定时删除</li></ul> 
<h4 id="%E4%B8%B4%E6%97%B6%E8%8A%82%E7%82%B9%E7%94%A8%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8E%9F%E7%90%86%E5%9B%BE">临时节点用于服务发现原理图</h4> 
<p><img alt="" height="454" src="https://images2.imgbox.com/19/6d/Yb9fCDP4_o.png" width="994"></p> 
<p> 如果是临时节点，zk服务器的session id在持续会话时，会延迟消亡时间，在一段时间没有会话后，会自动删除session id对应的临时节点</p> 
<h3 id="ZK%E5%AE%A2%E6%88%B7%E7%AB%AFCurator%EF%BC%9A">ZK客户端Curator：</h3> 
<h4 id="Curator%E4%BB%8B%E7%BB%8D%EF%BC%9A">Curator介绍：</h4> 
<p>Curator是Netflix公司开源的一套zookeeper客户端框架，解决了很多Zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册Watcher和NodeExistsException异常等等。</p> 
<p>官网：<a class="has-card" href="https://curator.apache.org/" rel="nofollow" title="Apache Curator –"><span class="link-card-box"><span class="link-title">Apache Curator –</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/fd/28/HRY46YYv_o.png">https://curator.apache.org/</span></span></a></p> 
<h4 id="maven%E9%85%8D%E7%BD%AEpom.xml%E6%96%87%E4%BB%B6">maven配置pom.xml文件</h4> 
<blockquote> 
 <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;zookeeper-app&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;16&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;16&lt;/maven.compiler.target&gt;
        &lt;curator.version&gt;2.12.0&lt;/curator.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-client&lt;/artifactId&gt;
            &lt;version&gt;${curator.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
            &lt;version&gt;${curator.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
            &lt;version&gt;${curator.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-test&lt;/artifactId&gt;
            &lt;version&gt;${curator.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-x-discovery&lt;/artifactId&gt;
            &lt;version&gt;${curator.version}&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-x-discovery-server&lt;/artifactId&gt;
            &lt;version&gt;${curator.version}&lt;/version&gt;
        &lt;/dependency&gt;


        &lt;!-- 对zookeeper的底层api的一些封装
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
            &lt;version&gt;2.12.0&lt;/version&gt;
        &lt;/dependency&gt;--&gt;
        &lt;!-- 封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式Barrier
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
            &lt;version&gt;2.12.0&lt;/version&gt;
        &lt;/dependency&gt;
        --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
            &lt;version&gt;3.4.6&lt;/version&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;com.sun.jmx&lt;/groupId&gt;
                    &lt;artifactId&gt;jmxri&lt;/artifactId&gt;
                &lt;/exclusion&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;com.sun.jdmk&lt;/groupId&gt;
                    &lt;artifactId&gt;jmxtools&lt;/artifactId&gt;
                &lt;/exclusion&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;javax.jms&lt;/groupId&gt;
                    &lt;artifactId&gt;jms&lt;/artifactId&gt;
                &lt;/exclusion&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;junit&lt;/groupId&gt;
                    &lt;artifactId&gt;junit&lt;/artifactId&gt;
                &lt;/exclusion&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
                    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
            &lt;version&gt;1.7.6&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
            &lt;version&gt;1.7.25&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

&lt;/project&gt;</pre> 
</blockquote> 
<p>curator示例代码</p> 
<pre><code class="language-java">import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.CreateMode;
import org.junit.Before;
import org.junit.Test;

import java.nio.charset.StandardCharsets;

public class ZKClientCuratorTest {
    CuratorFramework client;

    @Before
    public void init(){
        System.out.println("call init function");
        // 重试策略：重试之间等待的初始时间，最大的重试次数
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);
        // 通过工厂建造出连接实例：client
        CuratorFramework curatorFramework = CuratorFrameworkFactory.builder()
                .connectString("localhost:2181")
                .sessionTimeoutMs(5000)  // 会话超时时间
                .connectionTimeoutMs(5000) // 连接超时时间
                .retryPolicy(retryPolicy)
                .namespace("base") // 包含隔离名称
                .build();
        client = curatorFramework;
        // 客户端必须开始
        curatorFramework.start();
    }

    // 创建节点
    @Test
    public void testCreateMode() throws Exception {
        client.create().creatingParentContainersIfNeeded() // 递归创建所需父节点
                .withMode(CreateMode.PERSISTENT_SEQUENTIAL) // 创建类型为持久序号节点，避免重复运行时报错
                .forPath("/nodeA/sub1", "init".getBytes()); // 目录及内容
        //添加持久节点
        String path = client.create().forPath("/create-for-path-curator-node");
        // 添加持久序号节点
        String path1 = client.create().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/create-EPHEMERAL_SEQUENTIAL-curator-node",
                "some-data".getBytes(StandardCharsets.UTF_8));
        System.out.println("持久节点：" + path);
        System.out.println("添加持久序号节点：" + path1);
    }


    //查询节点
    @Test
    public void testSetAndGetData() throws Exception {
        // 设置数据
        client.setData().forPath("/create-for-path-curator-node","changed".getBytes(StandardCharsets.UTF_8));
        //查询数据
        byte[] bytes = client.getData().forPath("/create-for-path-curator-node");
        System.out.println("获取/create-for-path-curator-node节点信息：" + new String(bytes));
    }

    @Test
    public void testDeleteData() throws Exception {
        // 如果有子节点，一并删除
        client.delete().guaranteed().deletingChildrenIfNeeded().forPath("/nodeA");
    }
}
</code></pre> 
<p>上述每运行一个方法就去zk的客户端看下数据</p> 
<p><img alt="" height="478" src="https://images2.imgbox.com/b5/4b/3AH3cF5v_o.png" width="830"></p> 
<p></p> 
<p></p> 
<h2 id="ZK%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6">ZK持久化机制</h2> 
<p>zk的数据是运行在内存中，提供两种持久化机制：</p> 
<p><strong>事务日志</strong>：zk把执行的命令以日志形式保存在dataLogDir指定的路径中的文件</p> 
<p><strong>数据快照</strong>：zk会定时将一定时间间隔内做一次内存数据的快照，并将内存数据保存在快照文件中</p> 
<h4 id="%E2%80%8B"><img alt="" height="384" src="https://images2.imgbox.com/64/91/m8aW1uOP_o.png" width="856"></h4> 
<p></p> 
<h3 id="%E5%BF%AB%E7%85%A7%E6%95%B0%E6%8D%AE">快照数据</h3> 
<p>快照数据生成的基本过程：</p> 
<p></p> 
<p>关键点：</p> 
<ol><li>异步：异步线程生成快照文件</li><li>Fuzzy 快照： 
  <ul><li>快照文件生成过程中，仍然有新的事务提交，</li><li>因此，快照文件不是精确到某一时刻的快照文件，而是<code>模糊的</code>，</li><li>这就要求<code>事务操作</code>是<code>幂等的</code>，否则产生不一致。</li></ul></li></ol> 
<h3 id="%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97">事务日志</h3> 
<p>关键点：</p> 
<ol><li>事务日志频繁 flush 到磁盘，消耗大量磁盘 IO</li><li>磁盘空间<code>预分配</code>：事务日志剩余空间 &lt; 4KB 时，将文件大小增加 64 MB</li><li><code>磁盘预分配</code>的目标：减少磁盘 seek 次数</li></ol> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fb/d4/UIPkxxWJ_o.png"></p> 
<p><strong>事务序列化</strong>：本质是生成一个字节数组</p> 
<ol><li>包含：事务头、事务体的序列化</li><li>事务体：会话创建事务、节点创建事务、节点删除事务、节点数据更新事务</li></ol> 
<p><strong>日志截断</strong>：</p> 
<ol><li>现象：Learner 的机器上记录的 zxid 比 Leader 机器上的 zxid 大，这是非法状态；</li><li>原则：只要集群中存在 Leader，所有机器都必须与 Leader 的数据保持同步</li><li>处理细节：遇到非法状态，Leader 发送 TRUNC 命令给特定机器，要求进行日志截断，Learner 机器收到命令，会删除非法的事务日志</li></ol> 
<h3 id="%C2%A0%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E8%BF%87%E7%A8%8B"> 数据相关过程</h3> 
<h4 id="%E5%88%9D%E5%A7%8B%E5%8C%96">初始化</h4> 
<p>ZK 服务器启动时，首先会进行数据初始化，将磁盘中数据，加载到内存中，恢复现场。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/35/1a/kJDomyaw_o.png"></p> 
<h4 id="%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%C2%A0">数据同步 </h4> 
<p>ZK 集群服务器启动之后，会进行 2 个动作：</p> 
<ol><li>选举 Leader：分配角色</li><li>Learner 向 Leader 服务器注册：数据同步</li></ol> 
<p>数据同步，<strong>本质</strong>：将没有在 Learner 上执行的事务，同步给 Learner</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/61/a0/skblwapq_o.png"></p> 
<h4 id="%E5%B0%8F%E7%BB%93%EF%BC%9A">小结：</h4> 
<ul><li>内存数据，是真正提供服务的数据</li><li>磁盘数据，作用： 
  <ul><li>恢复内存数据，恢复现场，<span style="color:#fe2c24;">先恢复快照文件中的数据到内存，再用日志文件中的数据做增量恢复，这样恢复速度更快</span></li><li>数据同步：集群内，不同节点间的数据同步（另，内存中的提议缓存队列 proposals）</li><li>磁盘数据，为什么同时包含：快照、事务日志？出于数据粒度的考虑 
    <ul><li>如果只包含快照，那恢复现场的时候，会有数据丢失，因为生成快照的时间间隔太大，即，快照的粒度太粗了</li><li>事务日志，针对每条提交的事务都会 flush 到磁盘，因此粒度很细，恢复现场时，能够恢复到事务粒度上</li></ul></li></ul></li></ul> 
<h2></h2> 
<h2 id="ZK%E6%9D%83%E9%99%90">ZK权限</h2> 
<h4 id="%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE%EF%BC%9A">权限设置：</h4> 
<p>设置当前会话的账号和密码：</p> 
<blockquote> 
 <p>[zk: localhost:2181(CONNECTED) 45] addauth digest user:123456   <span style="color:#fe2c24;">//创建权限的用户名和密码，user是用户名，密码是123456</span><br> [zk: localhost:2181(CONNECTED) 46] create /test-node abcd auth:user:123456:cdwra  <span style="color:#fe2c24;">//创建一个节点，必须是用户user好额密码123456的人，拥有权限：cdwra(权限值看上面znode节点介绍）</span></p> 
 <p>Created /test-node<br> [zk: localhost:2181(CONNECTED) 47] ls /test-node<br> []</p> 
 <p><strong><span style="background-color:#ff9900;">新开一个客户端，用以下命令测试</span></strong></p> 
 <p>[zk: localhost:2181(CONNECTED) 0] ls /test-node   <span style="color:#fe2c24;">//此处没有权限,报错</span><br> Insufficient permission : /test-node<br> [zk: localhost:2181(CONNECTED) 1] get /test-node   <span style="color:#fe2c24;">//此处没有权限,报错</span><br> org.apache.zookeeper.KeeperException$NoAuthException: KeeperErrorCode = NoAuth f<br> or /test-node<br> [zk: localhost:2181(CONNECTED) 2] addauth digest user:123456   <span style="color:#fe2c24;">//添加本会话权限</span><br> [zk: localhost:2181(CONNECTED) 3] get /test-node   //拥有权限后操作成功<br> abcd</p> 
</blockquote> 
<h2 id="ZK%E9%94%81">ZK锁</h2> 
<p>在单体的应用开发场景中，涉及并发同步的时候，大家往往采用synchronized或者Lock的方式来解决多线程间的同步问题。但在分布式集群工作的开发场景中，那么就需要一种更加高级的锁机制，来处理种跨JVM进程之间的数据同步问题，这就是<span style="color:#fe2c24;">分布式锁</span>。</p> 
<h3 id="zk%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%9A">zk锁的类型：</h3> 
<p>读锁：大家都可以读，想要上读锁的前提：之前的锁没有写锁</p> 
<p>写锁：只有得到写锁的才能写，想要上写锁的前提是：之前没有任何锁（不能有读锁或者写锁）</p> 
<h3 id="ZooKeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86">ZooKeeper分布式锁的原理</h3> 
<h4 id="%EF%BC%88%E4%B8%80%EF%BC%89%20ZooKeeper%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A4%A9%E7%84%B6%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%8F%91%E5%8F%B7%E5%99%A8%E3%80%82">（一） ZooKeeper的每一个节点，都是一个天然的顺序发号器。</h4> 
<p>在每一个节点下面创建临时顺序节点（EPHEMERAL_SEQUENTIAL）类型，新的子节点后面，会加上一个次序编号，而这个生成的次序编号，是上一个生成的次序编号加一。</p> 
<p>例如，有一个用于发号的节点“/test/lock”为父亲节点，可以在这个父节点下面创建相同前缀的临时顺序子节点，假定相同的前缀为“/test/lock/seq-”。第一个创建的子节点基本上应该为/test/lock/seq-0000000000，下一个节点则为/test/lock/seq-0000000001，依次类推</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/08/8c/snJZ2Ss1_o.png"></p> 
<p>Zookeeper临时顺序节点的天然的发号器作用</p> 
<h4 id="%EF%BC%88%E4%BA%8C%EF%BC%89%20ZooKeeper%E8%8A%82%E7%82%B9%E7%9A%84%E9%80%92%E5%A2%9E%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%A1%AE%E4%BF%9D%E9%94%81%E7%9A%84%E5%85%AC%E5%B9%B3%C2%A0">（二） ZooKeeper节点的递增有序性，可以确保锁的公平 </h4> 
<p> 一个ZooKeeper分布式锁，首先需要创建一个父节点，尽量是持久节点（PERSISTENT类型），然后每个要获得锁的线程，都在这个节点下创建个临时顺序节点。由于ZK节点，是按照创建的次序，依次递增的。</p> 
<p>为了确保公平，可以简单的规定：编号最小的那个节点，表示获得了锁。所以，每个线程在尝试占用锁之前，首先判断自己是排号是不是当前最小，如果是，则获取锁。</p> 
<h4 id="%EF%BC%88%E4%B8%89%EF%BC%89ZooKeeper%E7%9A%84%E8%8A%82%E7%82%B9%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BF%9D%E9%9A%9C%E5%8D%A0%E6%9C%89%E9%94%81%E7%9A%84%E4%BC%A0%E9%80%92%E6%9C%89%E5%BA%8F%E8%80%8C%E4%B8%94%E9%AB%98%E6%95%88">（三）ZooKeeper的节点监听机制，可以保障占有锁的传递有序而且高效</h4> 
<p>每个线程抢占锁之前，先尝试创建自己的ZNode。同样，释放锁的时候，就需要删除创建的Znode。创建成功后，如果不是排号最小的节点，就处于等待通知的状态。等谁的通知呢？不需要其他人，只需要等前一个Znode<br> 的通知就可以了。前一个Znode删除的时候，会触发Znode事件，当前节点能监听到删除事件，就是轮到了自己占有锁的时候。第一个通知第二个、第二个通知第三个，击鼓传花似的依次向后。</p> 
<p>ZooKeeper的节点监听机制，能够非常完美地实现这种击鼓传花似的信息传递。具体的方法是，每一个等通知的Znode节点，只需要监听（linsten）或者监视（watch）排号在自己前面那个，而且紧挨在自己前面的那个节点，就能收到其删除事件了。<br> 只要上一个节点被删除了，就进行再一次判断，看看自己是不是序号最小的那个节点，如果是，自己就获得锁。</p> 
<p>另外，ZooKeeper的内部优越的机制，能保证由于网络异常或者其他原因，集群中占用锁的客户端失联时，锁能够被有效释放。一旦占用Znode锁的客户端与ZooKeeper集群服务器失去联系，这个临时Znode也将自动删除。排在它后面的那个节点，也能收到删除事件，从而获得锁。正是由于这个原因，在创建取号节点的时候，尽量创建临时znode<br> 节点，</p> 
<h4 id="%EF%BC%88%E5%9B%9B%EF%BC%89ZooKeeper%E7%9A%84%E8%8A%82%E7%82%B9%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6%EF%BC%8C%E8%83%BD%E9%81%BF%E5%85%8D%E7%BE%8A%E7%BE%A4%E6%95%88%E5%BA%94">（四）ZooKeeper的节点监听机制，能避免羊群效应</h4> 
<p>ZooKeeper这种首尾相接，后面监听前面的方式，可以避免羊群效应。所谓羊群效应就是一个节点挂掉，所有节点都去监听，然后做出反应，这样会给服务器带来巨大压力，所以有了临时顺序节点，当一个节点挂掉，只有它后面的那一个节点才做出反应。</p> 
<h3 id="图解分布式锁的抢占过程">图解：分布式锁的抢占过程</h3> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/a8/7d/LKg5PRO0_o.png"></p> 
<p></p> 
<p>咱们就假设客户端A抢先一步，对zk发起了加分布式锁的请求，这个加锁请求是用到了zk中的一个特殊的概念，叫做“临时顺序节点”。</p> 
<p>简单来说，就是直接在"my_lock"这个锁节点下，创建一个顺序节点，这个顺序节点有zk内部自行维护的一个节点序号。</p> 
<h4 id="autoid-h2-3-0-0">客户端A发起一个加锁请求</h4> 
<p> 比如说，第一个客户端来搞一个顺序节点，zk内部会给起个名字叫做：xxx-000001。然后第二个客户端来搞一个顺序节点，zk可能会起个名字叫做：xxx-000002。大家注意一下，最后一个数字都是依次递增的，从1开始逐次递增。zk会维护这个顺序。</p> 
<p>所以这个时候，假如说客户端A先发起请求，就会搞出来一个顺序节点，大家看下面的图，Curator框架大概会弄成如下的样子：</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/3b/a6/jMSNvUht_o.png"></p> 
<p> 大家看，客户端A发起一个加锁请求，先会在你要加锁的node下搞一个临时顺序节点，这一大坨长长的名字都是Curator框架自己生成出来的。</p> 
<p>然后，那个最后一个数字是"1"。大家注意一下，因为客户端A是第一个发起请求的，所以给他搞出来的顺序节点的序号是"1"。</p> 
<p>接着客户端A创建完一个顺序节点。还没完，他会查一下"my_lock"这个锁节点下的所有子节点，并且这些子节点是按照序号排序的，这个时候他大概会拿到这么一个集合：</p> 
<p><img alt="img" src="https://images2.imgbox.com/1c/f5/6cVIWT5o_o.png"></p> 
<p> 接着客户端A会走一个关键性的判断，就是说：唉！兄弟，这个集合里，我创建的那个顺序节点，是不是排在第一个啊？</p> 
<p>如果是的话，那我就可以加锁了啊！因为明明我就是第一个来创建顺序节点的人，所以我就是第一个尝试加分布式锁的人啊！</p> 
<p>bingo！加锁成功！大家看下面的图，再来直观的感受一下整个过程。</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/3f/1f/nYhCV89g_o.png"></p> 
<h4 id="%C2%A0%E5%AE%A2%E6%88%B7%E7%AB%AFB%E8%BF%87%E6%9D%A5%E6%8E%92%E9%98%9F"> 客户端B过来排队</h4> 
<p>接着假如说，客户端A都加完锁了，客户端B过来想要加锁了，这个时候他会干一样的事儿：先是在"my_lock"这个锁节点下创建一个临时顺序节点，此时名字会变成类似于：</p> 
<p><img alt="img" src="https://images2.imgbox.com/c3/e1/8sbtgHwh_o.png"></p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/9d/f8/K9M6m4a3_o.png"> 客户端B因为是第二个来创建顺序节点的，所以zk内部会维护序号为"2"。</p> 
<p>接着客户端B会走加锁判断逻辑，查询"my_lock"锁节点下的所有子节点，按序号顺序排列，此时他看到的类似于：</p> 
<p> <img alt="img" src="https://images2.imgbox.com/af/66/yRRXJUcU_o.png"></p> 
<p>同时检查自己创建的顺序节点，是不是集合中的第一个？</p> 
<p>明显不是啊，此时第一个是客户端A创建的那个顺序节点，序号为"01"的那个。所以加锁失败！</p> 
<h4 id="%C2%A0%E5%AE%A2%E6%88%B7%E7%AB%AFB%E5%BC%80%E5%90%AF%E7%9B%91%E5%90%AC%E5%AE%A2%E6%88%B7%E7%AB%AFA"> 客户端B开启监听客户端A</h4> 
<p>加锁失败了以后，客户端B就会通过ZK的API对他的顺序节点的上一个顺序节点加一个监听器。zk天然就可以实现对某个节点的监听。</p> 
<p>如果大家还不知道zk的基本用法，可以百度查阅，非常的简单。客户端B的顺序节点是：</p> 
<p><img alt="img" src="https://images2.imgbox.com/94/1e/9rrzRXc0_o.png"></p> 
<p>他的上一个顺序节点，不就是下面这个吗？</p> 
<p><img alt="img" src="https://images2.imgbox.com/a3/16/Dv5iJt0M_o.png"></p> 
<p>即客户端A创建的那个顺序节点！</p> 
<p>所以，客户端B会对：</p> 
<p><img alt="img" src="https://images2.imgbox.com/85/33/voE8WNMB_o.png"></p> 
<p>这个节点加一个监听器，监听这个节点是否被删除等变化！大家看下面的图。</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/99/10/CaTz3Juu_o.png"></p> 
<p>接着，客户端A加锁之后，可能处理了一些代码逻辑，然后就会释放锁。那么，释放锁是个什么过程呢？</p> 
<p>其实很简单，就是把自己在zk里创建的那个顺序节点，也就是：</p> 
<p><img alt="img" src="https://images2.imgbox.com/53/f9/12bPBTpo_o.png"></p> 
<p>这个节点给删除。</p> 
<p>删除了那个节点之后，zk会负责通知监听这个节点的监听器，也就是客户端B之前加的那个监听器，说：兄弟，你监听的那个节点被删除了，有人释放了锁。</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/74/5d/ymBGd87a_o.png"></p> 
<p>此时客户端B的监听器感知到了上一个顺序节点被删除，也就是排在他之前的某个客户端释放了锁。</p> 
<h4 id="autoid-h2-6-0-0">客户端B抢锁成功</h4> 
<p>此时，就会通知客户端B重新尝试去获取锁，也就是获取"my_lock"节点下的子节点集合，此时为：</p> 
<p><img alt="img" src="https://images2.imgbox.com/2e/79/6Q9M38EG_o.png"></p> 
<p>集合里此时只有客户端B创建的唯一的一个顺序节点了！</p> 
<p>然后呢，客户端B判断自己居然是集合中的第一个顺序节点，bingo！可以加锁了！直接完成加锁，运行后续的业务代码即可，运行完了之后再次释放锁。</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/9e/e7/ydZZn8CT_o.png"></p> 
<h3 id="分布式锁的基本实现">分布式锁的基本思路</h3> 
<p>使用ZooKeeper实现分布式锁的算法，有以下几个要点：</p> 
<ol><li>一把分布式锁通常使用一个Znode节点表示；如果锁对应的Znode节点不存在，首先创建Znode节点。这里假设为“/test/lock”，代表了一把需要创建的分布式锁。</li><li>抢占锁的所有客户端，使用锁的Znode节点的子节点列表来表示；如果某个客户端需要占用锁，则在“/test/lock”下创建一个临时有序的子节点。这里，所有临时有序子节点，尽量共用一个有意义的子节点前缀。比如，如果子节点的前缀为“/test/lock/seq-”，则第一次抢锁对应的子节点为“/test/lock/seq-000000000”，第二次抢锁对应的子节点为“/test/lock/seq-000000001”，以此类推。再比如，如果子节点前缀为“/test/lock/”，则第一次抢锁对应的子节点为“/test/lock/000000000”，第二次抢锁对应的子节点为“/test/lock/000000001”，以此类推，也非常直观。</li><li>如果判定客户端是否占有锁呢？很简单，客户端创建子节点后，需要进行判断：自己创建的子节点，是否为当前子节点列表中序号最小的子节点。如果是，则认为加锁成功；如果不是，则监听前一个Znode子节点变更消息，等待前一个节点释放锁。</li><li>一旦队列中的后面的节点，获得前一个子节点变更通知，则开始进行判断，判断自己是否为当前子节点列表中序号最小的子节点，如果是，则认为加锁成功；如果不是，则持续监听，一直到获得锁。</li><li>获取锁后，开始处理业务流程。完成业务流程后，删除自己的对应的子节点，完成释放锁的工作，以方面后继节点能捕获到节点变更通知，获得分布式锁。</li></ol> 
<h4 id="curator%E4%BB%A3%E7%A0%81">curator代码</h4> 
<pre><code class="language-java">//读写锁
    @Test
    public void testGetReadLock() throws Exception{
        //读写锁
        InterProcessReadWriteLock interProcessReadWriteLock = new InterProcessReadWriteLock(client, "/lock1");
        // 获取读锁对象
        InterProcessLock interProcessLock = interProcessReadWriteLock.readLock();
        System.out.println("等待获取读锁对象");
        //获取锁
        interProcessLock.acquire();
        System.out.println("拿到了读锁");
        for(int i = 1;i&lt;=100;i++){
            Thread.sleep(3000);
            System.out.println(i);
        }
        interProcessLock.release();
        System.out.println("等待释放锁");
    }

    @Test
    public void testGetReadLock1() throws Exception{
        testGetReadLock();
    }

    @Test
    public void testGetWriteLock() throws Exception{
        //读写锁
        InterProcessReadWriteLock interProcessReadWriteLock = new InterProcessReadWriteLock(client, "/lock1");
        // 获取读锁对象
        InterProcessLock interProcessLock = interProcessReadWriteLock.writeLock();
        System.out.println("等待获取写锁对象");
        //获取锁
        interProcessLock.acquire();
        System.out.println("拿到了写锁");
        for(int i = 1;i&lt;=100;i++){
            Thread.sleep(3000);
            System.out.println(i);
        }
        interProcessLock.release();
        System.out.println("等待释放锁");
    }</code></pre> 
<p>如果已经有读锁了，可以在别的方法获取读锁，但如果有读锁了不能获取写锁，先运行</p> 
<pre>testGetReadLock方法，获取读锁成功，再运行testGetReadLock1方法获取读锁成功，运行testGetWriteLock方法一直等待获取写锁，将两个读锁的进程关掉，才能获取到写锁</pre> 
<p><img alt="" height="604" src="https://images2.imgbox.com/78/29/AaBAN3l0_o.png" width="1200"></p> 
<p><img alt="" height="652" src="https://images2.imgbox.com/9f/7e/LI3dXxMn_o.png" width="1200"></p> 
<p></p> 
<p> <img alt="" height="626" src="https://images2.imgbox.com/8c/0a/uj5B9Ddp_o.png" width="1200"></p> 
<p></p> 
<h4 id="%E5%AF%B9%E6%AF%94ZooKeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8Credis%E9%94%81%EF%BC%9A">对比ZooKeeper分布式锁和redis锁：</h4> 
<ol><li>优点：ZooKeeper分布式锁（如InterProcessMutex），能有效的解决分布式问题，不可重入问题，使用起来也较为简单。</li><li>缺点：ZooKeeper实现的分布式锁，性能并不太高。为啥呢？因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。大家知道，ZK中创建和删除节点只能通过Leader服务器来执行，然后Leader服务器还需要将数据同不到所有的Follower机器上，这样频繁的网络通信，性能的短板是非常突出的。</li></ol> 
<p>总之，<strong>在高性能，高并发的场景下，不建议使用ZooKeeper的分布式锁。而由于ZooKeeper的高可用特性，所以在并发量不是太高的场景，推荐使用ZooKeeper的分布式锁</strong>。</p> 
<p>在目前分布式锁实现方案中，比较成熟、主流的方案有两种：</p> 
<p>（1）基于Redis的分布式锁</p> 
<p>（2）基于ZooKeeper的分布式锁</p> 
<p>两种锁，分别适用的场景为：</p> 
<p>（1）基于ZooKeeper的分布式锁，适用于高可靠（高可用）而并发量不是太大的场景；</p> 
<p>（2）基于Redis的分布式锁，适用于并发量很大、性能要求很高的、而可靠性问题可以通过其他方案去弥补的场景。</p> 
<h2 id="ZK%E7%9A%84watch%E6%9C%BA%E5%88%B6">ZK的watch机制</h2> 
<p>Watcher 监听机制是 Zookeeper 中非常重要的特性，我们基于 zookeeper 上创建的节点，可以对这些节点绑定监听事件，比如可以监听节点数据变更、节点删除、子节点状态变更等事件，通过这个事件机制，可以基于 zookeeper实现分布式锁、集群管理等功能。</p> 
<p>　　watcher 特性：当数据发生变化的时候， zookeeper 会产生一个 watcher 事件，并且会发送到客户端。但是客户端只会收到一次通知。如果后续这个节点再次发生变化，那么之前设置 watcher 的客户端不会再次收到消息。（<span style="color:#fe2c24;"><strong>watcher 是一次性的操作</strong></span>）。 可以通过循环监听去达到永久监听效果。</p> 
<p>通过下面命令，在获取数据时监听节点，但监听一次后节点再有变化将无法收到通知，只能在收到触发后再次监听，才可以达到循环监听的效果，数据修改和删除节点的类型不一样</p> 
<blockquote> 
 <p>get -w /test1</p> 
</blockquote> 
<p><img alt="" height="538" src="https://images2.imgbox.com/55/9c/TjuGwkKn_o.png" width="1200"></p> 
<p>上图右边的图是修改节点，左边的图是监听，右边图尝试多次触发，单左边只收到了3次，在 一次监听回调后不再次监听就无法收到节点变化</p> 
<p>curator代码如下</p> 
<pre><code class="language-java">//  watch监听器
    @Test
    public void addNodeListener() throws Exception {
        NodeCache nodeCache = new NodeCache(client, "/curator-node");
        nodeCache.getListenable().addListener(new NodeCacheListener() {
            @Override
            public void nodeChanged() throws Exception {
                System.out.println("node has been changed:" + "/curator-node");
                byte[] bytes = client.getData().forPath("/curator-node");
                System.out.println("node has been changed:" + new String(bytes));
            }
        });

        nodeCache.start();
        System.in.read();
    }</code></pre> 
<p></p> 
<h2 id="ZK%E9%9B%86%E7%BE%A4">ZK集群</h2> 
<h3 id="ZK%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA">ZK集群搭建</h3> 
<h4 id="%E5%88%9B%E5%BB%BAmyid%E6%96%87%E4%BB%B6">创建myid文件</h4> 
<p>在zookeeper的目录下创建4个目录</p> 
<p><img alt="" height="262" src="https://images2.imgbox.com/20/ac/ixVBq41H_o.png" width="627"></p> 
<p>每个文件夹下创建一个myid文件，每个文件内容对应1个数字（应该有4个文件，内容分别是1,2,3,4不能重复）</p> 
<p> <img alt="" height="298" src="https://images2.imgbox.com/42/d6/S1iqTBtE_o.png" width="529"></p> 
<h4 id="%C2%A0%E4%BF%AE%E6%94%B9zoo.cfg%E6%96%87%E4%BB%B6"> 修改zoo.cfg文件</h4> 
<p>将zoo.cfg复制为zoo1.cfg，并修改为下面红色字体部分</p> 
<p>server.A=B：C：D：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。<br>  </p> 
<blockquote> 
 <p> # The number of milliseconds of each tick<br> tickTime=2000<br> # The number of ticks that the initial <br> # synchronization phase can take<br> initLimit=10<br> # The number of ticks that can pass between <br> # sending a request and getting an acknowledgement<br> syncLimit=5<br> # the directory where the snapshot is stored.<br> # do not use /tmp for storage, /tmp here is just <br> # example sakes.<br><span style="color:#fe2c24;">dataDir=F:/workspace/arch/ZK/zkdata/zk1</span>     <br> # the port at which the clients will connect <span style="color:#fe2c24;">给客户端连接用的端口，每个集群的服务节点应该不一样</span><br><span style="color:#fe2c24;">clientPort=2182</span><br> # the maximum number of client connections.<br> # increase this if you need to handle more clients<br> #maxClientCnxns=60<br> #<br> # Be sure to read the maintenance section of the <br> # administrator guide before turning on autopurge.<br> #<br> # http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance<br> #<br> # The number of snapshots to retain in dataDir<br> #autopurge.snapRetainCount=3<br> # Purge task interval in hours<br> # Set to "0" to disable auto purge feature<br> #autopurge.purgeInterval=1</p> 
 <p>## Metrics Providers<br> #<br> # https://prometheus.io Metrics Exporter<br> #metricsProvider.className=org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider<br> #metricsProvider.httpPort=7000<br> #metricsProvider.exportJvmInfo=true</p> 
 <p><span style="color:#fe2c24;">#集群配置信息，数字要和上面的myid一致，2001那一列的端口是节点同步数据用的（主服务节点向从服务节点同步数据），3001那一列的端口用于选举leader</span></p> 
 <p><span style="color:#fe2c24;">server.1=127.0.0.1:2001:3001<br> server.2=127.0.0.1:2002:3002<br> server.3=127.0.0.1:2003:3003<br> server.4=127.0.0.1:2004:3004:observer</span></p> 
</blockquote> 
<p>按照上面的再复制和修改3个配置文件</p> 
<p><img alt="" height="310" src="https://images2.imgbox.com/4f/90/OsObeP9I_o.png" width="1200"></p> 
<h4 id="%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1">启动服务</h4> 
<p>windows复制zkServer.cmd的文件，复制成4个开始命令文件，新增：set ZOOCFG=../conf/zoo1.cfg，每个命令文件对应一个配置，然后分别启动</p> 
<p>cmd下启动多个zkServer都启动，四个zkServer没全启动的时候会报错误，这是zookeeper的Leader选举算法的异常信息，当节点没有启动完毕的时候，Leader无法正常进行工作，这种错误信息是可以忽略的，等其他节点启动之后就正常了。<br>  </p> 
<p><img alt="" height="557" src="https://images2.imgbox.com/3d/b1/c69A73IJ_o.png" width="319"></p> 
<p><img alt="" height="294" src="https://images2.imgbox.com/94/51/2YZpyEkK_o.png" width="1006"></p> 
<p>  <img alt="" height="1145" src="https://images2.imgbox.com/c7/b0/qcn4IHl6_o.png" width="1200"></p> 
<p></p> 
<p>linux用命令：./zkServer.sh start  ../conf/zoo1.cfg后台启动（windows可以通过bash启动）</p> 
<p>用命令：./zkServer.sh status  ../conf/zoo1.cfg 看下状态，可以看到，1主2从1个observer</p> 
<p><img alt="" height="790" src="https://images2.imgbox.com/59/a3/N2clxqkJ_o.png" width="1200"></p> 
<h4 id="%C2%A0%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5"> 客户端连接</h4> 
<p>windows兄弟要么写代码连接吧，没找到cli.cmd的修改方法，脚本使用的是默认2181端口，如果在bash中用sh的方式连接服务端，客户端能启动成功，但无法执行命令，会卡死</p> 
<p><img alt="" height="447" src="https://images2.imgbox.com/ad/18/ezj9HEZY_o.png" width="747"></p> 
<p></p> 
<p>linux的命令：</p> 
<p>./zkcli.sh -server localhost:2182,localhost:2183,localhost:2184,localhost:2185</p> 
<p>将集群服务器IP和端口都写上，这样在服务端一个机器挂了的话客户端会尝试连接另外一台</p> 
<p>客户端代码连接集群服务器和测试代码如下：</p> 
<pre><code class="language-java">import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.recipes.cache.NodeCache;
import org.apache.curator.framework.recipes.cache.NodeCacheListener;
import org.apache.curator.framework.recipes.locks.InterProcessLock;
import org.apache.curator.framework.recipes.locks.InterProcessReadWriteLock;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.CreateMode;
import org.junit.Before;
import org.junit.Test;

import java.nio.charset.StandardCharsets;
import java.util.Scanner;

public class ZKClusterClientCuratorTest {
    CuratorFramework client;

    public void init() {
        System.out.println("call init function");
        // 重试策略：重试之间等待的初始时间，最大的重试次数
        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);
        // 通过工厂建造出连接实例：client
        CuratorFramework curatorFramework = CuratorFrameworkFactory.builder()
                .connectString("localhost:2182,localhost:2183,localhost:2184,localhost:2185")
                .sessionTimeoutMs(5000)  // 会话超时时间
                .connectionTimeoutMs(5000) // 连接超时时间
                .retryPolicy(retryPolicy)
                .build();
        client = curatorFramework;
        // 客户端必须开始
        curatorFramework.start();
    }

    public void test() {
        while (true) {
            try {
                System.out.println("输入命令：");
                Scanner input = new Scanner(System.in);
                String str = input.nextLine();
                System.out.println("输入命令：" + str);
                String command = null;
                if (str.startsWith("create")) {
                    command = str.substring("create".length()).trim();
                    System.out.println("创建命令：" + command);
                    client.create().creatingParentContainersIfNeeded()
                            .withMode(CreateMode.PERSISTENT_SEQUENTIAL)
                            .forPath(command);
                } else if (str.startsWith("ls")) {
                    command = str.substring("ls".length()).trim();
                    System.out.println("ls命令：" + command);
                    System.out.println(client.getChildren().forPath(command));
                }
            } catch (Exception e) {
                System.out.println("报错了，" + e);
            }

        }
    }

    public static void main(String[] args) {
        ZKClusterClientCuratorTest zk = new ZKClusterClientCuratorTest();
        zk.init();
        zk.test();
    }

}
</code></pre> 
<p><img alt="" height="1087" src="https://images2.imgbox.com/66/7b/ZRxwv3wm_o.png" width="1200"></p> 
<p> 干掉了leader，客户端可以自动重新连接，正常查询节点信息</p> 
<p><img alt="" height="599" src="https://images2.imgbox.com/4f/55/GnydvpQe_o.png" width="850"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/f3/26/D8ZDiZVS_o.png" width="1200"></p> 
<p></p> 
<h3 id="ZK%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86">ZK集群原理</h3> 
<h4 id="ZK%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8A%82%E7%82%B9%EF%BC%88%E9%9D%9Eznode%EF%BC%89%E5%88%86%E4%B8%BA3%E7%A7%8D%E8%A7%92%E8%89%B2%EF%BC%9A">ZK服务器节点（非znode）分为3种角色：</h4> 
<ul><li>leader：处理集群的所有事务请求，集群中只有一个leader</li><li>follow：只能处理读请求，参与leader选举</li><li>observer：只能处理读请求，提升集群读性能，但不参与leader选举</li></ul> 
<p><img alt="" height="334" src="https://images2.imgbox.com/c5/56/WDSpb2a5_o.png" width="795"></p> 
<p></p> 
<h4 id="ZBA%E5%8D%8F%E8%AE%AE">ZBA协议</h4> 
<p>ZAB 协议全称：Zookeeper Atomic Broadcast（Zookeeper 原子广播协议），Zookeeper 是一个为分布式应用提供高效且可靠的分布式协调服务，<span style="color:#fe2c24;"><strong>ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持保证数据一致性的协议，主要解决了 <code>崩溃恢复</code> 和主从数据同步的问题</strong></span></p> 
<p><strong>Zab 节点有三种状态</strong>：</p> 
<ul><li>Following：当前节点是跟随者，服从 Leader 节点的命令。</li><li>Leading：当前节点是 Leader，负责协调事务。</li><li>Election/Looking：节点处于选举状态，正在寻找 Leader。</li><li>Observing：观察者节点所在的状态</li></ul> 
<p>流程：</p> 
<p>Zookeeper 客户端会随机的链接到 zookeeper 集群中的一个节点，如果是读请求，就直接从当前节点中读取数据；如果是写请求，那么节点就会向 Leader 提交事务，Leader 接收到事务提交，会广播该事务，只要超过半数节点写入成功，该事务就会被提交。</p> 
<p><img alt="" src="https://images2.imgbox.com/ac/ce/2i4StwsQ_o.png"></p> 
<ol><li>客户端发起一个<span style="color:#fe2c24;">写操作请求</span>。</li><li>Leader 服务器将客户端的请求转化为事务 Proposal 提案，同时为每个 Proposal 分配一个全局的ID，即zxid，写入leader的数据文件中，并给自己返回一个ack。</li><li>Leader 服务器为每个 Follower 服务器分配一个单独的队列，然后将需要广播的 Proposal 依次放到队列中取，并且根据 FIFO 策略进行消息发送。</li><li>Follower 接收到 Proposal 后，会首先将其以事务日志的方式写入本地磁盘中（此时没有加载到follower的内存中，如果客户端来查询，是无法查到数据的）</li><li>写入成功后向 Leader 反馈一个 Ack 响应消息。</li><li>Leader 接收到超过半数以上 Follower 的 Ack 响应消息后（此处的半数算leader，比如1主2从，如果leader和一个follower成功后就认为成功，如果不算leader就需要两个follower都成功后才可以发送commit），即认为消息发送成功，可以发送 commit 消息。</li><li>Leader 向所有 Follower 广播 commit 消息，同时自身也会完成事务提交。Follower 接收到 commit 消息后，会将上一条事务提交，从数据文件加载到内存中，此时客户端可以在follower中查到数据。</li></ol> 
<p><strong>zookeeper 采用 Zab 协议的核心，就是只要有一台服务器提交了 Proposal，就要确保所有的服务器最终都能正确提交 Proposal。这也是 CAP/BASE 实现最终一致性的一个体现。</strong></p> 
<p><strong>Leader 服务器与每一个 Follower 服务器之间都维护了一个单独的 FIFO 消息队列进行收发消息，使用队列消息可以做到异步解耦。 Leader 和 Follower 之间只需要往队列中发消息即可。如果使用同步的方式会引起阻塞，性能要下降很多。</strong></p> 
<p></p> 
<p> <img alt="" src="https://images2.imgbox.com/68/4c/sqD6m34u_o.png"></p> 
<p><img alt="" height="521" src="https://images2.imgbox.com/60/68/MRCD80aB_o.png" width="1117"><img alt="" src="https://images2.imgbox.com/5c/fe/Y4Vtg0v1_o.png"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h3 id="%E9%80%89%E4%B8%BEleader%E8%BF%87%E7%A8%8B%EF%BC%9A">选举leader过程：</h3> 
<h4 id="%E9%80%89%E7%A5%A8%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%EF%BC%9A">选票数据格式：</h4> 
<p><strong>服务器ID（myid）：</strong>比如有三台服务器，编号分别是1,2,3。编号越大在选择算法中的权重越大。</p> 
<p><strong>数据ID(zxid)</strong>：服务器中存放的最大数据ID，只要在ZK中做了节点的增删改（没有查），事务ID就会增加。值越大说明数据越新，在选举算法中数据越新权重越大。zxid是一个64位的数字。其中低32位可以看成一个简单的单增计数器，针对客户端每一个事务请求，Leader 在产生新的 Proposal 事务时，都会对该计数器加1。而高32位则代表了 Leader 周期的 epoch 编号。</p> 
<blockquote> 
 <p>epoch 编号可以理解为当前集群所处的年代，或者周期。每次Leader变更之后都会在 epoch 的基础上加1，这样旧的 Leader 崩溃恢复之后，其他Follower 也不会听它的了，因为 Follower 只服从epoch最高的 Leader 命令。</p> 
</blockquote> 
<p>每当选举产生一个新的 Leader ，就会从这个 Leader 服务器上取出本地事务日志充最大编号 Proposal 的 zxid，并从 zxid 中解析得到对应的 epoch 编号，然后再对其加1，之后该编号就作为新的 epoch 值，并将低32位数字归零，由0开始重新生成zxid。</p> 
<p><strong>Zab 协议通过 epoch 编号来区分 Leader 变化周期</strong>，能够有效避免不同的 Leader 错误的使用了相同的 zxid 编号提出了不一样的 Proposal 的异常情况。</p> 
<p></p> 
<h4 id="%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B%EF%BC%9A">选举流程简介：</h4> 
<p>目前有5台服务器，每台服务器均没有数据，它们的编号分别是1,2,3,4,5,按编号依次启动，它们的选择举过程如下：</p> 
<ul><li>服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于Looking。</li><li>服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大所以服务器2胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是LOOKING，进行了下图的第二轮投票。</li><li>服务器3启动，给自己投票，同时与之前启动的服务器1,2交换信息，由于服务器3的编号最大所以服务器3胜出，此时投票数正好大于半数，所以服务器3成为领导者，服务器1,2成为小弟。</li><li>服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但之前服务器3已经胜出，所以服务器4只能成为小弟。</li><li>服务器5启动，后面的逻辑同服务器4成为小弟。</li></ul> 
<p><span style="color:#fe2c24;">最终Leader是服务器3，状态为LEADING；其余服务器是Follower，状态为FOLLOWING。</span></p> 
<p><img alt="" height="671" src="https://images2.imgbox.com/5f/13/lSkbjJV7_o.png" width="987"></p> 
<p> 每个节点的选举流程图</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6e/8d/dn9T4vVE_o.png"></p> 
<p></p> 
<h4 id="%C2%A0%E9%80%89%E4%B8%BE%E8%A7%84%E5%88%99%EF%BC%9A"> 选举规则：</h4> 
<ul><li><strong>选举原则</strong>：<strong>比较每个节点的(zxid,myid),在当选节点的票数&gt;总节点数/2</strong>（该原则可以避免zk集群的脑裂问题），zxid大者当选，若zxid相同再比较myid，myid大者当选；若当前已发生投票节点数未过半，则继续等待投票</li><li>zk保证CAP中的CP，不保证可用性（A）：<span style="color:#fe2c24;">因为在zk集群选举过程中不对外提供服务</span></li><li>zk可以保证数据不丢失：因为在选举过程中zxid较大的节点会当选leader，zxid越大代表数据越新（但这种保证是不严格的：启动阶段zxid相同，但运行阶段zxid相对较大的位于中间的节点会当选，zxid最大但位于最后的节点反而不当选)</li><li>选举需满足【当选节点的票数&gt;总节点数/2】，故这种情况选举不出leader：整个集群中过半的节点挂掉了，此时永远不满足【当选节点的票数&gt;总节点数/2】</li><li>集群总节点数一般设为基数【2N+1】，目的有两个： 
  <ul><li>出于成本考虑。当集群有5个节点时，最多挂掉2个节点，此时剩下3台，最大的当选节点票数为3&gt;总节点数/2=5/2=2.5；当集群有6个节点，最多挂掉2个节点，此时剩下4台，最大当选票数为4&gt;总节点数/2=6/2=3。所以5个节点和6个节点服务器的容错数都是一样的，但明显5台服务器成本更少。</li><li>防止脑裂。脑裂=一个集群由于网络故障分为两个集群，这两个集群又各自选选举出了自己的主节点，这样就有两个主节点了，原本只有一个主节点现在有了两个，类似于大脑裂开了两半；当考虑过半机制时，不管节点裂开成多少个集群，每个集群都需要超过总节点数的一半才能选主成功，这样自始至终都只有一个裂开后形成的集群能正常选主，其他裂开后形成的集群不能选主而不能正常工作</li></ul></li></ul> 
<h4 id="%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%A3%80%E6%B5%8B%E4%B8%BB%E8%8A%82%E7%82%B9%E5%AE%95%E6%9C%BA">运行过程中检测主节点宕机</h4> 
<p><img alt="" height="455" src="https://images2.imgbox.com/58/f3/dr2f80qM_o.png" width="984"></p> 
<ol><li>在运行过程中，leader会发socket连接到从节点，格式是ping的空数据，从节点周期获取ping信息</li><li>在leader挂了，socket的连接断开，从节点无法获取ping数据，报错</li><li>从节点从following状态编程looking状态，重新开始进行选举</li><li>在从节点选出leader后，原有的leader即便重新上线也只能做从节点，根据 zxid的epoch 编号机制达到目的</li></ol> 
<h4 id="%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90">选举流程代码解析</h4> 
<p><strong>QuorumPeer</strong></p> 
<p>主要看这个类，只有LOOKING状态才会去执行选举算法。每个服务器在启动时都会选择自己做为领导，然后将投票信息发送出去，循环一直到选举出领导为止</p> 
<pre><code class="language-java">public void run() {
        //.......

        try {
            while (running) {
                switch (getPeerState()) {
                case LOOKING:
                    if (Boolean.getBoolean("readonlymode.enabled")) {
                        //...
                        try {
                           //投票给自己...
                            setCurrentVote(makeLEStrategy().lookForLeader());
                        } catch (Exception e) {
                            //...
                        } finally {
                            //...
                        }
                    } else {
                        try {
                           //...
                            setCurrentVote(makeLEStrategy().lookForLeader());
                        } catch (Exception e) {
                            //...
                        }                        
                    }
                    break;
                case OBSERVING:
                    //...
                    break;
                case FOLLOWING:
                    //...
                    break;
                case LEADING:
                    //...
                    break;
                }
                
            }
        } finally {
            //...
        }
    }</code></pre> 
<p><strong>FastLeaderElection</strong></p> 
<p>它是zookeeper默认提供的选举算法，核心方法如下：具体的可以与本文上面的流程图对照。</p> 
<pre><code class="language-java">public Vote lookForLeader() throws InterruptedException {
        //...
        try {
            HashMap&lt;Long, Vote&gt; recvset = new HashMap&lt;Long, Vote&gt;();

            HashMap&lt;Long, Vote&gt; outofelection = new HashMap&lt;Long, Vote&gt;();

            int notTimeout = finalizeWait;

            synchronized(this){
                //给自己投票
                logicalclock.incrementAndGet();
                updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());
            }

            //将投票信息发送给集群中的每个服务器
            sendNotifications();

            //循环，如果是竞选状态一直到选举出结果

            while ((self.getPeerState() == ServerState.LOOKING) &amp;&amp;
                    (!stop)){
            
                Notification n = recvqueue.poll(notTimeout,
                        TimeUnit.MILLISECONDS);

                //没有收到投票信息
                if(n == null){
                    if(manager.haveDelivered()){
                        sendNotifications();
                    } else {
                        manager.connectAll();
                    }

                    //...
                } 
                //收到投票信息
                else if (self.getCurrentAndNextConfigVoters().contains(n.sid)) {
                    
                    switch (n.state) {
                    case LOOKING:
                       
                        // 判断投票是否过时，如果过时就清除之前已经接收到的信息                      
                        if (n.electionEpoch &gt; logicalclock.get()) {
                            logicalclock.set(n.electionEpoch);
                            recvset.clear();
                            //更新投票信息
                            if(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,
                                    getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) {
                                updateProposal(n.leader, n.zxid, n.peerEpoch);
                            } else {
                                updateProposal(getInitId(),
                                        getInitLastLoggedZxid(),
                                        getPeerEpoch());
                            }
                            //发送投票信息
                            sendNotifications();
                        } else if (n.electionEpoch &lt; logicalclock.get()) {
                            //忽略
                            break;
                        } else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,
                                proposedLeader, proposedZxid, proposedEpoch)) {
                            //更新投票信息
                            updateProposal(n.leader, n.zxid, n.peerEpoch);
                            sendNotifications();
                        }                     

                        recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));
                        //判断是否投票结束
                        if (termPredicate(recvset,
                                new Vote(proposedLeader, proposedZxid,
                                        logicalclock.get(), proposedEpoch))) {

                            // Verify if there is any change in the proposed leader
                            while((n = recvqueue.poll(finalizeWait,
                                    TimeUnit.MILLISECONDS)) != null){
                                if(totalOrderPredicate(n.leader, n.zxid, n.peerEpoch,
                                        proposedLeader, proposedZxid, proposedEpoch)){
                                    recvqueue.put(n);
                                    break;
                                }
                            }

                          
                            if (n == null) {
                                self.setPeerState((proposedLeader == self.getId()) ?
                                        ServerState.LEADING: learningState());

                                Vote endVote = new Vote(proposedLeader,
                                        proposedZxid, proposedEpoch);
                                leaveInstance(endVote);
                                return endVote;
                            }
                        }
                        break;
                    case OBSERVING:
                        //忽略
                        break;
                    case FOLLOWING:
                    case LEADING:
                        //如果是同一轮投票
                        if(n.electionEpoch == logicalclock.get()){
                            recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));
                            //判断是否投票结束
                            if(termPredicate(recvset, new Vote(n.leader,
                                            n.zxid, n.electionEpoch, n.peerEpoch, n.state))
                                            &amp;&amp; checkLeader(outofelection, n.leader, n.electionEpoch)) {
                                self.setPeerState((n.leader == self.getId()) ?
                                        ServerState.LEADING: learningState());

                                Vote endVote = new Vote(n.leader, n.zxid, n.peerEpoch);
                                leaveInstance(endVote);
                                return endVote;
                            }
                        }

                        //记录投票已经完成
                        outofelection.put(n.sid, new Vote(n.leader, 
                                IGNOREVALUE, IGNOREVALUE, n.peerEpoch, n.state));
                        if (termPredicate(outofelection, new Vote(n.leader,
                                IGNOREVALUE, IGNOREVALUE, n.peerEpoch, n.state))
                                &amp;&amp; checkLeader(outofelection, n.leader, IGNOREVALUE)) {
                            synchronized(this){
                                logicalclock.set(n.electionEpoch);
                                self.setPeerState((n.leader == self.getId()) ?
                                        ServerState.LEADING: learningState());
                            }
                            Vote endVote = new Vote(n.leader, n.zxid, n.peerEpoch);
                            leaveInstance(endVote);
                            return endVote;
                        }
                        break;
                    default:
                        //忽略
                        break;
                    }
                } else {
                    LOG.warn("Ignoring notification from non-cluster member " + n.sid);
                }
            }
            return null;
        } finally {
            //...
        }
    }</code></pre> 
<h3 id="ZK%E4%B8%ADNIO%E5%92%8CBIO%E5%BA%94%E7%94%A8%EF%BC%9A">ZK中NIO和BIO应用：</h3> 
<p><strong>NIO</strong>：</p> 
<ul><li>用于被客户端连接的2181端口，使用的NIO模式与客户端建立连接</li><li>客户端开启watch时，使用NIO等待ZK的服务器回调</li></ul> 
<p><strong>BIO</strong></p> 
<ul><li>集群在选举时，多个节点之间的投票通信端口，使用BIO进行通讯</li></ul> 
<p></p> 
<p>参考文章：</p> 
<p> <a href="https://www.bilibili.com/video/BV1Ph411n7Ep?p=10&amp;share_source=copy_web" rel="nofollow" title="千锋最新Zookeeper集群教程-全网最全Zookeeper应用及原理分析课程_哔哩哔哩_bilibili">千锋最新Zookeeper集群教程-全网最全Zookeeper应用及原理分析课程_哔哩哔哩_bilibili</a></p> 
<p><a href="https://blog.csdn.net/varyall/article/details/79564418" title="ZooKeeper 技术内幕：数据的存储(持久化机制)_varyall的专栏-CSDN博客_zookeeper持久化">ZooKeeper 技术内幕：数据的存储(持久化机制)_varyall的专栏-CSDN博客_zookeeper持久化</a></p> 
<p><a href="https://www.cnblogs.com/crazymakercircle/p/14504520.html" rel="nofollow" title="Zookeeper 分布式锁 （图解+秒懂+史上最全） - 疯狂创客圈 - 博客园">Zookeeper 分布式锁 （图解+秒懂+史上最全） - 疯狂创客圈 - 博客园</a></p> 
<p><a href="https://blog.csdn.net/ypp91zr/article/details/89409707" title="Zookeeper leader选举机制_程序员-CSDN博客_zookeeper选举机制">Zookeeper leader选举机制_程序员-CSDN博客_zookeeper选举机制</a></p> 
<p><a href="https://blog.csdn.net/liuchang19950703/article/details/111406622" title="Zab协议详解_脑壳疼-CSDN博客_zab协议">Zab协议详解_脑壳疼-CSDN博客_zab协议</a></p> 
<p><a href="https://www.cnblogs.com/ASPNET2008/p/6421571.html" rel="nofollow" title="理解zookeeper选举机制 - min.jiang - 博客园">理解zookeeper选举机制 - min.jiang - 博客园</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/10f3aed3e9a59aa700d51fde5cb2704a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">总结 | 六大路径规划算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8be90f6f083092353125cab2d080b3cc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【python&#43;ROS&#43;路径规划】五、pyomo非线性规划工具</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>