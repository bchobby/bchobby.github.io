<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>kafaka在ELK日志集群中的应用 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="kafaka在ELK日志集群中的应用" />
<meta property="og:description" content="目录
一、消息队列 （message queue）
1、消息队列是什么
2、消息队列的优点
3、消息队列的模式
4、常用消息队列比较
二、kafka
1、kafka介绍
2、备份
3、基本概念
三、部署zookeeper集群
1、zookeeper介绍
2、zookeeper集群的部署
3、关于zookeeper集群的说明
四、 kafka集群的搭建
五、eflk数据流
appserver --&gt;filebeat --&gt; kafka --&gt; logstash --&gt; elasticsearch --&gt; kibana
filebeat配置
logstash[消费者]配置
一、消息队列 （message queue） 1、消息队列是什么 1.消息队列是进程间通信或同一进程间不同线程的通信方式。
2.消息队列提供了异步通信协议。
3.消息的发送者和接收者不需要同时与消息队列交互，消息会保存在队列中, 直到接收者取回它。
4.每一个贮列中的纪录包含详细说明的数据, 包含发生的时间, 输入设备的种类, 以及特定的输入参数。
5.消息队列中间件是分布式系统中重要的组件。
消息队列主要解决应用耦合、异步处理、流量削锋等问题 当前使用较多的消息队列有RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMq等, 而部分数据库如Redis、Mysql以及phxsql也可实现消息队列的功能。
2、消息队列的优点 解耦：在项目启动之初来预测将来项目会碰到什么需求, 是极其困难的消息系统在处理过程中间插入了一个隐含的、基于数据的接口层, 两边的处理过程都要实现这一接口这允许你独立的扩展或修改两边的处理过程, 只要确保它们遵守同样的接口约束
冗余：有些情况下, 处理数据的过程会失败除非数据被持久化, 否则将造成丢失消息队列把数据进行持久化直到它们已经被完全处理, 通过这一方式规避了数据丢失风险许多消息队列在把一个消息从队列中删除之前, 需要你的处理系统明确的指出该消息已经被处理完毕, 从而确保数据被安全的保存直到你使用完毕
扩展性：因为消息队列解耦了你的处理过程, 所以增大消息入队和处理的频率是很容易的, 只要另外增加处理过程即可不需要改变代码、不需要调节参数，扩展就像调大电力按钮一样简单
峰值处理：在访问量剧增的情况下, 应用仍然需要继续发挥作用, 但是这样的突发流量并不常见,如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费使用消息队列能够使关键组件顶住突发的访问压力, 而不会因为突发的超负荷的请求而完全崩溃
可恢复性：系统的一部分组件失效时, 不会影响到整个系统即使一个处理消息的进程挂掉, 加入队列中的消息仍然可以在系统恢复后被处理
顺序保证：在大多使用场景下, 数据处理的顺序都很重要大部分消息队列本来就是排序的, 并且能保证数据会按照特定的顺序来处理如Kafka能保证一个Partition内的消息的有序性" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/dd53deca59a69153d7eee4fe92366326/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-28T00:09:59+08:00" />
<meta property="article:modified_time" content="2023-06-28T00:09:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">kafaka在ELK日志集群中的应用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:40px;"></p> 
<p id="%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20%EF%BC%88message%20queue%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20%EF%BC%88message%20queue%EF%BC%89" rel="nofollow">一、消息队列 （message queue）</a></p> 
<p id="1%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%98%AF%E4%BB%80%E4%B9%88-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">1、消息队列是什么</a></p> 
<p id="2%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BC%98%E7%82%B9-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BC%98%E7%82%B9" rel="nofollow">2、消息队列的优点</a></p> 
<p id="3%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%A8%A1%E5%BC%8F" rel="nofollow">3、消息队列的模式</a></p> 
<p id="4%E3%80%81%E5%B8%B8%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%AF%94%E8%BE%83-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E5%B8%B8%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%AF%94%E8%BE%83" rel="nofollow">4、常用消息队列比较</a></p> 
<p id="%E4%BA%8C%E3%80%81kafka-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81kafka" rel="nofollow">二、kafka</a></p> 
<p id="1%E3%80%81kafka%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#1%E3%80%81kafka%E4%BB%8B%E7%BB%8D" rel="nofollow">1、kafka介绍</a></p> 
<p id="%C2%A02%E3%80%81%E5%A4%87%E4%BB%BD-toc" style="margin-left:80px;"><a href="#%C2%A02%E3%80%81%E5%A4%87%E4%BB%BD" rel="nofollow"> 2、备份</a></p> 
<p id="3%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">3、基本概念</a></p> 
<p id="%E4%B8%89%E3%80%81%E9%83%A8%E7%BD%B2zookeeper%E9%9B%86%E7%BE%A4-toc" style="margin-left:80px;"><a href="#%E4%B8%89%E3%80%81%E9%83%A8%E7%BD%B2zookeeper%E9%9B%86%E7%BE%A4" rel="nofollow">三、部署zookeeper集群</a></p> 
<p id="1%E3%80%81zookeeper%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#1%E3%80%81zookeeper%E4%BB%8B%E7%BB%8D" rel="nofollow">1、zookeeper介绍</a></p> 
<p id="2%E3%80%81zookeeper%E9%9B%86%E7%BE%A4%E7%9A%84%E9%83%A8%E7%BD%B2-toc" style="margin-left:80px;"><a href="#2%E3%80%81zookeeper%E9%9B%86%E7%BE%A4%E7%9A%84%E9%83%A8%E7%BD%B2" rel="nofollow">2、zookeeper集群的部署</a></p> 
<p id="3%E3%80%81%E5%85%B3%E4%BA%8Ezookeeper%E9%9B%86%E7%BE%A4%E7%9A%84%E8%AF%B4%E6%98%8E-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%85%B3%E4%BA%8Ezookeeper%E9%9B%86%E7%BE%A4%E7%9A%84%E8%AF%B4%E6%98%8E" rel="nofollow">3、关于zookeeper集群的说明</a></p> 
<p id="%E5%9B%9B%E3%80%81%20kafka%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%E3%80%81%20kafka%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA" rel="nofollow">四、 kafka集群的搭建</a></p> 
<p id="%E4%BA%94%E3%80%81eflk%E6%95%B0%E6%8D%AE%E6%B5%81-toc" style="margin-left:40px;"><a href="#%E4%BA%94%E3%80%81eflk%E6%95%B0%E6%8D%AE%E6%B5%81" rel="nofollow">五、eflk数据流</a></p> 
<p id="appserver%20--%3Efilebeat%20--%3E%20kafka%20--%3E%20logstash%20--%3E%20elasticsearch%20--%3E%20kibana-toc" style="margin-left:80px;"><a href="#appserver%20--%3Efilebeat%20--%3E%20kafka%20--%3E%20logstash%20--%3E%20elasticsearch%20--%3E%20kibana" rel="nofollow">appserver --&gt;filebeat --&gt; kafka --&gt; logstash --&gt; elasticsearch --&gt; kibana</a></p> 
<p id="filebeat%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#filebeat%E9%85%8D%E7%BD%AE" rel="nofollow">filebeat配置</a></p> 
<p id="logstash%5B%E6%B6%88%E8%B4%B9%E8%80%85%5D%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#logstash%5B%E6%B6%88%E8%B4%B9%E8%80%85%5D%E9%85%8D%E7%BD%AE" rel="nofollow">logstash[消费者]配置</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20%EF%BC%88message%20queue%EF%BC%89">一、消息队列 （message queue）</h3> 
<h4 id="1%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%98%AF%E4%BB%80%E4%B9%88">1、消息队列是什么</h4> 
<blockquote> 
 <p>1.消息队列是进程间通信或同一进程间不同线程的通信方式。</p> 
 <p>2.消息队列提供了异步通信协议。</p> 
 <p>3.消息的发送者和接收者不需要同时与消息队列交互，消息会保存在队列中, 直到接收者取回它。</p> 
 <p>4.每一个贮列中的纪录包含详细说明的数据, 包含发生的时间, 输入设备的种类, 以及特定的输入参数。</p> 
 <p>5.消息队列中间件是分布式系统中重要的组件。</p> 
</blockquote> 
<p><strong>消息队列主要解决应用耦合、异步处理、流量削锋等问题 </strong></p> 
<p><strong>当前使用较多的消息队列有RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMq等, 而部分数据库如Redis、Mysql以及phxsql也可实现消息队列的功能。</strong></p> 
<h4 id="2%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BC%98%E7%82%B9">2、消息队列的优点</h4> 
<blockquote> 
 <p><strong><span style="color:#fe2c24;">解耦：</span></strong>在项目启动之初来预测将来项目会碰到什么需求, 是极其困难的消息系统在处理过程中间插入了一个隐含的、基于数据的接口层, 两边的处理过程都要实现这一接口这允许你独立的扩展或修改两边的处理过程, 只要确保它们遵守同样的接口约束</p> 
 <hr> 
 <p><span style="color:#fe2c24;"><strong>冗余：</strong></span>有些情况下, 处理数据的过程会失败除非数据被持久化, 否则将造成丢失消息队列把数据进行持久化直到它们已经被完全处理, 通过这一方式规避了数据丢失风险许多消息队列在把一个消息从队列中删除之前, 需要你的处理系统明确的指出该消息已经被处理完毕, 从而确保数据被安全的保存直到你使用完毕</p> 
 <hr> 
 <p><span style="color:#fe2c24;"><strong>扩展性</strong>：</span>因为消息队列解耦了你的处理过程, 所以增大消息入队和处理的频率是很容易的, 只要另外增加处理过程即可不需要改变代码、不需要调节参数，扩展就像调大电力按钮一样简单</p> 
 <hr> 
 <p><span style="color:#fe2c24;"><strong>峰值处理</strong>：</span>在访问量剧增的情况下, 应用仍然需要继续发挥作用, 但是这样的突发流量并不常见,如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费使用消息队列能够使关键组件顶住突发的访问压力, 而不会因为突发的超负荷的请求而完全崩溃</p> 
 <hr> 
 <p><span style="color:#fe2c24;"><strong>可恢复性</strong>：</span>系统的一部分组件失效时, 不会影响到整个系统即使一个处理消息的进程挂掉, 加入队列中的消息仍然可以在系统恢复后被处理</p> 
 <hr> 
 <p><span style="color:#fe2c24;"><strong>顺序保证</strong>：</span>在大多使用场景下, 数据处理的顺序都很重要大部分消息队列本来就是排序的, 并且能保证数据会按照特定的顺序来处理如Kafka能保证一个Partition内的消息的有序性</p> 
 <hr> 
 <p><span style="color:#fe2c24;"><strong>缓冲</strong>：</span>在任何重要的系统中, 都会有需要不同的处理时间的元素例如, 加载一张图片比应用过滤器花费更少的时间消息队列通过一个缓冲层来帮助任务最高效率的执行———写入队列的处理会尽可能的快速该缓冲有助于控制和优化数据流经过系统的速度</p> 
 <hr> 
 <p><span style="color:#fe2c24;"><strong>异步通信</strong>：</span>很多时候, 用户不想也不需要立即处理消息消息队列提供了异步处理机制, 允许用户把一个消息放入队列, 但并不立即处理它想向队列中放入多少消息就放多少, 然后在需要的时候再去处理它们</p> 
</blockquote> 
<h4 id="3%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%A8%A1%E5%BC%8F">3、消息队列的模式</h4> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>1.点对点模式：</strong></span></p> 
 <p>角色：消息队列   生产者  消费者</p> 
 <p>消息发送者生产消息发送到queue中, 然后消息接收者从queue中取出并且消费消息</p> 
 <p>消息被消费以后, queue中不再有存储, 所以消息接收者不可能消费到已经被消费的消息</p> 
 <p>特点：</p> 
 <p>• 每个消息只有一个接收者（Consumer）(即一旦被消费, 消息就不再在消息队列中)；</p> 
 <p>• 发送者和接收者间没有依赖性, 发送者发送消息之后, 不管有没有接收者在运行, 都不会影响  到发送者下次发送消息；    </p> 
 <p>• 接收者在成功接收消息之后需向队列应答成功, 以便消息队列删除当前接收的消息；</p> 
 <p><span style="color:#fe2c24;"><strong>2.发布/订阅模式：</strong></span></p> 
 <p>角色：    角色主题（Topic）   发布者(Publisher)     订阅者(Subscriber)</p> 
 <p>特点：</p> 
 <p>每个消息可以有多个订阅者；</p> 
 <p>• 发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者, 它必须创建一个订阅者之后, 才能消费发布者的消息</p> 
 <p>• 为了消费消息, 订阅者需要提前订阅该角色主题, 并保持在线运行</p> 
 <p><span style="color:#fe2c24;"><strong>3.两者区别：</strong></span></p> 
 <p>点对点模式</p> 
 <p>生产者发送一条消息到queue, 一个queue可以有很多消费者, 但是一个消息只能被一个消费者接受当没有消费者可用时, 这个消息会被保存直到有 一个可用的消费者</p> 
 <p>发布订阅模式</p> 
 <p>发布者发送到topic的消息, 只有订阅了topic的订阅者才会收到消息</p> 
 <p>topic实现了发布和订阅, 当你发布一个消息, 所有订阅这个topic的服务都能得到这个消息, 所以从1到N个订阅者都能得到这个消息的拷贝</p> 
</blockquote> 
<h4 id="4%E3%80%81%E5%B8%B8%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%AF%94%E8%BE%83">4、常用消息队列比较</h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8c/86/WzMv3wgL_o.png"></p> 
<p><strong>Kafka常用于分布式架构,对性能要求高的可考虑Kafka</strong></p> 
<p><strong>RocketMQ/思路来源于kafka, 改成了主从结构, 在事务性可靠性方面做了优化</strong></p> 
<p><strong>广泛来说, 电商、金融等对事务性要求很高的, 可以考虑RabbitMQ和RocketMQ</strong></p> 
<h3 id="%E4%BA%8C%E3%80%81kafka">二、kafka</h3> 
<h4 id="1%E3%80%81kafka%E4%BB%8B%E7%BB%8D">1、kafka介绍</h4> 
<blockquote> 
 <p>1.kafka对外使用topic（话题）的概念, 生产者往topic里写消息, 消费者从中读消息。</p> 
 <p>2.为了做到水平拓展，一个topic实际上是由多个partition（隔扇）组成，当遇到瓶颈时可以通过增加partition的数量来进行横向扩容，单个partition内是保证消息是有序的。</p> 
 <p>3.每新写入一条消息，kafka就是在对应的文件append（附加）写，所以性能非常高。</p> 
</blockquote> 
<p> <strong>Kafka是一个分布式、分区、复制的提交日志服务</strong></p> 
<p>kafka对消息保存时根据topic进行归类，发送消息者称为producer（生产商），发送消息者称为consumer（消费者），此外kafka集群又多个kafka实例组成，每个实例（server）称为broker。</p> 
<p><strong>无论是kafka集群还是producer和consumer都依赖与zookeeper来保证系统的可用性，zookeeper集群保存一些meat信息。</strong></p> 
<p class="img-center"><img alt="" height="232" src="https://images2.imgbox.com/82/e4/AdsjN48m_o.png" width="354"></p> 
<p> 一个topic可以认为是一类消息，每个topic将被分成多个partition，每个partition在存储层面是append log文件。</p> 
<p>任何发布到此partition的消息都会被直接追加到log文件尾部，每条消息在文件中的位置称为offset（偏移量），offset为一个long型数字，它唯一标记一条消息，kafka并没有提供其他额外的索引机制来存储offset，因为在kafka中几乎不允许对消息进行“随机读写”。</p> 
<p class="img-center"><img alt="" height="248" src="https://images2.imgbox.com/6a/19/vKjuijXQ_o.png" width="406"></p> 
<h4 id="%C2%A02%E3%80%81%E5%A4%87%E4%BB%BD"> 2、备份</h4> 
<p>为了保证分布式可靠性，kafka0.8开始对每个分区的数据进行备份（不同的Broker上），防止其中一个Broker宕机造成分区上的数据不可用。</p> 
<h4 id="3%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">3、基本概念</h4> 
<blockquote> 
 <p>1、消费者：（Consumer）：从消息队列中请求消息的客户端应用程序</p> 
 <p>2、生产者：（Producer）  ：向broker发布消息的应用程序</p> 
 <p>3、AMQP服务端（broker）：用来接收生产者发送的消息并将这些消息路由给服务器中的队列，便于fafka将生产者发送的消息，动态的添加到磁盘并给每一条消息一个偏移量，所以对于kafka一个broker就是一个应用程序的实例</p> 
 <p>4、主题（Topic）：一个主题类似新闻中的体育、娱乐、教育等分类概念，在实际工程中通常一个业务一个主题。</p> 
 <p>5、分区（Partition）：一个Topic中的消息数据按照多个分区组织，<strong>分区是kafka消息队列组织的最小单位</strong>，一个分区可以看作是一个FIFO（ First Input First Output的缩写，<span style="color:#fe2c24;"><strong>先入先出队列</strong></span>）的队列。kafka分区是提高kafka性能的关键所在，<strong>当你发现你的集群性能不高时，常用手段就是增加Topic的分区</strong>，分区里面的消息是按照从新到老的顺序进行组织，<strong>消费者从队列头订阅消息，生产者从队列尾添加消息。</strong></p> 
</blockquote> 
<h4 id="%E4%B8%89%E3%80%81%E9%83%A8%E7%BD%B2zookeeper%E9%9B%86%E7%BE%A4">三、部署zookeeper集群</h4> 
<h4 id="1%E3%80%81zookeeper%E4%BB%8B%E7%BB%8D">1、zookeeper介绍</h4> 
<p><strong>zookeeper是一种在分布式系统中被广泛作为：分布式状态管理、分布式协调管理、分布式配置管理和分布式锁服务的集群。</strong></p> 
<p>zookeeper的功能十分强大，可以实现诸如分布式应用配置管理、统一命名服务、状态同步服务、集群管理等功能。比如：程序分布式部署在多台服务器上，如果我们要改变程序的配置文件就需要逐台机器的去修改，如果把这些配置全部放到zookeeper上去保存在zookeeper的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化每个应用程序就会收到zookeeper的通知，然后从zookeeper获取新的配置信息应用到系统中。</p> 
<blockquote> 
 <p>1、kafka集群依赖于zookeeper进行元数据管理、leader选举、broker注册等功能。确保zookeeper集群的高可用和稳定性可以提高kafka集群的可靠性和可靠性。</p> 
 <p>2、在kafka集群中，zookeeper用于维护kafka集群的状态信息，如broker的状态、topic/partition信息、以及consumer的位置信息等。如果没有zookeeper集群，kafka集群就无法工作。</p> 
 <p>3、kafka的增加和减少服务器都会在zookeeper节点上触发相应的事件。</p> 
</blockquote> 
<h4 id="2%E3%80%81zookeeper%E9%9B%86%E7%BE%A4%E7%9A%84%E9%83%A8%E7%BD%B2">2、zookeeper集群的部署</h4> 
<p><strong>首先，zookeeper集群的工作是超过半数才能对外提供服务，所以成员数量一般为奇数台。</strong></p> 
<blockquote> 
 <p>1.部署Java环境（安装JDK）</p> 
 <p>2.安装zookeeper（<a href="http://zookeeper.apache.org" rel="nofollow" title="Apache ZooKeeper">Apache ZooKeeper</a>）</p> 
 <p>3.修改配置文件</p> 
 <p>cd 到安装目录中的conf目录下</p> 
 <p>cp zoo_sample.cfg zoo.cfg</p> 
 <hr> 
 <p>[root@host1 conf]# egrep -v "^$|^#" zoo.cfg</p> 
 <p>tickTime=2000 #Zookeeper服务器之间或客户端与服务器之间维持心跳的时间间隔</p> 
 <p>initLimit=10 #这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，</p> 
 <p>#而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。</p> 
 <p>#当已经超过 5个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，</p> 
 <p>#那么表明这个客户端连接失败。总的时间长度就是 10*2=20 秒</p> 
 <p>syncLimit=5 #这个配置项标识 Leader 与Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，</p> 
 <p>#总的时间长度就是5*2=10秒</p> 
 <p>dataDir=/data/zookeeper/data #快照日志的存储路径</p> 
 <p>dataLogDir=/data/zookeeper/datalog #事物日志的存储路径，如果不配置这个那么事物日志会默认存储到dataDir制定的目录</p> 
 <p>#这样会严重影响zk的性能，当zk吞吐量较大的时候，产生的事物日志、快照日志太多</p> 
 <p>clientPort=2181 #这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求</p> 
 <p>server.1=192.168.10.21:2888:3888</p> 
 <p>server.2=192.168.10.22:2888:3888</p> 
 <p>server.3=192.168.10.23:2888:3888`</p> 
 <p>#server.1 这个1是服务器的标识也可以是其他的数字， 表示这个是第几号服务器，用来标识服务器，这个标识要写到数据目录下面myid文件里</p> 
 <p>#192.168.10.21为IP地址，第一个端口是leader和follower之间的通信端口，默认是2888,服务启动后,只有leader会监听这个端口</p> 
 <p>#第二个端口是leader选举的端口，集群刚启动的时候选举或者leader挂掉之后进行新的选举的端口默认是3888</p> 
 <hr> 
 <p>4、创建数据目录及服务器ID（集群中每台机器的id不一样，每台机器都要配置）</p> 
 <p>[root@host1 conf]# mkdir /data/zookeeper/data{,log} -p</p> 
 <p>[root@host1 conf]# echo 1 &gt; /data/zookeeper/data/myid</p> 
 <p>5、启动集群机器中所有服务并查看</p> 
 <p>[root@host1 ~]# /usr/local/zookeeper/bin/zkServer.sh start #启动服务</p> 
 <p>[root@host2 ~]# /usr/local/zookeeper/bin/zkServer.sh status #查看状态</p> 
 <p>ZooKeeper JMX enabled by default</p> 
 <p>Using config: /usr/local/zookeeper/bin/../conf/zoo.cfg</p> 
 <p>Mode: leader</p> 
 <p><strong>zk集群一般只有一个leader，多个follower，主一般是相应客户端的读写请求，而从主同步数据，当主挂掉之后就会从follower里投票选举一个leader出来</strong></p> 
 <p>[root@host2 ~]# jps #查看运行的进程号</p> 
 <p>10948 Jps</p> 
 <p>10431 QuorumPeerMain</p> 
</blockquote> 
<h4 id="3%E3%80%81%E5%85%B3%E4%BA%8Ezookeeper%E9%9B%86%E7%BE%A4%E7%9A%84%E8%AF%B4%E6%98%8E">3、关于zookeeper集群的说明</h4> 
<blockquote> 
 <p>1)、myid文件和server.myid  在快照目录下存放的标识本台服务器的文件，他是整个zk集群用来发现彼此的一个重要标识。</p> 
 <p>2)、zoo.cfg 文件是zookeeper配置文件在conf目录里。</p> 
 <p>3)、log4j.properties文件是zk的日志输出文件, 在conf目录里. 用java写的程序基本上有个共同点:日志都用log4j来进行管理。</p> 
 <p>4)、zkEnv.sh和zkServer.sh文件</p> 
 <p>zkServer.sh 主管理程序文件</p> 
 <p>zkEnv.sh 是主要配置zookeeper集群启动时配置环境变量的文件</p> 
 <p>5)、还有一个需要注意: zookeeper不会主动的清除旧的快照和日志文件，这个是操作者的责任。</p> 
 <p>清理方法:</p> 
 <p>一. 脚本+计划任务清理</p> 
 <p>二. 使用bin/zkCleanup.sh这个脚本清理,具体使用方法找官方文档</p> 
 <p>三. 从3.4.0开始，zookeeper提供了自动清理snapshot和事务日志的功能，通过在zoo.cfg中配置两个参数实现:</p> 
 <p><strong>autopurge.purgeInterval</strong>  清理频率，单位是小时，默认是0，表示不开启自动清理功能</p> 
 <p><strong>autopurge.snapRetainCount</strong> 需要保留的文件数目, 默认是保留3个</p> 
</blockquote> 
<h3 id="%E5%9B%9B%E3%80%81%20kafka%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA">四、 kafka集群的搭建</h3> 
<p><strong>虽然kafka中集成了zookeeper,但还是建议使用独立的zk集群。</strong></p> 
<blockquote> 
 <p>1.软件下载及安装</p> 
 <p>2.创建数据目录</p> 
 <p>mkdir /data/kafka/kafka-logs</p> 
 <p>3.修改配置文件</p> 
 <p>vim /usr/local/kafka/config/server.properties </p> 
 <hr> 
 <p><span style="color:#fe2c24;">broker.id=1</span> <span style="color:#4da8ee;"> #当前机器在集群中的唯一标识，和zookeeper的myid性质一样</span></p> 
 <p><span style="color:#fe2c24;">listeners=PLAINTEXT://192.168.10.21:9092 </span><span style="color:#4da8ee;">#监听套接字</span></p> 
 <p>num.network.threads=3<span style="color:#4da8ee;"> #这个是borker进行网络处理的线程数</span></p> 
 <p>num.io.threads=8 <span style="color:#4da8ee;">#这个是borker进行I/O处理的线程数</span></p> 
 <p>socket.send.buffer.bytes=102400<span style="color:#4da8ee;"> #发送缓冲区buffer大小，数据不是一下子就发送的，先回存储到缓冲区了到达一定的大小后在发送，能提高性能</span></p> 
 <p>socket.receive.buffer.bytes=102400 <span style="color:#4da8ee;">#kafka接收缓冲区大小，当数据到达一定大小后在序列化到磁盘</span></p> 
 <p>socket.request.max.bytes=104857600<span style="color:#4da8ee;"> #这个参数是向kafka请求消息或者向kafka发送消息的请请求的最大数，这个值不能超过java的堆栈大小</span></p> 
 <p><span style="color:#fe2c24;">log.dirs=/data/kafka-logs </span><span style="color:#4da8ee;">#消息存放的目录，这个目录可以配置为“，”逗号分割的表达式，上面的num.io.threads要大于这个目录的个数</span></p> 
 <p><span style="color:#4da8ee;">#如果配置多个目录，新创建的topic把消息持久化在分区数最少那一个目录中</span></p> 
 <p>num.partitions=1 <span style="color:#4da8ee;">#默认的分区数，一个topic默认1个分区数</span></p> 
 <p>num.recovery.threads.per.data.dir=1 <span style="color:#4da8ee;">#在启动时恢复日志和关闭时刷新日志时每个数据目录的线程的数量，默认1</span></p> 
 <p>offsets.topic.replication.factor=2</p> 
 <p>transaction.state.log.replication.factor=1</p> 
 <p>transaction.state.log.min.isr=1</p> 
 <p>log.retention.hours=168 <span style="color:#4da8ee;">#默认消息的最大持久化时间，168小时，7天</span></p> 
 <p>message.max.byte=5242880 <span style="color:#4da8ee;">#消息保存的最大值5M</span></p> 
 <p><span style="color:#fe2c24;">default.replication.factor=2 </span><span style="color:#4da8ee;">#kafka保存消息的副本数</span></p> 
 <p>replica.fetch.max.bytes=5242880<span style="color:#4da8ee;"> #取消息的最大字节数</span></p> 
 <p>log.segment.bytes=1073741824<span style="color:#4da8ee;"> #这个参数是：因为kafka的消息是以追加的形式落地到文件，当超过这个值的时候，kafka会新起一个文件</span></p> 
 <p>log.retention.check.interval.ms=300000 <span style="color:#4da8ee;">#每隔300000毫秒去检查上面配置的log失效时间,到目录查看是否有过期的消息如果有，删除</span></p> 
 <p><span style="color:#fe2c24;">zookeeper.connect=192.168.10.21:2181,192.168.10.22:2181,192.168.10.23:2181</span></p> 
 <p>zookeeper.connection.timeout.ms=6000</p> 
 <p>group.initial.rebalance.delay.ms=0</p> 
 <hr> 
 <p>4.启动Kafka</p> 
 <p>/usr/local/kafka/bin/kafka-server-start.sh /usr/local/kafka/config/server.properties &amp;</p> 
 <p>5.查看启动情况</p> 
 <p>[root@host1 ~]# jps</p> 
 <p>10754 QuorumPeerMain</p> 
 <p>11911 Kafka</p> 
 <p>12287 Jps</p> 
 <p>6.创建topic进行验证</p> 
 <p>[root@host1 ~]# /usr/local/kafka/bin/kafka-topics.sh --create --zookeeper 192.168.10.21:2181 --replication-factor 2 --partitions 1 --topic qianfeng</p> 
 <p>Created topic "qianfeng".</p> 
 <p></p> 
 <p>在一台服务器上创建一个发布者</p> 
 <p>[root@host2 ~]# /usr/local/kafka/bin/kafka-console-producer.sh --broker-list 192.168.10.22:9092 --topic qianfeng</p> 
 <p>&gt; hello kafka</p> 
 <p>&gt; ni hao ya</p> 
 <p>&gt;</p> 
 <p></p> 
 <p>在另一台服务器上创建一个订阅者</p> 
 <p>[root@host3 ~]# /usr/local/kafka/bin/kafka-console-consumer.sh --bootstrap-server 192.168.10.21:9092 --topic qianfeng --from-beginning</p> 
 <p>...</p> 
 <p>hello kafka</p> 
 <p></p> 
 <p>ni hao ya</p> 
 <p></p> 
 <p>如果都能接收到,说明kafka部署成功</p> 
 <p>-----------------------------------------------------------------------------</p> 
 <p>[root@host3 ~]# /usr/local/kafka/bin/kafka-topics.sh --zookeeper 192.168.10.23:2181 --list #查看所有topic</p> 
 <p>[root@host3 ~]# /usr/local/kafka/bin/kafka-topics.sh --describe --zookeeper 192.168.10.23:2181 --topic qianfeng #查看指定topic的详细信息</p> 
 <p>Topic:qianfeng PartitionCount:1 ReplicationFactor:2 Configs:</p> 
 <p>Topic: qianfeng Partition: 0 Leader: 2 Replicas: 2,3 Isr: 2,3</p> 
 <p>[root@host3 ~]# /usr/local/kafka/bin/kafka-topics.sh --delete --zookeeper 192.168.10.23:2181 --topic qianfeng #删除topic</p> 
 <p>Topic qianfeng is marked for deletion.</p> 
 <p>Note: This will have no impact if delete.topic.enable is not set to true.</p> 
 <p>-----------------------------------------------------------------------------</p> 
 <p>下面我们将logstash的输出改到kafka上面，将数据写入到kafka中</p> 
 <p>不要过滤, logstash会将message内容写入到队列中</p> 
 <p># cat logstash-kafka.conf</p> 
 <p>input {<!-- --></p> 
 <p>file {<!-- --></p> 
 <p>type =&gt; "sys-log"</p> 
 <p>path =&gt; "/var/log/messages"</p> 
 <p>start_position =&gt; beginning</p> 
 <p>}</p> 
 <p>}</p> 
 <p>output {<!-- --></p> 
 <p>kafka {<!-- --></p> 
 <p>bootstrap_servers =&gt; "192.168.10.21:9092,192.168.10.22:9092,192.168.10.23:9092" #输出到kafka集群</p> 
 <p>topic_id =&gt; "sys-log-messages" #主题名称</p> 
 <p>compression_type =&gt; "snappy" #压缩类型</p> 
 <p>codec =&gt; "json"</p> 
 <p>}</p> 
 <p>}</p> 
 <p></p> 
 <p>启动logstash</p> 
 <p># /usr/local/logstash/bin/logstash -f logstash-kafka.conf</p> 
 <p></p> 
 <p>在kafka上查看主题,发现已经有了sys-log-messages,说明写入成功了</p> 
 <p>[root@host2 ~]# /usr/local/kafka/bin/kafka-topics.sh --zookeeper 192.168.10.22:2181 --list</p> 
 <p>__consumer_offsets</p> 
 <p>qianfeng</p> 
 <p>sys-log-messages</p> 
 <p>[root@host2 ~]# /usr/local/kafka/bin/kafka-topics.sh --describe --zookeeper 192.168.10.22:2181 --topic sys-log-messages</p> 
 <p>Topic:sys-log-messages PartitionCount:1 ReplicationFactor:2 Configs:</p> 
 <p>Topic: sys-log-messages Partition: 0 Leader: 3 Replicas: 3,2 Isr: 3,2</p> 
 <p></p> 
 <p>接下来我们怎么将kafka中的内容写入到es集群中呢? 还是要利用logstash</p> 
 <p># cat kafka-es.conf</p> 
 <p>input {<!-- --></p> 
 <p>kafka {<!-- --></p> 
 <p>bootstrap_servers =&gt; "192.168.10.21:9092,192.168.10.22:9092,192.168.10.23:9092"</p> 
 <p>topics =&gt; "output-test"</p> 
 <p>codec =&gt; "json"</p> 
 <p>auto_offset_reset =&gt; "earliest"</p> 
 <p>}</p> 
 <p>}</p> 
 <p></p> 
 <p>output {<!-- --></p> 
 <p>elasticsearch {<!-- --></p> 
 <p>hosts =&gt; ["192.168.10.11:9200","192.168.10.12:9200"]</p> 
 <p>index =&gt; "kafka-%{type}-%{+YYYY.MM.dd}"</p> 
 <p>}</p> 
 <p>}</p> 
</blockquote> 
<h3 id="%E4%BA%94%E3%80%81eflk%E6%95%B0%E6%8D%AE%E6%B5%81">五、eflk数据流</h3> 
<blockquote> 
 <h4 id="appserver%20--%3Efilebeat%20--%3E%20kafka%20--%3E%20logstash%20--%3E%20elasticsearch%20--%3E%20kibana"><strong>appserver --&gt;</strong><strong>filebeat --&gt; kafka --&gt; logstash --&gt; elasticsearch --&gt; kibana</strong></h4> 
 <h4 id="filebeat%E9%85%8D%E7%BD%AE">filebeat配置</h4> 
 <p>lebeat.prospectors:</p> 
 <p>- input_type: log</p> 
 <p>paths:</p> 
 <p>- /var/log/nginx/access.log</p> 
 <p>json.keys_under_root: true</p> 
 <p>json.add_error_key: true</p> 
 <p>json.message_key: log</p> 
 <p></p> 
 <p>output.kafka:</p> 
 <p>hosts: [ "192.168.10.21:9092","192.168.10.22:9092","192.168.10.23:9092"]</p> 
 <p>topic: 'nginx-access-log'</p> 
 <p></p> 
 <h4 id="logstash%5B%E6%B6%88%E8%B4%B9%E8%80%85%5D%E9%85%8D%E7%BD%AE">logstash[消费者]配置</h4> 
 <p>/usr/local/logstash/config/input-from-kafka.conf</p> 
 <p>input {<!-- --></p> 
 <p>kafka {<!-- --></p> 
 <p>bootstrap_servers =&gt; "192.168.10.21:9092,192.168.10.22:9092,192.168.10.23:9092"</p> 
 <p>topics =&gt; "nginx-access-log"</p> 
 <p>auto_offset_reset =&gt; "earliest"</p> 
 <p>codec =&gt; "json"</p> 
 <p>decorate_events =&gt; true</p> 
 <p>}</p> 
 <p>}</p> 
 <p></p> 
 <p>filter {<!-- --></p> 
 <p>grok {<!-- --></p> 
 <p>match =&gt; {"log" =&gt; "%{COMBINEDAPACHELOG} %{QS:x-forwarded-for}"}</p> 
 <p>remove_field =&gt; ["error","beat","offset","auth","ident","log"]</p> 
 <p>}</p> 
 <p>}</p> 
 <p></p> 
 <p>output{<!-- --></p> 
 <p>elasticsearch {<!-- --></p> 
 <p>hosts =&gt; ["192.168.10.11:9200"]</p> 
 <p>index =&gt; "nginx-access-log-%{+YYYY.MM.dd}"</p> 
 <p>}</p> 
 <p>}</p> 
</blockquote> 
<p></p> 
<p></p> 
<p></p> 
<p>  </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9a19aec66687f99cd52fcd694c8d916a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C#四则运算计算器程序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/77ed4aa7c4b5f60feec19ff659f106b5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">高性能linux服务构建 1服务器安全运维</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>