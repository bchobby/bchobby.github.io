<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>路径规划算法之栅格地图绘制 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="路径规划算法之栅格地图绘制" />
<meta property="og:description" content="来源 | 古月居
01 数据地图
1.1 地图类型
1.2 栅格地图表示方式
a. 本栏路径规划利用矩阵（二维数组）来表示栅格地图（因为对于矩阵，无论MATLAB、C&#43;&#43;还是Python，矩阵更适合数组的表达，更便于编程。）
b. 矩阵表示地图与传统意识中坐标X,Y有所区别。
如图所示的地图，在矩阵表示中，起点位置为[3,1]，终点为[3,5]，三个障碍物分别为[2,3],[3,3]和[4,3]。在坐标表示中，起点位置为(1,2)，终点为(5,2)，三个障碍物分别为(3,1),(3,2)和(3,3)
c. 矩阵表示地图还可以用线性索引来简化，这样将矩阵的二维数组表示成一位数组，编程更方便。
Tips：线性索引，是从第一列开始，沿着行按顺序增长，然后从第二列开始…，是竖着沿行增长的，而非横着沿着列增长。理解记忆有点类似于Excel表格按行递增。
02 位置的表示方法的区分
2.1 在栅格地图上绘制xy点发生的情况
对于程序
clear;close all; rows = 4; cols = 5; % 地图行列尺寸 % 设置地图属性 field = ones(rows, cols); field(1,3) = 4; % 栅格矩阵表示1,3位置图像 % 颜色表征矩阵 cmap = [1 1 1; ... % 1-白色-空地 0 0 0; ... % 2-黑色-静态障碍 1 0 0; ... % 3-红色-动态障碍 1 1 0;... % 4-黄色-起始点 1 0 1;." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/ddab89b163e6db9c8e50c01a33efe8f9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-14T07:00:03+08:00" />
<meta property="article:modified_time" content="2023-03-14T07:00:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">路径规划算法之栅格地图绘制</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p>来源 | 古月居</p> 
 <p style="text-align:center;"><em><strong>01  </strong></em><strong>数据地图</strong></p> 
 <p><strong>1.1 地图类型</strong></p> 
 <p><img src="https://images2.imgbox.com/27/5e/v7hOorOi_o.jpg" alt="b57c74f0c7cf1c458c3b1d01b97b07a5.jpeg"></p> 
 <p><strong>1.2 栅格地图表示方式</strong></p> 
 <p>a. 本栏路径规划利用矩阵（二维数组）来表示栅格地图（因为对于矩阵，无论MATLAB、C++还是Python，矩阵更适合数组的表达，更便于编程。）</p> 
 <p>b. 矩阵表示地图与传统意识中坐标X,Y有所区别。</p> 
 <p><img src="https://images2.imgbox.com/13/f5/AAU043Bx_o.png" alt="5fe0ba1fc99dc19067e27f24621fbee9.png"></p> 
 <p>如图所示的地图，在矩阵表示中，起点位置为[3,1]，终点为[3,5]，三个障碍物分别为[2,3],[3,3]和[4,3]。在坐标表示中，起点位置为(1,2)，终点为(5,2)，三个障碍物分别为(3,1),(3,2)和(3,3)</p> 
 <p>c. 矩阵表示地图还可以用线性索引来简化，这样将矩阵的二维数组表示成一位数组，编程更方便。</p> 
 <p><img src="https://images2.imgbox.com/0e/21/slinu2lH_o.png" alt="f1d7ed5e347b99e3ce8ead7c974c26bd.png"></p> 
 <p>Tips：线性索引，是从第一列开始，沿着行按顺序增长，然后从第二列开始…，是竖着沿行增长的，而非横着沿着列增长。理解记忆有点类似于Excel表格按行递增。</p> 
 <p style="text-align:center;"><em><strong>02  </strong></em><strong>位置的表示方法的区分</strong></p> 
 <p><strong>2.1 在栅格地图上绘制xy点发生的情况</strong></p> 
 <p>对于程序</p> 
 <pre class="has"><code class="language-sql">clear;close all;
rows = 4; cols = 5;                           % 地图行列尺寸


% 设置地图属性
field = ones(rows, cols);
field(1,3) = 4;          % 栅格矩阵表示1,3位置图像


% 颜色表征矩阵
cmap = [1 1 1; ...       % 1-白色-空地
    0 0 0; ...           % 2-黑色-静态障碍
    1 0 0; ...           % 3-红色-动态障碍
    1 1 0;...            % 4-黄色-起始点
    1 0 1;...            % 5-品红-目标点
    0 1 0; ...           % 6-绿色-到目标点的规划路径
    0 1 1];              % 7-青色-动态规划的路径
colormap(cmap);
image(1.5,1.5,field);


% % 设置栅格属性
grid on;hold on;
set(gca,'gridline','-','gridcolor','k','linewidth',0.5,'GridAlpha',0.5);
set(gca,'xtick',1:cols+1,'ytick',1:rows+1);
set(gca, 'XAxisLocation','top')
axis image;


scatter(1,3,200,'filled');  % XY绘制1,3图像，其中200是圆圈大小</code></pre> 
 ‍ 
 <p><img src="https://images2.imgbox.com/ab/d4/4PmKo6Zy_o.png" alt="a3df742cc9a6d6d25d866cb26d32e782.png"></p> 
 <p>这是因为在栅格地图上的坐标系X对应于列col，而坐标Y对于与行row</p> 
 <p><img src="https://images2.imgbox.com/39/dc/uoQ2mqky_o.png" alt="228e73c741c2c03e6202b53761fe9a76.png"></p> 
 <p><strong>2.2 三种表述位置方法的关系</strong></p> 
 <p>下面图片是针对于Python绘图表述的，MATLAB绘图转换关系是一致的，但是MATLAB数组从1开始，而Python数组从0开始</p> 
 <p>①sub2coord和sub2xy均是仿照MATLABsub2ind命名的函数，方便理解和记忆</p> 
 <p>②MATLAB只要用到sub2ind和sub2coord即可</p> 
 <p>③sub2xy主要是正对于Python进行plt.plot绘图使用的</p> 
 <p>几个代码的转换函数见后面的模块</p> 
 <p><img src="https://images2.imgbox.com/7f/ef/pjdVZlqY_o.png" alt="030427af0730c87718c7bc625d17ef53.png"></p> 
 <p style="text-align:center;"><em><strong>03  </strong></em><strong>MATLAB绘制栅格地图</strong></p> 
 <p>Tips1：这里为了方便MATLAB语言、Python语言和C++编程的统一性，统一采用按行递增的方式存放的下标特征信息数据（如障碍物坐标[row1,col1;row2,col2;row3,col3;…]），表示地图特征信息的位置==；</p> 
 <p><img src="https://images2.imgbox.com/2c/11/PbxjwPq2_o.png" alt="6be14d006f70bc93eaa5312606466665.png"></p> 
 <p>Tips2：当你获得线性地图特征信息的线性索引关系或者是XY坐标值，可以将其装换成线性索引值套用程序。MATLAB的数组的应用可以参考：</p> 
 <p>MATLAB数组的一些操作</p> 
 <p>https://blog.csdn.net/qq_42727752/article/details/119765592</p> 
 <p>MATLAB绘制栅格步骤：</p> 
 <p>a. 创建行列大小的二维矩阵，初始状态全为数值1表示空地；</p> 
 <p>b. 利用矩阵(下标位置) = 赋值的方式，修改对应位置的数值(和colormap的颜色值对应)，表示地图特征；</p> 
 <p>c. 利用colormap函数和image函数绘制出颜色地图；</p> 
 <p>d. 添加坐标。</p> 
 <p><strong>3.1 colormap函数</strong></p> 
 <p>利用image函数可以画出栅格图像，具体操作可以查看help image的帮助文档。</p> 
 <p><strong>3.2 几个位置表述转换函数</strong></p> 
 <p>MATLAB只要用到sub2ind和sub2coord即可</p> 
 <p>sub2ind和ind2sub将矩阵对应的线性值化成下标，具体操作可以查看 help sub2ind和help ind2sub的帮助文档。</p> 
 <p>sub2coord.m和coord2sub.m函数：</p> 
 <pre class="has"><code class="language-perl">function coord = sub2coord(sub)
%SUB2COORD 将行列式下标装换为坐标格式，此时的坐标格式和原本认知坐标方向也不一致（如下所示）
%        1 2 3 4 5 6 7 .... X坐标
%      1|——————————&gt;
%      2|
%      3|
%      4|
%      5|
%  Y坐标\/


    [l,w] = size(sub);
    % 长度l=2表示sub为2*n矩阵
if l == 2
coord(1,:) = sub(2,:);
        coord(2,:) = sub(1,:);
    end


if w == 2
        coord(:,1) = sub(:,2);
        coord(:,2) = sub(:,1);
    end


end</code></pre> 
 <pre class="has"><code class="language-perl">function sub = coord2sub(coord)
%COORD2SUB 将坐标转换为矩阵行列格式，坐标格式为下图所示
%        1 2 3 4 5 6 7 .... X坐标
%      1|——————————&gt;
%      2|
%      3|
%      4|
%      5|
%  Y坐标\/


    [l,w] = size(coord);
    % 长度l=2表示sub为2*n矩阵
if l == 2
sub(1,:) = coord(2,:);
sub(2,:) = coord(1,:);
    end


if w == 2
sub(:,1) = coord(:,2);
sub(:,2) = coord(:,1);
    end
end</code></pre> 
 ‍ 
 <p><strong>3.3 利用地图线性值信息绘制栅格图(FD_DrawRasterMap.m函数)</strong></p> 
 <p>线性索引值的目的就是省略for循环，因为矩阵A(线性索引)=int可以很方便的全部赋值，而Python/C++等需要借助循环</p> 
 <p>其次是线性索引作为输入，只要一个参数即可，同时在表达矩阵上，可以简化成一维，而行列是二维较为复杂</p> 
 <pre class="has"><code class="language-sql">function Fields = DrawRasterMap(rows,cols,startsub,endsub,obssub)
%DRAWRASTERMAO 绘制随机障碍物的栅格图,存在一个返回内容；输入格式（行数 列数 起点行列 终点行列置 障碍物行列）；
                                                       % 输出内容:数值化的栅格矩阵


% 定义栅格地图全域，并初始化空白区域
field = ones(rows, cols); %初始化空白区域 数值全为1,数值用于表示Cmap的颜色(因为Cmap数组索引只能从1开始)


% 起始点和目标点
start = startsub;                       % 起点的位置
goal = endsub;                          % 终点的位置
field(start(1),start(2)) = 4;           % 起点在数组的数值,数值用于表示Cmap的颜色
field(goal(1),goal(2)) = 5;             % 终点在数组的数值,数值用于表示Cmap的颜色


% 障碍物区域
obs = obssub;
field(obs(:,1),obs(:,2)) = 2;       %障碍物在数组的数值,数值用于表示Cmap的颜色


% ObsR = obssub(:,1);ObsC = obssub(:,2);
% obs = sub2ind([rows,cols],ObsR,ObsC);
% field(obs) = 2;                         % 障碍物在数组的数值,数值用于表示Cmap的颜色


% 函数返回值为数值化的栅格矩阵
Fields = field;


%构建数组的栅格图 可以查看帮助 help image
cmap = [1 1 1; ...       % 1-白色-空地
    0 0 0; ...           % 2-黑色-静态障碍
    1 0 0; ...           % 3-红色-动态障碍
    1 1 0;...            % 4-黄色-起始点 
    1 0 1;...            % 5-品红-目标点
    0 1 0; ...           % 6-绿色-到目标点的规划路径   
    0 1 1; ...           % 7-青色-动态规划的路径
    0 0 1];              % 8-蓝色


% 构建颜色MAP图
colormap(cmap);




% 绘制图像
image(1.5,1.5,field);
grid on;
set(gca,'gridline','-','gridcolor','k','linewidth',2,'GridAlpha',0.5);
set(gca,'xtick',1:cols+1,'ytick',1:rows+1);
set(gca, 'XAxisLocation','top')
axis image;


end</code></pre> 
 <p><strong>测试代码：</strong>生成行为4列为5的矩阵，起点位置在3，终点在19，障碍物位置在10、11和12。主要目的是为了理解image函数的线性值和ROW和COL的坐标关系。</p> 
 <pre class="has"><code class="language-shell">%%%% TestMain.m
%%%% 脚本文件 用于直接调用函数 熟悉概念
clc;
clear;
close all;
rows = 4;cols = 5;


[startpos(1),startpos(2)] = ind2sub([rows,cols],3);
[endpos(1),endpos(2)] = ind2sub([rows,cols],19);
[obspos(:,1),obspos(:,2)] = ind2sub([rows,cols],[10;11;12]);


field = FD_DrawRasterMap(rows,cols,startpos,endpos,obspos);
field
% 如果出线障碍物信息在地图上显示不对
% 可能是在函数内的field(obsIndex(:,1),obsIndex(:,2)) = 2;产生错误
% 可以采用将行列转成线性索引即函数内该代码下面注释的内容</code></pre> 
 <p>最后生成的图像如图所示。</p> 
 <p><img src="https://images2.imgbox.com/be/7d/bSuIugPy_o.png" alt="868678404f0e636ef5d57e1128378d7c.png"></p> 
 <p style="text-align:center;"><em><strong>04  </strong></em><strong>Python绘制栅格地图</strong></p> 
 <p>Python绘制栅格地图的流程：</p> 
 <p>a. 创建全1二维矩阵，表示空地信息。<br>b. 将下标位置的栅格信息装换成特征值。<br>c. 将矩阵可视化。</p> 
 <p>Python数组的一些操作：</p> 
 <p>https://blog.csdn.net/qq_42727752/article/details/108368891</p> 
 <p>输入数据依旧采用按列递增的方式（如障碍物坐标[[row1,col1],][row2,col2],[row3,col3];…]）</p> 
 <p><strong>4.1 matplotlib和seaborn包</strong></p> 
 <p>绘制栅格地图前需要pip install matplotlib和seaborn两个绘图功能包。</p> 
 <p><strong>4.2 几种坐标转换函数PathPlanning.py</strong></p> 
 <pre class="has"><code class="language-python">import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import seaborn as sns
import random
import copy
from matplotlib import colors








'''
# --------------------------------PATHPLANNING函数包------------------------------------
# =====Tips1:输入参数矩阵尺寸为[0--&gt;rows]的所有个数，非rows的最大下标
# =====Tips2:区别行列矩阵，行列坐标，和XY坐标
# =====Tips3:在不同表示系，sz均为行列尺寸，即sz=[rows,cols],在XY坐标坐标系中sz=[leny,lenx]
#
# # sub2coord(possub)函数，输入单个行列位置，输出单个行列坐标位置(数组)
# # coord2sub(posxy)函数，输入单个行列坐标位置，输出单个行列位置(数组)
# # xy2sub(sz,x,y)函数，输入尺寸、x坐标和y坐标，输出行列位置(数组)
# # sub2xy(sz,r,c)函数，输入尺寸、XY坐标行位置和列位置，输出xy位置(数组)
# # sub2ind(sz,r,c)函数，输入尺寸，行位置和列位置，输出对应的线性索引值(从0开始)
# # ind2sub(sz,ind)函数，输入尺寸和线性索引值，输出矩阵位置(数组)
# # DrawHeatMap(field)函数，输入地图矩阵绘制热力图，无输出
# ----------------------------------------------------------------------------------------
'''








'''
# sub2coord和coord2sub函数，行列坐标系内，行列位置和坐标位置相互转换
# 其中的【行列坐标系】形式如图所示，从0开始，因为Python数组下标从0开始，Y方向沿下递增
#
#                   0 1 2 3 4
#                0+----------&gt;X(X=cols)
#                1|
#                2|
#                3|
#               Y(Y=rows)
'''
def sub2coord(possub):
    posx = possub[1]
    posy = possub[0]
return [posx, posy]




def coord2sub(posxy):
    posr = posxy[1]
    posc = posxy[0]
return [posr, posc]




'''
# xy2sub和sub2xy函数，坐标系XY位置转换为矩阵格式的转换函数
# ++++sz为坐标尺寸，即元素个数，非最大坐标值
# 其中的XY形式如图所示，从0开始，到[sz]-1为止
#
#                Y/
#                3|
#                2|
#                1|
#                0+----------&gt;X
#                   0 1 2 3 4
'''
def xy2sub(sz, x, y):
    r = sz[0]-1-y
    c = x
return [r, c]




def sub2xy(sz, r, c):
    x = c
    y = sz[0]-1-r
return [x, y]




'''
# sub2ind和ind2sub函数，将行列位置转换为索引位置
# 行列位置和索引关系，对应如图所示
#
#                   0 1 2 3 4
#                0+----------&gt;cols
#                1| 0 3 6 ...
#                2| 1 4 7 ...
#                3| 2 5 8 ...
#               rows
'''


def sub2ind(sz,r,c):
    ind = c*sz[0]+r
return ind




def ind2sub(sz,ind):
    c = int(ind/sz[0])
    r = ind-c*sz[0]
return [r,c]








'''
# DrawHeatMap函数，用于通过栅格地图的信息，绘制出彩色地图
# INPUT：栅格电子地图矩阵
# OUTPUT:NONE
#
'''
def DrawHeatMap(field):
    rows = len(field)
    cols = len(field[0])
    cmap = colors.ListedColormap(['none', 'white', 'black', 'red', 'yellow', 'magenta', 'green', 'cyan', 'blue'])


# 绘图函数
# 其实默认为fig,ax = plt.figure(),后续发现fig没有用上
# 但是ax需要频繁使用，因此直接ax = plt.gca()替代掉
    plt.figure(figsize=(12, 8))
    ax = plt.gca()


# 绘制热力图
# 其中vmin和vmax对应栅格地图数值的颜色与cmap一一对应
# cbar设置false将色条设置为不可见
    ax = sns.heatmap(field, cmap=cmap, vmin=0, vmax=8, linewidths=0.8,linecolor='black', ax=ax, cbar=False)


# 设置图标题
    ax.set_ylabel('rows')
    ax.set_xlabel('cols')


# 将列标签移动到图像上方
    ax.xaxis.tick_top()
    ax.xaxis.set_label_position('top')


# 设置图标的数字个数文字，放在plt.show下面能居中
    ax.set_xticks(np.arange(cols))
    ax.set_yticks(np.arange(rows))</code></pre> 
 <p><strong>4.3 采用seaborn绘制静态地图</strong></p> 
 <pre class="has"><code class="language-python">import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib import colors
from matplotlib import animation
import matplotlib.patches as pc
import copy




def sub2coord(possub):
    posx = possub[1]
    posy = possub[0]
return [posx,posy]




def coord2sub(posxy):
    posr = posxy[1]
    posc = posxy[0]
return [posr,posc]




'''
# # -------------------------------------这里定义绘图函数-------------------------------------------------
'''
def drawmap(rows,cols,startSub,goalSub,obsSub):
# 创建全部为空地的地图栅格，其中空地以数字1表征
    field = np.ones((rows,cols))


# 修改栅格地图中起始点和终点的数值，其中起点以数值4表征，终点以数值5表示
    field[startSub[0],startSub[1]] = 4
    field[goalSub[0],goalSub[1]] = 5


# 修改栅格地图中障碍物的数值，其中以数值5表示
for i in range(len(obsSub)):
        field[obsSub[i][0],obsSub[i][1]] = 2


# 绘制图像，利用matplotlib的热力图进行绘制
# 设置色条的范围，从0~8
    cmap = colors.ListedColormap(['none','white','black','red','yellow','magenta','green','cyan','blue'])


# 绘图函数
# 其实默认为fig,ax = plt.figure(),后续发现fig没有用上
# 但是ax需要频繁使用，因此直接ax = plt.gca()替代掉
    plt.figure(figsize=(cols,rows))
    ax = plt.gca()




# 绘制热力图
# 其中vmin和vmax对应栅格地图数值的颜色与cmap一一对应
# cbar设置false将色条设置为不可见
    sns.heatmap(field, cmap = cmap,vmin = 0,vmax = 8, linewidths = 1.25, linecolor= 'black', ax = ax, cbar = False)


# 设置图标题
    ax.set_ylabel('rows')
    ax.set_xlabel('cols')


# 将列标签移动到图像上方
    ax.xaxis.tick_top()
    ax.xaxis.set_label_position('top')




# 设置图标的数字个数文字，放在plt.show下面能居中
    ax.set_xticks(np.arange(cols))
    ax.set_yticks(np.arange(rows))


# 直接显示图像，如要类似于MATLAB的hold on建议在主函数最后使用plt.show()
# plt.show()


return field


'''
# # -------------------------------------这是是测试的主函数-------------------------------------------------
'''
rows = 4
cols = 5


startSub = [2,0]
goalSub = [2,4]
obsSub = [[1,2],[2,2],[3,2]]


drawmap(rows,cols,startSub,goalSub,obsSub)
# 采用热力图这种，坐标系简历和MATLAB是一致的，X=col，Y=rows，且递增方向都是一致的，因此绘制XY时候比较难理解
pointxy = [2,3]
plt.scatter(pointxy[0],pointxy[1],s = 200,c = 'r')
pointsub = coord2sub(pointxy)
plt.scatter(pointsub[0],pointsub[1],s = 200,c = 'y')
plt.show()</code></pre> 
 <p>最后生成的图像效果如图。</p> 
 <p><img src="https://images2.imgbox.com/e8/8b/4obRETm9_o.png" alt="943ceeb60e8fd7c2973fe0d06cfe4a1a.png"></p> 
 <p><strong>4.4 采用plot在XY坐标填充矩形绘制地图</strong></p> 
 <p><img src="https://images2.imgbox.com/bb/c8/fwn6aO1q_o.png" alt="6884bfd652dccc8e759f0752ccace289.png"></p> 
 <pre class="has"><code class="language-python">import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from matplotlib import colors
import matplotlib.patches as pc




def xy2sub(len,x,y):
    r = len - y -1
    c = x
return [r,c]


def sub2xy(len,r,c):
    x = c
    y = len - r - 1
return [x,y]




def drawmap_xy(Xs,Ys,startxy,goalxy,obsxy):
# 其中X和矩阵地图的cols对应
    rows = Ys
    cols = Xs
# 创建全部为空地的地图栅格，其中空地以数字1表征
# ！！！注意ones(行列个数，因此rows需要+1)
    field = np.ones([rows,cols])


# 修改栅格地图中起始点和终点的数值，其中起点以数值4表征，终点以数值5表示
    startsub = xy2sub(rows,startxy[0],startxy[1])
    goalsub = xy2sub(rows,goalxy[0],goalxy[1])
    field[startsub[0],startsub[1]] = 4
    field[goalsub[0],goalsub[1]] = 5


# 修改栅格地图中障碍物的数值，其中以数值5表示
for i in range(len(obsxy)):
        obssub = xy2sub(rows,obsxy[i][0],obsxy[i][1])
        field[obssub[0],obssub[1]] = 2




# 设置画布属性
    plt.figure(figsize=(cols,rows))
    plt.xlim(-1, cols)
    plt.ylim(-1, rows)
    plt.xticks(np.arange(Xs))
    plt.yticks(np.arange(Ys))


# 绘制障碍物XY位置
for i in range(len(obsxy)):
        plt.gca().add_patch(pc.Rectangle((obsxy[i][0] - 0.5, obsxy[i][1] - 0.5), 1,1,color='k'))


# 绘制起点，终点
    plt.gca().add_patch(pc.Rectangle((startxy[0] - 0.5, startxy[1] - 0.5), 1,1,color='yellow'))
    plt.gca().add_patch(pc.Rectangle((goalxy[0] - 0.5, goalxy[1] - 0.5), 1,1,color='m'))


return field








'''
这里是主函数，将下列地图，用以为坐标XY形式绘制出
# Y/|1. 1. 1. 1. 1.
#   |1. 1. 2. 1. 1.
#   |4. 1. 2. 1. 5.
#   |1. 1. 2. 1. 1.----&gt;X
'''


startxy = [0,1]
goalxy = [4,1]
obsxy = [[2,0],[2,1],[2,2]]


Ys = 4
Xs = 5


drawmap_xy(Xs,Ys,startxy,goalxy,obsxy)


# 采用XY坐标的优势在于绘制其他参数时候，如在X=2，Y=3 绘制一个大圆点，但是地图矩阵和XY又需要相互转变一下
plt.scatter(2,3,s = 200,c = 'r')
plt.show()</code></pre> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/80/d8/ht3kjcTT_o.png" alt="8253182591b40349313807aadbed6f5e.png"></p> 
 <p><strong>4.5 绘制动态地图信息的方法</strong></p> 
 <p>绘制动态地图方法提供两种参考：</p> 
 <p>a. 使用imshow(field)联合plt.pause()显示栅格地图</p> 
 <p>b. 利用plt.plot()联合plt.pause()和plt.cla()进行刷新显示</p> 
 <p>tips：import PathPlanning是必须的</p> 
 <pre class="has"><code class="language-python">import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib import colors
from matplotlib import animation
import matplotlib.patches as pc
import copy
import random


import PathPlanning




'''
# ----------------------------------------------------------------------------------------------
# 绘制动态地图方法提供两种参考：
# 1、使用imshow(field)联合plt.pause()显示栅格地图
# 2、利用plt.plot()联合plt.pause()和plt.cla()进行刷新显示
# tips：import PathPlanning是必须的
# -----------------------------------------------------------------------------------------------
'''


'''
# ------------------------声明地图信息和某些固定信息，地图样式如图所示
# [[1. 1. 1. 1. 1. 1. 1.]
#  [1. 1. 1. 2. 1. 1. 1.]
#  [1. 4. 1. 2. 1. 5. 1.]
#  [1. 1. 1. 2. 1. 1. 1.]
#  [1. 1. 1. 1. 1. 1. 1.]
#  [1. 1. 1. 1. 1. 1. 1.]]
#
'''
rows = 6
cols = 7
startSub = [2,1]
goalSub = [2,5]
obsSub = [[1,3],[2,3],[3,3]]




# 栅格地图属性
field = np.ones((rows, cols))


field[startSub[0], startSub[1]] = 4
field[goalSub[0], goalSub[1]] = 5


for i in range(len(obsSub)):
    field[obsSub[i][0], obsSub[i][1]] = 2


# 新建画布指定大小
fig = plt.figure(figsize=(9,6))
# 新建子图
ax = fig.add_subplot(111)


# 没有用的变量，主要是区分绘制方法是第一种还是第二种
draw = False






'''
# 方法一利用imshow绘制动态地图
# 利用随机函数，随机选择地图位置改变数值
'''
cmap = colors.ListedColormap(['none', 'white', 'black', 'red', 'yellow', 'magenta', 'green', 'cyan', 'blue'])


# 动态刷新地图次数
if draw:
for i in range(10):
# 随机选择修改地图信息的位置
        temp_r = random.randint(0,rows-1)
        temp_c = random.randint(0,cols-1)


# 修改地图信息
        field[temp_r][temp_c] = 3


# 显示图像并设置图像属性
        ax.imshow(field, cmap=cmap, vmin=0, vmax=8)
        ax.set_ylabel('rows')
        ax.set_xlabel('cols')
        ax.xaxis.tick_top()
        ax.xaxis.set_label_position('top')
        ax.set_xticks(np.arange(cols))
        ax.set_yticks(np.arange(rows))
        plt.pause(0.05)


# 重置回白色
        field[temp_r][temp_c] = 1




'''
# 方法二：采用plt.plot联合plt.pause()和plt.cla()
# 利用随机函数，随机选择地图位置改变数值
'''
if not draw:
# plt.plot都是建立在xy坐标系上的内容可以利用pathplanning的sub2xy函数转换
# 将行列转成xy坐标系的xy值
    startXY = PathPlanning.sub2xy([rows,cols],startSub[0],startSub[1])
    goalXY = PathPlanning.sub2xy([rows,cols],goalSub[0],goalSub[1])
    obsX = []
    obsY = []


for i in range(len(obsSub)):
        obsxy = PathPlanning.sub2xy([rows,cols],obsSub[i][0],obsSub[i][1])
        obsX.append(obsxy[0])
        obsY.append(obsxy[1])


for i in range(100):
# 随机选择修改地图信息的位置
        temp_r = random.randint(0,rows-1)
        temp_c = random.randint(0,cols-1)
        temp_xy = PathPlanning.sub2xy([rows,cols],temp_r,temp_c)


# 修改地图信息
        field[temp_r][temp_c] = 3


# 显示图像并设置图像属性
        plt.plot(startXY[0],startXY[1],'r+')
        plt.plot(goalXY[0],goalXY[1],'b+')
        plt.plot(obsX,obsY,'sk')
        plt.plot(temp_xy[0],temp_xy[1],'sr')
        ax.set_xlim([-1,cols])
        ax.set_ylim([-1,rows])
        ax.set_xticks(np.arange(cols))
        ax.set_yticks(np.arange(rows))
        plt.pause(1)
        plt.cla()


# 重置回白色
        field[temp_r][temp_c] = 1</code></pre> 
 <p style="text-align:center;"><em><strong>05  </strong></em><strong>C++创建栅格地图矩阵</strong></p> 
 <p>C++创建栅格地图矩阵的流程：</p> 
 <p>    a. 创建全0二维数组，表示空地信息。</p> 
 <p>    b. 将下标位置的栅格信息装换成特征值。</p> 
 <p>    c. C++虽然有matplotlib包，但是可视化效果并不是很好，这里不使用C++绘制栅格地图，难度较大。</p> 
 <p>C++数组的一些基本操作：</p> 
 <pre class="has"><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;


using namespace std;


int main()
{
int const rows = 4;
int const cols = 5;
int startpos[2] = {2,0};
int endpos[2] = {2,4};
int obspos[3][2] = {<!-- -->{1,2},{2,2},{3,2}};


// 定义栅格地图二维数组，默认初始化为0
int filed[rows][cols] = {0};


// 修改起点和终点在栅格数组中的数值，其中起点为1，终点为2
    filed[startpos[0]][startpos[1]] = 1;
    filed[endpos[0]][endpos[1]] = 2;


// 循环修改障碍物在栅格矩阵的数值，其中障碍物数值为3
int len = sizeof(obspos) / sizeof(obspos[0]);
for(int temp_len = 0;temp_len &lt;len; temp_len++)
    {
        filed[obspos[temp_len][0]][obspos[temp_len][1]] = 3;
    }




// 打印栅格矩阵数值
for(int r = 0; r &lt; rows; r++)
    {
for(int c = 0; c &lt; cols; c++)
        {
cout&lt;&lt;filed[r][c]&lt;&lt;" ";
        }
cout&lt;&lt;endl;


    }
return 0;
}</code></pre> 
 <p>Tips：对C++编程而言，特殊位置信息的二维数组，作为参数进行传递时候，是不方便编程的。后续优化代码，使其采用线性索引的方式进行编程，实现函数封装，提升通用性。</p> 
 <p style="text-align:left;">本文仅做学术分享，如有侵权，请联系删文。</p> 
 <p style="text-align:left;"><strong></strong><strong></strong><strong>点击进入</strong>—&gt;<a href="" rel="nofollow"><strong>3D视觉工坊学习交流群</strong></a><a href="" rel="nofollow"></a></p> 
 <p style="text-align:left;"><strong>干货下载与学习</strong><br></p> 
 <p style="text-align:left;">后台回复：<strong><strong>巴塞罗</strong></strong><strong><strong>那</strong></strong><strong>自治大学课件，</strong>即可下载国外大学沉淀数年3D Vison精品课件</p> 
 <p style="text-align:left;">后台回复：<strong>计算机视觉</strong><strong>书籍，</strong>即可下载3D视觉领域经典书籍pdf</p> 
 <p style="text-align:left;">后台回复：<strong>3D视觉课程，</strong>即可学习3D视觉领域精品课程</p> 
 <p style="text-align:center;"><strong><strong>3D视觉工坊精品课程官网：</strong><strong>3dcver.com</strong></strong></p> 
 <p style="text-align:left;">1<a href="" rel="nofollow">.面向自动驾驶领域的3D点云目标检测全栈学习路线！(单模态+多模态/数据+代码)</a><br><a href="" rel="nofollow">2.彻底搞透视觉三维重建：原理剖析、代码讲解、及优化改进</a><br><a href="" rel="nofollow">3.国内首个面向工业级实战的点云处理课程</a><br>4<a href="" rel="nofollow">.激光-视觉-IMU-GPS融合SLAM算法梳理和代码讲解</a><br>5<a href="" rel="nofollow">.彻底搞懂视觉-惯性SLAM：基于VINS-Fusion正式开课啦</a><br><a href="" rel="nofollow">6.彻底搞懂基于LOAM框架的3D激光SLAM: 源码剖析到算法优化</a><br><a href="" rel="nofollow">7.彻底剖析室内、室外激光SLAM关键算法原理、代码和实战(cartographer+LOAM +LIO-SAM)</a></p> 
 <p style="text-align:left;"><a href="" rel="nofollow">8.从零搭建一套结构光3D重建系统[理论+源码+实践]</a></p> 
 <p style="text-align:left;">9<a href="" rel="nofollow">.单目深度估计方法：算法梳理与代码实现</a></p> 
 <p style="text-align:left;"><a href="" rel="nofollow">10.自动驾驶中的深度学习模型部署实战</a></p> 
 <p style="text-align:left;"><a href="" rel="nofollow">11.相机模型与标定(单目+双目+鱼眼）</a></p> 
 <p style="text-align:left;"><a href="" rel="nofollow">12.重磅！四旋翼飞行器：算法与实战</a></p> 
 <p style="text-align:left;"><a href="" rel="nofollow">13.ROS2从入门到精通：理论与实战</a></p> 
 <p style="text-align:left;"><a href="" rel="nofollow">14.国内首个3D缺陷检测教程：理论、源码与实战</a></p> 
 <p style="text-align:left;"><a href="" rel="nofollow">15.基于Open3D的点云处理入门与实战教程</a></p> 
 <p style="text-align:left;"><a href="" rel="nofollow">16.透彻理解视觉ORB-SLAM3：理论基础+代码解析+算法改进</a></p> 
 <p style="text-align:left;"><a href="" rel="nofollow">17.机械臂抓取从入门到实战</a></p> 
 <h3></h3> 
 <p style="text-align:center;"><strong>重磅！粉丝学习</strong><strong>交流群</strong><strong>已成立</strong></p> 
 <h3></h3> 
 <p style="text-align:left;">交流群主要有<strong>3D视觉、CV&amp;深度学习、SLAM、三维重建、点云后处理、自动驾驶、多传感器融合、CV入门、三维测量、VR/AR、3D人脸识别、医疗影像、缺陷检测、行人重识别、目标跟踪、视觉产品落地、视觉竞赛、车牌识别、硬件选型、ORB-SLAM系列源码交流、深度估计、TOF、<strong>求职交流</strong></strong>等方向。</p> 
 <p style="text-align:left;">扫描以下二维码，添加小助理微信（<strong>dddvisiona</strong>）,一定要备注：<strong>研究方向+学校/公司+昵称</strong>，例如：”3D视觉 + 上海交大 + 静静“。请按照格式备注，可快速被通过且邀请进群。<strong>原创投稿</strong>也请联系。</p> 
 <h3></h3> 
 <p><img src="https://images2.imgbox.com/54/30/y4WI9sRr_o.png" alt="600aabcf03052adb587512d88697957a.jpeg"></p> 
 <p>▲长按加微信群或投稿，微信号：dddvisiona</p> 
 <h3></h3> 
 <p style="text-align:left;"><strong>3D视觉从入门到精通知识星球</strong>：针对3D视觉领域的<strong>视频课</strong><strong>程</strong>（三维重建系列、三维点云系列、结构光系列、手眼标定、相机标定、激光/视觉SLAM、自动驾驶等）<strong>、</strong><strong>源码分享、</strong><strong>知识点汇总、入门进阶学习路线、最新paper分享、疑问解答等</strong>进行深耕，更有各类大厂的算法工程人员进行技术指导。与此同时，星球将联合知名企业发布3D视觉相关算法开发<strong>岗位以及项目</strong>对接信息，打造成集技术与就业为一体的铁杆粉丝聚集区，6000+星球成员为创造更好的AI世界共同进步，知识星球入口：</p> 
 <h3></h3> 
 <p style="text-align:center;">学习3D视觉核心技术，扫描查看，3天内无条件退款</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/61/ee/0bMDUAgb_o.png" alt="abde8672fc3fed399319de1d79c86ccb.jpeg"></p> 
 <p style="text-align:center;">高质量教程资料、答疑解惑、助你高效解决问题</p> 
 <p style="text-align:right;"><strong>觉得有用，麻烦给个赞和在看~</strong><strong>  </strong></p> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eae9e3bc28fb18097c415f2356562667/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">shell编程之变量置换</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4a15c6466aa59acba7749ce6dec9a395/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CSS基本知识点总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>