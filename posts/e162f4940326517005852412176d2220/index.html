<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>20150902 --Oracle学习笔记 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="20150902 --Oracle学习笔记" />
<meta property="og:description" content="第二天 基本概念–数据库服务器、数据主和表的关系 所谓安装数据库服务器，只是在机器上装了一个数据库管理程序，这个管理程序可以管理多个数据库，一般开发人员会针对每个应用创建一个数据库。 为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体的数据。 数据库服务器、数据库和表的关系如图所示：
基本概念–数据在数据库中的存储方式 数据存在方式(主要是以表的形式)
表的管理–创建表(基本语句) 建表的基本语法： create table table_name( field1 datatype, field1 datatype, field1 datatype, … ) 注:table_name表名；field指定列名(字段名)；datatype指定列类型(字段数据类型) 注意：创建表时，要根据需保存的数据创建相应的列，并根据数据的类型定义相应的列类型。 例：user对象 id int name string password string birthday date
快速入门示例： SQL&gt; create table users( id number, name varchar2(32), password varchar2(32), birthday date); Id Name Password birthday
表的管理–oracle常用数据类型 分类 数据类型 说明 文本、二进制类型 char(size) char(20) varchar(size) varchar(20) nchar(n) nvarchar2(n) clob(character large object) blob(binary large object) 定长 最大2000字符 变长 最大4000字符 Unicode数据类型，定长 最大2000字符 Unicode数据类型，变长 最大4000字符 字符型大对象，最大8TB 二进制数据 可以存放图片/声音 8TB 数值类型 number(p,s) p为整数位,s为小数位." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/e162f4940326517005852412176d2220/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-09-02T20:16:53+08:00" />
<meta property="article:modified_time" content="2015-09-02T20:16:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">20150902 --Oracle学习笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>第二天 <br> 基本概念–数据库服务器、数据主和表的关系 <br> 所谓安装数据库服务器，只是在机器上装了一个数据库管理程序，这个管理程序可以管理多个数据库，一般开发人员会针对每个应用创建一个数据库。 <br> 为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体的数据。 <br> 数据库服务器、数据库和表的关系如图所示：</p> 
<p>基本概念–数据在数据库中的存储方式 <br> 数据存在方式(主要是以表的形式)</p> 
<p>表的管理–创建表(基本语句) <br> 建表的基本语法： <br> create table table_name( <br> field1 datatype, <br> field1 datatype, <br> field1 datatype, <br> … <br> ) <br> 注:table_name表名；field指定列名(字段名)；datatype指定列类型(字段数据类型) <br> 注意：创建表时，要根据需保存的数据创建相应的列，并根据数据的类型定义相应的列类型。 <br> 例：user对象 <br> id int <br> name string <br> password string <br> birthday date</p> 
<p>快速入门示例： <br> SQL&gt; create table users( <br> id number, <br> name varchar2(32), <br> password varchar2(32), <br> birthday date); <br> Id Name Password birthday</p> 
<p>表的管理–oracle常用数据类型 <br> 分类 数据类型 说明 <br> 文本、二进制类型 char(size) char(20) <br> varchar(size) varchar(20) <br> nchar(n) <br> nvarchar2(n) <br> clob(character large object) <br> blob(binary large object) 定长 最大2000字符 <br> 变长 最大4000字符 <br> Unicode数据类型，定长 最大2000字符 <br> Unicode数据类型，变长 最大4000字符 <br> 字符型大对象，最大8TB <br> 二进制数据 可以存放图片/声音 8TB <br> 数值类型 number(p,s) p为整数位,s为小数位.范围： <br> 1&lt;=p&lt;=38,-84&lt;=s&lt;=127 <br> 保存数据范围： <br> -1.0e-130&lt;=number value&lt;1.0e+126 <br> 保存在机器内部的范围： <br> 1～22 bytes <br> 时间日期 Date</p> 
<p>TIMESTAMP(n)邮戳 包含年月日，时分秒。默认格式:DD-MON-YYYY。从公元前4712年1月1日到公元4712年12月31日的所有合法日期 <br> n的取值为0-9，表示指定TIMESTAMP中秒的小数位数。N为可选。如果n为0,timestamp与date等价(不推荐) <br> number可以理解成是一个可变的数据类型，比如number(12)，你放一个小整数，它占用的字节数就少，你放一个大整数，它占用的字节数就多。</p> 
<p>oracle数据类型 <br> 1、char(size)存放字符串，它最大可以存放2000个字符，是定长。 <br> 举例说明： <br> create table test1(name char(32));//test1表中的name字段最多存放32个字符，不足32个字符oracle会用空格补齐,如果超过会报错。</p> 
<p>2、varchar2(size)存放字符串，它最大可以存放4000个字符，是变长。 <br> 举例说明： <br> create table test2(name varchar2(16));//test2表中的name字段最多存放16个字符，实际有几个字符就占几个字符的空间，如果超过会报错。</p> 
<p>特别说明：如果我们的数据的长度是固定的，比如商品编号(8位)，则应当使用char来存放，因为这样存取的速度就会提高。如果存放的数据长度是变化的，则使用varchar2来存放。</p> 
<p>3、nchar(n)以Unicode编码来存放字符串，它最大可以存放2000个字符，是定长。 <br> 举例说明： <br> create table test3(name nchar(32));//与char类似，只是以Unicode编码存放字符串</p> 
<p>4、nvarchar(n)以Unicode编码来存放字符串，它最大可以存放4000个字符，是变长。 <br> 举例说明： <br> create table test4(name nvarchar2(16));//与varchar2类似，只是以Unicode编码存放字符串 <br> 特别说明：nchar和nvarchar2与char和varchar2的区别在于，nchar和nvarchar2不论存放英文字符或中文字符都只占1个字符。如存放a和存放’中’都只占1个字符位。而char和varchar2存放a占1个字符而存放’中’则占2个字符。</p> 
<p>5、clob字符型大对象，它最大可以存放8TB，是变长。 <br> 与字符型的char/varchar2/nchar/nvarchar2的使用方式一样。</p> 
<p>6、blob二进制数据，可存放图片、声音，它最大可以存放8TB，是变长。 <br> 与字符型的char/varchar2/nchar/nvarchar2的使用方式一样。 <br> 注意：一般情况下很少使用数据库来存放媒体类文件，一般只使用数据库来记录媒体类文件的URL地址。如果考虑到文件的安全性，可以存放到数据库中来保存。</p> 
<p>7、number可以存放整数，也可存放小数，是变长。 <br> number(p,s)//p代表整数位，s代表小数位 <br> 保存数据范围：-1.0e-130至1.0e+126；保存在机器内部的范围：1～22bytes <br> 特别说明： <br> 有效位：从左到右，第一个非0数就是第一个有效位。 <br> s&gt;0精确到小数点右边s位，并四舍五入。然后检验有效位是否&lt;=p <br> s&lt;0精确到小数点左边s位，并四舍五入。然后检验有效位是否&lt;=p+|s| <br> s=0等价于number(p)此时number表示整数。 <br> 说明：-1.0e-130(科学计数法)：就是-1.0乘以10的-130次方 <br> 1.0e+126：就是1.0乘以10的126次方 <br> 举例说明： <br> number(5,2) <br> 表示一个小数有5位有效数，2位小数。范围-999.99～999.99 <br> 如果数值超出了位数限制就会被截取多余的位数。但在一行数据中的这个字段输入575.316，则真正保存到字段中的数值是575.32。</p> 
<p>number(5)&lt;=&gt;number(5,0) <br> 表示一个五位整数，范围-99999～99999。 <br> 输入57523.316，真正保存的数据是57523</p> 
<p>oracle表的管理–oracle支持的数据类型 <br> 数值型(练习) <br> Actual Data Specified AS Stored As Actual Data Specified AS Stored As <br> 123.89 NUMBER 123.89 123.2564 NUMBER 123.2567 <br> 123.89 NUMBER(3) 124 1234.9876 NUMBER(6,2) 1234.99 <br> 123.89 NUMBER(6,2) 123.89 12345.123456 NUMBER(6,2) Error <br> 123.89 NUMBER(6,1) 123.9 1234.9876 NUMBER(6) 1235 <br> 123.89 NUMBER(4,2) Error 12345.345 NUMBER(5,-2) 12300 <br> 123.89 NUMBER(6,-2) 100 1234567 NUMBER(5,-2) 1234600 <br> .01234 NUMBER(4,5) .01234 12345678 NUMBER(5,-2) Error <br> .00012 NUMBER(4,5) .00012 123456789 NUMBER(5,-4) 123460000 <br> .000127 NUMBER(4,5) .00013 1234567890 NUMBER(5,-4) Error <br> .0000012 NUMBER(2,7) .0000012 12345.58 NUMBER(*,1) 12345.6 <br> .00000123 NUMBER(2,7) .0000012 0.1 NUMBER(4,5) Error <br> 1.2e-4 NUMBER(2,5) 0.00012 0.01234567 NUMBER(4,5) 0.01235 <br> 1.2e-5 NUMBER(2,5) 0.00001 0.09999 NUMBER(4,5) 0.09999</p> 
<p>8、date，用于表示时间，(年/月/日/时/分/秒)，是定长。 <br> 举例说明： <br> create table test5(birthday date);//添加时个要使用默认格式insert into test5 values(‘11-11月-11’);如使用insert into test5 values(‘2011-11-11’);则报错。 <br> 特别说明：oracle日期有默认格式为：DD-MON-YYYY,天-月-年；如果我们希望使用自己习惯的日期添加，也可以，但是需要借助oracle函数来添加。</p> 
<p>oracle表的管理–创建表 <br> 建表–学生表 <br> 字段 字段类型 <br> id 整型 number <br> name 字符型 varchar2 <br> sex 字符型 char <br> brithday 日期型 date <br> fellowship 小数型 number(6,2) <br> resume 大文本型 clob</p> 
<p>学生表 <br> SQL&gt;create table students( <br> id number, <br> name varchar2(64), <br> sex char(2), <br> brithday date, <br> fellowship number(10,2), <br> resume clob <br> );</p> 
<p>班级表 <br> SQL&gt;create table class_( <br> class_id number, <br> class_name varchar2(32) <br> );</p> 
<p>oracle表的管理–修改表 <br> 使用alter table语句添加、修改或删除列的语法 <br> 添加列基本语法： <br> alter table TABLENAME add(columnname datatype); <br> alter table 表名 add(列名(字段名) 列类型(字段类型));</p> 
<p>修改列基本语法： <br> alter table TABLENAME modify(columnname datatype); <br> alter table 表名 modify(列名(字段名) 列类型(字段类型));</p> 
<p>删除列基本语法： <br> 删除多列语法： <br> alter table TABLENAME drop(columnname,columnname2,…); <br> alter table 表名 drop(列名(字段名),列名2(字段名2),…); <br> 删除单列语法： <br> alter table TABLENAME drop column COLUMNNAME; <br> alter table 表名 drop column 列名(字段名);</p> 
<p>修改表的名称基本语法： <br> rename OldTableName to NewTableName; <br> rename 表名 to 新表名; <br> 修改列名基本语法： <br> alter table TABLENAME rename(OldColumnName to NewColumnName); <br> alter table 表名 rename(旧列名 to 新列名); <br> 查看表结构基本语法： <br> desc TABLENAME; <br> desc 表名;</p> 
<p>练习： <br> 1、给学生表添加班级编号 <br> SQL&gt;alter table students add(class_id number);</p> 
<p>2、学生姓名变成varchar2(30) <br> SQL&gt;alter table students modify(name varchar2(30));</p> 
<p>3、学生姓名变成char(30) <br> SQL&gt;alter table students modify(name char(30));</p> 
<p>4、删除学生表的fellowship字段 <br> SQL&gt;alter table students drop column fellowship; <br> SQL&gt;alter table students drop(fellowship);</p> 
<p>5、把学生表名students修改成stu <br> SQL&gt;rename students to stu;</p> 
<p>6、删除学生表 <br> SQL&gt;drop table stu;</p> 
<p>oracle表的管理–添加数据 <br> 使用insert语句向表中插入数据 <br> 插入数据基本语法： <br> insert into table[(column [,column…])] values(value [,value…]); <br> insert into 表名[(列名 [,列名2…])] values(值 [,值2…]); <br> 注意事项： <br> 1、插入的数据应与字段的数据类型相同。 <br> 2、数据的大小应在列的规定范围内，例如：不能将一个长度为80的字符串加入到长度为40的列中。 <br> 3、在values中列出的数据位置必须与被加入的列的排列位置相对应。 <br> 4、字符和日期型数据应包含在单引号中。 <br> 5、插入空值，不指定或insert into table values(null); <br> 6、给表的所有列添加数据时，可以不带列名直接添加values值。</p> 
<p>向students添加数据 <br> SQL&gt;insert into students (id,name,sex,brithday,fellowship,resume) values(1,’张三’,’男’,’11 <br> -11月-01’,23.34,’hello’); <br> SQL&gt;insert into students values(2,’李四’,’男’,’11-11月-02’,67.34,’hello2’); <br> SQL&gt;insert into students values(3,’王五’,’女’,’11-11月-03’,671.34,’hello3’);</p> 
<p>插入部分字段与插入空值，语法是一样的。只是要注意，当字段设置可为空时，可以不用将字段列出。否则就需要将字段名和值添加进去。否则报错，具体参见上述插入数据6点注意事项。 <br> insert into table[(column [,column…])] values(value [,value…]);</p> 
<p>oracle表的管理–修改数据 <br> 使用update语句修改表中数据。 <br> Update语句基本语法： <br> update tablename set columnname=expr1 [,columnname2=expr2,…][where where_definition]; <br> update 表名 set 列名=表达式 [,列名2=表达式2,…][where 条件]; <br> 注意事项： <br> 1、update语法可以用新值更新原有表行中的各列； <br> 2、set子句指示要修改哪些列和要给予哪些值； <br> 3、where子句指定应更新哪些行。如没有where子句，则更新所有的行。(特别小心)</p> 
<p>对students中的数据进行修改 <br> 将张三的性别改成女 <br> SQL&gt;update students set sex=’女’ where name=’张三’; <br> 把张三的奖学金改为10 <br> SQL&gt;update students set fellowship=10 where name=’张三’; <br> 把所有人的奖金都指高10% <br> SQL&gt;update students set fellowship=fellowship*1.1;</p> 
<p>练习： <br> 将所有学生奖学金修改为5000元 <br> SQL&gt;update students set fellowship=5000;</p> 
<p>将姓名为’张三’的学生奖学金修改为3000元 <br> SQL&gt;update students set fellowship=3000 where name=’张三’;</p> 
<p>将’李四’的奖学金在原有基础上增加1000元 <br> SQL&gt;update students set fellowship=fellowship+1000 where name=’李四’;</p> 
<p>将没有奖学金同学的奖学金改成10元 <br> SQL&gt;update students set fellowship=10 where fellowship is null; <br> 特别注意：当修改空记录时应用is null而不能使用=null或=”</p> 
<p>oracle表的管理–删除数据 <br> 基本语法： <br> delete from TABLENAME [where where_definition]; <br> delete from 表名 [where 条件表达式]; <br> 注意事项： <br> 1、如果不使用where子句，将删除表中所有的数据。(特别注意) <br> 2、delete语句不能删除某一列的值(可使用update)。 <br> 3、使用delete语句仅删除记录，不删除表本身。如要删除表，使用drop table语句。 <br> 4、同insert和update一样，从一个表中删除记录将引起其它表的参照完整性问题，在修改数据库数据时，头脑中应始终不要忘记这个潜在的问题。</p> 
<p>删除的几种方法比较： <br> delete from 表名; <br> 删除所有记录，表结构还在，写日志，可以恢复的，速度慢 <br> drop table 表名; <br> 删除表的结构和数据 <br> delete from student where xh=’A001’; <br> 删除一条记录 <br> truncate table 表名; <br> 删除表中的所有记录，表结构还在，不写日志，无法找回删除的记录，速度快。</p> 
<p>设置保存点 <br> savepoint 保存点名称; <br> 回滚 <br> rollback to 保存点名称; <br> 特别注意：设置保存点及回滚操作是配合delete语句使用，用来找回使用delete删除的数据。而通过truncate删除的表数据是无法通过此方法找回的。 <br> 建议： <br> 在使用delete删除表数据前使用savepoint设置保存点，防止数据误删除。</p> 
<p>oracle表基本查询–介绍 <br> 在我们讲解的过程中我们利用scott用户存在的几张表(emp,dept,salgrade)为大家演示如何使用select语句，select语句在软件编程中非常的有用，希望大家好好的掌握。</p> 
<p>基本select语句 <br> 基本语法： <br> select [distinct] *|{columnl,column2,column3..} from table [where {condition}]; <br> select [是否剔除重复数据] *|{字段名(列名),字段名2(列名2),字段名3(列名3)..} from 表名 [where {条件}];注意事项： <br> 1、select指定查询哪些列的数据； <br> 2、column指定列名； <br> 3、*代表查询所有列； <br> 4、from指定查询哪张表； <br> 5、distinct可选，指显示结果时，是否剔除重复数据； <br> 6、where条件。</p> 
<p>oracle表基本查询–简单的查询语句 <br> 查看表结构 <br> SQL&gt;desc 表名;</p> 
<p>查询所有列 <br> SQL&gt;select * from 表名;</p> 
<p>查询指定列 <br> SQL&gt;select 列1,列2,列3,.. from 表名;</p> 
<p>如何取消重复行 <br> SQL&gt;select distinct deptno,job from emp;</p> 
<p>查询SMITH的薪水，工作，所在部门 <br> SQL&gt;select sal,job,deptno from emp where ename=’SMITH’; <br> 特别注意：oracle对sql语句不区分大小写，但对查询内容区分大小写。这与sqlserver是有区别的，sqlserver对查询内容不区分大小写。</p> 
<p>使用算数表达式 <br> 显示每个雇员的年工资 <br> SQL&gt;select ename,sal*13+nvl(comm,0)*13 from emp;</p> 
<p>使用列的别名 <br> SQL&gt;select ename “姓名”,sal*13+nvl(comm,0)*13 “年收入” from emp; <br> SQL&gt;select ename 姓名,sal*13+nvl(comm,0)*13 年收入 from emp; <br> SQL&gt;select ename as “姓名”,sal*13+nvl(comm,0)*13 as “年收入” from emp; <br> 特别注意：oracle在使用别名时，可以用双引号或不使用或使用as来表明别名。但不能使用单引号。sqlserver是可以使用双引号、单引号。</p> 
<p>如何处理null值 <br> 使用nvl函数来处理 <br> nvl函数的使用，说明：nvl是oracle提供的函数，是用于处理null值使用的。sqlserver提供的则是isnull函数来处理null值。 <br> SQL&gt;select ename,sal*13+nvl(comm,0)*13 from emp; <br> nvl(值1,值2) 解释：nvl值1为null时则取值2，值1不为null时则取值1原值。</p> 
<p>如何连接字符串(||) <br> SQL&gt;select ename ||’年收入’||(sal*13+nvl(comm,0)*13) “雇员的年收入” from emp; <br> ||在查询的时候，希望把多列内容做为一列内容返回可以使用||连接符。</p> 
<p>面试题： <br> 我们希望删除用户，同时保留该用户的数据对象，怎么处理？ <br> 1、oracle是锁定该用户。 <br> SQL&gt;alter user scott account lock;//锁定用户 <br> 2、这时用户已不能登录到数据库，但system用于依然可以使用它的数据对象。 <br> 3、解锁命令 <br> SQL&gt;alter user scott account unlock;//用户解锁</p> 
<p>oracle表基本查询–简单的查询语句 <br> 使用where子句 <br> 如何显示工资高于3000的员工 <br> SQL&gt;select ename,sal from emp where sal&gt;3000;</p> 
<p>如何查找1982.1.1后入职的员工 <br> SQL&gt;select ename,hiredate from emp where hiredate&gt;’1-1月-82’; <br> 也可以使用to_char函数转换日期类型后再进行日期比较，如下： <br> SQL&gt;select ename,hiredate from emp where to_char(hiredate,’yyyy-mm-dd’)&gt;’1982-1-1’; <br> 字符对比还是有一定出入的。不推荐使用。</p> 
<p>如何显示工资在2000到2500的员工情况 <br> SQL&gt;select * from emp where sal&gt;=2000 and sal&lt;=2500; <br> SQL&gt;select * from emp where sal between 2000 and 2500; <br> 说明：between是指定区间内取值，如：between 2000 and 2500，取2000至2500内的值，同时包含2000和2500</p> 
<p>如何使用like操作符 <br> %:表示任意0到多个字符 <br> _:表示任意单个字符 <br> 如何显示首字符为S的员工姓名和工资 <br> SQL&gt;select ename,sal from emp where ename like ‘S%’;</p> 
<p>如何显示第三个字符为大写O的所有员工的姓名和工资 <br> SQL&gt;select ename,sal from emp where ename link ‘__O%’;</p> 
<p>在where条件中使用in <br> 如何显示empno为123,345,800…的雇员情况 <br> SQL&gt;select * from emp where empno=123 or empno=345 or emp=800; <br> SQL&gt;select * from emp where empno in(123,345,800); </p> 
<p>使用is null的操作符 <br> 如何显示没有上级的雇员的情况 <br> SQL&gt;select * from emp where mgr is null;</p> 
<p>使用逻辑操作符号 <br> 查询工资高于500或是岗位为manager的雇员，同时还要满足他们的姓名首写字母为大写的J <br> SQL&gt;select * from emp where (sal&gt;500 or job=’MANAGER’) and (ename like ‘J%’);</p> 
<p>使用order by子句 <br> 如何按照工资的从低到高的顺序显示雇员的信息 <br> SQL&gt;select * from emp order by sal asc; <br> 注意：asc写或不写都是升序排序即从小到大排序，desc则是降序排序从大到小排序。</p> 
<p>按照部门号升序而雇员的入职时间降序排列 <br> SQL&gt;select * from emp order by deptno,hiredate desc;</p> 
<p>使用列的别名排序 <br> SQL&gt;select ename,sal*12 “年薪” from emp order by “年薪” asc; <br> 别名需要使用“”号圈中。</p> 
<p>oracle表复杂查询 <br> 在实际应用中经常需要执行复杂的数据统计，经常需要显示多张表的数据，现在我们给大家介绍较为复杂的select语句</p> 
<p>数据分组-max,min,avg,sum,count(分组函数) <br> 如何显示所有员工中最高工资和最低工资 <br> SQL&gt;select max(sal) “最高工资”,min(sal) “最低工资” from emp;</p> 
<p>请查询最高年工资 <br> SQL&gt;select max(sal*13+nvl(comm,0)*13) “最高年工资”,min(sal*13+nvl(comm,0)*13) “最低年工资” from emp;</p> 
<p>显示所有员工的平均工资和工资总和 <br> SQL&gt;select avg(sal) “平均工资”,sum(sal) “工资总和” from emp; <br> 特别注意：avg(sal)不会把sal为null的行进行统计，因此我们要注意，如果，你希望为空值也考虑，则我们可以这样做 <br> SQL&gt;selec sum(sal)/count(*) from emp;</p> 
<p>计算共有多少员工 <br> SQL&gt;select count(*) “共有员工” from emp;</p> 
<p>扩展要求： <br> 请显示工资最高的员工的名字，工作岗位 <br> SQL&gt;select ename,job from emp where sal=(select max(sal) from emp); <br> 特别注意：select语句执行的顺序是从右向左执行，正好和书写的方式相反。 <br> SQL&gt;select ename,job from emp where sal=(select max(sal) from emp); <br> oracle会先执行select max(sal) from emp这个语句，得出最大工资后。再执行where条件前的语句。</p> 
<p>请显示工资高于平均工资的员工信息 <br> SQL&gt;select * from emp where sal&gt;(select avg(sal) from emp); <br> SQL&gt;select * from emp where sal&gt;(select sum(sal)/count(*) from emp);</p> 
<p>oracle表复杂查询 <br> group by和having子句 <br> group by用于对查询的结果分组统计；（配合分组函数使用） <br> having子句用于限制(过滤)分组显示结果。（对分组后再使用）</p> 
<p>如何显示每个部门的平均工资和最高工资 <br> SQL&gt;select avg(sal) “平均工资”,max(sal) “最高工资”,deptno “部门编号” from emp group by deptno;</p> 
<p>显示每个部门的每种岗位的平均工资和最低工资 <br> SQL&gt;select avg(sal) “平均工资”,min(sal) “最低工资”,job “职位”,deptno “部门编号” from emp group by deptno,job order by deptno;</p> 
<p>显示部门平均工资低于2000的部门号和它的平均工资 <br> SQL&gt;select avg(sal) “平均工资”,deptno “部门编号” from emp group by deptno having avg(sal)&lt;2000;</p> 
<p>对数据分组的总结： <br> 1、分组函数(avg…)只能出现在选择列表、having、order by子句中； <br> 2、如果在select语句中同时包含有group by/having/order by那么他们的顺序是group by/having/order by； <br> 3、在选择列中如果有列、表达式和分组函数，那么这些列和表达式必需有一个出现在group by子句中，否则会出错。 <br> 如select deptno,avg(sal),max(sal) from emp group by deptno having avg(sal)&lt;2000; <br> 这里deptno就一定要出现在group by 中。</p> 
<p>oracle表复杂查询–多表查询 <br> 说明： <br> 多表查询是指基于两个和两个以上的表或是视图的查询，在实际应用中，查询单个表可能不能满足你的需求，(如显示sales部门位置和其员工的姓名)，这种情况下需要使用到(dept表和emp表)</p> 
<p>显示雇员名，雇员工资及所在的部门的名字[笛卡尔集] <br> 规定：多表查询的条件是至少不能少于表的个数-1 <br> 注意：笛卡尔集，在多表查询的时候，如果不带任何条件，则会出现笛卡尔集，避免笛卡尔集多表查询的条件是，至少不能少于表的个数-1 <br> SQL&gt;select e.ename,e.sal,d.dname from emp e,dept d where d.deptno=e.deptno;</p> 
<p>如何显示部门为10的部门名、员工名和工资 <br> SQL&gt;select d.dname,e.ename,e.sal,e.deptno from emp e,dept d where d.deptno=e.deptno and e.deptno=10;</p> 
<p>显示各个员工的姓名、工资及其工资的级别 <br> SQL&gt;select e.ename,e.sal,s.grade from emp e,salgrade s where e.sal between s.losal and s.hisal; <br> 注意：在多表查询时，不同的表中列名相同时要加表名，不同时可不加。(为增强可读性，建议都加表名或别名)</p> 
<p>扩展要求： <br> 显示雇员名，雇员工资及所在部门的名字，并按部门排序。 <br> SQL&gt;select e.ename,e.sal,d.dname from emp e,dept d where e.deptno=d.deptno order by d.dname;</p> 
<p>oracle表复杂查询–多表查询 <br> 自连接 <br> 自连接是指在同一张表的连接查询</p> 
<p>显示员工的上级领导的姓名 <br> SQL&gt;select e2.ename from emp e1,emp e2 where e1.mgr=e2.empno;</p> 
<p>比如显示’FORD’的上级 <br> SQL&gt;select e1.ename “员工姓名”,e2.ename “领导姓名” from emp e1,emp e2 where e1.mgr=e2.empno and e1.ename=’FORD’;</p> 
<p>扩展要求： <br> 显示各员工的姓名和他的上级领导姓名 <br> SQL&gt;select e1.ename “员工姓名”,e2.ename “领导姓名” from emp e1,emp e2 where e1.mgr=e2.empno; <br> 疑惑：这里我们看到king没有显示，因为king没有上级。如果我们希望把没有上级的员工也显示出来，则需要使用到外连接。外连接包括左外连接和右外连接。此处提到外连接，后面会详细讲解。</p> 
<p>左外连接：select 列名,.. from 表名1 left join 表名2 on 条件; <br> SQL&gt;select e1.ename “员工姓名”,e2.ename “直接上级领导” from emp e1 left join emp e2 on e1.mgr=e2.empno; <br> 或者使用(+)在右边也可以实现左外连接。 <br> SQL&gt;select e1.ename “员工姓名”,e2.ename “领导姓名” from emp e1,emp e2 where e1.mgr=e2.empno(+);</p> 
<p>右外连接：select 列名,.. from 表名1 right join 表名2 on 条件; <br> SQL&gt;select e1.ename “员工姓名”,e2.ename “直接上级领导” from emp e2 right join emp e1 on e1.mgr=e2.empno; <br> 或者使用(+)在左边也可以实现右外连接。 <br> SQL&gt;select e1.ename “员工姓名”,e2.ename “领导姓名” from emp e1,emp e2 where e2.empno(+)=e1.mgr; <br> 左外连接和右外连接在这里提到，后面会详细讲解。</p> 
<p>oracle表复杂查询–子查询 <br> 什么是子查询？ <br> 子查询是指嵌入在其它sql语句中的select语句，也叫嵌套查询。</p> 
<p>单行子查询 <br> 单行子查询是指只返回一行数据的子查询语句。(说的是后面的条件是返回的是一行结果) <br> 请思考：如果显示与smith同一部门的所有员工？ <br> SQL&gt;select * from emp where deptno=(select deptno from emp where ename=’SMITH’); <br> 将SMITH排除在外不显示 <br> SQL&gt;select * from emp where deptno=(select deptno from emp where ename=’SMITH’) and ename&lt;&gt;’SMITH’; <br> SQL&gt;select * from emp where deptno=(select deptno from emp where ename=’SMITH’) and ename!=’SMITH’;</p> 
<p>多行子查询？ <br> 多行子查询指返回多行数据的子查询。（说的是后面的条件是返回的是多行结果） <br> 请思考：如何查询和部门10的工作相同的雇员的名字、岗位、工资、部门号 <br> SQL&gt;select ename,job,sal,deptno from emp where job in (select distinct job from emp where deptno=10); <br> 特别注意：多行子查询是不能使用=号的，=号是单行子查询(由于只返回一个结果所以使用=号)，多行子查询返回的不是一个结果所以要使用in。</p> 
<p>oracle表复杂查询–子查询 <br> 在多行子查询中使用all操作符 <br> 请思考：如何显示工资比部门30的所有员工的工资高的员工的姓名、工资和部门号 <br> SQL&gt;select ename,sal,deptno from emp where sal&gt;all(select sal from emp where deptno=30);</p> 
<p>扩展要求：大家想想还有没有别的查询方法？ <br> SQL&gt;select ename,sal,deptno from emp where sal&gt;(select max(sal) from emp where deptno=30);</p> 
<p>在多行子查询中使用any操作符（比其中任意一个员工工资高即可） <br> 请思考：如何显示工资比部门30的任意一个员工的工资高的员工的姓名、工资和部门号 <br> SQL&gt;select ename,sal,deptno from emp where sal&gt;any(select sal from emp where deptno=30);</p> 
<p>扩展要求：大家想想还有没有别的查询方法？ <br> SQL&gt;select ename,sal,deptno from emp where sal&gt;(select min(sal) from emp where deptno=30);</p> 
<p>多列子查询（后面的条件是列） <br> 单行子查询是指子查询只返回单列、单行数据，多行子查询是指返回单列多行数据，都是针对单列而言的，而多列子查询则是指查询返回多个列数据的子查询语句。</p> 
<p>请思考如何查询与smith的部门和岗位完全相同的所有雇员？ <br> 原始查询方法(不推荐) <br> 多表多列查询： <br> SQL&gt;select * from emp e,dept d where e.deptno=d.deptno and d.dname=(select d.dname from emp e,dept d where e.deptno=d.deptno and e.ename=’SMITH’) and e.job=(select job from emp where ename=’SMITH’);</p> 
<p>单表多列查询： <br> SQL&gt;select * from emp where deptno=(select deptno from emp where ename=’SMITH’) and job=(select job from emp where ename=’SMITH’);</p> 
<p>多列查询(优化方法，在oracle下推荐使用) <br> SQL&gt;select * from emp where (deptno,job)=(select deptno,job from emp where ename=’SMITH’); <br> 特别注意：查询的列要与返回的列名相对应，顺序不能出错。否则报错。</p> 
<p>练习题： <br> 1、以下哪条语句是错误的？D <br> A、select empno,ename name,sal salary from emp; <br> B、select empno,ename name,sal as salary from emp; <br> C、select ename,sal*12 as “annual salary” from emp; <br> D、select ename,sal*12 annual salary from emp; <br> select ename,sal*12 “annual salary” from emp;</p> 
<p>2、某用户希望显示补助非空的所有雇员信息，应该使用哪条语句？B <br> A、select ename,sal,comm from emp where comm&lt;&gt;null; <br> B、select ename,sal,comm from emp where comm is not null; <br> C、select ename,sal,comm from emp where comm&lt;&gt;0;</p> 
<p>3、以下哪条语句是错误的？C <br> A、select ename,sal salary from emp order by sal; <br> B、select ename,sal salary from emp order by salary; <br> C、select ename,sal salary from emp order by 3;//order by支持数字排序，但不能越界。 <br> 注意：数字表示列select ename,sal salary from emp order by 2 表示按第二列升序</p> 
<p>4、查看dept表和emp表的结构。 <br> SQL&gt;desc dept; <br> SQL&gt;desc emp;</p> 
<p>5、使用简单查询语句完成 <br> (1)显示所有部门名称 <br> SQL&gt;select dname from dept;</p> 
<p>(2)显示所有雇员名及其全年收入13月(工资+补助)，并指定列名”年收入”。 <br> SQL&gt;select ename,sal*13+nvl(comm,0)*13 “年收入” from emp;</p> 
<p>(3)显示存在雇员的所有部门号 <br> SQL&gt;select distinct deptno from emp where ename is not null;</p> 
<p>6、限制查询数据 <br> (1)显示工资超过2850的雇员姓名和工资 <br> SQL&gt;select ename,sal from emp where sal&gt;2850;</p> 
<p>(2)显示工资不在1500到2850之间的所有雇员名和工资 <br> SQL&gt;select ename,sal from emp where sal&lt;1500 or sal&gt;2850; <br> select ename,sal from emp where sal between 1500 and 2850;</p> 
<p>(3)显示代码为7566的雇员姓名及所在部门代码 <br> SQL&gt;select ename,deptno from emp where empno=7566;</p> 
<p>(4)显示部门10和30中工资超过1500的雇员名及工资 <br> SQL&gt;select ename,sal from emp where deptno in(10,30) and sal&gt;1500; <br> SQL&gt;select ename,sal from emp where (deptno=10 or deptno=30) and sal&gt;1500;</p> 
<p>(5)显示无管理者的雇员名及岗位 <br> SQL&gt;select ename,job from emp where mgr is null;</p> 
<p>7、排序数据 <br> (1)显示在1981年2月1日至1981年5月1日之间雇用的雇员名、岗位及雇佣日期，并以雇佣日期进行排序 <br> SQL&gt;select ename,job,hiredate from emp where hiredate between ‘1-2月-81’ and ‘1-5月-81’ order by hiredate; <br> SQL&gt;select ename,job,hiredate from emp where to_char(hiredate,’yyyy-mm-dd’) between ‘1981-02-01’ and ‘1981-05-01’ order by hiredate;</p> 
<p>(2)显示获得补助的所有雇员名、工资及补助，并以工资和补助降序排序。 <br> select ename,sal,comm from emp where comm is not null order by sal desc,comm desc;</p> 
<p>oracle表复杂查询–子查询 <br> 在from子句中使用子查询<strong>此知识点必需掌握</strong> <br> 请思考：如何显示高于自己部门平均工资的员工的信息??? <br> 这里要用到数据查询的小技巧，把一个子查询当作一个临时表使用。 <br> SQL&gt;select e.ename,e.sal,t1.myavg,e.deptno from emp e,(select avg(sal) myavg,deptno from emp group by deptno) t1 where e.deptno=t1.deptno and e.sal&gt;t1.myavg order by e.deptno; <br> 下面方法不推荐使用(无法取出子查询(临时表)的值) <br> SQL&gt;select e.* from emp e where e.sal&gt;(select avg(sal) from emp where deptno=e.deptno); <br> 注意： 分组函数一定要别名 </p> 
<p>在from子句中使用子查询 <br> 请思考：查找每个部门工资最高的人的详细资料 <br> 思路：得到所有的员工，进行筛选，每拿到一个员工，判断该员工的工资是否是他们部门的最高工资。 <br> SQL&gt;select e.*,t1.mysal from emp e,(select max(sal) mysal,deptno from emp group by deptno) t1 where e.deptno=t1.deptno and e.sal&gt;=t1.mysal order by e.deptno;</p> 
<p>SQL&gt;select * from emp where sal in (select max(sal) from emp group by deptno) order by deptno;</p> 
<p>SQL&gt;select * from emp e where sal=(select max(sal) from emp where deptno=e.deptno) order by deptno;</p> 
<p>在from子句中使用子查询 <br> 请思考：显示每个部门的信息(编号、名称)和人员数量？？？，我们一起完成。 <br> SQL&gt;select distinct d.deptno,d.dname,t1.myuser from dept d,(select deptno,count(*) myuser from emp group by deptno) t1 where d.deptno=t1.deptno(+) order by d.deptno;</p> 
<p>SQL&gt;select distinct d.deptno,d.dname,t1.myuser from dept d left join (select deptno,count(*) myuser from emp group by deptno) t1 on d.deptno=t1.deptno order by d.deptno;</p> 
<p>在from子句中使用子查询 <br> 这里需要说明的当在from子句中使用子查询时，该子查询会被作为一个临时表来对待，当在from子句中使用子查询时，必需给予查询指定别名。</p> 
<p>oracle表复杂查询–子查询 <br> 分页查询是我们学习任何一种数据库，必需掌握的一个要点。 <br> mysql数据库的分页查询说明： <br> select * from 表名 where 条件 limit 从第几条取,取几条;</p> 
<p>sqlserver数据库的分页查询说明： <br> select top 4 * from 表名 where id not in (select top 4 id from 表名 where 条件); <br> 意思：排除前4条，再取4条记录。实际从第5条取到第8条。 <br> 详细说明： <br> select top 4 说明取4条记录； <br> select top 4 * from 表名 where 列名 not in (select top 4 列名 from 表名 where 条件); <br> 红色的标注为关键字，必需有。 <br> not in (select top 4 列名 from 表名 where 条件)这里top 4说明排除前4条数据，从第5条数据开始取值。</p> 
<p>***oracle数据库的分页查询说明： <br> 特别注意：oracle每张表都有rownum默认字段，默认情况下是不显示的。但是是一直存在的。 <br> select emp.*, rownum from emp <br> select emp.*, rownum from emp where rowm between 3 and 7;(这样是不行的，因为Oracle认为这样效率很低) <br> SQL&gt;select t2.* from (select t1.<em>,rownum rn from (select </em> from emp) t1 where rownum&lt;=6) t2 where rn&gt;=4; <br> 解释： <br> select * from emp //为第一张表，查询表中的所有数据 <br> select t1.* from (select emp.* ,rownum from emp) t1 where t1.rownum&lt;10（错误） <br> select t1.<em>,rownum rn from (select </em> from emp) t1 where rownum&lt;=6 //为第二张表，把表一查到的数据看成一张临时表从中取出前6条数据，并形成第二张临时表。 <br> select t2.* from (select t1.<em>,rownum rn from (select </em> from emp) t1 where rownum&lt;=6) t2 where rn&gt;=4; //为第三张表，把表二中取到的6条数据看成临时表，并从这6条数据中从第4条取到第6条数据，再形成第三张临时表，也就是我们所要查询的最终结果。 <br> 分页查询语法模版： <br> select t2.* from (select t1.<em>,rownum rn from (select </em> from 表名) t1 where rownum&lt;=大范围(取到多少条数据)) t2 where rn&gt;=小范围(从第几条数据开始取); <br> 特别说明：oracle分页查询是通过三层筛选法进行查询的。每一次都可以带where条件来对要查询的信息进行筛选。 <br> 建议：针对不同情况分页查询，尽可能的在最内层(第一层)设置条件，包括多表分页；第二层设置最大取值范围；第三层从第几条数据开始取值。 <br> 上面的这个sql分页查询模版是oracle数据库效率比较高的查询方法，在百万数据级别对数据进行查询都可以及时响应。</p> 
<p>请思考：按照入职时间的先后顺序，查询从第7至第10个人是谁？ <br> SQL&gt;select t2.ename,t2.hiredate,t2.rn from (select t1.<em>,rownum rn from (select </em> from emp order by hiredate) t1 where rownum&lt;=10) t2 where rn&gt;=7;</p> 
<p>看看分页查询的效率 <br> 模拟10万条数据的一个表：此方法用于对数据库进行测试使用。 <br> 以存在的表为模版，创建另一个表。 <br> create table mytest as select empno,ename,sal,comm,deptno from emp; <br> 自我复制(又称蠕虫复制) <br> insert into mytest (empno,ename,sal,comm,deptno) select empno,ename,sal,comm,deptno from mytest;</p> 
<p>oracle的分页查询共三种方法 <br> 1、根据ROWID来分页(速率一般) <br> SQL&gt;select * from emp where rowid in (select rid from (select rownum rn,rid from (select rowid rid,cid from emp order by cid desc) where rownum&lt;10000) where rn&gt;9980) order by cid desc; <br> 看得更清楚点 <br> select * from emp where rowid in <br> (select rid from <br> (select rownum rn,rid from <br> (select rowid rid,cid from emp order by cid desc) <br> where rownum&lt;10000) <br> where rn&gt;9980) <br> order by cid desc;</p> 
<p>2、按分析函数来分页(速率慢) <br> SQL&gt;select * from (select t.*,row_number() over(order by cid desc) rk from emp t) where rk&lt;10000 and rk&gt;9980;</p> 
<p>3、按rownum来分页(推荐使用速率稳定且速率快) <br> SQL&gt;select t2.* from (select t1.<em>,rownum rn from (select </em> from emp) t1 where rn&lt;=10000) t2 where rn&gt;=9980; <br> 看得更清楚一点 <br> select t2.* from <br> (select t1.*,rownum rn from <br> (select * from emp) <br> t1 where rn&lt;=10000) <br> t2 where rn&gt;=9980;</p> 
<p>oracle表复杂查询–子查询 <br> 用查询结果创建新表 <br> 这个命令是一种快捷建表方法(主要用于数据库压力测试使用) <br> 基本语法： <br> create table 新建表名 (列名1,列名2,列名3,..) as select 列名1,列名2,列名3,.. from 已有表名; <br> 说明： <br> 1、新建表名中的列名要与select中的列名一一对应，否则会报错； <br> 2、as关键字不可少；</p> 
<p>自我复制数据(蠕虫复制) <br> 有时，为了对某个sql语句进行效率测试，我们需要海量数据时，可以使用此法为表创建海量数据。 <br> 基本语法： <br> insert into 表名 (列名1,列名2,列名3,..) select 列名1,列名2,列名3,.. from 表名; <br> 说明：表名后的列名要与select后的列名一致，否则会报错。</p> 
<p>oracle表复杂查询–合并查询 <br> 有时在实际应用中，为了合并多个select语句的结果，可以使用集合操作符union,union all,intersect,minus <br> 1、union取并集 <br> 该操作符用于取得两个结果集的并集。当使用该操作符时，会自动去掉结果集中重复行。 <br> select ename,sal,job from emp where sal&gt;2500 union select ename,sal,job from emp where job=’MANAGER’; <br> 解释：union并集，将多条查询结果进行合并，去除相同重复的查询结果。</p> 
<p>2、union all取所有 <br> 该操作符与union相似，但是它不会取消重复行，而且不会排序。 <br> select ename,sal,job from emp where sal&gt;2500 union all select ename,sal,job from emp where job=’MANAGER’; <br> 解释：union all的用法与union相似，但union all不会对多条查询结果进行合并、排序。只会将查询到的所有内容都显示出来，而不象union对查询结果进行合并过滤。</p> 
<p>3、intersect取交集 <br> 使用该操作符用于取得两个结果集的交集。 <br> select ename,sal,job from emp where sal&gt;2500 intersect select ename,sal,job from emp where job=’MANAGER’; <br> 解释：intersect是将多条查询结果，重复部分提取并显示出来。</p> 
<p>4、minus取差集 <br> 使用该操作符用于取得两个结果集的差集，它只会显示存在第一个集合中，而不存在第二个集合中的数据。 <br> select ename,sal,job from emp where sal&gt;2500 minus select ename,sal,job from emp where job=’MANAGER’; <br> 解释：minus取差集，是将前一条查询结果与第二条查询结果进行比较，去除满足条件2，所得到的结果。</p> 
<p>oracle表内连接和外连接(重点) <br> 概述：表连接分为内连接和外连接</p> 
<p>内连接(inner join - on) <br> 内连接实际上就是利用where子句对两张表形成的笛卡尔集进行筛选，我们前面学习的查询都是内连接，也是开发过程中用的最多的连接查询。 <br> 内连接基本语法： <br> select 列名1,.. from 表1 inner join 表2 on 条件; <br> 说明：内连接只有两张表同时满足条件才会被查询到。</p> 
<p>举例：显示员工的信息和部门名称 <br> select e.*,d.dname from emp e,dept d where e.deptno=d.deptno; <br> 等价于 <br> select e.*,d.dname from emp e inner join dept d on e.deptno=d.deptno;</p> 
<p>外连接 <br> 外连接分为三种：左外连接、右外连接、完全外连 <br> 1、 左外连接 (left join - on)(如果左侧的表完全显示我们就说是左外连接) <br> 基本语法： <br> select 列名1,列名2,.. from 表1 left join 表2 on 条件; <br> 或者 <br> select列名1,列名2,.. from 表1,表2 where 条件1=条件2(+); <br> 2、 右外连接 (right join - on)(如果右侧的表完全显示我们就说是右外连接) <br> 基本语法： <br> select 列名1,列名2,.. from 表1 right join 表2 on 条件; <br> 或者 <br> select列名1,列名2,.. from 表1,表2 where 条件1(+)=条件2; <br> 3、完全外连 (full outer join - on)(完全显示两个表，没有匹配的记录置为空) <br> 基本语法： <br> select 列名1,列2,.. from 表1 full outer join 表2 on 条件;</p> 
<p>创建两张表做测试使用stu/exam表 <br> create table stu (id number,name varchar2(32)); <br> insert into stu values(1,’jack’); <br> insert into stu values(2,’tom’); <br> insert into stu values(3,’kity’); <br> insert into stu values(4,’nono’); <br> create table exam (id number,grade number); <br> insert into exam values(1,56); <br> insert into exam values(2,76); <br> insert into exam values(11,8);</p> 
<p>外连接 <br> 1、内连接案例(显示两表ID匹配的) <br> 基本语法：select 字段1,字段2… 表名1 inner join 表名2 on 条件;</p> 
<p>2、左连接(显示所有人的成绩，如果没有成绩，也要显示该人的姓名和id号，成绩显示为空)(右为显示空（左边全部显示）也要显示+写在右边) <br> SQL&gt;select s.id,s.name,e.grade from stu s left join exam e on s.id=e.id; <br> SQL&gt;select s.id,s.name,e.grade from stu s,exam e where s.id=e.id(+);</p> 
<p>3、右外连接(显示所有成绩，如果没有名字匹配，显示空)（左边显示为空：（右边全部显示）也要显示+写在左边） <br> SQL&gt;select s.id,s.name,e.grade from stu s right join exam e on s.id=e.id; <br> SQL&gt;select s.id,s.name,e.grade from stu s,exam e where s.id(+)=e.id; <br> 小结：实际上左外连接和右外连接是可以互为转换的。</p> 
<p>4、完全外连接(显示所有成绩和所有人的名字，如果没有相应的匹配值，则显示空) <br> SQL&gt;select s.id,s.name,e.grade from stu s full outer join exam e on s.id=e.id;</p> 
<p>oracle表内连接和外连接 <br> 一个小练习 <br> 为加深大家对外连接的理解，我们做一个小练习 <br> 列出部门名称和这些部门的员工信息，同时列出那些没有员工的部门。 <br> SQL&gt;select d.dname,e.* from dept d left join emp e on d.deptno=e.deptno; <br> SQL&gt;select d.dname,e.* from dept d,emp e where d.deptno=e.deptno(+); <br> SQL&gt;select d.dname,e.* from emp e right join dept d on d.deptno=e.deptno; <br> SQL&gt;select d.dname,e.* from emp e,dept d where e.deptno(+)=d.deptno;</p> 
<p>练习题3： <br> 1、假定sales部门有10个雇员，其中9个雇员的工资为1000，另一个雇员的工资为null，那么使用avg函数取得该部门的平均工资时，结果应该是多少？ A <br> A、1000 B、900</p> 
<p>2、以下哪条语句是正确的？C <br> A、select deptno,sum(sal) from emp; <br> B、select deptno,avg(sal) from emp where avg(sal)&gt;2000 group by deptno; <br> C、select deptno,avg(sal) from emp group by deptno having avg(sal)&gt;2000;</p> 
<p>3、如果要显示所有的部门及其雇员信息，应该使用哪个语句？B <br> A、select a.dname,b.ename from dept a,emp b where a.deptno=b.deptno; <br> B、select a.dname,b.ename from dept a,emp b where a.deptno=b.deptno(+); <br> C、select a.dname,b.ename from dept a,emp b where a.deptno(+)=b.deptno;</p> 
<p>4、以下哪条语句是不正确的？C <br> A、create table employee as select * from emp order by ename; <br> B、create view emp_vu as select * from emp order by ename; <br> C、select ename,job,sal from emp where job in(select job from emp where deptno=30 order by job);//对子查询排序无意义</p> 
<p>5、以下哪个集合操作符不会执行排序操作？B <br> A、union B、union all C、intersect D、minus</p> 
<p>6、使用分组函数和数据分组子句 <br> (1)显示所有雇员的平均工资、总计工资、最高工资、最低工资。 <br> SQL&gt;select avg(sal),sum(sal),max(sal),min(sal) from emp;</p> 
<p>(2)显示每种岗位的雇员总数、平均工资。 <br> SQL&gt;select count(*),avg(sal),job from emp group by job;</p> 
<p>(3)显示雇员总数，以及获得补助的雇员数。 <br> SQL&gt;select count(*),count(comm) from emp;</p> 
<p>(4)显示管理者的总人数 <br> SQL&gt;select count(distinct mgr) from emp;</p> 
<p>(5)显示雇员工资的最大差额。 <br> SQL&gt;select max(sal)-min(sal) from emp;</p> 
<p>(6)显示每个部门每个岗位的平均工资、每个部门的平均工资、每个岗位的平均工资。 <br> SQL&gt;select avg(sal),deptno,job from emp group by cube(deptno,job); <br> 特别注意：cube立方体函数的使用，此函数用于分组统计。</p> 
<p>7、使用连接查询完成 <br> (1)显示部门20的部门名，以及该部门的所有雇员名、雇员工资及岗位 <br> SQL&gt;select e.deptno,d.dname,e.ename,e.sal,e.job from emp e,dept d where e.deptno=d.deptno and e.deptno=20;</p> 
<p>(2)显示获得补助的所有雇员名、补助以及所在部门名 <br> SQL&gt;select e.ename,e.comm,d.dname from emp e,dept d where e.deptno=d.deptno and e.comm is not null;</p> 
<p>(3)显示在dallas工作的所有雇员名、雇员工资及所在部门名 <br> SQL&gt;select e.ename,e.sal,d.dname from emp e,dept d where e.deptno=d.deptno and d.loc=’DALLAS’;</p> 
<p>(4)显示雇员scott的管理者名称 <br> SQL&gt;select ename from emp where empno=(select mgr from emp where ename=’SCOTT’);</p> 
<p>(5)查询emp表和salgrade表显示部门20的雇员名、工资及其工资级别 <br> SQL&gt;select e.ename,e.sal,s.grade from emp e,salgrade s where e.deptno=20 and e.sal between losal and hisal;</p> 
<p>(6)显示部门10的所有雇员名、部门名以及其他部门名 <br> SQL&gt;select e.ename,d.dname from emp e right join dept d on e.deptno=d.deptno and e.deptno=10;</p> 
<p>(7)显示部门10的所有雇员名、部门名以及其他雇员名 <br> SQL&gt;select e.ename,d.dname from emp e left join dept d on e.deptno=d.deptno and e.deptno=10;</p> 
<p>(8)显示部门10的所有雇员名、部门名以及其他部门名和雇员名 <br> SQL&gt;select e.ename,d.dname from emp e full outer join dept d on e.deptno=d.deptno and e.deptno=10;</p> 
<p>8、使用子查询完成 <br> (1)显示blake同部门的所有雇员，但不显示blake <br> SQL&gt;select * from emp where deptno=(select deptno from emp where ename=’BLAKE’) and ename!=’BLAKE’;</p> 
<p>(2)显示超过平均工资的所有雇员名，工资及其部门号 <br> SQL&gt;select ename,sal,deptno from emp where sal&gt;(select avg(sal) from emp);</p> 
<p>(3)显示超过部门平均工资的所有雇员名、工资及部门号 <br> SQL&gt;select e.ename,e.sal,e.deptno,t1.mysal from emp e,(select avg(sal) mysal,deptno from emp group by deptno) t1 where e.deptno=t1.deptno and e.sal&gt;t1.mysal order by e.deptno;</p> 
<p>(4)显示高于clerk岗位所有雇员工资的所有雇员名、工资及岗位 <br> SQL&gt;select ename,sal,job from emp where sal&gt;(select sum(sal) from emp where job=’CLERK’);</p> 
<p>(5)显示工资、补助与scott完全一致的所有雇员名、工资及补助 <br> SQL&gt;select e.ename,e.sal,nvl(e.comm,0) ecomm,e.deptno from emp e,(select sal,nvl(comm,0) tcomm from emp where ename=’SCOTT’) t1 where e.sal=t1.sal and nvl(e.comm,0)=t1.tcomm;</p> 
<p>注意：select t.empno f from emp t where empno&gt;7369; （true） <br> select t.empno f from emp t where empno&gt;7369; （true） <br> select t.empno “f” from emp t where empno&gt;7369; （true） <br> select t.empno f from emp t where f&gt;7369; （false） </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/71e7a60689dabf927798b76ab4d5d8f5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ABAP 关于出口(user-exit)MV50AFZ1的一些问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a3f168c327ef7a8a61c3c9b0f5133b6c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">20150904看电影学英语</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>