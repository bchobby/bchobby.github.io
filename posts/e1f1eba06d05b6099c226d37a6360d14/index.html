<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Flask Mega-Tutorial V2.0 第22章：后台工作 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Flask Mega-Tutorial V2.0 第22章：后台工作" />
<meta property="og:description" content="最近在Flask Web Development作者博客看到第二版Flask Mega-Tutorial已在2017年底更新，现翻译给大家参考，希望帮助大家学习flask。
这是Flask Mega-Tutorial系列的第二十二章，我将告诉您如何创建独立于Web服务器之外运行的后台作业。
供您参考，以下是本系列文章的列表。
第1章：Hello, World！第2章：模板 第3章：Web表单第4章：数据库第5章：用户登录第6章：配置文件页面和头像第7章：错误处理第8章：关注与被关注第9章：分页第10章：电子邮件支持第11章：整容第12章：日期和时间第13章：I18n和L10n第14章：Ajax第15章：大型应用程序结构第16章：全文搜索第17章：在Linux上部署第18章：在Heroku上部署第19章：Docker容器上的部署第20章：一些JavaScript Magic第21章：用户通知第22章：后台工作（本文）第23章：应用程序编程接口（API） 注意1：如果您正在寻找本教程的旧版本，请在此处。
注意2：如果您想在此博客上支持我的工作，或者只是没有耐心等待每周的文章，我将提供完整的本教程版本，打包成电子书或视频集。欲了解更多信息，请访问courses.miguelgrinberg.com。
本章致力于为应用程序中运行时间较长或复杂的异步任务进程进行优化。这些进程不能在请求的上下文中同步执行，因为这会在任务持续期间阻塞对客户端的响应。在第十章中，我将邮件的发送转移到后台线程中执行，以免阻塞响应。 虽然使用线程处理电子邮件是可以接受的，但当问题处理时间更长时，此解决方案就不足以支撑了。 公认的做法是将耗时长的任务移交到worker进程（或进程池）。
为了证明长时间运行任务存在的必要性，我将介绍Microblog的一个导出功能，用户通过它可以请求一个包含他们所有用户帖子的数据文件。 当用户使用该选项时，应用程序将启动一个导出任务，该导出任务将生成包含所有用户帖子的JSON文件，然后通过电子邮件发送给用户。 所有这些活动都将在worker进程中发生，并且在执行时，用户可以看到显示完成百分比的进度。
本章的GitHub链接为：Browse，Zip和Diff。
任务队列简介 任务队列为后台作业提供了一个便捷的解决方案。 Worker进程独立于应用程序运行，甚至可以位于不同的系统上。 应用程序和worker之间的通信是通过消息队列完成的。 应用程序提交作业，然后通过与队列交互来监视其进度。 下图展示了一个典型的实现：
Python最受欢迎的任务队列是Celery。这是一个相当复杂的包，具有许多选项并支持多个消息队列。另一个流行的Python任务队列是Redis Queue（RQ），它牺牲了一些灵活性，例如仅支持Redis消息队列，但作为交换，它的设置比Celery简单得多。
Celery和RQ都完全可以支持Flask应用中的后台任务，因此，我对此应用程序的选择将倾向于RQ的简单性。但是，使用Celery实现相同的功能应该相对容易。如果您不仅对RQ感兴趣，还对Celery感兴趣，可以阅读我的博客中的Using Celery with Flask文章。
使用RQ RQ是一个标准的Python软件包，用pip安装：
(venv) $ pip install rq (venv) $ pip freeze &gt; requirements.txt 正如我前面提到的，应用和RQ worker之间的通信将在Redis消息队列中执行，因此您需要运行Redis服务器。 有许多途径来安装和运行Redis服务器，比如下载其源码并执行编译和安装。 如果您使用的是Windows，Microsoft在此处维护了Redis的安装程序。 在Linux上，您可以通过操作系统的软件包管理器安装Redis。 Mac OS X用户可以运行brew install redis，然后使用redis-server命令手动启动服务。
除了确保服务正在运行并可供RQ访问之外，您不需要与Redis进行其他交互。
请注意，RQ不能在Windows本机Python解释器上运行。如果使用Windows平台，则只能在Unix仿真下运行RQ。我向Windows用户推荐的两个Unix仿真层是Cygwin和Linux的Windows子系统（WSL），它们都与RQ兼容。
创建任务 通过RQ执行一项简单的任务后，您就会很快熟悉它。 一个任务，不过是一个Python函数而已。 以下是一个示例任务，我将其放入一个新的app/tasks.py模块：
app / tasks.py：示例后台任务。
import time def example(seconds): print(&#39;Starting task&#39;) for i in range(seconds): print(i) time." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/e1f1eba06d05b6099c226d37a6360d14/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-21T22:01:44+08:00" />
<meta property="article:modified_time" content="2021-03-21T22:01:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Flask Mega-Tutorial V2.0 第22章：后台工作</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>最近在Flask Web Development作者博客看到第二版Flask Mega-Tutorial已在2017年底更新，现翻译给大家参考，希望帮助大家学习flask。</p> 
</blockquote> 
<p>这是Flask Mega-Tutorial系列的第二十二章，我将告诉您如何创建独立于Web服务器之外运行的后台作业。</p> 
<p>供您参考，以下是本系列文章的列表。</p> 
<ul><li><a href="https://blog.csdn.net/gh254172840/article/details/81409498">第1章：Hello, World！</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410270">第2章：模板</a> </li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410281">第3章：Web表单</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410292">第4章：数据库</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410296">第5章：用户登录</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410299">第6章：配置文件页面和头像</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410299">第7章：错误处理</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410311">第8章：关注与被关注</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410319">第9章：分页</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410325">第10章：电子邮件支持</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410332">第11章：整容</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410334">第12章：日期和时间</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410340">第13章：I18n和L10n</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410341">第14章：Ajax</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410350">第15章：大型应用程序结构</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410355">第16章：全文搜索</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410357">第17章：在Linux上部署</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410363">第18章：在Heroku上部署</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410368">第19章：Docker容器上的部署</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410372">第20章：一些JavaScript Magic</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410382">第21章：用户通知</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410386">第22章：后台工作</a>（本文）</li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410391">第23章：应用程序编程接口（API）</a></li></ul> 
<p><em>注意1：如果您正在寻找本教程的旧版本，请<a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world-legacy" rel="nofollow">在此处</a>。</em></p> 
<p><em>注意2：如果您想在此博客上支持我的工作，或者只是没有耐心等待每周的文章，我将提供完整的本教程版本，打包成电子书或视频集。欲了解更多信息，请访问<a href="https://courses.miguelgrinberg.com/" rel="nofollow">courses.miguelgrinberg.com</a>。</em></p> 
<p>本章致力于为应用程序中运行时间较长或复杂的异步任务进程进行优化。这些进程不能在请求的上下文中同步执行，因为这会在任务持续期间阻塞对客户端的响应。在<a href="https://blog.csdn.net/gh254172840/article/details/81410325">第十章</a>中，我将邮件的发送转移到后台线程中执行，以免阻塞响应。 虽然使用线程处理电子邮件是可以接受的，但当问题处理时间更长时，此解决方案就不足以支撑了。 公认的做法是将耗时长的任务移交到worker进程（或进程池）。</p> 
<p>为了证明长时间运行任务存在的必要性，我将介绍Microblog的一个导出功能，用户通过它可以请求一个包含他们所有用户帖子的数据文件。 当用户使用该选项时，应用程序将启动一个导出任务，该导出任务将生成包含所有用户帖子的JSON文件，然后通过电子邮件发送给用户。 所有这些活动都将在worker进程中发生，并且在执行时，用户可以看到显示完成百分比的进度。</p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>本章的GitHub链接为：<a href="https://github.com/miguelgrinberg/microblog/tree/v0.22">Browse</a>，<a href="https://github.com/miguelgrinberg/microblog/archive/v0.22.zip">Zip</a>和<a href="https://github.com/miguelgrinberg/microblog/compare/v0.21...v0.22">Diff</a>。</em></span></p> 
<hr> 
<h3><span style="color:#333333;">任务队列简介</span></h3> 
<p>任务队列为后台作业提供了一个便捷的解决方案。 Worker进程独立于应用程序运行，甚至可以位于不同的系统上。 应用程序和worker之间的通信是通过<em>消息队列</em>完成的。 应用程序提交作业，然后通过与队列交互来监视其进度。 下图展示了一个典型的实现：</p> 
<p style="margin-left:0px;"><span style="color:#333333;"><img alt="任务队列图" src="https://images2.imgbox.com/33/35/fwnvlOCv_o.png"></span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">Python最受欢迎的任务队列是<a href="http://www.celeryproject.org/" rel="nofollow">Celery</a>。这是一个相当复杂的包，具有许多选项并支持多个消息队列。另一个流行的Python任务队列是<a href="http://python-rq.org/" rel="nofollow">Redis Queue</a>（RQ），它牺牲了一些灵活性，例如仅支持<a href="https://redis.io/" rel="nofollow">Redis</a>消息队列，但作为交换，它的设置比Celery简单得多。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">Celery和RQ都完全可以支持Flask应用中的后台任务，因此，我对此应用程序的选择将倾向于RQ的简单性。但是，使用Celery实现相同的功能应该相对容易。如果您不仅对RQ感兴趣，还对Celery感兴趣，</span>可以阅读我的博客中的<a href="https://blog.miguelgrinberg.com/post/using-celery-with-flask" rel="nofollow">Using Celery with Flask</a>文章。</p> 
<h3><span style="color:#333333;">使用RQ</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">RQ是一个标准的Python软件包，</span>用<code>pip</code>安装：</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint">(venv) $ pip install rq
(venv) $ pip freeze &gt; requirements.txt</code></pre> 
<p>正如我前面提到的，应用和RQ worker之间的通信将在Redis消息队列中执行，因此您需要运行Redis服务器。 有许多途径来安装和运行Redis服务器，比如下载其源码并执行编译和安装。 如果您使用的是Windows，Microsoft在<a href="https://github.com/MicrosoftArchive/redis/releases">此处</a>维护了Redis的安装程序。 在Linux上，您可以通过操作系统的软件包管理器安装Redis。 Mac OS X用户可以运行<code>brew install redis</code>，然后使用<code>redis-server</code>命令手动启动服务。</p> 
<p>除了确保服务正在运行并可供RQ访问之外，您不需要与Redis进行其他交互。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">请注意，RQ不能在Windows本机Python解释器上运行。如果使用Windows平台，则只能在Unix仿真下运行RQ。我向Windows用户推荐的两个Unix仿真层是<a href="https://cygwin.org/" rel="nofollow">Cygwin</a>和<a href="https://msdn.microsoft.com/en-us/commandline/wsl/about" rel="nofollow">Linux</a>的<a href="https://msdn.microsoft.com/en-us/commandline/wsl/about" rel="nofollow">Windows子系统（WSL）</a>，它们都与RQ兼容。</span></p> 
<h4><span style="color:#333333;">创建任务</span></h4> 
<p style="margin-left:0px;">通过RQ执行一项简单的任务后，您就会很快熟悉它。 一个任务，不过是一个Python函数而已。 以下是一个示例任务，我将其放入一个新的<em>app/tasks.py</em>模块：</p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / tasks.py</em>：示例后台任务。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">import time

def example(seconds):
    print('Starting task')
    for i in range(seconds):
        print(i)
        time.sleep(1)
    print('Task completed')</code></pre> 
<p style="margin-left:0px;">该任务将秒数作为参数，然后在该时间量内等待，并每秒打印一次计数器。</p> 
<h4><span style="color:#333333;">运行RQ Worker</span></h4> 
<p style="margin-left:0px;"><span style="color:#333333;">现在任务已经准备就绪，可以开始工作了。</span>可以通过<code>rq worker</code>来启动一个worker进程了</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint">(venv) $ rq worker microblog-tasks
18:55:06 RQ worker 'rq:worker:miguelsmac.90369' started, version 0.9.1
18:55:06 Cleaning registries for queue: microblog-tasks
18:55:06
18:55:06 *** Listening on microblog-tasks...</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">现在Worker进程已连接到Redis，</span>并在名为<code>microblog-tasks</code>的队列上查看可能分配给它的任何作业。 如果您想启动多个worker来扩展吞吐量，您只需要运行<code>rq worker</code>来生成更多连接到同一个队列的进程。 然后，当作业出现在队列中时，任何可用的worker进程都可以获取它。 在生产环境中，您可能希望至少运行可用CPU数量的worker。</p> 
<h4><span style="color:#333333;">执行任务</span></h4> 
<p style="margin-left:0px;"><span style="color:#333333;">现在打开第二个终端窗口，并在其上激活虚拟环境。</span>我将使用shell会话来启动worker中的<code>example()</code>任务：</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">&gt;&gt;&gt; from redis import Redis
&gt;&gt;&gt; import rq
&gt;&gt;&gt; queue = rq.Queue('microblog-tasks', connection=Redis.from_url('redis://'))
&gt;&gt;&gt; job = queue.enqueue('app.tasks.example', 23)
&gt;&gt;&gt; job.get_id()
'c651de7f-21a8-4068-afd5-8b982a6f6d32'
</code></pre> 
<p>来自RQ的<code>Queue</code>类表示从应用程序端看到的任务队列。 它采用的参数是队列名称和一个<code>Redis</code>连接对象，本处使用默认URL进行初始化。 如果您的Redis服务器运行在不同的主机或端口号上，则需要使用其他URL。</p> 
<p>Queue的<code>enqueue()</code>方法用于将作业添加到队列中。 第一个参数是要执行的任务的名称，可直接传入函数对象或导入字符串。 我发现传入字符串更加方便，因为不需要在应用程序的一端导入函数。 对<code>enqueue()</code>传入的任何剩余参数将被传递给worker中运行的函数。</p> 
<p>只要进行了<code>enqueue()</code>调用，运行着RQ worker的终端窗口上就会出现一些活动。 您会看到<code>example()</code>函数正在运行，并且每秒打印一次计数器。 同时，您的其他终端不会被阻塞，您可以继续在shell中执行表达式。在上面的例子中，我调用<code>job.get_id()</code>方法来获取分配给任务的唯一标识符。 您可以尝试使用另一个有趣表达式来检查worker上的函数是否已完成：</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">&gt;&gt;&gt; job.is_finished
False</code></pre> 
<p>如果您像我在上面的例子中那样传递了<code>23</code>，那么函数将运行约23秒。 在那之后，<code>job.is_finished</code>表达式将变为<code>True</code>。 就是这么简单，炫酷否？</p> 
<p>一旦函数完成，worker又回到等待作业的状态，所以如果您想进行更多的实验，您可以用不同的参数重复执行<code>enqueue()</code>调用。 队列中存储的有关任务的数据将保留一段时间（默认为500秒），但最终会被删除。 这很重要，任务队列不保留已执行作业的历史记录。</p> 
<h4><span style="color:#333333;">报告任务进度</span></h4> 
<p style="margin-left:0px;"><span style="color:#333333;">我上面使用的示例任务非常简单。通常，对于长时间运行的任务，您将需要使某种进度信息可供应用程序使用，从而可以将其显示给用户。RQ通​​过使用作业对象的<code>meta</code>属性来支持这一点。让我重写<code>example()</code>任务以编写进度报告：</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / tasks.py</em>：具有进度的示例后台任务。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">import time
from rq import get_current_job

def example(seconds):
    job = get_current_job()
    print('Starting task')
    for i in range(seconds):
        job.meta['progress'] = 100.0 * i / seconds
        job.save_meta()
        print(i)
        time.sleep(1)
    job.meta['progress'] = 100
    job.save_meta()
    print('Task completed')
</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">这一新版本<code>example()</code>使用RQ的<code>get_current_job()</code>函数来获取作业实例，该作业实例与提交任务时返回给应用程序的作业实例相似。作业对象的<code>meta</code>属性是一个字典，</span>任务可以编写任何想要与应用程序通信的自定义数据。 在这个例子中，我写入了<code>progress</code>，表示完成任务的百分比。 每次进程更新时，我都调用<code>job.save_meta()</code>指示RQ将数据写入Redis，应用程序可以在其中找到它。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">在应用程序端（当前仅是Python shell），我可以运行此任务，然后按如下所示监视进度：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">&gt;&gt;&gt; job = queue.enqueue('app.tasks.example', 23)
&gt;&gt;&gt; job.meta
{}
&gt;&gt;&gt; job.refresh()
&gt;&gt;&gt; job.meta
{'progress': 13.043478260869565}
&gt;&gt;&gt; job.refresh()
&gt;&gt;&gt; job.meta
{'progress': 69.56521739130434}
&gt;&gt;&gt; job.refresh()
&gt;&gt;&gt; job.meta
{'progress': 100}
&gt;&gt;&gt; job.is_finished
True
</code></pre> 
<p style="margin-left:0px;">如您所见，在另一侧，<code>meta</code>属性可以被读取。 需要调用<code>refresh()</code>方法来从Redis更新内容。</p> 
<h3><span style="color:#333333;">任务的数据库表示</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">对于上面的示例，足以启动任务并观察其运行。对于Web应用程序，事情变得更加复杂，因为一旦这些任务之一作为请求的一部分启动，该请求将结束，并且该任务的所有上下文都将丢失。因为我希望应用程序跟踪每个用户正在运行的任务，所以我需要使用数据库表来维护某些状态。在下面，您可以看到新的<code>Task</code>模型实现：</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / models.py</em>：Task模型。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python"># ...
import redis
import rq

class User(UserMixin, db.Model):
    # ...
    tasks = db.relationship('Task', backref='user', lazy='dynamic')

# ...

class Task(db.Model):
    id = db.Column(db.String(36), primary_key=True)
    name = db.Column(db.String(128), index=True)
    description = db.Column(db.String(128))
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    complete = db.Column(db.Boolean, default=False)

    def get_rq_job(self):
        try:
            rq_job = rq.job.Job.fetch(self.id, connection=current_app.redis)
        except (redis.exceptions.RedisError, rq.exceptions.NoSuchJobError):
            return None
        return rq_job

    def get_progress(self):
        job = self.get_rq_job()
        return job.meta.get('progress', 0) if job is not None else 100
</code></pre> 
<p>这个模型和以前的模型有一个有趣的区别是<code>id</code>主键字段是字符串类型，而不是整数类型。 这是因为对于这个模型，我不会依赖数据库自己的主键生成，而是使用由RQ生成的作业标识符。</p> 
<p>该模型将存储符合任务命名规范的名称（会传递给RQ），适用于向用户显示的任务描述，该任务的所属用户的关系以及任务是否已完成的布尔值。<code>complete</code>字段的目的是将正在运行的任务与已完成的任务分开，因为运行中的任务需要特殊处理才能显示最新进度。</p> 
<p><code>get_rq_job()</code>辅助方法可以用给定的任务ID加载RQ的<code>Job</code>实例。 这是通过<code>Job.fetch()</code>完成的，它会从Redis中存在的数据中加载<code>Job</code>实例。 <code>get_progress()</code>方法建立在<code>get_rq_job()</code>的基础之上，并返回任务的进度百分比。 该方法做一些有趣的假设，如果模型中的作业ID不存在于RQ队列中，则表示作业已完成并且数据已过期并已从队列中删除，因此在这种情况下返回的百分比为100。 另一方面，如果job存在，但'meta'属性中找不到进度相关的信息，那么可以安全地假定该job计划运行，但还没有启动，所以在这种情况下进度是0。</p> 
<p>要将更改应用于数据库，需要生成新的迁移，然后升级数据库：</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint">(venv) $ flask db migrate -m "tasks"
(venv) $ flask db upgrade</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">也可以将新模型添加到shell上下文中，以使其在shell会话中可以访问而不必导入它：</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>microblog.py</em>：将Task模型添加到Shell上下文中。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">from app import create_app, db, cli
from app.models import User, Post, Message, Notification, Task

app = create_app()
cli.register(app)

@app.shell_context_processor
def make_shell_context():
    return {'db': db, 'User': User, 'Post': Post, 'Message': Message,
            'Notification': Notification, 'Task': Task}</code></pre> 
<h3><span style="color:#333333;">将RQ与Flask应用集成</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">Redis服务的连接URL需要添加到配置中：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">class Config(object):
    # ...
    REDIS_URL = os.environ.get('REDIS_URL') or 'redis://'
</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">与往常一样，Redis连接URL将来自环境变量，如果未定义该变量，</span>则会假定该服务在当前主机的默认端口上运行并使用默认URL。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">应用工厂函数将负责初始化Redis和RQ：</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / __ init__.py：RQ</em>集成。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python"># ...
from redis import Redis
import rq

# ...

def create_app(config_class=Config):
    # ...
    app.redis = Redis.from_url(app.config['REDIS_URL'])
    app.task_queue = rq.Queue('microblog-tasks', connection=app.redis)

    # ...</code></pre> 
<p style="margin-left:0px;"><code>app.task_queue</code>将成为提交任务的队列。 将队列附加到应用上会提供很大的便利，因为我可以在应用的任何地方使用<code>current_app.task_queue</code>来访问它。 为了方便应用的任何部分提交或检查任务，我可以在<code>User</code>模型中创建一些辅助方法：</p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / models.py</em>：用户模型中的任务辅助方法。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python"># ...

class User(UserMixin, db.Model):
    # ...

    def launch_task(self, name, description, *args, **kwargs):
        rq_job = current_app.task_queue.enqueue('app.tasks.' + name, self.id,
                                                *args, **kwargs)
        task = Task(id=rq_job.get_id(), name=name, description=description,
                    user=self)
        db.session.add(task)
        return task

    def get_tasks_in_progress(self):
        return Task.query.filter_by(user=self, complete=False).all()

    def get_task_in_progress(self, name):
        return Task.query.filter_by(name=name, user=self,
                                    complete=False).first()</code></pre> 
<p><code>launch_task()</code>方法负责将任务提交到RQ队列，并将其添加到数据库中。 <code>name</code>参数是函数名称，如<em>app/tasks.py</em>中所定义的那样。 提交给RQ时，该函数会将<code>app.tasks.</code>预先添加到该名称中以构建符合规范的函数名称。<code>description</code>参数是对呈现给用户的任务的友好描述。 对于导出用户帖子的函数，我将名称设置为<code>export_posts</code>，将描述设置为<code>Exporting posts...</code>。 其余参数将传递给任务函数。 <code>launch_task()</code>函数首先调用队列的<code>enqueue()</code>方法来提交作业。 返回的作业对象包含由RQ分配的任务ID，因此我可以使用它在我的数据库中创建相应的<code>Task</code>对象。</p> 
<p>请注意，<code>launch_task()</code>将新的任务对象添加到会话中，但不会发出提交。 一般来说，最好在更高层次函数中的数据库会话上进行操作，因为它允许您在单个事务中组合由较低级别函数所做的多个更新。 这不是一个严格的规则，并且，在本章后面的子函数中也会存在一个例外的提交。</p> 
<p><code>get_tasks_in_progress()</code>方法返回该用户未完成任务的列表。 稍后您会看到，我使用此方法在将有关正在运行的任务的信息渲染到用户的页面中。</p> 
<p>最后，<code>get_task_in_progress()</code>是上一个方法的简化版本并返回指定的任务。 我阻止用户同时启动两个或多个相同类型的任务，因此在启动任务之前，可以使用此方法来确定前一个任务是否还在运行。</p> 
<h3><span style="color:#333333;">从RQ任务发送电子邮件</span></h3> 
<p>不要认为本节偏离主题，我在上面说过，当后台导出任务完成时，将使用包含所有用户帖子的JSON文件向用户发送电子邮件。 我在<a href="https://blog.csdn.net/gh254172840/article/details/81410325">第十章</a>中构建的电子邮件功能需要通过两种方式进行扩展。 首先，我需要添加对文件附件的支持，以便我可以附加JSON文件。 其次，<code>send_email()</code>函数总是使用后台线程异步发送电子邮件。 当我要从后台任务发送一封电子邮件时（已经是异步的了），基于线程的二级后台任务没有什么意义，所以我需要同时支持同步和异步电子邮件的发送。</p> 
<p>幸运的是，Flask-Mail支持附件，所以我需要做的就是扩展<code>send_email()</code>函数的默认关键字参数，然后在<code>Message</code>对象中配置它们。 选择在前台发送电子邮件时，我只需要添加一个<code>sync=True</code>的关键字参数即可</p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / email.py</em>：发送带有附件的电子邮件。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python"># ...

def send_email(subject, sender, recipients, text_body, html_body,
               attachments=None, sync=False):
    msg = Message(subject, sender=sender, recipients=recipients)
    msg.body = text_body
    msg.html = html_body
    if attachments:
        for attachment in attachments:
            msg.attach(*attachment)
    if sync:
        mail.send(msg)
    else:
        Thread(target=send_async_email,
            args=(current_app._get_current_object(), msg)).start()
</code></pre> 
<p>Message类的<code>attach()</code>方法接受三个定义附件的参数：文件名，媒体类型和实际文件数据。 文件名就是收件人看到的与附件关联的名称。 媒体类型定义了这种附件的类型，这有助于电子邮件读者适当地渲染它。 例如，如果您发送<code>image/png</code>作为媒体类型，则电子邮件阅读器会知道该附件是一个图像，在这种情况下，它可以显示它。 对于用户帖子数据文件，我将使用JSON格式，该格式使用<code>application/json</code>媒体类型。 最后一个参数包含附件内容的字符串或字节序列。</p> 
<p>简单来说，<code>send_email()</code>的<code>attachments</code>参数将成为一个元组列表，每个元组将有三个元素对应于<code>attach()</code>的三个参数。 因此，我需要将此列表中的每个元素作为参数发送给<code>attach()</code>。 在Python中，如果您想将列表或元组中的每个元素作为参数传递给函数，您可以使用<code>func(*args)</code>将这个列表或元祖解包成函数中的多个参数，而不必枯燥地一个个地传递，如<code>func(args[0], args[1], args[2])</code>。 例如，如果您有一个列表<code>args = [1, 'foo']</code>，<code>func(*args)</code>将会传递两个参数，就和您调用<code>func(1, 'foo')</code>一样。 如果没有<code>*</code>，调用将会传入一个参数，即<code>args</code>列表。</p> 
<p>至于电子邮件的同步发送，我需要做的就是，当<code>sync</code>是<code>True</code>的时候恢复成调用<code>mail.send(msg)</code>。</p> 
<h3><span style="color:#333333;">任务助手</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">虽然<code>example()</code>我上面使用的任务是一个简单的独立函数，但是导出博客文章的函数将需要我在应用中具有的某些功能，例如访问数据库和电子邮件发送功能。因为这将在单独的进程中运行，所以我需要初始化Flask-SQLAlchemy和Flask-Mail，这又需要一个Flask应用程序实例来从中获取其配置。因此，我将在<em>app / tasks.py</em>模块的顶部添加一个Flask应用程序实例和应用程序上下文：</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / tasks.py</em>：创建应用和上下文。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">from app import create_app

app = create_app()
app.app_context().push()</code></pre> 
<p>应用在此模块中创建，因为这是RQ worker要导入的唯一模块。 当使用<code>flask</code>命令时，根目录中的<em>microblog.py</em>模块创建应用实例，但RQ worker对此却一无所知，所以当任务函数需要它时，它需要创建自己的应用实例。 您已经在好几个地方看到了<code>app.app_context()</code>方法，推送一个上下文使应用成为“当前”的应用实例，这样一来Flask-SQLAlchemy等插件才可以使用<code>current_app.config</code> 获取它们的配置。 没有上下文，<code>current_app</code>表达式会返回一个错误。</p> 
<p>然后我开始考虑如何在这个函数运行时报告进度。除了通过<code>job.meta</code>字典传递进度信息之外，我还想将通知推送给客户端，以便自动动态更新完成百分比。为此，我将使用我在<a href="https://blog.csdn.net/gh254172840/article/details/81410382">第二十一章</a>中构建的通知机制。更新将以与未读消息徽章非常类似的方式工作。当服务器渲染模板时，它将包含从<code>job.meta</code>获得的“静态”进度信息，但是一旦页面位于客户端的浏览器中，通知将使用通知来动态更新百分比。由于通知的原因，更新正在运行的任务的进度将比上一个示例中的操作稍微多一些，所以我将创建一个专用于更新进度的包装函数：</p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / tasks.py</em>：设置任务进度。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">from rq import get_current_job
from app import db
from app.models import Task

# ...

def _set_task_progress(progress):
    job = get_current_job()
    if job:
        job.meta['progress'] = progress
        job.save_meta()
        task = Task.query.get(job.get_id())
        task.user.add_notification('task_progress', {'task_id': job.get_id(),
                                                     'progress': progress})
        if progress &gt;= 100:
            task.complete = True
        db.session.commit()</code></pre> 
<p>导出任务可以调用<code>_set_task_progress()</code>来记录进度百分比。 该函数首先将百分比写入<code>job.meta</code>字典并将其保存到Redis，然后从数据库加载相应的任务对象，并使用<code>task.user</code>已有的<code>add_notification()</code>方法将通知推送给请求该任务的用户。 通知将被命名为<code>task_progress</code>，并且与其关联的数据将成为具有两个条目的字典：任务标识符和进度数值。 稍后我将添加JavaScript代码来处理这种新的通知类型。</p> 
<p>该函数查看进度来确认任务函数是否已完成，并在这种情况下更新数据库中任务对象的<code>complete</code>属性。 数据库提交调用确保通过<code>add_notification()</code>添加的任务和通知对象都立即保存到数据库。 我需要非常精确地设计父任务，确保不执行任何数据库更改，因为执行本调用会将父任务的更改也写入数据库。</p> 
<h3><span style="color:#333333;">实现导出任务</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">现在所有部分都已准备就绪，可以编写导出函数了。此函数的高层结构如下：</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / tasks.py</em>：导出帖子的通用结构。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">def export_posts(user_id):
    try:
        # read user posts from database
        # send email with data to user
    except:
        # handle unexpected errors</code></pre> 
<p>为什么将整个任务包装在try/except块中呢？ 请求处理器中的应用代码可以防止意外错误，因为Flask本身捕获异常，然后将它们以我设置的日志配置的方式来进行处理。 然而，这个函数将运行在由RQ控制的单独进程中，而非Flask，因此如果发生任何意外错误，任务将中止，RQ将向控制台显示错误，然后返回等待新的job。 所以基本上，除非您正在观看RQ worker的输出或将其记录到文件中，否则将永远不会发现有错误。</p> 
<p>让我们从上面带有注释的三部分中最简单的错误处理部分开始梳理：</p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / tasks.py</em>：导出文章错误处理。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">import sys
# ...

def export_posts(user_id):
    try:
        # ...
    except:
        app.logger.error('Unhandled exception', exc_info=sys.exc_info())
    finally:
        _set_task_progress(100)</code></pre> 
<p>每当发生意外错误时，我将通过将进度设置为100％来将任务标记为完成，然后使用Flask应用程序中的日志记录器对象记录错误以及堆栈跟踪信息（调用<code>sys.exc_info()</code>来获得）。 使用Flask应用日志记录器来记录错误的好处在于，您可以观察到您为Flask应用实现的任何日志记录机制。 例如，在<a href="https://blog.csdn.net/gh254172840/article/details/81410299">第七章</a>中，我配置了要发送到管理员电子邮件地址的错误。 只要使用<code>app.logger</code>，我也可以得到这些错误信息。</p> 
<p>接下来，我将编写实际的导出代码，它只需发出一个数据库查询并在循环中遍历结果，并将它们累积在字典中：</p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / tasks.py</em>：从数据库中读取用户帖子。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">import time
from app.models import User, Post

# ...

def export_posts(user_id):
    try:
        user = User.query.get(user_id)
        _set_task_progress(0)
        data = []
        i = 0
        total_posts = user.posts.count()
        for post in user.posts.order_by(Post.timestamp.asc()):
            data.append({'body': post.body,
                         'timestamp': post.timestamp.isoformat() + 'Z'})
            time.sleep(5)
            i += 1
            _set_task_progress(100 * i // total_posts)

        # send email with data to user
    except:
        # ...
    finally:
        # ...
</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">对于每个帖子，该函数将包括</span></p> 
<p>两个条目的字典，即帖子正文和帖子发表的时间。 时间格式将采用<a href="https://en.wikipedia.org/wiki/ISO_8601" rel="nofollow">ISO 8601</a>标准。 我使用的Python的<code>datetime</code>对象不存储时区，因此在以ISO格式导出时间后，我添加了'Z'，它表示UTC。</p> 
<p>由于需要跟踪进度，代码变得稍微复杂了些。 我维护了一个计数器<code>i</code>，并且在进入循环之前还需要发出一个额外的数据库查询，查询<code>total_posts</code>以获得用户帖子的总数。 使用了<code>i</code>和<code>total_posts</code>，在每个循环迭代我都可以使用从0到100的数字来更新任务进度。</p> 
<p>您可能会好奇我为什么会在每个循环迭代中加入<code>time.sleep(5)</code>调用。主要原因是我想要延长导出所需的时间，以便在用户帖子不多的情况下也可以方便地查看到导出进度的增长。</p> 
<p>下面是函数的最后部分，将会带上<code>data</code>附件发送邮件给用户：</p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / tasks.py</em>：将帖子通过电子邮件发送给用户。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">import json
from flask import render_template
from app.email import send_email

# ...

def export_posts(user_id):
    try:
        # ...

        send_email('[Microblog] Your blog posts',
                sender=app.config['ADMINS'][0], recipients=[user.email],
                text_body=render_template('email/export_posts.txt', user=user),
                html_body=render_template('email/export_posts.html', user=user),
                attachments=[('posts.json', 'application/json',
                              json.dumps({'posts': data}, indent=4))],
                sync=True)
    except:
        # ...
    finally:
        # ...</code></pre> 
<p style="margin-left:0px;">其实只是对<code>send_email()</code>函数的调用。 附件被定义为一个元组，其中有三个元素被传递给Flask-Mail的<code>Message</code>对象的<code>attach()</code>方法。 元组中的第三个元素是附件内容，它是用Python的<code>json.dumps()</code>函数生成的。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">这里引用了一对新模板，它们以纯文本和HTML格式提供电子邮件正文的内容。这是文本模板：</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / templates / email / export_posts.txt</em>：导出帖子文本电子邮件模板。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint">Dear {<!-- -->{ user.username }},

Please find attached the archive of your posts that you requested.

Sincerely,

The Microblog Team</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">这是电子邮件的HTML版本：</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / templates / email / export_posts.html</em>：导出帖子的HTML电子邮件模板。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-html">&lt;p&gt;Dear {<!-- -->{ user.username }},&lt;/p&gt;
&lt;p&gt;Please find attached the archive of your posts that you requested.&lt;/p&gt;
&lt;p&gt;Sincerely,&lt;/p&gt;
&lt;p&gt;The Microblog Team&lt;/p&gt;
</code></pre> 
<h3><span style="color:#333333;">应用中的导出功能</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">现在已经支持后台导出任务的所有核心组件。剩下的就是将此功能连接到应用，以便用户可以发出将其帖子通过电子邮件发送给他们的请求。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">在下面您可以看到一个新的<code>export_posts</code>视图函数：</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / main / routes.py</em>：导出帖子路由和视图函数。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">@bp.route('/export_posts')
@login_required
def export_posts():
    if current_user.get_task_in_progress('export_posts'):
        flash(_('An export task is currently in progress'))
    else:
        current_user.launch_task('export_posts', _('Exporting posts...'))
        db.session.commit()
    return redirect(url_for('main.user', username=current_user.username))</code></pre> 
<p>该函数首先检查用户是否有未完成的导出任务，并在这种情况下只是闪现消息。 对同一用户同时执行两个导出任务是没有意义的，可以避免。 我可以使用前面实现的<code>get_task_in_progress()</code>方法来检查这种情况。</p> 
<p>如果用户没有正在运行的导出任务，则调用<code>launch_task()</code>来启动它。 第一个参数是将传递给RQ worker的函数的名称，前缀为<code>app.tasks.</code>。 第二个参数只是一个友好的文本描述，将会显示给用户。 这两个值都会被写入数据库中的Task对象。 该函数以重定向到用户个人主页结束。</p> 
<p>现在我需要暴露该路由的链接，以便用户可以请求导出。 我认为最合适的地方是在用户个人主页，只有在用户查看他们自己的主页时，链接在“编辑个人资料”链接下面显示：</p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / templates / user.html</em>：在</span>用户个人主页<span style="color:#333333;">中导出链接。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-html">                ...
                &lt;p&gt;
                    &lt;a href="{<!-- -->{ url_for('main.edit_profile') }}"&gt;
                        {<!-- -->{ _('Edit your profile') }}
                    &lt;/a&gt;
                &lt;/p&gt;
                {% if not current_user.get_task_in_progress('export_posts') %}
                &lt;p&gt;
                    &lt;a href="{<!-- -->{ url_for('main.export_posts') }}"&gt;
                        {<!-- -->{ _('Export your posts') }}
                    &lt;/a&gt;
                &lt;/p&gt;
                ...
                {% endif %}</code></pre> 
<p>此链接的渲染是有条件的，因为我不希望它在用户已经有导出任务执行时出现。</p> 
<p>此时的后台作业是可以运作的，但是不会向用户提供任何反馈。 如果您想尝试一下，您可以按如下方式启动应用和RQ worker：</p> 
<ul><li>确保您正在运行Redis</li><li>在第一个终端窗口中，启动RQ工作程序的一个或多个实例。为此，您必须使用命令<code>rq worker microblog-tasks</code></li><li>再打开另一个终端窗口中，使用<code>flask run</code>（请记住先设置<code>FLASK_APP</code>）启动Flask应用程序</li></ul> 
<h3><span style="color:#333333;">进度通知</span></h3> 
<p style="margin-left:0px;">为了完善这个功能，我想在后台任务运行时提醒用户任务完成的百分比进度。 在浏览Bootstrap组件选项时，我决定在导航栏的下方使用一个Alert组件。 Alert组件是向用户显示信息的带颜色的横条。 我用蓝色的Alert框来渲染闪现的消息。 现在我要添加一个绿色的Alert框来显示任务进度。 样式如下：</p> 
<p style="margin-left:0px;"><span style="color:#333333;"><img alt="进度警报" src="https://images2.imgbox.com/d8/bf/5iL3BWRw_o.png"></span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / templates / base.html</em>：在基本模板中导出进度Alert组件。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">...
{% block content %}
    &lt;div class="container"&gt;
        {% if current_user.is_authenticated %}
        {% with tasks = current_user.get_tasks_in_progress() %}
        {% if tasks %}
            {% for task in tasks %}
            &lt;div class="alert alert-success" role="alert"&gt;
                {<!-- -->{ task.description }}
                &lt;span id="{<!-- -->{ task.id }}-progress"&gt;{<!-- -->{ task.get_progress() }}&lt;/span&gt;%
            &lt;/div&gt;
            {% endfor %}
        {% endif %}
        {% endwith %}
        {% endif %}
        ...
{% endblock %}
...
</code></pre> 
<p>渲染任务Alert组件的方法几乎与闪现消息相同。 外部条件在用户未登录时跳过所有与Alert相关的标记。而对于已登录用户，我通过调用前面创建的<code>get_tasks_in_progress()</code>方法来获取当前正在进行的任务列表。 在当前版本的应用中，我最多只能得到一个结果，因为我不允许多个导出任务同时执行，但将来我可能要支持可以共存的其他类型的任务，所以以通用的方式渲染Alert可以节省我以后的时间。</p> 
<p>对于每项任务，我都会在页面上渲染一个Alert元素。 Alert的颜色由第二个CSS样式控制，本处是<code>alert-success</code>，而在闪现消息是<code>alert-info</code>。 <a href="https://getbootstrap.com/docs/3.3/components/#alerts" rel="nofollow">Bootstrap文档</a>包含有关Alert的HTML结构的详细信息。 Alert文本包括存储在<code>Task</code>模型中的<code>description</code>字段，后面跟着完成百分比。</p> 
<p>百分比被封装在具有<code>id</code>属性的<code>&lt;span&gt;</code>元素中。 原因是我要在收到通知时用JavaScript刷新百分比。 我给任务ID末尾附加<code>-progress</code>来构造<code>id</code>属性。 当有通知到达时，通过其中的任务ID，我可以很容易地使用<code>#&lt;task.id&gt;-progress</code>选择器找到正确的<code>&lt;span&gt;</code>元素来更新。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">如果此时尝试该应用程序，则每次导航到新页面时，您都将看到“静态”进度更新。您会注意到，启动导出任务后，您可以自由导航至应用程序的不同页面，并且始终会调用正在运行的任务的状态。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">为了准备将动态更新应用于百分比<code>&lt;span&gt;</code>元素，我将在JavaScript端编写一些辅助函数：</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / templates / base.html</em>：</span>动态更新任务进度的辅助函数。</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-html">...
{% block scripts %}
    ...
    &lt;script&gt;
        ...
        function set_task_progress(task_id, progress) {
            $('#' + task_id + '-progress').text(progress);
        }
    &lt;/script&gt;
    ...
{% endblock %}
</code></pre> 
<p>这个函数接受一个任务<code>id</code>和一个进度值，并使用jQuery为这个任务定位<code>&lt;span&gt;</code>元素，并将新进度作为其内容写入。 实际上不需要验证页面上是否存在该元素，因为如果没有找到该元素，jQuery将不会执行任何操作。</p> 
<p><em>app/tasks.py</em>中的<code>_set_task_progress()</code>函数每次更新进度时调用<code>add_notification()</code>，就会产生新的通知。 而我在<a href="https://blog.csdn.net/gh254172840/article/details/81410382">第二十一章</a>明智地以完全通用的方式实现了通知功能。 所以当浏览器定期向服务器发送通知更新请求时，浏览器会获得通过<code>add_notification()</code>方法添加的任何通知。</p> 
<p>但是，这些JavaScript代码只能识别具有<code>unread_message_count</code>名称的那些通知，并忽略其余部分。 我现在需要做的是扩展该函数，通过调用我上面定义的<code>set_task_progress()</code>函数来处理<code>task_progress</code>通知。 以下是处理通知更新版本JavaScript代码：</p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app / templates / base.html</em>：通知处理。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-html">                        for (var i = 0; i &lt; notifications.length; i++) {
                            switch (notifications[i].name) {
                                case 'unread_message_count':
                                    set_message_count(notifications[i].data);
                                    break;
                                case 'task_progress':
                                    set_task_progress(
                                        notifications[i].data.task_id,
                                        notifications[i].data.progress);
                                    break;
                            }
                            since = notifications[i].timestamp;
                        }
</code></pre> 
<p>现在我需要处理两个不同的通知，我决定用一个<code>switch</code>语句替换检查<code>unread_message_count</code>通知名称的<code>if</code>语句，该语句包含我现在需要支持的每个通知。 如果您对“C”系列语言不熟悉，就可能从未见过switch语句，它提供了一种方便的语法，可以替代一长串的<code>if/elseif</code>语句。这是一个很棒的特性，因为当我需要支持更多通知时，只需简单地添加<code>case</code>块即可。</p> 
<p>回顾一下，RQ任务附加到<code>task_progress</code>通知的数据是一个包含两个元素<code>task_id</code>和<code>progress</code>的字典，这两个元素是我用来调用<code>set_task_progress()</code>的两个参数。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">如果立即运行该应用程序，则在通知发送到客户端时，绿色警报框中的进度指示器将每10秒刷新一次。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">由于我在本章中介绍了新的可翻译字符串，因此需要更新翻译文件。如果要维护非英语文件，则需要使用Flask-Babel刷新翻译文件，然后添加新翻译：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint">(venv) $ flask translate update</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">如果您使用的是西班牙语翻译，</span>那么我已经为您完成了翻译工作，因此可以从<a href="https://github.com/miguelgrinberg/microblog/archive/version-0.22.zip">下载包</a>中提取<em>app/translations/es/LC_MESSAGES/messages.po</em>文件，并将其添加到您的项目中。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">翻译完成后，您必须编译翻译文件：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint">(venv) $ flask translate compile</code></pre> 
<h3><span style="color:#333333;">部署注意事项</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">为了完成本章，我想讨论应用程序部署的变化。为了支持后台任务，我向堆栈中添加了两个新组件，一个Redis服务器以及一个/多个RQ worker。</span> 很明显，它们需要包含在部署策略中，因此我将简要介绍前几章中不同部署方式的一些调整。</p> 
<h4><span style="color:#333333;">在Linux服务器上部署</span></h4> 
<p style="margin-left:0px;"><span style="color:#333333;">如果要在Linux服务器上运行应用，则添加Redis就像从操作系统安装此软件包一样简单。对于Ubuntu Linux，您必须运行<code>sudo apt-get install redis-server</code>。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">要运行RQ worker进程，您可以按照<a href="https://blog.csdn.net/gh254172840/article/details/81410355">第17章中</a>的“设置Gunicorn和Supervisor”部分来创建第二个Supervisor配置，</span>在其中运行的命令改成<code>rq worker microblog-tasks</code>。 如果您想要运行多个worker（假设是生产环境），则可以使用Supervisor的<code>numprocs</code>指令来指示要同时运行多少个实例。</p> 
<h4><span style="color:#333333;">在Heroku上部署</span></h4> 
<p style="margin-left:0px;"><span style="color:#333333;">要在Heroku上部署该应用，您需要向您的帐户添加Redis服务。这类似于我用来添加Postgres数据库的过程。Redis也有一个免费套餐，可以使用以下命令添加它：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint">$ heroku addons:create heroku-redis:hobby-dev</code></pre> 
<p>新的redis服务的访问URL将作为<code>REDIS_URL</code>变量添加到您的Heroku环境中，这正是应用所需的。</p> 
<p>Heroku的免费方案允许同时启动一个web进程和一个worker进程，因此您可以在免费的情况下启动一个<code>rq</code> worker进程。 为此，您将需要在procfile的一个单独的行中声明worker：</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint">web: flask db upgrade; flask translate compile; gunicorn microblog:app
worker: rq worker microblog-tasks</code></pre> 
<p style="margin-left:0px;">将这些变更重新部署之后，可以使用以下命令启动worker：</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint">$ heroku ps:scale worker=1</code></pre> 
<h4><span style="color:#333333;">在Docker上部署</span></h4> 
<p style="margin-left:0px;"><span style="color:#333333;">如果要将应用部署到Docker容器，则首先需要创建一个Redis容器。为此，</span>您可以使用Docker镜像仓库中的其中一个官方Redis镜像：</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint">$ docker run --name redis -d -p 6379:6379 redis:3-alpine</code></pre> 
<p style="margin-left:0px;">当运行您的应用时，您需要以类似于MySQL容器的链接方式，链接redis容器并设置<code>REDIS_URL</code>环境变量。 下面是一个完整的命令来启动应用，包含了一个redis链接：</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint">$ docker run --name microblog -d -p 8000:5000 --rm -e SECRET_KEY=my-secret-key \
    -e MAIL_SERVER=smtp.googlemail.com -e MAIL_PORT=587 -e MAIL_USE_TLS=true \
    -e MAIL_USERNAME=&lt;your-gmail-username&gt; -e MAIL_PASSWORD=&lt;your-gmail-password&gt; \
    --link mysql:dbserver --link redis:redis-server \
    -e DATABASE_URL=mysql+pymysql://microblog:&lt;database-password&gt;@dbserver/microblog \
    -e REDIS_URL=redis://redis-server:6379/0 \
    microblog:latest</code></pre> 
<p style="margin-left:0px;">最后，您需要为RQ worker运行一/多个容器。 由于worker与主应用具有相同的代码，因此可以使用与应用相同的容器镜像，并覆盖启动命令，以便启动worker而不是Web应用。 以下是启动worker的<code>docker run</code>命令：</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint">$ docker run --name rq-worker -d --rm -e SECRET_KEY=my-secret-key \
    -e MAIL_SERVER=smtp.googlemail.com -e MAIL_PORT=587 -e MAIL_USE_TLS=true \
    -e MAIL_USERNAME=&lt;your-gmail-username&gt; -e MAIL_PASSWORD=&lt;your-gmail-password&gt; \
    --link mysql:dbserver --link redis:redis-server \
    -e DATABASE_URL=mysql+pymysql://microblog:&lt;database-password&gt;@dbserver/microblog \
    -e REDIS_URL=redis://redis-server:6379/0 \
    --entrypoint venv/bin/rq \
    microblog:latest worker -u redis://redis-server:6379/0 microblog-tasks</code></pre> 
<p style="margin-left:0px;">覆盖Docker镜像的默认启动命令有点棘手，因为命令需要分两部分给出。 <code>--entrypoint</code>参数只取得可执行文件的名称，但是参数（如果有的话）需要在镜像和标签之后，也就是在命令行的结尾处给出。 请注意<code>rq</code>命令需要使用<code>venv/bin/rq</code>，以便在没有手动激活虚拟环境的情况下，也能识别虚拟环境并正常工作。</p> 
<hr> 
<p>原文链接：<a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xxii-background-jobs" rel="nofollow">https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xxii-background-jobs</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1fe862c3d05eaabcafb310215b3078a5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构c语言版习题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b0c24849d512d22dd74419e7faabe5fd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">002_简单的基础知识</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>