<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>牛客网java常考面试题笔记 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="牛客网java常考面试题笔记" />
<meta property="og:description" content="1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
Java虚拟机是一个可以执行Java字节码的虚拟机进程。
java的跨平台不是java源程序的跨平台，如果是这样，那么所以语言都是跨平台的， java源程序先经过javac编译器编译成二进制的.class字节码文件（java的跨平台指的就是.class字节码文件的跨平台，.class字节码文件是与平台无关的），.class文件再运行在jvm上，java解释器（jvm的一部分）会将其解释成对应平台的机器码执行，所以java所谓的跨平台就是在不同平台上安装了不同的jvm，而在不同平台上生成的.class文件都是一样的，而.class文件再由对应平台的jvm解释成对应平台的机器码执行。
2. JDK和JRE的区别是什么？
JRE： Java Runtime Environment JDK：Java Development Kit
JRE顾名思义是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。
JDK顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。
如果你需要运行java程序，只需安装JRE就可以了。如果你需要编写java程序，需要安装JDK。
JRE根据不同操作系统（如：windows，linux等）和不同JRE提供商（IBM,ORACLE等）有很多版本 3. ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？
Static表示静态的意思，可用于修饰成员变量和成员函数，被静态修饰的成员函数只能访问静态成员，不可以访问非静态成员。静态是随着类的加载而加载的，因此可以直接用类进行访问。重写是子类中的方法和子类继承的父类中的方法一样（函数名，参数，参数类型，反回值类型），但是子类中的访问权限要不低于父类中的访问权限。重写的前提是必须要继承，private修饰不支持继承，因此被私有的方法不可以被重写。静态方法形式上可以被重写，即子类中可以重写父类中静态的方法。但是实际上从内存的角度上静态方法不可以被重写。
4. 是否可以在static环境中访问非static变量？
因为静态的成员属于类，随着类的加载而加载到静态方法区内存，当类加载时，此时不一定有实例创建，没有实例，就不可以访问非静态的成员。
static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。
5. Java支持的数据类型有哪些？什么是自动拆装箱？
基本数据类型： 整数值型：byte,short,int,long, 字符型：char 浮点类型：float,double 布尔型：boolean 整数默认int型，小数默认是double型。Float和long类型的必须加后缀。首先知道String是引用类型不是基本类型，引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。引用类型包括类、接口、数组等。String类还是final修饰的。 而包装类就属于引用类型，自动装箱和拆箱就是基本类型和引用类型之间的转换，至于为什么要转换，因为基本类型转换为引用类型后，就可以new对象，从而调用包装类中封装好的方法进行基本类型之间的转换或者toString（当然用类名直接调用也可以，便于一眼看出该方法是静态的），还有就是如果集合中想存放基本类型，泛型的限定类型只能是对应的包装类型
6. Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？
方法重写的原则：
1) 重写方法的方法名称、参数列表必须与原方法的相同，返回类型可以相同也可以是原类型的子类型(从Java SE5开始支持)。 2) 重写方法不能比原方法访问性差（即访问权限不允许缩小）。 3) 重写方法不能比原方法抛出更多的异常。 4) 被重写的方法不能是final类型，因为final修饰的方法是无法重写的。 5) 被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行重写。 6) 被重写的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足重写条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足重写条件，但是仍然不会发生重写，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。 7) 重写是发生在运行时的，因为编译期编译器不知道并且没办法确定该去调用哪个方法，JVM会在代码运行的时候作出决定。 方法重载的原则：
1) 方法名称必须相同。 2) 参数列表必须不同（个数不同、或类型不同、参数类型排列顺序不同等）。 3) 方法的返回类型可以相同也可以不相同。 4) 仅仅返回类型不同不足以成为方法的重载。 5) 重载是发生在编译时的，因为编译器可以根据参数的类型来选择使用哪个方法。 重写和重载的不同：
1) 方法重写要求参数列表必须一致，而方法重载要求参数列表必须不一致。 2) 方法重写要求返回类型必须一致(或为其子类型)，方法重载对此没有要求。 3) 方法重写只能用于子类重写父类的方法，方法重载用于同一个类中的所有方法。 4) 方法重写对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。 5) 父类的一个方法只能被子类重写一次，而一个方法可以在所有的类中可以被重载多次。 6) 重载是编译时多态，重写是运行时多态。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/e1f84f4b4076ee5602dcad26a20ff1c6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-21T09:30:37+08:00" />
<meta property="article:modified_time" content="2018-03-21T09:30:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">牛客网java常考面试题笔记</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#7D7D7D;"></span></p> 
<p><span style="color:#7D7D7D;">1.   </span><span style="color:#7D7D7D;background:#FFFFFF;">什么是</span><span style="color:#7D7D7D;background:#FFFFFF;">Java</span><span style="color:#7D7D7D;background:#FFFFFF;">虚拟机？为什么</span><span style="color:#7D7D7D;background:#FFFFFF;">Java</span><span style="color:#7D7D7D;background:#FFFFFF;">被称作是</span><span style="color:#7D7D7D;background:#FFFFFF;">“</span><span style="color:#7D7D7D;background:#FFFFFF;">平台无关的编程语言</span><span style="color:#7D7D7D;background:#FFFFFF;">”</span><span style="color:#7D7D7D;background:#FFFFFF;">？</span></p> 
<p><span style="background:#D3F4EF;">Java</span><span style="background:#D3F4EF;">虚拟机是一个可以执行</span><span style="background:#D3F4EF;">Java</span><span style="background:#D3F4EF;">字节码的虚拟机进程。</span><br>java的跨平台不是java源程序的跨平台，如果是这样，那么所以语言都是跨平台的， java源程序先经过javac编译器编译成二进制的.class字节码文件（<span style="color:#FF0000;">java</span><span style="color:#FF0000;">的跨平台指的就是</span><span style="color:#FF0000;">.class</span><span style="color:#FF0000;">字节码文件的跨平台</span>，.class字节码文件是与平台无关的），.class文件再运行在jvm上，java解释器（jvm的一部分）会将其解释成对应平台的机器码执行，所以java所谓的跨平台就是在不同平台上安装了不同的jvm，而在不同平台上生成的.class文件都是一样的，而.class文件再由对应平台的jvm解释成对应平台的机器码执行。</p> 
<p><span style="color:#333333;">2.    </span><span style="color:#333333;background:#FFFFFF;">JDK</span><span style="color:#333333;background:#FFFFFF;">和</span><span style="color:#333333;background:#FFFFFF;">JRE</span><span style="color:#333333;background:#FFFFFF;">的区别是什么？</span><br>JRE： Java Runtime Environment  <br>JDK：Java Development Kit<br>JRE顾名思义是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。<br>JDK顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。<span style="color:#FF0000;">JDK</span><span style="color:#FF0000;">包含了JRE</span>，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。<br>如果你需要运行java程序，只需安装JRE就可以了。如果你需要编写java程序，需要安装JDK。</p> 
<p align="left">JRE根据不同操作系统（如：windows，linux等）和不同JRE提供商（IBM,ORACLE等）有很多版本  </p> 
<p>3.      <span style="color:#333333;background:#FFFFFF;">”static”</span><span style="color:#333333;background:#FFFFFF;">关键字是什么意思？</span><span style="color:#333333;background:#FFFFFF;">Java</span><span style="color:#333333;background:#FFFFFF;">中是否可以覆盖</span><span style="color:#333333;background:#FFFFFF;">(override)</span><span style="color:#333333;background:#FFFFFF;">一个</span><span style="color:#333333;background:#FFFFFF;">private</span><span style="color:#333333;background:#FFFFFF;">或者是</span><span style="color:#333333;background:#FFFFFF;">static</span><span style="color:#333333;background:#FFFFFF;">的方法？</span><br>Static表示静态的意思，可用于修饰成员变量和成员函数，被静态修饰的成员函数只能访问静态成员，不可以访问非静态成员。静态是随着类的加载而加载的，因此可以直接用类进行访问。重写是子类中的方法和子类继承的父类中的方法一样（函数名，参数，参数类型，反回值类型），但是子类中的访问权限要不低于父类中的访问权限。<span style="color:#FF0000;">重写的前提是必须要继承</span>，private修饰不支持继承，因此被私有的方法不可以被重写。静态方法形式上可以被重写，即子类中可以重写父类中静态的方法。但是实际上从内存的角度上静态方法不可以被重写。</p> 
<p>4.      <span style="color:#7D7D7D;background:#FFFFFF;">是否可以在</span><span style="color:#7D7D7D;background:#FFFFFF;">static</span><span style="color:#7D7D7D;background:#FFFFFF;">环境中访问非</span><span style="color:#7D7D7D;background:#FFFFFF;">static</span><span style="color:#7D7D7D;background:#FFFFFF;">变量？</span></p> 
<p><strong><span style="color:#000000;background:#FFFFFF;">因为静态的成员属于类，</span><span style="color:#FF0000;background:#FFFFFF;">随着类的加载而加载到静态方法区内存</span><span style="color:#000000;background:#FFFFFF;">，当类加载时，此时不一定有实例创建，没有实例，就不可以访问非静态的成员。</span></strong></p> 
<p><span style="color:#333333;background:#D3F4EF;">static</span><span style="color:#333333;background:#D3F4EF;">变量在</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">中是属于类的，它在所有的实例中的值是一样的。当类被</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">虚拟机载入的时候，会对</span><span style="color:#333333;background:#D3F4EF;">static</span><span style="color:#333333;background:#D3F4EF;">变量进行初始化。如果你的代码尝试不用实例来访问非</span><span style="color:#333333;background:#D3F4EF;">static</span><span style="color:#333333;background:#D3F4EF;">的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</span></p> 
<p><strong>5.       </strong><span style="color:#333333;background:#FFFFFF;">Java</span><span style="color:#333333;background:#FFFFFF;">支持的数据类型有哪些？什么是自动拆装箱？</span><strong></strong></p> 
<p align="left">基本数据类型： 整数值型：byte,short,int,long, 字符型：char 浮点类型：float,double 布尔型：boolean 整数默认int型，小数默认是double型。Float和long类型的必须加后缀。首先知道<span style="color:#FF0000;">String</span><span style="color:#FF0000;">是引用类型不是基本类型</span>，引用类型声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。引用类型包括类、接口、数组等。String类还是final修饰的。 而包装类就属于引用类型，<span style="color:#FF0000;">自动装箱和拆箱就是基本类型和引用类型之间的转换</span>，至于为什么要转换，因为基本类型转换为引用类型后，就可以new对象，从而调用包装类中封装好的方法进行基本类型之间的转换或者toString（当然用类名直接调用也可以，便于一眼看出该方法是静态的），还有就是如果集合中想存放基本类型，泛型的限定类型只能是对应的包装类型</p> 
<p align="left">6.  <span style="color:#333333;background:#FFFFFF;">Java</span><span style="color:#333333;background:#FFFFFF;">中的方法覆盖</span><span style="color:#333333;background:#FFFFFF;">(Overriding)</span><span style="color:#333333;background:#FFFFFF;">和方法重载</span><span style="color:#333333;background:#FFFFFF;">(Overloading)</span><span style="color:#333333;background:#FFFFFF;">是什么意思？</span></p> 
<p align="left">方法重写的原则：</p> 
<p align="left">1) <span style="color:#FF0000;">重写方法的方法名称、参数列表必须与原方法的相同，返回类型可以相同也可以是原类型的子类型</span>(从Java SE5开始支持)。 </p> 
<p align="left">2) 重写方法不能比原方法访问性差（即访问权限不允许缩小）。 </p> 
<p align="left">3) 重写方法不能比原方法抛出更多的异常。 </p> 
<p align="left">4) 被重写的方法不能是final类型，因为final修饰的方法是无法重写的。 </p> 
<p align="left">5) 被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行重写。 </p> 
<p align="left">6) 被重写的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足重写条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足重写条件，但是仍然不会发生重写，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。 </p> 
<p align="left">7) 重写是发生在运行时的，因为编译期编译器不知道并且没办法确定该去调用哪个方法，JVM会在代码运行的时候作出决定。 </p> 
<p align="left">方法重载的原则：</p> 
<p align="left"><span style="color:#FF0000;">1)  </span><span style="color:#FF0000;">方法名称必须相同。 </span></p> 
<p align="left">2) <span style="color:#FF0000;">参数列表必须不同</span>（个数不同、或类型不同、参数类型排列顺序不同等）。 </p> 
<p align="left">3) 方法的返回类型可以相同也可以不相同。 </p> 
<p align="left">4) 仅仅返回类型不同不足以成为方法的重载。 </p> 
<p align="left">5) 重载是发生在编译时的，因为编译器可以根据参数的类型来选择使用哪个方法。 </p> 
<p align="left">重写和重载的不同：</p> 
<p align="left">1) <span style="color:#FF0000;">方法重写要求参数列表必须一致，而方法重载要求参数列表必须不一致</span>。 </p> 
<p align="left">2) 方法重写要求返回类型必须一致(或为其子类型)，方法重载对此没有要求。 </p> 
<p align="left">3) <span style="color:#FF0000;">方法重写只能用于子类重写父类的方法，方法重载用于同一个类中的所有方法</span>。 </p> 
<p align="left">4) 方法重写对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。 </p> 
<p align="left">5) <span style="color:#FF0000;">父类的一个方法只能被子类重写一次，而一个方法可以在所有的类中可以被重载多次</span>。 </p> 
<p align="left">6) <span style="color:#FF0000;">重载是编译时多态，重写是运行时多态</span>。</p> 
<p align="left"><span style="color:#333333;">7.    </span><span style="color:#333333;background:#FFFFFF;">Java</span><span style="color:#333333;background:#FFFFFF;">中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？</span><br>Java中的构造函数是为了<span style="color:#FF0000;">初始化对象的</span>，构造函数的函数名和类名一致，默认的构造函数没有参数，没有返回值，构造函数的函数体内，没有内容。构造函数的重载是函数名与类名相同，参数类型不同，参数不同。同样的作用也是为了初始化对象的。 Java中没有拷贝构造函数的概念！</p> 
<p align="left">关于复制构造函数：C++中的复制构造函数通常有三种作用</p> 
<p align="left">1.<span style="color:#FF0000;">对象作为函数参数</span> </p> 
<p align="left">2.对象作为函数返回值 </p> 
<p align="left">3.使用一个对象对另一个对象初始化。 </p> 
<p align="left">C++语法允许用户定义自己的复制构造函数以实现自定义的复制，比如说进行深复制。<span style="color:#FF0000;">Java</span><span style="color:#FF0000;">并不支持这样的复制构造函数</span>。但是这并不代表Java中没有这种机制，在Java中Object类的clone()方法就是这种机制的体现。而且通过以上三种方式对Java对象进行的操作都是对引用的操作，不像C++里面是对原对象的操作，因此Java中也不需要考虑需要使用复制构造函数这种问题。</p> 
<p align="left">   <span style="color:#333333;background:#D3F4EF;">当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，</span><span style="color:#FF0000;background:#D3F4EF;">Java</span><span style="color:#FF0000;background:#D3F4EF;">编译器会为这个类创建一个默认的构造方法</span><span style="color:#333333;background:#D3F4EF;">。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">Java</span></span><span style="color:#333333;background:#D3F4EF;">中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">Java</span></span><span style="color:#333333;background:#D3F4EF;">不支持像</span><span style="color:#333333;background:#D3F4EF;">C++</span><span style="color:#333333;background:#D3F4EF;">中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">不会创建默认的复制构造方法。</span></p> 
<p align="left"><span style="color:#333333;">8.   </span><span style="color:#333333;background:#FFFFFF;">Java</span><span style="color:#333333;background:#FFFFFF;">支持多继承么？</span><br><span style="color:#FF0000;">Java</span><span style="color:#FF0000;">中类不支持多继承</span>，只支持单继承（即一个类只有一个父类）。 但是<span style="color:#FF0000;">java</span><span style="color:#FF0000;">中的接口支持多继承</span>，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</p> 
<p align="left"><span style="color:#333333;">9.   </span><span style="color:#333333;background:#FFFFFF;">接口和抽象类的区别是什么？</span></p> 
<p align="left"><span style="color:#FF0000;background:#FFFFFF;">从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范</span><span style="color:#000000;background:#FFFFFF;">。</span></p> 
<p align="left"><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">类可以实现很多个接口，但是只能继承一个抽象类</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">抽象类可以在不提供接口方法实现的情况下实现接口。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">Java</span></span><span style="color:#333333;background:#D3F4EF;">接口中声明的变量默认都是</span><span style="color:#333333;background:#D3F4EF;">final</span><span style="color:#333333;background:#D3F4EF;">的。抽象类可以包含非</span><span style="color:#333333;background:#D3F4EF;">final</span><span style="color:#333333;background:#D3F4EF;">的变量。</span><span style="color:#333333;"><br></span><span style="color:#FF0000;background:#D3F4EF;">Java</span><span style="color:#FF0000;background:#D3F4EF;">接口中的成员函数默认是</span><span style="color:#FF0000;background:#D3F4EF;">public</span><span style="color:#FF0000;background:#D3F4EF;">的。抽象类的成员函数可以是</span><span style="color:#FF0000;background:#D3F4EF;">private</span><span style="color:#FF0000;background:#D3F4EF;">，</span><span style="color:#FF0000;background:#D3F4EF;">protected</span><span style="color:#FF0000;background:#D3F4EF;">或者是</span><span style="color:#FF0000;background:#D3F4EF;">public</span><span style="color:#FF0000;background:#D3F4EF;">。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含</span><span style="color:#333333;background:#D3F4EF;">main</span><span style="color:#333333;background:#D3F4EF;">方法的话是可以被调用的。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">也可以参考</span><span style="color:#333333;background:#D3F4EF;">JDK8</span><span style="color:#333333;background:#D3F4EF;">中抽象类和接口的区别</span></p> 
<p align="left"><span style="color:#333333;">10. </span><span style="color:#333333;background:#FFFFFF;">什么是值传递和引用传递？</span></p> 
<p align="left"><span style="color:#333333;background:#FFFFFF;"> </span><span style="color:#FF0000;">值传递是对基本型变量而言的</span><span style="color:#333333;">,</span><span style="color:#333333;">传递的是该变量的一个副本</span><span style="color:#333333;">,</span><span style="color:#333333;">改变副本不影响原变量</span><span style="color:#333333;">.</span></p> 
<p align="left"><span style="color:#FF0000;">引用传递一般是对于对象型变量而言的</span><span style="color:#333333;">,</span><span style="color:#333333;">传递的是该对象地址的一个副本</span><span style="color:#333333;">, </span><span style="color:#333333;">并不是原对象本身</span><span style="color:#333333;"> </span><span style="color:#333333;">。</span></p> 
<p align="left"><span style="color:#333333;">一般认为</span><span style="color:#333333;">,java</span><span style="color:#333333;">内的传递都是值传递</span><span style="color:#333333;">. java</span><span style="color:#333333;">中实例对象的传递是引用传递</span><span style="color:#333333;">  </span><br>public void add(int a) { int b = a; } 这个可以看作是值传递，a是基本数据类型，他把他的值传给了b public void add(Object obj) { Object objTest = obj; } 这个可以看作是址传递，obj是引用数据类型，是把他栈中指向堆中的对象的地址值赋值给了objTest. 这时候就同时有两个引用指向了堆中的某个Object对象其实这样看来，java应该只有值传递的。如果是基本数据类型，传递的就是实际的值. 如果是引用数据类型，传递的就是该引用的地址值.</p> 
<p align="left"><span style="color:#333333;">11. </span><span style="color:#333333;background:#FFFFFF;">进程和线程的区别是什么？</span></p> 
<p align="left"><span style="color:#333333;"> </span><span style="color:#333333;">进程是执行着的应用程序，而线程是进程内部的一个执行序列。</span><span style="color:#FF0000;">一个进程可以有多个线程</span><span style="color:#333333;">。线程又叫做轻量级进程。</span></p> 
<p align="left"><span style="color:#333333;">线程的划分小于进程，线程隶属于某个进程。</span><span style="color:#333333;">进程是程序的一种动态形式，是</span><span style="color:#333333;">CPU</span><span style="color:#333333;">、内存等资源占用的基本单位，而线程是不能占有这些资源的。</span><span style="color:#333333;">进程之间相互独立，通信比较困难，而线程之间共享一块内存区域，通信比较方便。</span><span style="color:#333333;">进程在执行的过程中，包含比较固定的入口，执行顺序，出口，而线程的这些过程会被应用程序所控制</span></p> 
<p align="left"><strong>线程与进程的区别归纳：</strong> </p> 
<p align="left"><strong>a.地址空间和其它资源</strong>：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。 </p> 
<p align="left"><strong>b.通信：</strong>进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。 </p> 
<p align="left"><strong>c.调度和切换</strong>：线程上下文切换比进程上下文切换要快得多。 </p> 
<p align="left">d.在多线程OS中，进程不是一个可执行的实体。</p> 
<p align="left">12.<span style="color:#333333;background:#FFFFFF;">创建线程有几种不同的方式？你喜欢哪一种？为什么？</span></p> 
<p align="left"> <span style="color:#333333;background:#D3F4EF;">有</span><span style="color:#333333;background:#D3F4EF;">4</span><span style="color:#333333;background:#D3F4EF;">种方式可以用来创建线程：</span><span style="color:#333333;"><br></span><span style="color:#FF0000;background:#D3F4EF;">继承</span><span style="color:#FF0000;background:#D3F4EF;">Thread</span><span style="color:#FF0000;background:#D3F4EF;">类</span><span style="color:#FF0000;"><br></span><span style="color:#FF0000;background:#D3F4EF;">实现</span><span style="color:#FF0000;background:#D3F4EF;">Runnable</span><span style="color:#FF0000;background:#D3F4EF;">接口</span><span style="color:#FF0000;"><br></span><span style="color:#FF0000;background:#D3F4EF;">应用程序可以使用</span><span style="color:#FF0000;background:#D3F4EF;">Executor</span><span style="color:#FF0000;background:#D3F4EF;">框架来创建线程池</span></p> 
<p align="left"><span style="color:#333333;">实现</span><span style="color:#333333;">Runnable</span><span style="color:#333333;">接口这种方式更受欢迎，因为这不需要继承</span><span style="color:#333333;">Thread</span><span style="color:#333333;">类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而</span><span style="color:#333333;">Java</span><span style="color:#333333;">不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</span></p> 
<p align="left"><span style="color:#FF0000;">还有一种方式是实现</span><span style="color:#FF0000;">Callable</span><span style="color:#FF0000;">接口</span></p> 
<p align="left"><span style="color:#333333;">①</span><span style="color:#333333;">继承Thread</span>类（真正意义上的线程类），是Runnable接口的实现。 </p> 
<p align="left"><span style="color:#333333;">②</span><span style="color:#333333;">实现Runnable</span>接口，并重写里面的run方法。 </p> 
<p align="left"><span style="color:#333333;">③</span><span style="color:#333333;">使用Executor</span>框架创建线程池。Executor框架是juc里提供的线程池的实现。 </p> 
<p align="left"><span style="color:#333333;">调用线程的start()</span>：启动此线程；调用相应的run()方法 </p> 
<p align="left"><span style="color:#333333;">继承于Thread</span>类的线程类，可以直接调用start方法启动线程（使用static也可以实现资源共享）.一个线程（对象）只能够执行一次start()，而且不能通过Thread实现类对象的run()去启动一个线程。 </p> 
<p align="left"><span style="color:#333333;">实现Runnable</span>接口的类需要再次用Thread类包装后才能调用start方法。（三个Thread对象包装一个类对象，就实现了资源共享）。 </p> 
<p align="left"><span style="color:#333333;">线程的使用的话，注意锁和同步的使用。（多线程访问共享资源容易出现线程安全问题）</span> </p> 
<p align="left"><span style="color:#333333;">一般情况下，常见的是第二种。</span> </p> 
<p align="left"><span style="color:#333333;">* Runnable</span><span style="color:#333333;">接口有如下好处：</span> </p> 
<p align="left"><span style="color:#333333;">*①</span><span style="color:#333333;">避免点继承的局限，一个类可以继承多个接口。</span> </p> 
<p align="left"><span style="color:#333333;">*②</span><span style="color:#333333;">适合于资源的共享</span> </p> 
<p align="left"><span style="color:#333333;"> </span> <span style="color:#333333;">/*</span> </p> 
<p align="left"><span style="color:#333333;"> * Thread</span><span style="color:#333333;">的常用方法：</span> </p> 
<p align="left"><span style="color:#333333;"> * 1.start()</span><span style="color:#333333;">：启动线程并执行相应的run()</span>方法 </p> 
<p align="left"><span style="color:#333333;"> * 2.run():</span><span style="color:#333333;">子线程要执行的代码放入run()</span>方法中 </p> 
<p align="left"><span style="color:#333333;"> * 3.currentThread()</span><span style="color:#333333;">：静态的，调取当前的线程</span> </p> 
<p align="left"><span style="color:#333333;"> * 4.getName():</span><span style="color:#333333;">获取此线程的名字</span> </p> 
<p align="left"><span style="color:#333333;"> * 5.setName():</span><span style="color:#333333;">设置此线程的名字</span> </p> 
<p align="left"><span style="color:#333333;"> * 6.yield():</span><span style="color:#333333;">调用此方法的线程释放当前CPU</span>的执行权（很可能自己再次抢到资源） </p> 
<p align="left"><span style="color:#333333;"> * 7.join():</span><span style="color:#333333;">在A</span>线程中调用B线程的join()方法，表示：当执行到此方法，A线程停止执行，直至B线程执行完毕， </p> 
<p align="left"><span style="color:#333333;"> * A</span><span style="color:#333333;">线程再接着join()</span>之后的代码执行 </p> 
<p align="left"><span style="color:#333333;"> * 8.isAlive():</span><span style="color:#333333;">判断当前线程是否还存活</span> </p> 
<p align="left"><span style="color:#333333;"> * 9.sleep(long l):</span><span style="color:#333333;">显式的让当前线程睡眠l</span>毫秒  (只能捕获异常，因为父类run方法没有抛异常) </p> 
<p align="left"><span style="color:#333333;"> * 10.</span><span style="color:#333333;">线程通信（方法在Object</span>类中）：wait()  notify()  notifyAll() </p> 
<p align="left"><span style="color:#333333;"> * </span></p> 
<p align="left"><span style="color:#333333;"> *</span><span style="color:#333333;">设置线程的优先级（非绝对，只是相对几率大些）</span> </p> 
<p align="left"><span style="color:#333333;"> * getPriority()</span><span style="color:#333333;">：返回线程优先值</span> </p> 
<p align="left"><span style="color:#333333;"> * setPriority(int newPriority)</span><span style="color:#333333;">：改变线程的优先级</span> </p> 
<p align="left"><span style="color:#333333;"> */</span></p> 
<p align="left"><span style="color:#333333;">13. </span><span style="color:#333333;background:#FFFFFF;">概括的解释下线程的几种可用状态。</span></p> 
<p align="left"><span style="color:#195F91;">1.</span><span style="color:#93A1A1;">新建(</span><span style="color:#1E347B;">new</span><span style="color:#93A1A1;">)</span><span style="color:#93A1A1;">：新创建了一个线程对象。</span></p> 
<p align="left"><span style="color:#195F91;">2.</span><span style="color:#93A1A1;">可运行(</span><span style="color:#48484C;">runnable</span><span style="color:#93A1A1;">)</span><span style="color:#93A1A1;">：线程对象创建后，其他线程(</span>比如<span style="color:#48484C;">main</span><span style="color:#93A1A1;">线程）调用了该对象 的</span><span style="color:#48484C;">start</span><span style="color:#93A1A1;">()</span><span style="color:#93A1A1;">方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取</span><span style="color:#48484C;">cpu </span><span style="color:#93A1A1;">的使用权</span><span style="color:#93A1A1;">。</span></p> 
<p align="left"><span style="color:#195F91;">3.</span><span style="color:#93A1A1;">运行(</span><span style="color:#48484C;">running</span><span style="color:#93A1A1;">)</span><span style="color:#93A1A1;">：可运行状态(</span><span style="color:#48484C;">runnable</span><span style="color:#93A1A1;">)</span><span style="color:#93A1A1;">的线程获得了</span><span style="color:#48484C;">cpu </span><span style="color:#93A1A1;">时间片（</span><span style="color:#48484C;">timeslice</span><span style="color:#93A1A1;">）</span><span style="color:#93A1A1;">，执行程序代码。</span></p> 
<p align="left"><span style="color:#195F91;">4.</span><span style="color:#93A1A1;">阻塞(</span><span style="color:#48484C;">block</span><span style="color:#93A1A1;">)</span><span style="color:#93A1A1;">：阻塞状态是指线程因为某种原因放弃了</span><span style="color:#48484C;">cpu </span><span style="color:#93A1A1;">使用权，也即让出了 </span><span style="color:#48484C;">cputimeslice</span><span style="color:#93A1A1;">，暂时停止运行。直到线程进入可运行(</span><span style="color:#48484C;">runnable</span><span style="color:#93A1A1;">)</span><span style="color:#93A1A1;">状态，才有机会再次获得</span><span style="color:#48484C;">cpu timeslice </span><span style="color:#93A1A1;">转到运行(</span><span style="color:#48484C;">running</span><span style="color:#93A1A1;">)</span><span style="color:#93A1A1;">状态。</span></p> 
<p align="left"><span style="color:#93A1A1;">阻塞的情况分三种：</span></p> 
<p align="left"><span style="color:#93A1A1;">(</span><span style="color:#93A1A1;">一).</span><span style="color:#93A1A1;">等待阻塞：运行(</span><span style="color:#48484C;">running</span><span style="color:#93A1A1;">)</span><span style="color:#93A1A1;">的线程执行</span><span style="color:#48484C;">o</span><span style="color:#93A1A1;">.</span><span style="color:#48484C;">wait</span><span style="color:#93A1A1;">()</span><span style="color:#93A1A1;">方法，</span><span style="color:#48484C;">JVM</span><span style="color:#93A1A1;">会把该线程放入等待队列(</span><span style="color:#48484C;">waitting queue</span><span style="color:#93A1A1;">)</span><span style="color:#93A1A1;">中。</span></p> 
<p align="left"><span style="color:#93A1A1;">(</span><span style="color:#93A1A1;">二).</span><span style="color:#93A1A1;">同步阻塞：运行(</span><span style="color:#48484C;">running</span><span style="color:#93A1A1;">)</span><span style="color:#93A1A1;">的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则</span><span style="color:#48484C;">JVM</span><span style="color:#93A1A1;">会把该线程放入锁池(</span><span style="color:#48484C;">lock pool</span><span style="color:#93A1A1;">)</span><span style="color:#93A1A1;">中。</span></p> 
<p align="left"><span style="color:#93A1A1;">(</span><span style="color:#93A1A1;">三).</span><span style="color:#93A1A1;">其他阻塞: </span>运行(<span style="color:#48484C;">running</span><span style="color:#93A1A1;">)</span><span style="color:#93A1A1;">的线程执行</span><span style="color:#008080;">Thread</span><span style="color:#93A1A1;">.</span><span style="color:#48484C;">sleep</span><span style="color:#93A1A1;">(</span><span style="color:#1E347B;">long</span><span style="color:#48484C;">ms</span><span style="color:#93A1A1;">)</span><span style="color:#93A1A1;">或</span><span style="color:#48484C;">t</span><span style="color:#93A1A1;">.</span><span style="color:#48484C;">join </span><span style="color:#93A1A1;">()</span><span style="color:#93A1A1;">方法，或者发出了</span><span style="color:#48484C;">I</span><span style="color:#93A1A1;">/</span><span style="color:#48484C;">O</span><span style="color:#93A1A1;">请求时，</span><span style="color:#48484C;">JVM</span><span style="color:#93A1A1;">会把该线程置为阻塞状态。            </span>当<span style="color:#48484C;">sleep</span><span style="color:#93A1A1;">()</span><span style="color:#93A1A1;">状态超时、</span><span style="color:#48484C;">join</span><span style="color:#93A1A1;">()</span><span style="color:#93A1A1;">等待线程终止或者超时、或者</span><span style="color:#48484C;">I</span><span style="color:#93A1A1;">/</span><span style="color:#48484C;">O</span><span style="color:#93A1A1;">处理完毕时，线程重新转入可运行(</span><span style="color:#48484C;">runnable</span><span style="color:#93A1A1;">)</span><span style="color:#93A1A1;">状态。</span></p> 
<p align="left"><span style="color:#195F91;">5.</span><span style="color:#93A1A1;">死亡(</span><span style="color:#48484C;">dead</span><span style="color:#93A1A1;">)</span><span style="color:#93A1A1;">：线程</span><span style="color:#48484C;">run</span><span style="color:#93A1A1;">()</span><span style="color:#93A1A1;">、</span><span style="color:#48484C;">main</span><span style="color:#93A1A1;">()</span><span style="color:#93A1A1;">方法执行结束，或者因异常退出了</span><span style="color:#48484C;">run</span><span style="color:#93A1A1;">()</span><span style="color:#93A1A1;">方法，则该线程结束生命周期。死亡的线程不可再次复生。</span></p> 
<p align="left"></p> 
<p align="left"><span style="color:#333333;">14. </span><span style="color:#333333;background:#FFFFFF;">同步方法和同步代码块的区别是什么？</span></p> 
<p align="left"> <span style="color:#666666;">区别：</span></p> 
<p align="left"><span style="color:#666666;">同步方法默认用</span><span style="color:#666666;">this</span><span style="color:#666666;">或者当前类</span><span style="color:#666666;">class</span><span style="color:#666666;">对象作为锁；</span></p> 
<p align="left"><span style="color:#666666;">同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；</span></p> 
<p align="left"><span style="color:#333333;">同步方法使用关键字</span><span style="color:#666666;"> </span><span style="color:#333333;">synchronized</span><span style="color:#333333;">修饰方法，而同步代码块主要是修饰需要进行同步的代码，用</span><span style="color:#666666;"> </span><span style="color:#333333;"> </span><span style="color:#666666;"> </span><span style="color:#333333;">synchronized</span><span style="color:#333333;">（</span><span style="color:#333333;">object</span><span style="color:#333333;">）</span><span style="color:#333333;">{<!-- --></span><span style="color:#333333;">代码内容</span><span style="color:#333333;">}</span><span style="color:#333333;">进行修饰；</span><br><br><span style="color:#333333;">为何要使用同步？ </span> </p> 
<p align="left"><span style="color:#333333;">    java</span><span style="color:#333333;">允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），  </span></p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，  </span></p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">从而保证了该变量的唯一性和准确性。 </span></p> 
<p align="left"><span style="color:#333333;">  1.</span><span style="color:#333333;">同步方法  </span></p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">即有synchronized</span>关键字修饰的方法。  </p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">由于java</span>的每个对象都有一个内置锁，当用此关键字修饰方法时，  </p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。 </span></p> 
<p align="left"><span style="color:#333333;">   </span><span style="color:#333333;">代码如：  </span></p> 
<p align="left"><span style="color:#333333;">    public synchronized voidsave(){} </span></p> 
<p align="left"><span style="color:#333333;">     </span><span style="color:#333333;">注： synchronized</span>关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类 </p> 
<p align="left"><span style="color:#333333;">    2.</span><span style="color:#333333;">同步代码块  </span></p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">即有synchronized</span>关键字修饰的语句块。  </p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">被该关键字修饰的语句块会自动被加上内置锁，从而实现同步 </span></p> 
<p align="left"><span style="color:#333333;">        </span><span style="color:#333333;">代码如：  </span></p> 
<p align="left"><span style="color:#333333;">    synchronized(object){  </span></p> 
<p align="left"><span style="color:#333333;">    } </span></p> 
<p align="left"><span style="color:#333333;">        </span><span style="color:#333333;">注：同步是一种高开销的操作，因此应该尽量减少同步的内容。  </span></p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">通常没有必要同步整个方法，使用synchronized</span>代码块同步关键代码即可。  </p> 
<p align="left"><span style="color:#333333;">          </span><span style="color:#333333;">代码实例：  </span></p> 
<p align="left"><span style="color:#333333;">     </span><span style="color:#333333;">复制代码 </span></p> 
<p align="left"><span style="color:#333333;">package com.x</span><span style="color:#333333;">敏感词hread; </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">    /** </span></p> 
<p align="left"><span style="color:#333333;">     * </span><span style="color:#333333;">线程同步的运用 </span></p> 
<p align="left"><span style="color:#333333;">     *  </span></p> 
<p align="left"><span style="color:#333333;">     * @author XIEHEJUN </span></p> 
<p align="left"><span style="color:#333333;">     *  </span></p> 
<p align="left"><span style="color:#333333;">     */ </span></p> 
<p align="left"><span style="color:#333333;">    public class SynchronizedThread{ </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">        class Bank { </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">           private int account = 100; </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">           public int getAccount() { </span></p> 
<p align="left"><span style="color:#333333;">               return account; </span></p> 
<p align="left"><span style="color:#333333;">            }</span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">           /** </span></p> 
<p align="left"><span style="color:#333333;">            * </span><span style="color:#333333;">用同步方法实现 </span></p> 
<p align="left"><span style="color:#333333;">            *  </span></p> 
<p align="left"><span style="color:#333333;">            * @param money </span></p> 
<p align="left"><span style="color:#333333;">            */ </span></p> 
<p align="left"><span style="color:#333333;">           public synchronized void save(int money) { </span></p> 
<p align="left"><span style="color:#333333;">               account += money; </span></p> 
<p align="left"><span style="color:#333333;">            }</span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">           /** </span></p> 
<p align="left"><span style="color:#333333;">            * </span><span style="color:#333333;">用同步代码块实现 </span></p> 
<p align="left"><span style="color:#333333;">            *  </span></p> 
<p align="left"><span style="color:#333333;">            * @param money </span></p> 
<p align="left"><span style="color:#333333;">            */ </span></p> 
<p align="left"><span style="color:#333333;">           public void save1(int money) { </span></p> 
<p align="left"><span style="color:#333333;">               synchronized (this) { </span></p> 
<p align="left"><span style="color:#333333;">                   account += money; </span></p> 
<p align="left"><span style="color:#333333;">               } </span></p> 
<p align="left"><span style="color:#333333;">            }</span></p> 
<p align="left"><span style="color:#333333;">        } </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">        class NewThreadimplements Runnable { </span></p> 
<p align="left"><span style="color:#333333;">           private Bank bank; </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">           public NewThread(Bank bank) { </span></p> 
<p align="left"><span style="color:#333333;">               this.bank = bank; </span></p> 
<p align="left"><span style="color:#333333;">            }</span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">           @Override </span></p> 
<p align="left"><span style="color:#333333;">           public void run() { </span></p> 
<p align="left"><span style="color:#333333;">               for (int i = 0; i &lt; 10; i++) { </span></p> 
<p align="left"><span style="color:#333333;">                   // bank.save1(10); </span></p> 
<p align="left"><span style="color:#333333;">                   bank.save(10); </span></p> 
<p align="left"><span style="color:#333333;">                   System.out.println(i + "</span><span style="color:#333333;">账户余额为：" + bank.getAccount()); </span></p> 
<p align="left"><span style="color:#333333;">               } </span></p> 
<p align="left"><span style="color:#333333;">            }</span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">        } </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">        /** </span></p> 
<p align="left"><span style="color:#333333;">         * </span><span style="color:#333333;">建立线程，调用内部类 </span></p> 
<p align="left"><span style="color:#333333;">         */ </span></p> 
<p align="left"><span style="color:#333333;">        public voiduseThread() { </span></p> 
<p align="left"><span style="color:#333333;">           Bank bank = new Bank(); </span></p> 
<p align="left"><span style="color:#333333;">            NewThreadnew_thread = new NewThread(bank); </span></p> 
<p align="left"><span style="color:#333333;">           System.out.println("</span><span style="color:#333333;">线程1");</span></p> 
<p align="left"><span style="color:#333333;">           Thread thread1 = new Thread(new_thread); </span></p> 
<p align="left"><span style="color:#333333;">           thread1.start(); </span></p> 
<p align="left"><span style="color:#333333;">           System.out.println("</span><span style="color:#333333;">线程2");</span></p> 
<p align="left"><span style="color:#333333;">           Thread thread2 = new Thread(new_thread); </span></p> 
<p align="left"><span style="color:#333333;">           thread2.start(); </span></p> 
<p align="left"><span style="color:#333333;">        } </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">        public staticvoid main(String[] args) { </span></p> 
<p align="left"><span style="color:#333333;">           SynchronizedThread st = new SynchronizedThread(); </span></p> 
<p align="left"><span style="color:#333333;">           st.useThread(); </span></p> 
<p align="left"><span style="color:#333333;">        } </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">    } </span></p> 
<p align="left"><span style="color:#333333;">复制代码 </span></p> 
<p align="left"><span style="color:#333333;">      </span></p> 
<p align="left"><span style="color:#333333;">3.</span><span style="color:#333333;">使用特殊域变量(volatile)</span>实现线程同步 </p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">    a.volatile</span><span style="color:#333333;">关键字为域变量的访问提供了一种免锁机制，  </span></p> 
<p align="left"><span style="color:#333333;">    b.</span><span style="color:#333333;">使用volatile</span>修饰域相当于告诉<a href="http://www.2cto.com/os/xuniji/" rel="nofollow">虚拟机</a><span style="color:#333333;">该域可能会被其他线程更新，  </span></p> 
<p align="left"><span style="color:#333333;">    c.</span><span style="color:#333333;">因此每次使用该域就要重新计算，而不是使用寄存器中的值  </span></p> 
<p align="left"><span style="color:#333333;">    d.volatile</span><span style="color:#333333;">不会提供任何原子操作，它也不能用来修饰final</span>类型的变量  </p> 
<p align="left"><span style="color:#333333;">     </span></p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">例如：  </span></p> 
<p align="left"><span style="color:#333333;">        </span><span style="color:#333333;">在上面的例子当中，只需在account</span>前面加上volatile修饰，即可实现线程同步。  </p> 
<p align="left"><span style="color:#333333;">     </span></p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">代码实例：  </span></p> 
<p align="left"><span style="color:#333333;">     </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">复制代码 </span></p> 
<p align="left"><span style="color:#333333;">      //</span><span style="color:#333333;">只给出要修改的代码，其余代码与上同 </span></p> 
<p align="left"><span style="color:#333333;">        class Bank { </span></p> 
<p align="left"><span style="color:#333333;">           //</span><span style="color:#333333;">需要同步的变量加上volatile </span></p> 
<p align="left"><span style="color:#333333;">           private volatile int account = 100; </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">           public int getAccount() { </span></p> 
<p align="left"><span style="color:#333333;">               return account; </span></p> 
<p align="left"><span style="color:#333333;">            }</span></p> 
<p align="left"><span style="color:#333333;">           //</span><span style="color:#333333;">这里不再需要synchronized </span></p> 
<p align="left"><span style="color:#333333;">           public void save(int money) { </span></p> 
<p align="left"><span style="color:#333333;">               account += money; </span></p> 
<p align="left"><span style="color:#333333;">            }</span></p> 
<p align="left"><span style="color:#333333;">        </span><span style="color:#333333;">｝ </span></p> 
<p align="left"><span style="color:#333333;">复制代码 </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">注：多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。  </span></p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">用final</span>域，有锁保护的域和volatile域可以避免非同步的问题。  </p> 
<p align="left"><span style="color:#333333;">     </span></p> 
<p align="left"><span style="color:#333333;">4.</span><span style="color:#333333;">使用重入锁实现线程同步 </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">在</span><a href="http://www.2cto.com/kf/ware/Java/" rel="nofollow">Java</a><span style="color:#333333;">SE5.0</span><span style="color:#333333;">中新增了一个java.util.concurrent</span>包来支持同步。  </p> 
<p align="left"><span style="color:#333333;">    ReentrantLock</span><span style="color:#333333;">类是可重入、互斥、实现了Lock</span>接口的锁，  </p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">它与使用synchronized</span>方法和快具有相同的基本行为和语义，并且扩展了其能力 </p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">    ReenreantLock</span><span style="color:#333333;">类的常用方法有： </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">        ReentrantLock(): </span><span style="color:#333333;">创建一个ReentrantLock</span>实例  </p> 
<p align="left"><span style="color:#333333;">        lock() : </span><span style="color:#333333;">获得锁  </span></p> 
<p align="left"><span style="color:#333333;">        unlock() : </span><span style="color:#333333;">释放锁  </span></p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">注：ReentrantLock()</span>还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用  </p> 
<p align="left"><span style="color:#333333;">         </span></p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">例如：  </span></p> 
<p align="left"><span style="color:#333333;">        </span><span style="color:#333333;">在上面例子的基础上，改写后的代码为:  </span></p> 
<p align="left"><span style="color:#333333;">         </span></p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">代码实例：  </span></p> 
<p align="left"><span style="color:#333333;">     </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">复制代码 </span></p> 
<p align="left"><span style="color:#333333;">//</span><span style="color:#333333;">只给出要修改的代码，其余代码与上同 </span></p> 
<p align="left"><span style="color:#333333;">        class Bank { </span></p> 
<p align="left"><span style="color:#333333;">            </span></p> 
<p align="left"><span style="color:#333333;">           private int account = 100; </span></p> 
<p align="left"><span style="color:#333333;">           //</span><span style="color:#333333;">需要声明这个锁 </span></p> 
<p align="left"><span style="color:#333333;">           private Lock lock = new ReentrantLock(); </span></p> 
<p align="left"><span style="color:#333333;">           public int getAccount() { </span></p> 
<p align="left"><span style="color:#333333;">               return account; </span></p> 
<p align="left"><span style="color:#333333;">            }</span></p> 
<p align="left"><span style="color:#333333;">           //</span><span style="color:#333333;">这里不再需要synchronized </span></p> 
<p align="left"><span style="color:#333333;">           public void save(int money) { </span></p> 
<p align="left"><span style="color:#333333;">               lock.lock(); </span></p> 
<p align="left"><span style="color:#333333;">               try{ </span></p> 
<p align="left"><span style="color:#333333;">                   account += money; </span></p> 
<p align="left"><span style="color:#333333;">               }finally{ </span></p> 
<p align="left"><span style="color:#333333;">                   lock.unlock(); </span></p> 
<p align="left"><span style="color:#333333;">               } </span></p> 
<p align="left"><span style="color:#333333;">                </span></p> 
<p align="left"><span style="color:#333333;">            }</span></p> 
<p align="left"><span style="color:#333333;">        </span><span style="color:#333333;">｝ </span></p> 
<p align="left"><span style="color:#333333;">复制代码 </span></p> 
<p align="left"><span style="color:#333333;">           </span></p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">注：关于Lock</span>对象和synchronized关键字的选择：  </p> 
<p align="left"><span style="color:#333333;">        a.</span><span style="color:#333333;">最好两个都不用，使用一种java.util.concurrent</span>包提供的机制，  </p> 
<p align="left"><span style="color:#333333;">            </span><span style="color:#333333;">能够帮助用户处理所有与锁相关的代码。  </span></p> 
<p align="left"><span style="color:#333333;">        b.</span><span style="color:#333333;">如果synchronized</span>关键字能满足用户的需求，就用synchronized，因为它能简化代码  </p> 
<p align="left"><span style="color:#333333;">        c.</span><span style="color:#333333;">如果需要更高级的功能，就用ReentrantLock</span>类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁  </p> 
<p align="left"><span style="color:#333333;">         </span></p> 
<p align="left"><span style="color:#333333;">5.</span><span style="color:#333333;">使用局部变量实现线程同步  </span></p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">如果使用ThreadLocal</span>管理变量，则每一个使用该变量的线程都获得该变量的副本，  </p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。 </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">    ThreadLocal </span><span style="color:#333333;">类的常用方法 </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">    ThreadLocal() : </span><span style="color:#333333;">创建一个线程本地变量  </span></p> 
<p align="left"><span style="color:#333333;">    get() : </span><span style="color:#333333;">返回此线程局部变量的当前线程副本中的值  </span></p> 
<p align="left"><span style="color:#333333;">    initialValue() : </span><span style="color:#333333;">返回此线程局部变量的当前线程的"</span>初始值"  </p> 
<p align="left"><span style="color:#333333;">    set(T value) : </span><span style="color:#333333;">将此线程局部变量的当前线程副本中的值设置为value </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">例如：  </span></p> 
<p align="left"><span style="color:#333333;">        </span><span style="color:#333333;">在上面例子基础上，修改后的代码为：  </span></p> 
<p align="left"><span style="color:#333333;">         </span></p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">代码实例：  </span></p> 
<p align="left"><span style="color:#333333;">         </span></p> 
<p align="left"><span style="color:#333333;">  </span></p> 
<p align="left"><span style="color:#333333;">复制代码 </span></p> 
<p align="left"><span style="color:#333333;">//</span><span style="color:#333333;">只改Bank</span>类，其余代码与上同 </p> 
<p align="left"><span style="color:#333333;">        public classBank{ </span></p> 
<p align="left"><span style="color:#333333;">           //</span><span style="color:#333333;">使用ThreadLocal</span>类管理共享变量account </p> 
<p align="left"><span style="color:#333333;">           private static ThreadLocal&lt;Integer&gt; account = newThreadLocal&lt;Integer&gt;(){ </span></p> 
<p align="left"><span style="color:#333333;">               @Override </span></p> 
<p align="left"><span style="color:#333333;">               protected Integer initialValue(){ </span></p> 
<p align="left"><span style="color:#333333;">                   return 100; </span></p> 
<p align="left"><span style="color:#333333;">               } </span></p> 
<p align="left"><span style="color:#333333;">           }; </span></p> 
<p align="left"><span style="color:#333333;">           public void save(int money){ </span></p> 
<p align="left"><span style="color:#333333;">               account.set(account.get()+money); </span></p> 
<p align="left"><span style="color:#333333;">            }</span></p> 
<p align="left"><span style="color:#333333;">           public int getAccount(){ </span></p> 
<p align="left"><span style="color:#333333;">               return account.get(); </span></p> 
<p align="left"><span style="color:#333333;">            }</span></p> 
<p align="left"><span style="color:#333333;">        } </span></p> 
<p align="left"><span style="color:#333333;">复制代码 </span></p> 
<p align="left"><span style="color:#333333;">    </span><span style="color:#333333;">注：ThreadLocal</span>与同步机制  </p> 
<p align="left"><span style="color:#333333;">        a.ThreadLocal</span><span style="color:#333333;">与同步机制都是为了解决多线程中相同变量的访问冲突问题。  </span></p> 
<p align="left"><span style="color:#333333;">        b.</span><span style="color:#333333;">前者采用以"</span>空间换时间"的方法，后者采用以"时间换空间"的方式</p> 
<p align="left"><span style="color:#333333;">15. </span><span style="color:#333333;background:#FFFFFF;">在监视器</span><span style="color:#333333;background:#FFFFFF;">(Monitor)</span><span style="color:#333333;background:#FFFFFF;">内部，是如何做线程同步的？程序应该做哪种级别的同步？</span> </p> 
<p align="left"><span style="color:#93A1A1;">在</span><span style="color:#48484C;">java</span><span style="color:#93A1A1;">虚拟机中,</span><span style="color:#93A1A1;">每个对象(</span><span style="color:#008080;">Object</span><span style="color:#93A1A1;">和</span><span style="color:#1E347B;">class</span><span style="color:#93A1A1;">)</span><span style="color:#93A1A1;">通过某种逻辑关联监视器,</span>每个监视器和一个对象引用相关联,<span style="color:#93A1A1;">为了实现监视器的互斥功能,</span><span style="color:#93A1A1;">每个对象都关联着一把锁.</span></p> 
<p align="left"><span style="color:#BEBEC5;">  </span><span style="color:#93A1A1;">一旦方法或者代码块被</span><span style="color:#1E347B;">synchronized</span><span style="color:#93A1A1;">修饰,</span><span style="color:#93A1A1;">那么这个部分就放入了监视器的监视区域,</span><span style="color:#93A1A1;">确保一次只能有一个线程执行该部分的代码, </span>线程在获取锁之前不允许执行该部分的代码</p> 
<p align="left"><span style="color:#BEBEC5;">  </span><span style="color:#93A1A1;">另外</span><span style="color:#48484C;">java</span><span style="color:#93A1A1;">还提供了显式监视器(</span><span style="color:#008080;">Lock</span><span style="color:#93A1A1;">)</span><span style="color:#93A1A1;">和隐式监视器(</span><span style="color:#1E347B;">synchronized</span><span style="color:#93A1A1;">)</span><span style="color:#93A1A1;">两种锁方案</span></p> 
<p align="left"><span style="color:#333333;background:#D3F4EF;">监视器和锁在</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</span></p> 
<p align="left"><span style="color:#333333;">16. </span><span style="color:#333333;background:#FFFFFF;">什么是死锁</span><span style="color:#333333;background:#FFFFFF;">(deadlock)</span><span style="color:#333333;background:#FFFFFF;">？</span></p> 
<p align="left"><span style="color:#333333;"> </span><span style="color:#333333;">所谓死锁是指多个进</span><span style="color:#333333;">程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。死锁产生的</span><span style="color:#333333;">4</span><span style="color:#333333;">个必要条件：</span></p> 
<p align="left"><span style="color:#333333;">·        </span><span style="color:#333333;">互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某</span><span style="color:#333333;">资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</span></p> 
<p align="left"><span style="color:#333333;">·        </span><span style="color:#333333;">不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能</span><span style="color:#333333;">由获得该资源的进程自己来释放（只能是主动释放</span><span style="color:#333333;">)</span><span style="color:#333333;">。</span></p> 
<p align="left"><span style="color:#333333;">·        </span><span style="color:#333333;">请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源</span><span style="color:#333333;">已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</span></p> 
<p align="left"><span style="color:#333333;">·        </span><span style="color:#333333;">循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被</span><span style="color:#333333;">链中下一个进程所请求。</span></p> 
<p align="left"><span style="color:#333333;">17. </span><span style="color:#333333;background:#FFFFFF;">如何确保</span><span style="color:#333333;background:#FFFFFF;">N</span><span style="color:#333333;background:#FFFFFF;">个线程可以访问</span><span style="color:#333333;background:#FFFFFF;">N</span><span style="color:#333333;background:#FFFFFF;">个资源同时又不导致死锁？</span></p> 
<p align="left"><span style="color:#333333;"> </span><span style="color:#333333;background:#D3F4EF;">使用多线程的时候，一种非常简单的避免死锁的方式就是：</span><span style="color:#FF0000;background:#D3F4EF;">指定获取锁的顺序</span><span style="color:#333333;background:#D3F4EF;">，</span><span style="color:#FF0000;background:#D3F4EF;">并强制线程按照指定的顺序获取锁</span><span style="color:#333333;background:#D3F4EF;">。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</span></p> 
<p align="left"><span style="color:#333333;">18. </span><span style="color:#333333;background:#FFFFFF;">Java</span><span style="color:#333333;background:#FFFFFF;">集合类框架的基本接口有哪些？</span></p> 
<p align="left">总共有两大接口：Collection和Map ，一个元素集合，一个是键值对集合；其中List和Set接口继承了Collection接口，一个是有序元素集合，一个是无序元素集合；而ArrayList和 LinkedList 实现了List接口，HashSet实现了Set接口，这几个都比较常用； HashMap 和HashTable实现了Map接口，并且HashTable是线程安全的，但是HashMap性能更好；</p> 
<p align="left"><span style="color:#333333;">19. </span><span style="color:#333333;background:#FFFFFF;">为什么集合类没有实现</span><span style="color:#333333;background:#FFFFFF;">Cloneable</span><span style="color:#333333;background:#FFFFFF;">和</span><span style="color:#333333;background:#FFFFFF;">Serializable</span><span style="color:#333333;background:#FFFFFF;">接口？</span></p> 
<p align="left"><span style="color:#333333;"> </span><span style="color:#333333;background:#D3F4EF;">克隆</span><span style="color:#333333;background:#D3F4EF;">(cloning)</span><span style="color:#333333;background:#D3F4EF;">或者是序列化</span><span style="color:#333333;background:#D3F4EF;">(serialization)</span><span style="color:#333333;background:#D3F4EF;">的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</span></p> 
<p align="left"><span style="color:#333333;">20. </span><span style="color:#333333;background:#FFFFFF;">什么是迭代器</span><span style="color:#333333;background:#FFFFFF;">(Iterator)</span><span style="color:#333333;background:#FFFFFF;">？</span></p> 
<p align="left">迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。　　Java中的Iterator功能比较简单，并且只能单向移动：　　(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。　　(2) 使用next()获得序列中的下一个元素。　　(3) 使用hasNext()检查序列中是否还有元素。　　(4) 使用remove()将迭代器新返回的元素删除。　　Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</p> 
<p align="left"><span style="color:#555555;">代器模式（Iterator</span>），提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。 当你需要访问一个聚合对象，而且不管这些对象是什么都需要遍历的时候，就应该考虑使用迭代器模式。另外，当需要对聚集有多种方式遍历时，可以考虑去使用迭代器模式。迭代器模式为遍历不同的聚集结构提供如开始、下一个、是否结束、当前哪一项等统一的接口。</p> 
<p align="left"><span style="color:#333333;">21. </span><span style="color:#333333;background:#FFFFFF;">Iterator</span><span style="color:#333333;background:#FFFFFF;">和</span><span style="color:#333333;background:#FFFFFF;">ListIterator</span><span style="color:#333333;background:#FFFFFF;">的区别是什么？</span></p> 
<p align="left"><span style="color:#333333;background:#FFFFFF;"> </span><span style="color:#333333;background:#D3F4EF;">下面列出了他们的区别：</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">Iterator</span></span><span style="color:#333333;background:#D3F4EF;">可用来遍历</span><span style="color:#333333;background:#D3F4EF;">Set</span><span style="color:#333333;background:#D3F4EF;">和</span><span style="color:#333333;background:#D3F4EF;">List</span><span style="color:#333333;background:#D3F4EF;">集合，但是</span><span style="color:#333333;background:#D3F4EF;">ListIterator</span><span style="color:#333333;background:#D3F4EF;">只能用来遍历</span><span style="color:#333333;background:#D3F4EF;">List</span><span style="color:#333333;background:#D3F4EF;">。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">Iterator</span></span><span style="color:#333333;background:#D3F4EF;">对集合只能是前向遍历，</span><span style="color:#333333;background:#D3F4EF;">ListIterator</span><span style="color:#333333;background:#D3F4EF;">既可以前向也可以后向。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">ListIterator</span></span><span style="color:#333333;background:#D3F4EF;">实现了</span><span style="color:#333333;background:#D3F4EF;">Iterator</span><span style="color:#333333;background:#D3F4EF;">接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</span></p> 
<p align="left"><span style="color:#333333;">22. </span><span style="color:#333333;background:#FFFFFF;">快速失败</span><span style="color:#333333;background:#FFFFFF;">(fail-fast)</span><span style="color:#333333;background:#FFFFFF;">和安全失败</span><span style="color:#333333;background:#FFFFFF;">(fail-safe)</span><span style="color:#333333;background:#FFFFFF;">的区别是什么？</span></p> 
<p align="left"><span style="color:#333333;">一：快速失败（fail—fast</span>） </p> 
<p align="left"><span style="color:#333333;">         </span><span style="color:#333333;">在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出</span><span style="color:#2F2E2E;">Concurrent Modification Exception</span><span style="color:#2F2E2E;">。</span></p> 
<p align="left"><span style="color:#2F2E2E;">        </span><span style="color:#000000;">  </span><span style="color:#000000;">原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount </span>变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p> 
<p align="left"><span style="color:#000000;">      </span><span style="color:#000000;">注意：这里异常的抛出条件是检测到 modCount</span>！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。 </p> 
<p align="left"><span style="color:#000000;">      </span><span style="color:#000000;">场景：java.util</span>包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</p> 
<p align="left"><span style="color:#000000;">    </span><span style="color:#000000;">二：安全失败（fail—safe</span>） </p> 
<p align="left"><span style="color:#000000;">      </span><span style="color:#000000;">采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</span></p> 
<p align="left"><span style="color:#000000;">      </span><span style="color:#000000;">原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发</span><span style="color:#2F2E2E;">Concurrent Modification Exception</span><span style="color:#000000;">。 </span></p> 
<p align="left"><span style="color:#000000;">      </span><span style="color:#000000;">缺点：基于拷贝内容的优点是避免了</span><span style="color:#2F2E2E;">Concurrent Modification Exception</span><span style="color:#000000;">，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</span></p> 
<p align="left"><span style="color:#333333;">         </span><span style="color:#333333;">场景：java.util.concurrent</span>包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p> 
<p align="left"><span style="color:#FF0000;background:#D3F4EF;">Iterator</span><span style="color:#FF0000;background:#D3F4EF;">的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。</span><span style="color:#FF0000;background:#D3F4EF;">java.util</span><span style="color:#FF0000;background:#D3F4EF;">包下面的所有的集合类都是快速失败的，而</span><span style="color:#FF0000;background:#D3F4EF;">java.util.concurrent</span><span style="color:#FF0000;background:#D3F4EF;">包下面的所有的类都是安全失败的。快速失败的迭代器会抛出</span><span style="color:#FF0000;background:#D3F4EF;">ConcurrentModificationException</span><span style="color:#FF0000;background:#D3F4EF;">异常，而安全失败的迭代器永远不会抛出这样的异常。</span></p> 
<p align="left"><span style="color:#333333;">23. </span><span style="color:#333333;background:#FFFFFF;">Java</span><span style="color:#333333;background:#FFFFFF;">中的</span><span style="color:#333333;background:#FFFFFF;">HashMap</span><span style="color:#333333;background:#FFFFFF;">的工作原理是什么？</span></p> 
<p align="left"> <span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">中的</span><span style="color:#333333;background:#D3F4EF;">HashMap</span><span style="color:#333333;background:#D3F4EF;">是以键值对</span><span style="color:#333333;background:#D3F4EF;">(key-value)</span><span style="color:#333333;background:#D3F4EF;">的形式存储元素的。</span><span style="color:#333333;background:#D3F4EF;">HashMap</span><span style="color:#333333;background:#D3F4EF;">需要一个</span><span style="color:#333333;background:#D3F4EF;">hash</span><span style="color:#333333;background:#D3F4EF;">函数，它使用</span><span style="color:#333333;background:#D3F4EF;">hashCode()</span><span style="color:#333333;background:#D3F4EF;">和</span><span style="color:#333333;background:#D3F4EF;">equals()</span><span style="color:#333333;background:#D3F4EF;">方法来向集合</span><span style="color:#333333;background:#D3F4EF;">/</span><span style="color:#333333;background:#D3F4EF;">从集合添加和检索元素。当调用</span><span style="color:#333333;background:#D3F4EF;">put()</span><span style="color:#333333;background:#D3F4EF;">方法的时候，</span><span style="color:#333333;background:#D3F4EF;">HashMap</span><span style="color:#333333;background:#D3F4EF;">会计算</span><span style="color:#333333;background:#D3F4EF;">key</span><span style="color:#333333;background:#D3F4EF;">的</span><span style="color:#333333;background:#D3F4EF;">hash</span><span style="color:#333333;background:#D3F4EF;">值，然后把键值对存储在集合中合适的索引上。如果</span><span style="color:#333333;background:#D3F4EF;">key</span><span style="color:#333333;background:#D3F4EF;">已经存在了，</span><span style="color:#333333;background:#D3F4EF;">value</span><span style="color:#333333;background:#D3F4EF;">会被更新成新值。</span><span style="color:#333333;background:#D3F4EF;">HashMap</span><span style="color:#333333;background:#D3F4EF;">的一些重要的特性是它的容量</span><span style="color:#333333;background:#D3F4EF;">(capacity)</span><span style="color:#333333;background:#D3F4EF;">，负载因子</span><span style="color:#333333;background:#D3F4EF;">(load factor)</span><span style="color:#333333;background:#D3F4EF;">和扩容极限</span><span style="color:#333333;background:#D3F4EF;">(threshold resizing)</span><span style="color:#333333;background:#D3F4EF;">。</span></p> 
<p align="left">HashMap的底层是用hash数组和单向链表实现的，当调用put方法是，首先计算key的hashcode，定位到合适的数组索引，然后再在该索引上的单向链表进行循环遍历用equals比较key是否存在，如果存在则用新的value覆盖原值，如果没有则向后追加。HashMap的两个重要属性是容量capacity和加载因子loadfactor，<span style="color:#FF0000;">默认值分布为</span><span style="color:#FF0000;">16</span>和0.75，当容器中的元素个数大于capacity*loadfactor时，容器会进行扩容resize 为2n，在初始化Hashmap时可以对着两个值进行修改，负载因子0.75被证明为是性能比较好的取值，通常不会修改，那么只有初始容量capacity会导致频繁的扩容行为，这是非常耗费资源的操作，所以，如果事先能估算出容器所要存储的元素数量，最好在初始化时修改默认容量capacity，以防止频繁的resize操作影响性能。</p> 
<p align="left"><span style="color:#333333;">24. </span><span style="color:#333333;background:#FFFFFF;">hashCode()</span><span style="color:#333333;background:#FFFFFF;">和</span><span style="color:#333333;background:#FFFFFF;">equals()</span><span style="color:#333333;background:#FFFFFF;">方法的重要性体现在什么地方？</span></p> 
<p align="left"> <span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">中的</span><span style="color:#333333;background:#D3F4EF;">HashMap</span><span style="color:#333333;background:#D3F4EF;">使用</span><span style="color:#333333;background:#D3F4EF;">hashCode()</span><span style="color:#333333;background:#D3F4EF;">和</span><span style="color:#333333;background:#D3F4EF;">equals()</span><span style="color:#333333;background:#D3F4EF;">方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的</span><span style="color:#333333;background:#D3F4EF;">hash</span><span style="color:#333333;background:#D3F4EF;">值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对</span><span style="color:#333333;background:#D3F4EF;">HashMap</span><span style="color:#333333;background:#D3F4EF;">的精确性和正确性是至关重要的。</span></p> 
<p align="left">HashMap的很多函数要基于equal()函数和hashCode()函数。hashCode()用来定位要存放的位置，equal()用来判断是否<em>相等</em>。 <br>那么，<em>相等的概念是什么？</em> <br>Object版本的equal只是简单地判断是不是<strong>同一个</strong>实例。但是有的时候，我们想要的的是逻辑上的相等。比如有一个学生类student，有一个属性studentID，只要studentID相等，不是同一个实例我们也认为是同一学生。当我们认为判定equals的相等应该是逻辑上的相等而不是只是判断是不是内存中的同一个东西的时候，就需要重写equal()。<strong>而涉及到HashMap的时候，重写了equals()，就需要重写hashCode()</strong> </p> 
<p align="left">我们总结一下几条基本原则 <br>1. 同一个对象（没有发生过修改）无论何时调用hashCode()得到的返回值必须一样。 <br><strong><em>如果一个key对象在put的时候调用hashCode()决定了存放的位置，而在get的时候调用hashCode()得到了不一样的返回值，这个值映射到了一个和原来不一样的地方，那么肯定就找不到原来那个键值对了。</em></strong> <br>2. hashCode()的返回值相等的对象不一定相等，通过hashCode()和equals()必须能唯一确定一个对象 <br><strong><em>不相等的对象的hashCode()的结果可以相等。hashCode()在注意关注碰撞问题的时候，也要关注生成速度问题，完美hash不现实</em> </strong><br>3. 一旦重写了equals()函数（重写equals的时候还要注意要满足<strong>自反性、对称性、传递性、一致性</strong>），就必须重写hashCode()函数。而且hashCode()的生成哈希值的依据应该是equals()中用来比较是否相等的字段 <br><strong><em>如果两个由equals()规定相等的对象生成的hashCode不等，对于hashMap来说，他们很可能分别映射到不同位置，没有调用equals()比较是否相等的机会，两个实际上相等的对象可能被插入不同位置，出现错误。其他一些基于哈希方法的集合类可能也会有这个问题</em></strong></p> 
<p align="left"><span style="color:#333333;">25.  </span><span style="color:#333333;background:#FFFFFF;">HashMap</span><span style="color:#333333;background:#FFFFFF;">和</span><span style="color:#333333;background:#FFFFFF;">Hashtable</span><span style="color:#333333;background:#FFFFFF;">有什么区别？</span></p> 
<p align="left"> <span style="color:#333333;background:#D3F4EF;">HashMap</span><span style="color:#333333;background:#D3F4EF;">和</span><span style="color:#333333;background:#D3F4EF;">Hashtable</span><span style="color:#333333;background:#D3F4EF;">都实现了</span><span style="color:#333333;background:#D3F4EF;">Map</span><span style="color:#333333;background:#D3F4EF;">接口，因此很多特性非常相似。但是，他们有以下不同点：</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">HashMap</span></span><span style="color:#333333;background:#D3F4EF;">允许键和值是</span><span style="color:#333333;background:#D3F4EF;">null</span><span style="color:#333333;background:#D3F4EF;">，而</span><span style="color:#333333;background:#D3F4EF;">Hashtable</span><span style="color:#333333;background:#D3F4EF;">不允许键或者值是</span><span style="color:#333333;background:#D3F4EF;">null</span><span style="color:#333333;background:#D3F4EF;">。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">Hashtable</span></span><span style="color:#333333;background:#D3F4EF;">是同步的，而</span><span style="color:#333333;background:#D3F4EF;">HashMap</span><span style="color:#333333;background:#D3F4EF;">不是。因此，</span><span style="color:#333333;background:#D3F4EF;">HashMap</span><span style="color:#333333;background:#D3F4EF;">更适合于单线程环境，而</span><span style="color:#333333;background:#D3F4EF;">Hashtable</span><span style="color:#333333;background:#D3F4EF;">适合于多线程环境。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">HashMap</span></span><span style="color:#333333;background:#D3F4EF;">提供了可供应用迭代的键的集合，因此，</span><span style="color:#333333;background:#D3F4EF;">HashMap</span><span style="color:#333333;background:#D3F4EF;">是快速失败的。另一方面，</span><span style="color:#333333;background:#D3F4EF;">Hashtable</span><span style="color:#333333;background:#D3F4EF;">提供了对键的列举</span><span style="color:#333333;background:#D3F4EF;">(Enumeration)</span><span style="color:#333333;background:#D3F4EF;">。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">一般认为</span><span style="color:#333333;background:#D3F4EF;">Hashtable</span><span style="color:#333333;background:#D3F4EF;">是一个遗留的类。</span></p> 
<p><span style="color:#333333;">1</span><span style="color:#333333;">、HashMap</span>是非线程安全的，HashTable是线程安全的。 </p> 
<p><span style="color:#333333;">2</span><span style="color:#333333;">、HashMap</span>的键和值都允许有null值存在，而HashTable则不行。 </p> 
<p><span style="color:#333333;">3</span><span style="color:#333333;">、因为线程安全的问题，</span><span style="color:#333333;">HashMap</span><span style="color:#333333;">效率比</span><span style="color:#333333;">HashTable</span><span style="color:#333333;">的要高。</span></p> 
<p><span style="color:#333333;">4</span><span style="color:#333333;">、</span><span style="color:#333333;">Hashtable</span><span style="color:#333333;">是同步的，而</span><span style="color:#333333;">HashMap</span><span style="color:#333333;">不是。因此，</span><span style="color:#333333;">HashMap</span><span style="color:#333333;">更适合于单线程环境，而</span><span style="color:#333333;">Hashtable</span><span style="color:#333333;">适合于多线程环境。</span></p> 
<p><span style="color:#333333;"> </span></p> 
<p><span style="color:#333333;">一般现在<strong>不建议用</strong></span><strong><span style="color:#333333;">HashTable</span></strong><span style="color:#333333;">, ①</span><span style="color:#333333;">是</span><span style="color:#333333;">HashTable</span><span style="color:#333333;">是遗留类，内部实现很多没优化和冗余。</span><span style="color:#333333;">②</span><span style="color:#333333;">即使在<strong>多线程</strong></span>环境下，现在也有同步的<strong><span style="color:#333333;">ConcurrentHashMap</span></strong><span style="color:#333333;">替代，没有必要因为是多线程而用</span><span style="color:#333333;">HashTable</span><span style="color:#333333;">。</span></p> 
<p align="left"><span style="color:#333333;">26.  </span><span style="color:#333333;background:#FFFFFF;">数组</span><span style="color:#333333;background:#FFFFFF;">(Array)</span><span style="color:#333333;background:#FFFFFF;">和列表</span><span style="color:#333333;background:#FFFFFF;">(ArrayList)</span><span style="color:#333333;background:#FFFFFF;">有什么区别？什么时候应该使用</span><span style="color:#333333;background:#FFFFFF;">Array</span><span style="color:#333333;background:#FFFFFF;">而不是</span><span style="color:#333333;background:#FFFFFF;">ArrayList</span><span style="color:#333333;background:#FFFFFF;">？</span></p> 
<p align="left"> <span style="color:#333333;background:#D3F4EF;">下面列出了</span><span style="color:#333333;background:#D3F4EF;">Array</span><span style="color:#333333;background:#D3F4EF;">和</span><span style="color:#333333;background:#D3F4EF;">ArrayList</span><span style="color:#333333;background:#D3F4EF;">的不同点：</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">Array</span></span><span style="color:#333333;background:#D3F4EF;">可以包含基本类型和对象类型，</span><span style="color:#333333;background:#D3F4EF;">ArrayList</span><span style="color:#333333;background:#D3F4EF;">只能包含对象类型。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">Array</span></span><span style="color:#333333;background:#D3F4EF;">大小是固定的，</span><span style="color:#333333;background:#D3F4EF;">ArrayList</span><span style="color:#333333;background:#D3F4EF;">的大小是动态变化的。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">ArrayList</span></span><span style="color:#333333;background:#D3F4EF;">提供了更多的方法和特性，比如：</span><span style="color:#333333;background:#D3F4EF;">addAll()</span><span style="color:#333333;background:#D3F4EF;">，</span><span style="color:#333333;background:#D3F4EF;">removeAll()</span><span style="color:#333333;background:#D3F4EF;">，</span><span style="color:#333333;background:#D3F4EF;">iterator()</span><span style="color:#333333;background:#D3F4EF;">等等。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</span></p> 
<p>ArrayList可以算是Array的加强版，（对array有所取舍的加强）。 </p> 
<p><strong>存储内容比较：</strong> </p> 
<p align="left">·        Array数组可以包含基本类型和对象类型， </p> 
<p align="left">·        ArrayList却只能包含对象类型。 </p> 
<p>但是需要注意的是：Array数组在存放的时候一定是同种类型的元素。ArrayList就不一定了，因为ArrayList可以存储Object。 </p> 
<p><strong>空间大小比较：</strong> </p> 
<p align="left">·        它的空间大小是固定的，空间不够时也不能再次申请，所以需要事前确定合适的空间大小。 </p> 
<p align="left">·        ArrayList的空间是动态增长的，如果空间不够，它会创建一个空间比原空间大一倍的新数组，然后将所有元素复制到新数组中，接着抛弃旧数组。而且，每次添加新的元素的时候都会检查内部数组的空间是否足够。（比较麻烦的地方）。 </p> 
<p><strong>方法上的比较：</strong> <br>ArrayList作为Array的增强版，当然是在方法上比Array更多样化，比如添加全部addAll()、删除全部removeAll()、返回迭代器iterator()等。 </p> 
<p><strong>适用场景：</strong> <br>如果想要保存一些在整个程序运行期间都会存在而且不变的数据，我们可以将它们放进一个全局数组里，但是如果我们单纯只是想要以数组的形式保存数据，而不对数据进行增加等操作，只是方便我们进行查找的话，那么，我们就选择ArrayList。而且还有一个地方是必须知道的，就是如果我们需要对元素进行频繁的移动或删除，或者是处理的是超大量的数据，那么，使用ArrayList就真的不是一个好的选择，因为它的效率很低，使用数组进行这样的动作就很麻烦，那么，我们可以考虑选择LinkedList。</p> 
<p align="left"><span style="color:#333333;">27.  </span><span style="color:#333333;background:#FFFFFF;">ArrayList</span><span style="color:#333333;background:#FFFFFF;">和</span><span style="color:#333333;background:#FFFFFF;">LinkedList</span><span style="color:#333333;background:#FFFFFF;">有什么区别？</span></p> 
<p align="left"> <span style="color:#333333;background:#D3F4EF;">ArrayList</span><span style="color:#333333;background:#D3F4EF;">和</span><span style="color:#333333;background:#D3F4EF;">LinkedList</span><span style="color:#333333;background:#D3F4EF;">都实现了</span><span style="color:#333333;background:#D3F4EF;">List</span><span style="color:#333333;background:#D3F4EF;">接口，他们有以下的不同点：</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">ArrayList</span></span><span style="color:#333333;background:#D3F4EF;">是基于索引的数据接口，它的底层是数组。它可以以</span><span style="color:#333333;background:#D3F4EF;">O(1)</span><span style="color:#333333;background:#D3F4EF;">时间复杂度对元素进行随机访问。与此对应，</span><span style="color:#333333;background:#D3F4EF;">LinkedList</span><span style="color:#333333;background:#D3F4EF;">是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是</span><span style="color:#333333;background:#D3F4EF;">O(n)</span><span style="color:#333333;background:#D3F4EF;">。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">相对于</span><span style="color:#333333;background:#D3F4EF;">ArrayList</span><span style="color:#333333;background:#D3F4EF;">，</span><span style="color:#333333;background:#D3F4EF;">LinkedList</span><span style="color:#333333;background:#D3F4EF;">的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">LinkedList</span></span><span style="color:#333333;background:#D3F4EF;">比</span><span style="color:#333333;background:#D3F4EF;">ArrayList</span><span style="color:#333333;background:#D3F4EF;">更占内存，因为</span><span style="color:#333333;background:#D3F4EF;">LinkedList</span><span style="color:#333333;background:#D3F4EF;">为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</span></p> 
<p align="left">28.  <span style="color:#333333;background:#FFFFFF;">Comparable</span><span style="color:#333333;background:#FFFFFF;">和</span><span style="color:#333333;background:#FFFFFF;">Comparator</span><span style="color:#333333;background:#FFFFFF;">接口是干什么的？列出它们的区别。</span><br>Comparable &amp; Comparator 都是<span style="color:#FF0000;">用来实现集合中元素的比较、排序的</span>，只是 Comparable是在集合内部定义的方法实现的排序，Comparator 是在集合外部实现的排序，所以，如想实现排序，就需要在集合外定义 Comparator 接口的方法或在集合内实现 Comparable 接口的方法。 Comparator位于包java.util下，而Comparable位于包 java.lang下 Comparable 是一个对象本身就已经支持自比较所需要实现的接口（如 String、Integer 自己就可以完成比较大小操作，已经实现了Comparable接口）自定义的类要在加入list容器中后能够排序，可以实现Comparable接口，在用Collections类的sort方法排序时，如果不指定Comparator，那么就以自然顺序排序，这里的自然顺序就是实现Comparable接口设定的排序方式。而 Comparator 是一个专用的比较器，当这个对象不支持自比较或者自比较函数不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。可以说一个是自已完成比较，一个是外部程序实现比较的差别而已。用 Comparator 是策略模式（strategy design pattern），就是不改变对象自身，而用一个策略对象（strategyobject）来改变它的行为。比如：你想对整数采用绝对值大小来排序，Integer 是不符合要求的，你不需要去修改 Integer 类（实际上你也不能这么做）去改变它的排序行为，只要使用一个实现了 Comparator 接口的对象来实现控制它的排序就行了。</p> 
<p align="left">29. <span style="color:#333333;background:#FFFFFF;">什么是</span><span style="color:#333333;background:#FFFFFF;">Java</span><span style="color:#333333;background:#FFFFFF;">优先级队列</span><span style="color:#333333;background:#FFFFFF;">(Priority Queue)</span><span style="color:#333333;background:#FFFFFF;">？</span></p> 
<p align="left"><span style="color:#333333;background:#D3F4EF;">PriorityQueue</span><span style="color:#333333;background:#D3F4EF;">是一个基于优先级堆的无界队列，它的元素是按照自然顺序</span><span style="color:#333333;background:#D3F4EF;">(natural order)</span><span style="color:#333333;background:#D3F4EF;">排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。</span><span style="color:#333333;background:#D3F4EF;">PriorityQueue</span><span style="color:#333333;background:#D3F4EF;">不允许</span><span style="color:#333333;background:#D3F4EF;">null</span><span style="color:#333333;background:#D3F4EF;">值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，</span><span style="color:#333333;background:#D3F4EF;">PriorityQueue</span><span style="color:#333333;background:#D3F4EF;">不是线程安全的，入队和出队的时间复杂度是</span><span style="color:#333333;background:#D3F4EF;">O(log(n))</span><span style="color:#333333;background:#D3F4EF;">。</span></p> 
<p><span style="color:#444444;">PriorityQueue</span><span style="color:#444444;">是个基于优先级堆的极大优先级队列。</span></p> 
<p><span style="color:#444444;">此队列按照在构造时所指定的顺序对元素排序，既可以根据元素的自然顺序来指定排序（参阅</span><span style="color:#444444;"> Comparable</span><span style="color:#444444;">），</span></p> 
<p><span style="color:#444444;">也可以根据</span><span style="color:#444444;"> Comparator </span><span style="color:#444444;">来指定，这<strong>取决于使用哪种构造方法</strong></span>。优先级队列不允许<span style="color:#444444;"> null </span><span style="color:#444444;">元素。</span></p> 
<p><span style="color:#444444;">依靠自然排序的优先级队列还不允许插入不可比较的对象（这样做可能导致</span><span style="color:#444444;"> ClassCastException</span><span style="color:#444444;">）</span></p> 
<p><span style="color:#444444;"> </span></p> 
<p><span style="color:#444444;">队列检索操作</span><span style="color:#444444;"> poll</span><span style="color:#444444;">、</span><span style="color:#444444;">remove</span><span style="color:#444444;">、</span><span style="color:#444444;">peek </span><span style="color:#444444;">和</span><span style="color:#444444;"> element </span><span style="color:#444444;">访问处于队列头的元素。</span></p> 
<p><span style="color:#444444;">优先级队列是无界的，但是有一个内部容量，控制着用于存储队列元素的数组的大小。</span></p> 
<p><span style="color:#444444;">它总是至少与队列的大小相同。随着不断向优先级队列添加元素，其容量会自动增加。无需指定容量增加策略的细节。</span></p> 
<p><strong><span style="color:#444444;">注意</span><span style="color:#444444;">1:</span></strong><span style="color:#444444;">该队列是用<strong>数组</strong></span>实现，但是数组大小可以动态增加，容量无限。</p> 
<p><strong><span style="color:#444444;">注意</span><span style="color:#444444;">2:</span></strong><span style="color:#444444;">此实现<strong>不是同步</strong></span>的。<strong>不是线程安全</strong>的。如果多个线程中的任意线程从结构上修改了列表，<span style="color:#444444;">则这些线程不应同时访问</span><span style="color:#444444;">PriorityQueue </span><span style="color:#444444;">实例，这时请使用线程安全的</span><span style="color:#444444;">PriorityBlockingQueue</span><span style="color:#444444;">类。</span></p> 
<p><strong><span style="color:#444444;">注意</span><span style="color:#444444;">3:</span></strong><span style="color:#444444;">不允许使用</span><span style="color:#444444;"> null </span><span style="color:#444444;">元素。</span></p> 
<p><strong><span style="color:#444444;">注意</span><span style="color:#444444;">4:</span></strong><span style="color:#444444;">此实现为<strong>插入方法</strong></span>（<span style="color:#444444;">offer</span><span style="color:#444444;">、</span><span style="color:#444444;">poll</span><span style="color:#444444;">、</span><span style="color:#444444;">remove() </span><span style="color:#444444;">和</span><span style="color:#444444;"> add </span><span style="color:#444444;">方法）提供</span><span style="color:#444444;"> <strong>O(log(n)) </strong></span><span style="color:#444444;">时间；</span></p> 
<p><span style="color:#444444;">为</span><span style="color:#444444;"> remove(Object) </span><span style="color:#444444;">和</span><span style="color:#444444;"> contains(Object) </span><span style="color:#444444;">方法提供线性时间；</span></p> 
<p><span style="color:#444444;">为检索方法（</span><span style="color:#444444;">peek</span><span style="color:#444444;">、</span><span style="color:#444444;">element </span><span style="color:#444444;">和</span><span style="color:#444444;"> size</span><span style="color:#444444;">）提供固定时间。</span></p> 
<p><strong><span style="color:#444444;">注意</span><span style="color:#444444;">5:</span></strong><span style="color:#444444;">方法</span><span style="color:#444444;">iterator()</span><span style="color:#444444;">中提供的迭代器并不保证以有序的方式遍历优先级队列中的元素。</span></p> 
<p><span style="color:#444444;">至于原因可参考下面关于</span><span style="color:#444444;">PriorityQueue</span><span style="color:#444444;">的内部实现</span></p> 
<p><span style="color:#444444;">如果需要按顺序遍历，请考虑使用</span><span style="color:#444444;"> Arrays.sort(pq.toArray())</span><span style="color:#444444;">。</span></p> 
<p><strong><span style="color:#444444;">注意</span><span style="color:#444444;">6</span><span style="color:#444444;">：</span></strong><span style="color:#444444;">可以在构造函数中指定如何排序。如：</span></p> 
<p><span style="color:#444444;">PriorityQueue() </span></p> 
<p><span style="color:#444444;">使用默认的初始容量（</span><span style="color:#444444;">11</span><span style="color:#444444;">）创建一个</span><span style="color:#444444;"> PriorityQueue</span><span style="color:#444444;">，并根据其自然顺序来排序其元素（使用</span><span style="color:#444444;"> Comparable</span><span style="color:#444444;">）。</span></p> 
<p><span style="color:#444444;">PriorityQueue(int initialCapacity) </span></p> 
<p><span style="color:#444444;">使用指定的初始容量创建一个</span><span style="color:#444444;"> PriorityQueue</span><span style="color:#444444;">，并根据其自然顺序来排序其元素（使用</span><span style="color:#444444;"> Comparable</span><span style="color:#444444;">）。</span></p> 
<p><span style="color:#444444;">PriorityQueue(int initialCapacity, Comparatorcomparator) </span></p> 
<p><span style="color:#444444;">使用指定的初始容量创建一个</span><span style="color:#444444;"> PriorityQueue</span><span style="color:#444444;">，并根据指定的比较器</span><span style="color:#444444;">comparator</span><span style="color:#444444;">来排序其元素。</span></p> 
<p><strong><span style="color:#444444;">注意</span><span style="color:#444444;">7:</span></strong><span style="color:#444444;">此类及其迭代器实现了</span><span style="color:#444444;"> Collection </span><span style="color:#444444;">和</span><span style="color:#444444;"> Iterator </span><span style="color:#444444;">接口的所有可选</span><span style="color:#444444;">方法。</span></p> 
<p><span style="color:#444444;">PriorityQueue</span><span style="color:#444444;">的内部实现</span></p> 
<p><span style="color:#444444;">PriorityQueue</span><span style="color:#444444;">对元素采用的是<strong>堆排序</strong></span>，头是按指定排序方式的最小元素。<strong>堆排序只能保证根是最大（最小），整个堆并不是有序的。</strong></p> 
<p><span style="color:#444444;">方法</span><span style="color:#444444;">iterator()</span><span style="color:#444444;">中提供的迭代器可能只是对整个数组的依次遍历。也就只能保证数组的第一个元素是最小的。</span></p> 
<p><span style="color:#333333;">30.  </span><span style="color:#333333;background:#FFFFFF;">你了解大</span><span style="color:#333333;background:#FFFFFF;">O</span><span style="color:#333333;background:#FFFFFF;">符号</span><span style="color:#333333;background:#FFFFFF;">(big-O notation)</span><span style="color:#333333;background:#FFFFFF;">么？你能给出不同数据结构的例子么？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">大</span><span style="color:#333333;background:#D3F4EF;">O</span><span style="color:#333333;background:#D3F4EF;">符号描述了当数据结构里面的元素增加的时候，算法的规模或者是</span><span style="color:#333333;">一个渐进上界</span><span style="color:#333333;background:#D3F4EF;"> </span><span style="color:#333333;background:#D3F4EF;">。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">大</span><span style="color:#333333;background:#D3F4EF;">O</span><span style="color:#333333;background:#D3F4EF;">符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大</span><span style="color:#333333;background:#D3F4EF;">O</span><span style="color:#333333;background:#D3F4EF;">符号基于时间，内存和性能来选择最好的实现。大</span><span style="color:#333333;background:#D3F4EF;">O</span><span style="color:#333333;background:#D3F4EF;">符号可以对大量数据的性能给出一个很好的说明。</span></p> 
<p>大O符号表示一个程序运行时所需要的渐进时间复杂度上界。 </p> 
<p>其函数表示是： </p> 
<p>对于函数f(n),g(n),如果存在一个常数c，使得f(n)&lt;=c*g(n),则f(n)=O(g(n));</p> 
<p>大O描述当数据结构中的元素增加时，算法的规模和性能在最坏情景下有多好。 </p> 
<p>大O还可以描述其它行为，比如内存消耗。因为集合类实际上是数据结构，因此我们一般使用大O符号基于时间，内存，性能选择最好的实现。大O符号可以对大量数据性能给予一个很好的说明。</p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#666666;">O</span><span style="color:#666666;">：大</span><span style="color:#666666;">O</span><span style="color:#666666;">是上界</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#666666;">Θ</span><span style="color:#666666;">：大</span><span style="color:#666666;">Θ</span><span style="color:#666666;">是平均值</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#666666;">Ω</span><span style="color:#666666;">：大</span><span style="color:#666666;">Ω</span><span style="color:#666666;">是下界</span></p> 
<p><span style="color:#333333;">31.  </span><span style="color:#333333;background:#FFFFFF;">如何权衡是使用无序的数组还是有序的数组？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">有序数组最大的好处在于查找的时间复杂度是</span><span style="color:#333333;background:#D3F4EF;">O(log n)</span><span style="color:#333333;background:#D3F4EF;">，而无序数组是</span><span style="color:#333333;background:#D3F4EF;">O(n)</span><span style="color:#333333;background:#D3F4EF;">。有序数组的缺点是插入操作的时间复杂度是</span><span style="color:#333333;background:#D3F4EF;">O(n)</span><span style="color:#333333;background:#D3F4EF;">，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量</span><span style="color:#333333;background:#D3F4EF;">O(1)</span><span style="color:#333333;background:#D3F4EF;">。</span></p> 
<p><span style="color:#333333;">32.  </span><span style="color:#333333;background:#FFFFFF;">Java</span><span style="color:#333333;background:#FFFFFF;">集合类框架的最佳实践有哪些？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的数量是固定的，而且能事先知道，我们就应该用</span><span style="color:#333333;background:#D3F4EF;">Array</span><span style="color:#333333;background:#D3F4EF;">而不是</span><span style="color:#333333;background:#D3F4EF;">ArrayList</span><span style="color:#333333;background:#D3F4EF;">。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算</span><span style="color:#333333;background:#D3F4EF;">hash</span><span style="color:#333333;background:#D3F4EF;">值或者是扩容。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的</span><span style="color:#333333;background:#D3F4EF;">ClassCastException</span><span style="color:#333333;background:#D3F4EF;">。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">使用</span><span style="color:#333333;background:#D3F4EF;">JDK</span><span style="color:#333333;background:#D3F4EF;">提供的不变类</span><span style="color:#333333;background:#D3F4EF;">(immutable class)</span><span style="color:#333333;background:#D3F4EF;">作为</span><span style="color:#333333;background:#D3F4EF;">Map</span><span style="color:#333333;background:#D3F4EF;">的键可以避免为我们自己的类实现</span><span style="color:#333333;background:#D3F4EF;">hashCode()</span><span style="color:#333333;background:#D3F4EF;">和</span><span style="color:#333333;background:#D3F4EF;">equals()</span><span style="color:#333333;background:#D3F4EF;">方法。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">编程的时候接口优于实现。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">底层的集合实际上是空的情况下，返回长度是</span><span style="color:#333333;background:#D3F4EF;">0</span><span style="color:#333333;background:#D3F4EF;">的集合或者是数组，不要返回</span><span style="color:#333333;background:#D3F4EF;">null</span><span style="color:#333333;background:#D3F4EF;">。</span></p> 
<p align="left"><span style="color:#333333;">33.  </span><span style="color:#333333;background:#FFFFFF;">Enumeration</span><span style="color:#333333;background:#FFFFFF;">接口和</span><span style="color:#333333;background:#FFFFFF;">Iterator</span><span style="color:#333333;background:#FFFFFF;">接口的区别有哪些？</span></p> 
<p align="left"><span style="color:#333333;background:#D3F4EF;">Enumeration</span><span style="color:#333333;background:#D3F4EF;">速度是</span><span style="color:#333333;background:#D3F4EF;">Iterator</span><span style="color:#333333;background:#D3F4EF;">的</span><span style="color:#333333;background:#D3F4EF;">2</span><span style="color:#333333;background:#D3F4EF;">倍，同时占用更少的内存。但是，</span><span style="color:#333333;background:#D3F4EF;">Iterator</span><span style="color:#333333;background:#D3F4EF;">远远比</span><span style="color:#333333;background:#D3F4EF;">Enumeration</span><span style="color:#333333;background:#D3F4EF;">安全，因为其他线程不能够修改正在被</span><span style="color:#333333;background:#D3F4EF;">iterator</span><span style="color:#333333;background:#D3F4EF;">遍历的集合里面的对象。同时，</span><span style="color:#333333;background:#D3F4EF;">Iterator</span><span style="color:#333333;background:#D3F4EF;">允许调用者删除底层集合里面的元素，这对</span><span style="color:#333333;background:#D3F4EF;">Enumeration</span><span style="color:#333333;background:#D3F4EF;">来说是不可能的。</span></p> 
<p align="left"><span style="color:#333333;">34.  </span><span style="color:#333333;background:#FFFFFF;">HashSet</span><span style="color:#333333;background:#FFFFFF;">和</span><span style="color:#333333;background:#FFFFFF;">TreeSet</span><span style="color:#333333;background:#FFFFFF;">有什么区别？</span></p> 
<p align="left"><span style="color:#333333;background:#D3F4EF;">HashSet</span><span style="color:#333333;background:#D3F4EF;">是由一个</span><span style="color:#333333;background:#D3F4EF;">hash</span><span style="color:#333333;background:#D3F4EF;">表来实现的，因此，它的元素是无序的。</span><span style="color:#333333;background:#D3F4EF;">add()</span><span style="color:#333333;background:#D3F4EF;">，</span><span style="color:#333333;background:#D3F4EF;">remove()</span><span style="color:#333333;background:#D3F4EF;">，</span><span style="color:#333333;background:#D3F4EF;">contains()</span><span style="color:#333333;background:#D3F4EF;">方法的时间复杂度是</span><span style="color:#333333;background:#D3F4EF;">O(1)</span><span style="color:#333333;background:#D3F4EF;">。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">另一方面，</span><span style="color:#333333;background:#D3F4EF;">TreeSet</span><span style="color:#333333;background:#D3F4EF;">是由一个树形的结构来实现的，它里面的元素是有序的。因此，</span><span style="color:#333333;background:#D3F4EF;">add()</span><span style="color:#333333;background:#D3F4EF;">，</span><span style="color:#333333;background:#D3F4EF;">remove()</span><span style="color:#333333;background:#D3F4EF;">，</span><span style="color:#333333;background:#D3F4EF;">contains()</span><span style="color:#333333;background:#D3F4EF;">方法的时间复杂度是</span><span style="color:#333333;background:#D3F4EF;">O(logn)</span><span style="color:#333333;background:#D3F4EF;">。</span></p> 
<p align="left"><span style="color:#666666;background:#FFFFFF;">Hashset </span><span style="color:#666666;background:#FFFFFF;">的底层是由哈希表实现的，</span><span style="color:#666666;background:#FFFFFF;">Treeset </span><span style="color:#666666;background:#FFFFFF;">底层是由红黑树实现的。如果需要在</span><span style="color:#666666;background:#FFFFFF;">Treeset </span><span style="color:#666666;background:#FFFFFF;">中插入对象，需要实现</span><span style="color:#666666;background:#FFFFFF;">Comparable </span><span style="color:#666666;background:#FFFFFF;">接口，为其指定比较策略。</span></p> 
<p align="left" style="background:#FFFFFF;">35. <span style="color:#333333;background:#FFFFFF;">Java</span><span style="color:#333333;background:#FFFFFF;">中垃圾回收有什么目的？什么时候进行垃圾回收？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#666666;"> </span><span style="color:#666666;">     </span><span style="color:#666666;">目的：回收堆内存中不再使用的对象，释放资源</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#666666;">回收时间：当对象永久地失去引用后，系统会在合适的时候回收它所占的内存</span></p> 
<p align="left"><span style="color:#333333;">垃圾回收是在内存中存在没有引用的对象或超过作用域的对象时进行。</span></p> 
<p align="left"><span style="color:#333333;">垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;">36.  </span><span style="color:#333333;background:#FFFFFF;">System.gc()</span><span style="color:#333333;background:#FFFFFF;">和</span><span style="color:#333333;background:#FFFFFF;">Runtime.gc()</span><span style="color:#333333;background:#FFFFFF;">会做什么事情？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">这两个方法用来提示</span><span style="color:#333333;background:#D3F4EF;">JVM</span><span style="color:#333333;background:#D3F4EF;">要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于</span><span style="color:#333333;background:#D3F4EF;">JVM</span><span style="color:#333333;background:#D3F4EF;">的。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;">37.  </span><span style="color:#333333;background:#FFFFFF;">finalize()</span><span style="color:#333333;background:#FFFFFF;">方法什么时候被调用？析构函数</span><span style="color:#333333;background:#FFFFFF;">(finalization)</span><span style="color:#333333;background:#FFFFFF;">的目的是什么？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">垃圾回收器</span><span style="color:#333333;background:#D3F4EF;">(garbagecolector)</span><span style="color:#333333;background:#D3F4EF;">决定回收某对象时，就会运行该对象的</span><span style="color:#333333;background:#D3F4EF;">finalize()</span><span style="color:#333333;background:#D3F4EF;">方法</span><span style="color:#333333;background:#D3F4EF;">但是在</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说</span><span style="color:#333333;background:#D3F4EF;">filalize()</span><span style="color:#333333;background:#D3F4EF;">可能永远不被执行，显然指望它做收尾工作是靠不住的。</span><span style="color:#333333;background:#D3F4EF;">那么</span><span style="color:#333333;background:#D3F4EF;">finalize()</span><span style="color:#333333;background:#D3F4EF;">究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种</span><span style="color:#333333;background:#D3F4EF;">JNI(Java Native Interface)</span><span style="color:#333333;background:#D3F4EF;">调用</span><span style="color:#333333;background:#D3F4EF;">non-Java</span><span style="color:#333333;background:#D3F4EF;">程序（</span><span style="color:#333333;background:#D3F4EF;">C</span><span style="color:#333333;background:#D3F4EF;">或</span><span style="color:#333333;background:#D3F4EF;">C++</span><span style="color:#333333;background:#D3F4EF;">），</span><span style="color:#333333;background:#D3F4EF;">finalize()</span><span style="color:#333333;background:#D3F4EF;">的工作就是回收这部分的内存。</span></p> 
<p>调用时机：当垃圾回收器要宣告一个对象死亡时，至少要经过两次标记过程：如果对象在进行可达性分析后发现没有和GC Roots相连接的引用链，就会被第一次标记，并且判断是否执行finalizer( )方法，如果对象覆盖finalizer( )方法且未被虚拟机调用过，那么这个对象会被放置在F-Queue队列中，并在稍后由一个虚拟机自动建立的低优先级的Finalizer线程区执行触发finalizer( )方法，但不承诺等待其运行结束。 </p> 
<p>finalization的目的：对象逃脱死亡的最后一次机会。（只要重新与引用链上的任何一个对象建立关联即可。）但是不建议使用，运行代价高昂，不确定性大，且无法保证各个对象的调用顺序。可用try-finally或其他替代。</p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#666666;">38.  </span><span style="color:#333333;background:#FFFFFF;">如果对象的引用被置为</span><span style="color:#333333;background:#FFFFFF;">null</span><span style="color:#333333;background:#FFFFFF;">，垃圾收集器是否会立即释放对象占用的内存？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;">不会立即释放对象占用的内存。</span><span style="color:#333333;">如果对象的引用被置为</span><span style="color:#333333;">null</span><span style="color:#333333;">，只是断开了当前线程栈帧中对该对象的引用关系，而</span><span style="color:#333333;">垃圾收集器是运行在后台的线程，只有当用户线程运行到安全点</span><span style="color:#333333;">(safe point)</span><span style="color:#333333;">或者安全区域才会扫描对象引用关系，扫描到对象没有被引用则会标记对象，这时候仍然不会立即释放该对象内存，因为有些对象是可恢复的（在</span> finalize方法中恢复引用<span style="color:#333333;">）。只有确定了对象无法恢复引用的时候才会清除对象内存</span><span style="color:#333333;">.</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;">39.  </span><span style="color:#333333;background:#FFFFFF;">Java</span><span style="color:#333333;background:#FFFFFF;">堆的结构是什么样子的？什么是堆中的永久代</span><span style="color:#333333;background:#FFFFFF;">(Perm Gen space)?</span></p> 
<p align="left"><span style="color:#333333;background:#D3F4EF;">JVM</span><span style="color:#333333;background:#D3F4EF;">的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在</span><span style="color:#333333;background:#D3F4EF;">JVM</span><span style="color:#333333;background:#D3F4EF;">启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。</span></p> 
<p align="left"><span style="color:#333333;">堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。</span></p> 
<p align="left"><span style="color:#333333;"> </span></p> 
<p align="left"><span style="color:#333333;">永久代是用于存放静态文件，如</span><span style="color:#333333;">Java</span><span style="color:#333333;">类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些</span><span style="color:#333333;">class</span><span style="color:#333333;">，例如</span><span style="color:#333333;">Hibernate </span><span style="color:#333333;">等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类，永久代中一般包含：</span></p> 
<p align="left"><span style="color:#333333;">·        </span><span style="color:#333333;">类的方法</span><span style="color:#333333;">(</span><span style="color:#333333;">字节码</span><span style="color:#333333;">...)</span></p> 
<p align="left"><span style="color:#333333;">·        </span><span style="color:#333333;">类名</span><span style="color:#333333;">(Sring</span><span style="color:#333333;">对象</span><span style="color:#333333;">)</span></p> 
<p align="left"><span style="color:#333333;">·        </span><span style="color:#333333;">.class</span><span style="color:#333333;">文件读到的常量信息</span></p> 
<p align="left"><span style="color:#333333;">·        </span><span style="color:#333333;">class</span><span style="color:#333333;">对象相关的对象列表和类型列表</span><span style="color:#333333;"> (e.g., </span><span style="color:#333333;">方法对象的</span><span style="color:#333333;">array).</span></p> 
<p align="left"><span style="color:#333333;">·        </span><span style="color:#333333;">JVM</span><span style="color:#333333;">创建的内部对象</span></p> 
<p align="left"><span style="color:#333333;">·        </span><span style="color:#333333;">JIT</span><span style="color:#333333;">编译器优化用的信息</span></p> 
<p><u>虚拟机中的共划分为三个代：</u> </p> 
<p>        年轻代（YoungGeneration）、年老代（Old Generation）和持久代（Permanent  </p> 
<p>Generation）。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系 </p> 
<p>不大。年轻代和年老代的划分是对垃 圾收集影响比较大的。 </p> 
<p align="left">·        <strong>年轻代:</strong> </p> 
<p>        所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生 </p> 
<p>命周期短的对象。年轻代分三个区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在 </p> 
<p>Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这 </p> 
<p>个 Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了 </p> 
<p>的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区 </p> 
<p>(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时 </p> 
<p>存在从Eden复制过来对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第 </p> 
<p>一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要， </p> 
<p>Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减 </p> 
<p>少被放到年老代的可能。 </p> 
<p align="left">·        <strong>年老代:</strong> </p> 
<p>        在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认 </p> 
<p>为年老代中存放的都是一些生命周期较长的对象。 </p> 
<p align="left">·        <strong>持久代:</strong> </p> 
<p>        用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应 <br>用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持 <br>久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=&lt;N&gt;进行设置。</p> 
<p><span style="color:#333333;">40.  </span><span style="color:#333333;background:#FFFFFF;">串行</span><span style="color:#333333;background:#FFFFFF;">(serial)</span><span style="color:#333333;background:#FFFFFF;">收集器和吞吐量</span><span style="color:#333333;background:#FFFFFF;">(throughput)</span><span style="color:#333333;background:#FFFFFF;">收集器的区别是什么？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用</span><span style="color:#333333;background:#D3F4EF;">(</span><span style="color:#333333;background:#D3F4EF;">在现代处理器上需要大概</span><span style="color:#333333;background:#D3F4EF;">100M</span><span style="color:#333333;background:#D3F4EF;">左右的内存</span><span style="color:#333333;background:#D3F4EF;">)</span><span style="color:#333333;background:#D3F4EF;">就足够了。</span></p> 
<p>串行GC：整个扫描和复制过程均采用<strong>单线程</strong>的方式，相对于吞吐量GC来说简单；适合于<strong>单CPU、客户端</strong>级别。 </p> 
<p>吞吐量GC：采用<strong>多线程</strong>的方式来完成垃圾收集；适合于<strong>吞吐量</strong>要求较高的场合，比较适合中等和大规模的应用程序。</p> 
<p><span style="color:#333333;">41.  </span><span style="color:#333333;background:#FFFFFF;">在</span><span style="color:#333333;background:#FFFFFF;">Java</span><span style="color:#333333;background:#FFFFFF;">中，对象什么时候可以被垃圾回收？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。</span></p> 
<p>当一个对象到GC Roots不可达时，在下一个垃圾回收周期中尝试回收该对象，如果该对象重写了finalize()方法，并在这个方法中成功自救(将自身赋予某个引用)，那么这个对象不会被回收。但如果这个对象没有重写finalize()方法或者已经执行过这个方法，也自救失败，该对象将会被回收。</p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;">42.  </span><span style="color:#333333;background:#FFFFFF;">JVM</span><span style="color:#333333;background:#FFFFFF;">的永久代中会发生垃圾回收么？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收</span><span style="color:#333333;background:#D3F4EF;">(Full GC)</span><span style="color:#333333;background:#D3F4EF;">。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免</span><span style="color:#333333;background:#D3F4EF;">Full GC</span><span style="color:#333333;background:#D3F4EF;">是非常重要的原因。请参考下</span><span style="color:#333333;background:#D3F4EF;">Java8</span><span style="color:#333333;background:#D3F4EF;">：从永久代到元数据区</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">(</span></span><span style="color:#333333;background:#D3F4EF;">注：</span><span style="color:#333333;background:#D3F4EF;">Java8</span><span style="color:#333333;background:#D3F4EF;">中已经移除了永久代，新加了一个叫做元数据区的</span><span style="color:#333333;background:#D3F4EF;">native</span><span style="color:#333333;background:#D3F4EF;">内存区</span><span style="color:#333333;background:#D3F4EF;">)</span></p> 
<p align="left" style="background:#FFFFFF;">hotspot的方法区存放在永久代中，因此方法区被人们称为永久代。永久代的垃圾回收主要包括类型的卸载和废弃常量池的回收。当没有对象引用一个常量的时候，该常量即可以被回收。而类型的卸载更加复杂。必须满足一下三点，该类型的所有实例都被回收了，该类型的ClassLoader被回收了，该类型对应的java.lang.Class没有在任何地方被引用，在任何地方都无法通过反射来实例化一个对象</p> 
<p align="left"><span style="color:#333333;">43.  </span><span style="color:#333333;">Java</span><span style="color:#333333;">中的两种异常类型是什么？他们有什么区别？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">中有两种异常：受检查的</span><span style="color:#333333;background:#D3F4EF;">(checked)</span><span style="color:#333333;background:#D3F4EF;">异常和不受检查的</span><span style="color:#333333;background:#D3F4EF;">(unchecked)</span><span style="color:#333333;background:#D3F4EF;">异常。不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。相反，受检查的异常必须要用</span><span style="color:#333333;background:#D3F4EF;">throws</span><span style="color:#333333;background:#D3F4EF;">语句在方法或者是构造函数上声明。</span></p> 
<p>Throwable是所有异常的根，java.lang.Throwable<br>Error是错误，java.lang.Error<br>Exception是异常，java.lang.Exception </p> 
<p><strong><span style="color:#FF0000;">二、Exception</span></strong></p> 
<p>一般分为Checked异常和Runtime异常，所有RuntimeException类及其子类的实例被称为Runtime异常，不属于该范畴的异常则被称为CheckedException。 </p> 
<p><strong><span style="color:#FF0000;">①Checked</span><span style="color:#FF0000;">异常</span></strong></p> 
<p>只有java语言提供了Checked异常，Java认为Checked异常都是可以被处理的异常，所以Java程序必须显示处理Checked异常。如果程序没有处理Checked异常，该程序在编译时就会发生错误无法编译。这体现了Java的设计哲学：<span style="color:#FF0000;">没有完善错误处理的代码根本没有机会被执行。</span>对Checked异常处理方法有两种 </p> 
<p>1 当前方法知道如何处理该异常，则用try...catch块来处理该异常。</p> 
<p>2 当前方法不知道如何处理，则在定义该方法是声明抛出该异常。 </p> 
<p>我们比较熟悉的Checked异常有 </p> 
<p>Java.lang.ClassNotFoundException<br>Java.lang.NoSuchMetodException</p> 
<p>java.io.IOException </p> 
<p><strong><span style="color:#FF0000;">②RuntimeException</span></strong></p> 
<p>Runtime如除数是0和数组下标越界等，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大。所以由系统自动检测并将它们交给缺省的异常处理程序。当然如果你有处理要求也可以显示捕获它们。 </p> 
<p>我们比较熟悉的RumtimeException类的子类有 </p> 
<p>Java.lang.ArithmeticException<br>Java.lang.ArrayStoreExcetpion<br>Java.lang.ClassCastException<br>Java.lang.IndexOutOfBoundsException</p> 
<p>Java.lang.NullPointerException </p> 
<p><strong><span style="color:#FF0000;">三、Error</span></strong></p> 
<p>当程序发生不可控的错误时，通常做法是通知用户并中止程序的执行。与异常不同的是Error及其子类的对象不应被抛出。 </p> 
<p>Error是throwable的子类，代表编译时间和系统错误，用于指示合理的应用程序不应该试图捕获的严重问题。 </p> 
<p>Error由Java虚拟机生成并抛出，包括动态链接失败，虚拟机错误等。程序对其不做处理。</p> 
<p><span style="color:#333333;">44. </span><span style="color:#333333;background:#FFFFFF;">Java</span><span style="color:#333333;background:#FFFFFF;">中</span><span style="color:#333333;background:#FFFFFF;">Exception</span><span style="color:#333333;background:#FFFFFF;">和</span><span style="color:#333333;background:#FFFFFF;">Error</span><span style="color:#333333;background:#FFFFFF;">有什么区别？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">Exception</span><span style="color:#333333;background:#D3F4EF;">和</span><span style="color:#333333;background:#D3F4EF;">Error</span><span style="color:#333333;background:#D3F4EF;">都是</span><span style="color:#333333;background:#D3F4EF;">Throwable</span><span style="color:#333333;background:#D3F4EF;">的子类。</span><span style="color:#333333;background:#D3F4EF;">Exception</span><span style="color:#333333;background:#D3F4EF;">用于用户程序可以捕获的异常情况。</span><span style="color:#333333;background:#D3F4EF;">Error</span><span style="color:#333333;background:#D3F4EF;">定义了不期望被用户程序捕获的异常。</span></p> 
<p>Error ：表示由 JVM 所侦测到的无法预期的错误，由于这是属于 JVM 层次的严重错误，导致 JVM 无法继续执行，因此，这是不可捕捉到的，无法采取任何恢复的操作，顶多只能显示错误信息。 </p> 
<p>Exception ：包括runtimeException和受检异常， checked 异常也就是我们经常遇到的 IO 异常，以及 SQL 异常都是这种异常。对于这种异常， JAVA 编译器强制要求我们必需对出现的这些异常进行 catch 。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆 catch 块去处理可能的异常。 </p> 
<p>但是另外一种异常： runtime exception ，也称运行时异常，我们可以不处理。当出现这样的异常时，总是由虚拟机 接管。比如：我们从来没有人去处理过 NullPointerException 异常，它就是运行时异常，并且这种异常还是最常见的异常之一。</p> 
<p><span style="color:#333333;">45. </span><span style="color:#333333;background:#FFFFFF;">throw</span><span style="color:#333333;background:#FFFFFF;">和</span><span style="color:#333333;background:#FFFFFF;">throws</span><span style="color:#333333;background:#FFFFFF;">有什么区别？</span></p> 
<p align="left" style="background:#FFFFFF;">        <span style="color:#666666;">1</span><span style="color:#666666;">、</span><span style="color:#666666;">Throw</span><span style="color:#666666;">用于方法内部，</span><span style="color:#666666;">Throws</span><span style="color:#666666;">用于方法声明上</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#666666;">2</span><span style="color:#666666;">、</span><span style="color:#666666;">Throw</span><span style="color:#666666;">后跟异常对象，</span><span style="color:#666666;">Throws</span><span style="color:#666666;">后跟异常类型</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#666666;">3</span><span style="color:#666666;">、</span><span style="color:#666666;">Throw</span><span style="color:#666666;">后只能跟一个异常对象，</span><span style="color:#666666;">Throws</span><span style="color:#666666;">后可以一次声明多种异常类型</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">throw</span><span style="color:#333333;background:#D3F4EF;">关键字用来在程序中明确的抛出异常，相反，</span><span style="color:#333333;background:#D3F4EF;">throws</span><span style="color:#333333;background:#D3F4EF;">语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;">46.  </span><span style="color:#333333;background:#FFFFFF;">异常处理完成以后，</span><span style="color:#333333;background:#FFFFFF;">Exception</span><span style="color:#333333;background:#FFFFFF;">对象会发生什么变化？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">Exception</span><span style="color:#333333;background:#D3F4EF;">对象会在下一个垃圾回收过程中被回收掉。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;">47.  </span><span style="color:#333333;background:#FFFFFF;">finally</span><span style="color:#333333;background:#FFFFFF;">代码块和</span><span style="color:#333333;background:#FFFFFF;">finalize()</span><span style="color:#333333;background:#FFFFFF;">方法有什么区别？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">无论是否抛出异常，</span><span style="color:#333333;background:#D3F4EF;">finally</span><span style="color:#333333;background:#D3F4EF;">代码块都会执行，它主要是用来释放应用占用的资源。</span><span style="color:#333333;background:#D3F4EF;">finalize()</span><span style="color:#333333;background:#D3F4EF;">方法是</span><span style="color:#333333;background:#D3F4EF;">Object</span><span style="color:#333333;background:#D3F4EF;">类的一个</span><span style="color:#333333;background:#D3F4EF;">protected</span><span style="color:#333333;background:#D3F4EF;">方法，它是在对象被垃圾回收之前由</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">虚拟机来调用的。</span></p> 
<p align="left" style="background:#FFFFFF;">1. final是关键字，final可以修饰类、方法、属性。如果一个类被final修饰，那么这个类就是最终类，不能派生出新的子类，不能作为父类被继承，该类中的所有方法都不能被重写，但是final类中的成员变量是可以改变的，要想final类中的成员变量的不可以改变，必须给成员变量添加final修饰。因此，一个类不能同时被final和abstract修饰，这两个关键字相互矛盾。如果final修饰方法，那么这个方法是最终方法，不允许任何子类重写该方法，但子类仍可以使用该方法，注意：final参数用来表示这个参数在这个函数内部不允许被修改。 final修饰属性，被final修饰的变量不可变。这里的不可变有两重含义：引用不可变和对象不可变。final指的是引用不可变，即它只能指向初始化时指向的那个对象，而不关心指向对象内容的变化。因此，被final修饰的变量必须初始化，该变量其实就是常量。</p> 
<p align="left" style="background:#FFFFFF;">2. finally作为异常处理的一部分，只能用在try/catch语句快中，finally代码块中的语句一定会被执行，经常被用来释放资源，如IO流和数据库资源的释放。 </p> 
<p align="left" style="background:#FFFFFF;">3. finalize是Object类的一个方法，该方法在Object类中声明：protected void finalize() throws Throwable { } 在垃圾回收器执行时会调用被回收对象的finalize()方法，可以覆盖此方法来实现对其资源的回收。注意：一旦垃圾回收器准备释放某个对象占用的空间，将首先调该对象的 finalize()方法，并且在下一次垃圾回收动作发生时，才真正将该对象占用的内存回收。</p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;">48.  </span><span style="color:#333333;background:#FFFFFF;">什么是</span><span style="color:#333333;background:#FFFFFF;">Applet</span><span style="color:#333333;background:#FFFFFF;">？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">java applet</span><span style="color:#333333;background:#D3F4EF;">是能够被包含在</span><span style="color:#333333;background:#D3F4EF;">HTML</span><span style="color:#333333;background:#D3F4EF;">页面中并且能被启用了</span><span style="color:#333333;background:#D3F4EF;">java</span><span style="color:#333333;background:#D3F4EF;">的客户端浏览器执行的程序。</span><span style="color:#333333;background:#D3F4EF;">Applet</span><span style="color:#333333;background:#D3F4EF;">主要用来创建动态交互的</span><span style="color:#333333;background:#D3F4EF;">web</span><span style="color:#333333;background:#D3F4EF;">应用程序。</span></p> 
<p>Java应用小程序，可以直接嵌入到网页中，并能够产生特殊的效果，applet经编译后会产生.class文件，把.class文件嵌入到html页面中，用户在链接网页时，applet便会伴随网页一起下载到用户计算机运行。 </p> 
<p>applet主要用来创建动态交互的web应用程序。</p> 
<p><span style="color:#333333;">49.  </span><span style="color:#333333;background:#FFFFFF;">解释一下</span><span style="color:#333333;background:#FFFFFF;">Applet</span><span style="color:#333333;background:#FFFFFF;">的生命周期</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">可以经历下面的状态：</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">Init</span></span><span style="color:#333333;background:#D3F4EF;">：每次被载入的时候都会被初始化。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">Start</span></span><span style="color:#333333;background:#D3F4EF;">：开始执行</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">Stop</span></span><span style="color:#333333;background:#D3F4EF;">：结束执行</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">Destroy</span></span><span style="color:#333333;background:#D3F4EF;">：卸载</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">之前，做最后的清理工作。</span></p> 
<p>一个 Applet 的生命周期 </p> 
<p><span style="color:#666666;">Applet </span><span style="color:#666666;">类中的四个方法给了你构建 applet </span>程序时的框架： </p> 
<p align="left"><span style="color:#333333;">·        </span><strong><span style="color:#333333;">init</span><span style="color:#333333;">：</span></strong><span style="color:#333333;"> </span><span style="color:#333333;">这个方法适用于你的</span><span style="color:#333333;"> applet </span><span style="color:#333333;">程序所需要的任何初始化。它在</span><span style="color:#333333;"> applet </span><span style="color:#333333;">标记中的参数标签被处理后被调用。</span></p> 
<p align="left"><span style="color:#333333;">·        </span><strong><span style="color:#333333;">start</span><span style="color:#333333;">：</span></strong><span style="color:#333333;"> </span><span style="color:#333333;">这个方法在浏览器调用</span><span style="color:#333333;"> init </span><span style="color:#333333;">方法后被自动调用。它也在无论何时使用者在去其他页面后返回到包含</span><span style="color:#333333;"> applet </span><span style="color:#333333;">的页面时被调用。</span></p> 
<p align="left"><span style="color:#333333;">·        </span><strong><span style="color:#333333;">stop</span><span style="color:#333333;">：</span></strong><span style="color:#333333;"> </span><span style="color:#333333;">这个方法在使用者离开有</span><span style="color:#333333;"> applet </span><span style="color:#333333;">所在的页面时被自动调用。因此，它在同一个</span><span style="color:#333333;"> applet </span><span style="color:#333333;">中能被重复调用。</span></p> 
<p align="left"><span style="color:#333333;">·        </span><strong><span style="color:#333333;">destroy</span><span style="color:#333333;">：</span></strong><span style="color:#333333;"> </span><span style="color:#333333;">这个方法仅当浏览器正常关闭时被自动调用。因为</span><span style="color:#333333;"> applet </span><span style="color:#333333;">程序是生存在</span><span style="color:#333333;"> HTML </span><span style="color:#333333;">页面上的，你不应该在使用者离开有</span><span style="color:#333333;"> applet </span><span style="color:#333333;">的网页后留下资源。</span></p> 
<p align="left"><span style="color:#333333;">·        </span><strong><span style="color:#333333;">paint</span><span style="color:#333333;">：</span></strong><span style="color:#333333;"> </span><span style="color:#333333;">在</span><span style="color:#333333;"> start() </span><span style="color:#333333;">方法之后被立即调用，或是在</span><span style="color:#333333;"> applet </span><span style="color:#333333;">需要在浏览器上重现它自身的任何时候。</span><span style="color:#333333;">paint() </span><span style="color:#333333;">方法实际上是继承自</span><span style="color:#333333;"> java.awt</span><span style="color:#333333;">。</span></p> 
<p><span style="color:#333333;">50.  </span><span style="color:#333333;background:#FFFFFF;">当</span><span style="color:#333333;background:#FFFFFF;">applet</span><span style="color:#333333;background:#FFFFFF;">被载入的时候会发生什么？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">首先，创建</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">控制类的实例，然后初始化</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">，最后开始运行。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;">51.  </span><span style="color:#333333;background:#FFFFFF;">Applet</span><span style="color:#333333;background:#FFFFFF;">和普通的</span><span style="color:#333333;background:#FFFFFF;">Java</span><span style="color:#333333;background:#FFFFFF;">应用程序有什么区别？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">是运行在启用了</span><span style="color:#333333;background:#D3F4EF;">java</span><span style="color:#333333;background:#D3F4EF;">的浏览器中，</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">应用程序是可以在浏览器之外运行的独立的</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">程序。但是，它们都需要有</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">虚拟机。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">进一步来说，</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">应用程序需要一个有特定方法签名的</span><span style="color:#333333;background:#D3F4EF;">main</span><span style="color:#333333;background:#D3F4EF;">函数来开始执行。</span><span style="color:#333333;background:#D3F4EF;">Java applet</span><span style="color:#333333;background:#D3F4EF;">不需要这样的函数来开始执行。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">最后，</span><span style="color:#333333;background:#D3F4EF;">Java applet</span><span style="color:#333333;background:#D3F4EF;">一般会使用很严格的安全策略，</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">应用一般使用比较宽松的安全策略。</span></p> 
<p align="left" style="background:#FFFFFF;">（1）运行方式不同。Java Applet程序不能单独运行，它必须依附于一个用HTML语言编写的网页并嵌入其中，通过与Java兼容的浏览器来控制执行。Java Application是完整的程序，可以独立运行，只要有支持Java的虚拟机，它就可以独立运行而不需要其他文件的支持。 <br>         （2）运行工具不同。运行JavaApplet程序的解释器不是独立的软件，而是嵌在浏览器中作为浏览器软件的一部分。Java Application程序被编译以后，用普通的Java解释器就可以使其边解释边执行，而Java Applet必须通过网络浏览器或者Applet观察器才能执行。 <br>         （3）程序结构不同。每个JavaApplication程序必定含有一个并且只有一个main方法，程序执行时，首先寻找main方法，并以此为入口点开始运行。含有main方法的那个类，常被称为主类，也就是说，Java Application程序都含有一个主类。而Applet程序则没有含main方法的主类，这也正是Applet程序不能独立运行的原因。尽管Applet没有含main方法的主类，但Applet一定有一个从 java.applet.Applet派生的类，它是由Java系统提供的。 <br>         （4）Java Applet程序可以直接利用浏览器或AppletViewer提供的图形用户界面，而JavaApplication程序则必须另外书写专用代码来营建自己的图形界面。 <br>         （5）受到的限制不同JavaApplication程序可以设计成能进行各种操作的程序，包括读/写文件的操作，但是 Java Applet 对站点的磁盘文件既不能进行读操作，也不能进行写操作。然而，由于 Applet的引入，使Web页面具有动态多媒体效果和可交互性能，这使由名为超文本、实为纯文本的HTML语言编写成的Web页面真正具有了超文本功能，不但可以显示文本信息，而且还可以有各种图片效果和动态图形效果，从而使页面显得生动美丽；另外，Applet使Web页面增加了按钮等功能，从而增加了交互性。</p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;">52.  </span><span style="color:#333333;background:#FFFFFF;">Java applet</span><span style="color:#333333;background:#FFFFFF;">有哪些限制条件？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">主要是由于安全的原因，给</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">施加了以下的限制：</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">applet</span></span><span style="color:#333333;background:#D3F4EF;">不能够载入类库或者定义本地方法。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">applet</span></span><span style="color:#333333;background:#D3F4EF;">不能在宿主机上读写文件。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">applet</span></span><span style="color:#333333;background:#D3F4EF;">不能读取特定的系统属性。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">applet</span></span><span style="color:#333333;background:#D3F4EF;">不能发起网络连接，除非是跟宿主机。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">applet</span></span><span style="color:#333333;background:#D3F4EF;">不能够开启宿主机上其他任何的程序。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;">53.  </span><span style="color:#333333;background:#FFFFFF;">什么是不受信任的</span><span style="color:#333333;background:#FFFFFF;">applet</span><span style="color:#333333;background:#FFFFFF;">？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">不受信任的</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">是不能访问或是执行本地系统文件的</span><span style="color:#333333;background:#D3F4EF;">Java applet</span><span style="color:#333333;background:#D3F4EF;">，默认情况下，所有下载的</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">都是不受信任的。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;">54.  </span><span style="color:#333333;background:#FFFFFF;">从网络上加载的</span><span style="color:#333333;background:#FFFFFF;">applet</span><span style="color:#333333;background:#FFFFFF;">和从本地文件系统加载的</span><span style="color:#333333;background:#FFFFFF;">applet</span><span style="color:#333333;background:#FFFFFF;">有什么区别？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">当</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">是从网络上加载的时候，</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">是由</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">类加载器载入的，它受</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">安全管理器的限制。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">当</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">是从客户端的本地磁盘载入的时候，</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">是由文件系统加载器载入的。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">从文件系统载入的</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">允许在客户端读文件，写文件，加载类库，并且也允许执行其他程序，但是，却通不过字节码校验。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;">55.  </span><span style="color:#333333;background:#FFFFFF;">applet</span><span style="color:#333333;background:#FFFFFF;">类加载器是什么？它会做哪些工作？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">当</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">是从网络上加载的时候，它是由</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">类加载器载入的。类加载器有自己的</span><span style="color:#333333;background:#D3F4EF;">java</span><span style="color:#333333;background:#D3F4EF;">名称空间等级结构。类加载器会保证来自文件系统的类有唯一的名称空间，来自网络资源的类有唯一的名称空间。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">当浏览器通过网络载入</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">的时候，</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">的类被放置于和</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">的源相关联的私有的名称空间中。然后，那些被类加载器载入进来的类都是通过了验证器验证的。验证器会检查类文件格式是否遵守</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">语言规范，确保不会出现堆栈溢出</span><span style="color:#333333;background:#D3F4EF;">(stack overflow)</span><span style="color:#333333;background:#D3F4EF;">或者下溢</span><span style="color:#333333;background:#D3F4EF;">(underflow)</span><span style="color:#333333;background:#D3F4EF;">，传递给字节码指令的参数是正确的。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;">56.  </span><span style="color:#333333;background:#FFFFFF;">applet</span><span style="color:#333333;background:#FFFFFF;">安全管理器是什么？它会做哪些工作？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">安全管理器是给</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">施加限制条件的一种机制。浏览器可以只有一个安全管理器。安全管理器在启动的时候被创建，之后不能被替换覆盖或者是扩展。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;">57.  </span><span style="color:#333333;background:#FFFFFF;">弹出式选择菜单</span><span style="color:#333333;background:#FFFFFF;">(Choice)</span><span style="color:#333333;background:#FFFFFF;">和列表</span><span style="color:#333333;background:#FFFFFF;">(List)</span><span style="color:#333333;background:#FFFFFF;">有什么区别</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">Choice</span><span style="color:#333333;background:#D3F4EF;">是以一种紧凑的形式展示的，需要下拉才能看到所有的选项。</span><span style="color:#333333;background:#D3F4EF;">Choice</span><span style="color:#333333;background:#D3F4EF;">中一次只能选中一个选项。</span><span style="color:#333333;background:#D3F4EF;">List</span><span style="color:#333333;background:#D3F4EF;">同时可以有多个元素可见，支持选中一个或者多个元素。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;">58.  </span><span style="color:#333333;background:#FFFFFF;">什么是布局管理器？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">布局管理器用来在容器中组织组件。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;">59.  </span><span style="color:#333333;background:#FFFFFF;">滚动条</span><span style="color:#333333;background:#FFFFFF;">(Scrollbar)</span><span style="color:#333333;background:#FFFFFF;">和滚动面板</span><span style="color:#333333;background:#FFFFFF;">(JScrollPane)</span><span style="color:#333333;background:#FFFFFF;">有什么区别？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">Scrollbar</span><span style="color:#333333;background:#D3F4EF;">是一个组件，不是容器。而</span><span style="color:#333333;background:#D3F4EF;">ScrollPane</span><span style="color:#333333;background:#D3F4EF;">是容器。</span><span style="color:#333333;background:#D3F4EF;">ScrollPane</span><span style="color:#333333;background:#D3F4EF;">自己处理滚动事件。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#7D7D7D;">60. </span><span style="color:#7D7D7D;background:#FFFFFF;">哪些</span><span style="color:#7D7D7D;background:#FFFFFF;">Swing</span><span style="color:#7D7D7D;background:#FFFFFF;">的方法是线程安全的？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">只有</span><span style="color:#333333;background:#D3F4EF;">3</span><span style="color:#333333;background:#D3F4EF;">个线程安全的方法：</span><span style="color:#333333;background:#D3F4EF;"> repaint(), revalidate(), and invalidate()</span><span style="color:#333333;background:#D3F4EF;">。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#7D7D7D;">61. </span><span style="color:#7D7D7D;background:#FFFFFF;">说出三种支持重绘</span><span style="color:#7D7D7D;background:#FFFFFF;">(painting)</span><span style="color:#7D7D7D;background:#FFFFFF;">的组件。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">Canvas, Frame, Panel,</span><span style="color:#333333;background:#D3F4EF;">和</span><span style="color:#333333;background:#D3F4EF;">Applet</span><span style="color:#333333;background:#D3F4EF;">支持重绘。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#7D7D7D;">62. </span><span style="color:#7D7D7D;background:#FFFFFF;">什么是裁剪</span><span style="color:#7D7D7D;background:#FFFFFF;">(clipping)</span><span style="color:#7D7D7D;background:#FFFFFF;">？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">限制在一个给定的区域或者形状的绘图操作叫做裁剪。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#7D7D7D;">63. </span><span style="color:#7D7D7D;background:#FFFFFF;">MenuItem</span><span style="color:#7D7D7D;background:#FFFFFF;">和</span><span style="color:#7D7D7D;background:#FFFFFF;">CheckboxMenuItem</span><span style="color:#7D7D7D;background:#FFFFFF;">的区别是什么？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">CheckboxMenuItem</span><span style="color:#333333;background:#D3F4EF;">类继承自</span><span style="color:#333333;background:#D3F4EF;">MenuItem</span><span style="color:#333333;background:#D3F4EF;">类，支持菜单选项可以选中或者不选中。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#7D7D7D;">64. </span><span style="color:#7D7D7D;background:#FFFFFF;">边缘布局</span><span style="color:#7D7D7D;background:#FFFFFF;">(BorderLayout)</span><span style="color:#7D7D7D;background:#FFFFFF;">里面的元素是如何布局的？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">BorderLayout</span><span style="color:#333333;background:#D3F4EF;">里面的元素是按照容器的东西南北中进行布局的。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#7D7D7D;">65. </span><span style="color:#7D7D7D;background:#FFFFFF;">网格包布局</span><span style="color:#7D7D7D;background:#FFFFFF;">(GridBagLayout)</span><span style="color:#7D7D7D;background:#FFFFFF;">里面的元素是如何布局的？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">GridBagLayout</span><span style="color:#333333;background:#D3F4EF;">里面的元素是按照网格进行布局的。不同大小的元素可能会占据网格的多于</span><span style="color:#333333;background:#D3F4EF;">1</span><span style="color:#333333;background:#D3F4EF;">行或一列。因此，行数和列数可以有不同的大小。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#7D7D7D;">66. </span><span style="color:#7D7D7D;background:#FFFFFF;">Window</span><span style="color:#7D7D7D;background:#FFFFFF;">和</span><span style="color:#7D7D7D;background:#FFFFFF;">Frame</span><span style="color:#7D7D7D;background:#FFFFFF;">有什么区别？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">Frame</span><span style="color:#333333;background:#D3F4EF;">类继承了</span><span style="color:#333333;background:#D3F4EF;">Window</span><span style="color:#333333;background:#D3F4EF;">类，它定义了一个可以有菜单栏的主应用窗口。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#7D7D7D;">67. </span><span style="color:#7D7D7D;background:#FFFFFF;">裁剪</span><span style="color:#7D7D7D;background:#FFFFFF;">(clipping)</span><span style="color:#7D7D7D;background:#FFFFFF;">和重绘</span><span style="color:#7D7D7D;background:#FFFFFF;">(repainting)</span><span style="color:#7D7D7D;background:#FFFFFF;">有什么联系？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">当窗口被</span><span style="color:#333333;background:#D3F4EF;">AWT</span><span style="color:#333333;background:#D3F4EF;">重绘线程进行重绘的时候，它会把裁剪区域设置成需要重绘的窗口的区域。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#7D7D7D;">68. </span><span style="color:#7D7D7D;background:#FFFFFF;">事件监听器接口</span><span style="color:#7D7D7D;background:#FFFFFF;">(event-listener interface)</span><span style="color:#7D7D7D;background:#FFFFFF;">和事件适配器</span><span style="color:#7D7D7D;background:#FFFFFF;">(event-adapter)</span><span style="color:#7D7D7D;background:#FFFFFF;">有什么关系？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">事件监听器接口定义了对特定的事件，事件处理器必须要实现的方法。事件适配器给事件监听器接口提供了默认的实现。</span></p> 
<p align="left" style="background:#FFFFFF;">事件监听器接口定义了对特定的事件，事件处理器必须要实现的方法。事件适配器给事件监听器接口提供了默认的实现。如果实现事件监听器接口，就需要重新写接口中的所有方法,会<span style="color:#333333;">造成不必要的代码浪费</span>。适配器是一种设计模式，用抽象类实现接口所有方法，可以没有语句，只需要重写关注的方法。所有的适配器抽象类都采用了接口的适配器模式来实现。步骤：适配器抽象类实现所需接口（没有具体的语句实现），自定义类继承抽象类，重写所需的单击事件（其他事件不必重写，有默认的实现）。</p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#7D7D7D;">69. </span><span style="color:#7D7D7D;background:#FFFFFF;">GUI</span><span style="color:#7D7D7D;background:#FFFFFF;">组件如何来处理它自己的事件？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">GUI</span><span style="color:#333333;background:#D3F4EF;">组件可以处理它自己的事件，只要它实现相对应的事件监听器接口，并且把自己作为事件监听器。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#7D7D7D;">70. </span><span style="color:#7D7D7D;background:#FFFFFF;">Java</span><span style="color:#7D7D7D;background:#FFFFFF;">的布局管理器比传统的窗口系统有哪些优势？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">使用布局管理器以一种一致的方式在所有的窗口平台上摆放组件。因为布局管理器不会和组件的绝对大小和位置相绑定，所以他们能够适应跨窗口系统的特定平台的不同。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#7D7D7D;">71. </span><span style="color:#7D7D7D;background:#FFFFFF;">Java</span><span style="color:#7D7D7D;background:#FFFFFF;">的</span><span style="color:#7D7D7D;background:#FFFFFF;">Swing</span><span style="color:#7D7D7D;background:#FFFFFF;">组件使用了哪种设计模式？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">中的</span><span style="color:#333333;background:#D3F4EF;">Swing</span><span style="color:#333333;background:#D3F4EF;">组件使用了</span><span style="color:#333333;background:#D3F4EF;">MVC(</span><span style="color:#333333;background:#D3F4EF;">视图</span><span style="color:#333333;background:#D3F4EF;">-</span><span style="color:#333333;background:#D3F4EF;">模型</span><span style="color:#333333;background:#D3F4EF;">-</span><span style="color:#333333;background:#D3F4EF;">控制器</span><span style="color:#333333;background:#D3F4EF;">)</span><span style="color:#333333;background:#D3F4EF;">设计模式。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#7D7D7D;">72. </span><span style="color:#7D7D7D;background:#FFFFFF;">什么是</span><span style="color:#7D7D7D;background:#FFFFFF;">JDBC</span><span style="color:#7D7D7D;background:#FFFFFF;">？</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">JDBC</span><span style="color:#333333;background:#D3F4EF;">是允许用户在不同数据库之间做选择的一个抽象层。</span><span style="color:#333333;background:#D3F4EF;">JDBC</span><span style="color:#333333;background:#D3F4EF;">允许开发者用</span><span style="color:#333333;background:#D3F4EF;">JAVA</span><span style="color:#333333;background:#D3F4EF;">写数据库应用程序，而不需要关心底层特定数据库的细节。</span></p> 
<p>JDBC（Java DataBase Connectivity）,是一套面向对象的应用程序接口（API），制定了统一的访问各类关系数据库的标准接口，为各个数据库厂商提供了标准的实现。通过JDBC技术，开发人员可以用纯Java语言和标准的SQL语句编写完整的数据库应用程序，并且真正地实现了软件的跨平台性。 </p> 
<p><strong>通常情况下使用JDBC完成以下操作：</strong> </p> 
<p>1.同数据库建立连接； </p> 
<p>2.向数据库发送SQL语句； </p> 
<p>3.处理从数据库返回的结果； </p> 
<p><strong>JDBC具有下列优点：</strong> </p> 
<p>1.JDBC与ODBC<span style="color:#333333;">(Open Database Connectivity</span><span style="color:#333333;">，即开放数据库互连）十分相似，便于软件开发人员理解；</span> </p> 
<p><span style="color:#333333;">2.JDBC</span><span style="color:#333333;">使软件开发人员从复杂的驱动程序编写工作中解脱出来，可以完全专注于业务逻辑开发；</span> </p> 
<p><span style="color:#333333;">3.JDBC</span><span style="color:#333333;">支持多种关系型数据库，大大增加了软件的可移植性；</span> </p> 
<p><span style="color:#333333;">4.JDBC API</span><span style="color:#333333;">是面向对象的，软件开发人员可以将常用的方法进行二次封装，从而提高代码的重用性；</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;">73.  </span><span style="color:#333333;background:#FFFFFF;">解释下驱动</span><span style="color:#333333;background:#FFFFFF;">(Driver)</span><span style="color:#333333;background:#FFFFFF;">在</span><span style="color:#333333;background:#FFFFFF;">JDBC</span><span style="color:#333333;background:#FFFFFF;">中的角色。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#333333;background:#D3F4EF;">JDBC</span><span style="color:#333333;background:#D3F4EF;">驱动提供了特定厂商对</span><span style="color:#333333;background:#D3F4EF;">JDBC API</span><span style="color:#333333;background:#D3F4EF;">接口类的实现，驱动必须要提供</span><span style="color:#333333;background:#D3F4EF;">java.sql</span><span style="color:#333333;background:#D3F4EF;">包下面这些类的实现：</span><span style="color:#333333;background:#D3F4EF;">Connection, Statement, PreparedStatement,CallableStatement,ResultSet</span><span style="color:#333333;background:#D3F4EF;">和</span><span style="color:#333333;background:#D3F4EF;">Driver</span><span style="color:#333333;background:#D3F4EF;">。</span></p> 
<p align="left" style="background:#FFFFFF;">一句话总结：在使用jdbc前，应该保证相应的Driver类已经被加载到jvm中，并且完成了类的初始化工作就行了 使用JDBC时，我们都会很自然得使用下列语句： java 代码 Class.forName("com.mysql.jdbc.Driver" ); String url ="jdbc:mysql://127.0.0.1/test?useUnicode=true&amp;characterEncoding=utf-8"; String user = "" ; String psw = "" ; Connection con =DriverManager.getConnection(url,user,psw); 为什么说很自然呢，因为无论是网上还是书本教程上得例子都是这样的，而且程序也确实正常运行了，于是大家也就心安理得的找葫芦画瓢下去了。一定要有这一句吗？不是的，我们完全可以用这样一句代替它： java 代码 com.mysql.jdbc.Driver driver = new com.mysql.jdbc.Driver(); //or： //newcom.mysql.jdbc.Driver(); String url ="jdbc:mysql://127.0.0.1/test?useUnicode=true&amp;characterEncoding=utf-8"; String user = "" ; String psw = "" ; Connection con =DriverManager.getConnection(url,user,psw); 大家可能都看出个大概来了，我们只需要在调用DriverManager的getConnection方法之前，保证相应的Driver类已经被加载到 jvm中，并且完成了类的初始化工作就行了，而具体是怎样实现这个功能却是没有讲究的。上面两种方法都可以实现这个功能，因此程序可以正常运行。注意了，如果我们进行如下操作，程序是不能正常运行的，因为这样仅仅使Driver类被装载到jvm中，却没有进行相应的初始化工作。 java 代码 com.mysql.jdbc.Driver driver = null ; //or： ClassLoadercl = new ClassLoader(); cl.loadClass("com.mysql.jdbc.Driver" ); 我们都知道JDBC是使用Bridge模式进行设计的，DriverManager就是其中的Abstraction，java.sql.Driver是 Implementor，com.mysql.jdbc.Driver是Implementor的一个具体实现（请参考GOF的Bridge模式的描 述）。大家注意了，前一个Driver是一个接口，后者却是一个类，它实现了前面的Driver接口。 Bridge模式中，Abstraction（DriverManager）是要拥有一个Implementor（Driver）的引用的，但是我们在使用过程中，并没有将Driver对象注册到DriverManager中去啊，这是怎么回事呢？jdk文档对Driver的描述中有这么一句： When a Driver class is loaded, it should create an instance ofitself and register it with the DriverManager 哦，原来是com.mysql.jdbc.Driver在装载完后自动帮我们完成了这一步骤。源代码是这样的： java 代码 package com.mysql.jdbc public class Driver extendsNonRegisteringDriver implements java.sql.Driver { // ~ Staticfields/initializers // --------------------------------------------- // //Register ourselves with the DriverManager // static { t ry { java.sql.DriverManager.registerDriver(newDriver()); } catch (SQLException E) { throw new RuntimeException("Can'tregister driver!" ); } } // ~ Constructors //----------------------------------------------------------- /** * Construct anew driver and register it with DriverManager * * @throws SQLException * if adatabase error occurs. */ public Driver() throws SQLException { // Required forClass.forName().newInstance() } }</p> 
<p><span style="color:#333333;">74. </span><span style="color:#333333;background:#FFFFFF;">Class.forName()</span><span style="color:#333333;background:#FFFFFF;">方法有什么作用？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">初始化参数指定的类，并且返回此类对应的</span><span style="color:#333333;background:#D3F4EF;">Class </span><span style="color:#333333;background:#D3F4EF;">对象</span></p> 
<p><span style="color:#333333;">在初始化一个类，生成一个实例的时候，newInstance()</span>方法和new关键字除了一个是方法，一个是关键字外，它们的区别在于创建对象的方式不一样，前者是使用类加载机制，后者是创建一个新类。 <span style="color:#333333;">从JVM</span>的角度看，我们使用关键字new创建一个类的时候，这个类可以没有被加载。但是使用newInstance()方法的时候，就必须保证：<span style="color:#333333;">1</span><span style="color:#333333;">、这个类已经加载；</span><span style="color:#333333;">2</span><span style="color:#333333;">、这个类已经连接了。</span><span style="color:#333333;">而完成上面两个步骤的正是Class</span>的静态方法forName()所完成的，这个静态方法调用了启动类加载器，即加载 java API的那个加载器。</p> 
<p><span style="color:#333333;">75. </span><span style="color:#333333;background:#FFFFFF;">PreparedStatement</span><span style="color:#333333;background:#FFFFFF;">比</span><span style="color:#333333;background:#FFFFFF;">Statement</span><span style="color:#333333;background:#FFFFFF;">有什么优势？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">PreparedStatements</span><span style="color:#333333;background:#D3F4EF;">是预编译的，因此，性能会更好。同时，不同的查询参数值，</span><span style="color:#333333;background:#D3F4EF;">PreparedStatement</span><span style="color:#333333;background:#D3F4EF;">可以重用。</span></p> 
<p>在开发中使用PreparedStatements，不要使用statement</p> 
<p>为什么呢？  </p> 
<ol start="1" type="1"><li>PreparedStatements是预编译的，PreparedStatements实例包涵已编译的sql语句，所以其执行呢速度要快于statement对象。 </li><li>PreparedStatements作为statement的子类，继承了statement的所有方法，三种方法，excute,excuteQuery和excuteUpdate已被更改以使之不再需要参数。 </li><li>PreparedStatements的代码可读性，可维护性强于statement. </li><li>极大的提高了安全性</li></ol> 
<p><span style="color:#333333;">76. </span><span style="color:#333333;background:#FFFFFF;">什么时候使用</span><span style="color:#333333;background:#FFFFFF;">CallableStatement</span><span style="color:#333333;background:#FFFFFF;">？用来准备</span><span style="color:#333333;background:#FFFFFF;">CallableStatement</span><span style="color:#333333;background:#FFFFFF;">的方法是什么？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">CallableStatement</span><span style="color:#333333;background:#D3F4EF;">用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。准备一个</span><span style="color:#333333;background:#D3F4EF;">CallableStatement</span><span style="color:#333333;background:#D3F4EF;">的方法是：</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">CallableStatement Connection.prepareCall();</span></span></p> 
<p><span style="color:#333333;">77. </span><span style="color:#333333;background:#FFFFFF;">数据库连接池是什么意思？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求</span><span style="color:#333333;background:#D3F4EF;">.</span></p> 
<p>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；连接池是存储、管理数据库连接的容器，应用程序把获取数据库连接的功能委托给连接池，每个连接池都有一个上限，如果连接池达到上限，应用程序线程申请连接时被堵塞，等待其他线程释放连接，每个线程使用完连接后并不马上关闭，至少把它返还给连接池。由于连接的共享，不会频繁的创建、销毁连接，因此就不会增加创建连接的开销，也不会出现socket释放延迟现象。</p> 
<p><span style="color:#333333;">78. </span><span style="color:#333333;background:#FFFFFF;">什么是</span><span style="color:#333333;background:#FFFFFF;">RMI</span><span style="color:#333333;background:#FFFFFF;">？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">远程方法调用</span><span style="color:#333333;background:#D3F4EF;">(Java RMI)</span><span style="color:#333333;background:#D3F4EF;">是</span><span style="color:#333333;background:#D3F4EF;">Java API</span><span style="color:#333333;background:#D3F4EF;">对远程过程调用</span><span style="color:#333333;background:#D3F4EF;">(RPC)</span><span style="color:#333333;background:#D3F4EF;">提供的面向对象的等价形式，支持直接传输序列化的</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">对象和分布式垃圾回收。远程方法调用可以看做是激活远程正在运行的对象上的方法的步骤。</span><span style="color:#333333;background:#D3F4EF;">RMI</span><span style="color:#333333;background:#D3F4EF;">对调用者是位置透明的，因为调用者感觉方法是执行在本地运行的对象上的。</span></p> 
<p>JavaRMI（Remote MethodInvocation）--Java的远程方法调用是Java所特有的分布式计算技术，它允许运行在一个Java虚拟机上的对象调用运行在另一个Java虚拟机上的对象的方法，从而使Java编程人员可以方便地在网络环境中作分布式计算。面向对象设计要求每个任务由最适合该任务的对象执行，RMI将这个概念更深入了一步，使任务可以在最适合该任务的机器上完成。 RMI定义了一组远程接口，可以用于生成远程对象。客户机可以象调用本地对象的方法一样用相同的语法调用远程对象。RMI API提供的类和方法可以处理所有访问远程方法的基础通信和参数引用要求的串行化。 使用RMI开发步骤： 1、定义一个远程接口（远程接口必须继承接口，每个方法必须抛出远程异常，方法参数和方法返回值都必须是可序列化的） 2、实现远程接口 3、定义使用远程对象的客户程序 4、产生远程访问对象的桩和框 5、注册远程对象 6、运行服务器和客户程序</p> 
<p><span style="color:#333333;">79. </span><span style="color:#333333;background:#FFFFFF;">RMI</span><span style="color:#333333;background:#FFFFFF;">体系结构的基本原则是什么？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">RMI</span><span style="color:#333333;background:#D3F4EF;">体系结构是基于一个非常重要的行为定义和行为实现相分离的原则。</span><span style="color:#333333;background:#D3F4EF;">RMI</span><span style="color:#333333;background:#D3F4EF;">允许定义行为的代码和实现行为的代码相分离，并且运行在不同的</span><span style="color:#333333;background:#D3F4EF;">JVM</span><span style="color:#333333;background:#D3F4EF;">上。</span></p> 
<p><span style="color:#333333;">80. </span><span style="color:#333333;background:#FFFFFF;">RMI</span><span style="color:#333333;background:#FFFFFF;">体系结构分哪几层？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">RMI</span><span style="color:#333333;background:#D3F4EF;">体系结构分以下几层：</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">存根和骨架层</span><span style="color:#333333;background:#D3F4EF;">(Stub and Skeleton layer)</span><span style="color:#333333;background:#D3F4EF;">：这一层对程序员是透明的，它主要负责拦截客户端发出的方法调用请求，然后把请求重定向给远程的</span><span style="color:#333333;background:#D3F4EF;">RMI</span><span style="color:#333333;background:#D3F4EF;">服务。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">远程引用层</span><span style="color:#333333;background:#D3F4EF;">(Remote Reference Layer)</span><span style="color:#333333;background:#D3F4EF;">：</span><span style="color:#333333;background:#D3F4EF;">RMI</span><span style="color:#333333;background:#D3F4EF;">体系结构的第二层用来解析客户端对服务端远程对象的引用。这一层解析并管理客户端对服务端远程对象的引用。连接是点到点的。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">传输层</span><span style="color:#333333;background:#D3F4EF;">(Transport layer)</span><span style="color:#333333;background:#D3F4EF;">：这一层负责连接参与服务的两个</span><span style="color:#333333;background:#D3F4EF;">JVM</span><span style="color:#333333;background:#D3F4EF;">。这一层是建立在网络上机器间的</span><span style="color:#333333;background:#D3F4EF;">TCP/IP</span><span style="color:#333333;background:#D3F4EF;">连接之上的。它提供了基本的连接服务，还有一些防火墙穿透策略。</span></p> 
<p><span style="color:#333333;">81. </span><span style="color:#333333;background:#FFFFFF;">RMI</span><span style="color:#333333;background:#FFFFFF;">中的远程接口</span><span style="color:#333333;background:#FFFFFF;">(Remote Interface)</span><span style="color:#333333;background:#FFFFFF;">扮演了什么样的角色？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">远程接口用来标识哪些方法是可以被非本地虚拟机调用的接口。远程对象必须要直接或者是间接实现远程接口。实现了远程接口的类应该声明被实现的远程接口，给每一个远程对象定义构造函数，给所有远程接口的方法提供实现。</span></p> 
<p><span style="color:#333333;">82. </span><span style="color:#333333;background:#FFFFFF;">java.rmi.Naming</span><span style="color:#333333;background:#FFFFFF;">类扮演了什么样的角色？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">java.rmi.Naming</span><span style="color:#333333;background:#D3F4EF;">类用来存储和获取在远程对象注册表里面的远程对象的引用。</span><span style="color:#333333;background:#D3F4EF;">Naming</span><span style="color:#333333;background:#D3F4EF;">类的每一个方法接收一个</span><span style="color:#333333;background:#D3F4EF;">URL</span><span style="color:#333333;background:#D3F4EF;">格式的</span><span style="color:#333333;background:#D3F4EF;">String</span><span style="color:#333333;background:#D3F4EF;">对象作为它的参数。</span></p> 
<p><span style="color:#333333;">83. </span><span style="color:#333333;background:#FFFFFF;">RMI</span><span style="color:#333333;background:#FFFFFF;">的绑定</span><span style="color:#333333;background:#FFFFFF;">(Binding)</span><span style="color:#333333;background:#FFFFFF;">是什么意思？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">绑定是为了查询找远程对象而给远程对象关联或者是注册以后会用到的名称的过程。远程对象可以使用</span><span style="color:#333333;background:#D3F4EF;">Naming</span><span style="color:#333333;background:#D3F4EF;">类的</span><span style="color:#333333;background:#D3F4EF;">bind()</span><span style="color:#333333;background:#D3F4EF;">或者</span><span style="color:#333333;background:#D3F4EF;">rebind()</span><span style="color:#333333;background:#D3F4EF;">方法跟名称相关联。</span></p> 
<p><span style="color:#333333;">84. </span><span style="color:#333333;background:#FFFFFF;">Naming</span><span style="color:#333333;background:#FFFFFF;">类的</span><span style="color:#333333;background:#FFFFFF;">bind()</span><span style="color:#333333;background:#FFFFFF;">和</span><span style="color:#333333;background:#FFFFFF;">rebind()</span><span style="color:#333333;background:#FFFFFF;">方法有什么区别？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">bind()</span><span style="color:#333333;background:#D3F4EF;">方法负责把指定名称绑定给远程对象，</span><span style="color:#333333;background:#D3F4EF;">rebind()</span><span style="color:#333333;background:#D3F4EF;">方法负责把指定名称重新绑定到一个新的远程对象。如果那个名称已经绑定过了，先前的绑定会被替换掉。</span></p> 
<p><span style="color:#333333;">85. </span><span style="color:#333333;background:#FFFFFF;">让</span><span style="color:#333333;background:#FFFFFF;">RMI</span><span style="color:#333333;background:#FFFFFF;">程序能正确运行有哪些步骤？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">为了让</span><span style="color:#333333;background:#D3F4EF;">RMI</span><span style="color:#333333;background:#D3F4EF;">程序能正确运行必须要包含以下几个步骤：</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">编译所有的源文件。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">使用</span><span style="color:#333333;background:#D3F4EF;">rmic</span><span style="color:#333333;background:#D3F4EF;">生成</span><span style="color:#333333;background:#D3F4EF;">stub</span><span style="color:#333333;background:#D3F4EF;">。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">启动</span><span style="color:#333333;background:#D3F4EF;">rmiregistry</span><span style="color:#333333;background:#D3F4EF;">。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">启动</span><span style="color:#333333;background:#D3F4EF;">RMI</span><span style="color:#333333;background:#D3F4EF;">服务器。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">运行客户端程序。</span></p> 
<p><span style="color:#333333;">86. </span><span style="color:#333333;background:#FFFFFF;">RMI</span><span style="color:#333333;background:#FFFFFF;">的</span><span style="color:#333333;background:#FFFFFF;">stub</span><span style="color:#333333;background:#FFFFFF;">扮演了什么样的角色？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">远程对象的</span><span style="color:#333333;background:#D3F4EF;">stub</span><span style="color:#333333;background:#D3F4EF;">扮演了远程对象的代表或者代理的角色。调用者在本地</span><span style="color:#333333;background:#D3F4EF;">stub</span><span style="color:#333333;background:#D3F4EF;">上调用方法，它负责在远程对象上执行方法。当</span><span style="color:#333333;background:#D3F4EF;">stub</span><span style="color:#333333;background:#D3F4EF;">的方法被调用的时候，会经历以下几个步骤：</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">初始化到包含了远程对象的</span><span style="color:#333333;background:#D3F4EF;">JVM</span><span style="color:#333333;background:#D3F4EF;">的连接。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">序列化参数到远程的</span><span style="color:#333333;background:#D3F4EF;">JVM</span><span style="color:#333333;background:#D3F4EF;">。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">等待方法调用和执行的结果。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">反序列化返回的值或者是方法没有执行成功情况下的异常。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">把值返回给调用者。</span></p> 
<p><span style="color:#333333;">87. </span><span style="color:#333333;background:#FFFFFF;">什么是分布式垃圾回收</span><span style="color:#333333;background:#FFFFFF;">(DGC)</span><span style="color:#333333;background:#FFFFFF;">？它是如何工作的？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">DGC</span><span style="color:#333333;background:#D3F4EF;">叫做分布式垃圾回收。</span><span style="color:#333333;background:#D3F4EF;">RMI</span><span style="color:#333333;background:#D3F4EF;">使用</span><span style="color:#333333;background:#D3F4EF;">DGC</span><span style="color:#333333;background:#D3F4EF;">来做自动垃圾回收。因为</span><span style="color:#333333;background:#D3F4EF;">RMI</span><span style="color:#333333;background:#D3F4EF;">包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。</span><span style="color:#333333;background:#D3F4EF;">DGC</span><span style="color:#333333;background:#D3F4EF;">使用引用计数算法来给远程对象提供自动内存管理。</span></p> 
<p>RMI 子系统实现基于引用计数的“分布式垃圾回收”(DGC)，以便为远程服务器对象提供自动内存管理设施。 </p> 
<p>当客户机创建（序列化）远程引用时，会在服务器端 DGC 上调用 dirty()。当客户机完成远程引用后，它会调用对应的 clean() 方法。 </p> 
<p>针对远程对象的引用由持有该引用的客户机租用一段时间。租期从收到 dirty() 调用开始。在此类租约到期之前，客户机必须通过对远程引用额外调用 dirty() 来更新租约。如果客户机不在租约到期前进行续签，那么分布式垃圾收集器会假设客户机不再引用远程对象。</p> 
<p><span style="color:#333333;">88. </span><span style="color:#333333;background:#FFFFFF;">RMI</span><span style="color:#333333;background:#FFFFFF;">中使用</span><span style="color:#333333;background:#FFFFFF;">RMI</span><span style="color:#333333;background:#FFFFFF;">安全管理器</span><span style="color:#333333;background:#FFFFFF;">(RMISecurityManager)</span><span style="color:#333333;background:#FFFFFF;">的目的是什么？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">RMISecurityManager</span><span style="color:#333333;background:#D3F4EF;">使用下载好的代码提供可被</span><span style="color:#333333;background:#D3F4EF;">RMI</span><span style="color:#333333;background:#D3F4EF;">应用程序使用的安全管理器。如果没有设置安全管理器，</span><span style="color:#333333;background:#D3F4EF;">RMI</span><span style="color:#333333;background:#D3F4EF;">的类加载器就不会从远程下载任何的类。</span></p> 
<p><span style="color:#333333;">89. </span><span style="color:#333333;background:#FFFFFF;">解释下</span><span style="color:#333333;background:#FFFFFF;">Marshalling</span><span style="color:#333333;background:#FFFFFF;">和</span><span style="color:#333333;background:#FFFFFF;">demarshalling</span><span style="color:#333333;background:#FFFFFF;">。</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">当应用程序希望把内存对象跨网络传递到另一台主机或者是持久化到存储的时候，就必须要把对象在内存里面的表示转化成合适的格式。这个过程就叫做</span><span style="color:#333333;background:#D3F4EF;">Marshalling</span><span style="color:#333333;background:#D3F4EF;">，反之就是</span><span style="color:#333333;background:#D3F4EF;">demarshalling</span><span style="color:#333333;background:#D3F4EF;">。</span></p> 
<p><span style="color:#333333;">90. </span><span style="color:#333333;background:#FFFFFF;">解释下</span><span style="color:#333333;background:#FFFFFF;">Serialization</span><span style="color:#333333;background:#FFFFFF;">和</span><span style="color:#333333;background:#FFFFFF;">Deserialization</span><span style="color:#333333;background:#FFFFFF;">。</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">提供了一种叫做对象序列化的机制，他把对象表示成一连串的字节，里面包含了对象的数据，对象的类型信息，对象内部的数据的类型信息等等。因此，序列化可以看成是为了把对象存储在磁盘上或者是从磁盘上读出来并重建对象而把对象扁平化的一种方式。反序列化是把对象从扁平状态转化成活动对象的相反的步骤。</span></p> 
<p><span style="color:#333333;">91. </span><span style="color:#333333;background:#FFFFFF;">什么是</span><span style="color:#333333;background:#FFFFFF;">Servlet</span><span style="color:#333333;background:#FFFFFF;">？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">是用来处理客户端请求并产生动态网页内容的</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">类。</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">主要是用来处理或者是存储</span><span style="color:#333333;background:#D3F4EF;">HTML</span><span style="color:#333333;background:#D3F4EF;">表单提交的数据，产生动态内容，在无状态的</span><span style="color:#333333;background:#D3F4EF;">HTTP</span><span style="color:#333333;background:#D3F4EF;">协议下管理状态信息。</span></p> 
<p>servlet是基于java语言的web服务器端编程技术，是sun提供的一种实现动态网页的解决方案。servlet是运行在servlet容器中的java类，它能处理客户端的http请求并产生http响应。</p> 
<p><span style="color:#333333;">92. </span><span style="color:#333333;background:#FFFFFF;">说一下</span><span style="color:#333333;background:#FFFFFF;">Servlet</span><span style="color:#333333;background:#FFFFFF;">的体系结构。</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">所有的</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">都必须要实现的核心的接口是</span><span style="color:#333333;background:#D3F4EF;">javax.servlet.Servlet</span><span style="color:#333333;background:#D3F4EF;">。每一个</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">都必须要直接或者是间接实现这个接口，或者是继承</span><span style="color:#333333;background:#D3F4EF;">javax.servlet.GenericServlet</span><span style="color:#333333;background:#D3F4EF;">或者</span><span style="color:#333333;background:#D3F4EF;">javax.servlet.http.HTTPServlet</span><span style="color:#333333;background:#D3F4EF;">。最后，</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">使用多线程可以并行的为多个请求服务。</span></p> 
<p><span style="color:#7D7D7D;">93.</span><span style="color:#7D7D7D;background:#FFFFFF;">Applet</span><span style="color:#7D7D7D;background:#FFFFFF;">和</span><span style="color:#7D7D7D;background:#FFFFFF;">Servlet</span><span style="color:#7D7D7D;background:#FFFFFF;">有什么区别？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">Applet</span><span style="color:#333333;background:#D3F4EF;">是运行在客户端主机的浏览器上的客户端</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">程序。而</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">是运行在</span><span style="color:#333333;background:#D3F4EF;">web</span><span style="color:#333333;background:#D3F4EF;">服务器上的服务端的组件。</span><span style="color:#333333;background:#D3F4EF;">applet</span><span style="color:#333333;background:#D3F4EF;">可以使用用户界面类，而</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">没有用户界面，相反，</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">是等待客户端的</span><span style="color:#333333;background:#D3F4EF;">HTTP</span><span style="color:#333333;background:#D3F4EF;">请求，然后为请求产生响应。</span></p> 
<p><span style="color:#333333;">94. </span><span style="color:#333333;background:#FFFFFF;">GenericServlet</span><span style="color:#333333;background:#FFFFFF;">和</span><span style="color:#333333;background:#FFFFFF;">HttpServlet</span><span style="color:#333333;background:#FFFFFF;">有什么区别？</span></p> 
<p align="left"><span style="color:#333333;">GenericServlet</span><span style="color:#333333;">类实现了</span><span style="color:#333333;">Servlet</span><span style="color:#333333;">和</span><span style="color:#333333;">ServletConfig</span><span style="color:#333333;">接口。实现了除了</span><span style="color:#333333;">service()</span><span style="color:#333333;">之外的其他方法，在创建</span><span style="color:#333333;">Servlet</span><span style="color:#333333;">对象时，可以继承</span><span style="color:#333333;">GenericServlet</span><span style="color:#333333;">类来简化程序的代码，但需要实现</span><span style="color:#333333;">service()</span><span style="color:#333333;">方法。</span></p> 
<p align="left"><span style="color:#333333;">HttpServlet</span><span style="color:#333333;">类继承了</span><span style="color:#333333;">GeneriServlet</span><span style="color:#333333;">类，为实际开发中大多数用</span><span style="color:#333333;">Servlet</span><span style="color:#333333;">处理</span><span style="color:#333333;"> HTTP</span><span style="color:#333333;">请求的应用灵活的方法。</span></p> 
<p align="left"><span style="color:#333333;">       </span>链接： </p> 
<p><span style="color:#4B4B4B;">1.HttpServlet </span></p> 
<p><span style="color:#4B4B4B;">1). </span><span style="color:#4B4B4B;">是一个 Servlet, </span>继承自GenericServlet. 针对于 HTTP 协议所定制.</p> 
<p><span style="color:#4B4B4B;">2). </span><span style="color:#4B4B4B;">在 service() </span>方法中直接把ServletReuqest 和 ServletResponse 转为 HttpServletRequest 和 HttpServletResponse.<br>并调用了重载的 service(HttpServletRequest,HttpServletResponse) </p> 
<p><span style="color:#4B4B4B;">在service(HttpServletRequest, HttpServletResponse) </span>获取了请求方式: request.getMethod(). 根据请求方式有创建了<br>doXxx() 方法(xxx 为具体的请求方式, 比如 doGet, doPost) </p> 
<p><span style="color:#4B4B4B;">3). </span><span style="color:#4B4B4B;">实际开发中, </span>直接继承HttpServlet, 并根据请求方式复写 doXxx() 方法即可. </p> 
<p><span style="color:#4B4B4B;">4). </span><span style="color:#4B4B4B;">好处: </span>直接由针对性的覆盖 doXxx() 方法; 直接使用 HttpServletRequest 和 HttpServletResponse, 不再需要强转. </p> 
<p><span style="color:#4B4B4B;">  2.GenericServlet </span></p> 
<p><span style="color:#4B4B4B;">1). </span><span style="color:#4B4B4B;">是一个 Serlvet. </span>是 Servlet 接口和 ServletConfig 接口的实现类. 但是一个抽象类. 其中的 service 方法为抽象方法 </p> 
<p><span style="color:#4B4B4B;">2). </span><span style="color:#4B4B4B;">如果新建的 Servlet </span>程序直接继承GenericSerlvet 会使开发更简洁. </p> 
<p><span style="color:#4B4B4B;">3). </span><span style="color:#4B4B4B;">具体实现: </span></p> 
<p><span style="color:#4B4B4B;">①. </span><span style="color:#4B4B4B;">在 GenericServlet </span>中声明了一个SerlvetConfig 类型的成员变量, 在init(ServletConfig) 方法中对其进行了初始化 <br>②. 利用 servletConfig 成员变量的方法实现了ServletConfig 接口的方法<br>③. 还定义了一个 init() 方法, 在 init(SerlvetConfig) 方法中对其进行调用, 子类可以直接覆盖 init() 在其中实现对 Servlet 的初始化. <br>④. 不建议直接覆盖 init(ServletConfig), 因为如果忘记编写 super.init(config); 而还是用了 SerlvetConfig 接口的方法,<br>则会出现空指针异常. <br>⑤. 新建的 init(){} 并非 Serlvet 的生命周期方法. 而 init(ServletConfig) 是生命周期相关的方法.</p> 
<p align="left"><span style="color:#333333;">95. </span><span style="color:#333333;background:#FFFFFF;">解释下</span><span style="color:#333333;background:#FFFFFF;">Servlet</span><span style="color:#333333;background:#FFFFFF;">的生命周期。</span></p> 
<p align="left"><span style="color:#333333;background:#D3F4EF;">对每一个客户端的请求，</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">引擎载入</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">，调用它的</span><span style="color:#333333;background:#D3F4EF;">init()</span><span style="color:#333333;background:#D3F4EF;">方法，完成</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">的初始化。然后，</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">对象通过为每一个请求单独调用</span><span style="color:#333333;background:#D3F4EF;">service()</span><span style="color:#333333;background:#D3F4EF;">方法来处理所有随后来自客户端的请求，最后，调用</span><span style="color:#333333;background:#D3F4EF;">Servlet</span></p> 
<p align="left">Servlet程序是由WEB服务器调用，web服务器收到客户端的Servlet访问请求后： <br>①Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第②步。 <br>②装载并创建该Servlet的一个实例对象。  <br>③调用Servlet实例对象的init()方法。 <br>④创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。 <br>⑤WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。</p> 
<p><span style="color:#333333;">96. </span><span style="color:#333333;background:#FFFFFF;">doGet()</span><span style="color:#333333;background:#FFFFFF;">方法和</span><span style="color:#333333;background:#FFFFFF;">doPost()</span><span style="color:#333333;background:#FFFFFF;">方法有什么区别？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">doGet</span><span style="color:#333333;background:#D3F4EF;">：</span><span style="color:#333333;background:#D3F4EF;">GET</span><span style="color:#333333;background:#D3F4EF;">方法会把名值对追加在请求的</span><span style="color:#333333;background:#D3F4EF;">URL</span><span style="color:#333333;background:#D3F4EF;">后面。因为</span><span style="color:#333333;background:#D3F4EF;">URL</span><span style="color:#333333;background:#D3F4EF;">对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">doPOST</span></span><span style="color:#333333;background:#D3F4EF;">：</span><span style="color:#333333;background:#D3F4EF;">POST</span><span style="color:#333333;background:#D3F4EF;">方法通过把请求参数值放在请求体中来克服</span><span style="color:#333333;background:#D3F4EF;">GET</span><span style="color:#333333;background:#D3F4EF;">方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过</span><span style="color:#333333;background:#D3F4EF;">POST</span><span style="color:#333333;background:#D3F4EF;">请求传递的敏感信息对外部客户端是不可见的。</span></p> 
<p>1.get是从服务器上获取数据，post是向服务器传送数据。 2. get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTPpost机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。 3. 对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。 4. get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。 5. get安全性非常低，post安全性较高。但是执行效率却比Post方法好。 建议： 1、get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式； 2、在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；</p> 
<p><span style="color:#333333;">97. </span><span style="color:#333333;background:#FFFFFF;">什么是</span><span style="color:#333333;background:#FFFFFF;">Web</span><span style="color:#333333;background:#FFFFFF;">应用程序？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">Web</span><span style="color:#333333;background:#D3F4EF;">应用程序是对</span><span style="color:#333333;background:#D3F4EF;">Web</span><span style="color:#333333;background:#D3F4EF;">或者是应用服务器的动态扩展。有两种类型的</span><span style="color:#333333;background:#D3F4EF;">Web</span><span style="color:#333333;background:#D3F4EF;">应用：面向表现的和面向服务的。面向表现的</span><span style="color:#333333;background:#D3F4EF;">Web</span><span style="color:#333333;background:#D3F4EF;">应用程序会产生包含了很多种标记语言和动态内容的交互的</span><span style="color:#333333;background:#D3F4EF;">web</span><span style="color:#333333;background:#D3F4EF;">页面作为对请求的响应。而面向服务的</span><span style="color:#333333;background:#D3F4EF;">Web</span><span style="color:#333333;background:#D3F4EF;">应用实现了</span><span style="color:#333333;background:#D3F4EF;">Web</span><span style="color:#333333;background:#D3F4EF;">服务的端点</span><span style="color:#333333;background:#D3F4EF;">(endpoint)</span><span style="color:#333333;background:#D3F4EF;">。一般来说，一个</span><span style="color:#333333;background:#D3F4EF;">Web</span><span style="color:#333333;background:#D3F4EF;">应用可以看成是一组安装在服务器</span><span style="color:#333333;background:#D3F4EF;">URL</span><span style="color:#333333;background:#D3F4EF;">名称空间的特定子集下面的</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">的集合。</span></p> 
<p>Web应用程序是一种可以通过Web访问的应用程序。Web应用程序的一个最大好处是用户很容易访问应用程序。用户只需要有浏览器即可，不需要再安装其他软件。一个Web应用程序是由完成特定任务的各种Web组件（web components)构成的并通过Web将服务展示给外界。在实际应用中，Web应用程序是由多个Servlet、JSP页面、HTML文件以及图像文件等组成。所有这些组件相互协调为用户提供一组完整的服务。</p> 
<p><span style="color:#333333;">98. </span><span style="color:#333333;background:#FFFFFF;">什么是服务端包含</span><span style="color:#333333;background:#FFFFFF;">(Server SideInclude)</span><span style="color:#333333;background:#FFFFFF;">？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">服务端包含</span><span style="color:#333333;background:#D3F4EF;">(SSI)</span><span style="color:#333333;background:#D3F4EF;">是一种简单的解释型服务端脚本语言，大多数时候仅用在</span><span style="color:#333333;background:#D3F4EF;">Web</span><span style="color:#333333;background:#D3F4EF;">上，用</span><span style="color:#333333;background:#D3F4EF;">servlet</span><span style="color:#333333;background:#D3F4EF;">标签嵌入进来。</span><span style="color:#333333;background:#D3F4EF;">SSI</span><span style="color:#333333;background:#D3F4EF;">最常用的场景把一个或多个文件包含到</span><span style="color:#333333;background:#D3F4EF;">Web</span><span style="color:#333333;background:#D3F4EF;">服务器的一个</span><span style="color:#333333;background:#D3F4EF;">Web</span><span style="color:#333333;background:#D3F4EF;">页面中。当浏览器访问</span><span style="color:#333333;background:#D3F4EF;">Web</span><span style="color:#333333;background:#D3F4EF;">页面的时候，</span><span style="color:#333333;background:#D3F4EF;">Web</span><span style="color:#333333;background:#D3F4EF;">服务器会用对应的</span><span style="color:#333333;background:#D3F4EF;">servlet</span><span style="color:#333333;background:#D3F4EF;">产生的文本来替换</span><span style="color:#333333;background:#D3F4EF;">Web</span><span style="color:#333333;background:#D3F4EF;">页面中的</span><span style="color:#333333;background:#D3F4EF;">servlet</span><span style="color:#333333;background:#D3F4EF;">标签。</span></p> 
<p><span style="color:#333333;">99. </span><span style="color:#333333;background:#FFFFFF;">什么是</span><span style="color:#333333;background:#FFFFFF;">Servlet</span><span style="color:#333333;background:#FFFFFF;">链</span><span style="color:#333333;background:#FFFFFF;">(Servlet Chaining)</span><span style="color:#333333;background:#FFFFFF;">？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">链是把一个</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">的输出发送给另一个</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">的方法。第二个</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">的输出可以发送给第三个</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">，依次类推。链条上最后一个</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">负责把响应发送给客户端。</span></p> 
<p><span style="color:#333333;">100.         </span><span style="color:#333333;background:#FFFFFF;">如何知道是哪一个客户端的机器正在请求你的</span><span style="color:#333333;background:#FFFFFF;">Servlet</span><span style="color:#333333;background:#FFFFFF;">？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">ServletRequest</span><span style="color:#333333;background:#D3F4EF;">类可以找出客户端机器的</span><span style="color:#333333;background:#D3F4EF;">IP</span><span style="color:#333333;background:#D3F4EF;">地址或者是主机名。</span><span style="color:#333333;background:#D3F4EF;">getRemoteAddr()</span><span style="color:#333333;background:#D3F4EF;">方法获取客户端主机的</span><span style="color:#333333;background:#D3F4EF;">IP</span><span style="color:#333333;background:#D3F4EF;">地址，</span><span style="color:#333333;background:#D3F4EF;">getRemoteHost()</span><span style="color:#333333;background:#D3F4EF;">可以获取主机名。</span></p> 
<p><span style="color:#333333;">101.         </span><span style="color:#333333;background:#FFFFFF;">HTTP</span><span style="color:#333333;background:#FFFFFF;">响应的结构是怎么样的？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">HTTP</span><span style="color:#333333;background:#D3F4EF;">响应由三个部分组成：</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">状态码</span><span style="color:#333333;background:#D3F4EF;">(Status Code)</span><span style="color:#333333;background:#D3F4EF;">：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">没有返回状态码，默认会返回成功的状态码</span><span style="color:#333333;background:#D3F4EF;">HttpServletResponse.SC_OK</span><span style="color:#333333;background:#D3F4EF;">。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">HTTP</span></span><span style="color:#333333;background:#D3F4EF;">头部</span><span style="color:#333333;background:#D3F4EF;">(HTTPHeader)</span><span style="color:#333333;background:#D3F4EF;">：它们包含了更多关于响应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。如何在</span><span style="color:#333333;background:#D3F4EF;">Serlet</span><span style="color:#333333;background:#D3F4EF;">中检索</span><span style="color:#333333;background:#D3F4EF;">HTTP</span><span style="color:#333333;background:#D3F4EF;">的头部看这里。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">主体</span><span style="color:#333333;background:#D3F4EF;">(Body)</span><span style="color:#333333;background:#D3F4EF;">：它包含了响应的内容。它可以包含</span><span style="color:#333333;background:#D3F4EF;">HTML</span><span style="color:#333333;background:#D3F4EF;">代码，图片，等等。主体是由传输在</span><span style="color:#333333;background:#D3F4EF;">HTTP</span><span style="color:#333333;background:#D3F4EF;">消息中紧跟在头部后面的数据字节组成的。</span></p> 
<p>HTTP的请求报文的组成：<br>请求方法 + 请求的资源的URI + 协议版本 + 可选的请求首部字段 + 内容实体。<br>HTTP的响应报文的组成：<br>协议版本 + 状态码 + 用于解释状态码的原因短语 + 可选的响应首部字段 + 实体主体。</p> 
<p><span style="color:#333333;">102.         </span><span style="color:#333333;background:#FFFFFF;">什么是</span><span style="color:#333333;background:#FFFFFF;">cookie</span><span style="color:#333333;background:#FFFFFF;">？</span><span style="color:#333333;background:#FFFFFF;">session</span><span style="color:#333333;background:#FFFFFF;">和</span><span style="color:#333333;background:#FFFFFF;">cookie</span><span style="color:#333333;background:#FFFFFF;">有什么区别？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">cookie</span><span style="color:#333333;background:#D3F4EF;">是</span><span style="color:#333333;background:#D3F4EF;">Web</span><span style="color:#333333;background:#D3F4EF;">服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个</span><span style="color:#333333;background:#D3F4EF;">Web</span><span style="color:#333333;background:#D3F4EF;">服务器存储</span><span style="color:#333333;background:#D3F4EF;">cookie</span><span style="color:#333333;background:#D3F4EF;">。以后浏览器在给特定的</span><span style="color:#333333;background:#D3F4EF;">Web</span><span style="color:#333333;background:#D3F4EF;">服务器发请求的时候，同时会发送所有为该服务器存储的</span><span style="color:#333333;background:#D3F4EF;">cookie</span><span style="color:#333333;background:#D3F4EF;">。下面列出了</span><span style="color:#333333;background:#D3F4EF;">session</span><span style="color:#333333;background:#D3F4EF;">和</span><span style="color:#333333;background:#D3F4EF;">cookie</span><span style="color:#333333;background:#D3F4EF;">的区别：</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">无论客户端浏览器做怎么样的设置，</span><span style="color:#333333;background:#D3F4EF;">session</span><span style="color:#333333;background:#D3F4EF;">都应该能正常工作。客户端可以选择禁用</span><span style="color:#333333;background:#D3F4EF;">cookie</span><span style="color:#333333;background:#D3F4EF;">，但是，</span><span style="color:#333333;background:#D3F4EF;">session</span><span style="color:#333333;background:#D3F4EF;">仍然是能够工作的，因为客户端无法禁用服务端的</span><span style="color:#333333;background:#D3F4EF;">session</span><span style="color:#333333;background:#D3F4EF;">。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">在存储的数据量方面</span><span style="color:#333333;background:#D3F4EF;">session</span><span style="color:#333333;background:#D3F4EF;">和</span><span style="color:#333333;background:#D3F4EF;">cookies</span><span style="color:#333333;background:#D3F4EF;">也是不一样的。</span><span style="color:#333333;background:#D3F4EF;">session</span><span style="color:#333333;background:#D3F4EF;">能够存储任意的</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">对象，</span><span style="color:#333333;background:#D3F4EF;">cookie</span><span style="color:#333333;background:#D3F4EF;">只能存储</span><span style="color:#333333;background:#D3F4EF;">String</span><span style="color:#333333;background:#D3F4EF;">类型的对象。</span></p> 
<p>cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户的状态，就使用response向客户端浏览器颁发一个cookie。客户端浏览器会把cookie保存起来。当浏览器再次请求该网站时，浏览器就会把请求地址和cookie一同给服务器。服务器检查该cookie，从而判断用户的状态。服务器还可以根据需要修改cookie的内容。 session是另一种记录客户状态的机制。不同的是cookie保存在客户端浏览器中，而session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了。如果说cookie机制是通过检查客户身上的“通信证”，那么session机制就是通过检查服务器上的“客户明细表”来确认客户身份。</p> 
<p><span style="color:#333333;">103.         </span><span style="color:#333333;background:#FFFFFF;">浏览器和</span><span style="color:#333333;background:#FFFFFF;">Servlet</span><span style="color:#333333;background:#FFFFFF;">通信使用的是什么协议？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">浏览器和</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">通信使用的是</span><span style="color:#333333;background:#D3F4EF;">HTTP</span><span style="color:#333333;background:#D3F4EF;">协议。</span></p> 
<p><span style="color:#333333;">104.         </span><span style="color:#333333;background:#FFFFFF;">什么是</span><span style="color:#333333;background:#FFFFFF;">HTTP</span><span style="color:#333333;background:#FFFFFF;">隧道？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">HTTP</span><span style="color:#333333;background:#D3F4EF;">隧道是一种利用</span><span style="color:#333333;background:#D3F4EF;">HTTP</span><span style="color:#333333;background:#D3F4EF;">或者是</span><span style="color:#333333;background:#D3F4EF;">HTTPS</span><span style="color:#333333;background:#D3F4EF;">把多种网络协议封装起来进行通信的技术。因此，</span><span style="color:#333333;background:#D3F4EF;">HTTP</span><span style="color:#333333;background:#D3F4EF;">协议扮演了一个打通用于通信的网络协议的管道的包装器的角色。把其他协议的请求掩盖成</span><span style="color:#333333;background:#D3F4EF;">HTTP</span><span style="color:#333333;background:#D3F4EF;">的请求就是</span><span style="color:#333333;background:#D3F4EF;">HTTP</span><span style="color:#333333;background:#D3F4EF;">隧道。</span></p> 
<p><span style="color:#333333;">105.         </span><span style="color:#333333;background:#FFFFFF;">sendRedirect()</span><span style="color:#333333;background:#FFFFFF;">和</span><span style="color:#333333;background:#FFFFFF;">forward()</span><span style="color:#333333;background:#FFFFFF;">方法有什么区别？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">sendRedirect()</span><span style="color:#333333;background:#D3F4EF;">方法会创建一个新的请求，而</span><span style="color:#333333;background:#D3F4EF;">forward()</span><span style="color:#333333;background:#D3F4EF;">方法只是把请求转发到一个新的目标上。重定向</span><span style="color:#333333;background:#D3F4EF;">(redirect)</span><span style="color:#333333;background:#D3F4EF;">以后，之前请求作用域范围以内的对象就失效了，因为会产生一个新的请求，而转发</span><span style="color:#333333;background:#D3F4EF;">(forwarding)</span><span style="color:#333333;background:#D3F4EF;">以后，之前请求作用域范围以内的对象还是能访问的。一般认为</span><span style="color:#333333;background:#D3F4EF;">sendRedirect()</span><span style="color:#333333;background:#D3F4EF;">比</span><span style="color:#333333;background:#D3F4EF;">forward()</span><span style="color:#333333;background:#D3F4EF;">要慢。</span></p> 
<p>forward是服务器内部的跳转，浏览器的地址栏不会发生变化，同时可以把request和response传递给后一个请求。sendRedirect()是浏览器方面的跳转，要发送两次请求，地址栏也会发生变化，同时request和response也会发生变化，重新生成新的对象。</p> 
<p><span style="color:#333333;">106.         </span><span style="color:#333333;background:#FFFFFF;">什么是</span><span style="color:#333333;background:#FFFFFF;">URL</span><span style="color:#333333;background:#FFFFFF;">编码和</span><span style="color:#333333;background:#FFFFFF;">URL</span><span style="color:#333333;background:#FFFFFF;">解码？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">URL</span><span style="color:#333333;background:#D3F4EF;">编码是负责把</span><span style="color:#333333;background:#D3F4EF;">URL</span><span style="color:#333333;background:#D3F4EF;">里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。</span></p> 
<p><span style="color:#555555;">URL</span><span style="color:#555555;">编码指的是对网址上的不安全的字符，例如中文，进行编码，编码后的中文方便在网络上传输。</span></p> 
<p>可以使用URLEncoder.encoder(<span style="color:#555555;">String url,String encoder)</span><span style="color:#555555;">方法进行</span><span style="color:#555555;">url</span><span style="color:#555555;">编码</span><span style="color:#555555;">;</span> </p> 
<p><span style="color:#555555;">使用</span><span style="color:#555555;">URLDecoder.decode(String url,String encoder)</span><span style="color:#555555;">方法是进行</span><span style="color:#555555;">URL</span><span style="color:#555555;">解码</span></p> 
<p><span style="color:#333333;">107.         </span><span style="color:#333333;background:#FFFFFF;">什么是</span><span style="color:#333333;background:#FFFFFF;">JSP</span><span style="color:#333333;background:#FFFFFF;">页面？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">页面是一种包含了静态数据和</span><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">元素两种类型的文本的文本文档。静态数据可以用任何基于文本的格式来表示，比如：</span><span style="color:#333333;background:#D3F4EF;">HTML</span><span style="color:#333333;background:#D3F4EF;">或者</span><span style="color:#333333;background:#D3F4EF;">XML</span><span style="color:#333333;background:#D3F4EF;">。</span><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">是一种混合了静态内容和动态产生的内容的技术。</span></p> 
<p>jsp是java开发的专门用于动态显示页面的技术。jsp编译时，会首先编译成servlet文件，然后编译成class文件。包含9大内置对象：response、request、exception、out、application、pagecontext、config、session、page。有四个域对象：request、pagecontext、session、application</p> 
<p><span style="color:#333333;">108.         </span><span style="color:#333333;background:#FFFFFF;">JSP</span><span style="color:#333333;background:#FFFFFF;">请求是如何被处理的？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">浏览器首先要请求一个以</span><span style="color:#333333;background:#D3F4EF;">.jsp</span><span style="color:#333333;background:#D3F4EF;">扩展名结尾的页面，发起</span><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">请求，然后，</span><span style="color:#333333;background:#D3F4EF;">Web</span><span style="color:#333333;background:#D3F4EF;">服务器读取这个请求，使用</span><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">编译器把</span><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">页面转化成一个</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">类。需要注意的是，只有当第一次请求页面或者是</span><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">文件发生改变的时候</span><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">文件才会被编译，然后服务器调用</span><span style="color:#333333;background:#D3F4EF;">servlet</span><span style="color:#333333;background:#D3F4EF;">类，处理浏览器的请求。一旦请求执行结束，</span><span style="color:#333333;background:#D3F4EF;">servlet</span><span style="color:#333333;background:#D3F4EF;">会把响应发送给客户端。</span></p> 
<p>客户端通过浏览器发送jsp请求，服务器端接受到请求后，判断是否是第一次请求该页面，或者该页面是否改变，若是，服务器将jsp页面翻译为servlet，jvm将servlet编译为.class文件，字节码文件加载到服务器内存上执行，服务器将处理结果以.html页面的形式返回给客户端，若该页面不是第一次请求，则省略翻译和编译的步骤，直接执行。</p> 
<p><span style="color:#333333;">109.         </span><span style="color:#333333;background:#FFFFFF;">JSP</span><span style="color:#333333;background:#FFFFFF;">有什么优点？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">下面列出了使用</span><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">的优点：</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">JSP</span></span><span style="color:#333333;background:#D3F4EF;">页面是被动态编译成</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">的，因此，开发者可以很容易的更新展现代码。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">JSP</span></span><span style="color:#333333;background:#D3F4EF;">页面可以被预编译。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">JSP</span></span><span style="color:#333333;background:#D3F4EF;">页面可以很容易的和静态模板结合，包括：</span><span style="color:#333333;background:#D3F4EF;">HTML</span><span style="color:#333333;background:#D3F4EF;">或者</span><span style="color:#333333;background:#D3F4EF;">XML</span><span style="color:#333333;background:#D3F4EF;">，也可以很容易的和产生动态内容的代码结合起来。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">开发者可以提供让页面设计者以类</span><span style="color:#333333;background:#D3F4EF;">XML</span><span style="color:#333333;background:#D3F4EF;">格式来访问的自定义的</span><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">标签库。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">开发者可以在组件层做逻辑上的改变，而不需要编辑单独使用了应用层逻辑的页面。</span></p> 
<p><span style="color:#333333;">110.         </span><span style="color:#333333;background:#FFFFFF;">什么是</span><span style="color:#333333;background:#FFFFFF;">JSP</span><span style="color:#333333;background:#FFFFFF;">指令</span><span style="color:#333333;background:#FFFFFF;">(Directive)</span><span style="color:#333333;background:#FFFFFF;">？</span><span style="color:#333333;background:#FFFFFF;">JSP</span><span style="color:#333333;background:#FFFFFF;">中有哪些不同类型的指令？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">Directive</span><span style="color:#333333;background:#D3F4EF;">是当</span><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">页面被编译成</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">的时候，</span><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">引擎要处理的指令。</span><span style="color:#333333;background:#D3F4EF;">Directive</span><span style="color:#333333;background:#D3F4EF;">用来设置页面级别的指令，从外部文件插入数据，指定自定义的标签库。</span><span style="color:#333333;background:#D3F4EF;">Directive</span><span style="color:#333333;background:#D3F4EF;">是定义在</span><span style="color:#333333;background:#D3F4EF;"> &lt;%@ </span><span style="color:#333333;background:#D3F4EF;">和</span><span style="color:#333333;background:#D3F4EF;"> %&gt;</span><span style="color:#333333;background:#D3F4EF;">之间的。下面列出了不同类型的</span><span style="color:#333333;background:#D3F4EF;">Directive</span><span style="color:#333333;background:#D3F4EF;">：</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">包含指令</span><span style="color:#333333;background:#D3F4EF;">(Include directive)</span><span style="color:#333333;background:#D3F4EF;">：用来包含文件和合并文件内容到当前的页面。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">页面指令</span><span style="color:#333333;background:#D3F4EF;">(Page directive)</span><span style="color:#333333;background:#D3F4EF;">：用来定义</span><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">页面中特定的属性，比如错误页面和缓冲区。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">Taglib</span></span><span style="color:#333333;background:#D3F4EF;">指令：</span><span style="color:#333333;background:#D3F4EF;">用来声明页面中使用的自定义的标签库。</span></p> 
<p><span style="color:#333333;">111.         </span><span style="color:#333333;background:#FFFFFF;">什么是</span><span style="color:#333333;background:#FFFFFF;">JSP</span><span style="color:#333333;background:#FFFFFF;">动作</span><span style="color:#333333;background:#FFFFFF;">(JSP action)</span><span style="color:#333333;background:#FFFFFF;">？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">动作以</span><span style="color:#333333;background:#D3F4EF;">XML</span><span style="color:#333333;background:#D3F4EF;">语法的结构来控制</span><span style="color:#333333;background:#D3F4EF;">Servlet</span><span style="color:#333333;background:#D3F4EF;">引擎的行为。当</span><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">页面被请求的时候，</span><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">动作会被执行。它们可以被动态的插入到文件中，重用</span><span style="color:#333333;background:#D3F4EF;">JavaBean</span><span style="color:#333333;background:#D3F4EF;">组件，转发用户到其他的页面，或者是给</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">插件产生</span><span style="color:#333333;background:#D3F4EF;">HTML</span><span style="color:#333333;background:#D3F4EF;">代码。下面列出了可用的动作：</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">jsp:include-</span></span><span style="color:#333333;background:#D3F4EF;">当</span><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">页面被请求的时候包含一个文件。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">jsp:useBean-</span></span><span style="color:#333333;background:#D3F4EF;">找出或者是初始化</span><span style="color:#333333;background:#D3F4EF;">Javabean</span><span style="color:#333333;background:#D3F4EF;">。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">jsp:setProperty-</span></span><span style="color:#333333;background:#D3F4EF;">设置</span><span style="color:#333333;background:#D3F4EF;">JavaBean</span><span style="color:#333333;background:#D3F4EF;">的属性。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">jsp:getProperty-</span></span><span style="color:#333333;background:#D3F4EF;">获取</span><span style="color:#333333;background:#D3F4EF;">JavaBean</span><span style="color:#333333;background:#D3F4EF;">的属性。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">jsp:forward-</span></span><span style="color:#333333;background:#D3F4EF;">把请求转发到新的页面。</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">jsp:plugin-</span></span><span style="color:#333333;background:#D3F4EF;">产生特定浏览器的代码。</span></p> 
<p><span style="color:#333333;">112.         </span><span style="color:#333333;background:#FFFFFF;">什么是</span><span style="color:#333333;background:#FFFFFF;">Scriptlets</span><span style="color:#333333;background:#FFFFFF;">？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">技术中，</span><span style="color:#333333;background:#D3F4EF;">scriptlet</span><span style="color:#333333;background:#D3F4EF;">是嵌入在</span><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">页面中的一段</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">代码。</span><span style="color:#333333;background:#D3F4EF;">scriptlet</span><span style="color:#333333;background:#D3F4EF;">是位于标签内部的所有的东西，在标签与标签之间，用户可以添加任意有效的</span><span style="color:#333333;background:#D3F4EF;">scriplet</span><span style="color:#333333;background:#D3F4EF;">。</span></p> 
<p><strong>指jsp页面里&lt;%    %&gt; 中间的代码。 </strong></p> 
<p>一个包含任何在JSP页面中合法的脚本语言的代码片断的JSP脚本元素。Java Web开发时，尽量不要在JSP中出现这种Scriptlets，尽量多使用JSP标签，或者JSTL，或者一些框架的标签。</p> 
<p><span style="color:#333333;">113.         </span><span style="color:#333333;background:#FFFFFF;">声明</span><span style="color:#333333;background:#FFFFFF;">(Decalaration)</span><span style="color:#333333;background:#FFFFFF;">在哪里？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">声明跟</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">中的变量声明很相似，它用来声明随后要被表达式或者</span><span style="color:#333333;background:#D3F4EF;">scriptlet</span><span style="color:#333333;background:#D3F4EF;">使用的变量。添加的声明必须要用开始和结束标签包起来。</span></p> 
<p>1.有一个类Test,然后Test test;这句就是声明test是Test的对象，可以在后面需要的时候进行初始化，初始化的方法也有多种，比如test = new Test(); </p> 
<p>2.如果是基本数据类型的话，声明和定义是同时生成的。</p> 
<p>3.声明的作用就是为了告诉编译器，这个名字我已经给他分配了内存，是我先预订的，其他地方不能再用它作为变量名了 </p> 
<p><span style="color:#333333;">114.         </span><span style="color:#333333;background:#FFFFFF;">什么是表达式</span><span style="color:#333333;background:#FFFFFF;">(Expression)</span><span style="color:#333333;background:#FFFFFF;">？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">【列表很长，可以分上、中、下发布】</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">JSP</span></span><span style="color:#333333;background:#D3F4EF;">表达式是</span><span style="color:#333333;background:#D3F4EF;">Web</span><span style="color:#333333;background:#D3F4EF;">服务器把脚本语言表达式的值转化成一个</span><span style="color:#333333;background:#D3F4EF;">String</span><span style="color:#333333;background:#D3F4EF;">对象，插入到返回给客户端的数据流中。表达式是在</span><span style="color:#333333;background:#D3F4EF;">&lt;%=</span><span style="color:#333333;background:#D3F4EF;">和</span><span style="color:#333333;background:#D3F4EF;">%&gt;</span><span style="color:#333333;background:#D3F4EF;">这两个标签之间定义的。</span></p> 
<p><span style="color:#333333;">115.         </span><span style="color:#333333;background:#FFFFFF;">隐含对象是什么意思？有哪些隐含对象？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">隐含对象是页面中的一些</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">对象，</span><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">容器让这些</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">对象可以为开发者所使用。开发者不用明确的声明就可以直接使用他们。</span><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">隐含对象也叫做预定义变量。下面列出了</span><span style="color:#333333;background:#D3F4EF;">JSP</span><span style="color:#333333;background:#D3F4EF;">页面中的隐含对象：</span><span style="color:#333333;"><br><span style="background:#D3F4EF;">application</span></span><br><span style="background:#D3F4EF;">page</span><br><span style="background:#D3F4EF;">request</span><br><span style="background:#D3F4EF;">response</span><br><span style="background:#D3F4EF;">session</span><br><span style="background:#D3F4EF;">exception</span><br><span style="background:#D3F4EF;">out</span><br><span style="background:#D3F4EF;">config</span><br><span style="background:#D3F4EF;">pageContext</span></p> 
<p><span style="color:#333333;">116.         </span><span style="color:#333333;background:#FFFFFF;">面向对象软件开发的优点有哪些？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">代码开发模块化，更易维护和修改。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">代码复用。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">增强代码的可靠性和灵活性。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">增加代码的可理解性。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象。</span></p> 
<p>* 封装：通过关键字将类中的成员变量，成员方法设置访问权限，保证了代码的安全性，提高代码的可复用性，在实际开发时 * 站在使用者的角度封装，当其他人调用该方法时通过方法名就可以明白方法所执行的任务，可简化开发的复杂性。 * 继承：子类对父类有很强的耦合度，一般在开发web项目，可以将对数据库操作的crud封装成一个公用的父类，供项目中各模块调用，提高代码的复用性。 * 多态:他的本质是由子类的重载和重写实现，在web开发中使用面向接口编程提高了项目的可扩展性，接口只需要提供功能，具体的实现让他的子类去做。</p> 
<p><span style="color:#333333;">117.         </span><span style="color:#333333;background:#FFFFFF;">封装的定义和好处有哪些？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">当中，有</span><span style="color:#333333;background:#D3F4EF;">3</span><span style="color:#333333;background:#D3F4EF;">种修饰符：</span><span style="color:#333333;background:#D3F4EF;">public</span><span style="color:#333333;background:#D3F4EF;">，</span><span style="color:#333333;background:#D3F4EF;">private</span><span style="color:#333333;background:#D3F4EF;">和</span><span style="color:#333333;background:#D3F4EF;">protected</span><span style="color:#333333;background:#D3F4EF;">。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">下面列出了使用封装的一些好处：</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">通过隐藏对象的属性来保护对象内部的状态。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">禁止对象之间的不良交互提高模块化。</span></p> 
<p><span style="color:#333333;">118.         </span><span style="color:#333333;background:#FFFFFF;">多态的定义？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。</span></p> 
<p>多态：相同类型的引用变量，调用同一个方法时呈现出多种不同的行为特征。 </p> 
<p>对象的实例变量不具备多态性。 </p> 
<p>Java引用变量有两个类型：编译时类型，运行时类型</p> 
<p>编译时类型由声明该变量时使用的类型决定 </p> 
<p>运行时类型由实际赋给该变量的对象决定 </p> 
<p>如果编译时类型和运行时类型不一致，就可能出现多态（Polymorphism）</p> 
<p><span style="color:#333333;">119.         </span><span style="color:#333333;background:#FFFFFF;">继承的定义？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#666666;">继承是一种类与类之间的关系</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#666666;">利用一个已经存在的类，快速的创建新的类的机制</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#666666;">被继承的类称为父类</span><span style="color:#666666;">/</span><span style="color:#666666;">超类，继承者称为子类（得到继承的类为子类）</span></p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#666666;">子类继承父类，拥有父类所有属性和方法</span></p> 
<p><span style="color:#333333;">120.         </span><span style="color:#333333;background:#FFFFFF;">抽象的定义？抽象和封装的不同点？</span></p> 
<p><span style="color:#333333;background:#D3F4EF;">抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。</span><span style="color:#333333;background:#D3F4EF;">Java</span><span style="color:#333333;background:#D3F4EF;">支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</span><span style="color:#333333;"><br></span><span style="color:#333333;background:#D3F4EF;">抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略。</span></p> 
<p><span style="color:#333333;background:#FFFFFF;"> </span></p> 
<p> </p> 
<p align="left" style="background:#FFFFFF;"><span style="color:#666666;"> </span></p> 
<p align="left"> </p> 
<p align="left"> </p> 
<br> 
<br>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3c97572008ce6332173c8d90b27083a7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2018全球大学AI排名发布，中国高校表现强势！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e3f11725b076857d3bb26627ef3ecb33/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java内部类</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>