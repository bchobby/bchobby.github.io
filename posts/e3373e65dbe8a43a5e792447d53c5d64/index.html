<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python 并发编程 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python 并发编程" />
<meta property="og:description" content="目录
一. 为什么需要引入并发编程呢？
二. 怎么样选择多线程，多进程和多协程？
1. CPU 密集型与 I/O 密集型
2. 多线程，多进程和多协程的对比
三. python 的全局解释器锁（GIL）
1. python 速度慢的两大原因
2. GIL 是什么？
3. 为什么会有GIL 这个东西？
4. 怎么样规避GIL 带来的限制？
四. 使用多线程加速python spider
1. python 创建线程的方法；
2. 改写spider程序，变成多线程爬取；
五. 生产消费者spider
1. 多组件的Pipeline 技术架构
2. 生产者消费者的爬虫架构
3. 生产者消费者爬虫
六. python 线程安全问题以及解决方案
1. 线程安全的概念
2. python 可以使用 Lock 类来解决线程安全问题
七. python 线程池 ThreadPoolExecutor
1. 线程池的原理
2. 使用线程池的好处
3. ThreadPoolExecutor 的使用，使用线程池改造爬虫程序
八. 在web 服务中使用线程池加速
1. web 服务的架构以及特点" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/e3373e65dbe8a43a5e792447d53c5d64/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-11T15:29:46+08:00" />
<meta property="article:modified_time" content="2022-05-11T15:29:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python 并发编程</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BC%95%E5%85%A5%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%91%A2%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%B8%80.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BC%95%E5%85%A5%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%91%A2%EF%BC%9F" rel="nofollow">一. 为什么需要引入并发编程呢？</a></p> 
<p id="%E4%BA%8C.%20%E6%80%8E%E4%B9%88%E6%A0%B7%E9%80%89%E6%8B%A9%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E5%8D%8F%E7%A8%8B%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%BA%8C.%20%E6%80%8E%E4%B9%88%E6%A0%B7%E9%80%89%E6%8B%A9%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E5%8D%8F%E7%A8%8B%EF%BC%9F" rel="nofollow">二. 怎么样选择多线程，多进程和多协程？</a></p> 
<p id="1.%20CPU%20%E5%AF%86%E9%9B%86%E5%9E%8B%E4%B8%8E%20I%2FO%20%E5%AF%86%E9%9B%86%E5%9E%8B-toc" style="margin-left:40px;"><a href="#1.%20CPU%20%E5%AF%86%E9%9B%86%E5%9E%8B%E4%B8%8E%20I%2FO%20%E5%AF%86%E9%9B%86%E5%9E%8B" rel="nofollow">1. CPU 密集型与 I/O 密集型</a></p> 
<p id="2.%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AF%B9%E6%AF%94-toc" style="margin-left:40px;"><a href="#2.%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AF%B9%E6%AF%94" rel="nofollow">2. 多线程，多进程和多协程的对比</a></p> 
<p id="%E4%B8%89.%20python%20%E7%9A%84%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81%EF%BC%88GIL%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E4%B8%89.%20python%20%E7%9A%84%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81%EF%BC%88GIL%EF%BC%89" rel="nofollow">三. python 的全局解释器锁（GIL）</a></p> 
<p id="1.%C2%A0python%20%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E4%B8%A4%E5%A4%A7%E5%8E%9F%E5%9B%A0-toc" style="margin-left:40px;"><a href="#1.%C2%A0python%20%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E4%B8%A4%E5%A4%A7%E5%8E%9F%E5%9B%A0" rel="nofollow">1. python 速度慢的两大原因</a></p> 
<p id="2.%20GIL%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px;"><a href="#2.%20GIL%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">2. GIL 是什么？</a></p> 
<p id="3.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89GIL%20%E8%BF%99%E4%B8%AA%E4%B8%9C%E8%A5%BF%EF%BC%9F-toc" style="margin-left:40px;"><a href="#3.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89GIL%20%E8%BF%99%E4%B8%AA%E4%B8%9C%E8%A5%BF%EF%BC%9F" rel="nofollow">3. 为什么会有GIL 这个东西？</a></p> 
<p id="4.%20%E6%80%8E%E4%B9%88%E6%A0%B7%E8%A7%84%E9%81%BFGIL%20%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%99%90%E5%88%B6%EF%BC%9F-toc" style="margin-left:40px;"><a href="#4.%20%E6%80%8E%E4%B9%88%E6%A0%B7%E8%A7%84%E9%81%BFGIL%20%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%99%90%E5%88%B6%EF%BC%9F" rel="nofollow">4. 怎么样规避GIL 带来的限制？</a></p> 
<p id="%E5%9B%9B.%20%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%80%9Fpython%20%E7%88%AC%E8%99%AB-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.%20%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%80%9Fpython%20%E7%88%AC%E8%99%AB" rel="nofollow">四. 使用多线程加速python spider</a></p> 
<p id="1.%20python%20%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9B-toc" style="margin-left:40px;"><a href="#1.%20python%20%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9B" rel="nofollow">1. python 创建线程的方法；</a></p> 
<p id="2.%20%E6%94%B9%E5%86%99%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%8F%98%E6%88%90%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E5%8F%96%EF%BC%9B-toc" style="margin-left:40px;"><a href="#2.%20%E6%94%B9%E5%86%99%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%8F%98%E6%88%90%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E5%8F%96%EF%BC%9B" rel="nofollow">2. 改写spider程序，变成多线程爬取；</a></p> 
<p id="%E4%BA%94.%20%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85%E7%88%AC%E8%99%AB-toc" style="margin-left:0px;"><a href="#%E4%BA%94.%20%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85%E7%88%AC%E8%99%AB" rel="nofollow">五. 生产消费者spider</a></p> 
<p id="1.%20%E5%A4%9A%E7%BB%84%E4%BB%B6%E7%9A%84Pipeline%20%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84-toc" style="margin-left:40px;"><a href="#1.%20%E5%A4%9A%E7%BB%84%E4%BB%B6%E7%9A%84Pipeline%20%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84" rel="nofollow">1. 多组件的Pipeline 技术架构</a></p> 
<p id="2.%20%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E7%88%AC%E8%99%AB%E6%9E%B6%E6%9E%84-toc" style="margin-left:40px;"><a href="#2.%20%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E7%88%AC%E8%99%AB%E6%9E%B6%E6%9E%84" rel="nofollow">2. 生产者消费者的爬虫架构</a></p> 
<p id="3.%20%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E7%88%AC%E8%99%AB-toc" style="margin-left:40px;"><a href="#3.%20%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E7%88%AC%E8%99%AB" rel="nofollow">3. 生产者消费者爬虫</a></p> 
<p id="%E5%85%AD.%20python%20%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-toc" style="margin-left:0px;"><a href="#%E5%85%AD.%20python%20%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" rel="nofollow">六. python 线程安全问题以及解决方案</a></p> 
<p id="1.%20%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.%20%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">1. 线程安全的概念</a></p> 
<p id="2.%20python%20%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20Lock%20%E7%B1%BB%E6%9D%A5%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#2.%20python%20%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20Lock%20%E7%B1%BB%E6%9D%A5%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98" rel="nofollow">2. python 可以使用 Lock 类来解决线程安全问题</a></p> 
<p id="%E4%B8%83.%20Python%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%20ThreadPoolExecutor-toc" style="margin-left:0px;"><a href="#%E4%B8%83.%20Python%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%20ThreadPoolExecutor" rel="nofollow">七. python 线程池 ThreadPoolExecutor</a></p> 
<p id="1.%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#1.%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86" rel="nofollow">1. 线程池的原理</a></p> 
<p id="2.%20%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84-toc" style="margin-left:40px;"><a href="#2.%20%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84" rel="nofollow">2. 使用线程池的好处</a></p> 
<p id="3.%20ThreadPoolExecutor%20%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%94%B9%E9%80%A0%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F-toc" style="margin-left:40px;"><a href="#3.%20ThreadPoolExecutor%20%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%94%B9%E9%80%A0%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F" rel="nofollow">3. ThreadPoolExecutor 的使用，使用线程池改造爬虫程序</a></p> 
<p id="%E5%85%AB.%20%E5%9C%A8web%20%E6%9C%8D%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8A%A0%E9%80%9F-toc" style="margin-left:0px;"><a href="#%E5%85%AB.%20%E5%9C%A8web%20%E6%9C%8D%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8A%A0%E9%80%9F" rel="nofollow">八. 在web 服务中使用线程池加速</a></p> 
<p id="1.%20web%20%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8A%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#1.%20web%20%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8A%E7%89%B9%E7%82%B9" rel="nofollow">1. web 服务的架构以及特点</a></p> 
<p id="2.%20%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%20%E5%8A%A0%E9%80%9F-toc" style="margin-left:40px;"><a href="#2.%20%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%20%E5%8A%A0%E9%80%9F" rel="nofollow">2. 使用线程池ThreadPoolExecutor 加速</a></p> 
<p id="3.%20%E4%BB%A3%E7%A0%81%E7%94%A8Flask%20%E5%AE%9E%E7%8E%B0web%20%E6%9C%8D%E5%8A%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%8A%A0%E9%80%9F-toc" style="margin-left:40px;"><a href="#3.%20%E4%BB%A3%E7%A0%81%E7%94%A8Flask%20%E5%AE%9E%E7%8E%B0web%20%E6%9C%8D%E5%8A%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%8A%A0%E9%80%9F" rel="nofollow">3. 代码用Flask 实现web 服务并实现加速</a></p> 
<p id="%E4%B9%9D.%20%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%20multiprocessing%20%E5%8A%A0%E9%80%9F%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C-toc" style="margin-left:0px;"><a href="#%E4%B9%9D.%20%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%20multiprocessing%20%E5%8A%A0%E9%80%9F%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C" rel="nofollow">九. 使用多进程 multiprocessing 加速程序的运行</a></p> 
<p id="%E5%8D%81.%20%E5%9C%A8Flask%20%E6%9C%8D%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%8A%A0%E9%80%9F%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C-toc" style="margin-left:0px;"><a href="#%E5%8D%81.%20%E5%9C%A8Flask%20%E6%9C%8D%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%8A%A0%E9%80%9F%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C" rel="nofollow">十. 在Flask 服务中使用多进程池加速程序运行</a></p> 
<p id="%E5%8D%81%E4%B8%80.%20python%20%E5%BC%82%E6%AD%A5IO%20%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E7%88%AC%E8%99%AB-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%B8%80.%20python%20%E5%BC%82%E6%AD%A5IO%20%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E7%88%AC%E8%99%AB" rel="nofollow">十一. python 异步IO 实现并发spider</a></p> 
<p id="%E5%8D%81%E4%BA%8C.%20%E5%9C%A8%E5%BC%82%E6%AD%A5IO%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%8E%A7%E5%88%B6%E7%88%AC%E8%99%AB%E5%B9%B6%E5%8F%91%E5%BA%A6-toc" style="margin-left:0px;"><a href="#%E5%8D%81%E4%BA%8C.%20%E5%9C%A8%E5%BC%82%E6%AD%A5IO%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%8E%A7%E5%88%B6%E7%88%AC%E8%99%AB%E5%B9%B6%E5%8F%91%E5%BA%A6" rel="nofollow">十二. 在异步IO中使用信号量控制spider并发度</a></p> 
<hr id="hr-toc"> 
<h2>一. 为什么需要引入并发编程呢？</h2> 
<p>场景1：一个网络爬虫，按顺序爬取花了一小时，采用并发下载减少到20 min，场景2：一个app 应用，优化前每次打开页面需要3s，采用异步并发提升到每次200ms；引入并发，就是为了提升程序运行的速度，有哪些程序提升速度的方法呢？</p> 
<p>① 单线程串行：由CPU 和 IO 轮流执行；② 多线程并发（threading）③ 多CPU 并行（multiprocessing）④ 多机器并行；</p> 
<p>python 对于并发编程的支持：</p> 
<ol><li>多线程：threading，利用CPU 和 IO 可以同时执行的原理，让CPU 不会干巴巴等待IO 完成；</li><li>多进程：multiprocessing，利用多核CPU的能力，真正并行执行任务；</li><li>异步IO：asyncio，在单线程利用CPU 和 IO 同时执行的原理，实现函数的异步执行；</li><li>使用 Lock 对资源进行加锁，防止冲突访问；python 也提供了Queue 实现不同线程/进程之间的数据通信 ，实现生产者--消费者模式 </li><li>使用线程池Pool/进程池Pool，简化线程/进程任务提交，等待结果、获取结果；</li><li>使用subprocess 启动外部程序的进程，并进行输入输出的交互；</li></ol> 
<h2 id="%E4%BA%8C.%20%E6%80%8E%E4%B9%88%E6%A0%B7%E9%80%89%E6%8B%A9%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E5%8D%8F%E7%A8%8B%EF%BC%9F">二. 怎么样选择多线程，多进程和多协程？</h2> 
<p>python 并发编程有三种模式：1. 多线程Thread；2. 多进程Process；3. 多协程Corroutine；思考一下三个问题：1. 什么是CPU密集型计算，IO 密集型计算；2. 多线程，多进程和多协程的区别；3. 怎么样根据任务选择对应技术？</p> 
<h3 id="1.%20CPU%20%E5%AF%86%E9%9B%86%E5%9E%8B%E4%B8%8E%20I%2FO%20%E5%AF%86%E9%9B%86%E5%9E%8B">1. CPU 密集型与 I/O 密集型</h3> 
<p>CPU 密集型（CPU-bound）：CPU 密集型也叫做计算密集型，是指I/O在很短时间内就可以完成，CPU 需要大量的计算和处理，特点是CPU 占用率相当高；例如：压缩解压缩、加密解密、正则表达式搜索；I/O密集型（I/O bound）：IO 密集型指的是系统运作大部分的状况是CPU 在等I/O（硬盘，内存）的读写操作，CPU 占用率较低，例如：文件处理程序，网络爬虫程序，读写数据库程序；</p> 
<h3 id="2.%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AF%B9%E6%AF%94">2. 多线程，多进程和多协程的对比</h3> 
<p>一个进程中可以启动 N 个进程，一个线程中可以启动 N 个协程；多进程，多线程，多协程三种技术中只有多进程能够同时利用多核cpu并行计算；</p> 
<p>多进程 Process (multiprocessing)：<strong>优点</strong>：可以利用多核cpu 并行计算；<strong>缺点</strong>：占用资源最多，可以启动的数目比线程要少；适用于cpu 密集型计算；</p> 
<p>多线程 Thread (threading)：<strong>优点</strong>：相比进程，更加轻量级，占用资源较少；<strong>缺点</strong>：相比进程：多线程只能够并发执行，不能够利用多CPU（GIL），这是python 多线程一个很大的缺点，同一时间只能够使用一个cpu，相比于协程：启动数目有限，占用内存资源，有线程切换开销，多线程适用于IO密集行型计算，同时运行的任务数目要求不多；</p> 
<p>多协程 Coroutine (asyncio)：<strong>优点</strong>：内存开销最小，启动协程数目最多；<strong>缺点</strong>：支持的库有限制，代码实现复杂；很多库函是不支持协程的（aiohttp）；适用于：IO 密集型计算，需要超多任务运行，但是有现成库支持的场景；</p> 
<h2 id="%E4%B8%89.%20python%20%E7%9A%84%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81%EF%BC%88GIL%EF%BC%89">三. python 的全局解释器锁（GIL）</h2> 
<h3 id="1.%C2%A0python%20%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E4%B8%A4%E5%A4%A7%E5%8E%9F%E5%9B%A0">1. python 速度慢的两大原因</h3> 
<p>相比对c++/java，python 确实比较慢，在一些特殊场景下，python 比c++ 慢100~200倍；由于速度慢的原因，很多公司的基础架构代码仍然使用c/c++开发。python 速度慢的两大原因：① python 属于动态类型语言，边解释边执行；② python 中由于存在GIL，无法利用多核cpu 并发执行。</p> 
<h3 id="2.%20GIL%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">2. GIL 是什么？</h3> 
<p>全局解释器锁（GIL）：是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻只有一个线程在执行；即使在多核处理器上，使用GIL 的解释器也只允许同一时间执行一个线程；</p> 
<p><img alt="" height="226" src="https://images2.imgbox.com/ad/87/bd8fyVWv_o.png" width="419"></p> 
<p>所以当GIL存在的时候，即使电脑有多核cpu，单个时刻也只能够执行1个，相比并发加速的c++/java 所以慢；</p> 
<h3 id="3.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89GIL%20%E8%BF%99%E4%B8%AA%E4%B8%9C%E8%A5%BF%EF%BC%9F">3. 为什么会有GIL 这个东西？</h3> 
<p>简而言之，python 设计初期，为了规避并发问题引入了GIL，为了解决多线程之间数据完整性和状态同步问题；python 中对象的管理，是使用引用计数器进行的，引用数为0则释放对象，但是GIL 确实有好处，简化了python对于共享资源的管理；</p> 
<h3 id="4.%20%E6%80%8E%E4%B9%88%E6%A0%B7%E8%A7%84%E9%81%BFGIL%20%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%99%90%E5%88%B6%EF%BC%9F">4. 怎么样规避GIL 带来的限制？</h3> 
<p>多线程 threading 机制依然是有用的，用于IO 密集型计算，因为在IO期间，线程会释放GIL，实现CPU 和IO的并行，因此多线程用于IO密集型计算依然可以大幅度提升速度，但是多线程用于CPU密集型计算的时候，只会更加拖慢速度；使用multiprocessing 的多进程机制实现并行计算，利用多核cpu 的优势，为了应对GIL 的问题，python 提供了multiprocessing。</p> 
<h2 id="%E5%9B%9B.%20%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%80%9Fpython%20%E7%88%AC%E8%99%AB">四. 使用多线程加速python spider</h2> 
<p>使用多线程，python 爬虫被加速10倍；</p> 
<h3 id="1.%20python%20%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9B">1. python 创建线程的方法；</h3> 
<p>① 准备一个函数： func (a，b)；② 怎样创建一个线程；threading.Thread(target=func, args=(100，200)); ③ 启动线程：t.start()；4. 等待结束：t.join();</p> 
<h3 id="2.%20%E6%94%B9%E5%86%99%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%8F%98%E6%88%90%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E5%8F%96%EF%BC%9B">2. 改写spider程序，变成多线程爬取；</h3> 
<p>使用多线程爬取发现爬取的速度快了将近10倍，我们可以创建一个blog_spider.py和multi_thread_craw.py 文件，blog_spider.py 文件调用requests 库中的get()方法，multi_thread_craw.py 分别使用单线程和多线程进行爬取：</p> 
<p>blog_spider.py：</p> 
<pre><code class="language-python">import requests

# urls存储爬取页面的url, 以f开头表示在字符串内支持大括号内的python表达式(列表表达式生成列表的每一个元素)
urls = [f"https://www.cnblogs.com/#p{page}" for page in range(1, 51)]


# 爬取函数
def craw(url: str):
    # get()方法给url 对应的服务器发送一个get请求, 返回值为Response 类
    r = requests.get(url)
    print(url, len(r.text))</code></pre> 
<p>multi_thread_craw.py：</p> 
<pre><code class="language-python">import threading
import time

import blog_spider


def single_thread():
    print("single-thread begin")
    for url in blog_spider.urls:
        blog_spider.craw(url)
    print("single-thread end")


def multi_thread():
    print("multi-thread begin")
    # threads 存储线程对象
    threads = list()
    for url in blog_spider.urls:
        threads.append(
            # target 传递的是调用的函数, 当前调用的函数需要开启线程来处理, args为函数的参数, 需要传递一个元祖类型
            threading.Thread(target=blog_spider.craw, args=(url,))
        )
    for thread in threads:
        # 使用start()启动线程
        thread.start()
    # 使用join()函数等待结束
    for thread in threads:
        thread.join()
    print("multi-thread end")


if __name__ == "__main__":
    # 计算使用单线程爬取的耗时
    start = time.time()
    single_thread()
    end = time.time()
    print("single-thread cost: ", end - start, " seconds")
    
    # 计算使用多线程爬取的耗时
    start = time.time()
    multi_thread()
    end = time.time()
    print("multi-thread cost: ", end - start, " seconds")</code></pre> 
<p>根据输出结果可以发现单线程是按照顺序爬取的，而多线程是并发执行的，没有顺序的：</p> 
<p><img alt="" height="271" src="https://images2.imgbox.com/81/db/YpDqmTrj_o.png" width="266"></p> 
<p><img alt="" height="496" src="https://images2.imgbox.com/eb/d0/2LCeY1QD_o.png" width="1200"></p> 
<h2 id="%E4%BA%94.%20%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85%E7%88%AC%E8%99%AB">五. 生产消费者spider</h2> 
<h3 id="1.%20%E5%A4%9A%E7%BB%84%E4%BB%B6%E7%9A%84Pipeline%20%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84">1. 多组件的Pipeline 技术架构</h3> 
<p>复杂的事情一般不会一下子做完，而是会分很多中间的步骤来完成；</p> 
<p><img alt="" height="270" src="https://images2.imgbox.com/a1/a9/EaGawbM9_o.png" width="554"></p> 
<h3 id="2.%20%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E7%88%AC%E8%99%AB%E6%9E%B6%E6%9E%84">2. 生产者消费者的爬虫架构</h3> 
<p><img alt="" height="151" src="https://images2.imgbox.com/c4/34/DIfUeWdo_o.png" width="551"> 3. 多线程数据通信的queue.Queue</p> 
<p>queue.Queue 可以用于多线程之间的，线程安全的数据通信</p> 
<pre><code class="language-python">import queue

q = queue.Queue()
# 添加元素, 当队列满的时候会一直等待直到有人取出元素
q.put(elem)
# 当队列为空的时候使用get()会一直阻塞直到队列中有元素之后
elem = q.get()</code></pre> 
<h3 id="3.%20%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E7%88%AC%E8%99%AB">3. 生产者消费者爬虫</h3> 
<p>新建一个blog_spider.py，producer_consumer_spider.py：</p> 
<p>可以查看<a class="link-info" href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/#kinds-of-filters" rel="nofollow" title="BeautifulSoup">BeautifulSoup</a>第三方库的帮助文档，里面有详细的用法，这个库主要用来解析html 页面中的内容，blog_spider.py：</p> 
<pre><code class="language-python">import requests
from bs4 import BeautifulSoup

# urls存储爬取页面的url, 以f开头表示在字符串内支持大括号内的python表达式
urls = [f"https://www.cnblogs.com/#p{page}" for page in range(1, 51)]


# 爬取函数
def craw(url: str):
    r = requests.get(url)
    return r.text


def parse(html):
    soup = BeautifulSoup(html, "html.parser")
    # links = soup.find_all("a", "post-item-title")
    # 当html 文档需要获取对应的css属性对应的标签的时候这个时候可以使用 css属性名字_= "属性值"的方式
    links = soup.find_all("a", class_="post-item-title")
    return [(link["href"], link.get_text()) for link in links]</code></pre> 
<p>producer_consumer_spider.py：</p> 
<pre><code class="language-python">import queue
import blog_spider
import time
import random
import threading

# do_craw方法用来获取url_queue队列中url的值并爬取url地址对应的html内容并将其放入到html_queue队列中
def do_craw(url_queue: queue.Queue, html_queue: queue.Queue):
    while True:
        url = url_queue.get()
        html = blog_spider.craw(url)
        html_queue.put(html)
        print(threading.current_thread().name, f"craw {url}", "url_queue.size=", url_queue.qsize())
        time.sleep(random.randint(1, 2))

# do_parse方法用来获取爬取的html_queue的html内容并将解析, 将解析的结果写入到文件中
def do_parse(html_queue: queue.Queue, fout):
    while True:
        html = html_queue.get()
        results = blog_spider.parse(html)
        for res in results:
            fout.write(str(res) + "\n")
        print(threading.current_thread().name, f"result.size", len(results), "html_queue.size=", html_queue.qsize())
        time.sleep(random.randint(1, 2))


if __name__ == '__main__':
    url_queue = queue.Queue()
    html_queue = queue.Queue()
    for url in blog_spider.urls:
        url_queue.put(url)
    fout = open("data.txt", "w")
    # 开启三个线程来处理这些爬取html的函数
    for idx in range(3):
        t = threading.Thread(target=do_craw, args=(url_queue, html_queue), name=f"craw{idx}")
        t.start()
    # 开启两个线程解析爬取的html页面的内容
    for idx in range(2):
        t = threading.Thread(target=do_parse, args=(html_queue, fout), name=f"parse{idx}")
        t.start()</code></pre> 
<p>上面的生产者与消费者模型类似于go 语言的多协程并发执行，启动线程来调用函数的时候会根据cpu的调度轮流执行，生产者不断解析队列中url 爬取的hmtl 内容并将起放入到队列中，消费者不不停地取出生产者生产的存储在队列中的内容，如果没有内容则会等待，直到消费者消费了队列中的内容或者生产者生产了内容，其实就是多线程并发执行的思想。</p> 
<h2 id="%E5%85%AD.%20python%20%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">六. python 线程安全问题以及解决方案</h2> 
<h3 id="1.%20%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%A6%82%E5%BF%B5">1. 线程安全的概念</h3> 
<p>线程安全是指某个函数，函数库在多线程环境中被调用的时候，能够正确地处理多个线程之间的共享变量；由于线程的执行随时可能会发生切换，就造成了不可预料的结果，出现线程不安全的结果；</p> 
<h3 id="2.%20python%20%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20Lock%20%E7%B1%BB%E6%9D%A5%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98">2. python 可以使用 Lock 类来解决线程安全问题</h3> 
<p>存在两种方式对发生线程安全的代码进行加锁：① try-finally 模式；② with 模式；</p> 
<pre><code class="language-python"># 用法1
import threading

lock = threading.Lock()
lock.acquire()
try:
    ...

finally:
    lock.release()

# 用法2
import threading
lock = threading.Lock()
with lock:
    ...</code></pre> 
<p>下面是一个取钱的例子，线程a和线程b是并发执行的，一开始的时候轮到线程a执行发现1000 &gt;= 800 成立所以执行if 判断中的语句，此时可能还没有执行到account.balance -= amount 然后切换到第二个线程b 执行，此时余额还是1000 满足if 判断所以也会进入到if 判断，然后可能切换到线程a，执行account.balance -= amount 此时余额已经变为200了，而对于线程b 来说已经进入了if 判断然后继续执行 account.balance -= amount，导致余额变为了-600，这样在并发执行的过程中就发生了线程安全问题，发生了不可预料的结果，我们可以在进入if 判断之后加上time.sleep()这样在线程轮流切换的时候会更容易出现问题：</p> 
<pre><code class="language-python">import threading
import time


class Account:
    def __init__(self, balance):
        self.balance = balance


def draw(account, amount):
    if account.balance &gt;= amount:
        # 调用sleep()大概率会出现问题, 因为此时会发生线程的切换, 那么就一定会进入if判断的语句那么两个线程都会balance 操作就出现了问题
        time.sleep(0.1)
        print(threading.current_thread().name + "取钱成功")
        account.balance -= amount
        print(threading.current_thread().name + " 余额: ", account.balance)

    else:
        print(threading.current_thread().name, "取钱失败, 余额不足")


if __name__ == '__main__':
    account = Account(1000)
    # 使用线程a, b来执行draw 函数
    ta = threading.Thread(name="a", target=draw, args=(account, 800))
    tb = threading.Thread(name="b", target=draw, args=(account, 800))
    # 使用start()会启动一个线程
    ta.start()
    tb.start()</code></pre> 
<pre><code class="language-bash"># 有可能输出错误的结果, 也有可能输出正确的结果
a取钱成功
b取钱成功
b 余额:  200
a 余额:  -600

# 不够大部分的情况下输出的答案都是正确的, 这就是多个线程共同操作共享变量的时候发生的线程安全问题

a取钱成功
a 余额:  200
b 取钱失败, 余额不足</code></pre> 
<p>对发生线程安全的代码进行加锁解决线程安全问题：</p> 
<pre><code class="language-python">import threading
import time

# 获取锁对象
lock = threading.Lock()


class Account:
    def __init__(self, balance):
        self.balance = balance


def draw(account, amount):
    # 使用with关键字对发生线程安全的代码进行加锁, 当一个线程执行完成之后才会释放锁另外一个线程才可以获取到锁
    with lock:
        if account.balance &gt;= amount:
            # 调用sleep()大概率会出现问题
            time.sleep(0.1)
            print(threading.current_thread().name + "取钱成功")
            account.balance -= amount
            print(threading.current_thread().name + " 余额: ", account.balance)

        else:
            print(threading.current_thread().name, "取钱失败, 余额不足")


if __name__ == '__main__':
    account = Account(1000)
    ta = threading.Thread(name="a", target=draw, args=(account, 800))
    tb = threading.Thread(name="b", target=draw, args=(account, 800))
    ta.start()
    tb.start()</code></pre> 
<h2 id="%E4%B8%83.%20Python%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%20ThreadPoolExecutor">七. python 线程池 ThreadPoolExecutor</h2> 
<h3 id="1.%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86">1. 线程池的原理</h3> 
<p><img alt="" height="305" src="https://images2.imgbox.com/b3/ed/3hwTPUDG_o.png" width="330"></p> 
<p>新建线程需要系统分配资源，终止线程需要系统回收资源，如果可以重用线程，则可以减去新建/终止的开销，线程池就是这样一个概念： </p> 
<p><img alt="" height="290" src="https://images2.imgbox.com/da/43/Zzl9HBcK_o.png" width="411"></p> 
<h3 id="2.%20%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84">2. 使用线程池的好处</h3> 
<p>① 提升了性能：因为减去了大量新建，终止线程的开销，重用了线程资源；② 适用场景：处理处理突发性大量请求或者需要大量线程完成任务，但是实际上任务处理时间较短；③ 防御功能：能够有效避免系统因为创建线程过多，而导致的系统负荷过大相应变慢等问题；</p> 
<h3 id="3.%20ThreadPoolExecutor%20%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%94%B9%E9%80%A0%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F">3. ThreadPoolExecutor 的使用，使用线程池改造爬虫程序</h3> 
<p>新建thread_pool.py：</p> 
<pre><code class="language-python">import concurrent.futures
import blog_spider

with concurrent.futures.ThreadPoolExecutor() as pool:
    htmls = pool.map(blog_spider.craw, blog_spider.urls)
    htmls = list(zip(blog_spider.urls, htmls))
    for url, html in htmls:
        print(url, len(html))
print("craw over")

with concurrent.futures.ThreadPoolExecutor() as pool:
    futures = dict()
    # 使用submit的方式
    for url, html in htmls:
        future = pool.submit(blog_spider.parse, html)
        # future与url建立一个关系
        futures[future] = url
    for future, url in futures.items():
        print(url, future.result())
    # as_completed 哪一个任务先执行完就返回哪一个结果
    # for future in concurrent.futures.as_completed(futures):
    #     url = futures[future]
    #     print(url, future.result())
print("parse over")</code></pre> 
<h2 id="%E5%85%AB.%20%E5%9C%A8web%20%E6%9C%8D%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8A%A0%E9%80%9F">八. 在web 服务中使用线程池加速</h2> 
<h3 id="1.%20web%20%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%A5%E5%8F%8A%E7%89%B9%E7%82%B9">1. web 服务的架构以及特点</h3> 
<p><img alt="" height="128" src="https://images2.imgbox.com/38/53/nchD9hbK_o.png" width="462"></p> 
<p>web 后台服务的特点：</p> 
<p>① web 服务对响应时间要求非常高，比如要求200ms 返回；② web 服务有大量的依赖IO操作的调用，比如磁盘文件，数据库，远程API（可以使用线程池的技术加速）；③ web 服务经常需要处理几万人，几百万人同时请求；</p> 
<h3 id="2.%20%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%20%E5%8A%A0%E9%80%9F">2. 使用线程池ThreadPoolExecutor 加速</h3> 
<p>① 方便将磁盘文件，数据库，远程API的IO 调用并发执行；② 线程池的线程数目不会无限创建（导致系统挂掉）；具有防御功能；</p> 
<h3 id="3.%20%E4%BB%A3%E7%A0%81%E7%94%A8Flask%20%E5%AE%9E%E7%8E%B0web%20%E6%9C%8D%E5%8A%A1%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%8A%A0%E9%80%9F">3. 代码用Flask 实现web 服务并实现加速</h3> 
<p>原来的程序：</p> 
<pre><code class="language-python">import json
import time

import flask

app = flask.Flask(__name__)

# 使用time.sleep()方法模拟读取文件的操作, 其余两个方法也是类似的
def read_file():
    time.sleep(0.1)
    return "file_read result"


def read_db():
    time.sleep(0.2)
    return "db_read result"


def read_api():
    time.sleep(0.6)
    return "api_read result"

# 映射的url
@app.route("/")
def index():
    result_file = read_file()
    result_db = read_db()
    result_api = read_api()
    #返回json字符串
    return json.dumps({
        "result_file": result_file,
        "result_db": result_db,
        "result_api": result_api
    })


if __name__ == '__main__':
    # 启动flask 服务
    app.run()</code></pre> 
<p>使用cmd 命令行访问：curl <a href="http://127.0.0.1:5000/" rel="nofollow" title="http://127.0.0.1:5000/">http://127.0.0.1:5000/</a></p> 
<p>改进：这三种操作都是IO操作，可以使用线程池进行加速，因为三个读取IO操作的时间总共为600ms，使用线程池加速之后那么相当于并发执行最终只需要花费读取IO操作最长的时间为300ms即可完成：</p> 
<pre><code class="language-python">import json
import time
from concurrent.futures import ThreadPoolExecutor
import flask
# 创建一个全局的pool
pool = ThreadPoolExecutor()

app = flask.Flask(__name__)


def read_file():
    time.sleep(0.1)
    return "file_read result"


def read_db():
    time.sleep(0.2)
    return "db_read result"


def read_api():
    time.sleep(0.6)
    return "api_read result"


@app.route("/")
def index():
    # 使用submit()函数返回的是Future对象
    result_file = pool.submit(read_file)
    result_db = pool.submit(read_db)
    result_api = pool.submit(read_api)
    return json.dumps({
        "result_file": result_file.result(),
        "result_db": result_db.result(),
        "result_api": result_api.result()
    })


if __name__ == '__main__':
    # 启动flask 服务
    app.run()</code></pre> 
<h2 id="%E4%B9%9D.%20%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%20multiprocessing%20%E5%8A%A0%E9%80%9F%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C">九. 使用多进程 multiprocessing 加速程序的运行</h2> 
<p>1. 有了多线程threading，为什么还要用多进程multiprocessing，虽然对于IO 密集型来说多线程确实可以实现加速的效果，因为当遇到IO的时候cpu会切换到另外的线程，此时当前的线程可以执行当前的IO操作，这样就实现了多线程加速的效果，但是当遇到的是cpu 密集型来说，没有IO的操作，当一个线程执行一段时间之后那么切换到其他的线程，此时会发生线程切换的消耗，非但没有实现加速的效果，返回减慢了运行速度；而multiprocessing 模块就是为了python 为了解决GIL 缺陷而引入的一个模块，原理是在用多进程在多cpu 上并行执行；</p> 
<p><img alt="" height="239" src="https://images2.imgbox.com/b7/5d/d3lfU9dp_o.png" width="501"></p> 
<p>2. 多进程multiprocessing 知识梳理</p> 
<p><img alt="" height="262" src="https://images2.imgbox.com/0a/10/kxOdnFuE_o.png" width="550"></p> 
<p>3. 单线程，多线程，多进程对比 CPU密集型计算速度</p> 
<p>cpu 密集型计算：100次判断大数字是否是素数的计算，由于GIL 的存在，多线程比单线程计算还慢，而多进程可以明显加快执行速度（实际运行结果可能有的时候有偏差但是几乎单线程与多线程的计算速度差不多，多进程是最快的）：</p> 
<pre><code class="language-python">from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor
import time


class Solution:
    primes = [112272535095293] * 100

    # 判断n是否是素数
    def is_prime(self, n: int):
        i = 2
        while i * i &lt;= n:
            if n % i == 0: return False
            i += 1
        return True

    def single_thread(self):
        for x in self.primes:
            self.is_prime(x)

    def multi_thread(self):
        with ThreadPoolExecutor() as pool:
            pool.map(self.is_prime, self.primes)

    def multi_process(self):
        with ProcessPoolExecutor() as pool:
            pool.map(self.is_prime, self.primes)


if __name__ == '__main__':
    start = time.time()
    Solution().single_thread()
    end = time.time()
    print("single_thread cost", end - start, "s")

    start = time.time()
    Solution().multi_thread()
    end = time.time()
    print("multi_thread cost", end - start, "s")

    start = time.time()
    Solution().multi_process()
    end = time.time()
    print("multi_process cost", end - start, "s")</code></pre> 
<pre><code class="language-bash">single_thread cost 185.69155049324036 s
multi_thread cost 181.973712682724 s
multi_process cost 87.62334203720093 s</code></pre> 
<h2 id="%E5%8D%81.%20%E5%9C%A8Flask%20%E6%9C%8D%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%8A%A0%E9%80%9F%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C">十. 在Flask 服务中使用多进程池加速程序运行</h2> 
<p>如果像多线程那样的方式使用代码会直接报错，这就需要引入多进程与多线程的区别：多线程共享当前进程的所有环境，定义在哪里都可以，而多进程环境是相互隔离的，有一个限制是定义ProcessPoolExecutor的时候必须定义到最下面，也即它所依赖的函数都已经声明完了，并且需要定义到main()函数里面这样才不会报错：</p> 
<pre><code class="language-python">import flask
from concurrent.futures import ProcessPoolExecutor
import json

app = flask.Flask(__name__)


def is_prime(n: int):
    i = 2
    while i * i &lt;= n:
        if n % i == 0: return False
        i += 1
    return True


@app.route("/is_prime/&lt;numbers&gt;")
def api_is_prime(numbers):
    number_list = [int(x) for x in numbers.split(",")]
    results = process_pool.map(is_prime, number_list)
    return json.dumps(dict(zip(number_list, results)))


# 下面直接运行会报错
if __name__ == '__main__':
    process_pool = ProcessPoolExecutor()
    app.run()</code></pre> 
<p><img alt="" height="86" src="https://images2.imgbox.com/63/bd/Oib8O5Za_o.png" width="500"></p> 
<h2 id="%E5%8D%81%E4%B8%80.%20python%20%E5%BC%82%E6%AD%A5IO%20%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E7%88%AC%E8%99%AB">十一. python 异步IO 实现并发spider</h2> 
<p>并不是所有的库都支持异步爬虫，例如requests 库就不支持异步IO特性：</p> 
<p><img alt="" height="88" src="https://images2.imgbox.com/13/6b/UaEE5h2G_o.png" width="437"></p> 
<p></p> 
<p><img alt="" height="212" src="https://images2.imgbox.com/c6/22/xvvB88uO_o.png" width="423"></p> 
<p><img alt="" height="265" src="https://images2.imgbox.com/96/42/XEBHHCWR_o.png" width="517"></p> 
<pre><code class="language-python">import asyncio
import time
import aiohttp
import blog_spider


# 协程就是在异步IO中执行的函数, async需要使用超级循环进行调度
async def async_craw(url: str):
    print("craw url: ", url)
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            # await的时候超级循环不会等待而是切换到下一个循环
            result = await resp.text()
            print(f"craw url:{url}, {len(result)}")

loop = asyncio.get_event_loop()
tasks = [loop.create_task(async_craw(url)) for url in blog_spider.urls]
start = time.time()
loop.run_until_complete(asyncio.wait(tasks))
end = time.time()
print("use time seconds: ", end - start)</code></pre> 
<p>使用异步IO 的方法爬取可以发现只需要1s多就可以爬取50个url 的html页面，比单线程爬取的的快很多，并且单线程异步爬虫快于多线程的，多线程并发爬取的时候需要线程的切换需要一定的开销；</p> 
<h2 id="%E5%8D%81%E4%BA%8C.%20%E5%9C%A8%E5%BC%82%E6%AD%A5IO%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%8E%A7%E5%88%B6%E7%88%AC%E8%99%AB%E5%B9%B6%E5%8F%91%E5%BA%A6">十二. 在异步IO中使用信号量控制spider并发度</h2> 
<p>在异步IO中可以使用信号量来控制爬取的并发度：</p> 
<p><img alt="" height="297" src="https://images2.imgbox.com/67/f0/4npk4OMB_o.png" width="500"></p> 
<pre><code class="language-python">import asyncio
import time
import aiohttp
import blog_spider

# 控制并发度
semaphore = asyncio.Semaphore(10)


async def async_craw(url: str):
    # 在semaphore 代码内的都是在semaphore 信号量的控制内, 由它来控制并发
    async with semaphore:
        print("craw url: ", url)
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as resp:
                result = await resp.text()
                # 休眠5s
                await asyncio.sleep(5)
                print(f"craw url:{url}, {len(result)}")


loop = asyncio.get_event_loop()
tasks = [loop.create_task(async_craw(url)) for url in blog_spider.urls]
start = time.time()
loop.run_until_complete(asyncio.wait(tasks))
end = time.time()
print("use time seconds: ", end - start)</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f58cf1ac2c6ae3be94851aa4f399a3e5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">彻底关闭Win10自动更新（转载）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d3fbfeb59fd07633c46b95297d3345da/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">nohup 命令之 nohup: ignoring input and appending output to ‘nohup.out’</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>