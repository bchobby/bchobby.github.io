<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>XModem协议 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="XModem协议" />
<meta property="og:description" content="出处：XModem协议
XModem协议介绍：
XModem是一种在串口通信中广泛使用的异步文件传输协议，分为XModem和1k-XModem协议两种，前者使用128字节的数据块，后者使用1024字节即1k字节的数据块。
一、XModem校验和协议
1. XModem信息包格式
XModem协议最早由Ward Christensen在20世纪70年代提出并实现的，传输数据单位为信息包，信息包格式如下：
--------------------------------------------------------------------------- | Byte1 | Byte2 | Byte3 |Byte4~Byte131| Byte132 | |-------------------------------------------------------------------------| |Start Of Header|Packet Number|~(Packet Number)| Packet Data | Check Sum | --------------------------------------------------------------------------- 2. 校验和的计算
所有的数据字节都将参与和运算，由于校验和只占一个字节，如果累加的和超过255将从零开始继续累加。
3. 字段定义
&lt;SOH&gt; 01H
&lt;EOT&gt; 04H
&lt;ACK&gt; 06H
&lt;NAK&gt; 15H
&lt;CAN&gt; 18H
4. 校验和方式的XModem传输流程
传输流程如图所示：
------------------------------------------------------------------------------ | SENDER | | RECIEVER | | | &lt;--- | NAK | | | | Time out after 3 second | | | &lt;--- | NAK | | SOH|0x01|0xFE|Data[0~127]|CheckSum| | ---&gt; | | | | &lt;--- | ACK | | SOH|0x02|0xFD|Data[0~127]|CheckSum| | ---&gt; | | | | &lt;--- | NAK | | SOH|0x02|0xFD|Data[0~127]|CheckSum| | ---&gt; | | | | &lt;--- | ACK | | SOH|0x03|0xFC|Data[0~127]|CheckSum| | ---&gt; | | | | &lt;--- | ACK | | ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/e6b04d99cf7f41d21c90e9813fbf2766/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-23T09:19:33+08:00" />
<meta property="article:modified_time" content="2018-05-23T09:19:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">XModem协议</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>出处：<a href="https://blog.csdn.net/mcgrady_tracy/article/details/14522263">XModem协议</a></p> 
<p><span style="color:#333333;">XModem协议介绍：</span><br><span style="color:#333333;">XModem是一种在串口通信中广泛使用的异步文件传输协议，分为XModem和1k-XModem协议两种，前者使用128字节的数据块，后者使用1024字节即1k字节的数据块。</span><br><br><br><span style="color:#333333;">一、XModem校验和协议</span><br><br><span style="color:#333333;">1. XModem信息包格式</span><br><span style="color:#333333;">XModem协议最早由Ward Christensen在20世纪70年代提出并实现的，传输数据单位为信息包，信息包格式如下：</span></p> 
<pre class="has"><code class="language-html">---------------------------------------------------------------------------
|     Byte1     |    Byte2    |     Byte3      |Byte4~Byte131|  Byte132   |
|-------------------------------------------------------------------------|
|Start Of Header|Packet Number|~(Packet Number)| Packet Data |  Check Sum |
---------------------------------------------------------------------------
</code></pre> 
<p> </p> 
<p><span style="color:#333333;">2. 校验和的计算</span><br><span style="color:#333333;">所有的数据字节都将参与和运算，由于校验和只占一个字节，如果累加的和超过255将从零开始继续累加。</span></p> 
<p><br> 3. 字段定义<br> &lt;SOH&gt; 01H<br> &lt;EOT&gt; 04H<br> &lt;ACK&gt; 06H<br> &lt;NAK&gt; 15H<br> &lt;CAN&gt; 18H<br><br> 4. 校验和方式的XModem传输流程<br> 传输流程如图所示：</p> 
<pre class="has"><code class="language-html">------------------------------------------------------------------------------
|               SENDER                |          |          RECIEVER         |
|                                     |  &lt;---    |  NAK                      |
|                                     |          |  Time out after 3 second  |
|                                     |  &lt;---    |  NAK                      |
| SOH|0x01|0xFE|Data[0~127]|CheckSum| |  ---&gt;    |                           |
|                                     |  &lt;---    |  ACK                      |
| SOH|0x02|0xFD|Data[0~127]|CheckSum| |  ---&gt;    |                           |
|                                     |  &lt;---    |  NAK                      |
| SOH|0x02|0xFD|Data[0~127]|CheckSum| |  ---&gt;    |                           |
|                                     |  &lt;---    |  ACK                      |
| SOH|0x03|0xFC|Data[0~127]|CheckSum| |  ---&gt;    |                           |
|                                     |  &lt;---    |  ACK                      |
| .                                   |          |  .                        |
| .                                   |          |  .                        |
| .                                   |          |  .                        |
|                                     |  &lt;---    |  ACK                      |
| EOT                                 |  ---&gt;    |                           |
|                                     |  &lt;---    |  ACK                      |
------------------------------------------------------------------------------</code></pre> 
<p>对于发送方仅仅支持校验和的传输方式，接收方应首先发送NAK信号来发起传输，如果发送方没有数据发送过来，需要超时等待3秒之后再发起NAK信号来进行数据传输。对于数据传输正确，接收方需要发送ACK信号来进行确认，如果数据传输有误，则发送NAK信号，发送方在接收到NAK信号之后需要重新发起该次数据传输，如果数据已近传输完成，发送方需要发送EOT信号，来结束数据传输。<br><br> 5. 如何取消数据传输<br> 当接收方发送CAN表示无条件结束本次传输过程，发送方收到CAN后，无需发送EOT来确认，直接停止数据的发送。<br><br><br> 二、XModem-CRC16协议<br><br> 1. XModem-CRC16信息包格式<br> XModem协议在90年代做过一次修改，将132字节处的校验和改成双字节的CRC16校验，CRC16校验的信息包格式如下：</p> 
<pre class="has"><code class="language-html">------------------------------------------------------------------------------
|     Byte1     |    Byte2    |     Byte3      |Byte4~Byte131|Byte132~Byte133|
|----------------------------------------------------------------------------|
|Start Of Header|Packet Number|~(Packet Number)| Packet Data |   16Bit CRC   |
------------------------------------------------------------------------------
</code></pre> 
<p> </p> 
<p><span style="color:#333333;">2. CRC16的计算</span><br><span style="color:#333333;">比较复杂，表示看不懂，以后有时间再研究吧，先给出一份源代码，来自:</span><br><a href="http://web.mit.edu/6.115/www/miscfiles/amulet/amulet-help/xmodem.htm" rel="nofollow">http://web.mit.edu/6.115/www/miscfiles/amulet/amulet-help/xmodem.htm</a></p> 
<p> </p> 
<p>[cpp] <a class="ViewSource" href="https://blog.csdn.net/mcgrady_tracy/article/details/14522263#">view plain</a> <a class="CopyToClipboard" href="https://blog.csdn.net/mcgrady_tracy/article/details/14522263#">copy</a></p> 
<ol><li><span style="color:#000000;"><strong>int</strong> calcrc(<strong>char</strong> *ptr, <strong>int</strong> count)  </span></li><li><span style="color:#000000;">{  </span></li><li><span style="color:#000000;">    <strong>int</strong> crc;  </span></li><li><span style="color:#000000;">    <strong>char</strong> i;  </span></li><li><span style="color:#000000;">  </span></li><li><span style="color:#000000;">    crc = 0;  </span></li><li><span style="color:#000000;">    <strong>while</strong> (--count &gt;= 0)  </span></li><li><span style="color:#000000;">    {  </span></li><li><span style="color:#000000;">        crc = crc ^ (<strong>int</strong>) *ptr++ &lt;&lt; 8;  </span></li><li><span style="color:#000000;">        i = 8;  </span></li><li><span style="color:#000000;">        <strong>do</strong>  </span></li><li><span style="color:#000000;">        {  </span></li><li><span style="color:#000000;">            <strong>if</strong> (crc &amp; 0x8000)  </span></li><li><span style="color:#000000;">                crc = crc &lt;&lt; 1 ^ 0x1021;  </span></li><li><span style="color:#000000;">            <strong>else</strong>  </span></li><li><span style="color:#000000;">                crc = crc &lt;&lt; 1;  </span></li><li><span style="color:#000000;">        } <strong>while</strong> (--i);  </span></li><li><span style="color:#000000;">    }  </span></li><li><span style="color:#000000;">  </span></li><li><span style="color:#000000;">    <strong>return</strong> (crc);  </span></li><li><span style="color:#000000;">}  </span></li></ol> 
<p>需要注意的是，在发送方，CRC是高字节在前，低字节在后。</p> 
<p> </p> 
<p><span style="color:#333333;">3. CRC16校验的XModem传输流程</span><br><span style="color:#333333;">传输流程如图所示：</span></p> 
<p> </p> 
<pre class="has"><code class="language-html">---------------------------------------------------------------------------
|               SENDER             |          |           RECIEVER        |
|                                  |  &lt;---    |  'C'                      |
|                                  |          |  Time out after 3 second  |
|                                  |  &lt;---    |  'C'                      |
| SOH|0x01|0xFE|Data[0~127]|CRC16| |  ---&gt;    |                           |
|                                  |  &lt;---    |  ACK                      |
| SOH|0x02|0xFD|Data[0~127]|CRC16| |  ---&gt;    |                           |
|                                  |  &lt;---    |  NAK                      |
| SOH|0x02|0xFD|Data[0~127]|CRC16| |  ---&gt;    |                           |
|                                  |  &lt;---    |  ACK                      |
| SOH|0x03|0xFC|Data[0~127]|CRC16| |  ---&gt;    |                           |
|                                  |  &lt;---    |  ACK                      |
| .                                |          |  .                        |
| .                                |          |  .                        |
| .                                |          |  .                        |
|                                  |  &lt;---    |  ACK                      |
| EOT                              |  ---&gt;    |                           |
|                                  |  &lt;---    |  ACK                      |
---------------------------------------------------------------------------
</code></pre> 
<p> </p> 
<p>和校验和方式不同的是，当接收方要求发送方以CRC16校验方式发送数据时以'C'来请求，发送方对此做出应答，流程就如上图所示。当发送方仅仅支持校验和方式时，则接收方要发送NAK来请求，要求以校验和方式来发送数据，如果仅仅支持CRC16校验方式，则只能发送'C'来请求。如果两者都支持的话，优先发送'C'来请求，流程如图所示：</p> 
<pre class="has"><code class="language-html">------------------------------------------------------------------------------
|               SENDER                |          |           RECIEVER        |
|                                     |  &lt;---    |  'C'                      |
|                                     |          |  Time out after 3 second  |
|                                     |  &lt;---    |  NAK                      |
|                                     |          |  Time out after 3 second  |
|                                     |  &lt;---    |  'C'                      |
|                                     |          |  Time out after 3 second  |
|                                     |  &lt;---    |  NAK                      |
| SOH|0x01|0xFE|Data[0~127]|CheckSum| |  ---&gt;    |                           |
|                                     |  &lt;---    |  ACK                      |
| SOH|0x02|0xFD|Data[0~127]|CheckSum| |  ---&gt;    |                           |
|                                     |  &lt;---    |  NAK                      |
| SOH|0x02|0xFD|Data[0~127]|CheckSum| |  ---&gt;    |                           |
|                                     |  &lt;---    |  ACK                      |
| SOH|0x03|0xFC|Data[0~127]|CheckSum| |  ---&gt;    |                           |
|                                     |  &lt;---    |  ACK                      |
| .                                   |          |  .                        |
| .                                   |          |  .                        |
| .                                   |          |  .                        |
|                                     |  &lt;---    |  ACK                      |
| EOT                                 |  ---&gt;    |                           |
|                                     |  &lt;---    |  ACK                      |
------------------------------------------------------------------------------
</code></pre> 
<p>最后，如果信息包中的数据如果不足128字节，剩余的部分要以0x1A(Ctrl-Z)来填充。<br><br><br> 三、1k-XModem协议<br> 1k-XModem协议同XModem-CRC16协议差不多，只是数据块长度变成了1024字节即1k，同时每个信息报的第一个字节的SOH变成了STX，STX定义为 &lt;STX&gt; 0x02，能有效的加快数据传输速率。</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<h2><a href="https://www.jianshu.com/p/6dabbfe61495" rel="nofollow">使用Java实现Xmodem协议</a></h2> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>Xmodem协议<img alt="" class="has" src="https://images2.imgbox.com/a9/4e/sjoPEy2g_o.png"></p> 
<h2> </h2> 
<h2>1.介绍</h2> 
<p>Xmodem是一种在串口通信中广泛使用的异步文件传输协议，分为Xmodem（使用128字节的数据块）和1k-Xmodem（使用1024字节即1k字节的数据块）协议两种。<br> 本文实现的是128字节数据块的Xmodem协议，采用CRC16校验，在项目中应用时，发送端和接收端可根据具体情况修改双方的协议。</p> 
<p>标准Xmodem协议（使用128字节的数据块）帧格式：</p> 
<table><thead><tr><th style="text-align:center;">Byte1</th><th style="text-align:center;">Byte2</th><th style="text-align:center;">Byte3</th><th style="text-align:center;">Byte4 ~ byte131</th><th style="text-align:center;">Byte132</th></tr></thead><tbody><tr><td style="text-align:center;">控制字符</td><td style="text-align:center;">包序号</td><td style="text-align:center;">包序号的反码</td><td style="text-align:center;">数据</td><td style="text-align:center;">校验和</td></tr></tbody></table> 
<p>如果你对串口通信还不太了解，可以看下我写的这篇博客<a href="https://www.jianshu.com/p/abef84fdef41" rel="nofollow">使用Java实现串口通信</a>。</p> 
<h2>2.实现</h2> 
<p>在和嵌入式同学调试的过程中，发现发送端发送数据过快，导致接收端处理不过来，所以在send方法中开启了一个子线程来处理数据发送逻辑，方便加入延时处理。<br> 接收方法中，发送C是表示以CRC方式校验。</p> 
<pre><code class="language-java">
<code>public class Xmodem {

    // 开始
    private final byte SOH = 0x01;
    // 结束
    private final byte EOT = 0x04;
    // 应答
    private final byte ACK = 0x06;
    // 重传
    private final byte NAK = 0x15;
    // 无条件结束
    private final byte CAN = 0x18;

    // 以128字节块的形式传输数据
    private final int SECTOR_SIZE = 128;
    // 最大错误（无应答）包数
    private final int MAX_ERRORS = 10;

    // 输入流，用于读取串口数据
    private InputStream inputStream;
    // 输出流，用于发送串口数据
    private OutputStream outputStream;

    public Xmodem(InputStream inputStream, OutputStream outputStream) {
        this.inputStream = inputStream;
        this.outputStream = outputStream;
    }

    /**
     * 发送数据
     * 
     * @param filePath
     *            文件路径
     */
    public void send(final String filePath) {
        new Thread() {
            public void run() {
                try {
                    // 错误包数
                    int errorCount;
                    // 包序号
                    byte blockNumber = 0x01;
                    // 校验和
                    int checkSum;
                    // 读取到缓冲区的字节数量
                    int nbytes;
                    // 初始化数据缓冲区
                    byte[] sector = new byte[SECTOR_SIZE];
                    // 读取文件初始化
                    DataInputStream inputStream = new DataInputStream(
                            new FileInputStream(filePath));

                    while ((nbytes = inputStream.read(sector)) &gt; 0) {
                        // 如果最后一包数据小于128个字节，以0xff补齐
                        if (nbytes &lt; SECTOR_SIZE) {
                            for (int i = nbytes; i &lt; SECTOR_SIZE; i++) {
                                sector[i] = (byte) 0xff;
                            }
                        }

                        // 同一包数据最多发送10次
                        errorCount = 0;
                        while (errorCount &lt; MAX_ERRORS) {
                            // 组包
                            // 控制字符 + 包序号 + 包序号的反码 + 数据 + 校验和
                            putData(SOH);
                            putData(blockNumber);
                            putData(~blockNumber);
                            checkSum = CRC16.calc(sector) &amp; 0x00ffff;
                            putChar(sector, (short) checkSum);
                            outputStream.flush();

                            // 获取应答数据
                            byte data = getData();
                            // 如果收到应答数据则跳出循环，发送下一包数据
                            // 未收到应答，错误包数+1，继续重发
                            if (data == ACK) {
                                break;
                            } else {
                                ++errorCount;
                            }
                        }
                        // 包序号自增
                        blockNumber = (byte) ((++blockNumber) % 256);
                    }

                    // 所有数据发送完成后，发送结束标识
                    boolean isAck = false;
                    while (!isAck) {
                        putData(EOT);
                        isAck = getData() == ACK;
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            };
        }.start();
    }

    /**
     * 接收数据
     * 
     * @param filePath
     *            文件路径
     * @return 是否接收完成
     * @throws IOException
     *             异常
     */
    public boolean receive(String filePath) throws Exception {
        // 错误包数
        int errorCount = 0;
        // 包序号
        byte blocknumber = 0x01;
        // 数据
        byte data;
        // 校验和
        int checkSum;
        // 初始化数据缓冲区
        byte[] sector = new byte[SECTOR_SIZE];
        // 写入文件初始化
        DataOutputStream outputStream = new DataOutputStream(
                new FileOutputStream(filePath));

        // 发送字符C，CRC方式校验
        putData((byte) 0x43);

        while (true) {
            if (errorCount &gt; MAX_ERRORS) {
                outputStream.close();
                return false;
            }

            // 获取应答数据
            data = getData();
            if (data != EOT) {
                try {
                    // 判断接收到的是否是开始标识
                    if (data != SOH) {
                        errorCount++;
                        continue;
                    }

                    // 获取包序号
                    data = getData();
                    // 判断包序号是否正确
                    if (data != blocknumber) {
                        errorCount++;
                        continue;
                    }

                    // 获取包序号的反码
                    byte _blocknumber = (byte) ~getData();
                    // 判断包序号的反码是否正确
                    if (data != _blocknumber) {
                        errorCount++;
                        continue;
                    }

                    // 获取数据
                    for (int i = 0; i &lt; SECTOR_SIZE; i++) {
                        sector[i] = getData();
                    }

                    // 获取校验和
                    checkSum = (getData() &amp; 0xff) &lt;&lt; 8;
                    checkSum |= (getData() &amp; 0xff);
                    // 判断校验和是否正确
                    int crc = CRC16.calc(sector);
                    if (crc != checkSum) {
                        errorCount++;
                        continue;
                    }

                    // 发送应答
                    putData(ACK);
                    // 包序号自增
                    blocknumber++;
                    // 将数据写入本地
                    outputStream.write(sector);
                    // 错误包数归零
                    errorCount = 0;

                } catch (Exception e) {
                    e.printStackTrace();

                } finally {
                    // 如果出错发送重传标识
                    if (errorCount != 0) {
                        putData(NAK);
                    }
                }
            } else {
                break;
            }
        }

        // 关闭输出流
        outputStream.close();
        // 发送应答
        putData(ACK);

        return true;
    }

    /**
     * 获取数据
     * 
     * @return 数据
     * @throws IOException
     *             异常
     */
    private byte getData() throws IOException {
        return (byte) inputStream.read();
    }

    /**
     * 发送数据
     * 
     * @param data
     *            数据
     * @throws IOException
     *             异常
     */
    private void putData(int data) throws IOException {
        outputStream.write((byte) data);
    }

    /**
     * 发送数据
     * 
     * @param data
     *            数据
     * @param checkSum
     *            校验和
     * @throws IOException
     *             异常
     */
    private void putChar(byte[] data, short checkSum) throws IOException {
        ByteBuffer bb = ByteBuffer.allocate(data.length + 2).order(
                ByteOrder.BIG_ENDIAN);
        bb.put(data);
        bb.putShort(checkSum);
        outputStream.write(bb.array());
    }
}
</code></code></pre> 
<p>CRC16校验算法，采用的是查表法。</p> 
<pre><code class="language-java">
<code>public class CRC16 {

    private static final char crctable[] = { 0x0000, 0x1021, 0x2042, 0x3063,
            0x4084, 0x50a5, 0x60c6, 0x70e7, 0x8108, 0x9129, 0xa14a, 0xb16b,
            0xc18c, 0xd1ad, 0xe1ce, 0xf1ef, 0x1231, 0x0210, 0x3273, 0x2252,
            0x52b5, 0x4294, 0x72f7, 0x62d6, 0x9339, 0x8318, 0xb37b, 0xa35a,
            0xd3bd, 0xc39c, 0xf3ff, 0xe3de, 0x2462, 0x3443, 0x0420, 0x1401,
            0x64e6, 0x74c7, 0x44a4, 0x5485, 0xa56a, 0xb54b, 0x8528, 0x9509,
            0xe5ee, 0xf5cf, 0xc5ac, 0xd58d, 0x3653, 0x2672, 0x1611, 0x0630,
            0x76d7, 0x66f6, 0x5695, 0x46b4, 0xb75b, 0xa77a, 0x9719, 0x8738,
            0xf7df, 0xe7fe, 0xd79d, 0xc7bc, 0x48c4, 0x58e5, 0x6886, 0x78a7,
            0x0840, 0x1861, 0x2802, 0x3823, 0xc9cc, 0xd9ed, 0xe98e, 0xf9af,
            0x8948, 0x9969, 0xa90a, 0xb92b, 0x5af5, 0x4ad4, 0x7ab7, 0x6a96,
            0x1a71, 0x0a50, 0x3a33, 0x2a12, 0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e,
            0x9b79, 0x8b58, 0xbb3b, 0xab1a, 0x6ca6, 0x7c87, 0x4ce4, 0x5cc5,
            0x2c22, 0x3c03, 0x0c60, 0x1c41, 0xedae, 0xfd8f, 0xcdec, 0xddcd,
            0xad2a, 0xbd0b, 0x8d68, 0x9d49, 0x7e97, 0x6eb6, 0x5ed5, 0x4ef4,
            0x3e13, 0x2e32, 0x1e51, 0x0e70, 0xff9f, 0xefbe, 0xdfdd, 0xcffc,
            0xbf1b, 0xaf3a, 0x9f59, 0x8f78, 0x9188, 0x81a9, 0xb1ca, 0xa1eb,
            0xd10c, 0xc12d, 0xf14e, 0xe16f, 0x1080, 0x00a1, 0x30c2, 0x20e3,
            0x5004, 0x4025, 0x7046, 0x6067, 0x83b9, 0x9398, 0xa3fb, 0xb3da,
            0xc33d, 0xd31c, 0xe37f, 0xf35e, 0x02b1, 0x1290, 0x22f3, 0x32d2,
            0x4235, 0x5214, 0x6277, 0x7256, 0xb5ea, 0xa5cb, 0x95a8, 0x8589,
            0xf56e, 0xe54f, 0xd52c, 0xc50d, 0x34e2, 0x24c3, 0x14a0, 0x0481,
            0x7466, 0x6447, 0x5424, 0x4405, 0xa7db, 0xb7fa, 0x8799, 0x97b8,
            0xe75f, 0xf77e, 0xc71d, 0xd73c, 0x26d3, 0x36f2, 0x0691, 0x16b0,
            0x6657, 0x7676, 0x4615, 0x5634, 0xd94c, 0xc96d, 0xf90e, 0xe92f,
            0x99c8, 0x89e9, 0xb98a, 0xa9ab, 0x5844, 0x4865, 0x7806, 0x6827,
            0x18c0, 0x08e1, 0x3882, 0x28a3, 0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e,
            0x8bf9, 0x9bd8, 0xabbb, 0xbb9a, 0x4a75, 0x5a54, 0x6a37, 0x7a16,
            0x0af1, 0x1ad0, 0x2ab3, 0x3a92, 0xfd2e, 0xed0f, 0xdd6c, 0xcd4d,
            0xbdaa, 0xad8b, 0x9de8, 0x8dc9, 0x7c26, 0x6c07, 0x5c64, 0x4c45,
            0x3ca2, 0x2c83, 0x1ce0, 0x0cc1, 0xef1f, 0xff3e, 0xcf5d, 0xdf7c,
            0xaf9b, 0xbfba, 0x8fd9, 0x9ff8, 0x6e17, 0x7e36, 0x4e55, 0x5e74,
            0x2e93, 0x3eb2, 0x0ed1, 0x1ef0 };

    public static char calc(byte[] bytes) {
        char crc = 0x0000;
        for (byte b : bytes) {
            crc = (char) ((crc &lt;&lt; 8) ^ crctable[((crc &gt;&gt; 8) ^ b) &amp; 0x00ff]);
        }
        return (char) (crc);
    }
}
</code></code></pre> 
<h2>3.使用</h2> 
<pre><code class="language-cpp">
<code>// serialPort为串口对象
Xmodem xmodem = new Xmodem(serialPort.getInputStream(),serialPort.getOutputStream());
// filePath为文件路径
// ./bin/xxx.bin
xmodem.send(filePath);
</code></code></pre> 
<h2>4.写在最后</h2> 
<p><a href="https://link.jianshu.com?t=http://download.csdn.net/detail/kong_gu_you_lan/9712923">完整的代码下载</a></p> 
<p><br><br> 作者：容华谢后<br> 链接：https://www.jianshu.com/p/6dabbfe61495<br> 來源：简书<br> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>2018.06.08 10.58</p> 
<p>      xmodem协议模块今天测试完毕了，说下我的思路和感受。写之前一定要有一个大题的思路，</p> 
<p>这个东西做成什么样子（API接口设计，状态机设计），然后就是画各个状态图-&gt;合并状态图-&gt;源码实现。</p> 
<p>其实我比较懒，懒得动笔画，我习惯写之前把状态枚举出来，然后写的过程中会根据思路增加或者减少状态。</p> 
<p>       xmodem的API接口：</p> 
<pre class="has"><code class="language-objc">bool     xmodem_init(       xmodem_t *ptXmodem,user_api_t *ptApi);
bool     xmodem_start_rx(   xmodem_t *ptXmodem,xmodem_select_check_mode_t tCheckMode,uint16_t hwFrameLong);
bool     xmodem_cfg_tx_mode(xmodem_t *ptXmodem,uint16_t hwFrameLong);
bool     xmodem_cancel_rx(  xmodem_t *ptXmodem);
fsm_rt_t xmodem_tx(         xmodem_t *ptXmodem);
fsm_rt_t xmodem_check(      void     *ptXmodem,bool *pbIsRequestDrop,queue_peek_byte_t* ptReadByteHandler);</code></pre> 
<p>    模式：</p> 
<pre class="has"><code class="language-objc">typedef enum{
    XMODEM_CHECKOUT_SUM = 0,
    XMODEM_CHECKOUT_CRC16,
    XMODEM_CHECKOUT_AUTO,
}xmodem_select_check_mode_t;</code></pre> 
<p>注：</p> 
<p>1、发送模式自适应，无需配置模式；</p> 
<p>2、接收模式三种模式都可以配置，如果配置为自适应，则'C'和NAK每隔3s交替发送；</p> 
<p>3、帧长只做了1024和非1024（最大帧长为1024），非1024按着128格式走；</p> 
<p>4、不支持收和发文件同时进行；   </p> 
<p>5、接收线程由协议解析引擎驱动（每次进入接收都需要用户启动）；</p> 
<p>6、发送函数需要由用户发送线程驱动（开始发送前需要配置帧长，默认128）；</p> 
<p> </p> 
<p>      接收状态机，相对于发送状态机要复杂一些，其中有几个状态是独立：强制停止接收态，发送模式</p> 
<p>接收协议解析，这几个状态是通过API强制改变的。发送模式简单分为三大部分：发送启动字符(每隔3s发一次)，</p> 
<p>第一帧协议接收(这里面可能跳转到发送启动字符状态)，后续帧接收(这里面有发送ACK和NAK)。</p> 
<pre class="has"><code class="language-objc">typedef enum{
    XMODEM_CHECK_STATE_START = 0,
    XMODEM_CHECK_STATE_WAIT_START_RX_FLAG,
    XMODEM_CHECK_STATE_START_UP_TX_C,
    XMODEM_CHECK_STATE_START_UP_TX_NAK,
    XMODEM_CHECK_STATE_START_UP_WAIT_FRAME_START,
    XMODEM_CHECK_STATE_START_UP_WAIT_FRAME_NUM,
    XMODEM_CHECK_STATE_START_UP_WAIT_FRAME_CHECK_NUM,
    XMODEM_CHECK_STATE_START_UP_WAIT_FRAME_DATA,
    XMODEM_CHECK_STATE_START_UP_FRAME_CHECK,

    XMODEM_CHECK_STATE_WAIT_FRAME_START,
    XMODEM_CHECK_STATE_WAIT_FRAME_DATA,
    XMODEM_CHECK_STATE_WAIT_FRAME_CHECK,
    XMODEM_CHECK_STATE_WAIT_RETURN_ACK,
    XMODEM_CHECK_STATE_WAIT_RETURN_NAK,
    XMODEM_CHECK_STATE_RX_EOT,
    XMODEM_CHECK_STATE_USER_FORCE_STOP_RX,

    //TX
    XMODEM_CHECK_STATE_TX_CHECK_START_FLAG,
    XMODEM_CHECK_STATE_TX_WAIT_RETURN,
}xmodem_check_state_t;</code></pre> 
<p>        xmodem的接收模式就相对简单了，读取字符串流，打包发送，等待返回字符。</p> 
<pre class="has"><code class="language-objc">typedef enum{
    XMODEM_TX_STATE_START = 0,
    XMODEM_TX_STATE_IS_INIT_API,
    XMODEM_TX_STATE_WAIT_START_FLAG,
    XMODEM_TX_STATE_READ_BUFFER,
    XMODEM_TX_STATE_TX,
    XMODEM_TX_STATE_WAIT_RETURN,
    XMODEM_TX_STATE_TX_EOT,
}xmodem_tx_state_t;</code></pre> 
<p>       xmodem需要外部提供一些API借口，如下：</p> 
<pre class="has"><code class="language-objc">typedef void        start_timer(uint16_t hwDelayMs);
typedef bool        check_timer_flag(void);
typedef bool        user_buffer_write(uint8_t *pchBuffer,uint16_t hwNum);
typedef uint16_t    user_buffer_read( uint8_t *pchBuffer,uint16_t hwNum);
typedef fsm_rt_t    xmodem_serial_out(uint8_t *pchBuffer,uint16_t hwSize);

typedef struct  _user_api_t    user_api_t;
struct  _user_api_t{
    //延时相关
    start_timer         *ptStartTimer;
    check_timer_flag    *ptCheckTimerFlag;

    //APP层对接
    user_buffer_write   *ptWriteBuffer;
    user_buffer_read    *ptReadBuffer;

    //输出数据
    xmodem_serial_out   *ptSerialOut;
};</code></pre> 
<p>说明：</p> 
<p>1、start_timer和check_timer_flag延时相关函数；</p> 
<p>2、user_buffer_write向用户输出数据流，完整一帧协议；</p> 
<p>3、user_buffer_read读取用户要发送数据，每次读取一帧长度，返回实际读取数据长度，如果为0，则表示文件发送完成；</p> 
<p>4、xmodem_serial_out向UART的发送Buffer写入数据，状态机方式，主要是考虑UART的发送buffer小于帧长；</p> 
<p>源码我就不发布了，没啥意义，需要配合我的协议解析引擎和queue队列才能使用。</p> 
<p> </p> 
<p>2018.07.30</p> 
<p>前几天看了遍代码，总是感觉哪里不对，但是又说不上来，今天看了个相似历程，算是明白自己的代码哪里有问题了：</p> 
<p>1、状态机太"复杂"了，这里的复杂是指一个函数里面跑了几个状态机，都在一个平面；不是说一个函数不能跑几个状态机，</p> 
<p>而是状态机应该是嵌套关系，不应该是平铺的关系；</p> 
<p>2、数据流程没有去抽象，用了一个很大的函数去处理，也就是没有所谓的层次感；</p> 
<p>总结就是，写代码应该是像搭积木，用一块块积木去拼凑自己的模型；而不应该是像摊大饼一样，平铺在一起。</p> 
<p>修改代码，回头再发上来。</p> 
<p>2018.08.02</p> 
<p>今天代码改造完了，有了纵向的层次感，想积木一样，一层一层搭建起来。但是里面仍然有一些根据初始化配置不同而处理</p> 
<p>逻辑不同，比如：长度是128还是1K，校验方式是校验和还是CRC16。这些怎么处理？</p> 
<p>我们可以这样处理，逻辑层抽象出通用的API接口，把上述四种情况封装成四个处理函数，然后在初始化时候根据不同的</p> 
<p>配置初始化指针，这样对于逻辑层来说处理逻辑完全是通用的。</p> 
<p> </p> 
<p>2018.08.16</p> 
<p>今天抽个时间把代码改了下，以前的处理逻辑是这样的：</p> 
<p>模式定义：</p> 
<pre class="has"><code class="hljs language-objectivec">typedef enum{
    XMODEM_128_SUM = 0,
    XMODEM_128_CRC16,
    XMODEM_1K_SUM,
    XMODEM_1K_CRC16,
}xmodem_select_mode_t;</code></pre> 
<p>初始化：</p> 
<pre class="has"><code class="hljs language-objectivec">bool xmodem_init(xmodem_t *ptXmodem,xmodem_cfg_t *ptCfg,user_api_t *ptApi)
{
    CLASS(xmodem_t)  *ptThis    =   (CLASS(xmodem_t) *)ptXmodem;
    if(NULL == ptThis || NULL == ptCfg || NULL == ptApi){
        return false;
    }

    if(NULL == ptApi-&gt;ptWriteBuffer     ||
       NULL == ptApi-&gt;ptStartTimer      ||
       NULL == ptApi-&gt;ptCheckTimerFlag  ||
       NULL == ptApi-&gt;ptSerialRead      ||
       NULL == ptApi-&gt;ptSerialWrite     ||
       NULL == ptCfg-&gt;pchBuffer           ){
        this.ptUserApi          = NULL;
        this.tUserApiIsInitFlag = false;
        return false;
    }

    this.tXmodemSelectMode             = ptCfg-&gt;tXmodemSelectMode;
    this.pchBuffer                     = ptCfg-&gt;pchBuffer;
    this.chByte                        = 0x00;

    this.ptUserApi                     = ptApi;
    this.tUserApiIsInitFlag            = true;

    return true;
}</code></pre> 
<p>下面的处理逻辑：</p> 
<pre class="has"><code class="hljs language-objectivec">                switch(this.tXmodemSelectMode){
                    case XMODEM_128_SUM:
                        //break;
                    case XMODEM_128_CRC16:
                        if(SOH == this.pchBuffer[s_hwRevCnt]){
                            s_tState = XMODEM_REV_FRAME_DATA;
                            s_hwRevCnt++;
                        }else if(EOT == this.pchBuffer[s_hwRevCnt]){
                            RST_XMODEM_REV_FRAME_FSM();
                            return XMODEM_REV_FRAME_RX_CPL;
                        }else{
                            //RST_XMODEM_REV_FRAME_FSM();
                            return  XMODEM_REV_FRAME_DROP;
                        }
                        break;
                    case XMODEM_1K_SUM:
                        //break;
                    case XMODEM_1K_CRC16:
                        if(STX == this.pchBuffer[s_hwRevCnt]){
                            s_tState = XMODEM_REV_FRAME_DATA;
                            s_hwRevCnt++;
                        }else if(EOT == this.pchBuffer[s_hwRevCnt]){
                            RST_XMODEM_REV_FRAME_FSM();
                            return XMODEM_REV_FRAME_RX_CPL;
                        }else{
                            //RST_XMODEM_REV_FRAME_FSM();
                            return  XMODEM_REV_FRAME_DROP;
                        }
                        break;
                    default:
                        while(1);
                }</code></pre> 
<pre class="has"><code class="hljs language-objectivec">         if(XMODEM_REV_FRAME_CPL == tTemp){
                s_hwRevCnt++;
                switch(this.tXmodemSelectMode){
                    case XMODEM_128_SUM:
                        if(132 &gt; s_hwRevCnt){
                            break;
                        }
                        chTemp = calsum(this.pchBuffer,s_hwRevCnt-1);
                        if(chTemp == this.pchBuffer[s_hwRevCnt-1]){
                            RST_XMODEM_REV_FRAME_FSM();
                            return XMODEM_REV_FRAME_CPL;
                        }else{
                            RST_XMODEM_REV_FRAME_FSM();
                            return XMODEM_REV_FRAME_CHECK_ERROR;
                        }
                        break;
                    case XMODEM_128_CRC16:
                        if(133 &gt; s_hwRevCnt){
                            break;
                        }
                        hwTemp = calcrc(this.pchBuffer,s_hwRevCnt-2);
                        tCrc16.chCrcL = this.pchBuffer[s_hwRevCnt-1];
                        tCrc16.chCrcH = this.pchBuffer[s_hwRevCnt-2];
                        if(tCrc16.hwCrc16 == hwTemp){
                            RST_XMODEM_REV_FRAME_FSM();
                            return XMODEM_REV_FRAME_CPL;
                        }else{
                            RST_XMODEM_REV_FRAME_FSM();
                            return XMODEM_REV_FRAME_CHECK_ERROR;
                        }
                        break;
                    case XMODEM_1K_SUM:
                        if(1028 &gt; s_hwRevCnt){
                            break;
                        }
                        chTemp = calsum(this.pchBuffer,s_hwRevCnt-1);
                        if(chTemp == this.pchBuffer[s_hwRevCnt-1]){
                            RST_XMODEM_REV_FRAME_FSM();
                            return XMODEM_REV_FRAME_CPL;
                        }else{
                            RST_XMODEM_REV_FRAME_FSM();
                            return XMODEM_REV_FRAME_CHECK_ERROR;
                        }
                        break;
                    case XMODEM_1K_CRC16:
                        if(1029 &gt; s_hwRevCnt){
                            break;
                        }
                        hwTemp = calcrc(this.pchBuffer,s_hwRevCnt-2);
                        tCrc16.chCrcL = this.pchBuffer[s_hwRevCnt-1];
                        tCrc16.chCrcH = this.pchBuffer[s_hwRevCnt-2];
                        if(tCrc16.hwCrc16 == hwTemp){
                            RST_XMODEM_REV_FRAME_FSM();
                            return XMODEM_REV_FRAME_CPL;
                        }else{
                            RST_XMODEM_REV_FRAME_FSM();
                            return XMODEM_REV_FRAME_CHECK_ERROR;
                        }
                        break;
                    default:
                        while(1);
                }</code></pre> 
<p>有几处代码都是类似的形式，看着是不是辣眼睛？后来改为了这样：</p> 
<p>初始化：</p> 
<pre class="has"><code class="hljs language-objectivec">bool xmodem_init(xmodem_t *ptXmodem,xmodem_cfg_t *ptCfg,user_api_t *ptApi)
{
    CLASS(xmodem_t)  *ptThis    =   (CLASS(xmodem_t) *)ptXmodem;
    if(NULL == ptThis || NULL == ptCfg || NULL == ptApi){
        return false;
    }

    if(NULL == ptApi-&gt;ptWriteBuffer     ||
       NULL == ptApi-&gt;ptStartTimer      ||
       NULL == ptApi-&gt;ptCheckTimerFlag  ||
       NULL == ptApi-&gt;ptSerialRead      ||
       NULL == ptApi-&gt;ptSerialWrite     ||
       NULL == ptCfg-&gt;pchBuffer           ){
        this.ptUserApi          = NULL;
        this.tUserApiIsInitFlag = false;
        return false;
    }

    switch(ptCfg-&gt;tXmodemSelectMode){
        case XMODEM_128_SUM:
            this.cRxFrameHead   =   SOH;
            this.hwRxFrameSize  =   128+3+1;
            this.cTxStartUp     =   SUM_SAT;
            this.ptXmodemCheck  =   xmodem_sum_check;
            break;
        case XMODEM_128_CRC16:
            this.cRxFrameHead   =   SOH;
            this.hwRxFrameSize  =   128+3+2;
            this.cTxStartUp     =   CRC16_SAT;
            this.ptXmodemCheck  =   xmodem_crc_check;
            break;
        case XMODEM_1K_SUM:
            this.cRxFrameHead   =   STX;
            this.hwRxFrameSize  =   1024+3+1;
            this.cTxStartUp     =   SUM_SAT;
            this.ptXmodemCheck  =   xmodem_sum_check;
            break;
        case XMODEM_1K_CRC16:
            this.cRxFrameHead   =   STX;
            this.hwRxFrameSize  =   1024+3+2;
            this.cTxStartUp     =   CRC16_SAT;
            this.ptXmodemCheck  =   xmodem_crc_check;
            break;
        default:
            return false;
    }
    this.pchBuffer                     = ptCfg-&gt;pchBuffer;
    this.chByte                        = 0x00;

    this.ptUserApi                     = ptApi;
    this.tUserApiIsInitFlag            = true;

    return true;
}</code></pre> 
<p>然后下面的处理：</p> 
<pre class="has"><code class="hljs language-objectivec">                if(this.cRxFrameHead == this.pchBuffer[s_hwRevCnt]){
                    s_tState = XMODEM_REV_FRAME_DATA;
                    s_hwRevCnt++;
                }else if(EOT == this.pchBuffer[s_hwRevCnt]){
                    RST_XMODEM_REV_FRAME_FSM();
                    return XMODEM_REV_FRAME_RX_CPL;
                }else{
                    //RST_XMODEM_REV_FRAME_FSM();
                    return  XMODEM_REV_FRAME_DROP;
                }</code></pre> 
<pre class="has"><code class="hljs language-objectivec">                s_hwRevCnt++;
                if(this.hwRxFrameSize &gt; s_hwRevCnt){
                    break;
                }
                if(this.ptXmodemCheck(ptXmodem)){
                    RST_XMODEM_REV_FRAME_FSM();
                    return XMODEM_REV_FRAME_CPL;                    
                }else{
                    RST_XMODEM_REV_FRAME_FSM();
                    return XMODEM_REV_FRAME_CHECK_ERROR;
                }</code></pre> 
<p>这样看是不是舒服很多。。。。。。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/66a5e709aadb04cca71a729beea7e165/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringMvc提交问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9b4ce7b4ec32f1af8d945fd99a6480a4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言写一个计算器的三种方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>