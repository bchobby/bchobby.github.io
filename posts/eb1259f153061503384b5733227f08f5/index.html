<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>给软件行业带来了春天——揭秘Spring究竟是何方神圣（一） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="给软件行业带来了春天——揭秘Spring究竟是何方神圣（一）" />
<meta property="og:description" content="系列文章目录 给软件行业带来了春天——揭秘Spring究竟是何方神圣（一）
给软件行业带来了春天——揭秘Spring究竟是何方神圣（二）
给软件行业带来了春天——揭秘Spring究竟是何方神圣（三）
给软件行业带来了春天——揭秘Spring究竟是何方神圣（四）
给软件行业带来了春天——揭秘Spring究竟是何方神圣（五）
文章目录 系列文章目录简介Spring核心知识点SpringIOC创建对象方法一：调用无参数构造器创建对象方法二：调用有参构造方法来创建对象方法三：使用静态工厂方法创建对象方法四：使用实例工厂方法来创建对象方法五：使用实例工厂创建对象 DI依赖注入基于对象属性set方法进行注入利用构造器方式进行注入p名称空间注入集合类型属性注入util标签注入 bean的常见属性作用域生命周期自动装配 SpringBean的注解形式 简介 Spring是一个JavaEE开源的轻量级别的框架，可以解决我们企业开发中遇到的难题，能够让编码变的更加简单，核心组件IOC容器和Aop面向切面编程。 spring优点：
方便解耦，简化开发管理对象集成其他框架Junit单元测试方便进行事务操作降低API开发难度 spring框架图
Spring 是模块化的。
Core 容器
Core 容器由 Core、Beans、Context 和 Expression Language 模块组成。
Core 模块提供了框架的基本部分，包括 IoC 和依赖注入功能。Bean 模块提供了 BeanFactory，它是工厂模式的一个复杂的实现。Context 模块建立在 Core 和 Beans 模块提供的坚实基础之上，它是访问任何已定义和配置的对象的媒介。 ApplicationContext 接口是上下文模块的焦点。SpEL 模块提供了一种强大的表达式语言，用于在运行时查询和操作对象图。 数据访问/集成
数据访问/集成层由 JDBC、ORM、OXM、JMS 和 Transaction 事务模块组成。
JDBC 模块提供了一个 JDBC 抽象层，它消除了繁琐的 JDBC 相关编码的需要。ORM 模块为流行的对象关系映射 API 提供集成层，包括 JPA、JDO、Hibernate 和 iBatis。OXM 模块提供了一个抽象层，它支持 JAXB、Castor、XMLBeans、JiBX 和 XStream 的 Object/XML 映射实现。Java 消息传递服务 JMS 模块包含用于生成和使用消息的功能。Transaction 模块支持对实现特殊接口的类和所有 POJO 的编程和声明式事务管理。 Web" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/eb1259f153061503384b5733227f08f5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-26T10:55:49+08:00" />
<meta property="article:modified_time" content="2023-12-26T10:55:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">给软件行业带来了春天——揭秘Spring究竟是何方神圣（一）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_1"></a>系列文章目录</h2> 
<p><a href="https://blog.csdn.net/2301_82095378/article/details/135148118?spm=1001.2014.3001.5502">给软件行业带来了春天——揭秘Spring究竟是何方神圣（一）</a><br> <a href="https://blog.csdn.net/2301_82095378/article/details/135167193?spm=1001.2014.3001.5501">给软件行业带来了春天——揭秘Spring究竟是何方神圣（二）</a><br> <a href="https://blog.csdn.net/2301_82095378/article/details/135179334?spm=1001.2014.3001.5501">给软件行业带来了春天——揭秘Spring究竟是何方神圣（三）</a><br> <a href="https://blog.csdn.net/2301_82095378/article/details/135202830?spm=1001.2014.3001.5501">给软件行业带来了春天——揭秘Spring究竟是何方神圣（四）</a><br> <a href="https://blog.csdn.net/2301_82095378/article/details/135216260?spm=1001.2014.3001.5501">给软件行业带来了春天——揭秘Spring究竟是何方神圣（五）</a></p> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">系列文章目录</a></li><li><ul><li><a href="#_19" rel="nofollow">简介</a></li><li><a href="#Spring_79" rel="nofollow">Spring核心知识点</a></li><li><ul><li><a href="#SpringIOC_81" rel="nofollow">SpringIOC</a></li><li><ul><li><a href="#_87" rel="nofollow">创建对象</a></li><li><ul><li><a href="#_101" rel="nofollow">方法一：调用无参数构造器创建对象</a></li><li><a href="#_132" rel="nofollow">方法二：调用有参构造方法来创建对象</a></li><li><a href="#_174" rel="nofollow">方法三：使用静态工厂方法创建对象</a></li><li><a href="#_214" rel="nofollow">方法四：使用实例工厂方法来创建对象</a></li><li><a href="#_257" rel="nofollow">方法五：使用实例工厂创建对象</a></li></ul> 
     </li><li><a href="#DI_305" rel="nofollow">DI依赖注入</a></li><li><ul><li><a href="#set_310" rel="nofollow">基于对象属性set方法进行注入</a></li><li><a href="#_412" rel="nofollow">利用构造器方式进行注入</a></li><li><a href="#p_471" rel="nofollow">p名称空间注入</a></li><li><a href="#_490" rel="nofollow">集合类型属性注入</a></li><li><a href="#util_606" rel="nofollow">util标签注入</a></li></ul> 
     </li><li><a href="#bean_649" rel="nofollow">bean的常见属性</a></li><li><ul><li><a href="#_651" rel="nofollow">作用域</a></li><li><a href="#_674" rel="nofollow">生命周期</a></li><li><a href="#_691" rel="nofollow">自动装配</a></li></ul> 
     </li><li><a href="#SpringBean_705" rel="nofollow">SpringBean的注解形式</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<p><img src="https://images2.imgbox.com/59/b3/h5e8WwEz_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_19"></a>简介</h3> 
<pre><code>    Spring是一个JavaEE开源的轻量级别的框架，可以解决我们企业开发中遇到的难题，能够让编码变的更加简单，核心组件IOC容器和Aop面向切面编程。
</code></pre> 
<p><strong>spring优点：</strong></p> 
<ul><li>方便解耦，简化开发</li><li>管理对象</li><li>集成其他框架</li><li>Junit单元测试</li><li>方便进行事务操作</li><li>降低API开发难度</li></ul> 
<p><strong>spring框架图</strong><img src="https://images2.imgbox.com/79/30/q2HGmfoF_o.png" alt="image.png"><br><br> <strong>Spring 是模块化的。</strong><br><br> <strong>Core 容器</strong><br>Core 容器由 Core、Beans、Context 和 Expression Language 模块组成。</p> 
<ul><li><strong>Core</strong> 模块提供了框架的基本部分，包括 IoC 和依赖注入功能。</li><li><strong>Bean</strong> 模块提供了 BeanFactory，它是工厂模式的一个复杂的实现。</li><li><strong>Context</strong> 模块建立在 Core 和 Beans 模块提供的坚实基础之上，它是访问任何已定义和配置的对象的媒介。 ApplicationContext 接口是上下文模块的焦点。</li><li><strong>SpEL</strong> 模块提供了一种强大的表达式语言，用于在运行时查询和操作对象图。</li></ul> 
<p><strong>数据访问/集成</strong><br> <br>数据访问/集成层由 JDBC、ORM、OXM、JMS 和 Transaction 事务模块组成。</p> 
<ul><li><strong>JDBC</strong> 模块提供了一个 JDBC 抽象层，它消除了繁琐的 JDBC 相关编码的需要。</li><li><strong>ORM</strong> 模块为流行的对象关系映射 API 提供集成层，包括 JPA、JDO、Hibernate 和 iBatis。</li><li><strong>OXM</strong> 模块提供了一个抽象层，它支持 JAXB、Castor、XMLBeans、JiBX 和 XStream 的 Object/XML 映射实现。</li><li>Java 消息传递服务 <strong>JMS</strong> 模块包含用于生成和使用消息的功能。</li><li><strong>Transaction</strong> 模块支持对实现特殊接口的类和所有 POJO 的编程和声明式事务管理。</li></ul> 
<p><strong>Web</strong><br> <br>Web 层由 Web、Web-MVC、Web-Socket 和 Web-Portlet 模块组成。</p> 
<ul><li><strong>Web</strong> 模块提供了基本的面向 Web 的集成功能，例如多部分文件上传功能以及使用 servlet 侦听器和面向 Web 的应用程序上下文初始化 IoC 容器。</li><li><strong>Web-MVC</strong> 模块包含 Spring 的 Web 应用程序的 Model-View-Controller(模型-视图-控制器) (MVC) 实现。</li><li><strong>Web-Socket</strong> 模块支持 Web 应用程序中客户端和服务器之间基于 WebSocket 的双向通信。</li><li><strong>Web-Portlet</strong> 模块提供了在portlet 环境中使用的MVC 实现，并反映了Web-Servlet 模块的功能。</li></ul> 
<p><strong>其他</strong><br> <br>如 AOP、Aspects、Instrumentation、Web 和 Test 模块。</p> 
<ul><li><strong>AOP</strong> 模块提供了一个面向方面的编程实现，允许您定义方法拦截器和切入点，以清晰地解耦实现应该分离的功能的代码。</li><li><strong>Aspects</strong> 模块提供与 AspectJ 的集成，AspectJ 又是一个强大且成熟的 AOP 框架。</li><li><strong>Instrumentation</strong> 模块提供类检测支持和类加载器实现以用于某些应用程序服务器。</li><li><strong>Messaging</strong> 模块支持将 STOMP 作为 WebSocket 子协议在应用程序中使用。 它还支持注解编程模型，用于路由和处理来自 WebSocket 客户端的 STOMP 消息。</li><li><strong>Test</strong> 模块支持使用 JUnit 或 TestNG 框架对 Spring 组件进行测试。</li></ul> 
<p><strong>Spring核心特性:</strong><br> <br><img src="https://images2.imgbox.com/9e/5f/QOaIedrY_o.png" alt="image.png"><br><br> <strong>依赖注入 (DI):</strong><br> <br><strong>Inversion of Control (IoC)</strong> 控制反转是一个通用概念，可以用多种不同的方式表达。 依赖注入只是控制反转的一个具体例子。在编写复杂的 Java 应用程序时，应用程序类应尽可能独立于其他 Java 类，以增加重用这些类的可能性，并在单元测试时独立于其他类对其进行测试。 依赖注入有助于将这些类粘合在一起，同时保持它们的独立性。<br>依赖注入简单来说，例如，依赖，A 类依赖于B类。注入就意味着，B 类将被 IoC 注入到 A 类中。</p> 
<hr> 
<p><strong>面向切面编程（AOP）</strong><br> <br>跨越应用程序多个点的功能称为<strong>横切关注点</strong>，这些横切关注点在概念上与应用程序的业务逻辑分开。 有各种常见的好例子，包括日志记录、声明式事务、安全性、缓存等。<br>OOP 中模块化的关键单元是类，而 AOP 中模块化的单元是方面。 DI 可帮助您将应用程序对象彼此分离，而 AOP 可帮助您将横切关注点与它们影响的对象分离。<br>面向切面是一种思想，不是具体的框架，也不是具体的代码。<br>更多消息可以去官方文档查看。<br> <br>spring的官网:<a href="https://spring.io/" rel="nofollow">Home</a><br>Spring官方下载依赖jar包地址：<a href="https://repo.spring.io/webapp/#/artifacts/browse/tree/General/libs-release-local/org/springframework/spring" rel="nofollow">JFrog</a><br> spring教程：<a href="https://www.w3schools.cn/spring/index.html" rel="nofollow">Spring 教程</a><br> </p> 
<h3><a id="Spring_79"></a>Spring核心知识点</h3> 
<p></p> 
<h4><a id="SpringIOC_81"></a>SpringIOC</h4> 
<p><strong>IOC(Inversion of Control) 控制反转</strong>是一种面对对象编程的设计原则，用于降低代码之间的耦合度。IOC容器主要作用就是创建对象和处理对象之间的依赖关系。<br><strong>Bean的管理</strong></p> 
<ul><li>使用spring创建对象</li><li>使用spring注入属性<br> </li></ul> 
<h5><a id="_87"></a>创建对象</h5> 
<ol><li>单独new方式—耦合度太高</li></ol> 
<p>每次单独new对象，没有实现统一管理对象，如果后期userDao的名称信息发生变化的情况下，需要改变的引用地方比较多，耦合度太高。</p> 
<ol start="2"><li>工厂模式—降低我们耦合度</li></ol> 
<p>概念：统一的管理和维护我们每个对象创建与使用的过程。<br>不需要自己new对象。</p> 
<ol start="3"><li>反射的方式</li></ol> 
<p>降低代码的-耦合度<br><strong>反射创建对象</strong><br> </p> 
<h6><a id="_101"></a>方法一：调用无参数构造器创建对象</h6> 
<ul><li>利用无参构造器</li><li>给类添加一个无参构造器（缺省构造器）</li><li>配置bean元素</li><li>调用容器的getbean</li></ul> 
<pre><code>public class  Fast {
    public Fast() {
		System.out.println("spring创建对象方式一：通过无参构造方法");
	}
}

</code></pre> 
<pre><code>&lt;!--
    使用无参构造器创建对象
    id属性：bean的名称，要求唯一
    class属性：类的全名
    --&gt;
    &lt;bean id="Fast" class="Fast"&gt;&lt;/bean&gt;
</code></pre> 
<pre><code>@Test
public void test01(){
   ApplicationContext applicationContext=
							new ClassPathXmlApplicationContext("bean.xml");
}
</code></pre> 
<p>输出：<img src="https://images2.imgbox.com/e2/a0/dH4SaPqR_o.png" alt="image.png"><br> </p> 
<h6><a id="_132"></a>方法二：调用有参构造方法来创建对象</h6> 
<pre><code>public class Slow {

    private Integer id;
    private String name;

    public Slow(Integer id,String name){

        //super();
        this.id = id;
        this.name = name;
        System.out.println("spring创建对象方式2：通过有参构造方法"+"\n"+id+"-"+name);
    }

}
</code></pre> 
<pre><code>&lt;bean id="slow" class="Slow"&gt;
        &lt;!--
        		constructor-arg:是有参构造方法的使用标签
        		index:参数的索引,从 0 开始
        		name: 参数名
        		type:参数类型(区分开关键字和封装类 int 和 Integer)

        		此时的创建对象相当于：SomeBean2 bean=new SomeBean2(1,"alice");
        	  --&gt;

        &lt;constructor-arg index="0" name="id" type="java.lang.Integer" value="1"/&gt;
        &lt;constructor-arg index="1" name="name" type="java.lang.String" value="alice"/&gt;
    &lt;/bean&gt;
</code></pre> 
<pre><code>@Test
public void test01(){
   ApplicationContext applicationContext=
							new ClassPathXmlApplicationContext("bean.xml");
}
</code></pre> 
<p>输出：<img src="https://images2.imgbox.com/b5/4e/NaYvcUK8_o.png" alt="image.png"></p> 
<p></p> 
<h6><a id="_174"></a>方法三：使用静态工厂方法创建对象</h6> 
<p><strong>通过调用类的静态工厂方法来创建对象</strong></p> 
<pre><code>public class  Fast {
    public Fast() {
        System.out.println("spring创建对象第3种方式：通过静态方法工厂创建");
    }
}

</code></pre> 
<pre><code>public class FastFactory {

    public static Fast getInstance(){
        System.out.println("通过静态方法工厂创建对象");
        return new Fast();
      //相当于Fast.getInstance();

    }
}
</code></pre> 
<pre><code> &lt;!--
    使用静态工厂方法创建对象
    factory-method属性：指定一个静态方法，spring容器会调用这个静态方法来创建对象

    --&gt;
    &lt;bean id="FastFactory"
          class="FastFactory"
          factory-method="getInstance"&gt;&lt;/bean&gt;
</code></pre> 
<pre><code>@Test
public void test01(){
   ApplicationContext applicationContext=
							new ClassPathXmlApplicationContext("bean.xml");
}
</code></pre> 
<p>输出：<img src="https://images2.imgbox.com/df/d3/cHeGZxSg_o.png" alt="image.png"><br> </p> 
<h6><a id="_214"></a>方法四：使用实例工厂方法来创建对象</h6> 
<p><strong>调用对象的实例方法来创建对象</strong></p> 
<pre><code>public class cost {

    public cost(){
        System.out.println("通过实例工厂创建对象");
    }
}

</code></pre> 
<pre><code>public class costFactory {

    public cost getInstance(){
        return new cost();
    }

}
</code></pre> 
<pre><code> &lt;!--通过实例工厂创建对象
     使用实例工厂方法来创建对象
   factory-bean属性：指定一个bean的ID，
   factory-method属性:指定一个方法
   spring容器会调用这个bean的对应的方法来创建对象。

    costFactory factory=new costFactory();
    cost cost=factory.getInstance();--&gt;

    &lt;bean id="factory" class="costFactory"&gt;&lt;/bean&gt;

    &lt;bean id="cost" factory-bean="factory" factory-method="getInstance"&gt;&lt;/bean&gt;
</code></pre> 
<pre><code>@Test
public void test01(){
   ApplicationContext applicationContext=
							new ClassPathXmlApplicationContext("bean.xml");
}
</code></pre> 
<p>输出：<img src="https://images2.imgbox.com/0d/2a/5M6xx2yP_o.png" alt="image.png"><br> </p> 
<h6><a id="_257"></a>方法五：使用实例工厂创建对象</h6> 
<pre><code>
public class messageBean {

    public messageBean(){

        System.out.println("通过实现FactoryBean接口实现对象的创建");

    }
}

</code></pre> 
<pre><code>public class bean implements FactoryBean&lt;messageBean&gt; {
    @Override
    public messageBean getObject() throws Exception {
        return null;
    }

    @Override
    public Class&lt;?&gt; getObjectType() {
        return null;
    }

    @Override
    public boolean isSingleton() {
        return true;
    }
}
</code></pre> 
<pre><code> &lt;!--通过factorybean 来创建对象--&gt;
    &lt;bean id="factotybean" class="bean"&gt;&lt;/bean&gt;
</code></pre> 
<pre><code>@Test
    public void test01(){

        ApplicationContext applicationContext=
                new ClassPathXmlApplicationContext("applicationContext.xml");
        messageBean bean=applicationContext.getBean("factotybean", messageBean.class);

    }
</code></pre> 
<p>输出：<img src="https://images2.imgbox.com/26/05/OSexWPHL_o.png" alt="image.png"></p> 
<p></p> 
<h5><a id="DI_305"></a>DI依赖注入</h5> 
<p><strong>spring容器通过调用对象提供的set方法或者构造器来建立依赖关系。</strong><br>依赖关系的创建流程<br>spring 容器启动后读取配置文件</p> 
<p><img src="https://images2.imgbox.com/7d/b1/yzreG4zk_o.png" alt="image.png"><br><img src="https://images2.imgbox.com/c9/63/HN4yuXsp_o.png" alt="image.png"><br> </p> 
<h6><a id="set_310"></a>基于对象属性set方法进行注入</h6> 
<p>在Bean标签下 在定义一个属性&lt;<strong>property&gt;标签</strong></p> 
<ul><li>property元素：表示使用set方法来注入依赖关系</li></ul> 
<p>属性值包含特殊符号<br>1 把&lt;&gt;进行转义 &lt; &gt;<br>2 把带特殊符号内容写到CDATA</p> 
<pre><code>   &lt;!--&lt;property name="bookName" value="&lt;&lt;武汉&gt;&gt;"&gt;&lt;/property&gt; --&gt;
    &lt;property name="bookName"&gt;
        &lt;value&gt;&lt;![CDATA[&lt;&lt;武汉&gt;&gt;]]&gt;&lt;/value&gt;
    &lt;/property&gt;
</code></pre> 
<ul><li>name属性：指定属性值</li><li>ref属性：指定属性值（是被注入的bean的ID）</li></ul> 
<pre><code> &lt;!--
    property元素：表示使用set方法来注入依赖关系
    name属性：指定属性值
    ref属性：指定属性值（是被注入的bean的ID）
		&lt;!--null值--&gt;
        &lt;property name="address"&gt;&lt;null/&gt;&lt;/property&gt;

        &lt;!--属性值包含特殊符号
          	1 把&lt;&gt;进行转义 &amp;lt; &amp;gt;
						2 把带特殊符号内容写到CDATA --&gt;
    &lt;property name="address"&gt;&lt;value&gt;&lt;![CDATA[&lt;&lt;上海&gt;&gt;]]&gt;&lt;/value&gt;
    &lt;/property&gt;
    --&gt;


  	//注入属性 外部bean
  	&lt;bean id="dc1" class="ioc.dc"&gt;
    &lt;bean id="db1" class="ioc.db"&gt;
        &lt;property name="di" ref="dc1"&gt;&lt;/property&gt;
    &lt;/bean&gt;
</code></pre> 
<pre><code>public class db {
    private IB di;
		private String name;
    public void setName(String name) {
        this.name = name;
    }

    public void setDi(IB di) {
        this.di = di;
        System.out.println("调用了方法");
    }
}
</code></pre> 
<pre><code>public class di implements IB{
		private String diname;

    public di(){

    }
 		public void setDiname(String diname) {
        this.diname = diname;
    }

    public void f1(){
        System.out.println("注入bean的属性");
    }

}
</code></pre> 
<pre><code>   /*test01
    测试set方式的注入
    * */
    @Test
    public void test01(){

        db db=abstractApplicationContext.getBean("db1",ioc.db.class);
        logger.info("依赖注入成功。");

    }
</code></pre> 
<p>输出： <img src="https://images2.imgbox.com/94/0e/XqddJltE_o.png" alt="image.png"></p> 
<p><strong>注入属性—外部bean</strong></p> 
<pre><code>//注入属性 外部bean
  	&lt;bean id="dc1" class="ioc.dc"&gt;
    &lt;bean id="db1" class="ioc.db"&gt;
        &lt;property name="di" ref="dc1"&gt;&lt;/property&gt;
    &lt;/bean&gt;
</code></pre> 
<p><strong>注入属性—内部bean</strong></p> 
<pre><code>//注入属性---内部bean
&lt;property name="name" value="mysql"&gt;&lt;/property&gt;
        &lt;property name="di" &gt;
            &lt;bean id="di2" class="ioc.di"&gt;
                &lt;property name="diname" value="MYSQL AB"&gt;&lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
</code></pre> 
<p></p> 
<h6><a id="_412"></a>利用构造器方式进行注入</h6> 
<p>在Bean标签下 在定义一个属性**标签**<br>constructor-arg 元素：构造器方式注入<br>name 指定参数列表名称_，_** **index 指定参数列表索引，参数的下标（从0 开始）</p> 
<pre><code>public class A {
    private B b;
    public A(){

        System.out.println("A");
    }
    public A(B b){
        System.out.println("构造器方式注入");
        this.b=b;
    }
    public void execute(){
       System.out.println("成功注入");
       b.f1();
    }
}
</code></pre> 
<pre><code>public class B {

    public B(){
        System.out.println("对象被创建");
    }

    public void execute(){
        System.out.println("execute");
    }

    public void f1(){
        System.out.println("被成功注入");
    }

}
</code></pre> 
<pre><code>&lt;!--
    constructor-arg 元素：构造器方式注入，其中，index 属性指定参数的下标（从0 开始）
    --&gt;
    &lt;bean id="b1" class="DI.B"&gt;&lt;/bean&gt;
    &lt;bean id="a1" class="DI.A"&gt;
        &lt;constructor-arg index="0" ref="b1"&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
</code></pre> 
<pre><code> /*
    * 构造器注入
    * */
    @Test
    public void test01(){
        A a1=applicationContext.getBean("a1",A.class);
        a1.execute();
        logger.info("构造器方式注入完成");
    }
</code></pre> 
<p>输出：<img src="https://images2.imgbox.com/ae/43/fLUT3R9F_o.png" alt="image.png"><br> </p> 
<h6><a id="p_471"></a>p名称空间注入</h6> 
<p>Xml头部引入P标签：</p> 
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;
&lt;/bean&gt;
</code></pre> 
<p>使用p标签注入属性：</p> 
<pre><code>&lt;bean id="Book" class="book" p:bookName="books" p:bookPrice="66"&gt;
&lt;/bean&gt;
</code></pre> 
<p>p名称注入也是调用了set 方法注入属性。</p> 
<p></p> 
<h6><a id="_490"></a>集合类型属性注入</h6> 
<ol><li>注入数组类型<br>2. 注入list集合类型<br>3. 注入Map集合类型属性<br>4. 注入set集合属性</li></ol> 
<pre><code>public class stu {

    //四种类型属性
    private String[] courses;
    private List&lt;String&gt; list;
    private Map&lt;String,String&gt; map;
    private Set&lt;String&gt; set;

    //学生所学多门课程
    private List&lt;course&gt; courseList;
    public void setCourseList(List&lt;course&gt; courseList) {
        this.courseList = courseList;
    }

    public String[] getCourses() {
        return courses;
    }

    public void setCourses(String[] courses) {
        this.courses = courses;
    }

    public List&lt;String&gt; getList() {
        return list;
    }

    public void setList(List&lt;String&gt; list) {
        this.list = list;
    }

    public Map&lt;String, String&gt; getMap() {
        return map;
    }

    public void setMap(Map&lt;String, String&gt; map) {
        this.map = map;
    }

    public Set&lt;String&gt; getSet() {
        return set;
    }

    public void setSet(Set&lt;String&gt; set) {
        this.set = set;
    }
}
</code></pre> 
<pre><code>   &lt;!--1 集合类型属性注入--&gt;
    &lt;bean id="stu" class="bean_stu.stu"&gt;
        &lt;!--数组类型属性注入--&gt;
        &lt;property name="courses"&gt;
            &lt;array&gt;
                &lt;value&gt;体育&lt;/value&gt;
                &lt;value&gt;数学&lt;/value&gt;
            &lt;/array&gt;
        &lt;/property&gt;
        &lt;!--list类型属性注入--&gt;
        &lt;property name="list"&gt;
            &lt;list&gt;
                &lt;value&gt;张三&lt;/value&gt;
                &lt;value&gt;小三&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!--map类型属性注入--&gt;
        &lt;property name="map"&gt;
            &lt;map&gt;
                &lt;entry key="soccer" value="足球"&gt;&lt;/entry&gt;
                &lt;entry key="basketball" value="篮球"&gt;&lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;!--set类型属性注入--&gt;
        &lt;property name="set"&gt;
            &lt;set&gt;
                &lt;value&gt;SQL&lt;/value&gt;
                &lt;value&gt;Java&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;

</code></pre> 
<pre><code> @Test
    public void test01(){
        AbstractApplicationContext abstractApplicationContext=new ClassPathXmlApplicationContext("bean2.xml");
         stu stu=abstractApplicationContext.getBean("stu", bean_stu.stu.class);
         String str= JSONObject.toJSONString(stu);
         logger.info(str);
    }
</code></pre> 
<p>输出<img src="https://images2.imgbox.com/62/f6/pFP7J9LB_o.png" alt="image.png"></p> 
<p>集合里设置对象类型的值</p> 
<pre><code>&lt;!--创建多个course对象--&gt;
    &lt;bean id="course1" class="bean_stu.course"&gt;
        &lt;property name="cname" value="PHP"&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id="course2" class="bean_stu.course"&gt;
        &lt;property name="cname" value="C++"&gt;&lt;/property&gt;
    &lt;/bean&gt;

        &lt;!--注入list集合类型，值是对象--&gt;
        &lt;property name="courseList"&gt;
            &lt;list&gt;
                &lt;ref bean="course1"&gt;&lt;/ref&gt;
                &lt;ref bean="course2"&gt;&lt;/ref&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

</code></pre> 
<p></p> 
<h6><a id="util_606"></a>util标签注入</h6> 
<p>util ：命名空间，用以区分。</p> 
<ul><li>先引入一个util名称空间,将集合类型的值配置成一个bean，借用引用的方式注入集合，set等</li></ul> 
<pre><code>&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd"&gt;


&lt;!--1 提取list集合类型属性注入--&gt;
    &lt;util:list id="bookList"&gt;
        &lt;value&gt;A&lt;/value&gt;
        &lt;value&gt;B&lt;/value&gt;
        &lt;value&gt;C&lt;/value&gt;
    &lt;/util:list&gt;

    &lt;!--2 提取list集合类型属性注入使用  单例和多例--&gt;
    &lt;bean id="book" class="bean_stu.book" scope="prototype"&gt;
        &lt;property name="list" ref="bookList"&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre> 
<ul><li>使用util标签读取properties 文件的内容</li></ul> 
<p>classpath:按照类的路径来搜索<br>spring 容器会依据路径来找对对应的properties文件，然后读取该文件的内容到properties</p> 
<pre><code> &lt;util:properties id="config" location="classpath:config.properties"&gt;&lt;/util:properties&gt;
</code></pre> 
<ul><li>注入spring表达式</li></ul> 
<pre><code> &lt;bean id="sp1" class="res.SpelBean"&gt;
        &lt;property name="name" value="#{vb1.name}"&gt;&lt;/property&gt;
        &lt;property name="age" value="#{vb1.age}"&gt;&lt;/property&gt;
        &lt;property name="city" value="#{vb1.city[1]}"&gt;&lt;/property&gt;
        &lt;property name="score"  value="#{vb1.score.english}"&gt;&lt;/property&gt;
        &lt;property name="pageSize" value="#{vb1.pageSize}"&gt;&lt;/property&gt;
    &lt;/bean&gt;
</code></pre> 
<p></p> 
<h5><a id="bean_649"></a>bean的常见属性</h5> 
<p></p> 
<h6><a id="_651"></a>作用域</h6> 
<table><thead><tr><th>作用域</th><th>描述</th></tr></thead><tbody><tr><td>singleton</td><td>在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，bean作用域范围的默认值。</td></tr><tr><td>prototype</td><td>每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。</td></tr><tr><td>request</td><td>每次HTTP请求都会创建一个新的Bean，该作用域仅适用于web的Spring WebApplicationContext环境。</td></tr><tr><td>session</td><td>同一个HTTP Session共享一个Bean，不同Session使用不同的Bean。该作用域仅适用于web的Spring WebApplicationContext环境。</td></tr><tr><td>application</td><td>限定一个Bean的作用域为ServletContext的生命周期。该作用域仅适用于web的Spring WebApplicationContext环境。</td></tr></tbody></table> 
<pre><code>&lt;!--scope 属性： 用来配置作用域，缺省值为 singleton(即一个bean只能创建一个实例)
      如果值为prototype（即一个bean会创建多个实例）--&gt;
    &lt;bean id="s2" class="cost" scope="prototype"&gt;&lt;/bean&gt;
    &lt;bean id="s4"  class="cost"  scope="singleton"&gt;&lt;/bean&gt;
    &lt;bean id="s5" class="cost" scope="session"&gt;&lt;/bean&gt;
</code></pre> 
<pre><code>&lt;!-- A bean definition with singleton scope --&gt;
&lt;bean id="..." class="..." scope="singleton"&gt;
&lt;!-- collaborators and configuration for this bean go here --&gt;
&lt;/bean&gt;
</code></pre> 
<p></p> 
<h6><a id="_674"></a>生命周期</h6> 
<p>生命周期：初始化，分配资源 销毁 释放资源。</p> 
<pre><code>    &lt;!--生命周期：初始化，分配资源 销毁 释放资源。
    init-method属性:指定初始化方法：
    destroy-method属性：指定销毁方法 不过如果作用域为单例时，销毁方法才执行。
    lazy-init属性：指定是否延迟加载，如果为TRUE，表示延迟加载，容器不会直接创建bean实例。

    --&gt;
    &lt;bean id="messageBean1" class="init.messageBean" 
		init-method="init" destroy-method="destroy" lazy-init="true"&gt;
    &lt;/bean&gt;

    &lt;bean id="ExampleBean1" class="init.ExampleBean" 
		init-method="init" destroy-method="destroy" lazy-init="true"&gt;&lt;/bean&gt;
</code></pre> 
<p></p> 
<h6><a id="_691"></a>自动装配</h6> 
<p>自动装配指的是spring容器依据某种规则，自动建立对象之间的依赖关系<br>（默认情况下，容器不会自动装配。）可以通过指定autowire属性来告诉容器进行自动装配（容器实际上还是通过调用set方法或者构造器来完成依赖关系的建立。）</p> 
<ul><li>autowire属性: 自动装配，属性有三个值</li><li>byName ：容器依据属性名来查找对对应的bean，然后调用对应的set方法来完成注入。如果找不到对应的bean，注入为null。不可能找到多个符合条件。</li><li>byType:容器依据属性类型来查找对应的bean,然后调用对应的set方法来完成注入。如果找不到对应的bean，注入null,有可能找到多个符合条件的bean，此时会 出错。</li><li>constructor: 与byType类似，不同的是调用对应的构造器的来完成注入。</li></ul> 
<pre><code>&lt;bean id="wt" class="res.Waiter"&gt;&lt;/bean&gt;
&lt;bean id="res1" class="res.Restaurant" autowire="byType"&gt;
&lt;/bean&gt;
</code></pre> 
<p></p> 
<h5><a id="SpringBean_705"></a>SpringBean的注解形式</h5> 
<p><strong>注解：注解是JDK5中推出的新特性，代码的特殊标记。</strong></p> 
<blockquote> 
 <ol><li>基于XML方式实现</li><li>基于注解方式实现</li></ol> 
</blockquote> 
<p>注解可以使用在类、方法、属性上面。<br>使用注解的目的，简化xml的配置方式。<br><strong>配置组件扫描</strong><br>base-package属性：指定要扫描的包名，spring容器会扫描该包及其子包下面的所有的类，如果该类前面有特定的注解。<br>(比如@Component),则spring容器会将其纳入容器进行管理（相当于这儿配置了一个bean元素）</p> 
<pre><code>   通过注解来指定作用域
    &lt;context:component-scan base-package="somebean"&gt;&lt;/context:component-scan&gt;
</code></pre> 
<p>自动扫描的注解标记<br><img src="https://images2.imgbox.com/b4/38/JlbVsKrE_o.png" alt="image.png"><br>Spring提供的常用注解</p> 
<ul><li>@Component 将对象注入Spring容器中</li><li>@Service 注入业务逻辑对象</li><li>@Controller 控制器类</li><li>@Repository 注入dao对象</li></ul> 
<p>以上该四个注解底层都是基于@Component注解封装的，只是用于区分。<br><strong>部分其他注解</strong><br><strong>@Autowired @Qualifier</strong></p> 
<ul><li>该注解支只持setter方式和构造器方式注解。当采用set方式注入时，可以将@Autowired添加到set方法前面，如果不使用@Qualifier，则容器会使用byType方式来注入，有可能出错。</li><li>使用@Qualifier 明确要注入的对象类型id的bean的ID</li><li>也可以直接将两个注解直接添加到属性前面，这样利用Java的反射机制，即使没有set方法，也可以。不过只会赋值，不会进行其他操作。</li><li>当采用构造器注入时，可以将该注解添加到对应的构造器前面。</li></ul> 
<pre><code>@Component("res")
public class res {

   /* @Autowired
    @Qualifier("wt3")*/

    private Waiter wt;

    public Waiter getWt() {
        return wt;
    }

    @Autowired
    public void setWt(//注入进来的对象，类似于byName的属性。
            @Qualifier("wt3") Waiter wt) {
        this.wt = wt;
        System.out.println("测试：服务员");
    }
    public res(){
        System.out.println("res()");
    }
}

</code></pre> 
<p>@Resource<br>只支持set方式注入<br>可以将该注解添加属性前，使用name属性指定要注入的bean的ID，（不指定会按照byType方式进行注入）<br>可以将该注解添加到属性前。</p> 
<pre><code>@Component("bar")
public class Bar {
    private Waiter wt;
    public Waiter getWt() {
        return wt;
    }
    @Resource(name = "wt3")
    public void setWt(Waiter wt) {
        this.wt = wt;
    }

    public Bar(){
        System.out.println("11");
    }
    
}
</code></pre> 
<p>@Value注解<br>可以使用该注解来注入基本类型的值<br>也可以使用该注解来使用spring表达式<br>该注解可以添加到属性前，或者添加到对应的set方法前。</p> 
<pre><code>@Value("#{config.pagesize}")
    private String pageSize;
</code></pre> 
<p>@Configuration 注解<br>作为配置类，替代 xml 配置文件</p> 
<pre><code>@Configuration //作为配置类，替代 xml 配置文件
@ComponentScan(basePackages = { "bean"})
public class SpringConfig {
}
</code></pre> 
<p>注解实例</p> 
<pre><code>@Component("b1")
@Scope("singleton")//单例和多例
@Lazy(true)//延迟加载
public class bean {

  	@Value("#{config.pagesize}")
    private String pageSize;

    @Value("alice")
    private String name;

    @PostConstruct
    //初始化方法
    public void init(){
        System.out.println("初始化");
    }
    @PreDestroy
  	//销毁方法
    public void destroy(){
        System.out.println("销毁");
    }
  	
    public bean(){
        System.out.println("bean()");
    }

  	@Bean(name="Bean")
    public bean getBean(){
        bean bean = new bean();
        System.out.println("调用方法："+bean);
        return bean;
    }

}
</code></pre> 
<p>在本文中，我们揭开了 Spring 这个令软件行业为之动容的神秘面纱的一角。Spring 框架之所以如此备受推崇，不仅仅是因为它的灵活性和强大的功能，更因为它不断演进的能力，与软件发展的步伐同行。如果你对 Spring 框架的魅力产生了兴趣，那么请继续关注我们接下来的系列文章。在下一篇文章中，我们将深入探讨 Spring 的核心特性。</p> 
<p><strong>敬请期待!</strong></p> 
<p><img src="https://images2.imgbox.com/9e/04/u1lQL70b_o.jpg" alt="在这里插入图片描述"></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0035378714484a26c548efddf812cfc2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">给软件行业带来了春天——揭秘Spring究竟是何方神圣（二）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ca0d57af53c83cf411f254da2f2c498a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android保存WebView HTML源码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>