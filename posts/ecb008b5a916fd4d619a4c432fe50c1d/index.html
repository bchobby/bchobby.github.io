<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>面经-网络&#43;操作系统 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="面经-网络&#43;操作系统" />
<meta property="og:description" content="网络基础 TCP三次握手 一条视频讲清楚TCP协议与UDP协议-什么是三次握手与四次挥手_哔哩哔哩_bilibili
三次握手过程：
客户端——发送带有SYN标志的数据包——服务端 一次握手 Client进入syn_send状态
服务端——发送带有SYN/ACK标志的数据包——客户端 二次握手 服务端进入syn_rcvd
客户端——发送带有ACK标志的数据包——服务端 三次握手 连接就进入Established状态
为什么三次：
主要是为了建立可靠的通信信道，保证客户端与服务端同时具备发送、接收数据的能力
为什么两次不行？
假设采用两次握手建立连接,客户端向服务端发送了一个SYN包来请求建立连接，因为某些原因，并未到达服务器，在中间某个网络节点产生了滞留，为了建立连接客户端会重发SYN包，这次数据包正常送达，服务端回复SYN&#43;ACK，之后建立连接。但是第一包数据阻塞的网络节点突然恢复，第一包SYN包又送达到服务端，这时服务端会误认为是客户端又发起了一个新的连接，这样服务端进入等待数据状态，这样客户端认为是一个连接，服务端认为是两个连接。 TCP协议如何处理丢包问题以及乱序问题
TCP为每一个连接，建立一个发送缓冲区，从建立链接后的第一个字节的序列号为0，后面每个字节的序列号就会增加1，发送数据时，从发送缓冲区，取一部分数据组成发送报文，在发送报文的tcp协议头中会附带序列号和长度，接受端在收到数据后，需要回复确认报文，确认报文中的ACK，等于接收序列号加长度，也就是下一包数据要发送的起始序列号。这样一问一答的发送方式能够使发送端确认发送的数据已经被接收端收到，发送端也可以一次发送连续的多包数据，接收端只需要回复一次ACK就可以了，这样发送端，可以把待发送的数据分割成一系列的碎片发送到对端，对端根据序列号和长度，在接收后重构出来完整的数据。假设其中丢失了某些数据包，在接收端可以要求发送端重传，比如丢失了100-199这100个字节，接收端向发送端发送ACK=100的报文，发送端收到后重传这一包数据，接收端进行补全，以上过程不区分客户端和服务端，tcp连接是全双工的，对于两端来说都采取这种机制。
TCP四次挥手过程 四次挥手过程：
客户端——发送带有FIN标志的数据包——服务端，关闭与服务端的连接 ，客户端进入FIN-WAIT-1状态
服务端收到这个 FIN，它发回⼀ 个 ACK，确认序号为收到的序号加1，服务端就进入了CLOSE-WAIT状态
服务端——发送⼀个FIN数据包——客户端，关闭与客户端的连接，客户端就进入FIN-WAIT-2状态
客户端收到这个 FIN，发回 ACK 报⽂确认，并将确认序号设置为收到序号加1，TIME-WAIT状态
为什么四次：
因为需要确保客户端与服务端的数据能够完成传输。
CLOSE-WAIT：
这种状态的含义其实是表示在等待关闭
TIME-WAIT(等待超时时间)：
这是为了保证对方已收到ACK包，因为假设客户端发送完最后一包 ACK包后就释放了连接，一旦ACK包在网络中丢失，服务端将一直停留在最后确认状态，如果客户端发送最后一包ACK包后等待一段时间，这时服务端因为没有收到ACK包，会重发FIN包，客户端会响应这个FIN包，重发ACK包并刷新超时时间，也是为了保证在不可靠的网络链路中进行可靠的连接断开确认
如何查看TIME-WAIT状态的链接数量？
netstat -an |grep TIME_WAIT|wc -l 查看连接数等待time_wait状态连接数
为什么会TIME-WAIT过多？解决方法是怎样的？
可能原因： 高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接
解决：负载均衡服务器；Web服务器首先关闭来自负载均衡服务器的连
UDP协议 首先udp协议是基于非连接的，发送数据，就是简单地将数据包封装起来，然后从网卡发出去，数据包之间并没有状态上的联系，正因为udp这种简单的处理方式，导致他的性能损耗很小，资源占用也很小，但是对于网络传输过程中产生的丢包，UDP协议并不能保证，所以UDP在传输稳定性上要弱于tcp
1、OSI与TCP/IP 模型 OSI七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
2、TCP/IP模型各层的功能 TCP/IP五层：物理层、数据链路层、网络层、传输层、应用层 2、常见网络服务分层 应用层：HTTP、SMTP（支持电子邮件的 SMTP 协议）、DNS、FTP
传输层：TCP 、UDP
网络层：ICMP 、网际协议 IP 、NAT协议
网络接口层：以太网技术、MAC 协议、CSMA/CD 协议" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/ecb008b5a916fd4d619a4c432fe50c1d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-29T20:25:53+08:00" />
<meta property="article:modified_time" content="2022-10-29T20:25:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">面经-网络&#43;操作系统</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>网络基础</h2> 
<h3><strong>TCP三次握手</strong></h3> 
<p><a href="https://www.bilibili.com/video/BV1kV411j7hA?spm_id_from=333.337.search-card.all.click&amp;vd_source=09cff8f1aecdef9d3ca62a3d91ea4af9" rel="nofollow" title="一条视频讲清楚TCP协议与UDP协议-什么是三次握手与四次挥手_哔哩哔哩_bilibili">一条视频讲清楚TCP协议与UDP协议-什么是三次握手与四次挥手_哔哩哔哩_bilibili</a></p> 
<p><strong>三次握手过程：</strong></p> 
<p>客户端——发送带有SYN标志的数据包——服务端 <strong>一次握手</strong> Client进入syn_send状态</p> 
<p>服务端——发送带有SYN/ACK标志的数据包——客户端 <strong>二次握手</strong> 服务端进入syn_rcvd</p> 
<p>客户端——发送带有ACK标志的数据包——服务端 <strong>三次握手</strong> 连接就进入Established状态</p> 
<p><img alt="" height="524" src="https://images2.imgbox.com/92/71/XdgtCrRV_o.png" width="904"></p> 
<p></p> 
<p><strong>为什么三次：</strong></p> 
<p>主要是为了建立可靠的通信信道，保证客户端与服务端同时具备发送、接收数据的能力</p> 
<p><strong>为什么两次不行？</strong></p> 
<p>假设采用两次握手建立连接<span style="color:#fe2c24;">,客户端</span>向服务端发送了<span style="color:#fe2c24;">一个SYN包</span>来请求建立连接，因为某些原因，并未到达服务器，在<span style="color:#fe2c24;">中间某个网络节点产生了滞留</span>，为了建立连接客户端会<span style="color:#fe2c24;">重发SYN包</span>，这次数据包<span style="color:#fe2c24;">正常送达</span>，<span style="color:#fe2c24;">服务端回复SYN+ACK</span>，之后<span style="color:#fe2c24;">建立连接</span>。但是<span style="color:#fe2c24;">第一包</span>数据阻塞的网络节点<span style="color:#fe2c24;">突然恢复</span>，第一包SYN包又送达到服务端，这时<span style="color:#fe2c24;">服务端会误认为是客户端又发起了一个新的连接</span>，这样服务端进入等待数据状态，这样客户端认为是一个连接，服务端认为是两个连接。 </p> 
<p><img alt="" height="249" src="https://images2.imgbox.com/23/fd/IrvwSxjn_o.png" width="857"></p> 
<p><strong>TCP协议如何处理丢包问题以及乱序问题</strong></p> 
<p>TCP为每一个连接，建立一个<span style="color:#fe2c24;">发送缓冲区</span>，从建立链接后的第一个字节的序列号为0，后面每个字节的序列号就会增加1，发送数据时，从发送缓冲区，取一部分数据组成发送报文，在发送报文的tcp协议头中会附带<span style="color:#fe2c24;">序列号和长度</span>，接受端在收到数据后，需要回复确认报文，确认报文中的ACK，等于接收序列号加长度，也就是下一包数据要发送的起始序列号。这样一问一答的发送方式能够使发送端确认发送的数据已经被接收端收到，发送端也可以一次发送连续的多包数据，接收端只需要回复一次ACK就可以了，这样发送端，可以把待发送的数据分割成一系列的碎片发送到对端，对端根据序列号和长度，在接收后重构出来完整的数据。假设其中丢失了某些数据包，在接收端可以要求发送端重传，比如丢失了100-199这100个字节，接收端向发送端发送ACK=100的报文，发送端收到后重传这一包数据，接收端进行补全，以上过程不区分客户端和服务端，tcp连接是全双工的，对于两端来说都采取这种机制。<br><img alt="" height="561" src="https://images2.imgbox.com/f8/e8/oDWD6Dhf_o.png" width="1056"></p> 
<p></p> 
<h3><strong>TCP四次挥手过程 </strong></h3> 
<p><strong>四次挥手过程：</strong></p> 
<p>客户端——发送带有FIN标志的数据包——服务端，关闭与服务端的连接 ，客户端进入FIN-WAIT-1状态</p> 
<p>服务端收到这个 FIN，它发回⼀ 个 ACK，确认序号为收到的序号加1，服务端就进入了CLOSE-WAIT状态</p> 
<p>服务端——发送⼀个FIN数据包——客户端，关闭与客户端的连接，客户端就进入FIN-WAIT-2状态</p> 
<p>客户端收到这个 FIN，发回 ACK 报⽂确认，并将确认序号设置为收到序号加1，TIME-WAIT状态</p> 
<p><img alt="" height="565" src="https://images2.imgbox.com/d3/ce/PwG6M5eT_o.png" width="1068"></p> 
<p></p> 
<p><strong>为什么四次：</strong></p> 
<p>因为需要确保客户端与服务端的数据能够完成传输。</p> 
<p><strong>CLOSE-WAIT：</strong></p> 
<p>这种状态的含义其实是表示在等待关闭</p> 
<p><strong>TIME-WAIT(等待超时时间)：</strong></p> 
<p>这是为了保证对方已收到ACK包，因为假设客户端发送完最后一包 ACK包后就释放了连接，一旦ACK包在网络中丢失，服务端将一直停留在最后确认状态，如果客户端发送最后一包ACK包后等待一段时间，这时服务端因为没有收到ACK包，会重发FIN包，客户端会响应这个FIN包，重发ACK包并刷新超时时间，也是为了保证在不可靠的网络链路中进行可靠的连接断开确认</p> 
<p><strong>如何查看TIME-WAIT状态的链接数量？</strong></p> 
<p>netstat -an |grep TIME_WAIT|wc -l 查看连接数等待time_wait状态连接数</p> 
<p><strong>为什么会TIME-WAIT过多？解决方法是怎样的？</strong></p> 
<p><strong>可能原因：</strong> 高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接</p> 
<p><strong>解决：</strong>负载均衡服务器；Web服务器首先关闭来自负载均衡服务器的连</p> 
<h3><strong>UDP协议</strong></h3> 
<p>首先udp协议是基于非连接的，发送数据，就是简单地将数据包封装起来，然后从网卡发出去，数据包之间并没有状态上的联系，正因为udp这种简单的处理方式，导致他的性能损耗很小，资源占用也很小，但是对于网络传输过程中产生的丢包，UDP协议并不能保证，所以UDP在传输稳定性上要弱于tcp<br><img alt="" height="287" src="https://images2.imgbox.com/05/94/8zC0vcoB_o.png" width="964"><br>  </p> 
<p></p> 
<h4><strong>1、OSI与TCP/IP 模型</strong></h4> 
<p>OSI七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p> 
<p></p> 
<h3><img alt="OSI网络架构模型与TCP/IP模型" src="https://images2.imgbox.com/ec/82/U2MQjpY9_o.png"></h3> 
<p><strong>2、TCP/IP模型各层的功能 </strong></p> 
<p>TCP/IP五层：物理层、数据链路层、网络层、传输层、应用层 </p> 
<p> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/38/b6/482HjpQr_o.png"></p> 
<p></p> 
<p></p> 
<h4>2、<span style="color:#fe2c24;">常见网络服务分层</span></h4> 
<p>应用层：HTTP、SMTP（支持电子邮件的 SMTP 协议）、DNS、FTP</p> 
<p>传输层：TCP 、UDP</p> 
<p>网络层：ICMP 、网际协议 IP 、NAT协议</p> 
<p>网络接口层：以太网技术、MAC 协议、CSMA/CD 协议</p> 
<h4><strong>3、TCP与UDP区别及场景</strong></h4> 
<p>UDP全称为<strong>用户数据报协议</strong>。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。</p> 
<p>TCP全称传输控制协议，必须对数据的传输进行控制。</p> 
<table><thead><tr><th>类型</th><th style="width:450px;">特点</th><th style="width:134px;">性能</th><th style="width:87px;">应用过场景</th><th style="width:48px;">首部字节</th></tr></thead><tbody><tr><td>TCP</td><td style="width:450px;">面向连接、可靠、字节流，适用于对网络通信质量要求较高的环境</td><td style="width:134px;">传输效率慢、所需资源多</td><td style="width:87px;">文件、邮件传输</td><td style="width:48px;">20-60</td></tr><tr><td>UDP</td><td style="width:450px;">无连接、不可靠、数据报文段，适用于对实时性要求较高</td><td style="width:134px;">传输效率快、所需资源少</td><td style="width:87px;">语音、视频、直播</td><td style="width:48px;">8个字节</td></tr></tbody></table> 
<p><strong>基于TCP的协议：</strong>HTTP、FTP、SMTP</p> 
<p><strong>基于UDP的协议：</strong>RIP、DNS、SNMP</p> 
<p>TCP与UDP区别总结：<br> 1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br> 2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付<br> 3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br>   UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br> 4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br> 5、TCP首部开销20字节;UDP的首部开销小，只有8个字节<br> 6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p> 
<p></p> 
<h3><strong>HTTP协议</strong></h3> 
<h4> 1.HTTP报文</h4> 
<p>请求报文</p> 
<p>GET请求</p> 
<p>1、请求行<br>     (1) 请求的方式 GET<br>     (2) 请求的资源路径[+?+请求参数]<br>     (3) 请求的协议的版本号 HTTP/1.1<br> 2、请求头</p> 
<p>        浏览器的一些信息，由键值对组成<br>      key : value 组成 不同的键值对，表示不同的含义</p> 
<p><img alt="" height="376" src="https://images2.imgbox.com/3e/9e/QHp5GcGx_o.png" width="832"></p> 
<p></p> 
<p>POST请求报文</p> 
<p>1、请求行<br>   (1) 请求的方式 POST<br>   (2) 请求的资源路径[+?+请求参数]<br>   (3) 请求的协议的版本号 HTTP/1.1<br> 2、请求头</p> 
<p>        浏览器的一些信息，由键值对组成<br>    1) key : value 不同的请求头，有不同的含义<br> 3、空行<br> 4、请求体 ===&gt;&gt;&gt; 就是发送给服务器的数据</p> 
<p><img alt="" height="621" src="https://images2.imgbox.com/ed/a5/tlYhK4fq_o.png" width="1181"></p> 
<p>响应报文</p> 
<p>1、响应行<br> (1) 响应的协议和版本号<br> (2) 响应状态码<br> (3) 响应状态描述符<br> 2、响应头<br> (1) key : value 不同的响应头，有其不同含义<br> 空行<br> 3、响应体 ----&gt;&gt;&gt; 就是回传给客户端的数据</p> 
<p> <img alt="" height="802" src="https://images2.imgbox.com/6f/7c/r0fOEjjF_o.png" width="1200"></p> 
<h4>2、HTTP与HTTPS之间的区别</h4> 
<p><strong>HTTP与HTTPS之间的区别：</strong></p> 
<table><thead><tr><th>HTTP</th><th>HTTPS</th></tr></thead><tbody><tr><td>默认端口80，URL前缀是http://</td><td>HTTPS默认使用端口443，URL前缀https://</td></tr><tr><td>明文传输、数据未加密、安全性差</td><td>传输过程ssl加密、安全性较好</td></tr><tr><td>响应速度快、消耗资源少</td><td>响应速度较慢、消耗资源多、需要用到CA证书</td></tr></tbody></table> 
<p> </p> 
<h4 id="uri-和-url-的区别是什么">URI 和 URL 的区别是什么?</h4> 
<ul><li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li><li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li></ul> 
<p><strong>HTTPS链接建立的过程：</strong></p> 
<p>1.首先客户端先给服务器发送一个请求</p> 
<p>2.服务器发送一个SSL证书给客户端，内容包括：证书的发布机构、有效期、所有者、签名以及公钥</p> 
<p>3.客户端对发来的公钥进行真伪校验，校验为真则使用公钥对对称加密算法以及对称密钥进行加密</p> 
<p>4.服务器端使用私钥进行解密并使用对称密钥加密确认信息发送给客户端</p> 
<p>5.随后客户端和服务端就使用对称密钥进行信息传输</p> 
<p><strong>对称加密算法：</strong></p> 
<p>双方使用相同的加密算法，且加密速度快，典型对称加密算法：DES、AES</p> 
<p><strong>非对称加密算法：</strong></p> 
<p>密钥成对出现（私钥、公钥），私钥只有自己知道，不在网络中传输；而公钥可以公开。</p> 
<p>私钥放在服务器里，数据经过公钥加密，只能私钥解密。数据经过私钥加密只能公钥解密</p> 
<p>相比对称加密速度较慢，典型的非对称加密算法有：RSA、DSA</p> 
<p>证书</p> 
<p>SSL证书其实就是保存在源服务器的数据文件，要让SSL证书生效就需要向CA申请，也就是Certificate Authority证书授权中心，这是第三方的机构，这样大家都来信任这个机构颁发的证书。</p> 
<p>证书保存域名归属，日期，公钥</p> 
<h2><strong>加密算法/压缩算法</strong></h2> 
<p><br><span style="color:#fe2c24;">常用的加密算法（md5，sha256，base64，RSA，DES，前3个不可逆，后2个可逆）</span></p> 
<p><span style="color:#fe2c24;"><strong>常用的压缩算法（gzip：底层基于了哈夫曼编码，字典压缩法，定长位压缩，前缀树压缩）</strong></span></p> 
<h4>9、get/post的区别</h4> 
<p><strong>HTTP请求：</strong></p> 
<table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><span style="color:#fe2c24;">GET</span></td><td>向特定资源发送请求，查询数据，并返回实体</td></tr><tr><td><span style="color:#fe2c24;">POST</span></td><td>向指定资源提交数据进行处理请求，可能会导致新的资源建立、已有资源修改</td></tr><tr><td><span style="color:#fe2c24;">PUT</span></td><td>向服务器上传新的内容</td></tr><tr><td>HEAD</td><td>类似GET请求，返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td><span style="color:#fe2c24;">DELETE</span></td><td>请求服务器删除指定标识的资源</td></tr><tr><td><span style="color:#fe2c24;">OPTIONS</span></td><td>可以用来向服务器发送请求来测试服务器的功能性</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，用于测试或诊断</td></tr><tr><td>CONNECT</td><td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</td></tr></tbody></table> 
<p>区别：<br> POST：</p> 
<p>①、参数不会拼接再请求地址后，会放在请求体中，所以post有请求体，get没有</p> 
<p>②、post相对安全</p> 
<p>③、post传输速度相对慢</p> 
<p>④、传输数据量大，可以认为是无限制的</p> 
<p>⑤、文件上传使用post</p> 
<p>GET：</p> 
<p>①、每当使用get请求方式提交参数，请求参数会拼接在请求在请求地址后，用？来拼接，后面是请求参数名=请求参数值&amp;请求参数名=请求参数值。。。</p> 
<p>②、因为会将参数放在地址栏，所以不安全</p> 
<p>③、因为是伴随着地址传输，所以get传输速度快</p> 
<p>④、传输数据量小</p> 
<p>⑤、文件不可能拼接在地址中，如果使用get方式在传文件，地址栏传输的是文件的名称，所以上传文件不适用get</p> 
<h4><strong>4、HTTP常见响应状态码</strong></h4> 
<p>100：Continue --- 继续。客户端应继续其请求。</p> 
<p>200：OK --- 请求成功。一般用于GET与POST请求。</p> 
<p>301：Moved Permanently --- 永久重定向。</p> 
<p>302：Found --- 暂时重定向。</p> 
<p>400：Bad Request --- 客户端请求的语法错误，服务器无法理解。<span style="color:#fe2c24;">（跨域问题）</span></p> 
<p>403：Forbideen --- 服务器理解请求客户端的请求，但是拒绝执行此请求。</p> 
<p>404：Not Found --- 服务器无法根据客户端的请求找到资源（网页）。</p> 
<p>500：Internal Server Error --- 服务器内部错误，无法完成请求。</p> 
<p>502：Bad Gateway --- 作为网关或者代理服务器尝试执行请求时，从远程服务器接收到了无效的响应。</p> 
<h4><strong>5、重定向和转发区别</strong></h4> 
<p><strong>重定向：redirect：</strong></p> 
<p>地址栏发生变化</p> 
<p>重定向可以访问其他站点（服务器）的资源</p> 
<p>重定向是两次请求。不能使用request对象来共享数据</p> 
<p><strong>转发：forward：</strong></p> 
<p>请求转发是指，服务器收到请求后，从一次资源跳转到另一个资源的操作叫请求转发</p> 
<p>转发地址栏路径不变</p> 
<p>转发只能访问当前服务器下的资源</p> 
<p>转发是一次请求，可以使用request对象共享数据</p> 
<h4><strong>6、Cookie和Session区别。</strong></h4> 
<p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但两者有所区别：</p> 
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p> 
<p>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行欺骗,考虑到安全应当使用session。</p> 
<p>Cookie ⼀般⽤来保存⽤户信息，Session 的主要作⽤就是通过服务端记录⽤户的状态</p> 
<p>Cookie、Session、Token究竟区别在哪？如何进行身份认证，保持用户登录状态？</p> 
<p></p> 
<h4>7，<strong>浏览器输入URL过程</strong></h4> 
<p><strong>过程：</strong>DNS解析、TCP连接、发送HTTP请求、服务器处理请求并返回HTTP报文、浏览器渲染、结束</p> 
<table><thead><tr><th>过程</th><th>使用的协议</th></tr></thead><tbody><tr><td>1、DNS解析-把URL地址解析为ip地址（浏览器缓存、路由器缓存、DNS缓存）</td><td>DNS：获取域名对应的ip</td></tr><tr><td>2、根据ip建立TCP连接，就是三次握手</td><td>TCP：与服务器建立连接</td></tr><tr><td>3、浏览器向服务器发送HTTP请求，HTTP请求具体看上面</td><td>HTTP：发送请求</td></tr><tr><td>4、服务器响应HTTP响应，具体看上面</td><td>HTTP</td></tr><tr><td>5、浏览器进行渲染</td><td></td></tr></tbody></table> 
<h3></h3> 
<p></p> 
<p></p> 
<h2><strong>操作系统基础</strong></h2> 
<p></p> 
<h4><strong>进程和线程的区别</strong></h4> 
<p><strong>进程：</strong>是资源分配的最小单位，一个进程可以有多个线程，多个线程共享进程的堆和方法区资源，不共享栈、程序计数器</p> 
<p><strong>线程：</strong>是任务调度和执行的最小单位，线程并行执行存在资源竞争和上下文切换的问题</p> 
<p><strong>协程：</strong>是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。</p> 
<h4 id="_2-3-进程间的通信方式">进程间的通信方式</h4> 
<p>👨‍💻<strong>面试官</strong> ：<strong>进程间的通信常见的的有哪几种方式呢?</strong></p> 
<p>🙋 <strong>我</strong> ：大概有 7 种常见的进程间的通信方式。</p> 
<blockquote> 
 <p>下面这部分总结参考了:<a href="https://www.jianshu.com/p/c1015f5ffa74" rel="nofollow" title="《进程间通信 IPC (InterProcess Communication)》open in new window">《进程间通信 IPC (InterProcess Communication)》open in new window</a> 这篇文章，推荐阅读，总结的非常不错。</p> 
</blockquote> 
<ol><li><strong>管道/匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li><li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循<strong>先进先出(first in first out)</strong>。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li><li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li><li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。</strong></li><li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li><li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li><li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li></ol> 
<h4 id="_2-4-线程间的同步的方式">2.4 线程间的同步的方式</h4> 
<p>👨‍💻<strong>面试官</strong> ：<strong>那线程间的同步的方式有哪些呢?</strong></p> 
<p>🙋 <strong>我</strong> ：线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：</p> 
<ol><li><strong>互斥量(Mutex)</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li><li><strong>信号量(Semaphore)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li><li><strong>事件(Event)</strong> :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li></ol> 
<h4 id="_2-5-进程的调度算法"><a href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_2-5-%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95" rel="nofollow" title="#">#</a>2.5 进程的调度算法</h4> 
<p></p> 
<p>👨‍💻<strong>面试官</strong> ：<strong>你知道操作系统中进程的调度算法有哪些吗?</strong></p> 
<p>🙋 <strong>我</strong> ：嗯嗯！这个我们大学的时候学过，是一个很重要的知识点！</p> 
<p>为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是：</p> 
<ul><li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li><li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li><li><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li></ul> 
<h4 id="_2-6-什么是死锁"><a href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_2-6-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81" rel="nofollow" title="#">#</a>2.6 什么是死锁</h4> 
<p>👨‍💻<strong>面试官</strong> ：<strong>你知道什么是死锁吗?</strong></p> 
<p>🙋 <strong>我</strong> ：死锁描述的是这样一种情况：多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。</p> 
<h4 id="_2-7-死锁的四个条件"><a href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_2-7-%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%9D%A1%E4%BB%B6" rel="nofollow" title="#">#</a>2.7 死锁的四个条件</h4> 
<p>👨‍💻<strong>面试官</strong> ：<strong>产生死锁的四个必要条件是什么?</strong></p> 
<p>🙋 <strong>我</strong> ：如果系统中以下四个条件同时成立，那么就能引起死锁：</p> 
<ul><li> <p><strong>互斥条件</strong>：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待至占有该资源的进程释放该资源；</p> </li><li> <p><strong>请求与保持条件</strong>：进程获得一定的资源后，又对其他资源发出请求，阻塞过程中不会释放自己已经占有的资源</p> </li><li> <p><strong>非剥夺条件</strong>：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放循</p> </li><li> <p><strong>环等待条件</strong>：系统中若干进程组成环路，环路中每个进程都在等待相邻进程占用的资源</p> </li></ul> 
<p>注意，只有四个条件同时成立时，死锁才会出现。</p> 
<h4 id="_2-8-解决死锁的方法"><a href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_2-8-%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95" rel="nofollow" title="#">#</a>2.8 解决死锁的方法</h4> 
<p>破坏死锁的任意一条件</p> 
<ul><li> <p>乐观锁，破坏资源互斥条件，<strong>CAS</strong></p> </li><li> <p>资源一次性分配，从而剥夺请求和保持条件、<strong>tryLock</strong></p> </li><li> <p>可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件，<strong>数据库deadlock超时</strong></p> </li><li> <p>资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，从而破坏环路等待的条件，<strong>转账场景</strong><br>  </p> </li></ul> 
<h4>操作系统内存管理</h4> 
<h4><strong>内存存管理方式</strong></h4> 
<p>页式管理、段式管理、段页式管理</p> 
<p><strong>分段管理：</strong></p> 
<p>将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）</p> 
<p><strong>分页管理：</strong></p> 
<p>在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的页框，程序加载时，可以将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）</p> 
<p><strong>段页式管理：</strong></p> 
<p>段⻚式管理机制结合了段式管理和⻚式管理的优点。简单来说段⻚式管理机制就是把主存先分成若⼲段，每个段⼜分成若⼲⻚，也就是说 段⻚式管理机制 中段与段之间以及段的内部的都是离散的</p> 
<p></p> 
<p><strong>2、死锁条件、解决方式。</strong></p> 
<p>死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象；</p> 
<p><strong>死锁的条件：</strong></p> 
<p>互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待至占有该资源的进程释放该资源；</p> 
<p>请求与保持条件：进程获得一定的资源后，又对其他资源发出请求，阻塞过程中不会释放自己已经占有的资源</p> 
<p>非剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放</p> 
<p>循环等待条件：系统中若干进程组成环路，环路中每个进程都在等待相邻进程占用的资源</p> 
<p><strong>解决方法：</strong>破坏死锁的任意一条件</p> 
<p>乐观锁，破坏资源互斥条件，<strong>CAS</strong></p> 
<p>资源一次性分配，从而剥夺请求和保持条件、<strong>tryLock</strong></p> 
<p>可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件，<strong>数据库deadlock超时</strong></p> 
<p>资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，从而破坏环路等待的条件，<strong>转账场景</strong></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b7d2bb8b286a87df5b2e86b00e253cca/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">（思路）修复删除配置的管理员账户-与-修复临时账户配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bd8d61c0e772622aa429b41cd679199c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring Boot项目学习之通用权限管理项目02</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>