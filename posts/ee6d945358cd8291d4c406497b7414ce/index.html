<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>神奇的卡尔曼滤波，目标追踪的福音 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="神奇的卡尔曼滤波，目标追踪的福音" />
<meta property="og:description" content="前言 卡尔曼滤波算法由匈牙利数学家Kalman提出，主要基于线性系统提出。这里我们将其用于汽车跟踪，并对其基本原理进行介绍。
神奇的卡尔曼滤波，目标追踪的福音
1. 背景知识
1.1 时间序列模型
1.2. 滤波
1.3. 线性动态系统 2. 卡尔曼滤波理论知识 2.1 预测
2.1.1 第一条公式：状态转移
2.1.2 第二条公式：协方差矩阵
2.2 更新
2.2.1 第三条公式：卡尔曼增益
2.2.2 第四条公式：观测矩阵
2.2.3 第五条公式：
3. 卡尔曼滤波的应用
3.1 代码
3.1.1 获取场景数据。
3.1.2 初始化
3.1.3 开始预测与更新
3.1.4 画图 1.背景知识 1.1 时间序列模型 时间序列模型都可以用如下示意图表示：
这个模型包含两个序列，一个是黄色部分的状态序列，用X表示，一个是绿色部分的观测序列（又叫测量序列、证据序列、观察序列，不同的书籍有不同的叫法，在这里统一叫观测序列。）用Y表示。状态序列反应了系统的真实状态，一般不能被直接观测，即使被直接观测也会引进噪声；观测序列是通过测量得到的数据，它与状态序列之间有规律性的联系。
上面序列中，假设初始时间为, 则,是时刻的状态值和观测值，,是时刻的状态值和观测值...，即随着时间的流逝，序列从左向右逐渐展开。 常见的时间序列模型主要包括三个：隐尔马尔科夫模型，卡尔曼滤波，粒子滤波。
1.2. 滤波 时间序列模型中包括预测和滤波两步
预测：指用当前和过去的数据来求取未来的数据。对应上述序列图中，则是利用时刻,的值，估计时刻值。滤波：是用当前和过去的数据来求取当前的数据。对应上述序列图中，则是先通过上一步的预测步骤得到的一个预测值，再利用时刻的值对这个预测值进行纠正，得到最终的估计值。（通俗讲，就是通过预测一个值, 通过传感器测量一个值, 将两者进行融合得到最终的值） 1.3. 线性动态系统 卡尔曼滤波又称为基于高斯过程的线性动态系统(Linear Dynamic System, LDS)。
· 这里的高斯是指：状态变量和观测变量都符合高斯分布；（为什么是高斯分布？因为卡尔曼滤波估计的结果是一个概率，概率不是一个固定的值，而是一个范围，而这个范围符合高斯分布。）
· 这里的线性是指：可以通过线性表示，可以通过线性表示;
如果用数学表达式来表达这两层含义如下:
上面表达式中F是一个矩阵，常称作状态转移矩阵，保证了和的线性关系(线性代数中，矩阵就是线性变换)；常称作噪声，其服从均值为0，方差为Q的高斯分布，保证了服从高斯分布(因为高斯分布加上一个常数后依然是高斯分布)。
同样的关于和,也可以得到如下表示, 其中矩阵H称作状态空间到观测空间的映射矩阵， rtrt称作噪声，其服从高斯分布：
2.卡尔曼滤波理论知识 以下公式需要用到的变量含义如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/ee6d945358cd8291d4c406497b7414ce/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-26T09:50:17+08:00" />
<meta property="article:modified_time" content="2022-10-26T09:50:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">神奇的卡尔曼滤波，目标追踪的福音</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<p>        卡尔曼滤波算法由匈牙利数学家Kalman提出，主要基于线性系统提出。这里我们将其用于汽车跟踪，并对其基本原理进行介绍。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9b/a8/u8Gazjxc_o.jpg"></p> 
<hr> 
<p id="main-toc"><strong>神奇的卡尔曼滤波，目标追踪的福音</strong></p> 
<p id="1.%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86-toc" style="margin-left:0px;"><a href="#1.%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86" rel="nofollow">1. 背景知识</a></p> 
<p id="1.1%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B-toc" style="margin-left:40px;"><a href="#1.1%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B" rel="nofollow">1.1 时间序列模型</a></p> 
<p id="1.2.%20%E6%BB%A4%E6%B3%A2-toc" style="margin-left:40px;"><a href="#1.2.%20%E6%BB%A4%E6%B3%A2" rel="nofollow">1.2. 滤波</a></p> 
<p id="1.3.%20%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F%C2%A0-toc" style="margin-left:40px;"><a href="#1.3.%20%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F%C2%A0" rel="nofollow">1.3. 线性动态系统 </a></p> 
<p id="2.%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%C2%A0-toc" style="margin-left:0px;"><a href="#2.%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%C2%A0" rel="nofollow">2. 卡尔曼滤波理论知识 </a></p> 
<p id="2.1%20%E9%A2%84%E6%B5%8B-toc" style="margin-left:40px;"><a href="#2.1%20%E9%A2%84%E6%B5%8B" rel="nofollow">2.1 预测</a></p> 
<p id="2.1.1%20%E7%AC%AC%E4%B8%80%E6%9D%A1%E5%85%AC%E5%BC%8F%EF%BC%9A%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB-toc" style="margin-left:80px;"><a href="#2.1.1%20%E7%AC%AC%E4%B8%80%E6%9D%A1%E5%85%AC%E5%BC%8F%EF%BC%9A%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB" rel="nofollow">2.1.1 第一条公式：状态转移</a></p> 
<p id="2.1.2%20%E7%AC%AC%E4%BA%8C%E6%9D%A1%E5%85%AC%E5%BC%8F%EF%BC%9A%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5-toc" style="margin-left:80px;"><a href="#2.1.2%20%E7%AC%AC%E4%BA%8C%E6%9D%A1%E5%85%AC%E5%BC%8F%EF%BC%9A%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5" rel="nofollow">2.1.2 第二条公式：协方差矩阵</a></p> 
<p id="2.2%20%E6%9B%B4%E6%96%B0-toc" style="margin-left:40px;"><a href="#2.2%20%E6%9B%B4%E6%96%B0" rel="nofollow">2.2 更新</a></p> 
<p id="2.2.1%20%E7%AC%AC%E4%B8%89%E6%9D%A1%E5%85%AC%E5%BC%8F%EF%BC%9A%E5%8D%A1%E5%B0%94%E6%9B%BC%E5%A2%9E%E7%9B%8A-toc" style="margin-left:80px;"><a href="#2.2.1%20%E7%AC%AC%E4%B8%89%E6%9D%A1%E5%85%AC%E5%BC%8F%EF%BC%9A%E5%8D%A1%E5%B0%94%E6%9B%BC%E5%A2%9E%E7%9B%8A" rel="nofollow">2.2.1 第三条公式：卡尔曼增益</a></p> 
<p id="2.2.2%C2%A0%E7%AC%AC%E5%9B%9B%E6%9D%A1%E5%85%AC%E5%BC%8F%EF%BC%9A%E8%A7%82%E6%B5%8B%E7%9F%A9%E9%98%B5-toc" style="margin-left:80px;"><a href="#2.2.2%C2%A0%E7%AC%AC%E5%9B%9B%E6%9D%A1%E5%85%AC%E5%BC%8F%EF%BC%9A%E8%A7%82%E6%B5%8B%E7%9F%A9%E9%98%B5" rel="nofollow">2.2.2 第四条公式：观测矩阵</a></p> 
<p id="2.2.3%C2%A0%E7%AC%AC%E4%BA%94%E6%9D%A1%E5%85%AC%E5%BC%8F%EF%BC%9A-toc" style="margin-left:80px;"><a href="#2.2.3%C2%A0%E7%AC%AC%E4%BA%94%E6%9D%A1%E5%85%AC%E5%BC%8F%EF%BC%9A" rel="nofollow">2.2.3 第五条公式：</a></p> 
<p id="3%20%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E7%9A%84%E5%BA%94%E7%94%A8-toc" style="margin-left:0px;"><a href="#3%20%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E7%9A%84%E5%BA%94%E7%94%A8" rel="nofollow">3. 卡尔曼滤波的应用</a></p> 
<p id="3.1%20%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#3.1%20%E4%BB%A3%E7%A0%81" rel="nofollow">3.1 代码</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1.1%20%E8%8E%B7%E5%8F%96%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E3%80%82-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1.1%20%E8%8E%B7%E5%8F%96%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E3%80%82" rel="nofollow">        3.1.1 获取场景数据。</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1.2%20%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1.2%20%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">        3.1.2 初始化</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.1.3%20%E5%BC%80%E5%A7%8B%E9%A2%84%E6%B5%8B%E4%B8%8E%E6%9B%B4%E6%96%B0-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.1.3%20%E5%BC%80%E5%A7%8B%E9%A2%84%E6%B5%8B%E4%B8%8E%E6%9B%B4%E6%96%B0" rel="nofollow">        3.1.3 开始预测与更新</a></p> 
<p id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1.4%20%E7%94%BB%E5%9B%BE%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1.4%20%E7%94%BB%E5%9B%BE%C2%A0" rel="nofollow">        3.1.4 画图 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86">1.背景知识</h2> 
<h3 id="1.1%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B">1.1 时间序列模型</h3> 
<p>时间序列模型都可以用如下示意图表示：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/53/19/g4WBqo2f_o.png"></p> 
<p>这个模型包含两个序列，一个是黄色部分的状态序列，用<strong>X</strong>表示，一个是绿色部分的观测序列（又叫测量序列、证据序列、观察序列，不同的书籍有不同的叫法，在这里统一叫观测序列。）用<strong>Y</strong>表示。状态序列反应了系统的真实状态，一般不能被直接观测，即使被直接观测也会引进噪声；观测序列是通过测量得到的数据，它与状态序列之间有规律性的联系。</p> 
<p>上面序列中，假设初始时间为<img alt="t_{1}" class="mathcode" src="https://images2.imgbox.com/4a/39/yRX8aea4_o.png">, 则<img alt="X_{1}" class="mathcode" src="https://images2.imgbox.com/70/80/kx9dtVW3_o.png">,<img alt="Y_{1}" class="mathcode" src="https://images2.imgbox.com/8b/6f/Hl1Ify0Z_o.png">是<img alt="t_{1}" class="mathcode" src="https://images2.imgbox.com/66/73/eRmTN81I_o.png">时刻的状态值和观测值，<img alt="X_{2}" class="mathcode" src="https://images2.imgbox.com/68/a6/fdEgegrl_o.png">,<img alt="Y_{2}" class="mathcode" src="https://images2.imgbox.com/52/ad/r0IXgwVc_o.png">是<img alt="t_{2}" class="mathcode" src="https://images2.imgbox.com/6c/74/H5FgnVZD_o.png">时刻的状态值和观测值...，即随着时间的流逝，序列从左向右逐渐展开。  </p> 
<p>常见的时间序列模型主要包括三个：<strong>隐尔马尔科夫模型，卡尔曼滤波，粒子滤波</strong>。</p> 
<h3 id="1.2.%20%E6%BB%A4%E6%B3%A2">1.2. 滤波</h3> 
<p>时间序列模型中包括预测和滤波两步</p> 
<ul><li><strong>预测：指用当前和过去的数据来求取未来的数据。</strong>对应上述序列图中，则是利用<img alt="t_{1}" class="mathcode" src="https://images2.imgbox.com/48/dd/iN0jI0ea_o.png">时刻<img alt="X_{1}" class="mathcode" src="https://images2.imgbox.com/45/ca/PthF2AEC_o.png">,<img alt="Y_{1}" class="mathcode" src="https://images2.imgbox.com/a3/9b/xQEFsX0p_o.png">的值，估计<img alt="t_{2}" class="mathcode" src="https://images2.imgbox.com/7e/95/X7iXmofK_o.png">时刻<img alt="X_{2}" class="mathcode" src="https://images2.imgbox.com/01/6b/nOZ9Embg_o.png">值。</li><li><strong>滤波</strong>：<strong>是用当前和过去的数据来求取当前的数据。</strong>对应上述序列图中，则是先通过上一步的预测步骤得到<img alt="X_{2}" class="mathcode" src="https://images2.imgbox.com/3b/a2/Yi8IgqTP_o.png">的一个预测值，再利用<img alt="t_{2}" class="mathcode" src="https://images2.imgbox.com/c7/54/4E2j4XjF_o.png">时刻<img alt="Y_{2}" class="mathcode" src="https://images2.imgbox.com/d6/d5/aO5bhVWW_o.png">的值对这个预测值进行纠正，得到最终的<img alt="X_{2}" class="mathcode" src="https://images2.imgbox.com/df/06/hWLo2fcb_o.png">估计值。（通俗讲，就是通过<img alt="X_{1}" class="mathcode" src="https://images2.imgbox.com/b7/1d/TwW3tfyK_o.png">预测一个值, 通过传感器测量一个值<img alt="Y_{2}" class="mathcode" src="https://images2.imgbox.com/37/16/tBwQwBUm_o.png">, 将两者进行融合得到最终的<img alt="X_{2}" class="mathcode" src="https://images2.imgbox.com/cc/70/FAawBqcq_o.png">值）        </li></ul> 
<h3 id="1.3.%20%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E7%B3%BB%E7%BB%9F%C2%A0"><strong>1.3. 线性动态系统</strong> </h3> 
<p>        卡尔曼滤波又称为<strong>基于高斯过程的线性动态系统(Linear Dynamic System, LDS)。</strong></p> 
<p><strong>        ·</strong> 这里的高斯是指：状态变量<img alt="X_{t}" class="mathcode" src="https://images2.imgbox.com/30/fb/oUYay6d8_o.png">和观测变量<img alt="Y_{t}" class="mathcode" src="https://images2.imgbox.com/19/67/f5OfeFwo_o.png">都符合高斯分布；（<strong>为什么是高斯分布？因为卡尔曼滤波估计的结果是一个概率，概率不是一个固定的值，而是一个范围，而这个范围符合高斯分布。）</strong></p> 
<p><strong>        ·</strong> 这里的线性是指：<img alt="X_{t}" class="mathcode" src="https://images2.imgbox.com/36/92/btasEzL0_o.png">可以通过<img alt="X_{t-1}" class="mathcode" src="https://images2.imgbox.com/86/9e/Xvm2I7kn_o.png">线性表示，<img alt="Y_{t}" class="mathcode" src="https://images2.imgbox.com/7a/fb/67n3eu7D_o.png">可以通过<img alt="X_{t}" class="mathcode" src="https://images2.imgbox.com/af/9f/DyTZiRXW_o.png">线性表示;</p> 
<p>如果用数学表达式来表达这两层含义如下:</p> 
<p class="img-center"><img alt="" height="65" src="https://images2.imgbox.com/26/05/kJM8KjOM_o.png" width="506"></p> 
<p>上面表达式中F是一个矩阵，常称作<strong>状态转移矩阵</strong>，保证了<img alt="X_{t}" class="mathcode" src="https://images2.imgbox.com/cf/61/rGHjRyUX_o.png">和<img alt="X_{t-1}" class="mathcode" src="https://images2.imgbox.com/4f/85/fajVqLLu_o.png">的线性关系(线性代数中，矩阵就是线性变换)；<img alt="w_{t-1}" class="mathcode" src="https://images2.imgbox.com/44/c1/rWX8D8Se_o.png">常称作噪声，其服从均值为0，方差为Q的高斯分布，保证了<img alt="X_{t}" class="mathcode" src="https://images2.imgbox.com/cb/83/OUeExtm1_o.png">服从高斯分布(因为高斯分布加上一个常数后依然是高斯分布)。</p> 
<p>同样的关于<img alt="X_{t}" class="mathcode" src="https://images2.imgbox.com/88/28/ja7gaImi_o.png">和<img alt="Y_{t}" class="mathcode" src="https://images2.imgbox.com/dd/22/V2PArQkM_o.png">,也可以得到如下表示, 其中矩阵H称作<strong>状态空间到观测空间的映射矩阵</strong>， rtrt称作噪声，其服从高斯分布：</p> 
<p></p> 
<p class="img-center"><img alt="" height="64" src="https://images2.imgbox.com/5e/9e/ovYMHIz4_o.png" width="462"></p> 
<h2 id="2.%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%C2%A0">2.卡尔曼滤波理论知识 </h2> 
<p>以下公式需要用到的变量含义如下：</p> 
<ul><li><img alt="x\hat{}_{k}" class="mathcode" src="https://images2.imgbox.com/b7/c5/9in9SDEN_o.png">:状态变量</li><li><img alt="\hat{P}_{k}" class="mathcode" src="https://images2.imgbox.com/a3/cf/vkRAN89g_o.png">: 状态变量的协方差矩阵</li><li><img alt="F_{k}" class="mathcode" src="https://images2.imgbox.com/8a/e7/bsRcay4x_o.png">:状态转移矩阵</li><li><img alt="B_{k}" class="mathcode" src="https://images2.imgbox.com/a9/d5/BeQZhrIB_o.png">:控制矩阵</li><li><img alt="u_{k}" class="mathcode" src="https://images2.imgbox.com/a5/5a/XZ0QSLdM_o.png">:控制向量</li><li><img alt="w_{k}" class="mathcode" src="https://images2.imgbox.com/03/65/48O08Fnc_o.png">: 状态变量的噪声矩阵</li><li><img alt="Q_{k}" class="mathcode" src="https://images2.imgbox.com/5a/f4/7ZO5vbwY_o.png">:协方差矩阵的噪声矩阵</li></ul> 
<hr> 
<p>        学习卡尔曼滤波只需要弄懂下图这五个公式与他们之间的关系。</p> 
<p class="img-center"><img alt="" height="225" src="https://images2.imgbox.com/be/d9/kmGbULtJ_o.png" width="428"></p> 
<p>         <strong>预测</strong>中的两条公式，是通过上一时刻的状态预测下一时刻的状态的，通过这两条公式，我们得到的是带减号和上标的，这表示，这并不是<strong>最佳的估计值</strong>，减号表示它们还欠缺点什么东西，这个欠缺的东西呢就是通过<strong>观测值</strong>里面带来的信息，因为我们还需要用<strong>观测值</strong>中带来的信息修正误差，从而得到<strong>最优估计值</strong>，这正是<strong>更新</strong>这一步要做的事情，也就是说更新这一步才做到了真正的预测值X，<strong>更新了没有修正的预测结果</strong>，可以这么理解。</p> 
<hr> 
<p>       <strong> 更新</strong>这三个公式，第一条公式是用来求<strong>卡尔曼增益K</strong>的，<strong>卡尔曼增益K</strong>是用来协同当前状态的<strong>观测值Z</strong>来更新<strong>X</strong>（第二条公式）和<strong>P（</strong>第三条公式）<strong>的</strong>，经过更新后的值才是<strong>最佳的估计值</strong>，所以他们是不带减号下标的。</p> 
<hr> 
<p>        我们可以看出，五条公式有三条（<img alt="\hat{P}_{k}" class="mathcode" src="https://images2.imgbox.com/de/28/YQcOcWtq_o.png">、<img alt="w_{k}" class="mathcode" src="https://images2.imgbox.com/7a/5d/gTu7Nr3P_o.png">、<img alt="Q_{k}" class="mathcode" src="https://images2.imgbox.com/13/62/54OPFkMm_o.png">）都是有<strong>噪声</strong>尾随其后的，这些<strong>噪声</strong>的<strong>不确定性</strong>会化为数值根据每一次迭代不断的更新，并用来修正充满了<strong>噪声</strong>的<strong>观测值，</strong>从而使得观测值真实可靠。</p> 
<h3 id="2.1%20%E9%A2%84%E6%B5%8B">2.1 预测</h3> 
<h4 id="2.1.1%20%E7%AC%AC%E4%B8%80%E6%9D%A1%E5%85%AC%E5%BC%8F%EF%BC%9A%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB">2.1.1 第一条公式：状态转移</h4> 
<p class="img-center"><img alt="" height="221" src="https://images2.imgbox.com/dd/4e/brcC3ftb_o.png" width="604"></p> 
<p>        我们假设有这样一辆小车在以可变化的速度向前行驶，这个时候它有两个状态量：位置position和速度velocity（此后简略为p和v）。</p> 
<p>        若当前时刻为t，则<img alt="x_{t}" class="mathcode" src="https://images2.imgbox.com/1b/cf/df5RYLXk_o.png">为当前时刻的状态量，它有两个属性<img alt="p_{t}" class="mathcode" src="https://images2.imgbox.com/94/0a/PC9tAIXh_o.png">和<img alt="v_{t}" class="mathcode" src="https://images2.imgbox.com/3e/ec/8RRW5TBH_o.png">，分别表示当前状态的位置和速度。 上面我们也说了滤波是预测当前的状态，那么我们如何预测当前的状态？自然是用过去的状态量预测当前的状态量，于是我们又有了<img alt="x_{t-1}" class="mathcode" src="https://images2.imgbox.com/f3/37/uHNqstXj_o.png">，它也有两个属性<img alt="p_{t-1}" class="mathcode" src="https://images2.imgbox.com/3f/61/xoaUSbtV_o.png">与<img alt="v_{t-1}" class="mathcode" src="https://images2.imgbox.com/05/56/pFZ7wxM9_o.png">。</p> 
<p class="img-center"><img alt="" height="142" src="https://images2.imgbox.com/0d/41/jGWmWd22_o.png" width="851"></p> 
<p>        至此，我们根据位置与速度，速度与时间之间的关系，简单的推出它们的数学表达公式（左边的两个式子），如果我们用线性代数的知识：矩阵，来描述这个式子，那么它将变成一种更具有计算与表达价值的矩阵形式（右边的式子）。</p> 
<p>        但我们可以看出他依旧不是那么的简洁，这不符合优美的数学。所以我们接下来用<img alt="F_{t}" class="mathcode" src="https://images2.imgbox.com/de/d4/ACGhiQk3_o.png"><strong>状态转移矩阵</strong>，它代表我们如何从上一时刻的状态来推测当前时刻的状态，和<img alt="B_{t}" class="mathcode" src="https://images2.imgbox.com/a7/d6/uTCqwLl9_o.png"><strong>控制矩阵，</strong>它表示上一时刻的状态控制量u如何作用于当前状态。如下图：</p> 
<p class="img-center"><img alt="" height="1080" src="https://images2.imgbox.com/1a/03/fkbXNqi2_o.png" width="1200"></p> 
<p>         x之所以戴了尖帽子是因为这只是一个估计量，因为我们无法永远预测汽车的真实状态，只能尽量可能的估计推测出真实状态，这是因为真实状态包含了非常多的噪声，比如汽车突然减速加速，或者掉进了一个坑...等等。噪声越大，不确定性也就越大，所以我们待会还需要根据协方差矩阵来计算这个不确定性究竟有多大。</p> 
<h4 id="2.1.2%20%E7%AC%AC%E4%BA%8C%E6%9D%A1%E5%85%AC%E5%BC%8F%EF%BC%9A%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5">2.1.2 第二条公式：协方差矩阵</h4> 
<p>        协方差矩阵<strong>P(这次是大写的）</strong>是符合高斯分布的，它在卡尔曼滤波中是用来表示p,v两个状态量之间的相关性，比如<strong>正相关</strong>、<strong>负相关</strong>，<strong>不相关</strong>，并且计算出系数，也就是如果是正相关，那么<strong>相关的程度</strong>用数字表达是多少。具体如下图：</p> 
<p class="img-center"><img alt="" height="1080" src="https://images2.imgbox.com/31/f1/62Yvcc1w_o.png" width="1200"></p> 
<p>        那么下一个问题就是，我们通过让上一刻的协方差矩阵<img alt="P_{t-1}" class="mathcode" src="https://images2.imgbox.com/43/71/iTeGPz6W_o.png"> 推测到下一刻的协方差矩阵<img alt="P_{t}" class="mathcode" src="https://images2.imgbox.com/0f/37/y58zL7y9_o.png">呢？这里可以通过协方差的性质：<img alt="" height="61" src="https://images2.imgbox.com/07/e1/MnqMkD5P_o.png" width="655"></p> 
<p>来推出：（加上Q是因为这样的传递预测也同样是有噪声Q的）</p> 
<p class="img-center"><img alt="" height="123" src="https://images2.imgbox.com/f8/20/s5CFr4mL_o.png" width="300"></p> 
<h3 id="2.2%20%E6%9B%B4%E6%96%B0">2.2 更新</h3> 
<h4 id="2.2.1%20%E7%AC%AC%E4%B8%89%E6%9D%A1%E5%85%AC%E5%BC%8F%EF%BC%9A%E5%8D%A1%E5%B0%94%E6%9B%BC%E5%A2%9E%E7%9B%8A">2.2.1 第三条公式：卡尔曼增益</h4> 
<h4 id="2.2.2%C2%A0%E7%AC%AC%E5%9B%9B%E6%9D%A1%E5%85%AC%E5%BC%8F%EF%BC%9A%E8%A7%82%E6%B5%8B%E7%9F%A9%E9%98%B5">2.2.2 第四条公式：观测矩阵</h4> 
<h4 id="2.2.3%C2%A0%E7%AC%AC%E4%BA%94%E6%9D%A1%E5%85%AC%E5%BC%8F%EF%BC%9A">2.2.3 第五条公式： </h4> 
<hr> 
<h2 id="3%20%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E7%9A%84%E5%BA%94%E7%94%A8">3 卡尔曼滤波的应用</h2> 
<p>        假设这样一个场景：有一辆小车始终以1m/s的速度匀速行驶在公路，一共行驶了20秒。我们通过卡尔曼滤波在有强烈噪声干扰的情况下试试下，小车能否被准确预测出来速度1m/s，且每个时刻对应距离（11s对应位于离原点11m的距离）</p> 
<h3 id="3.1%20%E4%BB%A3%E7%A0%81">3.1 代码</h3> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1.1%20%E8%8E%B7%E5%8F%96%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E3%80%82">        3.1.1 获取场景数据。</h4> 
<pre><code class="language-python"># 假设条件；一个小车20秒里每秒匀速移动1米。
# 观测20个时刻状态的值
Z = np.array([x for x in range(1, 20+1)])
# 观测中的噪声
noise = np.random.randn(1, 20)
# 添加噪声
Z = Z + noise
Z = Z[0]
</code></pre> 
<p>        从加入了噪声的Z中可以看到，Z已经非常的混乱，那么我们的卡尔曼滤波是否还能够准确预测，达到我们理想中的情况呢？（速度1m/s，11s对应位于离原点11m的距离）</p> 
<pre><code class="language-python">&gt;&gt;&gt;print(Z)
&gt;&gt;&gt;[-1.54066623  2.65314083  2.55081667  3.60778965  3.5172674   6.24392259
  6.26421322  7.71828829  9.93166587  9.91688117 11.46280844 11.83685529
 12.13700321 13.5197601  12.52724415 17.40105333 16.84530721 18.10129522
 18.74874511 21.0930127 ]
</code></pre> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1.2%20%E5%88%9D%E5%A7%8B%E5%8C%96">        3.1.2 初始化</h4> 
<pre><code class="language-python"># 初始状态
X = np.array([0, 0])
# 初始状态协方差矩阵
P = np.eye(2)
# 初始化状态转移矩阵
F = np.array([
    [1, 1],
    [0, 1]
])
# 初始化状态转移矩阵协方差
Q = np.eye(2) * 0.0001
# 观测矩阵
H = np.eye(2)
# 观测矩阵噪声方差
R = np.eye(2)
</code></pre> 
<h4 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A03.1.3%20%E5%BC%80%E5%A7%8B%E9%A2%84%E6%B5%8B%E4%B8%8E%E6%9B%B4%E6%96%B0">        3.1.3 开始预测与更新</h4> 
<p class="img-center"><img alt="" height="190" src="https://images2.imgbox.com/d6/de/293sCuIp_o.png" width="362"></p> 
<pre><code class="language-python">p = []
v = []
for i in range(len(Z)):
    # 预测的两个式子
    X_ = np.dot(F, X)
    P_ = np.dot(F, P)
    P_ = np.dot(P_, F.T) + Q
    # 更新的三个式子
    k1 = np.dot(P_, H.T)
    k2 = np.dot(np.dot(H, P_), H.T) + R
    K = np.dot(k1, np.linalg.inv(k2))
    X = Z[i] - np.dot(H, X_)
    X = X_ + np.dot(K, X)
    P = np.eye(2) - np.dot(K, H)
    P = np.dot(P, P_)
    p.append(int(X[0]))
    v.append(int(X[1]))</code></pre> 
<h4 id="%C2%A0%20%C2%A0%20%C2%A0%20%C2%A0%203.1.4%20%E7%94%BB%E5%9B%BE%C2%A0">        3.1.4 画图 </h4> 
<p class="img-center"><img alt="" height="248" src="https://images2.imgbox.com/c8/20/DGcVDkIq_o.png" width="338"></p> 
<p style="text-align:center;">       （横轴位置p，纵轴速度v）</p> 
<p>        惊喜！我们可以从图中看出，只需要很少的迭代次数，卡尔曼滤波就能在极强的噪声干扰下依旧得出相对比较精准的结果！ps:有兴趣的伙伴可以试着增加场景的复杂度喔</p> 
<p style="text-align:center;"><span style="color:#4da8ee;"><strong>完整的代码 </strong></span></p> 
<pre><code class="language-python">import random
import matplotlib.pyplot as plt
import numpy as np

if __name__ == '__main__':
    # 假设条件；一个小车20秒里每秒匀速移动1米。
    # 观测20个时刻状态的值
    Z = np.array([x for x in range(1, 20+1)])
    # 观测中的噪声
    noise = np.random.randn(1, 20)
    # 添加噪声
    Z = Z + noise
    Z = Z[0]
    print(Z)
    # 初始状态
    X = np.array([0, 0])
    # 初始状态协方差矩阵
    P = np.eye(2)
    # 初始化状态转移矩阵
    F = np.array([
        [1, 1],
        [0, 1]
    ])
    # 初始化状态转移矩阵协方差
    Q = np.eye(2) * 0.0001
    # 观测矩阵
    H = np.eye(2)
    # 观测矩阵噪声方差
    R = np.eye(2)

    p = []
    v = []
    for i in range(len(Z)):
        # 预测两个方差式子
        X_ = np.dot(F, X)
        P_ = np.dot(F, P)
        P_ = np.dot(P_, F.T) + Q
        k1 = np.dot(P_, H.T)
        k2 = np.dot(np.dot(H, P_), H.T) + R
        K = np.dot(k1, np.linalg.inv(k2))
        X = Z[i] - np.dot(H, X_)
        X = X_ + np.dot(K, X)
        P = np.eye(2) - np.dot(K, H)
        P = np.dot(P, P_)
        p.append(int(X[0]))
        v.append(int(X[1]))
    plt.scatter(p, v)
    plt.show()</code></pre> 
<p>完毕！</p> 
<p>如果大家觉得本文对你有帮助的话，麻烦<span style="color:#956fe7;">点赞</span>+<span style="color:#1c7331;">收藏</span>，谢谢大家！</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d645f75da1ef54693c1387bd1664787b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Xshell连接不上Linux及网卡重启失败解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b92416db5a2665e0f0ef6be91e435a79/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mockjs模拟后台数据操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>