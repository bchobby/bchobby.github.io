<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【高阶系列二】数据清洗和准备——字符串操作 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【高阶系列二】数据清洗和准备——字符串操作" />
<meta property="og:description" content="字符串处理是数据清洗中常见的操作。在python中有两种方式进行字符串操作，一种是内置的字符串方法，一种是正则表达式工具——re模块。
目录
一、Python内置的字符串方法
二、正则表达式（Regular Expression）
2.1 普通字符
2.2 元字符（特殊字符）
2.2.1 单个字符匹配
2.2.2 预定义字符集
2.2.3 字符次数匹配——量词
2.2.4 边界匹配
2.2.5 逻辑与分组
2.2.6 特殊构造
2.2.7 贪婪模式与非贪婪模式
三、python正则表达式工具-re模块
3.1 Re模块对象属性
3.1.1 re模块对象
3.1.2 模式对象的方法和属性
3.1.3 匹配对象的方法和属性
3.1.4 实例
3.2 re模块的函数
四、向量化字符串函数
4.1 应用背景
4.2 pd.Series.str
4.3 Series.str函数
4.3.1 大小写转换
4.3.2 字符串填充
4.3.3. 字符串编码
4.3.4 字符串查找
4.3.5 解决判断问题
4.3.6 字符串修剪
4.3.7 分割字符串
4.3.8 字符串替换
4.3.9 统计字符函数
一、Python内置的字符串方法 方法说明示例string.count(sub)返回子串sub在字符串string中的出现次数，其中，string\sub均为字符串str string=&#39;a,bo,guido&#39;
print(type(string),string.count(&#39;o&#39;))
[out]: &lt;class &#39;str&#39;&gt; 2" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/eea0db490259c2f35b794c120571c941/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-14T16:14:09+08:00" />
<meta property="article:modified_time" content="2022-07-14T16:14:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【高阶系列二】数据清洗和准备——字符串操作</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>字符串处理是数据清洗中常见的操作。在python中有两种方式进行字符串操作，一种是内置的字符串方法，一种是正则表达式工具——re模块。</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81Python%E5%86%85%E7%BD%AE%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81Python%E5%86%85%E7%BD%AE%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95" rel="nofollow">一、Python内置的字符串方法</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88Regular%20Expression%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88Regular%20Expression%EF%BC%89" rel="nofollow">二、正则表达式（Regular Expression）</a></p> 
<p id="2.1%20%E6%99%AE%E9%80%9A%E5%AD%97%E7%AC%A6-toc" style="margin-left:40px;"><a href="#2.1%20%E6%99%AE%E9%80%9A%E5%AD%97%E7%AC%A6" rel="nofollow">2.1 普通字符</a></p> 
<p id="2.2%20%E5%85%83%E5%AD%97%E7%AC%A6%EF%BC%88%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.2%20%E5%85%83%E5%AD%97%E7%AC%A6%EF%BC%88%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%EF%BC%89" rel="nofollow">2.2 元字符（特殊字符）</a></p> 
<p id="2.2.1%20%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D-toc" style="margin-left:80px;"><a href="#2.2.1%20%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D" rel="nofollow">2.2.1 单个字符匹配</a></p> 
<p id="2.2.2%20%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E9%9B%86-toc" style="margin-left:80px;"><a href="#2.2.2%20%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E9%9B%86" rel="nofollow">2.2.2 预定义字符集</a></p> 
<p id="2.2.3%20%E5%AD%97%E7%AC%A6%E6%AC%A1%E6%95%B0%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94%E9%87%8F%E8%AF%8D-toc" style="margin-left:80px;"><a href="#2.2.3%20%E5%AD%97%E7%AC%A6%E6%AC%A1%E6%95%B0%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94%E9%87%8F%E8%AF%8D" rel="nofollow">2.2.3 字符次数匹配——量词</a></p> 
<p id="2.2.4%20%E8%BE%B9%E7%95%8C%E5%8C%B9%E9%85%8D-toc" style="margin-left:80px;"><a href="#2.2.4%20%E8%BE%B9%E7%95%8C%E5%8C%B9%E9%85%8D" rel="nofollow">2.2.4 边界匹配</a></p> 
<p id="2.2.5%20%E9%80%BB%E8%BE%91%E4%B8%8E%E5%88%86%E7%BB%84-toc" style="margin-left:80px;"><a href="#2.2.5%20%E9%80%BB%E8%BE%91%E4%B8%8E%E5%88%86%E7%BB%84" rel="nofollow">2.2.5 逻辑与分组</a></p> 
<p id="2.2.6%20%E7%89%B9%E6%AE%8A%E6%9E%84%E9%80%A0-toc" style="margin-left:80px;"><a href="#2.2.6%20%E7%89%B9%E6%AE%8A%E6%9E%84%E9%80%A0" rel="nofollow">2.2.6 特殊构造</a></p> 
<p id="%C2%A02.2.7%20%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%9D%9E%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%C2%A02.2.7%20%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%9D%9E%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F" rel="nofollow">2.2.7 贪婪模式与非贪婪模式</a></p> 
<p id="%E4%B8%89%E3%80%81python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B7%A5%E5%85%B7-re%E6%A8%A1%E5%9D%97-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B7%A5%E5%85%B7-re%E6%A8%A1%E5%9D%97" rel="nofollow">三、python正则表达式工具-re模块</a></p> 
<p id="3.1%20Re%E6%A8%A1%E5%9D%97%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7-toc" style="margin-left:40px;"><a href="#3.1%20Re%E6%A8%A1%E5%9D%97%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7" rel="nofollow">3.1 Re模块对象属性</a></p> 
<p id="3.1.1%20re%E6%A8%A1%E5%9D%97%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#3.1.1%20re%E6%A8%A1%E5%9D%97%E5%AF%B9%E8%B1%A1" rel="nofollow">3.1.1 re模块对象</a></p> 
<p id="3.1.2%20%E6%A8%A1%E5%BC%8F%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7-toc" style="margin-left:80px;"><a href="#3.1.2%20%E6%A8%A1%E5%BC%8F%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7" rel="nofollow">3.1.2 模式对象的方法和属性</a></p> 
<p id="3.1.3%20%E5%8C%B9%E9%85%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7-toc" style="margin-left:80px;"><a href="#3.1.3%20%E5%8C%B9%E9%85%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7" rel="nofollow">3.1.3 匹配对象的方法和属性</a></p> 
<p id="3.1.4%20%E5%AE%9E%E4%BE%8B-toc" style="margin-left:80px;"><a href="#3.1.4%20%E5%AE%9E%E4%BE%8B" rel="nofollow">3.1.4 实例</a></p> 
<p id="3.2%20re%E6%A8%A1%E5%9D%97%E7%9A%84%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#3.2%20re%E6%A8%A1%E5%9D%97%E7%9A%84%E5%87%BD%E6%95%B0" rel="nofollow">3.2 re模块的函数</a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0" rel="nofollow">四、向量化字符串函数</a></p> 
<p id="4.1%20%E5%BA%94%E7%94%A8%E8%83%8C%E6%99%AF-toc" style="margin-left:40px;"><a href="#4.1%20%E5%BA%94%E7%94%A8%E8%83%8C%E6%99%AF" rel="nofollow">4.1 应用背景</a></p> 
<p id="4.2%20pd.Series.str-toc" style="margin-left:40px;"><a href="#4.2%20pd.Series.str" rel="nofollow">4.2 pd.Series.str</a></p> 
<p id="4.3%20Series.str%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#4.3%20Series.str%E5%87%BD%E6%95%B0" rel="nofollow">4.3 Series.str函数</a></p> 
<p id="4.3.1%20%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2-toc" style="margin-left:80px;"><a href="#4.3.1%20%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2" rel="nofollow">4.3.1 大小写转换</a></p> 
<p id="4.3.2%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A1%AB%E5%85%85-toc" style="margin-left:80px;"><a href="#4.3.2%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A1%AB%E5%85%85" rel="nofollow">4.3.2 字符串填充</a></p> 
<p id="4.3.3.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81-toc" style="margin-left:80px;"><a href="#4.3.3.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81" rel="nofollow">4.3.3. 字符串编码</a></p> 
<p id="4.3.4%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE-toc" style="margin-left:80px;"><a href="#4.3.4%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE" rel="nofollow">4.3.4 字符串查找</a></p> 
<p id="4.3.5%20%E8%A7%A3%E5%86%B3%E5%88%A4%E6%96%AD%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#4.3.5%20%E8%A7%A3%E5%86%B3%E5%88%A4%E6%96%AD%E9%97%AE%E9%A2%98" rel="nofollow">4.3.5 解决判断问题</a></p> 
<p id="4.3.6%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BF%AE%E5%89%AA-toc" style="margin-left:80px;"><a href="#4.3.6%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BF%AE%E5%89%AA" rel="nofollow">4.3.6 字符串修剪</a></p> 
<p id="4.3.7%20%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2-toc" style="margin-left:80px;"><a href="#4.3.7%20%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2" rel="nofollow">4.3.7 分割字符串</a></p> 
<p id="4.3.8%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2-toc" style="margin-left:80px;"><a href="#4.3.8%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2" rel="nofollow">4.3.8 字符串替换</a></p> 
<p id="4.3.9%20%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#4.3.9%20%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0" rel="nofollow">4.3.9 统计字符函数</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81Python%E5%86%85%E7%BD%AE%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95">一、Python内置的字符串方法</h2> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="text-align:center;width:157px;"><strong>方法</strong></td><td style="text-align:center;width:212px;"><strong>说明</strong></td><td style="text-align:center;"><strong>示例</strong></td></tr><tr><td style="width:157px;">string.count(sub)</td><td style="width:212px;">返回子串sub在字符串string中的出现次数，其中，string\sub均为字符串str</td><td> <p>string='a,bo,guido'<br> print(type(string),string.count('o'))</p> <p>[out]: &lt;class 'str'&gt; 2</p> </td></tr><tr><td style="width:157px;"> <p>string.endswith(sub),</p> <p>string.startswith(sub)</p> </td><td style="width:212px;">如果字符串string以某个后缀sub结尾（以某个前缀开头），则返回True</td><td> <p>string='a,bo,guido'</p> <p>string.startswith('a')</p> <p>[out]:True</p> </td></tr><tr><td style="width:157px;">string.split(sub)</td><td style="width:212px;">通过指定的分隔符sub将字符串string分割成一组子串</td><td> <p>string='a,bo,guido'<br> pieces=string.split(',')<br> pieces</p> <p>[out]:['a', 'bo', 'guido']</p> </td></tr><tr><td style="width:157px;">sub.join(string)</td><td style="width:212px;">将sub插入到string的每个字符之间</td><td> <p>"-".join(pieces)</p> <p>[out]:'a-bo-guido'</p> <p>"1-2".join(pieces)</p> <p>[out]:'a1-2bo1-2guido'</p> </td></tr><tr><td style="width:157px;">string.index(sub)</td><td style="width:212px;">返回字符串string中子串sub首次出现的索引值，如果未找到sub，则返回ValueError</td><td> <p>string.index('o')</p> <p>[out]:3</p> <p>string.index('ao')</p> <p>[out]:ValueError</p> </td></tr><tr><td style="width:157px;">string.find(sub)</td><td style="width:212px;">返回字符串string中子串sub首次出现的索引值，如果未找到sub，则返回-1</td><td> <p>string.find('o')</p> <p>[out]:3</p> <p>string.find('ao')</p> <p>[out]:-1</p> </td></tr><tr><td style="width:157px;">string.find(sub)</td><td style="width:212px;">返回字符串string中子串sub最后出现的索引值，如果未找到，则返回-1</td><td> <p>string.rfind('o')</p> <p>[out]:9</p> </td></tr><tr><td style="width:157px;">string.replace(subold,subnew)</td><td style="width:212px;">在string中，用subnew替换subold生成新的字符串</td><td> <p>string.replace('a','-')</p> <p>[out]:'-,bo,guido'</p> </td></tr><tr><td style="width:157px;"> <p>string.strip()</p> <p>string.lstrip()</p> <p>string.rstrip()</p> </td><td style="width:212px;">去除空白符，常与split连用</td><td> <p>pieces2=[x.strip() for x in string.split(',')]<br> pieces2</p> <p>[out]:['a', 'bo', 'guido']</p> </td></tr><tr><td style="width:157px;"> <p>string.lower()</p> <p>string.upper()</p> </td><td style="width:212px;">将string的字符全部转换为小写（大写）</td><td> <p>string.upper()</p> <p>[out]:'A,BO,GUIDO'</p> </td></tr><tr><td style="width:157px;">string.title()</td><td style="width:212px;">将string的每个单词的首字母大写</td><td> <p>string.title()</p> <p>[out]:'A,Bo,Guido'</p> </td></tr><tr><td style="width:157px;"> <p>string.ljust(width, fillchar=' ', /)</p> <p>string.rjust(width, fillchar=' ', /)</p> </td><td style="width:212px;">返回指定长度width的字符串，左侧（右侧）以空格（默认）填充</td><td> <p>string.rjust(15)</p> <p>[out]:' a,bo,guido'</p> </td></tr></tbody></table> 
<h2 id="%E4%BA%8C%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88Regular%20Expression%EF%BC%89">二、正则表达式（Regular Expression）</h2> 
<p><strong>正则表达式（Regular Expression）是一种字符串匹配模式（Pattern Objects），由普通字符（自身值）+元字符（匹配规则）构成。</strong></p> 
<h3 id="2.1%20%E6%99%AE%E9%80%9A%E5%AD%97%E7%AC%A6">2.1 普通字符</h3> 
<p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符，包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。如：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="width:198px;"><strong>大小写字母</strong></td><td style="width:400px;"> <p>如：a-z;A-Z</p> </td></tr><tr><td style="width:198px;"><strong>数字</strong></td><td style="width:400px;">如：0-9</td></tr><tr><td style="width:198px;"><strong>标点符号</strong></td><td style="width:400px;">如：单引号' '</td></tr><tr><td style="width:198px;"><strong>非打印字符</strong></td><td style="width:400px;">如：换页符\f，换行符\n，制表符\t</td></tr></tbody></table> 
<h3 id="2.2%20%E5%85%83%E5%AD%97%E7%AC%A6%EF%BC%88%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%EF%BC%89">2.2 元字符（特殊字符）</h3> 
<p>元字符表示一种匹配规则，主要种类如下：</p> 
<h4 id="2.2.1%20%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D">2.2.1 单个字符匹配</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="text-align:center;width:63px;"><strong>语法</strong></td><td style="text-align:center;width:261px;"><strong>说明</strong></td><td style="text-align:center;width:122px;"><strong>regex实例</strong></td><td style="text-align:center;width:153px;"><strong>可Match对象</strong></td></tr><tr><td style="text-align:center;width:63px;"><strong>.</strong></td><td style="width:261px;">匹配除换行符'\n'外的任意一个字符；在DOTALL模式中，可匹配换行符</td><td style="text-align:center;width:122px;">a.c</td><td style="width:153px;"> <p style="text-align:center;">abc</p> <p style="text-align:center;">acc</p> <p style="text-align:center;">a\c等</p> </td></tr><tr><td colspan="1" rowspan="4" style="text-align:center;width:63px;"><strong>[...]</strong></td><td colspan="1" rowspan="4" style="width:261px;"> <p>表示一个字符集，也称为字符类；</p> <p>被匹配文本可以是这个字符集中的任意字符。[...]中的字符可以单个列出，也可以给出一个范围。</p> </td><td style="text-align:center;width:122px;">a[1-3bcd]z</td><td style="text-align:center;width:153px;"> <p style="text-align:center;">a1z</p> <p style="text-align:center;">abz等</p> </td></tr><tr><td style="text-align:center;width:122px;">[a-z]</td><td style="text-align:center;width:153px;"> <p style="text-align:center;">a、b等</p> </td></tr><tr><td style="text-align:center;width:122px;">[a-zA-Z]</td><td style="text-align:center;width:153px;">a、A等</td></tr><tr><td style="text-align:center;width:122px;">[1-9a-zA-Z]</td><td style="text-align:center;width:153px;">1、a、A等</td></tr><tr><td style="text-align:center;width:63px;"><strong>[^...]</strong></td><td style="width:261px;">表示匹配除该等字符集合外的其它任意一个字符，^在括号[ ]内表示取反</td><td style="text-align:center;width:122px;">a[^1-3bcd]z</td><td style="text-align:center;width:153px;">a4z、aez等</td></tr><tr><td style="text-align:center;width:63px;"><strong>\</strong></td><td style="width:261px;">转义字符，用来匹配元字符的自身值</td><td style="text-align:center;width:122px;">a\[bcd\]\e</td><td style="text-align:center;width:153px;"> <p style="text-align:center;">a[bcd]e</p> <p style="text-align:center;">此时，[ ]经过转义表示自身值</p> </td></tr></tbody></table> 
<p><strong>说明：所有元字符在[ ]内都将失去原有的特殊含义，具体如下：</strong></p> 
<p><strong>A. 被赋予新的特殊含义，如[^...]中^表示取反，[...^...]中^则表示其本身值^（变成普通字符）；</strong></p> 
<p><strong>B. 特殊字符变为普通字符，如 .  *  + ? $</strong></p> 
<p><strong>C. 普通字符变为特殊字符，如[A-Z]中'-'表示区间；[-AZ]中'-'则表示普通字符；</strong></p> 
<p><strong>D. [ ]中如果使用特殊字符的特殊含义，则在字符前面加上转义字符\。</strong></p> 
<h4 id="2.2.2%20%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E9%9B%86">2.2.2 预定义字符集</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="text-align:center;width:54px;"><strong>语法</strong></td><td style="text-align:center;width:270px;"><strong>说明</strong></td><td style="text-align:center;width:122px;"><strong>regex实例</strong></td><td style="text-align:center;width:153px;"><strong>可Match对象</strong></td></tr><tr><td style="text-align:center;width:54px;"><strong>\d</strong></td><td style="width:270px;">表示数字集合，即[0-9]</td><td style="text-align:center;">a\dc</td><td style="text-align:center;">a0c、a9c等</td></tr><tr><td style="text-align:center;width:54px;"><strong>\D</strong></td><td style="width:270px;">表示非数字字符集合，即[^0-9]</td><td style="text-align:center;">a\Dc</td><td style="text-align:center;">abc、a-c等</td></tr><tr><td style="text-align:center;width:54px;"><strong>\s</strong></td><td style="width:270px;">表示空白字符集合，即[&lt;空格&gt;\t\n\r\f\v]</td><td style="text-align:center;">a\sc</td><td style="text-align:center;">a c等</td></tr><tr><td style="text-align:center;width:54px;"><strong>\S</strong></td><td style="width:270px;">表示非空白字符集合，即[^\s]</td><td style="text-align:center;">a\Sc</td><td style="text-align:center;">abc、a1c等</td></tr><tr><td style="text-align:center;width:54px;"><strong>\w</strong></td><td style="width:270px;">表示单词字符（字母、数字和下划线）集合，等价于[a-zA-Z0-9]</td><td style="text-align:center;">a\wc</td><td style="text-align:center;">abc、aBc、a\c等</td></tr><tr><td style="text-align:center;width:54px;"><strong>\W</strong></td><td style="width:270px;">表示非单词字符（标点符号）集合，即[^a-zA-Z0-9]</td><td style="text-align:center;">a\Wc</td><td style="text-align:center;">a c、a&amp;c、a#c等</td></tr></tbody></table> 
<h4 id="2.2.3%20%E5%AD%97%E7%AC%A6%E6%AC%A1%E6%95%B0%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94%E9%87%8F%E8%AF%8D">2.2.3 字符次数匹配——量词</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="text-align:center;width:60px;"><strong>语法</strong></td><td style="text-align:center;width:285px;"><strong>说明</strong></td><td style="text-align:center;width:101px;"><strong>regex实例</strong></td><td style="text-align:center;width:153px;"><strong>可Match对象</strong></td></tr><tr><td style="text-align:center;width:60px;"><strong>?</strong></td><td style="width:285px;">表示匹配前面那个字符0次或1次</td><td style="text-align:center;width:101px;">ab?c</td><td style="text-align:center;">只能匹配abc、ac</td></tr><tr><td style="text-align:center;width:60px;"><strong>+</strong></td><td style="width:285px;">表示匹配前面那个字符至少1次</td><td style="text-align:center;width:101px;">ab+c</td><td style="text-align:center;">abc、abbc等</td></tr><tr><td style="text-align:center;width:60px;"><strong>*</strong></td><td style="width:285px;">表示匹配前面那个字符0次或者无限次</td><td style="text-align:center;width:101px;">ab*c</td><td style="text-align:center;">ac、abc、abbc等</td></tr><tr><td style="text-align:center;width:60px;"><strong>{m}</strong></td><td style="width:285px;">表示匹配前面那个字符m次</td><td style="text-align:center;width:101px;">ab{3}c</td><td style="text-align:center;">只能匹配abbbc</td></tr><tr><td style="text-align:center;width:60px;"><strong>{m,n}</strong></td><td style="width:285px;">表示匹配前面那个字符至少m次，至多n次</td><td style="text-align:center;width:101px;">ab{1,2}c</td><td style="text-align:center;">只能匹配abc、abbc</td></tr></tbody></table> 
<h4 id="2.2.4%20%E8%BE%B9%E7%95%8C%E5%8C%B9%E9%85%8D">2.2.4 边界匹配</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="text-align:center;width:60px;"><strong>语法</strong></td><td style="text-align:center;width:206px;"><strong>说明</strong></td><td style="text-align:center;width:180px;"><strong>regex实例</strong></td><td style="text-align:center;width:153px;"><strong>可Match对象</strong></td></tr><tr><td style="text-align:center;width:60px;"><strong>^</strong></td><td style="width:206px;">匹配字符串的开头</td><td style="text-align:center;width:180px;">^abc</td><td style="text-align:center;width:153px;">abc、abcde等</td></tr><tr><td style="text-align:center;width:60px;"><strong>$</strong></td><td style="width:206px;">匹配字符串末尾</td><td style="text-align:center;width:180px;">abc$</td><td style="text-align:center;width:153px;">abc、123abc等</td></tr><tr><td style="text-align:center;width:60px;"><strong>\A</strong></td><td style="width:206px;">仅匹配字符串的开头</td><td style="text-align:center;width:180px;">\Aabc</td><td style="text-align:center;width:153px;">abc、abcde等</td></tr><tr><td style="text-align:center;width:60px;"><strong>\Z</strong></td><td style="width:206px;">仅匹配字符串的末尾</td><td style="text-align:center;width:180px;">abc\Z</td><td style="text-align:center;width:153px;">abc、123abc等</td></tr><tr><td style="text-align:center;width:153px;"><strong>\b</strong></td><td style="width:206px;">匹配\w和\W之间，单词的词首和词尾</td><td style="text-align:center;width:180px;">a\b!bc</td><td style="text-align:center;width:153px;">a!bc</td></tr><tr><td style="text-align:center;width:60px;"><strong>\B</strong></td><td style="width:206px;">等价于[^\b]</td><td style="text-align:center;width:180px;">a\Bbc</td><td style="text-align:center;width:153px;">abc</td></tr></tbody></table> 
<h4 id="2.2.5%20%E9%80%BB%E8%BE%91%E4%B8%8E%E5%88%86%E7%BB%84">2.2.5 逻辑与分组</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="text-align:center;width:134px;"><strong>语法</strong></td><td style="text-align:center;width:195px;"><strong>说明</strong></td><td style="text-align:center;width:157px;"><strong>regex实例</strong></td><td style="text-align:center;width:112px;"><strong>可Match对象</strong></td></tr><tr><td style="text-align:center;width:134px;"><strong>|</strong></td><td style="width:195px;">表示逻辑或，表示它左右两边的表达式会任意匹配一个。实际上，它总是先尝试匹配它左边的表达式，一旦匹配成功则跳过右边表达式的匹配。如果|没有出现在( )中，则它的有效范围是整个正则表达式。</td><td style="text-align:center;width:157px;">abc|def</td><td style="text-align:center;width:112px;">只能匹配abc和def</td></tr><tr><td style="text-align:center;width:134px;"><strong>(...)</strong></td><td style="width:195px;"> <p>表示一个分组，且有分组序号；(...)作为一个整体，后可接表示次数的字符。</p> </td><td style="text-align:center;width:157px;">a(123|abc){2}e</td><td style="text-align:center;width:112px;">只能匹配a123123e、aabcabce</td></tr><tr><td style="text-align:center;width:134px;"><strong>（?P&lt;name&gt;...）</strong></td><td style="width:195px;">分组，用来给分组指定别名，match.group、regex.group可以看到</td><td style="text-align:center;width:157px;">a(?P&lt;id&gt;123|abc){2}e</td><td style="text-align:center;width:112px;">与上面表达式匹配内容相同，组的别名为id，可引用</td></tr><tr><td style="text-align:center;width:134px;"><strong>\&lt;number&gt;</strong></td><td style="width:195px;">引用编号为&lt;number&gt;的分组所匹配的字符串</td><td style="text-align:center;width:157px;"> <p style="text-align:center;">(\d)abc\1</p> </td><td style="text-align:center;width:112px;">1abc1、5abc5等</td></tr><tr><td style="text-align:center;width:134px;"><strong>(?P=name)</strong></td><td style="width:195px;">引用别名为name的分组所匹配的字符串</td><td style="text-align:center;width:157px;">(?P&lt;id&gt;\d)abc(?P=id)</td><td style="text-align:center;width:112px;">1abc1、2abc2等</td></tr></tbody></table> 
<h4 id="2.2.6%20%E7%89%B9%E6%AE%8A%E6%9E%84%E9%80%A0">2.2.6 特殊构造</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="text-align:center;width:134px;"><strong>语法</strong></td><td style="text-align:center;width:195px;"><strong>说明</strong></td><td style="text-align:center;width:137px;"><strong>regex实例</strong></td><td style="text-align:center;width:132px;"><strong>可Match对象</strong></td></tr><tr><td style="text-align:center;width:134px;"><strong>(?: ...)</strong></td><td style="width:195px;">(...)的不分组版本，用于使用|或后接数量词</td><td style="text-align:center;width:137px;">(?:abc){2}</td><td style="text-align:center;width:132px;">abcabc</td></tr><tr><td style="text-align:center;width:134px;"><strong>(?#...)</strong></td><td style="width:195px;">#后的内容为注释，将被忽略</td><td style="text-align:center;width:137px;">abc(?#flag)123</td><td style="text-align:center;width:132px;">abc123</td></tr><tr><td style="text-align:center;width:134px;"><strong>(?=...)</strong></td><td style="width:195px;">表示后面的字符串匹配这个表达时，整个regex才算匹配</td><td style="text-align:center;width:137px;">a(?=\d)</td><td style="text-align:center;width:132px;">表示字母a加一个数字的字符串</td></tr><tr><td style="text-align:center;width:134px;"><strong>(?!=...)</strong></td><td style="width:195px;">表示后面的字符串内容不匹配这个表达式时，整个regex才算匹配</td><td style="text-align:center;width:137px;">a(?!=\d)</td><td style="text-align:center;width:132px;">表示字母a加一个非数字的字符串</td></tr><tr><td style="text-align:center;width:134px;"><strong>(?&lt;=...)</strong></td><td style="width:195px;">表示前面的字符串内容匹配这个表达式时，整个regex才算匹配</td><td style="text-align:center;width:137px;">(?&lt;=\d)a</td><td style="text-align:center;width:132px;">表示一个数字加字母a的字符串</td></tr><tr><td style="text-align:center;width:134px;"><strong>(?&lt;!...)</strong></td><td style="width:195px;">表示前面的字符串内容不匹配这个表达式时，整个regex才算匹配</td><td style="text-align:center;width:137px;">(?&lt;!\d)a</td><td style="text-align:center;width:132px;">表示一个非数字加字母a的字符串</td></tr><tr><td style="text-align:center;width:134px;"><strong>(?(id/name)yes-pattern/no-pattern)</strong></td><td style="width:195px;">如编号为id/name匹配到字符串，则匹配yes-pattern，否则匹配no-pattern</td><td style="text-align:center;width:137px;">(\d)abc(?(1)\d|abc)</td><td style="text-align:center;width:132px;">1abc2、abcabc等</td></tr></tbody></table> 
<h4 id="%C2%A02.2.7%20%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%9D%9E%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F">2.2.7 贪婪模式与非贪婪模式</h4> 
<p>贪婪模式与非贪婪模式的选择适用于含量词的情况。</p> 
<p>贪婪模式：由多到少匹配，如[bcd]*，则先匹配bcd，如匹配不成功，则再匹配bc，如不成功，则再单个字符匹配</p> 
<p>非贪婪模式：由少到多匹配，[bcd]*?，先匹配0次，如不匹配，再匹配b，依次增多进行匹配。</p> 
<h2 id="%E4%B8%89%E3%80%81python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B7%A5%E5%85%B7-re%E6%A8%A1%E5%9D%97">三、python正则表达式工具-re模块</h2> 
<p>在python中，通过re模块实现正则表达式的应用。</p> 
<h3 id="3.1%20Re%E6%A8%A1%E5%9D%97%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">3.1 Re模块对象属性</h3> 
<h4 id="3.1.1%20re%E6%A8%A1%E5%9D%97%E5%AF%B9%E8%B1%A1">3.1.1 re模块对象</h4> 
<p>re模块包含两类对象：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="width:132px;"><strong>Pattern Objects</strong></td><td style="width:466px;"> <p><strong>模式对象，由re.compile生成</strong></p> </td></tr><tr><td style="width:132px;"><strong>Match Objects</strong></td><td style="width:466px;"><strong>匹配对象，由regex.match()、regex.fullmatch()、regex.search()三个函数生成</strong></td></tr></tbody></table> 
<h4 id="3.1.2%20%E6%A8%A1%E5%BC%8F%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7">3.1.2 模式对象的方法和属性</h4> 
<p><strong>         用regex表示模式对象:</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="text-align:center;width:147px;"><strong>方法名/属性名</strong></td><td style="text-align:center;width:451px;"><strong>描述</strong></td></tr><tr><td style="width:147px;">regex.match</td><td style="width:451px;">从字符串开始位置匹配正则表达式</td></tr><tr><td style="width:147px;">regex.fullmatch</td><td style="width:451px;">将整个字符串与regex匹配，相当于'^'和'$'精准匹配</td></tr><tr><td style="width:147px;">regex.search</td><td style="width:451px;">扫描整个字符串，查找regex可以匹配的字符串第一次出现的位置，并返回匹配对象</td></tr><tr><td style="width:147px;">regex.findall</td><td style="width:451px;">搜索字符串中与regex匹配的所有子串，以列表形式返回</td></tr><tr><td style="width:147px;">regex.finditer</td><td style="width:451px;">搜索字符串中与regex匹配的所有子串，以迭代器形式返回</td></tr><tr><td style="width:147px;">regex.sub</td><td style="width:451px;">替换字符串中与regex匹配的子串，返回新串</td></tr><tr><td style="width:147px;">regex.subn</td><td style="width:451px;">功能与regex.sub相同，同时返回替换次数</td></tr><tr><td style="width:147px;">regex.split</td><td style="width:451px;">将regex作为分隔符，对字符串进行分隔，生成分隔后的字符串列表</td></tr><tr><td style="width:147px;">regex.pattern</td><td style="width:451px;">属性，返回regex的pattern值</td></tr><tr><td style="width:147px;">regex.flags</td><td style="width:451px;">属性，返回regex的flags参数值</td></tr><tr><td style="width:147px;">regex.groups</td><td style="width:451px;">属性，返回regex中指定的“捕获组”的数量</td></tr><tr><td style="width:147px;">regex.groupindex</td><td style="width:451px;">属性，字典对象，存放“命名分组的分组名”与“该分组数量”的对应关系</td></tr></tbody></table> 
<h4 id="3.1.3%20%E5%8C%B9%E9%85%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7">3.1.3 匹配对象的方法和属性</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:618px;"><tbody><tr><td style="text-align:center;width:147px;"><strong>方法名/属性名</strong></td><td style="text-align:center;width:467px;"><strong>描述</strong></td></tr><tr><td style="text-align:center;width:147px;">match.group</td><td style="width:467px;">返回一个或多个指定捕获组所匹配的内容；group(0)代表整个匹配结果，group(1)代表第一个分组匹配部分，group(2)代表第二个分组匹配部分</td></tr><tr><td style="text-align:center;width:147px;">match.groups</td><td style="width:467px;">返回一个包含所有分组匹配内容的元组</td></tr><tr><td style="text-align:center;width:147px;">match.groupdict</td><td style="width:467px;">返回以别名的组名为键，以该组匹配内容为值的字典</td></tr><tr><td style="text-align:center;width:147px;">match.start([group])</td><td style="width:467px;">返回group组的起始索引，default=0</td></tr><tr><td style="text-align:center;width:147px;">match.end([group])</td><td style="width:467px;">返回group组的结尾索引</td></tr><tr><td style="text-align:center;width:147px;">match.span([group])</td><td style="width:467px;">返回group组的起始索引和结尾索引，0代表group(0)，1代表group(1)，以此类推</td></tr><tr><td style="text-align:center;width:147px;">match.expand(template)</td><td style="width:467px;">将group值代入template中返回，template可以是\d或\g&lt;id&gt;或\g&lt;name&gt;引用分组</td></tr><tr><td style="text-align:center;width:147px;">match.re</td><td style="width:467px;">匹配时使用的Pattern对象，属性</td></tr><tr><td style="text-align:center;width:147px;">match.string</td><td style="width:467px;">匹配时使用的string文本，属性</td></tr><tr><td style="text-align:center;width:147px;">match.pos</td><td style="width:467px;">文本中正则表达式开始搜索的索引，值与Pattern.match()和Pattern.search()方法的同名参数相同，属性</td></tr><tr><td style="text-align:center;width:147px;">match.endpos</td><td style="width:467px;">文中正则表达式结束搜索的索引，同上，属性</td></tr><tr><td style="text-align:center;width:147px;">match.lastindex</td><td style="width:467px;">最后一个被捕获的组在string中的索引，属性</td></tr><tr><td style="text-align:center;width:147px;">match.lastgroup</td><td style="width:467px;">最后一个被捕获的分组的别名，属性</td></tr></tbody></table> 
<h4 id="3.1.4%20%E5%AE%9E%E4%BE%8B">3.1.4 实例</h4> 
<p><strong>（1）match.group()、match.groups(）、match.span()</strong></p> 
<pre><code>&gt;&gt; import re
&gt;&gt; match=re.search('(abc)(cba)(def)','abccbadef123')
&gt;&gt; match
[out]:&lt;re.Match object; span=(0, 9), match='abccbadef'&gt;
&gt;&gt; match.span(0)
[out]:(0, 9)
&gt;&gt; match.group(0)
[out]:'abccbadef'
&gt;&gt; match.group(1)
[out]:'abc'
&gt;&gt; match.span(1)
[out]:(0, 3)
&gt;&gt; match.groups()
[out]:('abc', 'cba', 'def')</code></pre> 
<p><strong>（2）match.groupdict</strong></p> 
<pre><code>&gt;&gt; import re
&gt;&gt; match1=re.search('(?P&lt;name&gt;abc)(cba)(def)(?P&lt;id&gt;\d)','abccbadef1234')
&gt;&gt; match1
[out]:&lt;re.Match object; span=(0, 10), match='abccbadef1'&gt;
&gt;&gt; match1.groupdict()
[out]:{'name': 'abc', 'id': '1'}</code></pre> 
<p><strong>（3）match.expand</strong></p> 
<pre><code># 在expand中，三种引用方式的结果相同
&gt;&gt; match1.expand(r'The name is \g&lt;name&gt;,the number is \g&lt;id&gt;')
[out]:'The name is abc,the number is 1'
&gt;&gt; match1.expand(r'The name is \g&lt;1&gt;,the number is \g&lt;4&gt;')
[out]:'The name is abc,the number is 1'
&gt;&gt; match1.expand(r'The name is \1,the number is \4')
[out]:'The name is abc,the number is 1'
</code></pre> 
<h3 id="3.2%20re%E6%A8%A1%E5%9D%97%E7%9A%84%E5%87%BD%E6%95%B0">3.2 re模块的函数</h3> 
<p><strong>（1）re.compile </strong></p> 
<p>re.compile(pattern,flags=0)  将字符串形式的正则表达式编译为Pattern对象。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="text-align:center;width:153px;"><strong>参数</strong></td><td style="text-align:center;width:115px;"><strong>简称</strong></td><td style="text-align:center;width:355px;"><strong>描述</strong></td></tr><tr><td style="text-align:center;width:153px;">pattern</td><td style="text-align:center;width:115px;">/</td><td style="width:355px;">字符串形式的正则表达式regex</td></tr><tr><td style="text-align:center;width:153px;">re.IGNORECASE</td><td style="text-align:center;width:115px;">re.I</td><td style="width:355px;">执行正则匹配时忽略大小写</td></tr><tr><td style="text-align:center;width:153px;">re.MULTILINE</td><td style="text-align:center;width:115px;">re.M</td><td style="width:355px;">’^'和'$'可匹配每一行的行首和行尾</td></tr><tr><td style="text-align:center;width:153px;">re.LOCALE</td><td style="text-align:center;width:115px;">re.L</td><td style="width:355px;">使\w、\W、\b、\B的匹配依赖当前语言环境</td></tr><tr><td style="text-align:center;width:153px;">re.DOTALL</td><td style="text-align:center;width:115px;">re.S</td><td style="width:355px;">‘·’可匹配任意字符，包括换行符</td></tr><tr><td style="text-align:center;width:153px;">re.VERBOSE</td><td style="text-align:center;width:115px;">re.X</td><td style="width:355px;">忽略空白字符和注释</td></tr></tbody></table> 
<pre><code>&gt;&gt; import re
&gt;&gt; pattern=re.compile(r'hello')
&gt;&gt; m=pattern.match('hello world') 
&gt;&gt; m
[out]:&lt;re.Match object; span=(0, 5), match='hello'&gt;</code></pre> 
<p><strong>（2）re.match</strong></p> 
<p>re.match(pattern,string,flags=0)  同regex.match</p> 
<p><strong>（3）re.fullmatch</strong></p> 
<p>re.fullmatch(pattern,string,flags=0) 同regex.fullmatch</p> 
<p><strong>（4）re.search</strong></p> 
<p>re.search(pattern,string,flags=0) 同regex.search</p> 
<p><strong>（5）re.findall</strong></p> 
<p>re.findall(pattern,string,flags=0) 同regex.findall</p> 
<p><strong>（6）re.finditer</strong></p> 
<p>re.finditer(pattern,string,flags=0) 同regex.finditer</p> 
<p><strong>（7）re.sub</strong></p> 
<p>re.sub(pattern,repl,string,count=0,flags=0)  同regex.sub</p> 
<p><strong>（8）re.subn</strong></p> 
<p>re.subn(pattern,repl,string,count=0,flags=0) 同regex.subn</p> 
<p><strong>示例一：利用python内置的字符串方法</strong></p> 
<pre><code>&gt;&gt; text='pro---gram--files'
&gt;&gt; text.replace('-','')   # 利用python内置的字符串方法
[out]:'programfiles'
</code></pre> 
<p><strong>示例二：利用re.sub函数，repl为一个字符串</strong></p> 
<pre><code>&gt;&gt; re.sub(r'-+','',text) # 利用re.sub函数
[out]:'programfiles'

&gt;&gt; re.subn(r'-+','',text) # 利用re.subn函数
[out]:('programfiles', 2)</code></pre> 
<p><strong>示例三：利用re.sub函数，repl是一个自定义函数</strong></p> 
<pre><code>def dashrepl(match_obj):
    if match_obj.group()=='-':
        return ''
    else:
        return ''

re.sub(r'-+',dashrepl,text)
[out]:'programfiles'</code></pre> 
<p><strong>示例四：resub的pattern和repl参数均为正则表达式</strong></p> 
<pre><code>&gt;&gt; string='def myfunc(*args,**args)'
&gt;&gt; p=r'def\s+([a-zA-Z]\w*)\s*\((?P&lt;param&gt;.*)\)'
&gt;&gt; m=re.search(p,string)
&gt;&gt; m
[out]:&lt;re.Match object; span=(0, 24), match='def myfunc(*args,**args)'&gt;
&gt;&gt; m.group(0)
[out]:'def myfunc(*args,**args)'
&gt;&gt; m.group(1)
[out]:'myfunc'
&gt;&gt; m.group('param')
[out]:'*args,**args'
&gt;&gt; repl=r'def py_\1(\g&lt;param&gt;)'
&gt;&gt; re.sub(p,repl,string)
[out]:'def py_myfunc(*args,**args)'</code></pre> 
<p><strong>(9)re.split</strong></p> 
<p>re.split(pattern,string,maxsplit=0,flags=0)  同regex.split</p> 
<h2 id="%E5%9B%9B%E3%80%81%E5%90%91%E9%87%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0">四、向量化字符串函数</h2> 
<p>上述python内置的字符串方法及正则表达式为规范处理字符串提供了路径，但在数据处理中，一般需要处理DataFrame和Series形式的字符串序列，就涉及到向量化字符串函数。</p> 
<h3 id="4.1%20%E5%BA%94%E7%94%A8%E8%83%8C%E6%99%AF">4.1 应用背景</h3> 
<p>观察下面的例子：</p> 
<pre><code>&gt;&gt; import numpy as np
&gt;&gt; import pandas as pd
&gt;&gt; from pandas import DataFrame,Series
&gt;&gt; import re
&gt;&gt; data = {'Dave': 'dave@google.com', 'Steve': 'steve@gmail.com',
&gt;&gt;  .....:         'Rob': 'rob@gmail.com', 'Wes': np.nan}
&gt;&gt; data=pd.Series(data)
&gt;&gt; data
[out]:
Dave     dave@google.com
Steve    steve@gmail.com
Rob        rob@gmail.com
Wes                  NaN
dtype: object</code></pre> 
<p>data是含有缺失值的Series，按照惯常的方式，可以通过data.apply，所有字符串和正则表达式方法都能被应用于（传入lambda表达式或其他函数）各个值。</p> 
<pre><code>&gt;&gt; data.apply(lambda x:x.upper())
[out]:
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-29-6d48187fe861&gt; in &lt;module&gt;()
----&gt; 1 data.apply(lambda x:x.upper())

D:\ipython\lib\site-packages\pandas\core\series.py in apply(self, func, convert_dtype, args, **kwds)
   3192             else:
   3193                 values = self.astype(object).values
-&gt; 3194                 mapped = lib.map_infer(values, f, convert=convert_dtype)
   3195 
   3196         if len(mapped) and isinstance(mapped[0], Series):

pandas/_libs/src\inference.pyx in pandas._libs.lib.map_infer()

&lt;ipython-input-29-6d48187fe861&gt; in &lt;lambda&gt;(x)
----&gt; 1 data.apply(lambda x:x.upper())

AttributeError: 'float' object has no attribute 'upper'</code></pre> 
<p>可以看出，python会出现报错，主要原因是缺失数据NaN属于float类型，不适用于字符串的方法。</p> 
<pre><code>&gt;&gt; type(data['Wes'])
[out]:float</code></pre> 
<p>如果data不含缺失数据，则data.apply不会报错：</p> 
<pre><code>&gt;&gt; data1={'Dave': 'dave@google.com', 'Steve': 'steve@gmail.com',
&gt;&gt;    .....:         'Rob': 'rob@gmail.com'}
&gt;&gt; data1=pd.Series(data1)
&gt;&gt; data1
[out]:
Dave     dave@google.com
Steve    steve@gmail.com
Rob        rob@gmail.com
dtype: object

&gt;&gt; data1.apply(lambda x:x.upper())
[out]:
Dave     DAVE@GOOGLE.COM
Steve    STEVE@GMAIL.COM
Rob        ROB@GMAIL.COM
dtype: object
</code></pre> 
<p>除去上述方法外，pandas还提供了一种更为直接的方法，即pd.Series.str方法，可更加有效的处理字符串序列。</p> 
<h3 id="4.2%20pd.Series.str">4.2 pd.Series.str</h3> 
<p><strong>Series的str方法，提供了一种既可以高效化处理字符串序列，又可以正确处理缺失值的方法。</strong></p> 
<pre><code>&gt;&gt; help(pd.Series.str)
[out]:
class StringMethods(pandas.core.base.NoNewAttributesMixin)
 |  StringMethods(data)
 |  
 |  Vectorized string functions for Series and Index. NAs stay NA unless
 |  handled otherwise by a particular method. Patterned after Python's string
 |  methods, with some inspiration from R's stringr package.</code></pre> 
<h3 id="4.3%20Series.str%E5%87%BD%E6%95%B0">4.3 Series.str函数</h3> 
<p><strong>用法：Series.str.func()      func为函数名。</strong></p> 
<p><strong>举例：</strong></p> 
<pre><code>&gt;&gt; data
[out]:
Dave     dave@google.com
Steve    steve@gmail.com
Rob        rob@gmail.com
Wes                  NaN
dtype: object</code></pre> 
<h4 id="4.3.1%20%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><strong>4.3.1 大小写转换</strong></h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="text-align:center;width:150px;"><strong>函数/方法</strong></td><td style="text-align:center;width:145px;"><strong>说明</strong></td><td style="text-align:center;width:304px;"><strong>示例</strong></td></tr><tr><td style="width:150px;">Series.str.capitalize()</td><td style="width:145px;">字符串首字母大写，其余字母小写</td><td style="width:304px;"> <p>&gt;&gt; data.str.capitalize()</p> <p>[out]:</p> <pre>Dave     Dave@google.com
Steve    Steve@gmail.com
Rob        Rob@gmail.com
Wes                  NaN
dtype: object</pre> </td></tr><tr><td style="width:150px;">Series.str.title()</td><td style="width:145px;">字符串中，所有单词的首字母大写</td><td style="width:304px;"> <p>&gt;&gt; data.str.title()</p> <p>[out]:</p> <pre>Dave     Dave@Google.Com
Steve    Steve@Gmail.Com
Rob        Rob@Gmail.Com
Wes                  NaN
dtype: object</pre> </td></tr><tr><td style="width:150px;">Series.str.swapcase()</td><td style="width:145px;">字符串中，所有字母的大小写互换</td><td style="width:304px;"> <p>&gt;&gt; data.str.swapcase()</p> <p>[out]:</p> <pre>Dave     DAVE@GOOGLE.COM
Steve    STEVE@GMAIL.COM
Rob        ROB@GMAIL.COM
Wes                  NaN
dtype: object</pre> </td></tr><tr><td style="width:150px;">Series.str.lower()</td><td style="width:145px;">字符串中，所有字母小写</td><td style="width:304px;"> <p>&gt;&gt; data.str.lower()</p> <p>[out]:</p> <pre>Dave     dave@google.com
Steve    steve@gmail.com
Rob        rob@gmail.com
Wes                  NaN
dtype: object</pre> </td></tr><tr><td style="width:150px;">Series.str.upper()</td><td style="width:145px;">字符串中，所有字母大写</td><td style="width:304px;"> <p>&gt;&gt; data.str.upper()</p> <p>[out]:</p> <pre>Dave     DAVE@GOOGLE.COM
Steve    STEVE@GMAIL.COM
Rob        ROB@GMAIL.COM
Wes                  NaN
dtype: object</pre> </td></tr></tbody></table> 
<h4 id="4.3.2%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A1%AB%E5%85%85">4.3.2 字符串填充</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="text-align:center;width:157px;"><strong>函数/方法</strong></td><td style="text-align:center;width:187px;"><strong>说明</strong></td><td style="text-align:center;width:254px;"><strong>示例</strong></td></tr><tr><td style="width:157px;"> <pre>Series.str.center( width, fillchar=' ')</pre> </td><td style="width:187px;">返回两边用fillchar填充的、长度为width的字符串</td><td style="width:254px;"> <p>&gt;&gt; data.str.center(15,'*')</p> <p>[out]:</p> <pre>Dave     dave@google.com
Steve    steve@gmail.com
Rob      *rob@gmail.com*
Wes                  NaN
dtype: object</pre> </td></tr><tr><td style="width:157px;">Series.str.ljust( width, fillchar=' ')</td><td style="width:187px;">返回原字符左对齐，用fillchar填充，长度为width的字符串</td><td style="width:254px;"> <p>&gt;&gt; data.str.ljust(15,'*')</p> <p>[out]:</p> <pre>Dave     dave@google.com
Steve    steve@gmail.com
Rob      rob@gmail.com**
Wes                  NaN
dtype: object</pre> </td></tr><tr><td style="width:157px;">Series.str.rjust( width, fillchar=' ')</td><td style="width:187px;">返回原字符右对齐，用fillchar填充的字符串</td><td style="width:254px;"> <p>&gt;&gt; data.str.rjust(15,'*')</p> <p>[out]:</p> <pre>Dave     dave@google.com
Steve    steve@gmail.com
Rob      **rob@gmail.com
Wes                  NaN
dtype: object</pre> </td></tr><tr><td style="width:157px;">Series.str.zfill(width)</td><td style="width:187px;">原字符串右对齐，前面用0填充长度为width的字符串</td><td style="width:254px;"> <p>&gt;&gt; data.str.zfill(15)</p> <p>[out]:</p> <pre>Dave     dave@google.com
Steve    steve@gmail.com
Rob      00rob@gmail.com
Wes                  NaN
dtype: object</pre> </td></tr></tbody></table> 
<h4 id="4.3.3.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81">4.3.3. 字符串编码</h4> 
<p><img alt="" height="553" src="https://images2.imgbox.com/d0/e8/mWCpHR3R_o.png" width="1200"></p> 
<p></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="text-align:center;width:157px;"><strong>函数/方法</strong></td><td style="text-align:center;width:187px;"><strong>说明</strong></td><td style="text-align:center;width:254px;"><strong>示例</strong></td></tr><tr><td style="text-align:center;width:157px;">Series.str.encode()</td><td style="width:187px;">编码（字符集——计算机数字代码）</td><td style="width:254px;"> <p>&gt;&gt; data2=data.str.encode('UTF-8')<br> &gt;&gt; data2</p> <p>[out]:</p> <pre>Dave     b'dave@google.com'
Steve    b'steve@gmail.com'
Rob        b'rob@gmail.com'
Wes                     NaN
dtype: object</pre> <p>&gt;&gt; type(data2['Dave'])</p> <p>[out]:bytes</p> </td></tr><tr><td style="text-align:center;width:157px;">Series.str.decode()</td><td style="width:187px;">解码（计算机数字代码——字符集）</td><td style="width:254px;">略</td></tr></tbody></table> 
<h4 id="4.3.4%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE">4.3.4 字符串查找</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="text-align:center;width:249px;"><strong>函数/方法</strong></td><td style="text-align:center;width:183px;"><strong>说明</strong></td><td style="text-align:center;width:194px;"><strong>示例</strong></td></tr><tr><td style="width:249px;">Series.str.find(sub, start=0, end=None)</td><td style="width:183px;">查找字符串中子字符串sub第一次出现的位置，若无则返回-1</td><td style="width:194px;"> <p>&gt;&gt; data.str.find('gmail')</p> <p>[out]:</p> <pre>Dave    -1.0
Steve    6.0
Rob      4.0
Wes      NaN
dtype: float64</pre> </td></tr><tr><td style="width:249px;">Series.str.rfind(sub, start=0, end=None)</td><td style="width:183px;">查找字符串中子字符串sub最后一次出现的位置，若无则返回-1</td><td style="width:194px;"> <p>&gt;&gt; data.str.rfind('o')</p> <p>[out]:</p> <pre>Dave     13.0
Steve    13.0
Rob      11.0
Wes       NaN
dtype: float64</pre> </td></tr><tr><td style="width:249px;">Series.str.index(sub, start=0, end=None)</td><td style="width:183px;">同str.find，若无则会报错</td><td style="width:194px;">略</td></tr><tr><td style="width:249px;">Series.str.rindex(sub,start=0,end=None)</td><td style="width:183px;">同str.rfind，若无则会报错</td><td style="width:194px;">略</td></tr></tbody></table> 
<h4 id="4.3.5%20%E8%A7%A3%E5%86%B3%E5%88%A4%E6%96%AD%E9%97%AE%E9%A2%98">4.3.5 解决判断问题</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="text-align:center;width:244px;"><strong>函数/方法</strong></td><td style="text-align:center;width:183px;"><strong>说明</strong></td><td style="text-align:center;width:170px;"><strong>示例</strong></td></tr><tr><td style="width:244px;"> <p>Series.str.endswith(pat, na=nan)</p> <p>pat : str Character sequence.</p> <p>Regular expressions are not accepted.</p> </td><td style="width:183px;">判断字符串是否以指定字符或者子字符串结尾</td><td style="text-align:center;width:170px;"> <p>&gt;&gt;data.str.endswith('com')</p> <pre style="text-align:left;">[out]:
Dave     True
Steve    True
Rob      True
Wes       NaN
dtype: object</pre> </td></tr><tr><td style="width:244px;"> <p>Series.str.startswith(pat, na=nan)</p> <p>pat : str Character sequence.</p> <p>Regular expressions are not accepted.</p> </td><td style="width:183px;">判断字符串是否以指定字符或子字符串开头</td><td style="width:170px;">略</td></tr><tr><td style="width:244px;"> <p>Series.str.isalnum()</p> </td><td style="width:183px;"> <p>alnum为（alphabet+number),</p> <p>判断字符串是否由字母和数字组成</p> </td><td style="width:170px;"> <p>&gt;&gt; data.str.isalnum()</p> <p>[out]:</p> <pre>Dave     False
Steve    False
Rob      False
Wes        NaN
dtype: object</pre> </td></tr><tr><td style="width:244px;">Series.str.isalpha()</td><td style="width:183px;">判断字符串是否只由字母组成</td><td style="width:170px;"> <p>&gt;&gt; data.str.isalnum()</p> <p>[out]:</p> <pre>Dave     False
Steve    False
Rob      False
Wes        NaN
dtype: object</pre> </td></tr><tr><td style="width:244px;">Series.str.isdecimal()</td><td style="width:183px;">判断字符串是否只包含十进制字符</td><td style="width:170px;">略</td></tr><tr><td style="width:244px;">Series.str.isdigit()</td><td style="width:183px;">判断字符串是否只由数字组成</td><td style="width:170px;">略</td></tr><tr><td style="width:244px;">Series.str.islower()</td><td style="width:183px;">判断字符串中的字符是否全部为小写字母</td><td style="width:170px;"> <p>&gt;&gt; data.str.islower()</p> <p>[out]:</p> <pre>Dave     True
Steve    True
Rob      True
Wes       NaN
dtype: object</pre> </td></tr><tr><td style="width:244px;">Series.str.isupper()</td><td style="width:183px;">判断字符串中的字母是否全部为大写字母</td><td style="width:170px;">略</td></tr><tr><td style="width:244px;">Series.str.isnumeric()</td><td style="width:183px;">判断字符串是否只由数字组成</td><td style="width:170px;">略</td></tr><tr><td style="width:244px;">Series.str.isspace()</td><td style="width:183px;">判断字符串是否只由空格组成</td><td style="width:170px;">略</td></tr><tr><td style="width:244px;">Series.str.istitle()</td><td style="width:183px;">判断字符串中所有单词的首字母是否为大写</td><td style="width:170px;">略</td></tr></tbody></table> 
<h4 id="4.3.6%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BF%AE%E5%89%AA">4.3.6 字符串修剪</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="text-align:center;width:223px;"><strong>函数/方法</strong></td><td style="text-align:center;width:375px;"><strong>说明</strong></td></tr><tr><td style="width:223px;">Series.str.strip()</td><td style="width:375px;">去掉字符串开头和尾部指定的字符，默认为空格</td></tr><tr><td style="width:223px;">Series.str.lstrip()</td><td style="width:375px;">去掉开头的指定字符，默认空格</td></tr><tr><td style="width:223px;">Series.str.rstrip()</td><td style="width:375px;">去掉尾部的指定字符，默认空格</td></tr></tbody></table> 
<h4 id="4.3.7%20%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2">4.3.7 分割字符串</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="text-align:center;width:194px;"><strong>函数/方法</strong></td><td style="text-align:center;width:147px;"><strong>说明</strong></td><td style="text-align:center;width:256px;"><strong>示例</strong></td></tr><tr><td style="text-align:center;width:194px;">Series.str.partition(pat=' ', expand=True)</td><td style="width:147px;">用指定分隔符将字符串分为三部分，第一部分为pat前段，第二部分为pat，第三部分为pat后段</td><td style="text-align:center;width:256px;"> <p>&gt;&gt; data.str.partition('@')</p> <p>[out]:</p> <p><img alt="" height="286" src="https://images2.imgbox.com/3e/a3/AQrtZ0pi_o.png" width="455"></p> </td></tr><tr><td style="text-align:center;width:194px;">Series.str.rpartition(pat=' ', expand=True)</td><td style="width:147px;">功能与partition相同，但是是从右边第一个pat分割字符串</td><td style="text-align:center;width:256px;">略</td></tr><tr><td style="text-align:center;width:194px;">Series.str.split((pat=None, n=-1, expand=False)</td><td style="width:147px;">用指定分隔符sep分割字符串，返回分割后的字符串列表（list)</td><td style="text-align:center;width:256px;"> <p>&gt;&gt; data.str.split('@')</p> <p>[out]:</p> <p><img alt="" height="204" src="https://images2.imgbox.com/52/0b/8KsKYbtp_o.png" width="438"></p> </td></tr><tr><td style="text-align:center;width:194px;"> <p style="text-align:center;">Series.str.join(sep)</p> <pre>sep : str
Delimiter to use between list entries.</pre> </td><td style="width:147px;">将指定字符插入字符串序列中生成新的字符串</td><td style="width:256px;"> <p>&gt;&gt; data.str.join('-')</p> <p>[out]:</p> <p><img alt="" height="211" src="https://images2.imgbox.com/72/4e/K5Q3KvaJ_o.png" width="610"></p> </td></tr></tbody></table> 
<h4 id="4.3.8%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2">4.3.8 字符串替换</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="text-align:center;width:262px;"><strong>函数/方法</strong></td><td style="text-align:center;width:171px;"><strong>说明</strong></td><td style="text-align:center;width:164px;"><strong>示例</strong></td></tr><tr><td style="width:262px;"> <p>Series.str.replace(pat, repl, n=-1, case=None, flags=0, regex=True)</p> <p>pat : string or compiled regex String can be a character sequence or regular expression.</p> <p>repl : string or callable Replacement string or a callable.</p> </td><td style="width:171px;">将pat子字符串替换为repl子字符串，替换次数为count次</td><td style="width:164px;"> <p>&gt;&gt; data.str.replace('google','gmail')</p> <p>[out]:</p> <p><img alt="" height="197" src="https://images2.imgbox.com/65/d3/gruuWnkg_o.png" width="395"></p> </td></tr></tbody></table> 
<h4 id="4.3.9%20%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E5%87%BD%E6%95%B0">4.3.9 统计字符函数</h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:600px;"><tbody><tr><td style="text-align:center;width:262px;"><strong>函数/方法</strong></td><td style="text-align:center;width:171px;"><strong>说明</strong></td><td style="text-align:center;width:164px;"><strong>示例</strong></td></tr><tr><td style="text-align:center;width:262px;"> <p>Series.str.count(pat, flags=0, **kwargs)</p> <p>pat : str Valid regular expression.</p> </td><td style="width:171px;">统计字符串中pat子字符串出现的次数</td><td style="width:164px;"> <p>&gt;&gt; data.str.count('gmail')</p> <p>[out]:</p> <p><img alt="" height="198" src="https://images2.imgbox.com/2e/5c/xB1GzRmK_o.png" width="228"></p> </td></tr></tbody></table> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9cd511f5aa46d563dd332267f7f91804/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何在PD虚拟机中开启系统的嵌套虚拟化功能？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f809c76a781e730e49300a4c678bd865/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vscode报错：无法将“node.exe”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>