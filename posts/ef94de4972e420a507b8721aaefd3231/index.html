<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>sass/scss 浅谈 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="sass/scss 浅谈" />
<meta property="og:description" content="目录
前言
一、了解 sass
1、特点
2、语法格式
二、Sass 的语法
1、嵌套
（1）、最简单的嵌套实例
（2）、父选择器——&amp; 符
（3）、属性嵌套
（4）、占位符选择器 %foo
2、注释
（1）、多行注释 /* */ 与 单行注释 //
（2）、! 符 —— 压缩输出模式下保留的注释
（3）、注释中使用插值语句输出变量值
3、SassScript——变量、运算
（1）、$ 符 —— 变量
（2）、数据类型
（3）、运算
（4）、圆括号
（5）、 &amp; 在 SassScript 中
（6）、变量定义 !default
4、函数
（1）、最简单的 SassScript 函数
（2）、带参数变量的 SassScript 函数
（3）、函数中使用 插值表达式 #{}
（4）、自定义 Sass 函数——函数指令 @function
5、@-Rules 与指令
（1）、@import —— 导入文件
（2）、@media —— 媒体查询
（3）、@extend —— 继承（难点）
（4）、@at-root
（5）、@debug（了解）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/ef94de4972e420a507b8721aaefd3231/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-17T11:30:01+08:00" />
<meta property="article:modified_time" content="2023-12-17T11:30:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">sass/scss 浅谈</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
<p id="%E4%B8%80%E3%80%81%E4%BA%86%E8%A7%A3%20sass-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BA%86%E8%A7%A3%20sass" rel="nofollow">一、了解 sass</a></p> 
<p id="1%E3%80%81%E7%89%B9%E7%82%B9-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E7%89%B9%E7%82%B9" rel="nofollow">1、特点</a></p> 
<p id="2%E3%80%81%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F" rel="nofollow">2、语法格式</a></p> 
<p id="%E4%BA%8C%E3%80%81Sass%20%E7%9A%84%E8%AF%AD%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81Sass%20%E7%9A%84%E8%AF%AD%E6%B3%95" rel="nofollow">二、Sass 的语法</a></p> 
<p id="1%E3%80%81%E5%B5%8C%E5%A5%97-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%B5%8C%E5%A5%97" rel="nofollow">1、嵌套</a></p> 
<p id="%EF%BC%881%EF%BC%89%E3%80%81%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%B5%8C%E5%A5%97%E5%AE%9E%E4%BE%8B-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E3%80%81%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%B5%8C%E5%A5%97%E5%AE%9E%E4%BE%8B" rel="nofollow">（1）、最简单的嵌套实例</a></p> 
<p id="%EF%BC%882%EF%BC%89%E3%80%81%26%20%E7%AC%A6%E2%80%94%E2%80%94%E7%88%B6%E9%80%89%E6%8B%A9%E5%99%A8-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E3%80%81%26%20%E7%AC%A6%E2%80%94%E2%80%94%E7%88%B6%E9%80%89%E6%8B%A9%E5%99%A8" rel="nofollow">（2）、父选择器——&amp; 符</a></p> 
<p id="%EF%BC%883%EF%BC%89%E3%80%81%E5%B1%9E%E6%80%A7%E5%B5%8C%E5%A5%97-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E3%80%81%E5%B1%9E%E6%80%A7%E5%B5%8C%E5%A5%97" rel="nofollow">（3）、属性嵌套</a></p> 
<p id="%EF%BC%884%EF%BC%89%E3%80%81%E5%8D%A0%E4%BD%8D%E7%AC%A6%E9%80%89%E6%8B%A9%E5%99%A8%20%25foo-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E3%80%81%E5%8D%A0%E4%BD%8D%E7%AC%A6%E9%80%89%E6%8B%A9%E5%99%A8%20%25foo" rel="nofollow">（4）、占位符选择器 %foo</a></p> 
<p id="2%E3%80%81%E6%B3%A8%E9%87%8A-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E6%B3%A8%E9%87%8A" rel="nofollow">2、注释</a></p> 
<p id="%EF%BC%881%EF%BC%89%E3%80%81%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A%20%2F*%20*%2F%20%E4%B8%8E%20%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A%20%2F%2F-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E3%80%81%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A%20%2F*%20*%2F%20%E4%B8%8E%20%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A%20%2F%2F" rel="nofollow">（1）、多行注释 /* */ 与 单行注释 //</a></p> 
<p id="%EF%BC%882%EF%BC%89%E3%80%81!%20%E7%AC%A6%20%E2%80%94%E2%80%94%C2%A0%E5%8E%8B%E7%BC%A9%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F%E4%B8%8B%E4%BF%9D%E7%95%99%E7%9A%84%E6%B3%A8%E9%87%8A-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E3%80%81!%20%E7%AC%A6%20%E2%80%94%E2%80%94%C2%A0%E5%8E%8B%E7%BC%A9%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F%E4%B8%8B%E4%BF%9D%E7%95%99%E7%9A%84%E6%B3%A8%E9%87%8A" rel="nofollow">（2）、! 符 —— 压缩输出模式下保留的注释</a></p> 
<p id="%EF%BC%883%EF%BC%89%E3%80%81%E6%B3%A8%E9%87%8A%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%8F%92%E5%80%BC%E8%AF%AD%E5%8F%A5%E8%BE%93%E5%87%BA%E5%8F%98%E9%87%8F%E5%80%BC-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E3%80%81%E6%B3%A8%E9%87%8A%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%8F%92%E5%80%BC%E8%AF%AD%E5%8F%A5%E8%BE%93%E5%87%BA%E5%8F%98%E9%87%8F%E5%80%BC" rel="nofollow">（3）、注释中使用插值语句输出变量值</a></p> 
<p id="3%E3%80%81SassScript%E2%80%94%E2%80%94%E5%8F%98%E9%87%8F%E3%80%81%E8%BF%90%E7%AE%97-toc" style="margin-left:40px;"><a href="#3%E3%80%81SassScript%E2%80%94%E2%80%94%E5%8F%98%E9%87%8F%E3%80%81%E8%BF%90%E7%AE%97" rel="nofollow">3、SassScript——变量、运算</a></p> 
<p id="%EF%BC%881%EF%BC%89%E3%80%81%24%20%E7%AC%A6%20%E2%80%94%E2%80%94%20%E5%8F%98%E9%87%8F-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E3%80%81%24%20%E7%AC%A6%20%E2%80%94%E2%80%94%20%E5%8F%98%E9%87%8F" rel="nofollow">（1）、$ 符 —— 变量</a></p> 
<p id="%EF%BC%882%EF%BC%89%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" rel="nofollow">（2）、数据类型</a></p> 
<p id="%EF%BC%883%EF%BC%89%E3%80%81%E8%BF%90%E7%AE%97-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E3%80%81%E8%BF%90%E7%AE%97" rel="nofollow">（3）、运算</a></p> 
<p id="%EF%BC%884%EF%BC%89%E3%80%81%E5%9C%86%E6%8B%AC%E5%8F%B7-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E3%80%81%E5%9C%86%E6%8B%AC%E5%8F%B7" rel="nofollow">（4）、圆括号</a></p> 
<p id="%EF%BC%885%EF%BC%89%E3%80%81%C2%A0%26%20%E5%9C%A8%20SassScript%20%E4%B8%AD-toc" style="margin-left:80px;"><a href="#%EF%BC%885%EF%BC%89%E3%80%81%C2%A0%26%20%E5%9C%A8%20SassScript%20%E4%B8%AD" rel="nofollow">（5）、 &amp; 在 SassScript 中</a></p> 
<p id="%EF%BC%886%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%20!default-toc" style="margin-left:80px;"><a href="#%EF%BC%886%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%20!default" rel="nofollow">（6）、变量定义 !default</a></p> 
<p id="4%E3%80%81%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E5%87%BD%E6%95%B0" rel="nofollow">4、函数</a></p> 
<p id="%EF%BC%881%EF%BC%89%E3%80%81%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%C2%A0SassScript%20%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E3%80%81%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%C2%A0SassScript%20%E5%87%BD%E6%95%B0" rel="nofollow">（1）、最简单的 SassScript 函数</a></p> 
<p id="%EF%BC%882%EF%BC%89%E3%80%81%E5%B8%A6%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F%E7%9A%84%C2%A0SassScript%20%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E3%80%81%E5%B8%A6%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F%E7%9A%84%C2%A0SassScript%20%E5%87%BD%E6%95%B0" rel="nofollow">（2）、带参数变量的 SassScript 函数</a></p> 
<p id="%EF%BC%883%EF%BC%89%E3%80%81%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%C2%A0%E6%8F%92%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F%C2%A0%23%7B%7D-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E3%80%81%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%C2%A0%E6%8F%92%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F%C2%A0%23%7B%7D" rel="nofollow">（3）、函数中使用 插值表达式 #{}</a></p> 
<p id="%EF%BC%884%EF%BC%89%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%20Sass%20%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E6%8C%87%E4%BB%A4%20%40function-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%20Sass%20%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E6%8C%87%E4%BB%A4%20%40function" rel="nofollow">（4）、自定义 Sass 函数——函数指令 @function</a></p> 
<p id="5%E3%80%81%40-Rules%20%E4%B8%8E%E6%8C%87%E4%BB%A4-toc" style="margin-left:40px;"><a href="#5%E3%80%81%40-Rules%20%E4%B8%8E%E6%8C%87%E4%BB%A4" rel="nofollow">5、@-Rules 与指令</a></p> 
<p id="%EF%BC%881%EF%BC%89%E3%80%81%40import%20%E2%80%94%E2%80%94%20%E5%AF%BC%E5%85%A5%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E3%80%81%40import%20%E2%80%94%E2%80%94%20%E5%AF%BC%E5%85%A5%E6%96%87%E4%BB%B6" rel="nofollow">（1）、@import —— 导入文件</a></p> 
<p id="%EF%BC%882%EF%BC%89%E3%80%81%40media%20%E2%80%94%E2%80%94%20%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E3%80%81%40media%20%E2%80%94%E2%80%94%20%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2" rel="nofollow">（2）、@media —— 媒体查询</a></p> 
<p id="%EF%BC%883%EF%BC%89%E3%80%81%40extend%20%E2%80%94%E2%80%94%20%E7%BB%A7%E6%89%BF%EF%BC%88%E9%9A%BE%E7%82%B9%EF%BC%89-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E3%80%81%40extend%20%E2%80%94%E2%80%94%20%E7%BB%A7%E6%89%BF%EF%BC%88%E9%9A%BE%E7%82%B9%EF%BC%89" rel="nofollow">（3）、@extend —— 继承（难点）</a></p> 
<p id="%EF%BC%884%EF%BC%89%E3%80%81%40at-root-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E3%80%81%40at-root" rel="nofollow">（4）、@at-root</a></p> 
<p id="%EF%BC%885%EF%BC%89%E3%80%81%40debug-toc" style="margin-left:80px;"><a href="#%EF%BC%885%EF%BC%89%E3%80%81%40debug" rel="nofollow">（5）、@debug（了解）</a></p> 
<p id="%EF%BC%886%EF%BC%89%E3%80%81%40warn%C2%A0-toc" style="margin-left:80px;"><a href="#%EF%BC%886%EF%BC%89%E3%80%81%40warn%C2%A0" rel="nofollow">（6）、@warn（了解）</a></p> 
<p id="%EF%BC%887%EF%BC%89%E3%80%81%40error%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:80px;"><a href="#%EF%BC%887%EF%BC%89%E3%80%81%40error%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89" rel="nofollow">（7）、@error（了解）</a></p> 
<p id="6%E3%80%81%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4" rel="nofollow">6、控制指令</a></p> 
<p id="%EF%BC%881%EF%BC%89%E3%80%81if()-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E3%80%81if%28%29" rel="nofollow">（1）、if()（了解）</a></p> 
<p id="%EF%BC%882%EF%BC%89%E3%80%81%40if()-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E3%80%81%40if%28%29" rel="nofollow">（2）、@if()</a></p> 
<p id="%EF%BC%883%EF%BC%89%E3%80%81%40for-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E3%80%81%40for" rel="nofollow">（3）、@for</a></p> 
<p id="%EF%BC%884%EF%BC%89%E3%80%81%40each-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E3%80%81%40each" rel="nofollow">（4）、@each</a></p> 
<p id="%EF%BC%885%EF%BC%89%E3%80%81%40while-toc" style="margin-left:80px;"><a href="#%EF%BC%885%EF%BC%89%E3%80%81%40while" rel="nofollow">（5）、@while</a></p> 
<p id="7%E3%80%81%E6%B7%B7%E5%90%88%E6%8C%87%E4%BB%A4-toc" style="margin-left:40px;"><a href="#7%E3%80%81%E6%B7%B7%E5%90%88%E6%8C%87%E4%BB%A4" rel="nofollow">7、混合指令</a></p> 
<p id="%EF%BC%881%EF%BC%89%E3%80%81%E5%AE%9A%E4%B9%89%E6%B7%B7%E5%90%88%E6%8C%87%E4%BB%A4%20%40mixin-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E3%80%81%E5%AE%9A%E4%B9%89%E6%B7%B7%E5%90%88%E6%8C%87%E4%BB%A4%20%40mixin" rel="nofollow">（1）、定义混合指令 @mixin</a></p> 
<p id="%C2%A0%EF%BC%882%EF%BC%89%E3%80%81%E5%BC%95%E7%94%A8%E6%B7%B7%E5%90%88%E6%A0%B7%E5%BC%8F%20%40include-toc" style="margin-left:80px;"><a href="#%C2%A0%EF%BC%882%EF%BC%89%E3%80%81%E5%BC%95%E7%94%A8%E6%B7%B7%E5%90%88%E6%A0%B7%E5%BC%8F%20%40include" rel="nofollow"> （2）、引用混合样式 @include</a></p> 
<p id="%EF%BC%883%EF%BC%89%E3%80%81%E5%8F%82%E6%95%B0-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E3%80%81%E5%8F%82%E6%95%B0" rel="nofollow">（3）、参数</a></p> 
<p id="%EF%BC%884%EF%BC%89%E3%80%81%E5%90%91%E6%B7%B7%E5%90%88%E6%A0%B7%E5%BC%8F%E4%B8%AD%E5%AF%BC%E5%85%A5%E5%86%85%E5%AE%B9-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E3%80%81%E5%90%91%E6%B7%B7%E5%90%88%E6%A0%B7%E5%BC%8F%E4%B8%AD%E5%AF%BC%E5%85%A5%E5%86%85%E5%AE%B9" rel="nofollow">（4）、向混合样式中导入内容</a></p> 
<p id="8%E3%80%81%E5%87%BD%E6%95%B0%E6%8C%87%E4%BB%A4-toc" style="margin-left:40px;"><a href="#8%E3%80%81%E5%87%BD%E6%95%B0%E6%8C%87%E4%BB%A4" rel="nofollow">8、输出格式（了解）</a></p> 
<p id="%EF%BC%881%EF%BC%89%E3%80%81%3Anested-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E3%80%81%3Anested" rel="nofollow">（1）、:nested</a></p> 
<p id="%EF%BC%882%EF%BC%89%E3%80%81%3Aexpanded-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E3%80%81%3Aexpanded" rel="nofollow">（2）、:expanded</a></p> 
<p id="%EF%BC%883%EF%BC%89%E3%80%81%3Acompact-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E3%80%81%3Acompact" rel="nofollow">（3）、:compact</a></p> 
<p id="%EF%BC%884%EF%BC%89%E3%80%81%3Acompressed-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E3%80%81%3Acompressed" rel="nofollow">（4）、:compressed</a></p> 
<p id="9%E3%80%81%3Aexport%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89-toc" style="margin-left:40px;"><a href="#9%E3%80%81%3Aexport%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89" rel="nofollow">9、:export（了解）</a></p> 
<p id="t3-toc" style="margin-left:0px;"><a href="#t3" rel="nofollow">三、vue 中使用 Sass</a></p> 
<p id="1%E3%80%81%E5%BC%95%E5%85%A5%20sass-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E5%BC%95%E5%85%A5%20sass" rel="nofollow">1、引入 sass</a></p> 
<p id="%EF%BC%881%EF%BC%89%E3%80%81CDN%20%E5%BC%95%E5%85%A5%C2%A0sass-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E3%80%81CDN%20%E5%BC%95%E5%85%A5%C2%A0sass" rel="nofollow">（1）、CDN 引入 sass</a></p> 
<p id="%EF%BC%882%EF%BC%89%E3%80%81%E4%BB%A5%E6%8F%92%E4%BB%B6%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%BC%95%E5%85%A5%20sass-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E3%80%81%E4%BB%A5%E6%8F%92%E4%BB%B6%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%BC%95%E5%85%A5%20sass" rel="nofollow">（2）、以插件的形式引入 sass</a></p> 
<p id="%E5%9B%9B%E3%80%81%E8%A2%AB%E5%81%8F%E7%88%B1%E7%9A%84%20dart-sass-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E8%A2%AB%E5%81%8F%E7%88%B1%E7%9A%84%20dart-sass" rel="nofollow">四、被偏爱的 dart-sass</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<p>参考文档：<a href="https://www.sass.hk/docs/" rel="nofollow" title="Sass教程 Sass中文文档 | Sass中文网">Sass教程 Sass中文文档 | Sass中文网</a></p> 
<blockquote> 
 <p>Sass 官方目前主力推 dart-sass，最新的特性都会在这个上面先实现。<br><a class="link-info" href="https://github.com/sass/dart-sass" title="dart-sass GitHub 项目地址">dart-sass GitHub 项目地址</a><br><a class="link-info" href="https://www.sasscss.com/dart-sass" rel="nofollow" title="dart-sass 中文官方文档">dart-sass 中文官方文档</a></p> 
</blockquote> 
<p>Dart Sass 速度快、易于安装，并且 可以被编译成纯 JavaScript 代码，这使得它很容易集成到现代 web 的开发流程中。</p> 
<ul><li>node-sass 是用 node(调用 cpp 编写的 libsass)来编译 sass；</li><li>dart-sass 是用 Dart 虚拟机（VM）来编译 sass；</li><li>node-sass是自动编译实时的，dart-sass需要保存后才会生效</li></ul> 
<p>推荐 dart-sass 性能更好（也是 sass 官方使用的），而且 node-sass 因为国情问题经常装不上</p> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E4%BA%86%E8%A7%A3%20sass">一、了解 sass</h2> 
<p>Sass 是一款强化 CSS 的辅助工具。它在 CSS 语法的基础上增加了一些高级功能，这些拓展令 CSS 更加强大与优雅。</p> 
<h3 id="1%E3%80%81%E7%89%B9%E7%82%B9">1、特点</h3> 
<ul><li>完全兼容 CSS3。</li><li>在 CSS 基础上增加变量、嵌套、混合、导入等高级功能。</li><li>通过函数进行颜色值与属性值的运算。</li><li>提供控制指令等高级功能。</li><li>自定义输出格式。</li></ul> 
<h3 id="2%E3%80%81%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F">2、语法格式</h3> 
<p>Sass 有两种语法格式：SCSS 语法格式 和 Sass 语法格式。</p> 
<ul><li>SCSS 语法格式：完全兼容 CSS3，支持大多数 CSS hacks 写法，支持浏览器前缀写法，支持早期的 IE 滤镜写法，这种格式以 .scss 作为拓展名。</li><li>Sass 语法格式：支持“缩进”。使用 “缩进” 代替 “花括号”，用 “换行” 代替 “分号” 分隔属性。这种格式以 .sass 作为拓展名。</li></ul> 
<p>SCSS 语法格式，完全兼容 CSS3，同时加入 Sass 的特色功能。</p> 
<p><img alt="" height="128" src="https://images2.imgbox.com/18/4a/0KZwpn4S_o.png" width="227"></p> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81Sass%20%E7%9A%84%E8%AF%AD%E6%B3%95">二、Sass 的语法</h2> 
<h3 id="1%E3%80%81%E5%B5%8C%E5%A5%97">1、嵌套</h3> 
<h4 id="%EF%BC%881%EF%BC%89%E3%80%81%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%B5%8C%E5%A5%97%E5%AE%9E%E4%BE%8B">（1）、最简单的嵌套实例</h4> 
<p>Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器，例如：</p> 
<pre><code>#main p {
  color: #00ff00;
  width: 97%;

  .redbox {
    background-color: #ff0000;
    color: #000000;
  }
}</code></pre> 
<p>编译为</p> 
<pre><code>#main p {
  color: #00ff00;
  width: 97%; }
  #main p .redbox {
    background-color: #ff0000;
    color: #000000; }</code></pre> 
<h4 id="%EF%BC%882%EF%BC%89%E3%80%81%26%20%E7%AC%A6%E2%80%94%E2%80%94%E7%88%B6%E9%80%89%E6%8B%A9%E5%99%A8">（2）、父选择器——&amp; 符</h4> 
<p>在嵌套 CSS 规则时，有时也需要直接使用嵌套外层的父选择器，例如，当给某个元素设定 hover 样式时，或者当 body 元素有某个 classname 时，可以用 &amp; 代表嵌套规则外层的父选择器。</p> 
<pre><code>a {
  font-weight: bold;
  text-decoration: none;
  &amp;:hover { text-decoration: underline; }
  body.firefox &amp; { font-weight: normal; }
}</code></pre> 
<p>编译为</p> 
<pre><code>a {
  font-weight: bold;
  text-decoration: none; }
  a:hover {
    text-decoration: underline; }
  body.firefox a {
    font-weight: normal; }</code></pre> 
<p>编译后的 CSS 文件中 &amp; 将被替换成嵌套外层的父选择器，如果含有多层嵌套，最外层的父选择器会一层一层向下传递：</p> 
<pre><code>#main {
  color: black;
  a {
    font-weight: bold;
    &amp;:hover { color: red; }
  }
}</code></pre> 
<p>编译为</p> 
<pre><code>#main {
  color: black; }
  #main a {
    font-weight: bold; }
    #main a:hover {
      color: red; }</code></pre> 
<p>&amp; 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器，例如：</p> 
<pre><code>#main {
  color: black;
  &amp;-sidebar { border: 1px solid; }
}</code></pre> 
<p> 编译为</p> 
<pre><code>#main {
  color: black; }
  #main-sidebar {
    border: 1px solid; }</code></pre> 
<h4 id="%EF%BC%883%EF%BC%89%E3%80%81%E5%B1%9E%E6%80%A7%E5%B5%8C%E5%A5%97">（3）、属性嵌套</h4> 
<p>有些 CSS 属性遵循相同的命名空间 (namespace)，比如 font-family, font-size, font-weight 都以 font 作为属性的命名空间。为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中，例如：</p> 
<pre><code>.funky {
  font: {
    family: fantasy;
    size: 30em;
    weight: bold;
  }
}</code></pre> 
<p>编译为</p> 
<pre><code>.funky {
  font-family: fantasy;
  font-size: 30em;
  font-weight: bold; }</code></pre> 
<h4 id="%EF%BC%884%EF%BC%89%E3%80%81%E5%8D%A0%E4%BD%8D%E7%AC%A6%E9%80%89%E6%8B%A9%E5%99%A8%20%25foo">（4）、占位符选择器 %foo</h4> 
<p>Sass 额外提供了一种特殊类型的选择器：占位符选择器。与常用的 id 与 class 选择器写法相似，只是 # 或 . 替换成了 %。必须通过 @extend 指令调用，更多介绍请查阅 <a class="link-info" href="https://www.sass.hk/docs/#t7-3-6" rel="nofollow" title="@extend-Only Selectors">@extend-Only Selectors</a>。</p> 
<p>当占位符选择器单独使用时（未通过 @extend 调用），不会编译到 CSS 文件中。</p> 
<h3 id="2%E3%80%81%E6%B3%A8%E9%87%8A">2、注释</h3> 
<h4 id="%EF%BC%881%EF%BC%89%E3%80%81%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A%20%2F*%20*%2F%20%E4%B8%8E%20%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A%20%2F%2F">（1）、多行注释 /* */ 与 单行注释 //</h4> 
<p>Sass 支持标准的 CSS 多行注释 /* */，以及单行注释 //，前者会 被完整输出到编译后的 CSS 文件中，而后者则不会，例如：</p> 
<pre><code>/* Hello world */
body { color: black; }

// The world is bad
a { color: green; }</code></pre> 
<p>编译为：</p> 
<pre><code>/* Hello world */
body {
  color: black; }

a {
  color: green; }</code></pre> 
<h4 id="%EF%BC%882%EF%BC%89%E3%80%81!%20%E7%AC%A6%20%E2%80%94%E2%80%94%C2%A0%E5%8E%8B%E7%BC%A9%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F%E4%B8%8B%E4%BF%9D%E7%95%99%E7%9A%84%E6%B3%A8%E9%87%8A">（2）、! 符 —— 压缩输出模式下保留的注释</h4> 
<p>将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。</p> 
<h4 id="%EF%BC%883%EF%BC%89%E3%80%81%E6%B3%A8%E9%87%8A%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%8F%92%E5%80%BC%E8%AF%AD%E5%8F%A5%E8%BE%93%E5%87%BA%E5%8F%98%E9%87%8F%E5%80%BC">（3）、注释中使用插值语句输出变量值</h4> 
<p>插值语句 也可写进多行注释中输出变量值：</p> 
<pre><code>$version: "1.2.3";
/* This CSS is generated by My Snazzy Framework version #{$version}. */</code></pre> 
<p>编译为</p> 
<pre><code>/* This CSS is generated by My Snazzy Framework version 1.2.3. */</code></pre> 
<h3 id="3%E3%80%81SassScript%E2%80%94%E2%80%94%E5%8F%98%E9%87%8F%E3%80%81%E8%BF%90%E7%AE%97">3、SassScript——变量、运算</h3> 
<p>在命令行中输入 sass -i，然后输入想要测试的 SassScript 查看输出结果：</p> 
<pre><code>$ sass -i
&gt;&gt; "Hello, Sassy World!"
"Hello, Sassy World!"
&gt;&gt; 1px + 1px + 1px
3px
&gt;&gt; #777 + #777
#eeeeee
&gt;&gt; #777 + #888
white</code></pre> 
<h4 id="%EF%BC%881%EF%BC%89%E3%80%81%24%20%E7%AC%A6%20%E2%80%94%E2%80%94%20%E5%8F%98%E9%87%8F">（1）、$ 符 —— 变量</h4> 
<p>SassScript 最普遍的用法就是变量，变量以美元符号开头，赋值方法与 CSS 属性的写法一样：</p> 
<pre><code>$width: 5em;</code></pre> 
<p>直接使用即调用变量：</p> 
<pre><code>#main {
  width: $width;
}</code></pre> 
<p>变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 !global 声明：</p> 
<pre><code>#main {
  $width: 5em !global;
  width: $width;
}

#sidebar {
  width: $width;
}</code></pre> 
<p>编译为</p> 
<pre><code>#main {
  width: 5em;
}

#sidebar {
  width: 5em;
}</code></pre> 
<h4 id="%EF%BC%882%EF%BC%89%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">（2）、数据类型</h4> 
<p>SassScript 支持 6 种主要的数据类型：</p> 
<ul><li><strong>数值</strong>：1, 2, 13, 10px</li><li><strong>字符串</strong>：有引号字符串与无引号字符串，"foo", 'bar', baz</li><li><strong>颜色</strong>：blue, #04a3f9, rgba(255,0,0,0.5)</li><li><strong>布尔型</strong>：true, false</li><li><strong>空值</strong>：null</li><li><strong>数组</strong> (list)：用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif</li><li><strong>maps</strong>：相当于 JavaScript 的 object，(key1: value1, key2: value2)</li></ul> 
<h4 id="%EF%BC%883%EF%BC%89%E3%80%81%E8%BF%90%E7%AE%97">（3）、运算</h4> 
<p><strong>①、数字运算</strong></p> 
<p>SassScript 支持数字的加减乘除、取整等运算 (+, -, *, /, %)，如果必要会在不同单位间转换值。</p> 
<pre><code>p {
  width: 1in + 8pt;
}</code></pre> 
<p>编译为</p> 
<pre><code>p {
  width: 1.111in; }</code></pre> 
<p>关系运算 &lt;, &gt;, &lt;=, &gt;= 也可用于数字运算，相等运算 ==, != 可用于所有数据类型。</p> 
<p><strong>②、颜色值运算</strong></p> 
<p>颜色值的运算是分段计算进行的，也就是分别计算 “红、绿、蓝” 的值：</p> 
<pre><code>p {
  color: #010203 + #040506;
}</code></pre> 
<p>计算 01 + 04 = 05 02 + 05 = 07 03 + 06 = 09，然后编译为</p> 
<pre><code>p {
  color: #050709; }</code></pre> 
<p><strong>③、字符串运算</strong></p> 
<p>+ 可用于连接字符串。</p> 
<p><strong>④、布尔运算</strong></p> 
<p>SassScript 支持布尔型的 and or 以及 not 运算。</p> 
<h4 id="%EF%BC%884%EF%BC%89%E3%80%81%E5%9C%86%E6%8B%AC%E5%8F%B7">（4）、圆括号</h4> 
<p>圆括号可以用来影响运算的顺序：</p> 
<pre><code>p {
  width: 1em + (2em * 3);
}</code></pre> 
<p>编译为</p> 
<pre><code>p {
  width: 7em; }</code></pre> 
<h4 id="%EF%BC%885%EF%BC%89%E3%80%81%C2%A0%26%20%E5%9C%A8%20SassScript%20%E4%B8%AD">（5）、 &amp; 在 SassScript 中</h4> 
<p>就像在选择器中使用时一样，在 SassScript 中，&amp; 指的是当前的父选择器。这是一个逗号分隔的列表，由空格分隔的列表组成。例如：</p> 
<pre><code>.foo.bar .baz.bang, .bip.qux {
  $selector: &amp;;
}</code></pre> 
<p>$selector 的值现在是（（“.foo.bar”“.baz.bang”），“.bip.qux”）。这里引用复合选择器表示它们是字符串，但实际上它们是未加引号的。即使父选择器不包含逗号或空格，&amp; 也始终具有两个嵌套级别，因此可以一致访问。</p> 
<p>如果没有父选择器，&amp; 的值将为空。这意味着您可以在 mixin（下文会讲到）中使用它来检测父选择器是否存在：</p> 
<pre><code>@mixin does-parent-exist {
  @if &amp; {
    &amp;:hover {
      color: red;
    }
  } @else {
    a {
      color: green;
    }
  }
}</code></pre> 
<h4 id="%EF%BC%886%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%20!default">（6）、变量定义 !default</h4> 
<p>可以在变量的结尾添加 !default 给一个未通过 !default 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。</p> 
<pre><code>$content: "First content";
$content: "Second content?" !default;
$new_content: "First time reference" !default;

#main {
  content: $content;
  new-content: $new_content;
}</code></pre> 
<p>编译为</p> 
<pre><code>#main {
  content: "First content";
  new-content: "First time reference"; }</code></pre> 
<p>变量是 null 空值时将视为未被 !default 赋值。</p> 
<pre><code>$content: null;
$content: "Non-null content" !default;

#main {
  content: $content;
}</code></pre> 
<p>编译为</p> 
<pre><code>#main {
  content: "Non-null content"; }</code></pre> 
<h3 id="4%E3%80%81%E5%87%BD%E6%95%B0">4、函数</h3> 
<p>SassScript 定义了多种函数，有些甚至可以通过普通的 CSS 语句调用。</p> 
<p>通过 <a href="https://sass-lang.com/documentation/modules" rel="nofollow" title="Sass::Script::Functions">Sass::Script::Functions</a> 查看完整的 Sass 函数列表，参数名，以及如何自定义函数。 </p> 
<h4 id="%EF%BC%881%EF%BC%89%E3%80%81%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%C2%A0SassScript%20%E5%87%BD%E6%95%B0">（1）、最简单的 SassScript 函数</h4> 
<pre><code>p {
  color: hsl(0, 100%, 50%);
}</code></pre> 
<p>编译为</p> 
<pre><code>p {
  color: #ff0000; }</code></pre> 
<h4 id="%EF%BC%882%EF%BC%89%E3%80%81%E5%B8%A6%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F%E7%9A%84%C2%A0SassScript%20%E5%87%BD%E6%95%B0">（2）、带参数变量的 SassScript 函数</h4> 
<p>SassScript 函数也支持参数变量：</p> 
<pre><code>p {
  color: hsl($hue: 0, $saturation: 100%, $lightness: 50%);
}</code></pre> 
<h4 id="%EF%BC%883%EF%BC%89%E3%80%81%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%C2%A0%E6%8F%92%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F%C2%A0%23%7B%7D">（3）、函数中使用 插值表达式 #{}</h4> 
<p>通过 #{} 插值语句可以在选择器或属性名中使用变量：</p> 
<pre><code>$name: foo;
$attr: border;
p.#{$name} {
  #{$attr}-color: blue;
}</code></pre> 
<p>编译为</p> 
<pre><code>p.foo {
  border-color: blue; }</code></pre> 
<h4 id="%EF%BC%884%EF%BC%89%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%20Sass%20%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E6%8C%87%E4%BB%A4%20%40function">（4）、自定义 Sass 函数——函数指令 @function</h4> 
<p>Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用：</p> 
<pre><code>$grid-width: 40px;
$gutter-width: 10px;

@function grid-width($n) {
  @return $n * $grid-width + ($n - 1) * $gutter-width;
}

#sidebar { width: grid-width(5); }</code></pre> 
<p>编译为</p> 
<pre><code>#sidebar {
  width: 240px; }</code></pre> 
<p>与 mixin 相同，也可以传递若干个全局变量给函数作为参数。一个函数可以含有多条语句，需要调用 @return 输出结果。</p> 
<p>自定义的函数也可以使用关键词参数，上面的例子还可以这样写：</p> 
<pre><code>#sidebar { width: grid-width($n: 5); }</code></pre> 
<p>建议在自定义函数前添加前缀避免命名冲突，其他人阅读代码时也会知道这不是 Sass 或者 CSS 的自带功能。</p> 
<p>自定义函数与 mixin 相同，都支持 variable arguments。</p> 
<p>更多通过自定义 Sass 函数，请看 Ruby API 提供的 <a class="link-info" href="http://sass-lang.com/docs/yardoc/Sass/Script/Functions.html#adding_custom_functions" rel="nofollow" title="source documentation">source documentation</a>。</p> 
<h3 id="5%E3%80%81%40-Rules%20%E4%B8%8E%E6%8C%87%E4%BB%A4">5、@-Rules 与指令</h3> 
<p>Sass 支持所有的 CSS3 @-Rules，以及 Sass 特有的 “指令”（directives）。更多资料请查看 <a class="link-info" href="https://www.sass.hk/docs/#8" rel="nofollow" title="控制指令 (control directives)">控制指令 (control directives)</a>与 <a class="link-info" href="https://www.sass.hk/docs/#9" rel="nofollow" title="混合指令 (mixin directives)">混合指令 (mixin directives)</a>两个部分。</p> 
<h4 id="%EF%BC%881%EF%BC%89%E3%80%81%40import%20%E2%80%94%E2%80%94%20%E5%AF%BC%E5%85%A5%E6%96%87%E4%BB%B6">（1）、@import —— 导入文件</h4> 
<p>Sass 拓展了 @import 的功能，允许其导入 SCSS 或 Sass 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。</p> 
<p>通常，@import 寻找 Sass 文件并将其导入，但在以下情况下，@import 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。</p> 
<ul><li>文件拓展名是 .css；</li><li>文件名以 http:// 开头；</li><li>文件名是 url()；</li><li>@import 包含 media queries。</li></ul> 
<p>如果不在上述情况内，文件的拓展名是 .scss 或 .sass，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 .scss 或 .sass 的文件并将其导入。</p> 
<p>例如：</p> 
<pre><code>@import "foo.scss";
// 或
@import "foo";</code></pre> 
<p>Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：</p> 
<pre><code>@import "rounded-corners", "text-shadow";</code></pre> 
<p>导入文件也可以使用 #{ } 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 url() 导入方式： </p> 
<pre><code>$family: unquote("Droid+Sans");
@import url("http://fonts.googleapis.com/css?family=\#{$family}");</code></pre> 
<p>编译为</p> 
<pre><code>@import url("http://fonts.googleapis.com/css?family=Droid+Sans");</code></pre> 
<p><strong>①、分音（Partials）</strong></p> 
<p><strong>如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，但导入语句中却不需要添加下划线</strong>。</p> 
<p>例如，将文件命名为 _colors.scss，便不会编译 _colours.css 文件。</p> 
<pre><code>@import "colors";</code></pre> 
<p>上面的例子，导入的其实是 _colors.scss 文件。 </p> 
<p><strong>②、嵌套 @import</strong></p> 
<p>大多数情况下，一般在文件的最外层（不在嵌套规则内）使用 @import，其实，也可以将 @import 嵌套进 CSS 样式或者 @media 中，与平时的用法效果相同，只是这样导入的样式只能出现在嵌套的层中。</p> 
<p>假设 example.scss 文件包含以下样式：</p> 
<pre><code>.example {
  color: red;
}</code></pre> 
<p>然后导入到 #main 样式内</p> 
<pre><code>#main {
  @import "example";
}</code></pre> 
<p>将会被编译为</p> 
<pre><code>#main .example {
  color: red;
}</code></pre> 
<p>不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 @import。</p> 
<h4 id="%EF%BC%882%EF%BC%89%E3%80%81%40media%20%E2%80%94%E2%80%94%20%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2">（2）、@media —— 媒体查询</h4> 
<p>Sass 中 @media 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 @media 嵌套在 CSS 规则内，编译时，@media 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 @media 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。</p> 
<h4 id="%EF%BC%883%EF%BC%89%E3%80%81%40extend%20%E2%80%94%E2%80%94%20%E7%BB%A7%E6%89%BF%EF%BC%88%E9%9A%BE%E7%82%B9%EF%BC%89">（3）、@extend —— 继承（难点）</h4> 
<p>在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。通常会在 HTML 中给元素定义两个 class，一个通用样式，一个特殊样式。假设现在要设计一个普通错误样式与一个严重错误样式，一般会这样写：</p> 
<pre><code>&lt;div class="error seriousError"&gt;
  Oh no! You've been hacked!
&lt;/div&gt;</code></pre> 
<p>样式如下：</p> 
<pre><code>.error {
  border: 1px #f00;
  background-color: #fdd;
}
.seriousError {
  border-width: 3px;
}</code></pre> 
<p>麻烦的是，这样做必须时刻记住使用 .seriousError 时需要参考 .error 的样式，带来了很多不变：智能比如加重维护负担，导致 bug，或者给 HTML 添加无语意的样式。使用 @extend 可以避免上述情况，告诉 Sass 将一个选择器下的所有样式继承给另一个选择器。</p> 
<pre><code>.error {
  border: 1px #f00;
  background-color: #fdd;
}
.seriousError {
  @extend .error;
  border-width: 3px;
}</code></pre> 
<p>上面代码的意思是将 .error 下的所有样式继承给 .seriousError，border-width: 3px; 是单独给 .seriousError 设定特殊样式，这样，使用 .seriousError 的地方可以不再使用 .error。 </p> 
<p><strong>①、@extend 的工作原理</strong></p> 
<p>@extend 的作用是将重复使用的样式 (.error) 延伸 (extend) 给需要包含这个样式的特殊样式（.seriousError），刚刚的例子：</p> 
<pre><code>.error {
  border: 1px #f00;
  background-color: #fdd;
}
.error.intrusion {
  background-image: url("/image/hacked.png");
}
.seriousError {
  @extend .error;
  border-width: 3px;
}</code></pre> 
<p>编译为</p> 
<pre><code>.error, .seriousError {
  border: 1px #f00;
  background-color: #fdd; }

.error.intrusion, .seriousError.intrusion {
  background-image: url("/image/hacked.png"); }

.seriousError {
  border-width: 3px; }</code></pre> 
<p>当合并选择器时，@extend 会很聪明地避免无谓的重复，.seriousError.seriousError 将编译为 .seriousError，不能匹配任何元素的选择器（比如 #main#footer ）也会删除。</p> 
<p><strong>②、延伸复杂的选择器</strong></p> 
<p>Class 选择器并不是唯一可以被延伸 (extend) 的，Sass 允许延伸任何定义给单个元素的选择器，比如 .special.cool，a:hover 或者 a.user[href^="http://"] 等，例如：</p> 
<pre><code>.hoverlink {
  @extend a:hover;
}</code></pre> 
<p>同 class 元素一样，a:hover 的样式将继承给 .hoverlink。</p> 
<pre><code>.hoverlink {
  @extend a:hover;
}
a:hover {
  text-decoration: underline;
}</code></pre> 
<p>编译为</p> 
<pre><code>a:hover, .hoverlink {
  text-decoration: underline; }</code></pre> 
<p>与上面 .error.intrusion 的例子一样，所有 a:hover 的样式将继承给 .hoverlink，包括其他使用到 a:hover 的样式，例如：</p> 
<pre><code>.hoverlink {
  @extend a:hover;
}
.comment a.user:hover {
  font-weight: bold;
}</code></pre> 
<p>编译为</p> 
<pre><code>.comment a.user:hover, .comment .user.hoverlink {
  font-weight: bold; }</code></pre> 
<p><strong>③、多重延伸</strong></p> 
<p>同一个选择器可以延伸给多个选择器，它所包含的属性将继承给所有被延伸的选择器：</p> 
<pre><code>.error {
  border: 1px #f00;
  background-color: #fdd;
}
.attention {
  font-size: 3em;
  background-color: #ff0;
}
.seriousError {
  @extend .error;
  @extend .attention;
  border-width: 3px;
}</code></pre> 
<p>编译为</p> 
<pre><code>.error, .seriousError {
  border: 1px #f00;
  background-color: #fdd; }

.attention, .seriousError {
  font-size: 3em;
  background-color: #ff0; }

.seriousError {
  border-width: 3px; }</code></pre> 
<p>每个 .seriousError 将包含 .error 与 .attention 下的所有样式，这时，后定义的样式享有优先权：.seriousError 的背景颜色是 #ff0 而不是 #fdd，因为 .attention 在 .error 之后定义。</p> 
<p>多重延伸可以使用逗号分隔选择器名，比如 @extend .error, .attention; 与 @extend .error; @extend.attention 有相同的效果。</p> 
<p><strong>④、继续延伸</strong></p> 
<p>当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个，例如：</p> 
<pre><code>.error {
  border: 1px #f00;
  background-color: #fdd;
}
.seriousError {
  @extend .error;
  border-width: 3px;
}
.criticalError {
  @extend .seriousError;
  position: fixed;
  top: 10%;
  bottom: 10%;
  left: 10%;
  right: 10%;
}</code></pre> 
<p>现在，每个 .seriousError 选择器将包含 .error 的样式，而 .criticalError 不仅包含 .seriousError 的样式也会同时包含 .error 的所有样式，上面的代码编译为：</p> 
<pre><code>.error, .seriousError, .criticalError {
  border: 1px #f00;
  background-color: #fdd; }

.seriousError, .criticalError {
  border-width: 3px; }

.criticalError {
  position: fixed;
  top: 10%;
  bottom: 10%;
  left: 10%;
  right: 10%; }</code></pre> 
<p><strong>⑤、选择器列</strong></p> 
<p>暂时不可以将选择器列 (Selector Sequences)，比如 .foo .bar 或 .foo + .bar，延伸给其他元素，但是，却可以将其他元素延伸给选择器列：</p> 
<pre><code>#fake-links .link {
  @extend a;
}

a {
  color: blue;
  &amp;:hover {
    text-decoration: underline;
  }
}</code></pre> 
<p>编译为</p> 
<pre><code>a, #fake-links .link {
  color: blue; }
  a:hover, #fake-links .link:hover {
    text-decoration: underline; }</code></pre> 
<p>有时会遇到复杂的情况，比如选择器列中的某个元素需要延伸给另一个选择器列，这种情况下，两个选择器列需要合并，比如：</p> 
<pre><code>#admin .tabbar a {
  font-weight: bold;
}
#demo .overview .fakelink {
  @extend a;
}</code></pre> 
<p>技术上讲能够生成所有匹配条件的结果，但是这样生成的样式表太复杂了，上面这个简单的例子就可能有 10 种结果。所以，Sass 只会编译输出有用的选择器。</p> 
<p>当两个列 (sequence) 合并时，如果没有包含相同的选择器，将生成两个新选择器：第一列出现在第二列之前，或者第二列出现在第一列之前：</p> 
<pre><code>#admin .tabbar a {
  font-weight: bold;
}
#demo .overview .fakelink {
  @extend a;
}</code></pre> 
<p>编译为</p> 
<pre><code>#admin .tabbar a,
#admin .tabbar #demo .overview .fakelink,
#demo .overview #admin .tabbar .fakelink {
  font-weight: bold; }</code></pre> 
<p>如果两个列 (sequence) 包含了相同的选择器，相同部分将会合并在一起，其他部分交替输出。在下面的例子里，两个列都包含 #admin，输出结果中它们合并在了一起：</p> 
<pre><code>#admin .tabbar a {
  font-weight: bold;
}
#admin .overview .fakelink {
  @extend a;
}</code></pre> 
<p>编译为</p> 
<pre><code>#admin .tabbar a,
#admin .tabbar .overview .fakelink,
#admin .overview .tabbar .fakelink {
  font-weight: bold; }</code></pre> 
<p><strong>⑥、@extend-Only 选择器 </strong></p> 
<p>有时，需要定义一套样式并不是给某个元素用，而是只通过 @extend 指令使用，尤其是在制作 Sass 样式库的时候，希望 Sass 能够忽略用不到的样式。</p> 
<p>如果使用普通的 CSS 规则，最后会编译出很多用不到的样式，也容易与其他样式名冲突，所以，Sass 引入了“占位符选择器” (placeholder selectors)，看起来很像普通的 id 或 class 选择器，只是 # 或 . 被替换成了 %。可以像 class 或者 id 选择器那样使用，当它们单独使用时，不会被编译到 CSS 文件中。</p> 
<pre><code>// 此规则集不会单独呈现。
#context a%extreme {
  color: blue;
  font-weight: bold;
  font-size: 2em;
}</code></pre> 
<p>占位符选择器需要通过延伸指令使用，用法与 class 或者 id 选择器一样，被延伸后，占位符选择器本身不会被编译。</p> 
<pre><code>.notice {
  @extend %extreme;
}</code></pre> 
<p>编译为</p> 
<pre><code>#context a.notice {
  color: blue;
  font-weight: bold;
  font-size: 2em; }</code></pre> 
<p><strong>⑦、!optional 声明</strong></p> 
<p>如果 @extend 失败会收到错误提示，比如，这样写 a.important {@extend .notice}，当没有 .notice 选择器时，将会报错，只有 h1.notice 包含 .notice 时也会报错，因为 h1 与 a 冲突，会生成新的选择器。</p> 
<p>如果要求 @extend 不生成新选择器，可以通过 !optional 声明达到这个目的，例如：</p> 
<pre><code>a.important {
  @extend .notice !optional;
}</code></pre> 
<p><strong>⑧、在指令中延伸</strong> </p> 
<p>在指令中使用 @extend 时（比如在 @media 中）有一些限制：Sass 不可以将 @media 层外的 CSS 规则延伸给指令层内的 CSS，这样会生成大量的无用代码。也就是说，如果在 @media （或者其他 CSS 指令）中使用 @extend，必须延伸给相同指令层中的选择器。</p> 
<p>下面的例子是可行的：</p> 
<pre><code>@media print {
  .error {
    border: 1px #f00;
    background-color: #fdd;
  }
  .seriousError {
    @extend .error;
    border-width: 3px;
  }
}</code></pre> 
<p>但不可以这样：</p> 
<pre><code>.error {
  border: 1px #f00;
  background-color: #fdd;
}

@media print {
  .seriousError {
    // INVALID EXTEND: .error is used outside of the "@media print" directive
    @extend .error;
    border-width: 3px;
  }
}</code></pre> 
<p>希望有一天，浏览器可以原生支持 @extend 指令，这样就可以在任何指令中使用延伸功能，不再受限制了。</p> 
<h4 id="%EF%BC%884%EF%BC%89%E3%80%81%40at-root">（4）、@at-root</h4> 
<p>@at root指令使一个或多个规则在文档的根发出，而不是嵌套在其父选择器下。它可以与单个内联选择器一起使用：</p> 
<pre><code>.parent {
  ...
  @at-root .child { ... }
}</code></pre> 
<p>编译为</p> 
<pre><code>.parent { ... }
.child { ... }</code></pre> 
<p>也可以与包含多个选择器的块一起使用：</p> 
<pre><code>.parent {
  ...
  @at-root {
    .child1 { ... }
    .child2 { ... }
  }
  .step-child { ... }
}</code></pre> 
<p>编译为</p> 
<pre><code>.parent { ... }
.child1 { ... }
.child2 { ... }
.parent .step-child { ... }</code></pre> 
<h4 id="%EF%BC%885%EF%BC%89%E3%80%81%40debug">（5）、@debug（了解）</h4> 
<p>@debug指令将SassScript表达式的值打印到标准错误输出流。这对于调试Sass文件非常有用，因为Sass脚本非常复杂。例如：</p> 
<pre><code>@debug 10em + 12em;</code></pre> 
<p>编译为</p> 
<pre><code>Line 1 DEBUG: 22em</code></pre> 
<h4 id="%EF%BC%886%EF%BC%89%E3%80%81%40warn%C2%A0">（6）、@warn（了解）</h4> 
<p>@warn指令将SassScript表达式的值打印到标准错误输出流。它对于需要警告用户不推荐或从轻微的混合使用错误中恢复的库非常有用。@warn和@debug之间有两个主要区别：</p> 
<p>可以使用--quiet命令行选项或：quiet Sass选项关闭警告。</p> 
<p>样式表跟踪将与消息一起打印出来，以便被警告的用户可以看到其样式导致警告的位置。</p> 
<p>用法示例：</p> 
<pre><code>@mixin adjust-location($x, $y) {
  @if unitless($x) {
    @warn "Assuming #{$x} to be in pixels";
    $x: 1px * $x;
  }
  @if unitless($y) {
    @warn "Assuming #{$y} to be in pixels";
    $y: 1px * $y;
  }
  position: relative; left: $x; top: $y;
}</code></pre> 
<h4 id="%EF%BC%887%EF%BC%89%E3%80%81%40error%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">（7）、@error（了解）</h4> 
<p>@error指令将SassScript表达式的值作为致命错误抛出，包括一个漂亮的堆栈跟踪。它对于验证mixin和函数的参数很有用。例如：</p> 
<pre><code>@mixin adjust-location($x, $y) {
  @if unitless($x) {
    @error "$x may not be unitless, was #{$x}.";
  }
  @if unitless($y) {
    @error "$y may not be unitless, was #{$y}.";
  }
  position: relative; left: $x; top: $y;
}</code></pre> 
<p>目前无法捕获错误。</p> 
<h3 id="6%E3%80%81%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4">6、控制指令</h3> 
<p>SassScript 提供了一些基础的控制指令，比如在满足一定条件时引用样式，或者设定范围重复输出格式。控制指令是一种高级功能，日常编写过程中并不常用到，主要与混合指令 (mixin) 配合使用，尤其是用在 <a class="link-info" href="http://compass-style.org/" rel="nofollow" title="Compass">Compass</a> 等样式库中。</p> 
<h4 id="%EF%BC%881%EF%BC%89%E3%80%81if()">（1）、if()（了解）</h4> 
<p>内置的if（）函数允许您对条件进行分支，并只返回两种可能结果中的一种。它可以在任何脚本上下文中使用。if函数只计算与它将返回的参数相对应的参数，这允许您引用可能未定义的变量，或进行否则会导致错误的计算（例如，除以零）。</p> 
<h4 id="%EF%BC%882%EF%BC%89%E3%80%81%40if()">（2）、@if()</h4> 
<p>当 @if 的表达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码：</p> 
<pre><code>p {
  @if 1 + 1 == 2 { border: 1px solid; }
  @if 5 &lt; 3 { border: 2px dotted; }
  @if null  { border: 3px double; }
}</code></pre> 
<p>编译为</p> 
<pre><code>p {
  border: 1px solid; }</code></pre> 
<p>@if 声明后面可以跟多个 @else if 声明，或者一个 @else 声明。如果 @if 声明失败，Sass 将逐条执行 @else if 声明，如果全部失败，最后执行 @else 声明，例如：</p> 
<pre><code>$type: monster;
p {
  @if $type == ocean {
    color: blue;
  } @else if $type == matador {
    color: red;
  } @else if $type == monster {
    color: green;
  } @else {
    color: black;
  }
}</code></pre> 
<p>编译为</p> 
<pre><code>p {
  color: green; }</code></pre> 
<h4 id="%EF%BC%883%EF%BC%89%E3%80%81%40for">（3）、@for</h4> 
<p>@for 指令可以在限制的范围内重复输出格式，每次按要求（变量的值）对输出结果做出变动。这个指令包含两种格式：@for $var from &lt;start&gt; through &lt;end&gt;，或者 @for $var from &lt;start&gt; to &lt;end&gt;，区别在于 through 与 to 的含义：当使用 through 时，条件范围包含 &lt;start&gt; 与 &lt;end&gt; 的值，而使用 to 时条件范围只包含 &lt;start&gt; 的值不包含 &lt;end&gt; 的值。另外，$var 可以是任何变量，比如 $i；&lt;start&gt; 和 &lt;end&gt; 必须是整数值。</p> 
<pre><code>@for $i from 1 through 3 {
  .item-#{$i} { width: 2em * $i; }
}</code></pre> 
<p>编译为</p> 
<pre><code>.item-1 {
  width: 2em; }
.item-2 {
  width: 4em; }
.item-3 {
  width: 6em; }</code></pre> 
<h4 id="%EF%BC%884%EF%BC%89%E3%80%81%40each">（4）、@each</h4> 
<p>@each 指令的格式是 $var in &lt;list&gt;, $var 可以是任何变量名，比如 $length 或者 $name，而 &lt;list&gt; 是一连串的值，也就是值列表。</p> 
<p>@each 将变量 $var 作用于值列表中的每一个项目，然后输出结果，例如：</p> 
<pre><code>@each $animal in puma, sea-slug, egret, salamander {
  .#{$animal}-icon {
    background-image: url('/images/#{$animal}.png');
  }
}</code></pre> 
<p>编译为</p> 
<pre><code>.puma-icon {
  background-image: url('/images/puma.png'); }
.sea-slug-icon {
  background-image: url('/images/sea-slug.png'); }
.egret-icon {
  background-image: url('/images/egret.png'); }
.salamander-icon {
  background-image: url('/images/salamander.png'); }</code></pre> 
<p>多重分配——@each指令还可以使用多个变量，如@each$var1，$var2，…in。如果是列表列表，则子列表的每个元素都分配给相应的变量。例如： </p> 
<pre><code>@each $animal, $color, $cursor in (puma, black, default),
                                  (sea-slug, blue, pointer),
                                  (egret, white, move) {
  .#{$animal}-icon {
    background-image: url('/images/#{$animal}.png');
    border: 2px solid $color;
    cursor: $cursor;
  }
}</code></pre> 
<p>编译为</p> 
<pre><code>.puma-icon {
  background-image: url('/images/puma.png');
  border: 2px solid black;
  cursor: default; }
.sea-slug-icon {
  background-image: url('/images/sea-slug.png');
  border: 2px solid blue;
  cursor: pointer; }
.egret-icon {
  background-image: url('/images/egret.png');
  border: 2px solid white;
  cursor: move; }</code></pre> 
<p>由于映射被视为成对列表，因此多重赋值也适用于它们。例如：</p> 
<pre><code>@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) {
  #{$header} {
    font-size: $size;
  }
}</code></pre> 
<p> 编译为</p> 
<pre><code>h1 {
  font-size: 2em; }
h2 {
  font-size: 1.5em; }
h3 {
  font-size: 1.2em; }</code></pre> 
<h4 id="%EF%BC%885%EF%BC%89%E3%80%81%40while">（5）、@while</h4> 
<p>@while 指令重复输出格式直到表达式返回结果为 false。这样可以实现比 @for 更复杂的循环，只是很少会用到。例如：</p> 
<pre><code>$i: 6;
@while $i &gt; 0 {
  .item-#{$i} { width: 2em * $i; }
  $i: $i - 2;
}</code></pre> 
<p> 编译为</p> 
<pre><code>.item-6 {
  width: 12em; }

.item-4 {
  width: 8em; }

.item-2 {
  width: 4em; }</code></pre> 
<h3 id="7%E3%80%81%E6%B7%B7%E5%90%88%E6%8C%87%E4%BB%A4">7、混合指令</h3> 
<p>混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 .float-left。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。</p> 
<h4 id="%EF%BC%881%EF%BC%89%E3%80%81%E5%AE%9A%E4%B9%89%E6%B7%B7%E5%90%88%E6%8C%87%E4%BB%A4%20%40mixin">（1）、定义混合指令 @mixin</h4> 
<p>混合指令的用法是在 @mixin 后添加名称与样式，比如名为 large-text 的混合通过下面的代码定义：</p> 
<pre><code>@mixin large-text {
  font: {
    family: Arial;
    size: 20px;
    weight: bold;
  }
  color: #ff0000;
}</code></pre> 
<p>混合也需要包含选择器和属性，甚至可以用 &amp; 引用父选择器：</p> 
<pre><code>@mixin clearfix {
  display: inline-block;
  &amp;:after {
    content: ".";
    display: block;
    height: 0;
    clear: both;
    visibility: hidden;
  }
  * html &amp; { height: 1px }
}</code></pre> 
<h4 id="%C2%A0%EF%BC%882%EF%BC%89%E3%80%81%E5%BC%95%E7%94%A8%E6%B7%B7%E5%90%88%E6%A0%B7%E5%BC%8F%20%40include"> （2）、引用混合样式 @include</h4> 
<p>使用 @include 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）：</p> 
<pre><code>.page-title {
  @include large-text;
  padding: 4px;
  margin-top: 10px;
}</code></pre> 
<p>编译为</p> 
<pre><code>.page-title {
  font-family: Arial;
  font-size: 20px;
  font-weight: bold;
  color: #ff0000;
  padding: 4px;
  margin-top: 10px; }</code></pre> 
<p> 也可以在最外层引用混合样式，不会直接定义属性，也不可以使用父选择器。</p> 
<pre><code>@mixin silly-links {
  a {
    color: blue;
    background-color: red;
  }
}
@include silly-links;</code></pre> 
<p>编译为</p> 
<pre><code>a {
  color: blue;
  background-color: red; }</code></pre> 
<p>混合样式中也可以包含其他混合样式，比如：</p> 
<pre><code>@mixin compound {
  @include highlighted-background;
  @include header-text;
}
@mixin highlighted-background { background-color: #fc0; }
@mixin header-text { font-size: 20px; }</code></pre> 
<p>混合样式中应该只定义后代选择器，这样可以安全的导入到文件的任何位置。</p> 
<h4 id="%EF%BC%883%EF%BC%89%E3%80%81%E5%8F%82%E6%95%B0">（3）、参数</h4> 
<p>参数用于给混合指令中的样式设定变量，并且赋值使用。在定义混合指令的时候，按照变量的格式，通过逗号分隔，将参数写进圆括号里。引用指令时，按照参数的顺序，再将所赋的值对应写进括号：</p> 
<pre><code>@mixin sexy-border($color, $width) {
  border: {
    color: $color;
    width: $width;
    style: dashed;
  }
}
p { @include sexy-border(blue, 1in); }</code></pre> 
<p>编译为</p> 
<pre><code>p {
  border-color: blue;
  border-width: 1in;
  border-style: dashed; }</code></pre> 
<p>混合指令也可以使用给变量赋值的方法给参数设定默认值，然后，当这个指令被引用的时候，如果没有给参数赋值，则自动使用默认值：</p> 
<pre><code>@mixin sexy-border($color, $width: 1in) {
  border: {
    color: $color;
    width: $width;
    style: dashed;
  }
}
p { @include sexy-border(blue); }
h1 { @include sexy-border(blue, 2in); }</code></pre> 
<p> 编译为</p> 
<pre><code>p {
  border-color: blue;
  border-width: 1in;
  border-style: dashed; }

h1 {
  border-color: blue;
  border-width: 2in;
  border-style: dashed; }</code></pre> 
<p><strong>①、 关键词参数</strong></p> 
<p>混合指令也可以使用关键词参数，上面的例子也可以写成：</p> 
<pre><code>p { @include sexy-border($color: blue); }
h1 { @include sexy-border($color: blue, $width: 2in); }</code></pre> 
<p>虽然不够简明，但是阅读起来会更方便。关键词参数给函数提供了更灵活的接口，以及容易调用的参数。关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，另外，参数名被视为变量名，下划线、短横线可以互换使用。 </p> 
<p><strong>②、参数变量</strong></p> 
<p>有时，不能确定混合指令需要使用多少个参数，比如一个关于 box-shadow 的混合指令不能确定有多少个 'shadow' 会被用到。这时，可以使用参数变量 … 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理：</p> 
<pre><code>@mixin box-shadow($shadows...) {
  -moz-box-shadow: $shadows;
  -webkit-box-shadow: $shadows;
  box-shadow: $shadows;
}
.shadows {
  @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);
}</code></pre> 
<p>编译为</p> 
<pre><code>.shadowed {
  -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
  -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
  box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;
}</code></pre> 
<p>参数变量也可以用在引用混合指令的时候 (@include)，与平时用法一样，将一串值列表中的值逐条作为参数引用：</p> 
<pre><code>@mixin colors($text, $background, $border) {
  color: $text;
  background-color: $background;
  border-color: $border;
}
$values: #ff0000, #00ff00, #0000ff;
.primary {
  @include colors($values...);</code></pre> 
<p>编译为</p> 
<pre><code>.primary {
  color: #ff0000;
  background-color: #00ff00;
  border-color: #0000ff;
}</code></pre> 
<p>您可以使用变量参数包装mixin并添加其他样式，而无需更改mixin的参数签名。如果这样做，即使是关键字参数也会传递给包装的mixin。例如：</p> 
<pre><code>@mixin wrapped-stylish-mixin($args...) {
  font-weight: bold;
  @include stylish-mixin($args...);
}
.stylish {
  // The $width argument will get passed on to "stylish-mixin" as a keyword
  @include wrapped-stylish-mixin(#00ff00, $width: 100px);
}</code></pre> 
<p>上面注释内的意思是：$width 参数将会传递给 stylish-mixin 作为关键词。 </p> 
<h4 id="%EF%BC%884%EF%BC%89%E3%80%81%E5%90%91%E6%B7%B7%E5%90%88%E6%A0%B7%E5%BC%8F%E4%B8%AD%E5%AF%BC%E5%85%A5%E5%86%85%E5%AE%B9">（4）、向混合样式中导入内容</h4> 
<p>在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 @content 标志的地方：</p> 
<pre><code>@mixin apply-to-ie6-only {
  * html {
    @content;
  }
}
@include apply-to-ie6-only {
  #logo {
    background-image: url(/logo.gif);
  }
}</code></pre> 
<p>编译为</p> 
<pre><code>* html #logo {
  background-image: url(/logo.gif);
}</code></pre> 
<p>为便于书写，@mixin 可以用 = 表示，而 @include 可以用 + 表示，所以上面的例子可以写成：</p> 
<pre><code>=apply-to-ie6-only
  * html
    @content

+apply-to-ie6-only
  #logo
    background-image: url(/logo.gif)</code></pre> 
<p>注意： 当 @content 在指令中出现过多次或者出现在循环中时，额外的代码将被导入到每一个地方。 </p> 
<p>可变范围和内容块——传递给mixin的内容块在定义块的范围内进行求值，而不是在mixin范围内。这意味着不能在传递的样式块中使用mixin本地变量，变量将解析为全局值：</p> 
<pre><code>$color: white;
@mixin colors($color: blue) {
  background-color: $color;
  @content;
  border-color: $color;
}
.colors {
  @include colors { color: $color; }
}</code></pre> 
<p>编译为</p> 
<pre><code>.colors {
  background-color: blue;
  color: white;
  border-color: blue;
}</code></pre> 
<p>此外，这清楚地表明，在传递的块中使用的变量和混合与定义块的其他样式有关。例如：</p> 
<pre><code>#sidebar {
  $sidebar-width: 300px;
  width: $sidebar-width;
  @include smartphone {
    width: $sidebar-width / 3;
  }
}</code></pre> 
<h3 id="8%E3%80%81%E5%87%BD%E6%95%B0%E6%8C%87%E4%BB%A4">8、输出格式（了解）</h3> 
<p>Sass 提供了四种输出格式，可以通过 :style option 选项设定，或者在命令行中使用 --style 选项。</p> 
<ul><li>:nested</li><li>:expanded</li><li>:compact</li><li>:compressed</li></ul> 
<h4 id="%EF%BC%881%EF%BC%89%E3%80%81%3Anested">（1）、:nested</h4> 
<p>Nested （嵌套）样式是 Sass 默认的输出格式，能够清晰反映 CSS 与 HTML 的结构关系。选择器与属性等单独占用一行，缩进量与 Sass 文件中一致，每行的缩进量反映了其在嵌套规则内的层数。当阅读大型 CSS 文件时，这种样式可以很容易地分析文件的主要结构。</p> 
<pre><code>#main {
  color: #fff;
  background-color: #000; }
  #main p {
    width: 10em; }

.huge {
  font-size: 10em;
  font-weight: bold;
  text-decoration: underline; }</code></pre> 
<h4 id="%EF%BC%882%EF%BC%89%E3%80%81%3Aexpanded">（2）、:expanded</h4> 
<p>Expanded 输出更像是手写的样式，选择器、属性等各占用一行，属性根据选择器缩进，而选择器不做任何缩进。</p> 
<pre><code>#main {
  color: #fff;
  background-color: #000;
}
#main p {
  width: 10em;
}

.huge {
  font-size: 10em;
  font-weight: bold;
  text-decoration: underline;
}</code></pre> 
<h4 id="%EF%BC%883%EF%BC%89%E3%80%81%3Acompact">（3）、:compact</h4> 
<p>Compact 输出方式比起上面两种占用的空间更少，每条 CSS 规则只占一行，包含其下的所有属性。嵌套过的选择器在输出时没有空行，不嵌套的选择器会输出空白行作为分隔符。</p> 
<pre><code>#main { color: #fff; background-color: #000; }
#main p { width: 10em; }

.huge { font-size: 10em; font-weight: bold; text-decoration: underline; }</code></pre> 
<h4 id="%EF%BC%884%EF%BC%89%E3%80%81%3Acompressed">（4）、:compressed</h4> 
<p>Compressed 输出方式删除所有无意义的空格、空白行、以及注释，力求将文件体积压缩到最小，同时也会做出其他调整，比如会自动替换占用空间最小的颜色表达方式。</p> 
<pre><code>#main{color:#fff;background-color:#000}#main p{width:10em}.huge{font-size:10em;font-weight:bold;text-decoration:underline}</code></pre> 
<h3 id="9%E3%80%81%3Aexport%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89">9、:export（了解）</h3> 
<p>使用 :export 可以将 sass 里定义的变量抛给 js 使用。比如：</p> 
<pre><code>$color-primary: #3c8dbc;
$bg: #ffffff;

:export {
  colorPrimary: $color-primary;
  bgColor: $bg;
}</code></pre> 
<p>之后再你要导入的文件中引入这个文件：</p> 
<pre><code>import styles from '../assets/css/vars.scss'

export default {
    data () {
        return {
            bgColor: styles.bgColor
        }
    }
}</code></pre> 
<p>【拓展】<a class="link-info" href="http://www.manongjc.com/detail/27-krxrkbxocnqibrt.html" rel="nofollow" title="运用 CSS in JS 实现模块化">运用 CSS in JS 实现模块化</a></p> 
<p></p> 
<h2 id="t3">三、vue 中使用 Sass</h2> 
<h3 id="1%E3%80%81%E5%BC%95%E5%85%A5%20sass" style="background-color:transparent;">1、引入 sass</h3> 
<p>vue 中引入 Sass 的方式：</p> 
<ul><li>CDN 引入 sass。</li><li>以插件的形式引入 sass。</li></ul> 
<h4 id="%EF%BC%881%EF%BC%89%E3%80%81CDN%20%E5%BC%95%E5%85%A5%C2%A0sass">（1）、CDN 引入 sass</h4> 
<p><a href="https://www.bootcdn.cn/sass.js/" rel="nofollow" title="sass.js (v0.11.1) - Sass.js is a convenience API for the JavaScript libsass (compiled with Emscripten) | BootCDN - Bootstrap 中文网开源项目免费 CDN 加速服务">sass.js (v0.11.1) - Sass.js is a convenience API for the JavaScript libsass (compiled with Emscripten) | BootCDN - Bootstrap 中文网开源项目免费 CDN 加速服务</a></p> 
<h4 id="%EF%BC%882%EF%BC%89%E3%80%81%E4%BB%A5%E6%8F%92%E4%BB%B6%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%BC%95%E5%85%A5%20sass">（2）、<span style="color:#f33b45;">以插件的形式引入 sass</span></h4> 
<pre><code>npm install node-sass --save-dev 
npm install sass-loader --save-dev</code></pre> 
<p>在 vue3 中安装 sass 时直接安装就行：</p> 
<pre><code class="hljs">npm install -D sass</code></pre> 
<p> </p> 
<h2 id="%E5%9B%9B%E3%80%81%E8%A2%AB%E5%81%8F%E7%88%B1%E7%9A%84%20dart-sass">四、被偏爱的 dart-sass</h2> 
<blockquote> 
 <p>Sass 官方目前主力推 dart-sass，最新的特性都会在这个上面先实现。基于 libsass 的 node-sass 将被弃用。</p> 
 <p><br><a class="link-info" href="https://github.com/sass/dart-sass" title="dart-sass GitHub 项目地址">dart-sass GitHub 项目地址</a><br><a class="link-info" href="https://www.sasscss.com/dart-sass" rel="nofollow" title="dart-sass 中文官方文档">dart-sass 中文官方文档</a></p> 
</blockquote> 
<p>Dart Sass 速度快、易于安装，并且 可以被编译成纯 JavaScript 代码，这使得它很容易集成到现代 web 的开发流程中。</p> 
<p>dart-sass 与 node-sass 的对比：</p> 
<ul><li>node-sass 是用 node(调用 cpp 编写的 libsass)来编译 sass，dart-sass 是用 Dart 虚拟机（VM）来编译 sass。</li><li>node-sass是自动编译实时的，dart-sass需要保存后才会生效。</li><li>推荐 dart-sass 性能更好（也是 sass 官方使用的），而且 node-sass 因为国情问题经常装不上。</li></ul> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/65e559bd222218e0f478396cea66b321/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux笔记--VSCode利用交换机跳转服务器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fa8225af4a3b17ee149a33182e29e3a5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Pytorch中的contiguous问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>