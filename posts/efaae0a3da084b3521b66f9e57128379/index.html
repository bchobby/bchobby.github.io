<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Helm-chart学习-简单介绍与使用 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Helm-chart学习-简单介绍与使用" />
<meta property="og:description" content="目录
为什么需要Helm？直接kubectl有什么问题吗？
Helm介绍
Helm基本使用
Helm模板设置 流程控制
Chart模板：命名模板
写一个通用的Chart
使用Harbor作为Chart仓库
为什么需要Helm？直接kubectl有什么问题吗？ 常规K8s部署应用方式：将需要的资源编写YAML文件，然后apply -f进行部署，当然也有使用图形界面操作的，这里不做讨论。 例如部署一个常规web程序，一般我们需要部署deployment、service、ingress资源。 Deployment.yaml
apiVersion: apps/v1 kind: Deployment metadata: name: web namespace: default spec: replicas: 3 selector: matchLabels: app: web template: metadata: labels: app: web spec: containers: - name: web image: nginx:1.19 ports: - containerPort: 80 Service.yaml
apiVersion: v1 kind: Service metadata: labels: app: web name: web spec: ports: - port: 80 protocol: TCP targetPort: 8080 selector: app: web Ingress." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/efaae0a3da084b3521b66f9e57128379/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-11T01:29:01+08:00" />
<meta property="article:modified_time" content="2022-07-11T01:29:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Helm-chart学习-简单介绍与使用</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Helm%EF%BC%9F%E7%9B%B4%E6%8E%A5kubectl%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Helm%EF%BC%9F%E7%9B%B4%E6%8E%A5kubectl%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F" rel="nofollow">为什么需要Helm？直接kubectl有什么问题吗？</a></p> 
<p id="Helm%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#Helm%E4%BB%8B%E7%BB%8D" rel="nofollow">Helm介绍</a></p> 
<p id="Helm%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-toc" style="margin-left:80px;"><a href="#Helm%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" rel="nofollow">Helm基本使用</a></p> 
<p id="Helm%E6%A8%A1%E6%9D%BF%E8%AE%BE%E7%BD%AE%C2%A0-toc" style="margin-left:80px;"><a href="#Helm%E6%A8%A1%E6%9D%BF%E8%AE%BE%E7%BD%AE%C2%A0" rel="nofollow">Helm模板设置 </a></p> 
<p id="%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-toc" style="margin-left:80px;"><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6" rel="nofollow">流程控制</a></p> 
<p id="Chart%E6%A8%A1%E6%9D%BF%EF%BC%9A%E5%91%BD%E5%90%8D%E6%A8%A1%E6%9D%BF-toc" style="margin-left:80px;"><a href="#Chart%E6%A8%A1%E6%9D%BF%EF%BC%9A%E5%91%BD%E5%90%8D%E6%A8%A1%E6%9D%BF" rel="nofollow">Chart模板：命名模板</a></p> 
<p id="%C2%A0%E5%86%99%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84Chart-toc" style="margin-left:80px;"><a href="#%C2%A0%E5%86%99%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84Chart" rel="nofollow"> 写一个通用的Chart</a></p> 
<p id="%E4%BD%BF%E7%94%A8Harbor%E4%BD%9C%E4%B8%BAChart%E4%BB%93%E5%BA%93-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8Harbor%E4%BD%9C%E4%B8%BAChart%E4%BB%93%E5%BA%93" rel="nofollow">使用Harbor作为Chart仓库</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h4 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Helm%EF%BC%9F%E7%9B%B4%E6%8E%A5kubectl%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F"><span style="color:#2c3f51;"><strong>为什么需要Helm？</strong></span><span style="color:#2c3f51;"><strong>直接kubectl有什么问题吗？</strong></span></h4> 
<div> 
 <div> 
  <span style="color:#2c3f51;">    常规K8s部署应用方式：将需要的资源编写YAML文件，然后apply  -f进行部署，当然也有使用图形界面操作的，这里不做讨论。</span> 
 </div> 
 <div> 
  <span style="color:#2c3f51;">    例如部署一个常规web程序，一般我们需要部署<strong>deployment、service、ingress</strong>资源。</span> 
 </div> 
 <div> 
  <p><strong><span style="color:#1c7331;">Deployment.yaml</span></strong></p> 
  <pre><code class="language-bash">apiVersion: apps/v1
kind: Deployment
metadata:
  name: web
  namespace: default
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
      - name: web
        image: nginx:1.19
        ports:
        - containerPort: 80</code></pre> 
  <p><strong><span style="color:#1c7331;">Service.yaml</span></strong></p> 
  <pre><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  labels:
    app: web
  name: web
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 8080
  selector:
    app: web</code></pre> 
  <p><span style="color:#1c7331;"><strong>Ingress.yaml</strong></span></p> 
  <pre><code class="language-bash">apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: web
spec:
  rules:
  - host: web.linux.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: web
            port:
              number: 80</code></pre> 
  <div> 
   <span style="color:#2c3f51;">因为Kubernetes缺少对发布的应用版本管理和控制，使得部署的应用维护和更新等面临许多的问题： </span> 
  </div> 
  <div> 
   <span style="color:#2c3f51;">1.如何将这些服务作为一个整体管理？</span> 
  </div> 
  <div> 
   <span style="color:#2c3f51;">例如业务下线，去卸载的话得一个一个yaml文件执行delete，上线也得一个个去apply，虽然可以在目录里执行 kubectl apply -f . 来执行当前目录所有yaml文件，但是不能保证每次都会再同一个目录。</span> 
  </div> 
  <div> 
   <span style="color:#2c3f51;">2.这些资源文件如何高效复用？</span> 
  </div> 
  <div> 
   <span style="color:#2c3f51;">就像上面的yaml文件我部署了一个名称为web的deployment，下次我要部署一个web2，该怎么办，又得重新复制过来修改重新部署。</span> 
  </div> 
  <div> 
   <span style="color:#2c3f51;">3.而且k8s并不支持应用级别的版本管理。</span> 
  </div> 
  <div> 
   <span style="color:#2c3f51;">这个怎么理解呢，就是说k8s目前只支持deployment的回滚，像ingress，service这些资源并没有一个版本记录，不支持回滚。</span> 
  </div> 
  <div></div> 
  <div> 
   <strong>所以我们可以helm来解决这3个问题，当然它也不是万能的，不能完全替代kubectl。</strong> 
  </div> 
  <div> 
   <div></div> 
   <h4 id="Helm%E4%BB%8B%E7%BB%8D"><strong><span style="color:#2c3f51;">Helm介绍 </span></strong></h4> 
   <div> 
    <span style="color:#2c3f51;">Helm是一个Kubernetes的包管理工具，就像Linux下的包管理器，如yum/apt等，可以很方便的将之前 打包好的yaml文件部署到kubernetes上。 </span> 
   </div> 
   <div> 
    <span style="color:#2c3f51;">Helm有3个重要概念： </span> 
   </div> 
   <div> 
    <span style="color:#2c3f51;"><strong>helm：</strong></span> 
    <span style="color:#2c3f51;">一个命令行客户端工具，主要用于Kubernetes应用chart的创建、打包、发布和管理。 </span> 
   </div> 
   <div> 
    <span style="color:#2c3f51;"><strong>Chart：</strong></span> 
    <span style="color:#2c3f51;">应用描述，一系列用于描述 k8s 资源相关文件的集合。 </span> 
   </div> 
   <div> 
    <span style="color:#2c3f51;"><strong>Release：</strong></span> 
    <span style="color:#2c3f51;">基于Chart的部署实体，一个 chart 被 Helm 运行后将会生成对应的一个release；将在 </span> 
   </div> 
   <div> 
    <span style="color:#2c3f51;">k8s中创建出真实运行的资源对象。</span> 
   </div> 
   <div></div> 
   <div> 
    <span style="color:#2c3f51;">Helm目前有两个大版本：v2和v3，查资料时注意一下版本。</span> 
   </div> 
   <div> 
    <div> 
     <span style="color:#2c3f51;">2019年11月Helm团队发布v3版本，相比v2版本最大变化是将Tiller删除，并大部分代码重构。</span> 
    </div> 
    <div> 
     <span style="color:#2c3f51;">也就是说v3版本是直接</span> 
     <span style="color:#2c3f51;">会通过kubeconfig配置（</span> 
     <span style="color:#2c3f51;">$HOME/.kube/config）来连接Kubernetes。</span> 
    </div> 
    <div> 
     <span style="color:#2c3f51;">kubectl可以使用这个helm就能正常使用。</span> 
    </div> 
   </div> 
   <div> 
    <span style="color:#2c3f51;">Helm项目地址：</span> 
    <span style="color:#0563c1;">https://github.com/helm/helm </span> 
   </div> 
   <div> 
    <span style="color:#2c3f51;">下载Helm客户端： wget </span> 
    <span style="color:#0563c1;">https://get.helm.sh/helm-v3.9.0-linux-amd64.tar.gz </span> 
   </div> 
   <div> 
    <span style="color:#2c3f51;">tar zxvf helm-v3.9.0-linux-amd64.tar.gz  #解压</span> 
   </div> 
   <div> 
    <span style="color:#2c3f51;">mv linux-amd64/helm /usr/bin/                #将这个文件移动到系统的二进制目录下就能使用了。</span> 
   </div> 
   <div></div> 
   <div> 
    <table border="1" cellpadding="1" cellspacing="1" style="width:700px;"><caption>
       Helm常用命令，官网helm.sh 
     </caption><tbody><tr><td>completion</td><td>命令补全，source &lt;(helm completion bash)</td></tr><tr><td><strong>create</strong></td><td>创建一个chart并指定名字</td></tr><tr><td><strong>history</strong></td><td>获取release历史</td></tr><tr><td><strong>install</strong></td><td>安装一个chart</td></tr><tr><td><strong>list</strong></td><td>列出release</td></tr><tr><td> 
        <div> 
         <strong><span style="color:#2c3f51;">template</span></strong> 
        </div> </td><td> 
        <div> 
         <span style="color:#2c3f51;">本地呈现渲染模板</span> 
        </div> </td></tr><tr><td> 
        <div> 
         <strong><span style="color:#2c3f51;">uninstall</span></strong> 
        </div> </td><td> 
        <div> 
         <span style="color:#2c3f51;">卸载一个release</span> 
        </div> </td></tr><tr><td> 
        <div> 
         <strong><span style="color:#2c3f51;">rollback</span></strong> 
        </div> </td><td> 
        <div> 
         <span style="color:#2c3f51;">从之前版本回滚</span> 
        </div> </td></tr><tr><td> 
        <div> 
         <strong><span style="color:#2c3f51;">upgrade</span></strong> 
        </div> </td><td> 
        <div> 
         <span style="color:#2c3f51;">更新一个release</span> 
        </div> </td></tr><tr><td><strong>package</strong></td><td>将chart目录打包到chart存档文件中</td></tr><tr><td>pull</td><td>从远程仓库中下载chart并解压到本地 # helm pull stable/mysql --untar</td></tr><tr><td>repo</td><td>添加，列出，移除，更新和索引chart仓库。可用子命令：add、index、list、remove、update</td></tr><tr><td> 
        <div> 
         <span style="color:#2c3f51;">search</span> 
        </div> </td><td> 
        <div> 
         <span style="color:#2c3f51;">根据关键字搜索chart。可用子命令：hub、repo</span> 
        </div> </td></tr><tr><td> 
        <div> 
         <span style="color:#2c3f51;">show</span> 
        </div> </td><td> 
        <div> 
         <span style="color:#2c3f51;">查看chart详细信息。可用子命令：all、chart、readme、values</span> 
        </div> </td></tr><tr><td> 
        <div> 
         <span style="color:#2c3f51;">status</span> 
        </div> </td><td> 
        <div> 
         <span style="color:#2c3f51;">显示已命名版本的状态</span> 
        </div> </td></tr><tr><td> 
        <div> 
         <span style="color:#2c3f51;">version </span> 
        </div> </td><td> 
        <div> 
         <span style="color:#2c3f51;">查看helm客户端版本</span> 
        </div> </td></tr><tr><td>help</td><td>命令的帮助文档</td></tr><tr><td>dependency</td><td>管理chart依赖</td></tr><tr><td>get</td><td>下载一个release。可用子命令：all、hooks、manifest、notes、values</td></tr></tbody></table> 
    <p><strong>下面我们来直接使用它：</strong></p> 
    <p>使用helm前这里插个故障我之前遇到的，因为集群是二进制搭建的 k8s的config文件并不在~/.kube目录下，所以使用时报错：<br><img alt="" height="47" src="https://images2.imgbox.com/01/74/1XSBNKOQ_o.png" width="1200"></p> 
   </div> 
   <div>
     这里可以使用：helm --kubeconfig  /etc/kubernetes/config  ls 
    <br> 
    <img alt="" height="132" src="https://images2.imgbox.com/7f/7b/ZYV3TCgT_o.png" width="1003"> 
   </div> 
   <p></p> 
   <h4 id="Helm%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span style="color:#2c3f51;"><strong>Helm基本使用 </strong></span></h4> 
   <div> 
    <span style="color:#2c3f51;">helm create 创建Chart示例 </span> 
   </div> 
   <div> 
    <span style="color:#2c3f51;">helm install 部署 </span> 
   </div> 
   <div> 
    <span style="color:#2c3f51;">helm upgrade 更新 </span> 
   </div> 
   <div> 
    <span style="color:#2c3f51;">helm rollback 回滚 </span> 
   </div> 
   <div> 
    <span style="color:#2c3f51;">helm uninstall 卸载</span> 
   </div> 
   <div></div> 
   <div> 
    <div> 
     <span style="color:#2c3f51;"><strong>创建Chart示例 </strong></span> 
    </div> 
    <div> 
     <span style="color:#2c3f51;">创建chart： </span> 
    </div> 
    <div> 
     <span style="color:#2c3f51;"><strong>helm create mychart</strong> # 创建一个示例chart</span> 
    </div> 
    <div> 
     <img alt="" height="69" src="https://images2.imgbox.com/01/1b/JlUXLdBE_o.png" width="457"> 
    </div> 
    <p>charts：目录里存放这个chart依赖的所有子chart。  #这个我没有使用<br> Chart.yaml：用于描述这个 Chart的基本信息，包括名字、描述信息以及版本等。#只用于描述。<br> values.yaml ：用于存储 templates 目录中模板文件中用到变量的值。<br> templates： 目录里面存放所有yaml模板文件。</p> 
    <p><img alt="" height="87" src="https://images2.imgbox.com/c8/66/TFNdW5cS_o.png" width="1172"><br>     NOTES.txt ：用于介绍Chart帮助信息， helm install 部署后展示给用户。例如：如何使用这个        Chart、列出缺省的设置等。<br>     _helpers.tpl：放置模板的地方，可以在整个chart中重复使用。</p> 
    <p><strong><span style="color:#2c3f51;">helm install </span>web mychart #部署一个示例chart，示例这里是一个nginx。</strong></p> 
    <p><img alt="" height="313" src="https://images2.imgbox.com/75/0e/svKBWxUn_o.png" width="1200"></p> 
    <p><img alt="" height="445" src="https://images2.imgbox.com/8e/6c/ZkDi48Ln_o.png" width="1200"></p> 
    <p>这是一个官方的chart，演示示例。<br> 我这边不用它的示例，我们自己动手写一个chart。</p> 
    <pre><code class="language-bash">mkdir  test-chart

cd test-chart
 
touch values.yaml  #先创建后面添加变量

mkdir templates

cat &gt; Chart.yaml &lt;&lt;EOF #这里我只是删除了示例里的注释信息。
apiVersion: v2
appVersion: 1.16.0
description: A Helm chart for Kubernetes
name: test-chart
type: application
version: 0.1.0
EOF

cd templates
touch _helpers.tpl
touch NOTES.txt

#创建一个deployment
kubectl create deployment web --image=nginx --dry-run=client -o yaml &gt; deployment.yaml
#创建一个service用NodePort方式暴露方便测试，因为我是用的iptables转发没用使用ipvs模式，不能直接访问。
kubectl expose deployment web --port=80 --target-port=80 --type=NodePort --dry-run=client -o yaml &gt; service.yaml

echo hello! &gt; NOTES.txt</code></pre> 
    <p>#这就已经完成了一个基础的chart，部署之后可以查看版本。<br><strong>helm install web /root/test-chart/ -n test #指定在test名称空间部署</strong><br><img alt="" height="197" src="https://images2.imgbox.com/fc/2a/qqYG02e4_o.png" width="1031">helm ls -n test #查看chart列表</p> 
    <p>kubectl get pod,svc,ep -n test -o wide #查看资源部署情况<img alt="" height="801" src="https://images2.imgbox.com/45/e1/HUjsIVJo_o.png" width="1200"></p> 
    <p></p> 
    <p> <strong>#更新与回滚测试</strong></p> 
    <pre><code class="language-bash">sed -i "s/1.16.0/1.17.0/" /root/test-chart/Chart.yaml
helm upgrade web /root/test-chart/ -n test
sed -i "s/1.17.0/1.18.0/" /root/test-chart/Chart.yaml
helm upgrade web /root/test-chart/ -n test
#这里做2个版本升级用于测试回滚</code></pre> 
    <p><strong>helm history web -n test</strong></p> 
    <p><img alt="" height="402" src="https://images2.imgbox.com/db/9c/AukNcnJ4_o.png" width="1200"></p> 
    <p> <strong>helm rollback web 1 -n test#默认不指定版本是回滚到上一个版本，我这里指定了版本号“1”。</strong><img alt="" height="457" src="https://images2.imgbox.com/d2/e0/shKFqxT3_o.png" width="1200"></p> 
    <p> #到这里已经学会了helm的基本使用，但是这个不是我们使用helm的最终目的，helm的强大之处在于它的模板渲染功能，下面我们学习模板使用。</p> 
    <p><span style="color:#1c7331;">--------------------------------------------------------------------------------------------------------------------------------</span></p> 
    <h4 id="Helm%E6%A8%A1%E6%9D%BF%E8%AE%BE%E7%BD%AE%C2%A0">Helm模板设置 </h4> 
    <p>在做模板之前，我们要知道每个yaml文件的差异化信息，这里大致整理了一下以下几点：<br> 1.应用名称<br> 2.标签<br> 3.镜像和tag<br> 4.端口<br> 5.命名空间<br> 6.数据卷<br> 7.副本数量<br> 8.资源限制</p> 
    <div> 
     <span style="color:#2c3f51;">Helm有内置对象参数，下面是常用的：</span> 
    </div> 
    <div> 
     <table border="1" cellpadding="1" cellspacing="1" style="width:700px;"><tbody><tr><td> 
         <div> 
          <span style="color:#2c3f51;">内置 </span> 
         </div> </td><td><span style="color:#2c3f51;">作用</span></td></tr><tr><td> 
         <div> 
          <span style="color:#2c3f51;">Release.Name </span> 
         </div> </td><td> 
         <div> 
          <span style="color:#2c3f51;">release 名称</span> 
         </div> </td></tr><tr><td> 
         <div> 
          <span style="color:#2c3f51;">Release.Time </span> 
         </div> </td><td> 
         <div> 
          <span style="color:#2c3f51;">release 的时间</span> 
         </div> </td></tr><tr><td> 
         <div> 
          <span style="color:#2c3f51;">Release.Namespace </span> 
         </div> </td><td> 
         <div> 
          <span style="color:#2c3f51;">release 的命名空间</span> 
         </div> </td></tr><tr><td> 
         <div> 
          <span style="color:#2c3f51;">Release.Service </span> 
         </div> </td><td> 
         <div> 
          <span style="color:#2c3f51;">release 服务的名称</span> 
         </div> </td></tr><tr><td> 
         <div> 
          <span style="color:#2c3f51;">Release.Revision </span> 
         </div> </td><td> 
         <div> 
          <span style="color:#2c3f51;">release 的修订版本号，从1开始累加</span> 
         </div> </td></tr></tbody></table> 
     <p><strong>#helm 动态传参演示。</strong><br>  </p> 
     <pre><code class="language-bash">#/root/test-chart/values.yaml
#存储yaml文件渲染时的默认值，以后部署只修改这个文件的参数。
#参考刚刚我们使用helm create mychart 的目录里的values.yaml

#默认副本数
replicaCount: 1

#默认使用的镜像
image:
  repository: nginx
  tag: "latest"

---
#/root/test-chart/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: {<!-- -->{ .Release.Name }}
  name: {<!-- -->{ .Release.Name }}
spec:
  replicas: {<!-- -->{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: {<!-- -->{ .Release.Name }}
  strategy: {}
  template:
    metadata:
      labels:
        app: {<!-- -->{ .Release.Name }}
    spec:
      containers:
      - image: {<!-- -->{ .Values.image.repository }}:{<!-- -->{ .Values.image.tag }}
        name: nginx
        resources: {}

---
#/root/test-chart/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: {<!-- -->{ .Release.Name }}
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
  selector:
    app: {<!-- -->{ .Release.Name }}
  type: NodePort</code></pre> 
     <p><img alt="" height="229" src="https://images2.imgbox.com/ec/39/FdWj6EQR_o.png" width="973"></p> 
     <p><img alt="" height="349" src="https://images2.imgbox.com/77/2a/3R5S6JUF_o.png" width="1200"></p> 
     <p>#<strong>这里默认values文件里使用的nginx镜像，使用set命令将它更改成httpd。</strong></p> 
     <p><img alt="" height="698" src="https://images2.imgbox.com/89/05/Paq55bc5_o.png" width="1200"></p> 
     <p>如果执行helm upgrade web3 /root/test-chart/ --set image.tag=1.19 -n test<br> 我这里web3是一个httpd，在执行完指定版本更新后，是否会变更r<span style="color:#2c3f51;">elease的镜像</span>？<br><img alt="" height="249" src="https://images2.imgbox.com/e0/ec/AmC7nSuB_o.png" width="1080"></p> 
     <p><img alt="" height="271" src="https://images2.imgbox.com/71/f8/RYImXEuU_o.png" width="608"></p> 
     <p>做到这里时会发现，如果用命令行执行了set变更了values的值，我又没有写入到文件，我该怎么查询我做的更改？<br> 这里可以使用get命令获取：<br><strong>helm get values web3 -n test</strong><br><img alt="" height="131" src="https://images2.imgbox.com/44/47/zTLJWQKa_o.png" width="667"></p> 
     <p><strong>helm get manifest web3 -n test 则可以获取这个r<span style="color:#2c3f51;">elease</span>部署的所有yaml文件内容：</strong><br><img alt="" height="387" src="https://images2.imgbox.com/06/e2/Z71WBBU8_o.png" width="720"></p> 
     <p>然后会发现我获取的是我当前版本的yaml，那我需要获取的是某个部署失败或者部署错误的yaml文件来拍错，例如我之前部署的httpd版本yaml文件我该怎么查询？<br> 这里可以是用参数 --revesion ，通history查询到报错的版本，我这里是版本号1.<br> helm history -n test web3 #查询到版本号<br><img alt="" height="154" src="https://images2.imgbox.com/43/5a/tDRLzlnx_o.png" width="1200"></p> 
     <p>helm get manifest --revision=1 web3 -n test  #指定版本号查询<span style="color:#2c3f51;">release所渲染的yaml文件。</span></p> 
     <p> <img alt="" height="633" src="https://images2.imgbox.com/fc/af/UZinMG4c_o.png" width="721"></p> 
     <p> 我们会发现在使用set命令，只指定了values.yaml里的的tag参数时，默认也会读取image的信息，当我不想让它读取默认values.yaml里的其他参数时，我们也可以指定一个自定义需要变更的values文件来更新，<span style="color:#0d0016;">不要对原有values.yaml来操作</span>。</p> 
     <pre><code class="language-bash">cat &gt;/tmp/test.yaml &lt;&lt;EOF
image:
  repository: nginx
  tag: "1.20"
EOF

helm upgrade web3 /root/test-chart/ -f /tmp/test.yaml -n test</code></pre> 
     <p><img alt="" height="250" src="https://images2.imgbox.com/a8/ad/OU46sCeu_o.png" width="732"></p> 
     <table border="1" cellpadding="1" cellspacing="1" style="width:700px;"><caption>
        yaml文件与命令行set命令区别 
      </caption><tbody><tr><td>yaml</td><td>set</td></tr><tr><td>name: value</td><td>--set name=value</td></tr><tr><td> <p>a:b</p> <p>c:d</p> </td><td>--set a=b,c=d</td></tr><tr><td> <p>outer:</p> <p>  inner: value</p> </td><td>--set outer.inner=value</td></tr><tr><td> <p>name:</p> <p>  - a</p> <p>  - b</p> <p>  - c</p> </td><td>--set name={a,b,c}</td></tr><tr><td> <p>servers:</p> <p>  - port: 80</p> </td><td>--set servers[0].port=80</td></tr><tr><td> <p>servers:</p> <p>  - port: 80</p> <p>    host: example</p> </td><td>--set servers[0].port=80,servers[0].host=example</td></tr><tr><td>name: "value1,value2"</td><td>--set name=value1\,value2</td></tr><tr><td>nodeSelector:<br>   kubernetes.io/role: master</td><td>--set nodeSelector."kubernetes\.io/role"=master</td></tr></tbody></table> 
     <p><span style="color:#2c3f51;"><strong>Chart模板：调试</strong></span><br> 我们在创建完chart时往往不确定渲染出来的yaml是否是自己所需要的，这是可以使用调试命令查看所渲染的yaml文件。<br> helm template /root/test-chart/ #直接本地渲染，使用了Releaes.Name处使用占位符显示，因为我们没有提供release的名称。<br><img alt="" height="406" src="https://images2.imgbox.com/a5/83/mW3F4TXL_o.png" width="716"><br> helm install web4 /root/test-chart/ -n test --dry-run #使用--dry-run 则会直接完整显示release所渲染的结果。</p> 
     <p><img alt="" height="819" src="https://images2.imgbox.com/6f/7a/0nhUTtzX_o.png" width="949"><br><br>  </p> 
     <p><span style="color:#2c3f51;"><strong>Chart模板：函数与管道 </strong></span></p> 
     <div> 
      <span style="color:#2c3f51;">常用函数： </span> 
     </div> 
     <div> 
      <span style="color:#2c3f51;">quote：将值转换为字符串，即加双引号 </span> 
     </div> 
     <div> 
      <span style="color:#2c3f51;">default：设置默认值，如果获取的值为空则为默认值 </span> 
     </div> 
     <div> 
      <span style="color:#2c3f51;">indent和nindent：缩进字符串 </span> 
     </div> 
     <div> 
      <span style="color:#2c3f51;">toYaml：引用一块YAML内容 </span> 
      <br>   
     </div> 
     <div> 
      <div> 
       <span style="color:#2c3f51;"><strong>quote：</strong></span> 
       <span style="color:#2c3f51;">将值转换为字符串，即加双引号 </span> 
      </div> 
      <div> 
       <span style="color:#2c3f51;">示例：nodeSelector标签的值用了true正常使用会报错，这是因为它是一个布尔值，需要加引号才可以。</span> 
      </div> 
      <div> 
       <span style="color:#2c3f51;">在values.yaml增加：</span> 
       <br> 
       <img alt="" height="72" src="https://images2.imgbox.com/10/eb/ERUK0khJ_o.png" width="286"> 
      </div> 
      <div> 
       <span style="color:#2c3f51;">在deployment.yaml增加：</span> 
       <br> 
       <img alt="" height="206" src="https://images2.imgbox.com/a8/e6/u5guQynO_o.png" width="910"> 
       <br> 部署时会发现报错： 
       <br> 
       <img alt="" height="132" src="https://images2.imgbox.com/57/fa/YTmpLMr2_o.png" width="1200"> 
      </div> 
      <p> 在deployment.yaml增加函数<span style="color:#2c3f51;"><strong>quote </strong>解决</span><br><img alt="" height="193" src="https://images2.imgbox.com/4a/db/ukMZbSmN_o.png" width="939"></p> 
      <p><img alt="" height="263" src="https://images2.imgbox.com/18/f6/eblwEKQy_o.png" width="976"></p> 
      <div> 
       <span style="color:#2c3f51;"><strong>default：</strong></span> 
       <span style="color:#2c3f51;">设置默认值，如果获取的值为空则为默认值 </span> 
      </div> 
      <div> 
       <span style="color:#2c3f51;">示例：以防止忘记定义而导致模板文件缺少字段无法创建资源，这时可以为字段定义一个默认值。 </span> 
      </div> 
      <div></div> 
      <div> 
       <div> 
        <span style="color:#2c3f51;">image: "{<!-- -->{ .Values.image.repository }}:{<!-- -->{ .Values.image.tag | default .Chart.AppVersion }}</span> 
       </div> 
       <div> 
        <span style="color:#2c3f51;">这里为镜像标签设置了一个默认值，如果values.yaml里没有image.tag的值则读取Chart.yaml里AppVersion的值作为标签。</span> 
       </div> 
       <div> 
        <span style="color:#2c3f51;">#注释values的tag</span> 
       </div> 
       <div> 
        <img alt="" height="132" src="https://images2.imgbox.com/64/a9/uIWuyoIA_o.png" width="358"> 
        <img alt="" height="214" src="https://images2.imgbox.com/82/2a/TIJmAHlA_o.png" width="537"> 
       </div> 
       <div>
         添加默认标签值 
       </div> 
       <p><img alt="" height="184" src="https://images2.imgbox.com/70/85/bvaTkoMf_o.png" width="1200"> 渲染结果：<br><img alt="" height="533" src="https://images2.imgbox.com/e2/18/go59Jj6a_o.png" width="528"></p> 
       <p> <span style="color:#2c3f51;"><strong>indent和nindent：</strong></span><span style="color:#2c3f51;">都是缩进字符串，主要区别在于nindent会在缩进前多添加一个换行符。</span></p> 
       <div> 
        <span style="color:#2c3f51;">示例： </span> 
       </div> 
       <div> 
        <span style="color:#2c3f51;">apiVersion: apps/v1<br> kind: Deployment<br> metadata:<br>   labels:<br>     app: {<!-- -->{ .Release.Name |indent 6}}<br>     app: {<!-- -->{ .Release.Name |nindent 6}}</span> 
        <br> 
        <img alt="" height="225" src="https://images2.imgbox.com/69/d0/SBHsw3ZK_o.png" width="641"> 
        <span style="color:#2c3f51;"> </span> 
        <br> 所以常用的是nindent，因为indent直接按空格就能实现。 
        <br>   
       </div> 
       <div> 
        <div> 
         <span style="color:#2c3f51;"><strong>toYaml：</strong></span> 
         <span style="color:#2c3f51;">引用一块YAML内容 </span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">示例：在values.yaml里写结构化数据，引用内容块</span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">在values增加resources资源配额。</span> 
         <br> 
         <img alt="" height="513" src="https://images2.imgbox.com/91/56/F34GSNXO_o.png" width="834"> 
        </div> 
        <p></p> 
        <div>
          {<!-- -->{ toYaml .Values.resources | nindent 10 }} 
         <br> 
         <img alt="" height="175" src="https://images2.imgbox.com/8e/42/LeuNt8VX_o.png" width="1200"> 
         <br> 渲染结果： 
         <br> 
         <img alt="" height="402" src="https://images2.imgbox.com/9e/0e/R3c6oMVp_o.png" width="677"> 
        </div> 
        <p></p> 
        <div> 
         <span style="color:#2c3f51;"><strong>动态读取文件内容 </strong></span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">有时想从文件中导入内容，可通过.Files对象实现与toYaml类似。 </span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">示例：通过configmap存储redis的配置文件</span> 
        </div> 
        <div> 
         <pre><code class="language-bash">cat &gt; /root/test-chart/templates/configmap.yaml  &lt;&lt; EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: configmap-test
data:
  config.yaml: |
{<!-- -->{ .Files.Get "redis.properties" | indent 4 }} #引用chart根目录下的redis.properties文件内容
EOF

cat &gt; /root/test-chart/redis.properties &lt;&lt; EOF
redis.host=127.0.0.1
redis.port=6379
redis.passwd=123456
EOF

helm install web4  /root/test-chart/ -n test --dry-run #渲染测试</code></pre> 
         <span style="color:#2c3f51;">渲染结果：</span> 
         <br> 
         <img alt="" height="536" src="https://images2.imgbox.com/0a/7a/bYW9jy1m_o.png" width="1075"> 
        </div> 
        <p> <span style="color:#2c3f51;">Files.Glob方法返回所有匹配的文件路径列表，当多个文件时，可以更灵活提取某些文件。</span></p> 
        <pre><code class="language-bash">mkdir /root/test-chart/files
mv /root/test-chart/redis.properties  /root/test-chart/files
cat &gt;/root/test-chart/files/mysql.properties &lt;&lt; EOF
mysql.host=127.0.0.1
mysql.port=3306
EOF

cat &gt;/root/test-chart/templates/configmap &lt;&lt; EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: configmap-test
data:
  {<!-- -->{- $root := . }}          #设置作用域为chart根目录
  {<!-- -->{- range $path,$bytes := .Files.Glob "files/*.properties" }} #将文件名称赋值给path
  {<!-- -->{ base $path }}: |        #打印出文件名称
{<!-- -->{ $root.Files.Get $path |indent 4 }} #获取文件内容
  {<!-- -->{- end -}}                #循环结束符
EOF

helm install web4  /root/test-chart/ -n test --dry-run #渲染模板

#这个步骤我留了一个坑，做到这里就会发现^^</code></pre> 
        <p> 测试渲染结果：<br><img alt="" height="388" src="https://images2.imgbox.com/1c/61/WMtBfgSl_o.png" width="712"></p> 
        <h4 id="%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span style="color:#2c3f51;"><strong>流程控制 </strong></span></h4> 
        <div> 
         <span style="color:#2c3f51;">Helm模板语言提供以下流程控制语句： </span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">if/else：条件判断 </span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">range：循环 </span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">with：指定变量作用域</span> 
        </div> 
        <p> <span style="color:#2c3f51;"><strong>流程控制之if/else</strong></span><br><img alt="" height="522" src="https://images2.imgbox.com/ac/b3/ZAZjyubC_o.png" width="994"></p> 
        <div> 
         <span style="color:#2c3f51;">示例：部署一个应用，在没明确启用ingress时，默认情况下不启用</span> 
         <br> 在values增加： 
         <br> 
         <img alt="" height="54" src="https://images2.imgbox.com/a4/37/o5i58BMA_o.png" width="436"> 
        </div> 
        <p> 在templates目录下创建ingress.yaml，并在yaml文件增加if判断，为true时执行。<br><img alt="" height="557" src="https://images2.imgbox.com/61/86/0Whjau8e_o.png" width="644"></p> 
        <p> helm install web4  /root/test-chart/ -n test --dry-run --set ingress.enabled=true#默认不部署ingress，执行ingress.enabled=true则部署<img alt="" height="590" src="https://images2.imgbox.com/88/b5/AcAaHd11_o.png" width="1200"> <strong>如果值为以下几种情况则为false：</strong><br> 一个布尔类型 false<br> 一个数字 0<br> 一个空的字符串<br> 一个 nil（空或 null）<br> 一个空的集合（ map、 slice、 tuple、 dict、 array）<br><strong>条件表达式也支持操作符：</strong><br>  eq 等于<br>  ne 不等于<br>  lt 小于<br>  gt 大于<br>  and 逻辑与<br>  or 逻辑或</p> 
        <div> 
         <span style="color:#2c3f51;">示例：如果是一个空的集合则不启用资源配额 </span> 
         <br> values.yaml： 
         <br> 
         <img alt="" height="198" src="https://images2.imgbox.com/b2/94/JQC5swso_o.png" width="322"> 
        </div> 
        <div>
          deployment.yaml: 
         <br> 
         <img alt="" height="86" src="https://images2.imgbox.com/e3/41/EFfkCS9e_o.png" width="986"> 
        </div> 
        <p><img alt="" height="703" src="https://images2.imgbox.com/3e/c0/H6S8nahF_o.png" width="672"></p> 
        <p>#增加if判断后，渲染出来的模板有空行，增加减号删除空行。</p> 
        <p><img alt="" height="827" src="https://images2.imgbox.com/76/1c/VyUz30Xn_o.png" width="1200"></p> 
        <p><img alt="" height="98" src="https://images2.imgbox.com/db/fc/YGCtvmxt_o.png" width="1200"></p> 
        <p><img alt="" height="827" src="https://images2.imgbox.com/c9/b4/f5nbrmdM_o.png" width="1200"></p> 
        <p> <span style="color:#2c3f51;"><strong>流程控制之range</strong></span><br><img alt="" height="488" src="https://images2.imgbox.com/6b/37/Bw4bHc3t_o.png" width="1200"></p> 
        <p> range相当于shell的for循环。</p> 
        <div> 
         <span style="color:#2c3f51;">示例：遍历数据</span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">values.yaml:</span> 
         <br> 
         <img alt="" height="107" src="https://images2.imgbox.com/57/8b/dtNTNeky_o.png" width="164"> 
        </div> 
        <p>configmap.yaml:<br><img alt="" height="295" src="https://images2.imgbox.com/4a/1f/nCVzHvye_o.png" width="782"></p> 
        <div> 
         <span style="color:#2c3f51;">渲染结果</span> 
        </div> 
        <div> 
         <img alt="" height="255" src="https://images2.imgbox.com/f0/a8/F1AOjwCl_o.png" width="659"> 
        </div> 
        <p></p> 
        <p> <span style="color:#2c3f51;"><strong>流程控制之with</strong></span></p> 
        <div> 
         <span style="color:#2c3f51;"><strong>with：</strong></span> 
         <span style="color:#2c3f51;">指定变量作用域 </span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">语法： </span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">{<!-- -->{ with &lt;值&gt; }} </span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;"># 限制范围 </span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">{<!-- -->{ end }}</span> 
        </div> 
        <div></div> 
        <div> 
         <div> 
          <span style="color:#2c3f51;"><strong>with语句可以允许将当前范围 . 设置为特定的对象</strong></span> 
          <span style="color:#2c3f51;">，比如我们前面一直使用的 .Values.nodeSelecotr，我们可以使用 with来将 . 范围指向.Values.nodeSelecotr： </span> 
         </div> 
         <div>
           values.yaml 
          <br> 
          <img alt="" height="103" src="https://images2.imgbox.com/53/e9/H0rKxG9p_o.png" width="403"> 
         </div> 
         <p> deployment.yaml<br><img alt="" height="180" src="https://images2.imgbox.com/45/a2/uBN0iEW4_o.png" width="1069"></p> 
         <p>渲染结果： </p> 
        </div> 
       </div> 
       <p> <img alt="" height="388" src="https://images2.imgbox.com/38/29/Omwqh18O_o.png" width="520"></p> 
       <p> <span style="color:#2c3f51;"><strong>变量：</strong></span></p> 
       <div> 
        <span style="color:#2c3f51;">变量是实际应用中不多，但有时候结合with、range能更好处理数据。 </span> 
       </div> 
       <div> 
        <span style="color:#2c3f51;">示例：k8s变量是键值，可以range遍历生成</span> 
        <br>   
        <div> 
         <pre><code class="language-bash"># values.yaml
env:
  NAME: "wang"
  CLASS: "graduate"
#deployment.yaml
env:
        {<!-- -->{- range $k,$v := .Values.env }}
          - name: {<!-- -->{ $k }}
            value: {<!-- -->{ $v }}
        {<!-- -->{- end }} 
</code></pre> 
         <p>渲染结果:<br><img alt="" height="138" src="https://images2.imgbox.com/72/f2/ga6bQr7d_o.png" width="617"></p> 
         <p></p> 
        </div> 
        <h4 id="Chart%E6%A8%A1%E6%9D%BF%EF%BC%9A%E5%91%BD%E5%90%8D%E6%A8%A1%E6%9D%BF"><span style="color:#2c3f51;"><strong>Chart模板：命名模板 </strong></span></h4> 
        <div> 
         <span style="color:#2c3f51;"><strong>命名模板类似于开发语言中的函数，指一段可以直接被另一段程序或代码引用的程序或代码。 </strong></span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">在编写chart时，可以将一些重复使用的内容写在命名模板文件中供公共使用，这样可减少重 复编写程序段和简化代码结构。 </span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">命名模块使用define定义，template（不支持管道）或include引入，在templates目录中默 认下划线开头的文件为公共模板（helpers.tpl）。</span> 
        </div> 
       </div> 
       <p></p> 
       <pre><code class="language-bash"># cat templates/_helpers.tpl
{<!-- -->{- define "fullname" -}}
{<!-- -->{- .Chart.Name -}}-{<!-- -->{ .Release.Name }}
{<!-- -->{- end -}}

# cat templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: {<!-- -->{ .Release.Name |indent 6}}
    app: {<!-- -->{ .Release.Name |nindent 6}}
  name: {<!-- -->{ include "fullname" . }}</code></pre> 
       <p>渲染结果： </p> 
       <p> <img alt="" height="233" src="https://images2.imgbox.com/85/42/o91dTOzC_o.png" width="713"></p> 
       <h4 id="%C2%A0%E5%86%99%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84Chart"> <span style="color:#2c3f51;"><strong>写一个通用的Chart </strong></span></h4> 
       <div> 
        <div> 
         <span style="color:#2c3f51;">编写流程： </span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">1. 先创建模板示例 helm create demo </span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">2. 修改Chart.yaml，Values.yaml，参考示例预留变动的字段值 </span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">3. 在templates目录下准备部署应用所需的yaml文件，并添加指令引用 Values.yaml字段 </span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">4. 将重复使用的内容作为命名模板 </span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">5. 使用Chart结合参数部署多个同类服务</span> 
        </div> 
        <div></div> 
       </div> 
       <div> 
        <pre><code class="language-bash">[root@k8s-master ~]# mkdir example-chart/templates -p 
[root@k8s-master ~]# cp mychart/Chart.yaml example-chart/
[root@k8s-master ~]# touch example-chart/values.yaml
[root@k8s-master ~]# touch example-chart/templates/{_helpers.tpl,NOTES.txt}

#Chart.yaml 删除空行与注释文件就保留以下信息，修改name字段为自己的chart名字----------
[root@k8s-master ~]# cat example-chart/Chart.yaml 
apiVersion: v2
name: example-chart
description: A Helm chart for Kubernetes
type: application
version: 0.1.0
appVersion: "1.16.0"


#为chart设置所有yaml都通用的模板资源-------------------------------
root@k8s-master templates]# cat _helpers.tpl 
{<!-- -->{/*
注释模板
*/}}

{<!-- -->{/*
这个chart资源的名字
*/}}

{<!-- -->{- define "fullname" -}}
{<!-- -->{ .Chart.Name }}-{<!-- -->{.Release.Name }}
{<!-- -->{- end -}}

{<!-- -->{/*
标签
*/}}
{<!-- -->{- define "labels" -}}
chart_name: {<!-- -->{ .Chart.Name }}
instance_name: {<!-- -->{ .Release.Name }}
{<!-- -->{- end -}}

#为values设置常用参数------------------------------------
[root@k8s-master templates]# cat ../values.yaml 
#副本数
replicaCount: 1

#镜像选择
image:
  repository: nginx
  tag: "latest"

#资源配额
resources:
  limits:
    cpu: 200m
    memory: 256Mi
  requests:
    cpu: 100m
    memory: 128Mi

#configmap开关，默认关闭
configmap:
  enabled: false

#ingress开关，默认关闭
ingress:
  enabled: false
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    kubernetes.io/ingress.class: nginx
  host: www.checkqq.com
  path: /
#service端口模式
service:
  port: 80
  targetport: 80
  type: ClusterIP

#环境变量
env:
  NAME: "wang"
  CLASS: "graduate"

#存活检查
livenessProbe:
  httpGet:
    path: /
    port: 80

#就绪检查
readinessProbe:
  httpGet:
    path: /
    port: 80

#为configmap设置配置文件-----------------------------------
[root@k8s-master templates]# cat ../files/redis.properties  ../files/mysql.properties 
redis.host=127.0.0.1
redis.port=6379
----------------------------------分割线，前面为redis，后面为mysql
redis.passwd=123456
mysql.host=127.0.0.1
mysql.port=3306

#configmap.yaml 最终模板------------------------------------
[root@k8s-master templates]# cat configmap.yaml 
apiVersion: v1
kind: ConfigMap
metadata:
  name: {<!-- -->{ include "fullname" . }}
data:
  {<!-- -->{- $root := . }}          #设置作用域为chart根目录
  {<!-- -->{- range $path,$bytes := .Files.Glob "files/*.properties" }} #将文件名称赋值给path
  {<!-- -->{ base $path }}: |        #打印出文件名称
{<!-- -->{ $root.Files.Get $path |indent 4 }} #获取文件内容
  {<!-- -->{- end -}}  

#deployment.yaml  最终模板------------------------------------
#[root@k8s-master templates]# cat deployment.yaml 
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {<!-- -->{ include "fullname" . }}
spec:
  replicas: {<!-- -->{ .Values.replicaCount }}
  selector:
    matchLabels:
      {<!-- -->{- include "labels" . | nindent 6 }}
  strategy: {}
  template:
    metadata:
      labels:
        {<!-- -->{- include "labels" . | nindent 8 }}
    spec:
      containers:
      - image: {<!-- -->{ .Values.image.repository }}:{<!-- -->{ .Values.image.tag }}
        name: web
        resources: {<!-- -->{ toYaml .Values.resources | nindent 10 }}
        env:
        {<!-- -->{- range $k,$v := .Values.env }}
          - name: {<!-- -->{ $k }}
            value: {<!-- -->{ $v }}
        {<!-- -->{- end }}
        {<!-- -->{- if .Values.livenessProbe }}
        livenessProbe: {<!-- -->{ toYaml .Values.livenessProbe | nindent 10 }}
        {<!-- -->{- end }}
        {<!-- -->{- if .Values.readinessProbe }}
        readinessProbe: {<!-- -->{ toYaml .Values.readinessProbe | nindent 10 }}
        {<!-- -->{- end }}


#service.yaml  最终模板------------------------------------
[root@k8s-master templates]# cat service.yaml 
apiVersion: v1
kind: Service
metadata:
  name: {<!-- -->{ include "fullname" . }} 
spec:
  ports:
  - port: {<!-- -->{ .Values.service.port }}
    protocol: TCP
    targetPort: {<!-- -->{ .Values.service.targetport }}
  selector:
    {<!-- -->{- include "labels" . | nindent 4}}
  type: {<!-- -->{ .Values.service.type }}

#ingress.yaml  最终模板------------------------------------
[root@k8s-master templates]# cat ingress.yaml 
{<!-- -->{ if .Values.ingress.enabled }}  #如果ingress值为真启用ingress
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: {<!-- -->{ include "fullname" . }}
  annotations: 
  {<!-- -->{- toYaml .Values.ingress.annotations | nindent 4 }}
spec:
  rules:
  - host: {<!-- -->{ .Values.ingress.host }}
    http:
      paths:
      - path: {<!-- -->{ .Values.ingress.path }}
        pathType: Prefix
        backend:
          service:
            name: {<!-- -->{ include "fullname" . }}
            port:
              number: {<!-- -->{ .Values.service.port }}
{<!-- -->{- end }}

#####最后的最后为我们的chart写入使用说明########
echo "这家伙很懒，什么也没写" &gt; NOTES.txt</code></pre> 
        <p>到这里，我们的chart已经书写完毕，接下来是平常该怎么使用的说明。</p> 
        <pre><code class="language-bash">#对我们的chart进行打包
[root@k8s-master ~]# helm package example-chart/
Successfully packaged chart and saved it to: /root/example-chart-0.1.0.tgz
[root@k8s-master ~]# ls
anaconda-ks.cfg  example-chart                   ingress-controller-1.1.yaml  nfs-external-provisioner      test-chart
calico.yaml      example-chart-0.1.0.tgz         linux-amd64                  nfs-external-provisioner.zip
deployment.yaml  helm-v3.6.0-linux-amd64.tar.gz  mychart                      service.yaml


也就是这个example-chart-0.1.0.tgz，后续使用是直接用这个chart包

例如：[root@k8s-master templates]# helm install web /root/example-chart-0.1.0.tgz --dry-run  -n test --dry-run --set ingress.enabled=true  --set configmap.enabled=true --set replicaCount=3 --set image.tag=1.19 --set livenessProbe=false --set readinessProbe=false

#--set ingress.enabled=true      values默认不启用部署ingress 
#--set configmap.enabled=true    values默认不启用部署configmap
#--set replicaCount=3            设置pod的副本数为3
#--set image.tag=1.19            设置镜像版本标签为1.19
#--set livenessProbe=false       不启用存活检查
#--set readinessProbe=false      不启用就绪检查</code></pre> 
        <h4 id="%E4%BD%BF%E7%94%A8Harbor%E4%BD%9C%E4%B8%BAChart%E4%BB%93%E5%BA%93"><span style="color:#2c3f51;"><strong>使用Harbor作为Chart仓库 </strong></span></h4> 
        <div> 
         <span style="color:#2c3f51;">Harbor是一个主流的镜像仓库系统，在 v1.6 版本以后的 harbor 中新增加了 helm charts 的管理功能，可以存储Chart文件。 </span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">使用步骤： </span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;"><strong>1、启用Harbor的Chart仓库服务 </strong></span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;"># ./install.sh --with-chartmuseum </span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">启用后，默认创建的项目就带有helm charts功能了。 </span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;"><strong>2、安装push插件 </strong></span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">helm plugin install https://github.com/chartmuseum/helm-push #自动安装</span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;">如果安装失败可以手动安装：</span> 
         <pre><code class="language-bash">mkdir -p  /root/.local/share/helm/plugins/helm-push
cd /root/.local/share/helm/plugins/helm-push
tar zxvf helm-push_0.9.0_linux_amd64.tar.gz</code></pre> 
        </div> 
        <div> 
         <span style="color:#2c3f51;"><strong>3、添加repo </strong></span> 
         <pre><code class="language-bash">[root@k8s-master ~]# helm repo add --username admin --password Harbor12345 myrepo http://192.168.31.90/chartrepo/library
"myrepo" has been added to your repositories
[root@k8s-master helm-push]# helm repo list
NAME   	URL                                   
myrepo 	http://192.168.31.90/chartrepo/library
[root@k8s-master ~]# helm repo list
NAME  	URL                                   
myrepo	http://192.168.31.90/chartrepo/library

[root@k8s-master ~]# helm repo update
</code></pre> 
         <span style="color:#2c3f51;"> </span> 
        </div> 
        <div> 
         <span style="color:#2c3f51;"><strong>4、推送 </strong></span> 
        </div> 
        <div> 
         <pre><code class="language-bash">[root@k8s-master ~]# helm push example-chart-0.1.0.tgz --username=admin --password=Harbor12345 http://192.168.31.90/chartrepo/library
Pushing example-chart-0.1.0.tgz to http://192.168.31.90/chartrepo/library...
Done.</code></pre> 
         <img alt="" height="435" src="https://images2.imgbox.com/34/2f/7rKCuY15_o.png" width="1200"> 
        </div> 
        <p></p> 
        <div> 
         <span style="color:#2c3f51;"><strong>5、部署 </strong></span> 
        </div> 
       </div> 
      </div> 
      <pre><code class="language-bash">[root@k8s-master ~]# helm install web2  --version 0.1.0 myrepo/example-chart  --set image.repository=nginx --set ingress.enabled=true   -n test 
NAME: web2
LAST DEPLOYED: Mon Jul 11 01:08:15 2022
NAMESPACE: test
STATUS: deployed
REVISION: 1
TEST SUITE: None
NOTES:
这家伙很懒，什么也没写
</code></pre> 
      <p><img alt="" height="529" src="https://images2.imgbox.com/39/ed/xbKxsUae_o.png" width="1200"></p> 
      <pre><code class="language-bash">[root@k8s-master ~]# kubectl get pod,svc,ep -o wide -n test
NAME                                      READY   STATUS    RESTARTS   AGE   IP             NODE        NOMINATED NODE   READINESS GATES
pod/example-chart-web-f7bc75db4-572hn     1/1     Running   0          11m   10.244.36.78   k8s-node1   &lt;none&gt;           &lt;none&gt;
pod/example-chart-web2-7455c75b88-754xn   1/1     Running   0          38s   10.244.36.79   k8s-node1   &lt;none&gt;           &lt;none&gt;

NAME                         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE   SELECTOR
service/example-chart-web    ClusterIP   10.102.212.0    &lt;none&gt;        80/TCP    11m   chart_name=example-chart,instance_name=web
service/example-chart-web2   ClusterIP   10.102.255.92   &lt;none&gt;        80/TCP    38s   chart_name=example-chart,instance_name=web2

NAME                           ENDPOINTS         AGE
endpoints/example-chart-web    10.244.36.78:80   11m
endpoints/example-chart-web2   10.244.36.79:80   38s
[root@k8s-master ~]# 
</code></pre> 
      <p> 这里我遇到个故障顺便记录下。</p> 
      <pre><code class="language-bash">Error: Internal error occurred: failed calling webhook"validate.nginx.ingress.kubernetes.io": Post "https://ingress-nginx-controller-admission.ingress-nginx.svc:443/networking/v1/ingresses?timeout=10s": dial tcp 10.108.0.150:443: i/o timeout

#部署ingress报错删除ValidatingWebhookConfiguration。

kubectl delete -A ValidatingWebhookConfiguration ingress-nginx-admission</code></pre> 
      <p> 最后通过部署的ingress测试刚刚部署的chart，域名+ingress的端口</p> 
      <p><img alt="" height="497" src="https://images2.imgbox.com/8a/7a/zbS5tQNk_o.png" width="1200"></p> 
      <p> </p> 
     </div> 
     <p></p> 
     <p></p> 
     <p></p> 
     <p></p> 
     <p></p> 
     <p></p> 
     <p></p> 
     <p></p> 
     <p></p> 
     <p></p> 
    </div> 
    <p></p> 
    <p></p> 
   </div> 
   <p></p> 
   <p></p> 
  </div> 
 </div> 
</div>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8d7c2c376d14b14101fc3d78918b1467/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">leetcode295 一道题认识大顶堆和小顶堆</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e244e8b374e40797e044fa067468fea5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VS中使用类图查看和编辑项目中的类结构</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>