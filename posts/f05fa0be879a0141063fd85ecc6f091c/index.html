<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java8 Stream 流的创建、筛选、映射、排序、归约、分组、聚合、提取与组合、收集、接合、foreach遍历 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java8 Stream 流的创建、筛选、映射、排序、归约、分组、聚合、提取与组合、收集、接合、foreach遍历" />
<meta property="og:description" content="目录
一 了解Stream
1 Stream概述
那么什么是Stream？
Stream可以由数组或集合创建
Stream有几个特性：
Stream流的起始操作
2 Stream的创建----Stream可以通过集合数组创建。
3、通过 java.util.Collection.stream() 方法 用map集合 ,间接创建生成流
stream和parallelStream的简单区分：
4、使用java.util.Arrays.stream(T[] array)方法 用数组 创建流
3 Stream的使用
类声明
类方法 注意： 这些方法是从 java.lang.Object 类继承来的。
Optional 实例
输出结果：
案例使用的员工类
3.1 遍历/匹配（foreach/find/match）
foreach()是终止操作，只能执行一次，之后再执行此操作，会报IllegalStateException异常
案例--- forEach() / findFirst() / findAny() / findFirst.get() / findAny.get() / anyMatch(）
二 Stream流常见的中间操作
3.2 筛选（filter）--进行筛选提取，不对元素进行修改附加操作
案例一：filter的常规中间操作
案例二：筛选出Integer集合中大于7的元素，并打印出来
案例三： 筛选员工中工资高于8000的人，并形成新的集合。 形成新集合依赖collect（收集）。
3.3 聚合（max/min/count)
3.4 映射(map/flatMap)--会对每一个元素进行修改等附加操作
3.5 归约(reduce)
3.6 收集(collect)
3.6.1 归集(toList/toSet/toMap)
toMap 的案例" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/f05fa0be879a0141063fd85ecc6f091c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-27T18:15:48+08:00" />
<meta property="article:modified_time" content="2022-02-27T18:15:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java8 Stream 流的创建、筛选、映射、排序、归约、分组、聚合、提取与组合、收集、接合、foreach遍历</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%C2%A0%20%E4%BA%86%E8%A7%A3Stream-toc" style="margin-left:0px;"><a href="#%E4%B8%80%C2%A0%20%E4%BA%86%E8%A7%A3Stream" rel="nofollow">一  了解Stream</a></p> 
<p id="Stream%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#Stream%E6%A6%82%E8%BF%B0" rel="nofollow">1 Stream概述</a></p> 
<p id="%E9%82%A3%E4%B9%88%E4%BB%80%E4%B9%88%E6%98%AFStream%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E9%82%A3%E4%B9%88%E4%BB%80%E4%B9%88%E6%98%AFStream%EF%BC%9F" rel="nofollow">那么什么是Stream？</a></p> 
<p id="Stream%E5%8F%AF%E4%BB%A5%E7%94%B1%E6%95%B0%E7%BB%84%E6%88%96%E9%9B%86%E5%90%88%E5%88%9B%E5%BB%BA-toc" style="margin-left:80px;"><a href="#Stream%E5%8F%AF%E4%BB%A5%E7%94%B1%E6%95%B0%E7%BB%84%E6%88%96%E9%9B%86%E5%90%88%E5%88%9B%E5%BB%BA" rel="nofollow">Stream可以由数组或集合创建</a></p> 
<p id="Stream%E6%9C%89%E5%87%A0%E4%B8%AA%E7%89%B9%E6%80%A7%EF%BC%9A-toc" style="margin-left:80px;"><a href="#Stream%E6%9C%89%E5%87%A0%E4%B8%AA%E7%89%B9%E6%80%A7%EF%BC%9A" rel="nofollow">Stream有几个特性：</a></p> 
<p id="Stream%E6%B5%81%E7%9A%84%E8%B5%B7%E5%A7%8B%E6%93%8D%E4%BD%9C-toc" style="margin-left:40px;"><a href="#Stream%E6%B5%81%E7%9A%84%E8%B5%B7%E5%A7%8B%E6%93%8D%E4%BD%9C" rel="nofollow">Stream流的起始操作</a></p> 
<p id="V9KUg-toc" style="margin-left:0px;"><a href="#V9KUg" rel="nofollow">2 Stream的创建----Stream可以通过集合数组创建。</a></p> 
<p id="R01SO-toc" style="margin-left:80px;"><a href="#R01SO" rel="nofollow">3、通过 java.util.Collection.stream() 方法 用map集合 ,间接创建生成流</a></p> 
<p id="stream%E5%92%8CparallelStream%E7%9A%84%E7%AE%80%E5%8D%95%E5%8C%BA%E5%88%86%EF%BC%9A-toc" style="margin-left:80px;"><a href="#stream%E5%92%8CparallelStream%E7%9A%84%E7%AE%80%E5%8D%95%E5%8C%BA%E5%88%86%EF%BC%9A" rel="nofollow">stream和parallelStream的简单区分：</a></p> 
<p id="4%E3%80%81%E4%BD%BF%E7%94%A8java.util.Arrays.stream(T%5B%5D%20array)%E6%96%B9%E6%B3%95%20%E7%94%A8%E6%95%B0%E7%BB%84%20%E5%88%9B%E5%BB%BA%E6%B5%81-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E4%BD%BF%E7%94%A8java.util.Arrays.stream%28T%5B%5D%20array%29%E6%96%B9%E6%B3%95%20%E7%94%A8%E6%95%B0%E7%BB%84%20%E5%88%9B%E5%BB%BA%E6%B5%81" rel="nofollow">4、使用java.util.Arrays.stream(T[] array)方法 用数组 创建流</a></p> 
<p id="gxL5F-toc" style="margin-left:40px;"><a href="#gxL5F" rel="nofollow">3 Stream的使用</a></p> 
<p id="sCctZ-toc" style="margin-left:80px;"><a href="#sCctZ" rel="nofollow">类声明</a></p> 
<p id="zHlmq-toc" style="margin-left:80px;"><a href="#zHlmq" rel="nofollow">类方法   注意： 这些方法是从 java.lang.Object 类继承来的。</a></p> 
<p id="B5CEj-toc" style="margin-left:40px;"><a href="#B5CEj" rel="nofollow">Optional 实例</a></p> 
<p id="JKJNb-toc" style="margin-left:80px;"><a href="#JKJNb" rel="nofollow">输出结果：</a></p> 
<p id="nai1l-toc" style="margin-left:40px;"><a href="#nai1l" rel="nofollow">案例使用的员工类</a></p> 
<p id="r4aKc-toc" style="margin-left:40px;"><a href="#r4aKc" rel="nofollow">3.1 遍历/匹配（foreach/find/match）</a></p> 
<p id="hrmlT-toc" style="margin-left:80px;"><a href="#hrmlT" rel="nofollow">foreach()是终止操作，只能执行一次，之后再执行此操作，会报IllegalStateException异常</a></p> 
<p id="%C2%A0%E6%A1%88%E4%BE%8B---%20forEach()%20%2F%C2%A0%C2%A0findFirst()%20%2F%C2%A0%20findAny()%20%2F%20findFirst.get()%20%2F%C2%A0findAny.get()%20%2F%C2%A0anyMatch(%EF%BC%89-toc" style="margin-left:80px;"><a href="#%C2%A0%E6%A1%88%E4%BE%8B---%20forEach%28%29%20%2F%C2%A0%C2%A0findFirst%28%29%20%2F%C2%A0%20findAny%28%29%20%2F%20findFirst.get%28%29%20%2F%C2%A0findAny.get%28%29%20%2F%C2%A0anyMatch%28%EF%BC%89" rel="nofollow"> 案例--- forEach() /  findFirst() /  findAny() / findFirst.get() / findAny.get() / anyMatch(）</a></p> 
<p id="NLhfH-toc" style="margin-left:40px;"><a href="#NLhfH" rel="nofollow">二 Stream流常见的中间操作</a></p> 
<p id="gTzE5-toc" style="margin-left:40px;"><a href="#gTzE5" rel="nofollow">3.2 筛选（filter）--进行筛选提取，不对元素进行修改附加操作</a></p> 
<p id="%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9Afilter%E7%9A%84%E5%B8%B8%E8%A7%84%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"><a href="#%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9Afilter%E7%9A%84%E5%B8%B8%E8%A7%84%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C" rel="nofollow">案例一：filter的常规中间操作</a></p> 
<p id="%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E7%AD%9B%E9%80%89%E5%87%BAInteger%E9%9B%86%E5%90%88%E4%B8%AD%E5%A4%A7%E4%BA%8E7%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E5%B9%B6%E6%89%93%E5%8D%B0%E5%87%BA%E6%9D%A5-toc" style="margin-left:80px;"><a href="#%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E7%AD%9B%E9%80%89%E5%87%BAInteger%E9%9B%86%E5%90%88%E4%B8%AD%E5%A4%A7%E4%BA%8E7%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E5%B9%B6%E6%89%93%E5%8D%B0%E5%87%BA%E6%9D%A5" rel="nofollow">案例二：筛选出Integer集合中大于7的元素，并打印出来</a></p> 
<p id="%E6%A1%88%E4%BE%8B%E4%B8%89%EF%BC%9A%20%E7%AD%9B%E9%80%89%E5%91%98%E5%B7%A5%E4%B8%AD%E5%B7%A5%E8%B5%84%E9%AB%98%E4%BA%8E8000%E7%9A%84%E4%BA%BA%EF%BC%8C%E5%B9%B6%E5%BD%A2%E6%88%90%E6%96%B0%E7%9A%84%E9%9B%86%E5%90%88%E3%80%82%20%E5%BD%A2%E6%88%90%E6%96%B0%E9%9B%86%E5%90%88%E4%BE%9D%E8%B5%96collect%EF%BC%88%E6%94%B6%E9%9B%86%EF%BC%89%E3%80%82-toc" style="margin-left:80px;"><a href="#%E6%A1%88%E4%BE%8B%E4%B8%89%EF%BC%9A%20%E7%AD%9B%E9%80%89%E5%91%98%E5%B7%A5%E4%B8%AD%E5%B7%A5%E8%B5%84%E9%AB%98%E4%BA%8E8000%E7%9A%84%E4%BA%BA%EF%BC%8C%E5%B9%B6%E5%BD%A2%E6%88%90%E6%96%B0%E7%9A%84%E9%9B%86%E5%90%88%E3%80%82%20%E5%BD%A2%E6%88%90%E6%96%B0%E9%9B%86%E5%90%88%E4%BE%9D%E8%B5%96collect%EF%BC%88%E6%94%B6%E9%9B%86%EF%BC%89%E3%80%82" rel="nofollow">案例三： 筛选员工中工资高于8000的人，并形成新的集合。 形成新集合依赖collect（收集）。</a></p> 
<p id="m5QQQ-toc" style="margin-left:40px;"><a href="#m5QQQ" rel="nofollow">3.3 聚合（max/min/count)</a></p> 
<p id="Hv8dd-toc" style="margin-left:40px;"><a href="#Hv8dd" rel="nofollow">3.4 映射(map/flatMap)--会对每一个元素进行修改等附加操作</a></p> 
<p id="QbqvV-toc" style="margin-left:40px;"><a href="#QbqvV" rel="nofollow">3.5 归约(reduce)</a></p> 
<p id="PouLN-toc" style="margin-left:40px;"><a href="#PouLN" rel="nofollow">3.6 收集(collect)</a></p> 
<p id="lCOKU-toc" style="margin-left:80px;"><a href="#lCOKU" rel="nofollow">3.6.1 归集(toList/toSet/toMap)</a></p> 
<p id="yNEO9-toc" style="margin-left:80px;"><a href="#yNEO9" rel="nofollow">toMap 的案例</a></p> 
<p id="s1rbN-toc" style="margin-left:80px;"><a href="#s1rbN" rel="nofollow">3.6.2 统计(count/averaging)</a></p> 
<p id="H7CBM-toc" style="margin-left:80px;"><a href="#H7CBM" rel="nofollow">3.6.3 分组(partitioningBy/groupingBy)</a></p> 
<p id="WdvSt-toc" style="margin-left:80px;"><a href="#WdvSt" rel="nofollow">3.6.4 接合(joining)</a></p> 
<p id="p7KxJ-toc" style="margin-left:80px;"><a href="#p7KxJ" rel="nofollow">3.6.5 归约(reducing)</a></p> 
<p id="HChAD-toc" style="margin-left:40px;"><a href="#HChAD" rel="nofollow">3.7 排序(sorted)---自然排序调用的是equals（）方法</a></p> 
<p id="yF6q3-toc" style="margin-left:40px;"><a href="#yF6q3" rel="nofollow">3.8 提取/组合--中间操作</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%C2%A0%20%E4%BA%86%E8%A7%A3Stream">一  了解Stream</h2> 
<p></p> 
<h2 id="Stream%E6%A6%82%E8%BF%B0">1 Stream概述</h2> 
<p id="u7b699d40"><a href="https://so.csdn.net/so/search?q=Java&amp;spm=1001.2101.3001.7020" title="Java">Java</a><strong> 8 是一个非常成功的版本</strong>，这个版本新增的Stream，配合同版本出现的 Lambda ，给我们操作<a href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&amp;spm=1001.2101.3001.7020" title="集合">集合</a>（Collection）提供了极大的便利。</p> 
<p> </p> 
<p> <img src="https://images2.imgbox.com/cf/9d/91W2aVns_o.png" alt="6d75a3f1539c920ea20638530e160633.png"></p> 
<p> </p> 
<p></p> 
<p></p> 
<h4 id="%E9%82%A3%E4%B9%88%E4%BB%80%E4%B9%88%E6%98%AFStream%EF%BC%9F"><span style="color:#fe2c24;"><strong>那么什么是Stream？</strong></span></h4> 
<p id="ubcea2332"><strong>Stream</strong><strong>将要处理的元素集合看作一种流，在流的过程中，借助</strong><strong>Stream API</strong><strong>对流中的元素进行操作，比如：筛选、映射、排序、归约、分组、聚合、提取与组合、收集、接合、foreach遍历等。</strong></p> 
<p></p> 
<p> </p> 
<h4 id="Stream%E5%8F%AF%E4%BB%A5%E7%94%B1%E6%95%B0%E7%BB%84%E6%88%96%E9%9B%86%E5%90%88%E5%88%9B%E5%BB%BA">Stream可以由数组或集合创建</h4> 
<p>对流的操作分为两种： </p> 
<p><span style="color:#fe2c24;"><strong>中间操作：</strong></span>每次返回一个新的流，可以有多个。</p> 
<p><span style="color:#fe2c24;"><strong>终止操作：</strong></span>流只能进行一次终端操作，终止操作结束后流无法再次使用。终止操作会产生一个新的集合或值。</p> 
<p></p> 
<h4 id="Stream%E6%9C%89%E5%87%A0%E4%B8%AA%E7%89%B9%E6%80%A7%EF%BC%9A">Stream有几个特性：</h4> 
<blockquote> 
 <p id="u35bf2212"><strong>stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。</strong></p> 
 <p id="u9b5c21de"><strong>stream不会改变数据源，通常情况下会产生一个新的集合或一个值。</strong></p> 
 <p id="u57aab740"><strong>stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。</strong></p> 
</blockquote> 
<p></p> 
<h3 id="Stream%E6%B5%81%E7%9A%84%E8%B5%B7%E5%A7%8B%E6%93%8D%E4%BD%9C">Stream流的起始操作</h3> 
<p></p> 
<h2 id="V9KUg">2 Stream的创建----Stream可以通过集合数组创建。</h2> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c5/90/OjJUUU1Q_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0c/bd/VAsLVS4o_o.png"></p> 
<p> </p> 
<p><strong>1、通过 java.util.Collection.stream() 方法 用list集合 创建流 --顺序流/并行流</strong></p> 
<pre><code class="language-java">		/*
         * @Author Vincent
         * @Description
         * 1、通过 java.util.Collection.stream() 方法用集合创建流
         **/

        List&lt;String&gt; list = Arrays.asList("A", "B", "C");
        //创建一个顺序流
        Stream&lt;String&gt; stream = list.stream();
        stream.forEach(System.out::println);

        System.out.println("=============list.stream()=================");
</code></pre> 
<pre><code class="language-java">//创建一个并行流
        Stream&lt;String&gt; parallelStream = list.parallelStream();
        parallelStream.forEach(System.out::println);
        
        System.out.println("===============list.parallelStream()===============");</code></pre> 
<p></p> 
<p><strong>2、通过 java.util.Collection.stream() 方法 用set集合 创建流</strong></p> 
<pre><code class="language-java">System.out.println("============set.stream()==================");

        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();
        set.add("法外狂徒张三");
        set.add("芜湖大司马");
        set.add("杭州吴彦祖");
        Stream&lt;String&gt; setStream = set.stream();
        setStream.forEach(System.out::println);</code></pre> 
<p id="u268b6b78">输出结果：</p> 
<pre><code class="language-java">============set.stream()==================
法外狂徒张三
芜湖大司马
杭州吴彦祖</code></pre> 
<p> </p> 
<h4 id="R01SO">3、通过 java.util.Collection.stream() 方法 <span style="color:#fe2c24;">用map集合 ,间接创建生成流</span></h4> 
<pre><code class="language-java">System.out.println("============Map集合只能间接生成流==================");

        System.out.println("===========map.keySet().stream()================");
        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        map.put("唐伯虎",9527);
        map.put("祝枝山",9528);
        map.put("文征明",9529);
        map.put("徐祯卿",9530);

        Stream&lt;String&gt; keyStream = map.keySet().stream();
        keyStream.forEach(System.out::println);

        System.out.println("===========map.values().stream()================");

        Stream&lt;Integer&gt; valueStream = map.values().stream();
        valueStream.forEach(System.out::println);

        System.out.println("============map.entrySet().stream()============");

        Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; entryStream= map.entrySet().stream();
        entryStream.forEach(System.out::println);
</code></pre> 
<p id="u291ab6b9">输出结果：</p> 
<pre><code>============Map集合只能间接生成流==================
===========map.keySet().stream()================
祝枝山
徐祯卿
唐伯虎
文征明
===========map.values().stream()================
9528
9530
9527
9529
============map.entrySet().stream()============
祝枝山=9528
徐祯卿=9530
唐伯虎=9527
文征明=9529</code></pre> 
<p></p> 
<h4 id="stream%E5%92%8CparallelStream%E7%9A%84%E7%AE%80%E5%8D%95%E5%8C%BA%E5%88%86%EF%BC%9A">stream和parallelStream的简单区分：</h4> 
<p id="ud32c9a9e"><span style="color:#fe2c24;"><strong>stream是顺序流</strong></span>，由主线程按顺序对流执行操作；</p> 
<p id="uce4e1835"><strong><span style="color:#fe2c24;">而parallelStream是并行流</span></strong>，内部以多线程并行执行的方式对流进行操作；</p> 
<p id="uea4aaa47">但<strong>前提是流中的</strong><a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE&amp;spm=1001.2101.3001.7020" title="数据">数据</a><strong>处理没有顺序要求</strong>。例如筛选集合中的奇数，两者的处理不同之处：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ec/17/16t2xIUD_o.png"></p> 
<p> </p> 
<p id="u3501141c"><strong><span style="color:#fe2c24;">如果流中的数据量足够大，并行流可以加快处速度。</span></strong></p> 
<p id="ubd17b0c8"><strong>除了直接创建并行流，还可以通过</strong><strong>parallel()</strong><strong>把顺序流转换成并行流：</strong></p> 
<pre><code class="language-java">List&lt;Integer&gt; list2 = Arrays.asList(3, 4, 5,7,9,8,1,18);
        //把顺序流转成并行流   过滤x&gt;6的数，取第一个数
        Optional&lt;Integer&gt; integergOptional = list2.stream().parallel().filter(x -&gt; x &gt; 6).findFirst();
        System.out.println(stringOptional);

        System.out.println("==============================");</code></pre> 
<p></p> 
<h4 id="4%E3%80%81%E4%BD%BF%E7%94%A8java.util.Arrays.stream(T%5B%5D%20array)%E6%96%B9%E6%B3%95%20%E7%94%A8%E6%95%B0%E7%BB%84%20%E5%88%9B%E5%BB%BA%E6%B5%81">4、使用java.util.Arrays.stream(T[] array)方法 用数组 创建流</h4> 
<pre><code class="language-java">/**
         * @Author Vincent
         * @Description //TODO
         * 2、使用java.util.Arrays.stream(T[] array)方法用数组创建流
         **/

        int[] array ={2,4,6,8,9};
        IntStream arrStream = Arrays.stream(array);
        arrStream.forEach(System.out::println);

        System.out.println("===============Arrays.stream()===============");</code></pre> 
<p><strong>4.1 使用Stream的静态方法：of()、iterate()、generate()</strong></p> 
<pre><code class="language-java">	/**
         * @Author Vincent
         * @Description
         * 3、使用Stream的静态方法：of()、iterate()、generate()
         **/

       System.out.println("==============Stream.of()================");
        //of()
        Stream&lt;int[]&gt; arrayStream = Stream.of(array);
        Stream&lt;Integer&gt; integerStream = Stream.of(1, 2, 3, 4, 5, 6);
        Stream&lt;String&gt; stringStream = Stream.of("hello", "world", "java", "yyds");

        arrayStream.forEach(System.out::println);
        integerStream.forEach(System.out::println);
        stringStream.forEach(System.out::println);

        System.out.println("==============Stream.iterate()================");
        //iterate() x从0开始，进行x+3运算，取前4条数据
        Stream&lt;Integer&gt; limitStream = Stream.iterate(0, (x) -&gt; x + 3).limit(4);
        //foreach结合方法引用
        limitStream.forEach(System.out::println);

        System.out.println("==============Stream.generate()================");

        //generate() 生成
        Stream&lt;Double&gt; generateStream = Stream.generate(Math::random).limit(3);
        generateStream.forEach(System.out::println);
</code></pre> 
<p><strong>输出结果：</strong></p> 
<pre><code class="language-java">============list.stream()==================
A
B
C
============set.stream()==================
法外狂徒张三
芜湖大司马
杭州吴彦祖
============Map集合只能间接生成流==================
===========map.keySet().stream()================
祝枝山
徐祯卿
唐伯虎
文征明
===========map.values().stream()================
9528
9530
9527
9529
============map.entrySet().stream()============
祝枝山=9528
徐祯卿=9530
唐伯虎=9527
文征明=9529
=============list2.stream().parallel()=================
Optional[7]
=============list.parallelStream()=================
B
C
A
=============Arrays.stream()=================
2
4
6
8
9
==============Stream.of()================
[I@643b1d11
1
2
3
4
5
6
hello
world
java
yyds
==============Stream.iterate()================
0
3
6
9
==============Stream.generate()================
0.8949224931186376
0.3844974833341598
0.7886508926329633

Process finished with exit code 0
</code></pre> 
<p></p> 
<p></p> 
<h3 id="gxL5F">3 Stream的使用</h3> 
<p><strong>在使用stream之前，先理解一个概念：Optional</strong></p> 
<blockquote> 
 <p id="u4da8ef69"><strong>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</strong></p> 
 <p id="u13689fa6"><strong>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</strong></p> 
 <p id="u2a993997"><strong>Optional 类的引入很好的解决空指针异常。</strong></p> 
</blockquote> 
<h4 id="sCctZ">类声明</h4> 
<blockquote> 
 <p id="u17d68d8e">以下是一个 <strong>java.util.Optional&lt;T&gt;</strong> 类的声明：</p> 
 <p id="u126abe48"><strong>public </strong><strong>final </strong><strong>class </strong><strong>Optional</strong><strong>&lt;</strong><strong>T</strong><strong>&gt; </strong><strong>extends </strong><strong>Object </strong></p> 
</blockquote> 
<h4></h4> 
<h4 id="zHlmq">类方法   <span style="color:#fe2c24;"><strong>注意： 这些方法是从 </strong><strong>java.lang.Object </strong><strong>类继承来的。</strong></span></h4> 
<table><tbody><tr><td> <p id="u56e47bc5">序号</p> </td><td> <p id="ue7ca6aef">方法 &amp; 描述</p> </td></tr><tr><td> <p id="u93b03fd1">1</p> </td><td> <p id="ua3cee259"><strong>static &lt;T&gt; Optional&lt;T&gt; empty()</strong></p> <p id="ub1c4515b">返回空的 Optional 实例。</p> </td></tr><tr><td> <p id="u9f235c82">2</p> </td><td> <p id="u93c25f0c"><strong>boolean equals(Object obj)</strong></p> <p id="u68b4fe5d">判断其他对象是否等于 Optional。</p> </td></tr><tr><td> <p id="u3d255ecf">3</p> </td><td> <p id="u871d4e47"><strong>Optional&lt;T&gt; filter(Predicate&lt;? super &lt;T&gt; predicate)</strong></p> <p id="u45e81eb0">如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。</p> </td></tr><tr><td> <p id="u745e1c8b">4</p> </td><td> <p id="uabe5d836"><strong>&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T,Optional&lt;U&gt;&gt; mapper)</strong></p> <p id="ude4d5b59">如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional</p> </td></tr><tr><td> <p id="u3ad3d939">5</p> </td><td> <p id="u7aa6e58b"><strong>T get()</strong></p> <p id="u7bacec8a">如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException</p> </td></tr><tr><td> <p id="u9254f412">6</p> </td><td> <p id="u76a1f430"><strong>int hashCode()</strong></p> <p id="ud5918a9a">返回存在值的哈希码，如果值不存在 返回 0。</p> </td></tr><tr><td> <p id="u10212c2c">7</p> </td><td> <p id="u60df5c46"><strong>void ifPresent(Consumer&lt;? super T&gt; consumer)</strong></p> <p id="ub0fa57e3">如果值存在则使用该值调用 consumer , 否则不做任何事情。</p> </td></tr><tr><td> <p id="ue72bc3c1">8</p> </td><td> <p id="uc0d068e9"><strong>boolean isPresent()</strong></p> <p id="u01d69e40">如果值存在则方法会返回true，否则返回 false。</p> </td></tr><tr><td> <p id="ub7bd3be4">9</p> </td><td> <p id="u8de889e7"><strong>&lt;U&gt;Optional&lt;U&gt; map(Function&lt;? super T,? extends U&gt; mapper)</strong></p> <p id="udf6ab5e0">如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。</p> </td></tr><tr><td> <p id="uabd0a5c7">10</p> </td><td> <p id="uaeeee9aa"><strong>static &lt;T&gt; Optional&lt;T&gt; of(T value)</strong></p> <p id="u978f3bfe">返回一个指定非null值的Optional。</p> </td></tr><tr><td> <p id="u9a9498a8">11</p> </td><td> <p id="u4257ee91"><strong>static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)</strong></p> <p id="uaa369c90">如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。</p> </td></tr><tr><td> <p id="u1a38aa00">12</p> </td><td> <p id="uac4da36f"><strong>T orElse(T other)</strong></p> <p id="uaf9e8927">如果存在该值，返回值， 否则返回 other。</p> </td></tr><tr><td> <p id="u6658840c">13</p> </td><td> <p id="u7e7a3a0d"><strong>T orElseGet(Supplier&lt;? extends T&gt; other)</strong></p> <p id="u3e204adc">如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。</p> </td></tr><tr><td> <p id="u3f51355f">14</p> </td><td> <p id="u509723e5"><strong>&lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</strong></p> <p id="u7f02404d">如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常</p> </td></tr><tr><td> <p id="u15875e8e">15</p> </td><td> <p id="u3dd8a7a7"><strong>String toString()</strong></p> <p id="u466f8e83">返回一个Optional的非空字符串，用来调试</p> </td></tr></tbody></table> 
<p></p> 
<h3 id="B5CEj">Optional 实例</h3> 
<pre><code class="language-java">/**
 * @author Vincent
 * @version V1.0
 * @Package com.legion.streamstudy
 * @Description Java8--&gt;Optional的学习
 * @date 2022/2/26 14:33
 **/

public class OptionalTest {

    public static void main(String[] args) {

        //创建类对象
        OptionalTest java8Test = new OptionalTest();
        Integer value1 = null;
        Integer value2 = new Integer(10);

        // Optional.ofNullable - 允许传递为 null 参数
        Optional&lt;Integer&gt; a = Optional.ofNullable(value1);

        // Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException
        Optional&lt;Integer&gt; b = Optional.of(value2);
        System.out.println(java8Test.sum(a,b));

    }

    public Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b){

        // Optional.isPresent - 判断值是否存在

        System.out.println("第一个参数值存在: " + a.isPresent());
        System.out.println("第二个参数值存在: " + b.isPresent());

        // Optional.orElse - 如果值存在，返回它，否则返回默认值
        Integer value1 = a.orElse(new Integer(0));

        //Optional.get() - 获取值，值需要存在
        Integer value2 = b.get();
        return value1 + value2;
    }

}
</code></pre> 
<h4 id="JKJNb">输出结果：</h4> 
<pre><code class="language-java">第一个参数值存在: false
第二个参数值存在: true
10

Process finished with exit code 0</code></pre> 
<p></p> 
<h3 id="nai1l">案例使用的员工类</h3> 
<p id="u843b16e2">这是后面案例中使用的员工类：</p> 
<pre><code class="language-java">/**
 * @author Vincent
 * @version V1.0
 * @Package com.legion.streamstudy.exampleDemo
 * @Description 员工类
 * @date 2022/2/26 14:49
 **/


public class Person {


    private String name;  // 姓名
    private int salary; // 薪资
    private int age; // 年龄
    private String sex; //性别
    private String area;  // 地区


    public Person() { }

    public Person(String name, int salary, int age, String sex, String area) {
        this.name = name;
        this.salary = salary;
        this.age = age;
        this.sex = sex;
        this.area = area;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getSalary() {
        return salary;
    }

    public void setSalary(int salary) {
        this.salary = salary;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public String getArea() {
        return area;
    }

    public void setArea(String area) {
        this.area = area;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Person person = (Person) o;
        return salary == person.salary &amp;&amp;
                age == person.age &amp;&amp;
                Objects.equals(name, person.name) &amp;&amp;
                Objects.equals(sex, person.sex) &amp;&amp;
                Objects.equals(area, person.area);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, salary, age, sex, area);
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", salary=" + salary +
                ", age=" + age +
                ", sex='" + sex + '\'' +
                ", area='" + area + '\'' +
                '}';
    }
}
</code></pre> 
<p></p> 
<h3 id="r4aKc">3.1 遍历/匹配（foreach/find/match）</h3> 
<h4 id="hrmlT">foreach()是终止操作，只能执行一次，之后再执行此操作，会报<span style="color:#fe2c24;">IllegalStateException</span>异常</h4> 
<p>Stream也是支持类似集合的遍历和匹配元素的，只是Stream中的元素是以Optional类型存在的。Stream的遍历、匹配非常简单。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/04/1f/BpC74ILX_o.png"></p> 
<p> </p> 
<h4 id="%C2%A0%E6%A1%88%E4%BE%8B---%20forEach()%20%2F%C2%A0%C2%A0findFirst()%20%2F%C2%A0%20findAny()%20%2F%20findFirst.get()%20%2F%C2%A0findAny.get()%20%2F%C2%A0anyMatch(%EF%BC%89"><span style="color:#fe2c24;"><strong> 案例--- forEach() /  findFirst() /  findAny() / findFirst.get() / findAny.get() / anyMatch(）</strong></span></h4> 
<pre><code class="language-java">public class StreamForeachTest {
    public static void main(String[] args) {

        List&lt;Integer&gt; list = Arrays.asList(7, 6, 9, 3, 8, 2, 1);

        /**
         * @Author Vincent
         * @Description 遍历输出符合条件的元素
         * list.stream() 调用stream流方法
         * filter(x-&gt;x&gt;6) 筛选过滤条件
         * forEach()遍历
         * (System.out::println) 方法引用
         *
         **/
        list.stream().filter(x -&gt; x &gt; 6).forEach(System.out::println);

        /* 匹配满足条件的第一个元素
         * findFirst()
         * */
        Optional&lt;Integer&gt; findFirst = list.stream().filter(x -&gt; x &gt; 6).findFirst();


        /* 匹配任意（适用于并行流）
         * findAny()
         * */
        Optional&lt;Integer&gt; findAny = list.parallelStream().filter(x -&gt; x &gt; 6).findAny();


        boolean anyMatch = list.stream().anyMatch(x -&gt; x &gt; 6);


        System.out.println("匹配满足条件的第一个值：" + findFirst.get());
        System.out.println("匹配满足条件的任意一个值：" + findAny.get());
        System.out.println("是否存在大于6的值：" + anyMatch);

    }

}
</code></pre> 
<p><strong>输出结果：</strong></p> 
<pre><code class="language-java">7
9
8
匹配满足条件的第一个值：7
匹配满足条件的任意一个值：8
是否存在大于6的值：true

Process finished with exit code 0</code></pre> 
<p></p> 
<p></p> 
<h3 id="NLhfH">二 Stream流常见的中间操作</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/70/1b/NoVWNCq4_o.png"></p> 
<h3></h3> 
<h3 id="gTzE5">3.2 筛选（<a href="https://so.csdn.net/so/search?q=filter&amp;spm=1001.2101.3001.7020" title="filter">filter</a>）--进行筛选提取，<span style="color:#fe2c24;">不对元素进行修改附加操作</span></h3> 
<p><span style="color:#fe2c24;"><strong>筛选，是按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。</strong></span></p> 
<p><img alt="" src="https://images2.imgbox.com/63/e1/mOMpsh1l_o.png"></p> 
<p> </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h4 id="%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9Afilter%E7%9A%84%E5%B8%B8%E8%A7%84%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C">案例一：filter的常规中间操作</h4> 
<pre><code class="language-java">public class StreamFilterTest {
    public static void main(String[] args) {
      
        //把集合长度为3的元素在控制台输出
        ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;();
        list1.add("林青霞");
        list1.add("王祖贤");
        list1.add("张曼玉");
        list1.add("张敏");
        list1.add("钟丽缇");
        list1.add("朱茵");
        list1.add("莫文蔚");

        //把list集合中以朱开头的元素输出
        list1.stream().filter(s-&gt;s.startsWith("朱"))
                      .forEach(System.out::println);

        System.out.println("--------");

        //把集合长度为3的元素在控制台输出
        list1.stream().filter(s-&gt;s.length()==3)
                      .forEach(System.out::println);

        System.out.println("--------");

        //把list集合中以张开头且长度为3的元素在控制台输出
        list1.stream().filter(s-&gt;s.startsWith("张"))
                      .filter(s-&gt;s.length()==3)
                      .forEach(System.out::println);
    }
}</code></pre> 
<p id="u97a4e41d"><strong>输出结果：</strong></p> 
<pre><code class="language-java">朱茵
--------
林青霞
王祖贤
张曼玉
钟丽缇
莫文蔚
--------
张曼玉


Process finished with exit code 0</code></pre> 
<p></p> 
<h4 id="%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E7%AD%9B%E9%80%89%E5%87%BAInteger%E9%9B%86%E5%90%88%E4%B8%AD%E5%A4%A7%E4%BA%8E7%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C%E5%B9%B6%E6%89%93%E5%8D%B0%E5%87%BA%E6%9D%A5">案例二：筛选出Integer集合中大于7的元素，并打印出来</h4> 
<pre><code class="language-java">public class StreamFilterTest {
    public static void main(String[] args) {

        //筛选出Integer集合中大于7的元素，并打印出来
        List&lt;Integer&gt; list = Arrays.asList(6, 7, 3, 8, 1, 2, 9);
        Stream&lt;Integer&gt; stream = list.stream();
        stream.filter(x -&gt; x &gt; 7).forEach(System.out::println);

    }
}</code></pre> 
<p><strong>输出结果：</strong></p> 
<pre><code class="language-java">8
9

Process finished with exit code 0</code></pre> 
<p></p> 
<h4 id="%E6%A1%88%E4%BE%8B%E4%B8%89%EF%BC%9A%20%E7%AD%9B%E9%80%89%E5%91%98%E5%B7%A5%E4%B8%AD%E5%B7%A5%E8%B5%84%E9%AB%98%E4%BA%8E8000%E7%9A%84%E4%BA%BA%EF%BC%8C%E5%B9%B6%E5%BD%A2%E6%88%90%E6%96%B0%E7%9A%84%E9%9B%86%E5%90%88%E3%80%82%20%E5%BD%A2%E6%88%90%E6%96%B0%E9%9B%86%E5%90%88%E4%BE%9D%E8%B5%96collect%EF%BC%88%E6%94%B6%E9%9B%86%EF%BC%89%E3%80%82">案例三： 筛选员工中工资高于8000的人，并形成新的集合。 形成新集合依赖collect（收集）。</h4> 
<pre><code class="language-java">/**
 * @author Vincent
 * @version V1.0
 * @Package com.legion.streamstudy.exampleDemo
 * @Description 筛选员工中工资高于8000的人，并形成新的集合
 * @date 2022/2/26 15:24
 **/

public class StreamFilterCollect {
    public static void main(String[] args) {

        //多态
        List&lt;Person&gt; list = new ArrayList&lt;&gt;();

        list.add(new Person("Tom", 8900, 23, "male", "New York"));
        list.add(new Person("Jack", 7000, 25, "male", "Washington"));
        list.add(new Person("Lily", 7800, 21, "female", "Washington"));
        list.add(new Person("Anni", 8200, 24, "female", "New York"));
        list.add(new Person("Owen", 9500, 25, "male", "New York"));
        list.add(new Person("Alisa", 7900, 26, "female", "New York"));

        /**
         * @Author Vincent
         * @Description 筛选员工中工资高于8000的人，并形成新的集合。 形成新集合依赖collect（收集）
         * @Date 15:33 2022/2/26
         * list.stream() 调用stream流
         * filter(person-&gt;person.getSalary()&gt;8000) 筛选薪水&gt;8000的person   如&lt;Tom,8900&gt;,&lt;Anni,8200&gt;,&lt;Owen,9500&gt;
         * map(Person::getName) 把满足上述条件的人的人名获取到放在map中
         * collect(Collectors.toList()) 收集转成list集合
         * forEach(System.out::println) 遍历输出
         **/
        
        list.stream().filter(person-&gt;person.getSalary()&gt;8000).map(Person::getName).collect(Collectors.toList()).forEach(System.out::println);
        
    }
}
</code></pre> 
<p><strong>输出结果：</strong></p> 
<pre><code class="language-java">Tom
Anni
Owen

Process finished with exit code 0</code></pre> 
<p></p> 
<p></p> 
<h3 id="m5QQQ">3.3 聚合（max/min/count)</h3> 
<p id="u684182a6"><strong>max</strong><strong>、</strong><strong>min</strong><strong>、</strong><strong>count</strong>这些字眼你一定不陌生，没错，在mysql中我们常用它们进行数据<a href="https://so.csdn.net/so/search?q=%E7%BB%9F%E8%AE%A1&amp;spm=1001.2101.3001.7020" title="统计">统计</a>。</p> 
<p id="uc4724815">Java stream中也引入了这些概念和用法，极大地方便了我们对集合、数组的数据统计工作。</p> 
<p></p> 
<p><img alt="" src="https://images2.imgbox.com/8b/81/DgXfmMro_o.png"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p><strong>案例一：获取String集合中最长的元素。</strong></p> 
<pre><code class="language-java">/**
 * @author Vincent
 * @version V1.0
 * @Package com.legion.streamstudy.exampleDemo
 * @Description TODO
 * @date 2022/2/26 15:54
 **/
public class StreamAggregateTest {
    public static void main(String[] args) {

        /**
         * @Author Vincent
         * @Description //获取String集合中最长的元素
         * @Date 15:58 2022/2/26
         * max()
         * Comparator.comparing(String::length) 调用比较器中的comparing()方法，比较String类型的元素长度
         * get()方法，如果值存在则返回，值不存在则抛出异常NoSuchElementException
         **/
        List&lt;String&gt; list = Arrays.asList("adnm", "admmt", "csdn", "xbangd", "hellolegion");
        Optional&lt;String&gt; maxLength = list.stream().max(Comparator.comparing(String::length));

        System.out.println("最长的字符串：" + maxLength.get());

    }
}</code></pre> 
<p id="uf40cd234"><strong>输出结果：</strong></p> 
<blockquote> 
 <p id="uf27ddc99">最长的字符串：hellolegion</p> 
</blockquote> 
<p> </p> 
<p><strong>案例二：获取Integer集合中的最大值。</strong></p> 
<pre><code class="language-java">public class MaxIntegerTest {
    public static void main(String[] args) {

        List&lt;Integer&gt; list = Arrays.asList(7, 6, 9, 4, 11, 6);

        // 自然排序
        Optional&lt;Integer&gt; maxInteger = list.stream().max(Integer::compareTo);

        /**
         * @Author Vincent
         * @Description  自定义排序---要创建比较器对象--调用compare()方法
         * return o1.compareTo(o2);
         * new Comparator&lt;Integer&gt;() {} 匿名内部类
         * get()方法，如果值存在则返回，值不存在则抛出异常NoSuchElementException 
         * @Date 16:25 2022/1/26
         **/
        Optional&lt;Integer&gt; maxInteger2 = list.stream().max(new Comparator&lt;Integer&gt;() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1.compareTo(o2);
            }
        });

        System.out.println("自然排序的最大值：" + maxInteger.get());
        System.out.println("自定义排序的最大值：" + maxInteger2.get());
        
    }
}
</code></pre> 
<p></p> 
<p><strong>输出结果：</strong></p> 
<pre><code class="language-java">自然排序的最大值：11
自定义排序的最大值：11

Process finished with exit code 0
</code></pre> 
<p></p> 
<p><strong>案例三：获取员工工资最高的人。</strong></p> 
<pre><code class="language-java">public class MaxSalaryTest {
    public static void main(String[] args) {

        //案例三：获取员工工资最高的人
        List&lt;Person&gt; list = new ArrayList&lt;&gt;();

        list.add(new Person("Tom", 8900, 23, "male", "New York"));
        list.add(new Person("Jack", 7000, 25, "male", "Washington"));
        list.add(new Person("Lily", 7800, 21, "female", "Washington"));
        list.add(new Person("Anni", 8200, 24, "female", "New York"));
        list.add(new Person("Owen", 9500, 25, "male", "New York"));
        list.add(new Person("Alisa", 7900, 26, "female", "New York"));

        Optional&lt;Person&gt; maxSalary = list.stream().max(Comparator.comparingInt(Person::getSalary));
        System.out.println("员工工资最大值：" + maxSalary.get().getSalary());
    }
}
</code></pre> 
<p></p> 
<p><strong>输出结果：</strong></p> 
<blockquote> 
 <p>员工工资最大值：9500</p> 
</blockquote> 
<p></p> 
<p><strong>案例四：计算Integer集合中大于6的元素的个数。</strong></p> 
<pre><code class="language-java">public class MaxCountTest {
    public static void main(String[] args) {

        List&lt;Integer&gt; list = Arrays.asList(7, 6, 4, 8, 2, 11, 9);
          
        long count = list.stream().filter(x -&gt; x &gt; 6).count();
          
        System.out.println("list中大于6的元素个数：" + count);

    }
}
</code></pre> 
<p id="u32a646e0"><strong>输出结果：</strong></p> 
<blockquote> 
 <p id="uccbf2c78">list中大于6的元素个数：4</p> 
</blockquote> 
<p></p> 
<h3 id="Hv8dd">3.4 映射(map/flatMap)--<span style="color:#fe2c24;">会对每一个元素进行修改等附加操作</span></h3> 
<p id="u66fb6beb"><span style="color:#fe2c24;"><strong>映射</strong></span>，可以将一个流的元素按照一定的映射规则映射到另一个流中。分为map和flatMap：</p> 
<ul><li id="uaa09ab6d"><strong><span style="color:#fe2c24;">map</span></strong>：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</li><li id="ue9239248"><strong><span style="color:#fe2c24;">flatMap</span></strong>：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</li></ul> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/03/50/wgJR9sG2_o.png"></p> 
<p></p> 
<p><strong>案例一：英文字符串数组的元素全部改为大写。整数数组每个元素+3。</strong></p> 
<pre><code class="language-java">public class MapCollectTest {
    public static void main(String[] args) {

				 /**
         * @Author Vincent
         * map：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。
         **/

        //英文字符串数组的元素全部改为大写
        String[] strArr = {"abcd", "bcdd", "defde", "fTr"};
        List&lt;String&gt; stringList = Arrays.stream(strArr).map(String::toUpperCase).collect(Collectors.toList());

        //整数数组每个元素+3
        List&lt;Integer&gt; integerList = Arrays.asList(1, 3, 5, 7, 9, 11);
        List&lt;Integer&gt; integerListNew = integerList.stream().map(x -&gt; x + 3).collect(Collectors.toList());
        
        System.out.println("每个元素大写：" + stringList);
        System.out.println("每个元素+3：" + integerListNew);
    }
}
</code></pre> 
<p id="ub6aff8a1"><strong>输出结果：</strong></p> 
<pre><code class="language-java">每个元素大写：[ABCD, BCDD, DEFDE, FTR]
每个元素+3：[4, 6, 8, 10, 12, 14]

Process finished with exit code 0</code></pre> 
<p></p> 
<p><strong>案例二：将员工的薪资全部增加1000。</strong></p> 
<pre><code class="language-java">public class MapCollectTest2 {
    public static void main(String[] args) {

        //案例二：将员工的薪资全部增加1000。

        List&lt;Person&gt; list = new ArrayList&lt;&gt;();

        list.add(new Person("Tom", 8900, 23, "male", "New York"));
        list.add(new Person("Jack", 7000, 25, "male", "Washington"));
        list.add(new Person("Lily", 7800, 21, "female", "Washington"));
        list.add(new Person("Anni", 8200, 24, "female", "New York"));
        list.add(new Person("Owen", 9500, 25, "male", "New York"));
        list.add(new Person("Alisa", 7900, 26, "female", "New York"));

        //1.不改变原来员工集合的方式
        List&lt;Person&gt; personListNew = list.stream().map(person -&gt; {
            Person personNew = new Person(person.getName(), 0, 0, null, null);
            personNew.setSalary(person.getSalary() + 1000);
            return personNew;
        }).collect(Collectors.toList());

        // Person person = list.get(0);
        System.out.println("一次改动前：" + list.get(0).getName() + "--&gt;" + list.get(0).getSalary());
        System.out.println("一次改动后：" + personListNew.get(0).getName() + "--&gt;" + personListNew.get(0).getSalary());


        //2.改变原来员工集合的方式
        List&lt;Person&gt; personListNew2 = list.stream().map(person -&gt; {
            person.setSalary(person.getSalary() + 10000);
            return person;
        }).collect(Collectors.toList());

        System.out.println("二次改动前：" + personListNew.get(0).getName() + "--&gt;" + personListNew.get(0).getSalary());
        System.out.println("二次改动后：" + personListNew2.get(0).getName() + "--&gt;" + personListNew2.get(0).getSalary());
    }
}
</code></pre> 
<p id="u1ab6205d"><strong>输出结果：</strong></p> 
<blockquote> 
 <p id="u307199a3">一次改动前：Tom--&gt;8900</p> 
 <p id="u40297ab9">一次改动后：Tom--&gt;9900</p> 
 <p id="uf8425a6b">二次改动前：Tom--&gt;9900</p> 
 <p id="u9a863c74">二次改动后：Tom--&gt;18900</p> 
 <p id="u48b0aa58"></p> 
</blockquote> 
<p></p> 
<p><strong>案例三：将两个字符数组合并成一个新的字符数组。</strong></p> 
<pre><code class="language-java">public class MapCollectTest3 {
    public static void main(String[] args) {

        //将两个字符数组合并成一个新的字符数组。
        List&lt;String&gt; list = Arrays.asList("m,k,l,a", "1,3,5,7");
        List&lt;String&gt; listNew = list.stream().flatMap(s -&gt; {
            // 将每个元素转换成一个stream
            String[] split = s.split(",");
            Stream&lt;String&gt; s2 = Arrays.stream(split);
            return s2;
        }).collect(Collectors.toList());

        System.out.println("处理前的集合：" + list);
        System.out.println("处理后的集合：" + listNew);
    }
}
</code></pre> 
<p id="u9c3f6f88"><strong>输出结果：</strong></p> 
<pre><code class="language-java">处理前的集合：[m-k-l-a, 1,3,5,7]
处理后的集合：[m-k-l-a, 1, 3, 5, 7]</code></pre> 
<h3></h3> 
<h3 id="QbqvV">3.5 归约(<a href="https://so.csdn.net/so/search?q=reduce&amp;spm=1001.2101.3001.7020" title="reduce">reduce</a>)</h3> 
<p id="u2b572c92"><span style="color:#fe2c24;"><strong>归约，也称缩减</strong></span>，顾名思义，是<span style="color:#fe2c24;"><strong>把一个流缩减成一个值</strong></span>，能实现<strong>对集合 <span style="color:#fe2c24;">求和、求乘积 和求最值</span> </strong>操作。</p> 
<p><img alt="" src="https://images2.imgbox.com/bb/15/l0UMmLfE_o.png"></p> 
<p> </p> 
<p></p> 
<p> </p> 
<p><strong>案例一：求Integer集合的元素之和、乘积和最大值。</strong></p> 
<pre><code class="language-java">public class ReduceTest2 {
    public static void main(String[] args) {

        // 求所有员工的工资之和和最高工资。
        List&lt;Person&gt; list = new ArrayList&lt;&gt;();

        list.add(new Person("Tom", 8900, 23, "male", "New York"));
        list.add(new Person("Jack", 7000, 25, "male", "Washington"));
        list.add(new Person("Lily", 7800, 21, "female", "Washington"));
        list.add(new Person("Anni", 8200, 24, "female", "New York"));
        list.add(new Person("Owen", 9500, 25, "male", "New York"));
        list.add(new Person("Alisa", 7900, 26, "female", "New York"));


        // 求工资之和方式1--sum
        Optional&lt;Integer&gt; sumSalary = list.stream().map(Person::getSalary).reduce(Integer::sum);
        // 求工资之和方式2
        Integer sumSalary2 = list.stream().map(Person::getSalary).reduce(0, Integer::sum);
        //求工资之和方式3
        Integer sumSalary3 = list.stream().reduce(0, (sum, p) -&gt; sum += p.getSalary(), (sum1, sum2) -&gt; sum1 + sum2);

        //求工资之和方式4
        Integer sumSalary4 = list.stream().reduce(0, (sum, p) -&gt; sum += p.getSalary(), Integer::sum);


        //求最高工资方式1--max
        Integer maxSalary  = list.stream().reduce(0, (max, p) -&gt; max &gt; p.getSalary() ? max : p.getSalary(), Integer::max);

        //求最高工资方式2
        Integer maxSalary2 = list.stream().reduce(0, (max, p) -&gt; max &gt; p.getSalary() ? max : p.getSalary(),
                (max1, max2) -&gt; max1 &gt; max2 ? max1 : max2);

        System.out.println("工资之和：" + sumSalary.get() + "," + sumSalary2 + "," + sumSalary3+","+sumSalary4);
        System.out.println("最高工资：" + maxSalary + "," + maxSalary2);


    }
}</code></pre> 
<p id="u08d47c39"><strong>输出结果：</strong></p> 
<pre><code class="language-java">list求和：29,29,29
list求积：2112
list求最大值：11,11</code></pre> 
<p></p> 
<p><strong>案例二：求所有员工的工资之和和最高工资。</strong></p> 
<pre><code class="language-java">/**
 * @author Vincent
 * @version V1.0
 * @Package com.legion.streamstudy.exampleDemo.streamReduce
 * @Description 案例二：求所有员工的工资之和和最高工资。
 * @date 2022/2/26 19:24
 **/

public class ReduceTest2 {
    public static void main(String[] args) {

        // 求所有员工的工资之和和最高工资。
        List&lt;Person&gt; list = new ArrayList&lt;&gt;();

        list.add(new Person("Tom", 8900, 23, "male", "New York"));
        list.add(new Person("Jack", 7000, 25, "male", "Washington"));
        list.add(new Person("Lily", 7800, 21, "female", "Washington"));
        list.add(new Person("Anni", 8200, 24, "female", "New York"));
        list.add(new Person("Owen", 9500, 25, "male", "New York"));
        list.add(new Person("Alisa", 7900, 26, "female", "New York"));

        
        // 求工资之和方式1--sum
        Optional&lt;Integer&gt; sumSalary = list.stream().map(Person::getSalary).reduce(Integer::sum);
        //求工资之和方式2
        Integer sumSalary2 = list.stream().reduce(0, (sum, p) -&gt; sum += p.getSalary(), (sum1, sum2) -&gt; sum1 + sum2);
        
        //求工资之和方式3
        Integer sumSalary3 = list.stream().reduce(0, (sum, p) -&gt; sum += p.getSalary(), Integer::sum);


        //求最高工资方式1--max
        Integer maxSalary  = list.stream().reduce(0, (max, p) -&gt; max &gt; p.getSalary() ? max : p.getSalary(), Integer::max);

        //求最高工资方式2
        Integer maxSalary2 = list.stream().reduce(0, (max, p) -&gt; max &gt; p.getSalary() ? max : p.getSalary(),
                (max1, max2) -&gt; max1 &gt; max2 ? max1 : max2);

        System.out.println("工资之和：" + sumSalary.get() + "," + sumSalary2 + "," + sumSalary3);
        System.out.println("最高工资：" + maxSalary + "," + maxSalary2);


    }
}
</code></pre> 
<p><strong>输出结果：</strong></p> 
<pre><code>工资之和：49300,49300,49300,49300
最高工资：9500,9500

Process finished with exit code 0</code></pre> 
<p></p> 
<h3 id="PouLN">3.6 收集(collect)</h3> 
<p><strong>collect，收集，可以说是内容最繁多、功能最丰富的部分了。</strong></p> 
<p><strong>从字面上去理解，就是<span style="color:#fe2c24;">把一个流收集起来，最终 可以是收集成一个值 也 可以收集成一个新的集合</span>。</strong></p> 
<blockquote> 
 <p id="u2ae48107"><strong>collect</strong><strong>主要依赖</strong><strong>java.util.stream.<span style="color:#fe2c24;">Collectors</span></strong><strong>类内置的静态方法</strong></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a7/9d/Ne4tnGBF_o.png"></p> 
<p></p> 
<h4 id="lCOKU">3.6.1 归集(toList/toSet/toMap)</h4> 
<p>因为<span style="color:#fe2c24;"><strong>流不存储数据，那么在流中的数据完成处理后，需要将流中的数据重新归集到新的集合里。</strong></span></p> 
<p><strong>toList、toSet和toMap比较常用</strong>，另外还有toCollection、toConcurrentMap等复杂一些的用法。</p> 
<p></p> 
<p><strong>下面用一个案例演示toList、toSet和toMap：</strong></p> 
<pre><code class="language-java">public class StreamCollectTest {
    public static void main(String[] args) {

        //归集(toList/toSet/toMap)
        
        List&lt;Integer&gt; list = Arrays.asList(1, 6, 3, 4, 6, 7, 9, 6, 20);

        //筛选偶数转成list集合
        List&lt;Integer&gt; listNew = list.stream().filter(x -&gt; x % 2 == 0).collect(Collectors.toList());

        //筛选偶数转成set(无序且不重复的)集合
        Set&lt;Integer&gt; set = list.stream().filter(x -&gt; x % 2 == 0).collect(Collectors.toSet());



        List&lt;Person&gt; personList = new ArrayList&lt;&gt;();
        personList.add(new Person("Tom", 8900, 23, "male", "New York"));
        personList.add(new Person("Jack", 7000, 25, "male", "Washington"));
        personList.add(new Person("Lily", 7800, 21, "female", "Washington"));
        personList.add(new Person("Anni", 8200, 24, "female", "New York"));

        //筛选出薪水&gt;8000的人，转成map集合
        Map&lt;String, Person&gt; map = personList.stream().filter(p -&gt; p.getSalary() &gt; 8000).collect(Collectors.toMap(Person::getName, P -&gt; P));

        System.out.println("toList:" + listNew);
        System.out.println("toSet:" + set);
        System.out.println("toMap:" + map);

    }
}
</code></pre> 
<p id="u828b4544"><strong>输出结果：</strong></p> 
<p> </p> 
<pre><code class="language-java">toList:[6, 4, 6, 6, 20]
toSet:[4, 20, 6]
toMap:{Tom=com.legion.streamstudy.exampleDemo.Person@6b2fad11, Anni=com.legion.streamstudy.exampleDemo.Person@79698539}

Process finished with exit code 0
</code></pre> 
<p></p> 
<h4 id="yNEO9"><span style="color:#fe2c24;">toMap 的案例</span></h4> 
<pre><code class="language-java">public class MapCollectTest4 {
    public static void main(String[] args) {


        //创建list集合
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("林青霞");
        list.add("王祖贤");
        list.add("钟丽缇");
        list.add("张敏");
        list.add("朱茵");
        list.add("莫文蔚");

        //得到3个字的流
        Stream&lt;String&gt; listStream = list.stream().filter(s -&gt; s.length() == 3);

        //把Stream流操作玩的数据收集到list集合中
        List&lt;String&gt; names = listStream.collect(Collectors.toList());
        //names.forEach(System.out::println);

        //创建set集合
        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();
        set.add(10);
        set.add(20);
        set.add(30);
        set.add(35);


        //得到元素大于25的流
        Stream&lt;Integer&gt; ages = set.stream().filter(age -&gt; age &gt; 25);

        //把ages 收集到Set集合中，并遍历
        //ages.collect(Collectors.toSet()).forEach(System.out::println);


        System.out.println("==============Collectors.toMap()=====================");

        //定义一个字符串数组，每一个字符串数据由姓名数据和年龄数据组成
        String[] strArray = {"林青霞,30", "王祖贤,25", "钟丽缇,24", "张敏,26", "朱茵,27", "莫文蔚,28"};

        //得到字符串年龄数据大于28的流
        Stream&lt;String&gt; ageStream = Stream.of(strArray).filter(s -&gt; Integer.parseInt(s.split(",")[1]) &gt; 25);


        //把使用Stream流操作的数据收集到Map集合中遍历，姓名作为key,年龄作为value
        Map&lt;String, Integer&gt; map = ageStream.collect(Collectors.toMap(s -&gt; s.split(",")[0],
                                                                      s -&gt; Integer.parseInt(s.split(",")[1])));

        Set&lt;String&gt; keySet = map.keySet();
        for (String key : keySet) {
            Integer value = map.get(key);
            System.out.println(key + "," + value);

        }
    }
}
</code></pre> 
<p></p> 
<p id="u3817132b"><strong>输出结果：</strong></p> 
<pre><code class="language-java">林青霞,30
张敏,26
莫文蔚,28
朱茵,27

Process finished with exit code 0
</code></pre> 
<p></p> 
<h4 id="s1rbN">3.6.2 统计(count/averaging)</h4> 
<p id="u2179902c"><strong>Collectors</strong><strong>提供了一系列用于数据统计的静态方法：</strong></p> 
<ul><li id="u2e503f66"><strong>计数：</strong><span style="color:#fe2c24;"><strong>count</strong></span></li><li id="u05915669"><strong>平均值：</strong><span style="color:#fe2c24;"><strong>averagingInt</strong><strong>、</strong><strong>averagingLong</strong><strong>、</strong><strong>averagingDouble</strong></span></li></ul> 
<ul><li id="u0e70ba9c"><strong>最值：</strong><span style="color:#fe2c24;"><strong>maxBy</strong><strong>、</strong><strong>minBy</strong></span></li><li id="u25d44fdf"><strong>求和：</strong><span style="color:#fe2c24;"><strong>summingInt</strong><strong>、</strong><strong>summingLong</strong><strong>、</strong><strong>summingDouble</strong></span></li></ul> 
<ul><li id="u35d60771"><span style="color:#fe2c24;"><strong>统计以上所有：</strong><strong>summarizingInt</strong><strong>、</strong><strong>summarizingLong</strong><strong>、</strong><strong>summarizingDouble</strong></span></li></ul> 
<p> </p> 
<p> </p> 
<p><strong>案例：统计员工人数、平均工资、工资总额、最高工资。</strong></p> 
<p id="u8c51d3a8"><strong>数据统计常用Collectors类对象来调用各种方法</strong></p> 
<pre><code class="language-java">public class CountAverageTest {
    public static void main(String[] args) {

        //统计员工人数、平均工资、工资总额、最高工资。

        List&lt;Person&gt; list = new ArrayList&lt;&gt;();
        list.add(new Person("Tom", 8900, 23, "male", "New York"));
        list.add(new Person("Jack", 7000, 25, "male", "Washington"));
        list.add(new Person("Lily", 7800, 21, "female", "Washington"));

        // 求总数方式1
        Long count = list.stream().collect(Collectors.counting());
        // 求总数方式2
        Long count2 = list.stream().count();
        // 求总数方式3
        Long count3 = (long) list.size();

        // 求平均工资
        Double average  = list.stream().collect(Collectors.averagingDouble(Person::getSalary));

        // 求最高工资方式1
        Integer max1 = list.stream().reduce(0, (max, p) -&gt; max &gt; p.getSalary() ? max : p.getSalary(),
                Integer::max);
        // 求最高工资方式2
        Optional&lt;Integer&gt; max2 = list.stream().map(Person::getSalary).collect(Collectors.maxBy(Integer::compareTo));
        // 求最高工资方式3
        Optional&lt;Integer&gt; max3 = list.stream().map(Person::getSalary).max(Integer::compareTo);

        // 求工资之和
        IntSummaryStatistics sum = list.stream().collect(Collectors.summarizingInt(Person::getSalary));


        // 一次性统计所有信息
        DoubleSummaryStatistics statistics = list.stream().collect(Collectors.summarizingDouble(Person::getSalary));

        System.out.println("员工总数：" + count+","+count2+","+count3);
        System.out.println("员工平均工资：" + average);
        System.out.println("员工最高工资：" + max1+","+max2.get()+","+max3.get());
        System.out.println("员工工资总和：" + sum.getSum());
        System.out.println("员工工资所有统计：" + statistics);

    }
}
</code></pre> 
<p><strong>输出结果：</strong></p> 
<pre><code class="language-java">员工总数：3,3,3
员工平均工资：7900.0
员工最高工资：8900,8900,8900
员工工资总和：23700
员工工资所有统计：DoubleSummaryStatistics{count=3, sum=23700.000000, min=7000.000000, average=7900.000000, max=8900.000000}

Process finished with exit code 0
</code></pre> 
<p></p> 
<h4 id="H7CBM">3.6.3 分组(partitioningBy/groupingBy)</h4> 
<ul><li id="ua151c208"><strong><span style="color:#fe2c24;">分区</span>：<span style="color:#fe2c24;">将</span></strong><span style="color:#fe2c24;"><strong>stream</strong><strong>按条件分为两个</strong><strong>Map</strong></span><strong>，比如员工按薪资是否高于8000分为两部分。</strong></li></ul> 
<ul><li id="u2d46e84e"><strong><span style="color:#fe2c24;">分组</span>：<span style="color:#fe2c24;">将集合分为多个Map</span>，比如员工按性别分组。有单级分组和多级分组。</strong></li></ul> 
<p></p> 
<p><img alt="" src="https://images2.imgbox.com/ce/bf/3z4CPXlw_o.png"></p> 
<p> </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p><strong>案例：将员工按薪资是否高于8000分为两部分--<span style="color:#fe2c24;">partitioningBy() </span>；将员工按性别和地区分组--<span style="color:#fe2c24;">groupingBy()</span></strong></p> 
<pre><code class="language-java">public class GroupByTest {
    public static void main(String[] args) {

        //将员工按薪资是否高于8000分为两部分；将员工按性别和地区分组

        List&lt;Person&gt; list = new ArrayList&lt;&gt;();
        list.add(new Person("Tom", 8900,23, "male", "New York"));
        list.add(new Person("Jack", 7000,25, "male", "Washington"));
        list.add(new Person("Lily", 7800,28, "female", "Washington"));
        list.add(new Person("Anni", 8200,19, "female", "New York"));
        list.add(new Person("Owen", 9500,26, "male", "New York"));
        list.add(new Person("Alisa", 7900,21, "female", "New York"));


        // 将员工按薪资 是否 高于8000分组(两部分：高于8000和低于8000)--partitioningBy()
        Map&lt;Boolean, List&lt;Person&gt;&gt; part = list.stream().collect(Collectors.partitioningBy(x -&gt; x.getSalary() &gt; 8000));

        // 将员工按性别分组--groupingBy()
        Map&lt;String, List&lt;Person&gt;&gt; group  = list.stream().collect(Collectors.groupingBy(Person::getSex));

        // 将员工先按性别分组，再按地区分组--groupingBy()
        Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; group2  = list.stream().collect(Collectors.groupingBy(Person::getSex, Collectors.groupingBy(Person::getArea)));


        System.out.println("员工按薪资是否大于8000分组情况：" + part);
        System.out.println("员工按性别分组情况：" + group);
        System.out.println("员工按性别、地区：" + group2);


    }
}
</code></pre> 
<p><strong>输出结果：</strong></p> 
<pre><code class="language-java">员工按薪资是否大于8000分组情况：
{ false=[com.legion.streamstudy.exampleDemo.Person@42d3bd8b, com.legion.streamstudy.exampleDemo.Person@26ba2a48, com.legion.streamstudy.exampleDemo.Person@5f2050f6],
  true=[com.legion.streamstudy.exampleDemo.Person@3b81a1bc, com.legion.streamstudy.exampleDemo.Person@64616ca2, com.legion.streamstudy.exampleDemo.Person@13fee20c] }

员工按性别分组情况：
{ female=[com.legion.streamstudy.exampleDemo.Person@26ba2a48, com.legion.streamstudy.exampleDemo.Person@64616ca2, com.legion.streamstudy.exampleDemo.Person@5f2050f6],
  male=[com.legion.streamstudy.exampleDemo.Person@3b81a1bc, com.legion.streamstudy.exampleDemo.Person@42d3bd8b, com.legion.streamstudy.exampleDemo.Person@13fee20c] }

员工按性别、地区：
{ female={ New York=[com.legion.streamstudy.exampleDemo.Person@64616ca2, com.legion.streamstudy.exampleDemo.Person@5f2050f6], Washington=[com.legion.streamstudy.exampleDemo.Person@26ba2a48]},
  male={ New York=[com.legion.streamstudy.exampleDemo.Person@3b81a1bc, com.legion.streamstudy.exampleDemo.Person@13fee20c],  Washington=[com.legion.streamstudy.exampleDemo.Person@42d3bd8b]} }

Process finished with exit code 0
</code></pre> 
<p></p> 
<h4 id="WdvSt">3.6.4 接合(joining)</h4> 
<p><strong>joining 可以将stream中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串。</strong></p> 
<pre><code class="language-java">public class JoiningTest {
    public static void main(String[] args) {

        //Collectors.joining("分隔符")，用于拼接
        
        List&lt;Person&gt; list = new ArrayList&lt;&gt;();
        list.add(new Person("Tom", 8900, 23, "male", "New York"));
        list.add(new Person("Jack", 7000, 25, "male", "Washington"));
        list.add(new Person("Lily", 7800, 21, "female", "Washington"));

        //所有员工姓名，用逗号","隔开
        String names = list.stream().map(Person::getName).collect(Collectors.joining(","));
        System.out.println("所有员工的姓名：" + names);

        //用"-"拼接集合中的字符串
        List&lt;String&gt; list2 = Arrays.asList("A", "B", "C");
        String str = list2.stream().collect(Collectors.joining("-"));
        System.out.println("拼接后的字符串：" + str);
    }
}
</code></pre> 
<p><strong>输出结果：</strong></p> 
<pre><code class="language-java">所有员工的姓名：Tom,Jack,Lily
拼接后的字符串：A-B-C

Process finished with exit code 0</code></pre> 
<p></p> 
<h4 id="p7KxJ">3.6.5 归约(reducing)</h4> 
<p><span style="color:#fe2c24;"><strong>Collectors类</strong></span>提供的<span style="color:#fe2c24;">reducing</span>方法，<strong><span style="color:#fe2c24;">相比于stream本身的reduce方法，增加了对自定义归约的支持</span></strong>。</p> 
<pre><code class="language-java">public class StreamReducing {
    public static void main(String[] args) {

        //学习reducing()

        List&lt;Person&gt; list = new ArrayList&lt;&gt;();

        list.add(new Person("Tom", 8900, 23, "male", "New York"));
        list.add(new Person("Jack", 7000, 25, "male", "Washington"));
        list.add(new Person("Lily", 7800, 21, "female", "Washington"));

        // 每个员工减去起征点税后的薪资之和--reducing()方法
        Integer sum = list.stream().collect(Collectors.reducing(0, Person::getSalary, (i, j) -&gt; (i + j - 5000)));
        System.out.println("员工扣税薪资总和：" + sum);

        //stream的reduce()方法
        Optional&lt;Integer&gt; sum2 = list.stream().map(Person::getSalary).reduce(Integer::sum);
        System.out.println("员工薪资总和：" + sum2.get());
        
    }
}
</code></pre> 
<p><strong>输出结果：</strong></p> 
<pre><code class="language-java">员工扣税薪资总和：8700
员工薪资总和：23700

Process finished with exit code 0</code></pre> 
<p></p> 
<h3 id="HChAD">3.7 排序(sorted)---自然排序调用的是equals（）方法</h3> 
<p><strong><span style="color:#fe2c24;">sorted，中间操作。有两种排序：</span></strong></p> 
<ul><li id="u088c2d9d"><strong>sorted()：自然排序，流中元素需实现Comparable接口</strong></li><li id="uc7039fd2"><strong>sorted(Comparator com)：Comparator排序器---自定义排序</strong></li></ul> 
<p></p> 
<p><strong>案例：将员工按工资由高到低（工资一样则按年龄由大到小）排序</strong></p> 
<pre><code class="language-java">public class SortedTest {
    public static void main(String[] args) {

        //将员工按工资由高到低（工资一样则按年龄由大到小）排序

        List&lt;Person&gt; list = new ArrayList&lt;Person&gt;();

        list.add(new Person("Sherry", 9000, 24, "female", "New York"));
        list.add(new Person("Tom", 8900, 22, "male", "Washington"));
        list.add(new Person("Jack", 9000, 25, "male", "Washington"));
        list.add(new Person("Lily", 8800, 26, "male", "New York"));
        list.add(new Person("Alisa", 9000, 26, "female", "New York"));


        //按工资升序排序（自然排序）
        List&lt;String&gt; newList = list.stream().sorted(Comparator.comparing(Person::getSalary))
                .map(Person::getName).collect(Collectors.toList());

        // 按工资倒序排序 reversed() 反转   map(Person::getName)--&gt;映射到人名上
        List&lt;String&gt; newList2 = list.stream().sorted(Comparator.comparing(Person::getSalary).reversed())
                .map(Person::getName).collect(Collectors.toList());


        // 先按工资再按年龄升序排序 --&gt;先按工资排序，工资相同，按年龄升序排
        List&lt;String&gt; newList3 = list.stream().sorted(Comparator.comparing(Person::getSalary).thenComparing(Person::getAge))
                .map(Person::getName).collect(Collectors.toList());

        // 先按工资再按年龄 自定义排序（降序）, map(Person::getName)--&gt;映射到人名上
        List&lt;String&gt; newList4 = list.stream().sorted((p1, p2) -&gt; {
            if (p1.getSalary() == p2.getSalary()) {
                return p2.getAge() - p1.getAge();
            } else {
                return p2.getSalary() - p1.getSalary();
            }
        }).map(Person::getName).collect(Collectors.toList());

        System.out.println("按工资升序排序：" + newList);
        System.out.println("按工资降序排序：" + newList2);
        System.out.println("先按工资再按年龄升序排序：" + newList3);
        System.out.println("先按工资再按年龄自定义降序排序：" + newList4);

    }
}</code></pre> 
<p><strong>输出结果：</strong></p> 
<pre><code class="language-java">按工资升序排序：[Lily, Tom, Sherry, Jack, Alisa]
按工资降序排序：[Sherry, Jack, Alisa, Tom, Lily]
先按工资再按年龄升序排序：[Lily, Tom, Sherry, Jack, Alisa]
先按工资再按年龄自定义降序排序：[Alisa, Jack, Sherry, Tom, Lily]

Process finished with exit code 0</code></pre> 
<p></p> 
<p></p> 
<h3 id="yF6q3">3.8 提取/组合--<span style="color:#fe2c24;">中间操作</span></h3> 
<p><strong>流也可以进行<span style="color:#fe2c24;">合并、去重、限制、跳过</span>等操作。</strong></p> 
<p><span style="color:#fe2c24;"><strong>去重: distinct()</strong></span></p> 
<p><img src="https://images2.imgbox.com/49/a5/UrDSEUzB_o.png" alt="35e1736f96d1d24365990ded71106cf6.png"></p> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>限制: limit()</strong></span></p> 
<p><img alt="" src="https://images2.imgbox.com/27/44/3a5kqoll_o.png"></p> 
<p> </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>跳过: skip()</strong></span></p> 
<p><img alt="" src="https://images2.imgbox.com/63/0f/DcLwTnBn_o.png"></p> 
<p> </p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p id="u55a37b74"><span style="color:#fe2c24;"><strong>concat() 合并流</strong></span></p> 
<p id="u5c6f6f3e"><span style="color:#fe2c24;"><strong>limit() 限制取数</strong></span></p> 
<p id="ua08a834e"><span style="color:#fe2c24;"><strong>skip() 跳过元素</strong></span></p> 
<p><span style="color:#0d0016;"><strong>案例一：</strong></span></p> 
<pre><code class="language-java">public class ConcatTest {
    public static void main(String[] args) {

        //concat合并流操作

        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add("林青霞");
        list.add("王祖贤");
        list.add("张曼玉");
        list.add("张敏");
        list.add("钟丽缇");
        list.add("朱茵");
        list.add("莫文蔚");

        //取前4个数据组成一个流
        Stream&lt;String&gt; s1 = list.stream().limit(4);

        // 跳过2个数据组成一个流
        Stream&lt;String&gt; s2 = list.stream().skip(2);

        //合并上述得到的2个流，并输出结果
        Stream&lt;String&gt; concatStream = Stream.concat(s1, s2);
        //concatStream.forEach(System.out::println);

        /**
         * @Author Vincent
         * @Description //TODO
         *
         * 注意：
         * 1. 上面2个流合并后，下面不能再合并，会报IllegalStateException异常
         * 2. 上面进行forEach()终止操作后，下面也不能进行forEach()终止操作也会报IllegalStateException异常
         **/

        //把上述的合并流去重，要求字符串元素不能重复，并把结果输出
        concatStream.distinct().forEach(System.out::println);

    }
}
</code></pre> 
<p id="u9060b985"><strong>输出结果：</strong></p> 
<pre><code class="language-java">林青霞
王祖贤
张曼玉
张敏
钟丽缇
朱茵
莫文蔚

Process finished with exit code 0</code></pre> 
<p></p> 
<p><strong>案例二：</strong></p> 
<pre><code class="language-java">public class ExtractCombTest {
    public static void main(String[] args) {

        //流也可以进行合并、去重、限制、跳过等操作
        
        String[] arr1 = {"a", "b", "c", "d"};
        String[] arr2 = {"d", "e", "f", "g"};

        Stream&lt;String&gt; stream1 = Stream.of(arr1);
        Stream&lt;String&gt; stream2 = Stream.of(arr2);

        // concat:合并两个流 distinct：去重
        List&lt;String&gt; newList = Stream.concat(stream1, stream2).distinct().collect(Collectors.toList());

        // limit：限制从流中获得前n个数据 --从1开始，+2，无限迭代，取前10个元素
        List&lt;Integer&gt; collect = Stream.iterate(1, x -&gt; x + 2).limit(10).collect(Collectors.toList());

        // skip：跳过前n个数据 --从1开始，+2，无限迭代，跳过第1个元素，取前5个元素
        List&lt;Integer&gt; collect2 = Stream.iterate(1, x -&gt; x + 2).skip(1).limit(5).collect(Collectors.toList());

        System.out.println("流合并：" + newList);
        System.out.println("limit：" + collect);
        System.out.println("skip：" + collect2);
    }
}
</code></pre> 
<p></p> 
<p id="ud27e7319"><strong>输出结果：</strong></p> 
<pre><code>流合并：[a, b, c, d, e, f, g]
limit：[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
skip：[3, 5, 7, 9, 11]

Process finished with exit code 0</code></pre> 
<p></p> 
<p>部分内容借鉴于此：<a href="https://blog.csdn.net/mu_wind/article/details/109516995" title="(40条消息) Java8 Stream：2万字20个实例，玩转集合的筛选、归约、分组、聚合_云深不知处-CSDN博客_java stream 聚合">(40条消息) Java8 Stream：2万字20个实例，玩转集合的筛选、归约、分组、聚合_云深不知处-CSDN博客_java stream 聚合</a></p> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b7984329ef54a44117522e144eca0746/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">朋友创业2年，估值已达10亿，正招贤纳士，不错的机会</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/32c3e176e33d5b9988861099b2b5c3ba/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pyecharts如何给柱形图的每个柱子设置不同颜色</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>