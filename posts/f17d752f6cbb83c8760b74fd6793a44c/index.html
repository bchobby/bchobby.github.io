<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>进化算法——多目标优化 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="进化算法——多目标优化" />
<meta property="og:description" content="所有的实际优化问题都是多目标的，如果不是显式的至少也是隐式的。接下来讨论多目标优化问题（MOP）如何修改进化算法。实际的优化问题包含多个目标，那些目标常常互相冲突。例如：
在购买汽车时，我们可能想要车最舒适并且花钱最少。最舒适的汽车太贵，最便宜的汽车又不太舒服。在设计一座桥时，我们可能想让它的费用最低强度最大。用泡沫塑料建造的桥可能费用最低，但他非常脆弱。用钛合金建造的桥可能强度最大但它非常昂贵，在费用和强度之间如何才是最好的折中？ MOP又被称为多准则优化、多性能优化，以及向量优化。假定独立变量x为n维向量，并假定MOP是最小化问题。MOP可以写成如下的形式：
MOP的目标是同时最小化k个函数。
MOP常常包含约束，我们不处理带约束的MOP。我们可以将约束融入多目标进化算（MOEAs），其方式与将约束融入单目标进化算法相同。
目录
帕累托最优性
​支配
多目标优化的目标
1.超体积
2.相对覆盖度
基于非帕累托的进化算法
1.集结方法
凹帕累托前沿的目标达成
2.向量评价遗传算法
3.字典排序
4.​-约束方法
5.基于性别的方法
基于帕累托进化算法
1.多目标进化优化器
a.简单多目标进化优化器（simple evolutionary multi-objective optimizer，SEMO）
b.多样性多目标进化优化器（divercity evolutionary multi-objective optimizer，DEMO） 2.基于​的多目标进化算法
3.非支配排序遗传算法NSGA
NSGAⅡ
4.多目标遗传算法 5.小生境帕累托遗传算法NPGA
6.优势帕累托进化算法SPEA
SPEA2
7.帕累托归档进化策略PAES
基于生物地理学的多目标优化
1.向量评价BBO
2.非支配排序BBO
3.小生境帕累托BBO
4.优势帕累托BBO
帕累托最优性 我们首先列出在多目标优化中经常用到的一些定义。
1.支配。称点支配x如果下面的两个条件成立：（1）对所有i∈[1,k]，并且（2）对至少一个j∈[1,k]，＜，即对所有目标函数值，至少与x一样好，并且至少有一个目标函数值比x好，用记号
表示支配x，符号表示的函数值小于或等于x的函数值。
2.弱支配。 称点弱支配x如果对所有i∈[1,k]，，即对所有目标函数值，至少与x一样好，如果支配x，它也弱支配x。 如果对所有i∈[1,k]，=， 则与x互相弱支配。用记号
表示 弱支配x。
3.非支配。 称点是非支配的，如果不存在能支配它的x。非劣、允许的，以及有效的，都是非支配的同义词。
4.帕累托最优点。 帕累托最优点，也被称为帕累托点，是不受搜索空间中任意一点x支配的点。即，
5.帕累托最优集。也被称为帕累托集并记为，是所有非支配的的集合。
6.帕累托前沿。也被称为非支配集合，并记为，是相应于帕累托集的所有函数向量f(x)的集合。
注意，是非支配的并不意味着支配所有与不等的x。对所有i∈[1,k]，可能会有 = ，在这种情况下x和互相都是非支配的，其中一个不会支配另一个。还可能出现的情况是，以有两个目标的问题为例，其中并且。在这种情况下x和都是非支配的，其中一个不会支配另一个。
支配 帕累托集这个概念的局限在于它的非此即彼，非黑即白的性质。例如，考虑下面三个费用函数值的集合：
x支配y和z，但是帕累托支配的概念并不考虑支配水平之间的差别，也不会识别在目标函数空间中相互靠的很近的两个候选解。在（11）式中，x支配y，但是因为x和y很相似，相互之间几乎都是非支配的。实际上，差不多也可以说y支配z。由此引出了支配的概念。
加性支配： 称点加性支配x，如果对某个＞0和所有i∈[1,k]， ＜ &#43;。也就是说， “接近”支配x，这里的“接近”有加性参数来量化。乘性支配： 称点乘性支配x，如果对某个＞0和所有i∈[1,k], ＜ &#43;(1&#43;)。也就是说， “接近”支配x，这里的“接近”有乘性参数来量化。 我们用记号" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/f17d752f6cbb83c8760b74fd6793a44c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-18T10:41:13+08:00" />
<meta property="article:modified_time" content="2022-04-18T10:41:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">进化算法——多目标优化</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>所有的实际优化问题都是多目标的，如果不是显式的至少也是隐式的。接下来讨论多目标优化问题（MOP）如何修改进化算法。实际的优化问题包含多个目标，那些目标常常互相冲突。例如：</p> 
<ul><li>在购买汽车时，我们可能想要车最舒适并且花钱最少。最舒适的汽车太贵，最便宜的汽车又不太舒服。</li><li>在设计一座桥时，我们可能想让它的费用最低强度最大。用泡沫塑料建造的桥可能费用最低，但他非常脆弱。用钛合金建造的桥可能强度最大但它非常昂贵，在费用和强度之间如何才是最好的折中？</li></ul> 
<p>MOP又被称为多准则优化、多性能优化，以及向量优化。假定独立变量x为n维向量，并假定MOP是最小化问题。MOP可以写成如下的形式：</p> 
<p><img src="https://images2.imgbox.com/5b/96/euCbhsqb_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_15,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>MOP的目标是同时最小化k个函数<img class="mathcode" src="https://images2.imgbox.com/ff/09/66uYGaGq_o.png" alt="gif.latex?f_%7Bi%7D%28x%29">。</p> 
<p>MOP常常包含约束，我们不处理带约束的MOP。我们可以将约束融入多目标进化算（MOEAs），其方式与将约束融入单目标进化算法相同。</p> 
<hr> 
<p><strong>目录</strong></p> 
<p style="margin-left:0px;"><a href="#%E5%B8%95%E7%B4%AF%E6%89%98%E6%9C%80%E4%BC%98%E6%80%A7" rel="nofollow">帕累托最优性</a></p> 
<p style="margin-left:40px;"><a href="#%E2%80%8B%E6%94%AF%E9%85%8D" rel="nofollow">​支配</a></p> 
<p style="margin-left:0px;"><a href="#%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96%E7%9A%84%E7%9B%AE%E6%A0%87" rel="nofollow">多目标优化的目标</a></p> 
<p style="margin-left:40px;"><a href="#1.%E8%B6%85%E4%BD%93%E7%A7%AF" rel="nofollow">1.超体积</a></p> 
<p style="margin-left:40px;"><a href="#2.%E7%9B%B8%E5%AF%B9%E8%A6%86%E7%9B%96%E5%BA%A6" rel="nofollow">2.相对覆盖度</a></p> 
<p style="margin-left:0px;"><a href="#%E5%9F%BA%E4%BA%8E%E9%9D%9E%E5%B8%95%E7%B4%AF%E6%89%98%E7%9A%84%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95" rel="nofollow">基于非帕累托的进化算法</a></p> 
<p style="margin-left:40px;"><a href="#1.%E9%9B%86%E7%BB%93%E6%96%B9%E6%B3%95" rel="nofollow">1.集结方法</a></p> 
<p style="margin-left:80px;"><a href="#%C2%A0%E5%87%B9%E5%B8%95%E7%B4%AF%E6%89%98%E5%89%8D%E6%B2%BF%E7%9A%84%E7%9B%AE%E6%A0%87%E8%BE%BE%E6%88%90" rel="nofollow"> 凹帕累托前沿的目标达成</a></p> 
<p style="margin-left:40px;"><a href="#2.%E5%90%91%E9%87%8F%E8%AF%84%E4%BB%B7%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95" rel="nofollow">2.向量评价遗传算法</a></p> 
<p style="margin-left:40px;"><a href="#3.%E5%AD%97%E5%85%B8%E6%8E%92%E5%BA%8F" rel="nofollow">3.字典排序</a></p> 
<p style="margin-left:40px;"><a href="#%C2%A04.%E2%80%8B-%E7%BA%A6%E6%9D%9F%E6%96%B9%E6%B3%95" rel="nofollow"> 4.​-约束方法</a></p> 
<p style="margin-left:40px;"><a href="#%C2%A05.%E5%9F%BA%E4%BA%8E%E6%80%A7%E5%88%AB%E7%9A%84%E6%96%B9%E6%B3%95" rel="nofollow"> 5.基于性别的方法</a></p> 
<p style="margin-left:0px;"><a href="#%E5%9F%BA%E4%BA%8E%E5%B8%95%E7%B4%AF%E6%89%98%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95" rel="nofollow">基于帕累托进化算法</a></p> 
<p style="margin-left:40px;"><a href="#1.%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%BF%9B%E5%8C%96%E4%BC%98%E5%8C%96%E5%99%A8" rel="nofollow">1.多目标进化优化器</a></p> 
<p style="margin-left:80px;"><a href="#a.%E7%AE%80%E5%8D%95%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%BF%9B%E5%8C%96%E4%BC%98%E5%8C%96%E5%99%A8%EF%BC%88simple%20evolutionary%20multi-objective%20optimizer%EF%BC%8CSEMO%EF%BC%89" rel="nofollow">a.简单多目标进化优化器（simple evolutionary multi-objective optimizer，SEMO）</a></p> 
<p style="margin-left:80px;"><a href="#b.%E5%A4%9A%E6%A0%B7%E6%80%A7%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%BF%9B%E5%8C%96%E4%BC%98%E5%8C%96%E5%99%A8%EF%BC%88divercity%20evolutionary%20multi-objective%20optimizer%EF%BC%8CDEMO%EF%BC%89%C2%A0" rel="nofollow">b.多样性多目标进化优化器（divercity evolutionary multi-objective optimizer，DEMO） </a></p> 
<p style="margin-left:40px;"><a href="#2.%E5%9F%BA%E4%BA%8E%E2%80%8B%E7%9A%84%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95" rel="nofollow">2.基于​的多目标进化算法</a></p> 
<p style="margin-left:40px;"><a href="#3.%E9%9D%9E%E6%94%AF%E9%85%8D%E6%8E%92%E5%BA%8F%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95NSGA" rel="nofollow">3.非支配排序遗传算法NSGA</a></p> 
<p style="margin-left:80px;"><a href="#NSGA%E2%85%A1" rel="nofollow">NSGAⅡ</a></p> 
<p style="margin-left:40px;"><a href="#4.%E5%A4%9A%E7%9B%AE%E6%A0%87%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%C2%A0" rel="nofollow">4.多目标遗传算法 </a></p> 
<p style="margin-left:40px;"><a href="#5.%E5%B0%8F%E7%94%9F%E5%A2%83%E5%B8%95%E7%B4%AF%E6%89%98%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95NPGA" rel="nofollow">5.小生境帕累托遗传算法NPGA</a></p> 
<p style="margin-left:40px;"><a href="#6.%E4%BC%98%E5%8A%BF%E5%B8%95%E7%B4%AF%E6%89%98%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95SPEA" rel="nofollow">6.优势帕累托进化算法SPEA</a></p> 
<p style="margin-left:80px;"><a href="#SPEA2" rel="nofollow">SPEA2</a></p> 
<p style="margin-left:40px;"><a href="#7.%E5%B8%95%E7%B4%AF%E6%89%98%E5%BD%92%E6%A1%A3%E8%BF%9B%E5%8C%96%E7%AD%96%E7%95%A5PAES" rel="nofollow">7.帕累托归档进化策略PAES</a></p> 
<p style="margin-left:0px;"><a href="#%E5%9F%BA%E4%BA%8E%E7%94%9F%E7%89%A9%E5%9C%B0%E7%90%86%E5%AD%A6%E7%9A%84%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96" rel="nofollow">基于生物地理学的多目标优化</a></p> 
<p style="margin-left:40px;"><a href="#1.%E5%90%91%E9%87%8F%E8%AF%84%E4%BB%B7BBO" rel="nofollow">1.向量评价BBO</a></p> 
<p style="margin-left:40px;"><a href="#2.%E9%9D%9E%E6%94%AF%E9%85%8D%E6%8E%92%E5%BA%8FBBO" rel="nofollow">2.非支配排序BBO</a></p> 
<p style="margin-left:40px;"><a href="#3.%E5%B0%8F%E7%94%9F%E5%A2%83%E5%B8%95%E7%B4%AF%E6%89%98BBO" rel="nofollow">3.小生境帕累托BBO</a></p> 
<p style="margin-left:40px;"><a href="#4.%E4%BC%98%E5%8A%BF%E5%B8%95%E7%B4%AF%E6%89%98BBO" rel="nofollow">4.优势帕累托BBO</a></p> 
<hr> 
<p> </p> 
<h2>帕累托最优性</h2> 
<p>我们首先列出在多目标优化中经常用到的一些定义。</p> 
<p><strong>1.支配</strong>。称点<img class="mathcode" src="https://images2.imgbox.com/b0/4d/eDOD8aYp_o.png" alt="gif.latex?x%5E%7B*%7D">支配x如果下面的两个条件成立：（1）对所有i∈[1,k]，<img class="mathcode" src="https://images2.imgbox.com/a9/fe/cdhYV0FM_o.png" alt="gif.latex?f_%7Bi%7D%28x%5E%7B*%7D%29"><img class="mathcode" src="https://images2.imgbox.com/e9/bb/lKydo8W1_o.png" alt="gif.latex?%5Cleq"><img class="mathcode" src="https://images2.imgbox.com/d0/a0/hOYm6wyT_o.png" alt="gif.latex?f_%7Bi%7D%28x%29">并且（2）对至少一个j∈[1,k]，<img class="mathcode" src="https://images2.imgbox.com/8d/68/4DOQRcTc_o.png" alt="gif.latex?f_%7Bi%7D%28x%5E%7B*%7D%29">＜<img class="mathcode" src="https://images2.imgbox.com/1d/b2/fPFTqY0r_o.png" alt="gif.latex?f_%7Bi%7D%28x%29">，即对所有目标函数值，<img class="mathcode" src="https://images2.imgbox.com/e5/ee/oszzw2mv_o.png" alt="gif.latex?x%5E%7B*%7D">至少与x一样好，并且<img class="mathcode" src="https://images2.imgbox.com/04/40/CuNH6nEL_o.png" alt="gif.latex?x%5E%7B*%7D">至少有一个目标函数值比x好，用记号</p> 
<p><img src="https://images2.imgbox.com/bd/38/IicOsdo7_o.png" alt="6d035caf99be43619a1e6deb773887e6.png"></p> 
<p>表示<img class="mathcode" src="https://images2.imgbox.com/6c/79/1FWfl2Wm_o.png" alt="gif.latex?x%5E%7B*%7D">支配x，符号<img class="mathcode" src="https://images2.imgbox.com/ec/1c/luKVziZn_o.png" alt="gif.latex?%5Csucc">表示<img class="mathcode" src="https://images2.imgbox.com/f4/3b/93VfhuZy_o.png" alt="gif.latex?x%5E%7B*%7D">的函数值小于或等于x的函数值。</p> 
<p><strong>2.弱支配</strong>。 称点<img class="mathcode" src="https://images2.imgbox.com/6e/76/QTrUnRP3_o.png" alt="gif.latex?x%5E%7B*%7D">弱支配x如果对所有i∈[1,k]，<img class="mathcode" src="https://images2.imgbox.com/62/e4/JLRVfBcG_o.png" alt="gif.latex?f_%7Bi%7D%28x%5E%7B*%7D%29"><img class="mathcode" src="https://images2.imgbox.com/d2/f1/MeicMSEY_o.png" alt="gif.latex?%5Cleq"><img class="mathcode" src="https://images2.imgbox.com/1c/90/17wTqTdN_o.png" alt="gif.latex?f_%7Bi%7D%28x%29">，即对所有目标函数值，<img class="mathcode" src="https://images2.imgbox.com/7a/0d/qZhRukVr_o.png" alt="gif.latex?x%5E%7B*%7D">至少与x一样好，如果<img class="mathcode" src="https://images2.imgbox.com/cb/de/kTPRiBrE_o.png" alt="gif.latex?x%5E%7B*%7D">支配x，它也弱支配x。 如果对所有i∈[1,k]，<img class="mathcode" src="https://images2.imgbox.com/fb/fe/WTNZHDrp_o.png" alt="gif.latex?f_%7Bi%7D%28x%5E%7B*%7D%29">=<img class="mathcode" src="https://images2.imgbox.com/91/9e/VIRMNARx_o.png" alt="gif.latex?f_%7Bi%7D%28x%29">， 则<img class="mathcode" src="https://images2.imgbox.com/0a/be/KsNi2q3C_o.png" alt="gif.latex?x%5E%7B*%7D">与x互相弱支配。用记号</p> 
<p><img src="https://images2.imgbox.com/3c/af/cNBr0v1s_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_9,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>表示 <img class="mathcode" src="https://images2.imgbox.com/b2/d6/FWpK33Np_o.png" alt="gif.latex?x%5E%7B*%7D">弱支配x。</p> 
<p><strong>3.非支配</strong>。 称点<img class="mathcode" src="https://images2.imgbox.com/b2/45/9bYww3PF_o.png" alt="gif.latex?x%5E%7B*%7D">是非支配的，如果不存在能<strong>支配</strong>它的x。非劣、允许的，以及有效的，都是非支配的同义词。</p> 
<p><strong>4.帕累托最优点</strong>。 帕累托最优点<img class="mathcode" src="https://images2.imgbox.com/5e/80/8zb31NXq_o.png" alt="gif.latex?x%5E%7B*%7D">，也被称为帕累托点，是不受搜索空间中任意一点x支配的点。即，</p> 
<p><img src="https://images2.imgbox.com/f6/c1/7HjOyTXc_o.png" alt="1a243a6ab03744398614263f39fb08f4.png?x-oss-process=image,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_20,color_FFFFFF,t_70,g_se,x_16"></p> 
<p><strong>5.帕累托最优集</strong>。也被称为帕累托集并记为<img class="mathcode" src="https://images2.imgbox.com/c7/e5/NylmZJiO_o.png" alt="gif.latex?P_%7Bs%7D">，是所有非支配的<img class="mathcode" src="https://images2.imgbox.com/00/8f/YGUulx4Q_o.png" alt="gif.latex?x%5E%7B*%7D">的集合。</p> 
<p><img src="https://images2.imgbox.com/9e/bf/xwIXAe3v_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_16,color_FFFFFF,t_70,g_se,x_16"></p> 
<p><strong>6.帕累托前沿</strong>。也被称为非支配集合，并记为<img class="mathcode" src="https://images2.imgbox.com/33/3e/usBExeK3_o.png" alt="gif.latex?P_%7Bf%7D">，是相应于帕累托集的所有函数向量f(x)的集合。</p> 
<p><img src="https://images2.imgbox.com/21/6a/JOpMgQFQ_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_12,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>注意，<img class="mathcode" src="https://images2.imgbox.com/94/00/toLccPHc_o.png" alt="gif.latex?x%5E%7B*%7D">是非支配的并不意味着<img class="mathcode" src="https://images2.imgbox.com/ff/79/EHU0q8f1_o.png" alt="gif.latex?x%5E%7B*%7D">支配所有与<img class="mathcode" src="https://images2.imgbox.com/b4/e3/kwFVYjh1_o.png" alt="gif.latex?x%5E%7B*%7D">不等的x。对所有i∈[1,k]，可能会有 <img class="mathcode" src="https://images2.imgbox.com/16/7e/vh6TPbDI_o.png" alt="gif.latex?f_%7Bi%7D%28x%5E%7B*%7D%29">=<img class="mathcode" src="https://images2.imgbox.com/2a/83/S6GodqDL_o.png" alt="gif.latex?f_%7Bi%7D%28x%29"> ，在这种情况下x和<img class="mathcode" src="https://images2.imgbox.com/f8/7a/zDlpyIT5_o.png" alt="gif.latex?x%5E%7B*%7D">互相都是非支配的，其中一个不会支配另一个。还可能出现的情况是，以有两个目标的问题为例，其中<img class="mathcode" src="https://images2.imgbox.com/cf/31/UzGnKHnL_o.png" alt="gif.latex?f_%7B1%7D%28x%29%3C%20f_%7B1%7D%28x%5E%7B*%7D%29">并且<img class="mathcode" src="https://images2.imgbox.com/e1/8d/PiOnpZKA_o.png" alt="gif.latex?f_%7B2%7D%28x%29%3Ef%20_%7B2%7D%28x%5E%7B*%7D%29">。在这种情况下x和<img class="mathcode" src="https://images2.imgbox.com/f6/fa/jKcrZqrP_o.png" alt="gif.latex?x%5E%7B*%7D">都是非支配的，其中一个不会支配另一个。</p> 
<h3><img class="mathcode" src="https://images2.imgbox.com/b3/4a/UOESybpQ_o.png" alt="gif.latex?%5Cepsilon">支配</h3> 
<p>帕累托集这个概念的局限在于它的非此即彼，非黑即白的性质。例如，考虑下面三个费用函数值的集合：</p> 
<p><img src="https://images2.imgbox.com/a4/e4/j62gOjAx_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_12,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>x支配y和z，但是帕累托支配的概念并不考虑支配水平之间的差别，也不会识别在目标函数空间中相互靠的很近的两个候选解。在（11）式中，x支配y，但是因为x和y很相似，相互之间几乎都是非支配的。实际上，差不多也可以说y支配z。由此引出了<strong><img class="mathcode" src="https://images2.imgbox.com/35/c2/1I3MytO1_o.png" alt="gif.latex?%5Cepsilon">支配</strong>的概念。</p> 
<ol><li>加性<img class="mathcode" src="https://images2.imgbox.com/99/72/wDTjg9aO_o.png" alt="gif.latex?%5Cepsilon">支配： 称点<img class="mathcode" src="https://images2.imgbox.com/ce/df/fRS0PUjL_o.png" alt="gif.latex?x%5E%7B*%7D">加性<img class="mathcode" src="https://images2.imgbox.com/11/5b/f9kk26fo_o.png" alt="gif.latex?%5Cepsilon">支配x，如果对某个<img class="mathcode" src="https://images2.imgbox.com/d2/3f/RPykl6pf_o.png" alt="gif.latex?%5Cepsilon">＞0和所有i∈[1,k]， <img class="mathcode" src="https://images2.imgbox.com/0c/bc/MFFy3Tj9_o.png" alt="gif.latex?f_%7Bi%7D%28x%5E%7B*%7D%29">＜<img class="mathcode" src="https://images2.imgbox.com/36/72/MpeixbQW_o.png" alt="gif.latex?f_%7Bi%7D%28x%29"> +<img class="mathcode" src="https://images2.imgbox.com/4d/78/h8duaXHa_o.png" alt="gif.latex?%5Cepsilon">。也就是说， <img class="mathcode" src="https://images2.imgbox.com/ef/4b/xKaDB51d_o.png" alt="gif.latex?x%5E%7B*%7D">“接近”支配x，这里的“接近”有加性参数<img class="mathcode" src="https://images2.imgbox.com/ba/13/O6NggWB4_o.png" alt="gif.latex?%5Cepsilon">来量化。</li><li>乘性<img class="mathcode" src="https://images2.imgbox.com/27/de/ADcXGk7Y_o.png" alt="gif.latex?%5Cepsilon">支配： 称点<img class="mathcode" src="https://images2.imgbox.com/00/a9/jNH4baBS_o.png" alt="gif.latex?x%5E%7B*%7D">乘性<img class="mathcode" src="https://images2.imgbox.com/a2/ef/tp0CTsLu_o.png" alt="gif.latex?%5Cepsilon">支配x，如果对某个<img class="mathcode" src="https://images2.imgbox.com/03/20/7IVOKdMD_o.png" alt="gif.latex?%5Cepsilon">＞0和所有i∈[1,k], <img class="mathcode" src="https://images2.imgbox.com/bc/bf/qNlyIMIv_o.png" alt="gif.latex?f_%7Bi%7D%28x%5E%7B*%7D%29">＜<img class="mathcode" src="https://images2.imgbox.com/1e/6b/K8YQA2k9_o.png" alt="gif.latex?f_%7Bi%7D%28x%29"> +(1+<img class="mathcode" src="https://images2.imgbox.com/06/f1/7wXW8GMB_o.png" alt="gif.latex?%5Cepsilon">)。也就是说， <img class="mathcode" src="https://images2.imgbox.com/58/2b/xDnWwYdK_o.png" alt="gif.latex?x%5E%7B*%7D">“接近”支配x，这里的“接近”有乘性参数<img class="mathcode" src="https://images2.imgbox.com/19/4c/hV0n9fPU_o.png" alt="gif.latex?%5Cepsilon">来量化。</li></ol> 
<p>我们用记号</p> 
<p><img src="https://images2.imgbox.com/cc/57/MzgWSMM1_o.png" alt="8811ec9b76e0451c99d1758f85ce0ae0.png"></p> 
<p>表示 <img class="mathcode" src="https://images2.imgbox.com/f8/a4/ioqA97H2_o.png" alt="gif.latex?x%5E%7B*%7D"><img class="mathcode" src="https://images2.imgbox.com/c3/cf/SjWpJqX3_o.png" alt="gif.latex?%5Cepsilon">支配x，注意，如果<img class="mathcode" src="https://images2.imgbox.com/5e/6e/Gyb6yU7y_o.png" alt="gif.latex?%5Cepsilon">=0，则<img class="mathcode" src="https://images2.imgbox.com/fe/ba/gGxGAKbP_o.png" alt="gif.latex?%5Cepsilon">支配等价于弱支配。</p> 
<p><img src="https://images2.imgbox.com/b0/27/jMZ89tc1_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_13,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>注意，对于<img class="mathcode" src="https://images2.imgbox.com/db/ab/0qxuoent_o.png" alt="gif.latex?%5Cepsilon">＞0，<img class="mathcode" src="https://images2.imgbox.com/27/3b/nIIaPhPb_o.png" alt="gif.latex?%5Cepsilon">支配是比弱支配更弱的支配，也就是说，如果 <img class="mathcode" src="https://images2.imgbox.com/1c/18/cteD9kA4_o.png" alt="gif.latex?x%5E%7B*%7D">弱支配x，则对<img class="mathcode" src="https://images2.imgbox.com/ef/61/wlWeKG7G_o.png" alt="gif.latex?%5Cepsilon">＞0， <img class="mathcode" src="https://images2.imgbox.com/eb/45/ycTODpD5_o.png" alt="gif.latex?x%5E%7B*%7D">也<img class="mathcode" src="https://images2.imgbox.com/95/4e/tic28EAs_o.png" alt="gif.latex?%5Cepsilon">支配x。反之，如果对某个<img class="mathcode" src="https://images2.imgbox.com/ef/01/3I087PeR_o.png" alt="gif.latex?%5Cepsilon">＞0， <img class="mathcode" src="https://images2.imgbox.com/1a/f5/duibhYvj_o.png" alt="gif.latex?x%5E%7B*%7D"><img class="mathcode" src="https://images2.imgbox.com/d1/96/YrFyTCJD_o.png" alt="gif.latex?%5Cepsilon">支配x，则 <img class="mathcode" src="https://images2.imgbox.com/69/12/9BOShMkt_o.png" alt="gif.latex?x%5E%7B*%7D">可能弱支配x，可能不能弱支配x：</p> 
<p><img src="https://images2.imgbox.com/9f/24/zRV7T6FS_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_14,color_FFFFFF,t_70,g_se,x_16"></p> 
<hr> 
<h2>多目标优化的目标</h2> 
<p>MOEA可能的一些目标如下：</p> 
<ol><li>在与真实帕累托集的<strong>某个距离之内</strong>找到最多个体；</li><li>MOEA的<strong>近似帕累托集</strong>与真实帕累托集之间的平均距离；</li><li>在近似帕累托集中找到最具<strong>多样性的个体</strong>；</li><li>目标函数空间中候选解到<strong>理想点</strong>，也称为乌托邦点的<strong>距离最小</strong>。</li></ol> 
<p>目标1和2是要找出真实帕累托集的“最好的”近似，目标3是要找出解的多样化集合，以便让决策者有足够的资源做出明智的决定。与其他目标不同，目标4是要找出与决策者的理想解尽可能接近的解。</p> 
<p>目标1和2假定我们一开始就知道真实帕累托集。如果知道真实的帕累托集<img class="mathcode" src="https://images2.imgbox.com/12/e8/hWshxycN_o.png" alt="gif.latex?P_%7Bs%7D">，并且MOEA给出一个近似的帕累托集<img class="mathcode" src="https://images2.imgbox.com/e7/d0/TaaWnsCy_o.png" alt="gif.latex?%5Chat%7BP_%7Bs%7D%7D">，可以计算它们之间的平均距离M(<img class="mathcode" src="https://images2.imgbox.com/c6/e7/B3IkOcvn_o.png" alt="gif.latex?P_%7Bs%7D">，<img class="mathcode" src="https://images2.imgbox.com/19/a5/rc1IeAVE_o.png" alt="gif.latex?%5Chat%7BP_%7Bs%7D%7D">)</p> 
<p><img src="https://images2.imgbox.com/37/68/203HT5LU_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_15,color_FFFFFF,t_70,g_se,x_16"></p> 
<p> 其中||·||是用户指定的距离测度。</p> 
<p>可以用几种不同的方式度量目标3。首先，可以度量每一个个体与近似帕累托集中离他最近的邻居的平均距离；其次，可以度量在近似帕累托集中两个末端的个体之间的距离；最后，可以计算在帕累托集中与每个元素距离大于某个阈值的个数的平均</p> 
<p><img src="https://images2.imgbox.com/0e/e0/vT8bJNOi_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_15,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>其中，<img class="mathcode" src="https://images2.imgbox.com/4f/8e/fvhN85WX_o.png" alt="gif.latex?%5Csigma">是用户指定的距离。一般来说，<img class="mathcode" src="https://images2.imgbox.com/d2/b8/nuLDlG6B_o.png" alt="gif.latex?M_%7B2%7D">随着<img class="mathcode" src="https://images2.imgbox.com/fa/46/bnjwPI81_o.png" alt="gif.latex?%5Chat%7BP_%7Bs%7D%7D">中元素的个数的增加而增大，也随着<img class="mathcode" src="https://images2.imgbox.com/cb/a2/fyBJpGbT_o.png" alt="gif.latex?%5Chat%7BP_%7Bs%7D%7D">中元素多样性的增加而增大。</p> 
<p>目标4被称为目标向量优化，目标达到，或目标规划。我们通常使用欧氏距离<img class="mathcode" src="https://images2.imgbox.com/c2/45/AJ9TSuAN_o.png" alt="gif.latex?D_%7B2%7D">度量目标函数向量f和理想点<img class="mathcode" src="https://images2.imgbox.com/44/67/3lVCsEnL_o.png" alt="gif.latex?f%5E%7B*%7D">之间的距离，欧氏距离<img class="mathcode" src="https://images2.imgbox.com/de/a3/vjKenk4O_o.png" alt="gif.latex?D_%7B2%7D">也被称为二范数距离。f和<img class="mathcode" src="https://images2.imgbox.com/65/6c/szJ79qkJ_o.png" alt="gif.latex?f%5E%7B*%7D">之间的距离定义如下：</p> 
<p><img src="https://images2.imgbox.com/6c/a7/rCdTxDpM_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_18,color_FFFFFF,t_70,g_se,x_16"></p> 
<p> 也可以使用其他距离，如加权二范数，一范数，或无穷范数。</p> 
<h3>1.超体积</h3> 
<p> 常用的度量帕累托前沿质量的另一个指标是它的超体积。假设MOEA在近似帕累托前沿中找到M个点<img class="mathcode" src="https://images2.imgbox.com/3d/a7/Hjl6bjVM_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D">={<!-- --><img class="mathcode" src="https://images2.imgbox.com/32/39/HgPGGQLe_o.png" alt="gif.latex?f%28x_%7Bj%7D%29">}，j∈[1,M]，其中<img class="mathcode" src="https://images2.imgbox.com/4d/99/WWLiElug_o.png" alt="gif.latex?f%28x_%7Bj%7D%29">是一个k维函数。超体积为</p> 
<p><img src="https://images2.imgbox.com/47/33/AkMY1NFu_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_11,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>对于最小化问题，超体积越小表明帕累托前沿的近似也越好。</p> 
<p> 假设有两个MOEA，它们都被用来近似一个有两个目标的最小化问题的帕累托前沿。下图所示为它们的近似帕累托前沿。图a的近似点为</p> 
<p><img src="https://images2.imgbox.com/c8/b2/xWfEVEWr_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_15,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>其超体积为1×5+2×3+5×1=16。图b的近似点为</p> 
<p><img src="https://images2.imgbox.com/ce/f2/sF4TMMov_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_15,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>其超体积为1×4+3×3+4×1=17.图a中的<img class="mathcode" src="https://images2.imgbox.com/c4/42/sJ3fNumi_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D">比图b中的<img class="mathcode" src="https://images2.imgbox.com/d6/9e/xpz7kmIf_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D">稍好。 </p> 
<p><img src="https://images2.imgbox.com/81/8a/zvnd93zL_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_13,color_FFFFFF,t_70,g_se,x_16"></p> 
<p> 不能盲目的将超体积作为衡量帕累托前沿质量的指标。（18）式说明一个空的近似帕累托前沿（M=0）得到S可能的最小值。因此，更精确的度量可能是正规化之后的超体积<img class="mathcode" src="https://images2.imgbox.com/d7/90/E4zGxU83_o.png" alt="gif.latex?S_%7Bn%7D%28%5Chat%7BP_%7Bf%7D%7D%29">=<img class="mathcode" src="https://images2.imgbox.com/61/7f/EXWi6WVU_o.png" alt="gif.latex?S%28%5Chat%7BP_%7Bf%7D%7D%29">/M。但这个量也可能不是近似帕累托前沿的好指标。考虑某个近似帕累托前沿<img class="mathcode" src="https://images2.imgbox.com/84/04/fVUlqiMU_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D%281%29">，其正规化后的超体积<img class="mathcode" src="https://images2.imgbox.com/9f/59/9991bIRe_o.png" alt="gif.latex?S_%7Bn%7D%28%5Chat%7BP_%7Bf%7D%7D%281%29%29">。现在假设添加一个新的点到<img class="mathcode" src="https://images2.imgbox.com/d2/be/Ki6OQSBC_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D%281%29">中得到<img class="mathcode" src="https://images2.imgbox.com/bd/10/k4t50YxM_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D%282%29">。于是有可能让<img class="mathcode" src="https://images2.imgbox.com/dc/29/nTv38s6z_o.png" alt="gif.latex?S_%7Bn%7D%28%5Chat%7BP_%7Bf%7D%7D%282%29%29">＞<img class="mathcode" src="https://images2.imgbox.com/be/11/JB1vDLsn_o.png" alt="gif.latex?S_%7Bn%7D%28%5Chat%7BP_%7Bf%7D%7D%281%29%29">。尽管<img class="mathcode" src="https://images2.imgbox.com/dc/81/3hdmm0Lh_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D%282%29">和<img class="mathcode" src="https://images2.imgbox.com/f2/69/bfRPLipo_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D%281%29">的唯一不同是，<img class="mathcode" src="https://images2.imgbox.com/b6/52/A0PN7p10_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D%282%29">比<img class="mathcode" src="https://images2.imgbox.com/cb/90/gowuKglB_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D%281%29">多了一个点。<img class="mathcode" src="https://images2.imgbox.com/a2/fd/zO1PXpDu_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D%282%29">显然比<img class="mathcode" src="https://images2.imgbox.com/b8/24/kS8a24BL_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D%281%29">好，但 <img class="mathcode" src="https://images2.imgbox.com/50/45/8A6IlgAR_o.png" alt="gif.latex?S_%7Bn%7D%28%5Chat%7BP_%7Bf%7D%7D%282%29%29">＞<img class="mathcode" src="https://images2.imgbox.com/7a/1f/MtidXhPh_o.png" alt="gif.latex?S_%7Bn%7D%28%5Chat%7BP_%7Bf%7D%7D%281%29%29"> 与我们的直觉不符。 </p> 
<p>因此我们得修改超体积这个测度，不是关于目标函数空间的原点来计算超体积，而是关于帕累托前沿之外的参考点来计算。假设要比较Q个帕累托前沿近似<img class="mathcode" src="https://images2.imgbox.com/b8/70/SbvWTAEc_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D%28q%29">，q∈[1,Q]，首先计算参考点向量r=[<img class="mathcode" src="https://images2.imgbox.com/a1/1a/RSjSq48G_o.png" alt="gif.latex?r_%7B1%7D%2Cr_%7B2%7D%2C...r_%7Bk%7D">]，其中</p> 
<p><img src="https://images2.imgbox.com/b1/d2/2TJqp0e4_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_10,color_FFFFFF,t_70,g_se,x_16"></p> 
<p> 然后关于参考点计算超体积<img class="mathcode" src="https://images2.imgbox.com/cb/08/02jhDq4T_o.png" alt="gif.latex?%7BS%7D%27"></p> 
<p><img src="https://images2.imgbox.com/7d/23/BRnDf9wz_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_11,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>其中，M(q)是在第q个近似帕累托前沿中点的个数，<img class="mathcode" src="https://images2.imgbox.com/7f/d8/ddodNMeD_o.png" alt="gif.latex?x_%7Bj%7D%28q%29">是在第q个近似帕累托集中第j个点。参考点超体积S’较大表示最小化问题的帕累托前沿较好。我们可以采用正规化后的参考点超体积</p> 
<p><img src="https://images2.imgbox.com/52/c4/Yl1csNqG_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_10,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>如果要将帕累托点的个数也纳入指标中，也可以采用总的参考点超体积<img class="mathcode" src="https://images2.imgbox.com/d4/6e/xHoelTsr_o.png" alt="gif.latex?%7BS%7D%27%28%5Chat%7BP_%7Bf%7D%7D%28q%29%29">。</p> 
<h3>2.相对覆盖度</h3> 
<p>比较近似帕累托前沿的另一种方式是计算在一个近似中的个体被另一个近似中至少一个个体弱支配的平均个数。假设两个<img class="mathcode" src="https://images2.imgbox.com/15/55/8zRUjK1M_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D">近似记为 <img class="mathcode" src="https://images2.imgbox.com/03/5a/ScV7csdX_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D%281%29">和<img class="mathcode" src="https://images2.imgbox.com/17/14/yRZO0K7t_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D%282%29"> 。定义 <img class="mathcode" src="https://images2.imgbox.com/14/0e/XEvqreV5_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D%281%29">相对于 <img class="mathcode" src="https://images2.imgbox.com/24/e0/mmgXF1m0_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D%282%29">中个体被 <img class="mathcode" src="https://images2.imgbox.com/6c/23/apmooY1W_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D%281%29">中至少一个个体弱支配的平均个数：</p> 
<p><img src="https://images2.imgbox.com/0b/32/sCwKN0Oc_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_17,color_FFFFFF,t_70,g_se,x_16"></p> 
<p> </p> 
<p>注意，<img class="mathcode" src="https://images2.imgbox.com/94/3e/dXUiTO0P_o.png" alt="gif.latex?C%28%5Chat%7BP_%7Bf%7D%7D%281%29%2C%5Chat%7BP_%7Bf%7D%7D%282%29%29"><img class="mathcode" src="https://images2.imgbox.com/96/95/P1yLmt2Z_o.png" alt="gif.latex?%5Cin%20%5B0%2C1%5D">。如果<img class="mathcode" src="https://images2.imgbox.com/33/57/A2e6hAFe_o.png" alt="gif.latex?C%28%5Chat%7BP_%7Bf%7D%7D%281%29%2C%5Chat%7BP_%7Bf%7D%7D%282%29%29">=0，则对没一个个体a2∈ <img class="mathcode" src="https://images2.imgbox.com/a6/de/M6sfFwTd_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D%282%29"> ，在 <img class="mathcode" src="https://images2.imgbox.com/98/40/Vr7Asifv_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D%281%29"> 中没有个体弱支配a2。如果<img class="mathcode" src="https://images2.imgbox.com/db/f3/rZwWlx0q_o.png" alt="gif.latex?C%28%5Chat%7BP_%7Bf%7D%7D%281%29%2C%5Chat%7BP_%7Bf%7D%7D%282%29%29">=1，则对每一个个体a2∈ <img class="mathcode" src="https://images2.imgbox.com/73/00/E8t3xlQO_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D%282%29"> ，在 <img class="mathcode" src="https://images2.imgbox.com/ee/1c/CdHVUiRy_o.png" alt="gif.latex?%5Chat%7BP_%7Bf%7D%7D%281%29">中至少有一个个体弱支配a2。</p> 
<hr> 
<h2>基于非帕累托的进化算法</h2> 
<p>接下来讨论几种MOEA，它们并不显示的使用帕累托支配个概念。</p> 
<h3>1.集结方法</h3> 
<p>集结方法将MOP的目标函数向量组合成一个目标函数。例如，将（1）式中k个目标的MOP转换为问题</p> 
<p><img src="https://images2.imgbox.com/be/24/GAi8LKkp_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_13,color_FFFFFF,t_70,g_se,x_16"></p> 
<p><img class="mathcode" src="https://images2.imgbox.com/c5/14/LTrgzvSI_o.png" alt="gif.latex?%5Cleft%20%5C%7B%20%5Comega%20_%7Bi%7D%20%5Cright%20%5C%7D">是权重参数的集合，其元素都为正且总和为1。（25）式被称为加权和方法，但也可以采用其他的集结方法。例如，把目标组合成一个乘积：</p> 
<p><img src="https://images2.imgbox.com/a2/bb/bxXBHPO9_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_10,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>如果采用该方法，就应该确保对所有的x，目标<img class="mathcode" src="https://images2.imgbox.com/97/aa/Oy5lMrRG_o.png" alt="gif.latex?f%28x_%7Bi%7D%29"><img class="mathcode" src="https://images2.imgbox.com/01/4c/j8L37NXC_o.png" alt="gif.latex?%3E">0。无论用什么方法集结，其重点在于将MOP转化为单目标优化问题。</p> 
<p>如果帕累托前沿是凹的，集结方法就无法得到完整的帕累托前沿，我们用下面的例子来说明。</p> 
<p> 考虑问题</p> 
<p><img src="https://images2.imgbox.com/6e/d7/euDrZxcC_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_10,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>其中x∈[0,4]，这是一个一维两个目标的MOP，我们可以将两个目标集结成一个标量目标</p> 
<p><img src="https://images2.imgbox.com/b4/e5/T2bCD9OG_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_11,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>其中w∈[0,1]。下图为两个问题的解。我们知道帕累托前沿是凹的，集结方法正确地给出了帕累托前沿凸起的部分，但凹进的部分不正确。</p> 
<p><img src="https://images2.imgbox.com/2b/45/tSo5o1aC_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_13,color_FFFFFF,t_70,g_se,x_16"></p> 
<h4> 凹帕累托前沿的目标达成</h4> 
<p>有时候，通过七届下面的问题来近似目标达到：</p> 
<p><img src="https://images2.imgbox.com/a1/a3/CBxw3ub0_o.png" alt="2ea1a4b603f5473db23d32162110c858.png?x-oss-process=image,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_18,color_FFFFFF,t_70,g_se,x_16"></p> 
<p> 其中，<img class="mathcode" src="https://images2.imgbox.com/c6/55/88GQ52fG_o.png" alt="gif.latex?f_%7Bi%7D%5E%7B*%7D">是第i个目标的理想解，<img class="mathcode" src="https://images2.imgbox.com/8b/44/ZR0UlKYj_o.png" alt="gif.latex?%5Cleft%20%5C%7B%20%5Comega%20_%7Bi%7D%20%5Cright%20%5C%7D">是权重参数的集合，表示每个目标的相对重要性，每一个<img class="mathcode" src="https://images2.imgbox.com/17/92/vcGvJzvh_o.png" alt="gif.latex?%5Comega%20_%7Bi%7D">都是正数。（33）式允许比用户的理想解还好的解存在。如果最优的α＞0，则不能达到理想点，但（33）式的解是尽可能靠近理想点的向量解。如果最优的α＜0，对于每一个目标，就可以找到比理想解更好的解。</p> 
<h3>2.向量评价遗传算法</h3> 
<p>向量评价遗传算法VEGA是最早的MOEA。VEGA每次使用一个目标函数在种群中选择。它给出子种群的集合，每个目标函数一个集合。然后从子种群中选择个体得到下一代的父代，并利用标准进化算法的重组方法让父代组合得到子代。算法1为VEGA的概述。</p> 
<p><img src="https://images2.imgbox.com/76/55/7aAarWYl_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_19,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>算法1通常随机生成初始化种群。在每一代计算所有N个个体的全部k个费用函数值。然后用所需的选择方案选择M个个体，即子种群。我们根据概率来选择每个目标函数的子种群。再生成每个目标函数的子种群之后，将它们组合起来得到父代1种群P。然后将P中的个体重组生成子代集合C。可以采用任何一个进化算法进行重组。</p> 
<p>在单目标进化算法中实施精英能极大地改善算法性能。在算法1中实施精英的几种方式。例如，在每一代找到针对每一个目标函数的最好个体，并确保它们能留到下一代；或者可以在每一个直到非支配个体，确保其中至少能有几个保留到下一代。</p> 
<h3>3.字典排序</h3> 
<p>与VEGA类似，它允许用户对目标按优先级排序。基于优先级的目标对个体做比较执行锦标赛选择。锦标赛选择也可以基于随机的目标。</p> 
<p> 算法2概述了字典排序方法。在最初的字典排序方法中，最外层的循环按目标函数的优先级对i∈[1,k]执行。在它的随即便种中，则会一直执行直到满足用户定义的终止准则，并且在每一代指标i会随机的变化。</p> 
<p><img src="https://images2.imgbox.com/0a/53/9dDKa05I_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_18,color_FFFFFF,t_70,g_se,x_16"></p> 
<h3> 4.<img class="mathcode" src="https://images2.imgbox.com/71/2d/fcuyeqwc_o.png" alt="gif.latex?%5Cepsilon">-约束方法</h3> 
<p><img class="mathcode" src="https://images2.imgbox.com/76/80/PYXSz7M2_o.png" alt="gif.latex?%5Cepsilon">-约束方法每次最小化一个目标函数，同时将其他目标函数限制在给定的阈值内。首先，对于i∈[1,k]，通过单目标优化算法最小化<img class="mathcode" src="https://images2.imgbox.com/d7/cc/cTx7UDth_o.png" alt="gif.latex?f_%7Bi%7D%28x%29">找到目标函数的最小值。于是得到目标函数约束<img class="mathcode" src="https://images2.imgbox.com/04/48/vrqHesnj_o.png" alt="gif.latex?%5Cepsilon%20_%7Bi%7D">的下界：</p> 
<p><img src="https://images2.imgbox.com/1d/e1/53lluIlc_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_9,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>然后最小化第一个目标同时限制其他目标小于某个阈值：</p> 
<p><img src="https://images2.imgbox.com/4e/f5/KqzR0P2S_o.png" alt="d332ee1564324a86bcbecf56474db2e9.png?x-oss-process=image,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_13,color_FFFFFF,t_70,g_se,x_16"></p> 
<p> 由（35）式得到的最后的种群作为下一个进化算法的初始种群，最小化下一个目标：</p> 
<p><img src="https://images2.imgbox.com/ce/1c/SXl3UQE0_o.png" alt="48699e00dfec452ba72763bff5692016.png?x-oss-process=image,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_13,color_FFFFFF,t_70,g_se,x_16"></p> 
<p> 对所有k个目标重复这个过程，然后减小<img class="mathcode" src="https://images2.imgbox.com/24/61/sk2dT2EP_o.png" alt="gif.latex?%5Cepsilon%20_%7Bi%7D">值并重复顺序最小化的过程。算法3概述约束MOEA。在实施<img class="mathcode" src="https://images2.imgbox.com/20/80/ZoBGVZL7_o.png" alt="gif.latex?%5Cepsilon">-约束方法时，MOEA最具挑战的是算法3如何精确决定“设<img class="mathcode" src="https://images2.imgbox.com/31/28/7EKROnem_o.png" alt="gif.latex?%5Cepsilon%20_%7Bi%7D">为大于<img class="mathcode" src="https://images2.imgbox.com/ad/f2/3dMqoanB_o.png" alt="gif.latex?f_%7Bi%7D%5E%7B*%7D%28x%29">的某个数”以及如何“减小<img class="mathcode" src="https://images2.imgbox.com/4f/02/4o8zJp6t_o.png" alt="gif.latex?%5Cepsilon%20_%7Bi%7D">，i∈[1,k]”。</p> 
<p><img src="https://images2.imgbox.com/ea/af/RGEih93M_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_19,color_FFFFFF,t_70,g_se,x_16"></p> 
<h3> 5.基于性别的方法</h3> 
<p> 基于性别的方法根据对目标函数的评价为每一个个体的<strong>分配性别</strong>。基于性别的方法还利用被称为<strong>档案</strong>的第二种群。<strong>档案</strong>也是非支配个体的一个集合，与精英类似，他能避免丢失最好的个体。</p> 
<p>在k个目标MOP基于性别的方法中，有k个不同的性别，每一个相应于不同的目标。我们对每个个体生成数目相同的初始化种群，然后基于<img class="mathcode" src="https://images2.imgbox.com/29/0c/vbLMrWPC_o.png" alt="gif.latex?f_%7Bi%7D%28x%29">从每个性别i选择一个个体。再用选出的个体重组得到子代个体，按照子代表现得最好的目标为子代个体分配性别。在每一代的最后，通常将种群与档案比较并将非支配个体存入档案同时去掉档案中的被支配个体。算法4概述了多目标优化基于性别的方法。</p> 
<p><img src="https://images2.imgbox.com/85/de/JO3siW8R_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_19,color_FFFFFF,t_70,g_se,x_16"></p> 
<hr> 
<h2>基于帕累托进化算法</h2> 
<p>下面几节讨论直接使用帕累托支配的方法。</p> 
<h3>1.多目标进化优化器</h3> 
<h4>a.简单多目标进化优化器（simple evolutionary multi-objective optimizer，SEMO）</h4> 
<p>最初是为<strong>二进制优化</strong>提出的算法。在SEMO中，一开始我们随机生成个体中群。一开始的种群规模为1，随着算法找到越来越多的非支配解，种群也在长大。在每一代，我们从种群中随机选出一个个体，让它变异生成子代。如果这个子代不被种群支配，就将它加入种群中，并去掉种群中被支配的个体。算法5说明SEMO。</p> 
<p><img src="https://images2.imgbox.com/73/9b/4Lya3VaI_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_19,color_FFFFFF,t_70,g_se,x_16"></p> 
<h4>b.多样性多目标进化优化器（divercity evolutionary multi-objective optimizer，DEMO） </h4> 
<p>SEMO有一个问题是它的种群会不受限制的生长。我们可以在测试时候将y纳入种群P时采用<img class="mathcode" src="https://images2.imgbox.com/bf/b6/2YPXpiGW_o.png" alt="gif.latex?%5Cepsilon">支配而不是支配来处理这个问题。由此得到多样性多目标进化优化器DEMO。DEMO采用的算法和算法5相同，但它使用<img class="mathcode" src="https://images2.imgbox.com/fb/f9/M99noscb_o.png" alt="gif.latex?%5Cepsilon">支配作为是否将y纳入P的准则。这个准则就是仅当y不被P中的其他个体<img class="mathcode" src="https://images2.imgbox.com/06/f4/INXafa8X_o.png" alt="gif.latex?%5Cepsilon">支配是就将y纳入当前种群。因为<img class="mathcode" src="https://images2.imgbox.com/33/9e/uVesxfQK_o.png" alt="gif.latex?%5Cepsilon">支配是比帕累托支配更弱的一种支配。在DEMO中将y纳入种群的准则比在SEMO中更严格。DEMO本质上是将目标空间分成超箱，并且让种群在每个超箱中包含的个体最多只有一个。DEMO通常使用加性<img class="mathcode" src="https://images2.imgbox.com/ee/81/MUzDxQu0_o.png" alt="gif.latex?%5Cepsilon">支配。</p> 
<p>对两个目标的优化问题，如下图说明DEMO的概念。我们不会将子代<img class="mathcode" src="https://images2.imgbox.com/9f/56/JGZg6Pag_o.png" alt="gif.latex?y_%7B1%7D">纳入种群，因为它被同一个超箱中的个体<img class="mathcode" src="https://images2.imgbox.com/ed/25/Nq5TWOvN_o.png" alt="gif.latex?%5Cepsilon">支配，但会将<img class="mathcode" src="https://images2.imgbox.com/26/c9/bpTFK54G_o.png" alt="gif.latex?y_%7B2%7D">纳入种群因为它不会被当前种群中的任何一个成员<img class="mathcode" src="https://images2.imgbox.com/51/14/PeFKZMIA_o.png" alt="gif.latex?%5Cepsilon">支配。注意，下图说的并不是百分百正确，因为DEMO的超箱是相对当前种群定义的。</p> 
<p><img src="https://images2.imgbox.com/d3/6e/rW4QBXxs_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_7,color_FFFFFF,t_70,g_se,x_16"></p> 
<h3>2.基于<img class="mathcode" src="https://images2.imgbox.com/f4/88/S28jTRPd_o.png" alt="gif.latex?%5Cepsilon">的多目标进化算法</h3> 
<p><strong><img class="mathcode" src="https://images2.imgbox.com/ee/da/AiaXeA8R_o.png" alt="gif.latex?%5Cepsilon">-MODE</strong>包含一个<strong>种群</strong>和一个<strong>档案</strong>。在每一代，我们从种群中选择一个个体并在档案中选择一个个体，用某种重组方法得到一个子代。</p> 
<p>如果子代支配种群中的一个个体，就用子代替换被支配的个体。如果子代支配不止一个个体，则替换随机选出的一个个体。</p> 
<p>然后将子代与档案比较。这种比较会出现<strong>四种情况</strong>：</p> 
<p><strong>（1）</strong>如果子代被归档中的一个个体支配，就不把子代放进档案中。</p> 
<p><strong>（2）</strong>如果子代支配某个归档个体，则将子代添加到档案，并去掉档案中的被支配个体。</p> 
<p>如果这两个条件不成立，就计算子代x的<img class="mathcode" src="https://images2.imgbox.com/aa/55/ezwAy2pc_o.png" alt="gif.latex?%5Cepsilon">-箱B(x)：对于j∈[1,k]</p> 
<p><img src="https://images2.imgbox.com/93/09/tqEGfA49_o.png" alt="7aa1a886dd734c89ab37b2561477cfce.png"></p> 
<p>其中，k是目标函数的个数，<img class="mathcode" src="https://images2.imgbox.com/e8/4c/dm9UpyaA_o.png" alt="gif.latex?%5Cepsilon%20_%7Bj%7D">是第j个目标所需的分辨率。由此得到子代与档案比较的第三种情况：<strong>（3）</strong>如果子代x与一个归档个体同一个 <img class="mathcode" src="https://images2.imgbox.com/e4/59/2eaM6Wb8_o.png" alt="gif.latex?%5Cepsilon">-箱中，如果子代更接近目标函数的原点，就让子代替换a：</p> 
<p><img src="https://images2.imgbox.com/e2/d9/PRKAY5SX_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_15,color_FFFFFF,t_70,g_se,x_16"></p> 
<p><strong>（4）</strong>如果上面的三种情况都没有出现，就将子代添加到档案中，档案规模加1。</p> 
<p>下图说明了这4种可能性。这里描述的逻辑保证档案的每个<img class="mathcode" src="https://images2.imgbox.com/44/23/f3Tq0zQg_o.png" alt="gif.latex?%5Cepsilon">-箱中最多只有一个个体。尽管档案从一代到另一代会长大，这个逻辑会限制它的增长。</p> 
<p><img src="https://images2.imgbox.com/ea/83/15vwu7fR_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_9,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>图（a）说明子代被一个或者多个归档支配；在这种情况下，子代不会被纳入档案。图（b）说明子代支配一个或者多个归档个体；在这种情况下，子代被纳入档案，替换被子代支配的个体；图（c）说明子代和归档个体互相非支配，且子代与归档个体在同一个 <img class="mathcode" src="https://images2.imgbox.com/9d/2f/XPFKaSbv_o.png" alt="gif.latex?%5Cepsilon">-箱中；在这种情况下，如果子代更接近目标函数空间的原点，子代就替换同一个 <img class="mathcode" src="https://images2.imgbox.com/df/a3/vk8ShFaw_o.png" alt="gif.latex?%5Cepsilon">-箱中归档个体。最后，图（d）说明子代和档案互相都是非支配的，并且子代没有与任何一个归档个体在同一个 <img class="mathcode" src="https://images2.imgbox.com/c8/f9/pHvEEsas_o.png" alt="gif.latex?%5Cepsilon">-箱中；在这种情况下，子代被添加到档案，档案规模加1.</p> 
<p>算法6概述 <img class="mathcode" src="https://images2.imgbox.com/a8/5b/WVmsXJC1_o.png" alt="gif.latex?%5Cepsilon">-MOEA。</p> 
<p><img src="https://images2.imgbox.com/c0/22/XPyYS3x6_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_20,color_FFFFFF,t_70,g_se,x_16"></p> 
<h3>3.非支配排序遗传算法NSGA</h3> 
<p><strong>非支配排序遗传算法</strong>（nondominated sorting genetic algrorithm，<strong>NSGA</strong>），它基于每一个个体的支配水平为其分配费用。首先将所有的个体复制给一个临时种群T。然后找出T中的所有非支配个体；用集合B表示这些非支配个体并未它们分配最低的费用。接下来从T中去掉B并在缩减后的集合T中找出所有非支配个体，为这些个体分配次低的费用。重复这个过程，就得到基于个体非支配水平的每一个个体的费用。算法7概述NSGA。</p> 
<p><img src="https://images2.imgbox.com/a4/f0/mApSOwNW_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_20,color_FFFFFF,t_70,g_se,x_16"></p> 
<h4>NSGAⅡ</h4> 
<p> <strong>NSGAⅡ</strong>是对NSGA的改进。 NSGAⅡ在计算个体x费用时不仅考虑支配它的个体而且还考虑它支配的个体。对每一个个体，沿着目标函数的维度找出离它最近的个体，并用它们之间的距离计算<strong>拥挤距离</strong>。 NSGAⅡ不适用档案，但使用(μ+λ)进化策略实施精英。</p> 
<p> NSGA将每一个个体x的拥挤距离设置为沿每个目标函数的维度距离它最近的邻居的平均距离。加入，在 NSGA中有N个个体，进一步假设x的目标函数向量为</p> 
<p><img src="https://images2.imgbox.com/3c/05/CFkUT7gL_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_10,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>对于每个目标的维度，找出种群中<strong>离得最近的较大值</strong>和<strong>离得最近的较小值</strong>，如下：</p> 
<p><img src="https://images2.imgbox.com/ee/91/JEGKuVTm_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_12,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>然后计算x的拥挤距离：</p> 
<p><img class="mathcode" src="https://images2.imgbox.com/eb/9b/zBe9eVgT_o.png" alt="gif.latex?f_%7B1%7D"></p> 
<p>在目标函数空间中较拥挤的地方拥挤距离往往较小。位于目标函数空间极值处的个体的距离会无穷大：</p> 
<p><img src="https://images2.imgbox.com/9b/52/XgAYAxz9_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_18,color_FFFFFF,t_70,g_se,x_16"></p> 
<p><strong>最大立方体</strong>的边界不会超出x的最近邻居在每个维度上目标函数空间的坐标，<strong>拥挤距离</strong>应该相应于最大立方体的边长的一半。下图显示二维目标函数空间中的一个超立方，它是一个矩形。下图中x在<img class="mathcode" src="https://images2.imgbox.com/b3/82/Jfsc9e2E_o.png" alt="gif.latex?f_%7B1%7D">方向上的最近邻居是A和C，在<img class="mathcode" src="https://images2.imgbox.com/c0/4b/fim1hMkZ_o.png" alt="gif.latex?f_%7B2%7D">方向上的最近邻居是A和B。</p> 
<p><img src="https://images2.imgbox.com/94/f5/DHgwV1BX_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_9,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>最大超立方体（在二维空间中是一个矩形）的周长的1一半为x的拥挤距离，最大立方体的边界不会超出x的最近邻居在目标函数空间中的坐标。 </p> 
<p>既然种群中的每个个体都由一个拥挤距离，我们就把它作为次级排序的参数得到每一个个体的排名。与NSGA算法一样，我们基于非支配水平对每一个个体排序，同时还包含<strong>基于拥挤距离的一个细粒度</strong>的排名水平。也就是说，如果<img class="mathcode" src="https://images2.imgbox.com/02/2e/Zln5RPL4_o.png" alt="gif.latex?%5Cphi%20%5Cleft%20%28%20x%20%5Cright%20%29"><img class="mathcode" src="https://images2.imgbox.com/5c/89/nGpB2bvZ_o.png" alt="gif.latex?%3C"><img class="mathcode" src="https://images2.imgbox.com/0e/64/bcct73oF_o.png" alt="gif.latex?%5Cphi%20%5Cleft%20%28%20y%20%5Cright%20%29">，或者如果<img class="mathcode" src="https://images2.imgbox.com/3b/d6/6KSvtPJ3_o.png" alt="gif.latex?%5Cphi%20%5Cleft%20%28%20x%20%5Cright%20%29">=<img class="mathcode" src="https://images2.imgbox.com/93/2a/Mnr3SeYz_o.png" alt="gif.latex?%5Cphi%20%5Cleft%20%28%20y%20%5Cright%20%29">且d(x)&gt;d(y)，则x的排名比y的好。NSGA算法采用<img class="mathcode" src="https://images2.imgbox.com/33/4f/VVyXetti_o.png" alt="gif.latex?%5Cphi%20%5Cleft%20%28%20x%20%5Cright%20%29">选择重组父代，而NSGAⅡ则用上述的排名来选择重组父代。</p> 
<h3>4.多目标遗传算法 </h3> 
<p>它基于<strong>支配水平</strong>分配费用。MOGA从相反的方向解决费用分配。MOGA基于有多少个个体支配x来为他分配费用。我们对所有非支配个体分配相同的费用。对每个被支配个体x，则根据有多少个个体支配它以及有多少个个体在它附近来分配费用。与NSGAⅡ使用拥挤距离类似，这样做会促进种群的多样性。</p> 
<p>在MOGA中，x的排名比y好（即<img class="mathcode" src="https://images2.imgbox.com/0c/d0/SbXZy9BM_o.png" alt="gif.latex?%5Cphi%20%5Cleft%20%28%20x%20%5Cright%20%29"><img class="mathcode" src="https://images2.imgbox.com/67/ea/SOSsqzZt_o.png" alt="gif.latex?%3C"><img class="mathcode" src="https://images2.imgbox.com/b0/70/CMq3MIKc_o.png" alt="gif.latex?%5Cphi%20%5Cleft%20%28%20y%20%5Cright%20%29">），如果种群P中支配它的个体较少（即d(x)＜d(y)），或者支配它们的个体数相同且在目标函数空间靠近x的个体比靠近y的个体少（即s(x)＜s(y)）。这个排名的方法可以表示为</p> 
<p><img src="https://images2.imgbox.com/e9/a3/YEkRDdGv_o.png" alt="f89073cffcb5499eaa7de44521ce3541.png?x-oss-process=image,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_15,color_FFFFFF,t_70,g_se,x_16"></p> 
<p> 其中，<img class="mathcode" src="https://images2.imgbox.com/16/53/l8cRbmMx_o.png" alt="gif.latex?%5Csigma">是用户定义的参数，||·||是某个距离测度，可以自动的实现共享，这样就不需要其他用户定义共享参数。算法8概述MOGA。</p> 
<p><img src="https://images2.imgbox.com/0f/95/QBZTf5TE_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_20,color_FFFFFF,t_70,g_se,x_16"></p> 
<h3>5.小生境帕累托遗传算法NPGA</h3> 
<p><strong>小生境帕累托遗传算法（NPGA）</strong>与NSGA和MOGA类似，它基于<strong>支配水平</strong>分配费用。NPGA试图<strong>减少</strong>NSGA和MOGA的<strong>计算量</strong>。我们从种群中随机选出两个个体<img class="mathcode" src="https://images2.imgbox.com/62/44/FC1wdJMR_o.png" alt="gif.latex?x_%7B1%7D">和<img class="mathcode" src="https://images2.imgbox.com/cf/3b/9ixldfHi_o.png" alt="gif.latex?x_%7B2%7D">，然后随机选出种群的一个子集S，这个子集通常约占种群的10%。如果其中有一个个体<img class="mathcode" src="https://images2.imgbox.com/73/a5/fTQqetSo_o.png" alt="gif.latex?x_%7B1%7D">或<img class="mathcode" src="https://images2.imgbox.com/85/7b/FuPsGdbn_o.png" alt="gif.latex?x_%7B2%7D">被S中的某个个体支配，另一不被支配，则记非支配个体为r（r为<img class="mathcode" src="https://images2.imgbox.com/29/a8/ULTrfjgB_o.png" alt="gif.latex?x_%7B1%7D">或<img class="mathcode" src="https://images2.imgbox.com/af/04/3eOr7vIv_o.png" alt="gif.latex?x_%7B2%7D">中的一个），它赢得锦标赛被选出来进行重组。如果<img class="mathcode" src="https://images2.imgbox.com/07/c8/1aYB0MYs_o.png" alt="gif.latex?x_%7B1%7D">和<img class="mathcode" src="https://images2.imgbox.com/fd/61/eYQE75nn_o.png" alt="gif.latex?x_%7B2%7D">这两个个体都被S中至少一个个体支配，或都不被S中的任何一个个体支配，则用适应度分享来决定锦标赛的赢家；也就是说，处于目标函数空间中不拥挤区域中的个体赢得锦标赛。这个选择过程可以描述如下：</p> 
<p><img src="https://images2.imgbox.com/23/6b/77zDvOjr_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_14,color_FFFFFF,t_70,g_se,x_16"></p> 
<p> <img class="mathcode" src="https://images2.imgbox.com/19/af/eMJSh8t9_o.png" alt="gif.latex?d_%7Bi%7D">是支配<img class="mathcode" src="https://images2.imgbox.com/05/79/flpW2JDc_o.png" alt="gif.latex?x_%7Bi%7D">个个体数，<img class="mathcode" src="https://images2.imgbox.com/6a/3a/zMcLeF4S_o.png" alt="gif.latex?s_%7Bi%7D">是<img class="mathcode" src="https://images2.imgbox.com/77/e5/rlVnjfQM_o.png" alt="gif.latex?x_%7Bi%7D">的拥挤距离，r是我们最后选出来重组的个体（ <img class="mathcode" src="https://images2.imgbox.com/1b/53/aVHqenqa_o.png" alt="gif.latex?x_%7B1%7D">或<img class="mathcode" src="https://images2.imgbox.com/ff/f5/ljWCxSWl_o.png" alt="gif.latex?x_%7B2%7D"> ）。</p> 
<p>搜索空间或目标函数空间中越拥挤的区域个体的拥挤距离越小。在NPGA中使用拥挤距离会鼓励多样性；它特别适合<strong>多模态问题</strong>，或者用户有意在函数空间或搜索空间中相距很远的区域找到好的潜在解的那些问题。算法9概述NPGA。</p> 
<p><img src="https://images2.imgbox.com/f7/1c/CxQ7UnBI_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_19,color_FFFFFF,t_70,g_se,x_16"></p> 
<h3>6.优势帕累托进化算法SPEA</h3> 
<p>优势帕累托进化算法（strength Pareto evolutionary algorithm，SPEA）是第一个显式地利用精英的MOEA。精英通常是单目标和多目标进化算法的一个常识性的选择。如果基于用户的偏好的方法用与MOEA，并且让偏好随时间地变化而变化，精英可能会导致性能退化。</p> 
<p>SPEA会把在学习过程中找到的所有非支配个体留在档案中。每当找到非支配个体就把它复制到档案中。对每个归档个体α，基于种群中被α支配的个体数为其分配<strong>优势值S(α)</strong>：</p> 
<p><img src="https://images2.imgbox.com/77/00/EpE1bOkA_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_12,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>其中，P是候选解的集合，N为P的大小，A是档案的集合。注意， S(α)∈[0,1）。对P中的每一个个体x，我们找出支配它的的所有归档个体的集合α(x)。然后令x的原始费用为α(x)中<strong>优势个体的总和</strong>，记为R(x)：</p> 
<p><img src="https://images2.imgbox.com/97/81/bIjI6Pax_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_11,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>在上面的等式加上1能保证R(x)≥1，它反过来保证，对所有x∈P和所有α∈A，R(x)＞S(α)。注意，如果x的原始费用很低，则x是一个高性能个体。</p> 
<p>下图说明优势和原始费用的计算，其中档案规模为|A|=3种群规模|P|=6。下图显示帕累托前沿的优势值为它们所支配的个体数正规化后的值。此图也显示每个被支配的点的原始费用为支配它的帕累托前沿点的优势的总和再加上1。注意，个体越远离帕累托前沿（即当个体被更多的帕累托前沿支配），原始费用就越大。</p> 
<p><img src="https://images2.imgbox.com/96/32/3NgZBItw_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_9,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>帕累托前沿个体用x表示，旁边显示的是它们的优势值，非帕累托前沿用实心圆表示，旁边显示的是它们的原始费用。例如9/7的点被优势值为2/7的点支配，因此原始费用为2/7+1=9/7。</p> 
<p> 在每一代将{P，A}中的非支配个体都加入到档案A中，但这会让<strong>档案无限增长</strong>。SPEA用<strong>聚类</strong>来处理这个潜在的问题。如果档案中有|A|个个体，我们一开始定义一个个体为一个聚类。然后把两个离得最近的聚类合并为一个聚类，A的聚类个数减1.重复这个过程直到档案中含有<img class="mathcode" src="https://images2.imgbox.com/85/01/aXeHI7bV_o.png" alt="gif.latex?N_%7BA%7D">个聚类，它是我们想要的档案规模。最后，在每一个聚类中留下一个点，通常是离聚类中心点最近的那个点。</p> 
<h4>SPEA2</h4> 
<p>SPEA2对SPEA做了医学改进。<strong>首先</strong>，我们不仅为档案个体分配优势值S(α)，也为种群中的个体分配优势值：</p> 
<p><img src="https://images2.imgbox.com/67/91/YAYfcviw_o.png" alt="30a3c069132a4e7c9eeb46581a6298d0.png?x-oss-process=image,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_14,color_FFFFFF,t_70,g_se,x_16"></p> 
<p> 与（45）式比较，可知上式没有对优势值做归一化处理。</p> 
<p><strong>其次</strong>，在计算P中每个个体的原始费用时也稍微有点不同，我们将种群和档案中支配个体的总优势和起来：</p> 
<p><img src="https://images2.imgbox.com/60/df/56Q68pBV_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_12,color_FFFFFF,t_70,g_se,x_16"></p> 
<p> 与（46）式比较，上式在计算原始费用时没有加1。</p> 
<p><strong>再次</strong>，基于邻近个体数修改每个x∈P的原始费用；也就是说，对于目标函数空间中邻居较多的个体在费用上给予惩罚。对于y≠x的所有x∈P和所有y∈{P,A}，找出f(x)和f(y)之间的距离来惩罚。通常采用欧氏距离。对于每一个x∈P，将它与每一个y∈{P,A}之间的距离<strong>按升序排列</strong>，得到x的（|P|+|A|）个元素的<strong>有序距离列表</strong>。然后选择距离列表中的第j个元素，它是x和距它第j个最近邻居之间的距离，记为<img class="mathcode" src="https://images2.imgbox.com/a3/da/2swTIgy7_o.png" alt="gif.latex?%5Csigma%20_%7Bj%7D%28x%29">。定义x的密度为</p> 
<p><img src="https://images2.imgbox.com/98/d0/34yJ4IWr_o.png" alt="1a827e7fc16146058894bd0c09360ae4.png"></p> 
<p> 这列分母需要选择常数γ以保证D(x)&lt;1。</p> 
<p><strong>最后</strong>，将原始费用加到密度上得到修改后x点的费用：</p> 
<p><img src="https://images2.imgbox.com/4e/90/ZD5QhZv2_o.png" alt="267d5df9275a48ec987d31070c60027c.png"></p> 
<p> 由（48）式可知，所有非支配个体的原始费用为0，并且对于所有x，D(x)&lt;1，因此所欲非支配个体的费用C(x)&lt;1。</p> 
<p>在SPEA中档案规模没有下界，但在SPEA2中档案规模保持为一个常值。如果在SPEA2过程中任一点<strong>档案规模过小</strong>，就将种群中费用最低的个体，即使它们是被支配的，纳入档案直到档案规模达到最想要的值。如果<strong>档案规模过大</strong>，就在目标函数空间中通过找出距每个x∈A最近的邻居：</p> 
<p><img src="https://images2.imgbox.com/f1/0c/n38gIGed_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_18,color_FFFFFF,t_70,g_se,x_16"></p> 
<p> 由此得到|A|个<img class="mathcode" src="https://images2.imgbox.com/fc/54/A3dRmBzY_o.png" alt="gif.latex?D_%7Bmin%7D%28x%29">的值，这里|A|为档案的规模。下面我们用D表示具有最小<img class="mathcode" src="https://images2.imgbox.com/ab/14/6J2lPFcY_o.png" alt="gif.latex?D_%7Bmin%7D%28x%29">的个体的集合：</p> 
<p><img src="https://images2.imgbox.com/11/1f/pmVVMvdE_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_12,color_FFFFFF,t_70,g_se,x_16"></p> 
<p>D中至少会有两个个体，因为两个个体x和y之间的距离与y与x之间的距离相同。在D中的所有个体中，找出距不属于D的任一归档个体最近的个体，记为<img class="mathcode" src="https://images2.imgbox.com/f4/88/KbUXtQuq_o.png" alt="gif.latex?x_%7Bmin%7D">：</p> 
<p><img src="https://images2.imgbox.com/31/6f/R7PepTJU_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_18,color_FFFFFF,t_70,g_se,x_16"></p> 
<p> 从档案中去掉，这样档案规模减1。如果|A|过大，重复上述过程，在每次迭代中去掉一个个体，直到达到想要的档案规模。</p> 
<p>算法10概述了SPEA和SPEA2个基本思想。</p> 
<p><img src="https://images2.imgbox.com/8b/dc/1y8GQmmk_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_20,color_FFFFFF,t_70,g_se,x_16"></p> 
<h3>7.帕累托归档进化策略PAES</h3> 
<p><strong>帕累托归档进化策略PAES</strong>，其<strong>动机</strong>来自<strong>（1+1）进化策略</strong>。在每一代，单个个体利用变异生成单个子代。在每一代一个父代生成一个子代，如果子代不被档案中的个体支配就将它纳入档案。如果档案规模超过某个阈值，就通过剔除拥挤距离最小的个体（即在搜索空间或目标函数看空间中最拥挤的个体）修剪档案。算法11概述一般的PAES。s(α)是α的拥挤距离，对于目标函数空间或搜索域的拥挤区域中的个体数。</p> 
<p><img src="https://images2.imgbox.com/d2/6d/ksYCXwMd_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_19,color_FFFFFF,t_70,g_se,x_16"></p> 
<hr> 
<h2>基于生物地理学的多目标优化</h2> 
<h3>1.向量评价BBO</h3> 
<p>因为BBO以迁移为基础，<strong>多目标BBO</strong>的<strong>迁入</strong>以每一个个体的第<img class="mathcode" src="https://images2.imgbox.com/3a/f1/N1d4lHjY_o.png" alt="gif.latex?k_%7Bi%7D">个目标函数值为基础，这里<img class="mathcode" src="https://images2.imgbox.com/37/37/ckrbiKTx_o.png" alt="gif.latex?k_%7Bi%7D">是在第i个迁移实验的随机目标函数的指标，然后，让<strong>迁出</strong>以每一个个体的第<img class="mathcode" src="https://images2.imgbox.com/01/06/p2pWTCX7_o.png" alt="gif.latex?k_%7Be%7D">个目标函数值为基础，这里也是一个随机目标函数指标。由此得到向量评价BBO（VEBBO）算法12。</p> 
<p><img src="https://images2.imgbox.com/b1/f2/PeJrrXPB_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_20,color_FFFFFF,t_70,g_se,x_16"></p> 
<h3>2.非支配排序BBO</h3> 
<p>将BBO与NSGA结合，算法7是NSGA。为了针对BBO修改算法7，只需要将重组语句改为一个BBO的迁移操作。由此得到非支配排序BBO算法（NSBBO），算法13。</p> 
<p><img src="https://images2.imgbox.com/df/12/SWDoPa0U_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_19,color_FFFFFF,t_70,g_se,x_16"></p> 
<h3>3.小生境帕累托BBO</h3> 
<p>与NSBBO算法类似，为了针对BBO修改算法9，只需要把重组语句改为BBO的迁移操作。因为NPGA已经基于非支配选择了R中的个体，我们可以简单的对R中的每一个个体以相等的迁移概率选择迁移操作。由此得到<strong>小生境帕累托BBO（NPBBO）</strong>算法14。</p> 
<p><img src="https://images2.imgbox.com/66/bd/l3lDbR2e_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_19,color_FFFFFF,t_70,g_se,x_16"></p> 
<h3>4.优势帕累托BBO</h3> 
<p>BBO与SPEA或SPEA2结合的方法，算法10是SPEA和SPEA2，为了针对BBO修改算法10，需要改变选择父代和重组方法的语句。用SPEA或者SPEA2的费用来计算迁移率，然后利用这些迁移率实施BBO。从种群P和档案A中选出父代，这就是优势帕累托BBO(SPBBP)算法15。</p> 
<p><img src="https://images2.imgbox.com/42/77/LxURyCq5_o.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546L5LiN55WZ6KGM4pyo,size_20,color_FFFFFF,t_70,g_se,x_16"></p> 
<p> </p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9dd9f35031f05628d5e63bd6f821b933/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">String字符串删除空格的七种方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/601567afe5f2b24278fcc17339a98f45/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">transform——CSS</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>