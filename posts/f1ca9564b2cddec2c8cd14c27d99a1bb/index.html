<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>栈 和 队列 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="栈 和 队列" />
<meta property="og:description" content="什么是栈? 一种特殊的线性表，只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出（LIFO - Last In First Out）的原则。
从数据结构的角度来看，栈 就是一种数据结构。
压栈 和 出栈
压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。出栈：栈的删除操作叫做出栈。出数据在栈顶。 Java 虚拟机栈 Java 虚拟机 JVM 可分五个部分
方法区：存放类定义信息、字节码、常量等数据，在Sun HotSpot JVM中，这块也称为Perm Gen。
堆：创建的对象信息将放入堆中，堆内部如何实现各虚拟机各不相同，对于Sun HotSpot JVM来说又分为Young Gen和Tenured Gen，更详细描述参见《[Java性能剖析]Sun JVM内存管理和垃圾回收 》
Java栈：对于每个执行线程，会分配一个Java栈，JVM在执行过程当中，每执行一个方法，都会为方法在当前栈中增加一个栈帧，每个栈帧的信息与具体实现相关，但一般会由3部分组成：变量区，方法参数和本地变量会放入这个位置，大小是固定的，在进行方法时会先分配好，在类定义中，会由max local来指定这块区的大小；方法信息区，会包括当前类常量池的入口地址等信息，这块大小也是固定的；操作栈，与Intel体系架构中的运算使用寄存器来进行不一样，JVM的字节码的方法调用、运算等需要的参数，都是通过操作栈来传递的。在类定义中，会由max stack指定最大的操作栈。关于Java栈的更详细描述参见《Java 栈内存介绍 》
本地方法栈：对本地方法的调用，并不会使用Java栈而是使用本地方法栈，本地方法栈的组成取决于所使用的平台和操作系统.
PC寄存器/程序计数器：对于每个执行线程会分配一个PC寄存器，寄存器中存放当前字节码的执行位置 栈帧 在调用函数的时候，我们会为这个函数在java虚拟机栈中开辟一块内存，叫做栈帧。 栈的使用 1.入栈 和 出栈的顺序 中缀 和 后缀 表达式的表现形式 中缀表达式：最常见的表达式，就是我们平常使用的： a &#43; b、a - c、a * b、a/b。
还可以加括号 (5 &#43; 4) * 3 - 2。
后缀表达式：就拿中缀的式子【(5 &#43; 4) * 3 - 2】来说，它的后缀表达式为 54&#43; 3 * 2 -" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/f1ca9564b2cddec2c8cd14c27d99a1bb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-11T16:21:21+08:00" />
<meta property="article:modified_time" content="2023-11-11T16:21:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">栈 和 队列</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>什么是栈?</h4> 
<p>        一种特殊的线性表，只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守<strong><span style="color:#956fe7;">后进先出</span></strong>（LIFO - Last In First Out）的原则。<br>  <br> 从数据结构的角度来看，栈 就是一种数据结构。</p> 
<blockquote> 
 <p><span style="color:#4da8ee;"><strong>压栈 和 出栈</strong></span></p> 
 <ul><li>压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。</li><li>出栈：栈的删除操作叫做出栈。出数据在栈顶。</li></ul> 
 <p><img alt="" height="343" src="https://images2.imgbox.com/ef/91/Jb4Nygnh_o.png" width="1200"></p> 
</blockquote> 
<hr> 
<h4>Java 虚拟机栈</h4> 
<p>        Java 虚拟机 JVM 可分五个部分</p> 
<p><img alt="" height="540" src="https://images2.imgbox.com/22/ff/XPDbmfk3_o.png" width="1200"></p> 
<p><span style="color:#956fe7;"><strong>        方法区：</strong></span>存放类定义信息、字节码、常量等数据，在Sun HotSpot JVM中，这块也称为Perm Gen。<br>  <br><strong><span style="color:#956fe7;">        堆：</span></strong>创建的对象信息将放入堆中，堆内部如何实现各虚拟机各不相同，对于Sun HotSpot JVM来说又分为Young Gen和Tenured Gen，更详细描述参见《[Java性能剖析]Sun JVM内存管理和垃圾回收 》<br><span style="color:#956fe7;"> <br><strong>        Java栈：</strong></span>对于每个执行线程，会分配一个Java栈，JVM在执行过程当中，每执行一个方法，都会为方法在当前栈中增加一个栈帧，每个栈帧的信息与具体实现相关，但一般会由3部分组成：<strong>变量区</strong>，方法参数和本地变量会放入这个位置，大小是固定的，在进行方法时会先分配好，在类定义中，会由max local来指定这块区的大小；<strong>方法信息区</strong>，会包括当前类常量池的入口地址等信息，这块大小也是固定的；<strong>操作栈</strong>，与Intel体系架构中的运算使用寄存器来进行不一样，JVM的字节码的方法调用、运算等需要的参数，都是通过操作栈来传递的。在类定义中，会由max stack指定最大的操作栈。关于Java栈的更详细描述参见《Java 栈内存介绍 》<br>  <br><span style="color:#956fe7;"><strong>        本地方法栈：</strong></span>对本地方法的调用，并不会使用Java栈而是使用本地方法栈，本地方法栈的组成取决于所使用的平台和操作系统.<br><span style="color:#956fe7;"><strong> <br>         PC寄存器/程序计数器：</strong></span>对于每个执行线程会分配一个PC寄存器，寄存器中存放当前字节码的执行位置 </p> 
<hr> 
<h4>栈帧</h4> 
<p>        在调用函数的时候，我们会为这个函数在java虚拟机栈中开辟一块内存，叫做栈帧。 </p> 
<p><img alt="" height="386" src="https://images2.imgbox.com/51/be/ODp7lITB_o.png" width="986"></p> 
<hr> 
<h4>栈的使用</h4> 
<h5><a name="t7"></a><a id="1___34"></a><span style="color:#956fe7;">1.入栈 和 出栈的顺序</span></h5> 
<h5><a name="t8"></a><img alt="" height="1200" src="https://images2.imgbox.com/64/c0/suspL8Yk_o.png" width="1200"></h5> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/2a/bd/55I7d6XO_o.png" width="1200"></p> 
<h5>中缀 和 后缀 表达式的表现形式</h5> 
<p>中缀表达式：最常见的表达式，就是我们平常使用的： a + b、a - c、a * b、a/b。<br> 还可以加括号 (5 + 4) * 3 - 2。</p> 
<p> <br> 后缀表达式：就拿中缀的式子【(5 + 4) * 3 - 2】来说，它的后缀表达式为 54+ 3 * 2 -<br> 再来看一个 a + b * c ，这个中缀表达式转换成 后缀表达式为 abc*+ </p> 
<blockquote> 
 <h6>中缀转后缀 和 中缀转前缀 的方法</h6> 
 <p><img alt="" height="887" src="https://images2.imgbox.com/d1/00/6SDKKLcl_o.png" width="1200"></p> 
</blockquote> 
<h5>实战题</h5> 
<blockquote> 
 <h5><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/" rel="nofollow" title="150. 逆波兰表达式求值 - 力扣（LeetCode）">150. 逆波兰表达式求值 - 力扣（LeetCode）</a></h5> 
 <p><img alt="" height="402" src="https://images2.imgbox.com/9c/19/gUweTmSp_o.png" width="558"></p> 
</blockquote> 
<h6>解题思维</h6> 
<p>借助栈和循环，思维是这样的：</p> 
<ol><li>如果 i 下标的元素 是 数字，直接入栈。</li><li>如果 i 下标的元素 是 运算符时，出栈两个数字 进行运算，再将其计算结果入栈。</li><li>以此类推！</li></ol> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/59/6f/n50r9YbM_o.png" width="1200"></p> 
<p><span style="color:#956fe7;"><strong>代码阶段:</strong></span></p> 
<p>1、怎么 new 一个 Stack</p> 
<p><img alt="" height="835" src="https://images2.imgbox.com/b1/d5/kDWTDvPU_o.png" width="469"></p> 
<h6>进入 栈Stack 类，按下 alt + 7</h6> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/fe/5d/8yA1zA7S_o.png" width="1200"></p> 
<h6>2、Stack 的功能</h6> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/5e/cf/okDCTBTn_o.png" width="1200"></p> 
<h6>3、另外，栈继承了 Vector 类，Vectoc 类，又实现了一些接口功能。那么，就意味着：Stack 可以调用的方法不止本身的那些功能，还可以调用 它 所继承的类 和 接口 的 一些方法 和 属性。</h6> 
<p><img alt="" height="170" src="https://images2.imgbox.com/29/e8/7EdmCEQK_o.png" width="1061"></p> 
<p>Ctrl + 左键 进入 Vector</p> 
<p><img alt="" height="1042" src="https://images2.imgbox.com/85/f0/ZcMBA38g_o.png" width="1200"></p> 
<p>简略图</p> 
<p><img alt="" height="420" src="https://images2.imgbox.com/cb/87/cAVMtzyK_o.png" width="875"></p> 
<h6>代码</h6> 
<pre><code>class Solution {
    public int evalRPN(String[] tokens) {
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        for(int i = 0; i &lt;tokens.length;i++){
            String str = tokens[i];//获取下标为 i 字符串元素
            if(isOperator(str)){// 如果 str 是运算符 为 true，否则为false
                int num2 = stack.pop();// 获取 栈顶 的 两个数字数据（出栈）
                int num1 = stack.pop();
                switch(str){// 判断 str 具体是 哪一个字符串，就执行对应的运算，并将其结果入栈
                    case "+":
                        stack.push(num1 + num2);
                        break;
                    case "-":
                        stack.push(num1 - num2);
                        break;
                    case "*":
                        stack.push(num1 * num2);
                        break;
                    case "/":
                        stack.push(num1 / num2);
                        break;
                }
            }else{// 将 数字字符转换成 整形数据 存入 栈中
                stack.push(Integer.parseInt(str));
            }
        }
        return stack.pop();// 返回/出栈   最终存入栈中的结果
    }
    public boolean isOperator(String s){// 判断 str 是运算符 返回 true；否则，返回 false
        if(s.equals("+") || s.equals("-")|| s.equals("*") || s.equals("/")){
            return true;
        }
        return false;
    }
}
</code></pre> 
<hr> 
<h5>实战题 </h5> 
<p><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;&amp;tqId=11174&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking" rel="nofollow" title="栈的压入、弹出序列_牛客题霸_牛客网 (nowcoder.com)">栈的压入、弹出序列_牛客题霸_牛客网 (nowcoder.com)</a></p> 
<p><img alt="" height="576" src="https://images2.imgbox.com/51/97/5RT9j8hK_o.png" width="1061"></p> 
<h6>解题思维 - 双指针遍历</h6> 
<p>定义两个整形指针 p1 和 p2【初始值为0】，分别指向 输入的两个数组 pushA 和 popA</p> 
<p><img alt="" height="536" src="https://images2.imgbox.com/cc/cf/GtB9TdQG_o.png" width="758"></p> 
<p>我们想法：</p> 
<p>将 i 指向的元素入栈、入栈后，i++。直到 栈顶的数据 与 出栈序列 j 的指向相等，我们将其出栈。<br> 然后， j++，开始判断下一个。<br> 如果 栈顶的数据 与 出栈序列 j 指向的元素不相等。则继续 将 i 指向的数据入栈。直到 栈顶的数据 与 出栈序列 j 的指向相等，我们将其出栈。<br> 重复此操作，直到 i 遍历完 pushA数组。<br> 如果： 入栈数组 出栈效果 可以达到 出栈数组的效果，栈里面应该是为 空的。</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/17/4a/kxR9nUJv_o.png" width="1167"></p> 
<pre><code>import java.util.*;

public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
      Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        for(int i = 0, j = 0;i &lt; pushA.length;i++){
            stack.push(pushA[i]);
            while(!stack.isEmpty() &amp;&amp; j &lt; popA.length &amp;&amp; stack.peek() == popA[j]){
                j++;
                stack.pop();
            }
        }
        return stack.isEmpty();

    }
}
</code></pre> 
<hr> 
<h4 style="background-color:transparent;">模拟实现栈 - 数组实现</h4> 
<p>参考栈的源码，观察它所具有的方法 和 属性。</p> 
<p><img alt="" height="398" src="https://images2.imgbox.com/7e/5b/URsicAhl_o.png" width="505"></p> 
<p>由此，得出结论：Stack 底层 也可以说是一个数组。</p> 
<p><img alt="" height="452" src="https://images2.imgbox.com/a0/9d/NJosaO3y_o.png" width="872"></p> 
<p>然后，就是数组的入栈了。<br> 但是！我们需要注意：<br>      数组的容量假设为5。但是，我该怎么知道 栈内 存储数据个数。<br> 那么，我们就肯定需要一个 usedSize【初始值为0】 来记录 存入的数据个数。存入一个（usedSize++）.<br> 而且！ 我们还可以通过它 来进行 入栈。<br> 这么来想：当还没有存入 数据时，usedSize 为 0。此时，我们要入栈一个数据，我们 直接 elements[usedSize] = data。 然后，usedSize++：【细品一下：在将原先的数据“入栈”到对应的位置后，usedSize再++。是不是记录了入栈的元素个数，又为下一次入栈的数据，指定好了位置】<br>  <img alt="" height="547" src="https://images2.imgbox.com/ab/92/FBmOBoGY_o.png" width="461"></p> 
<p>之后，就是构造一个 Stack 的 构造方法。【将底层数组初始容量定为5】</p> 
<p><img alt="" height="205" src="https://images2.imgbox.com/8a/03/9U5ACE47_o.png" width="408"></p> 
<h5><span style="color:#956fe7;">实现栈的功能</span></h5> 
<h6>1、 push 入栈 功能</h6> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/57/c2/MvYadUE2_o.png" width="1200"></p> 
<h6>pop 出栈功能</h6> 
<p><img alt="" height="207" src="https://images2.imgbox.com/db/51/1Gj9C5D0_o.png" width="452"></p> 
<p>注意！此时，我们的栈是利用数组来实现了。</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/54/80/dFoFQJiu_o.png" width="1200"></p> 
<h6>peek 方法</h6> 
<p>peek 方法只是获取栈顶元素，并不涉及删除。所以，usedSize 就不用再减减了</p> 
<p><img alt="" height="252" src="https://images2.imgbox.com/99/b2/ofyEE6iF_o.png" width="528"></p> 
<h6>模拟 Stack（栈） 总程序附图</h6> 
<p><img alt="" height="1161" src="https://images2.imgbox.com/41/7e/gj0hIRkf_o.png" width="1080"></p> 
<p><img alt="" height="715" src="https://images2.imgbox.com/9e/75/bNBe0lRs_o.png" width="1026"></p> 
<p><img alt="" height="369" src="https://images2.imgbox.com/2d/0e/hVfhhhSt_o.png" width="575"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/f1/7f/bMiPuB25_o.png" width="1200"></p> 
<h4>模拟实现栈 - 链表实现</h4> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/d0/5f/gNfm1nvy_o.png" width="1200"></p> 
<h5>单向链表 + 头插</h5> 
<pre><code class="hljs">class Node{
    int val;
    Node next;
    public Node(){}

    public Node(int val,Node node){
        this.val = val;
        this.next = node;
    }

}

public class MyStackLinked {
    Node head;// 头节点 : 标记栈顶

    public void push(int x){
        Node node = new Node(x,head);
            this.head = node;
    }

    public int pop(){
        if(isEmpty()){
            throw  new RuntimeException("栈为空");
        }
        int oldVal = this.head.val;
        head = head.next;
        return oldVal;
    }
    public boolean isEmpty(){
        return this.head == null;
    }

    public int peek(){
        if(isEmpty()){
            throw  new RuntimeException("栈为空");
        }
        return head.val;
    }
}

</code></pre> 
<h5>双向链表 + 尾插</h5> 
<pre><code class="hljs">class DoubleNode{
    int val;
//    DoubleNode next;// next 用不到，加不加都不影响效果
    DoubleNode prev;
    public DoubleNode(int val,DoubleNode prev){
        this.val =val;
        this.prev = prev;
    }
}

public class MyStackDoubleLinked {
//    DoubleNode head; 头节点 用不到
    DoubleNode tail;

    public void push(int x){
        if(tail == null){
            tail = new DoubleNode(x,tail);
        }else{
            DoubleNode node = new DoubleNode(x,tail);
//            tail.next = node; 如果你还是加 next，这一步我给你准备好了
            tail = node;
        }
    }

    public int pop(){
        if(isEmpty()){
            throw new RuntimeException(" 栈为空 ");
        }
        int oldVal = tail.val;
        tail = tail.prev;
        return oldVal;
    }
    public  boolean isEmpty(){
        return tail == null;
    }

    public int peek(){
        if(isEmpty()){
            throw new RuntimeException(" 栈为空 ");
        }
        return tail.val;
    }
}
</code></pre> 
<h4>栈的面试题</h4> 
<h5><a href="https://leetcode-cn.com/problems/valid-parentheses/" rel="nofollow" title="LeetCode - 20. 有效的括号">LeetCode - 20. 有效的括号</a></h5> 
<p>解题思维<br> 这道题跟前面 逆序波兰表达式，做法思维是相同的。<br> 遍历 字符串，当我们 遇到 ’ ( ’ 、’ [ ‘、’ { ’ 的 时候，我们就将它入栈。<br> 随后，继续便来字符串。直到遇到 ’ ) ‘、’ ] ‘、’ } '。我们就去判断栈顶的数据 是不是 它们对应的做符号。如果是：出栈（将栈顶数据出栈，表示这对括号有效）。反之，如果不是：直接返回 false。【因为这个乱入的符号导致整个字符串的符号无法匹配】。再或者：遍历完了字符串，栈里面还存储的左符号，没有右符号匹配了，直接返回false;<br> 之所以说与逆波兰表达式那题相同，就是遇到了特定字符需要进行相应的操作，返回值还是需要根据 栈的内部情况决定【空为ture，否则为 false（为 true，说明字符串里面的括号都是有效的）】<br>  <img alt="" height="1200" src="https://images2.imgbox.com/ee/92/n8GOcDVp_o.png" width="1200"></p> 
<h6>代码如下</h6> 
<pre><code class="hljs">class Solution {
    public boolean isValid(String s) {
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();
        for(int i = 0;i &lt; s.length();i++){
            char ch = s.charAt(i);
            if(ch == '(' || ch == '[' || ch == '{'){
                stack.push(ch);
            }else{
                if(stack.isEmpty()){
                    return false;
                }
                char top = stack.peek();
                if(top == '(' &amp;&amp; ch == ')'){
                    stack.pop();
                }else if(top == '[' &amp;&amp; ch == ']'){
                    stack.pop();
                }else if(top == '{' &amp;&amp; ch == '}'){
                    stack.pop();
                }else{
                    return false;
                }
            }
        }
        return stack.isEmpty();
    }
}
</code></pre> 
<h5><a href="https://leetcode-cn.com/problems/min-stack/" rel="nofollow" title="155. 最小栈">155. 最小栈</a></h5> 
<p>这题大概是这么个意思：要求我们实现一个栈，能以时间复杂度O(1)，找到栈中最小的元素。<br> 其中 top ，其实就是 peek方法：查看栈顶数据。</p> 
<h6 style="margin-left:0;"><span style="color:#4f4f4f;"><span style="background-color:#ffffff;">解题思维</span></span></h6> 
<blockquote> 
 <p style="margin-left:0;"><span style="color:#555666;">首先，我们需要明白一个问题：能以时间复杂度O(1)，找到栈中最小的元素是不可能的。<br> 因为需要再遍历数组一遍，才能确定最小值。时间复杂度达到O(N)…<br> 那么，既然一个不行，那我两个！<br> 来看我怎么做：</span></p> 
</blockquote> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/a0/b0/fWm87Zrt_o.png" width="1200"></p> 
<h6>代码如下</h6> 
<pre><code class="hljs">class MinStack {
    private Stack&lt;Integer&gt; stack;
    private Stack&lt;Integer&gt; stackMin;
    public MinStack() {
        stack = new Stack&lt;&gt;();
        stackMin = new Stack&lt;&gt;();
    }
    //入栈
    public void push(int val) {
        stack.push(val);
        if(stackMin.isEmpty()){
            stackMin.push(val);
        }else{
            if(val &lt;= stackMin.peek()){
                stackMin.push(val);
            }
        }

    }
    // 出栈
    public void pop() {
        if(!stack.isEmpty()){
            int val = stack.pop();
            if(val == stackMin.peek()){
                stackMin.pop();
            }
        }

    }
    // 等价于 peek方法
    public int top() {
        return stack.peek();

    }
    // 和获取 目前 Stack 栈中最小值
    public int getMin() {
        return stackMin.peek();
    }
}
</code></pre> 
<h3 style="margin-left:0;"><span style="color:#4f4f4f;"><span style="background-color:#ffffff;">队列</span></span></h3> 
<blockquote> 
 <p style="margin-left:0;"><span style="color:#555666;">普通队列【queue】：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出FIFO(First In First Out) 入队列：进行插入操作的一端称为队尾（Tail/Rear） 出队列：进行删除操作的一端称为队头。<br><span style="color:#FF0000;">双端队列【deque】： 出队 和 入队，则没有像普通队列那样的限制。 无论是 队头 还是 队尾，都可以出入队。</span></span></p> 
</blockquote> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/bd/6f/Zdu6JCK3_o.png" width="1200"></p> 
<p>看过上面的图，我们 可以知道 双向队列，可以用来实现 栈 。因为队尾队头都可以入出对，也就是说肯定会有一个 标识 队头 和 队尾的属性，我们就可以通过这个来用队列 实现 栈 。（这个deque 会有相对应的功能 可以用来实现 栈，可以参考下方的 deque 功能展示）<br> 再来看看 集合框架背后的数据结构图。</p> 
<p><img alt="" height="811" src="https://images2.imgbox.com/08/88/asZlB38z_o.png" width="1200"></p> 
<p>当然也可以 直接通过 LinkedList 实现类 来 new LinkedList 对象。因为 LInkedList 类 实现了 deque 和 queue。再加上它自身的功能，说明LinkedList 的功能 只会 更多。</p> 
<p><img alt="" height="890" src="https://images2.imgbox.com/91/e7/FjuvjApW_o.png" width="314"></p> 
<h4>queue【队列】 和 deque【双端队列】所具有的功能</h4> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/20/15/8RebtP0n_o.png" width="1200"></p> 
<h5>普通队列 queue 基础功能 分析 与 区别</h5> 
<h6><a id="add___offer__465"></a>add 和 offer 入栈方法的区别</h6> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/7d/ec/GTUNnrPT_o.png" width="1200"></p> 
<h6>peek 和 element 返回队顶数据 方法的区别</h6> 
<p><img alt="" height="721" src="https://images2.imgbox.com/d7/0f/yC42uFYx_o.png" width="1200"></p> 
<h6>poll 和 remove 出队方法的区别</h6> 
<p><img alt="" height="745" src="https://images2.imgbox.com/20/e2/rAQu3asQ_o.png" width="1200"></p> 
<p><img alt="" height="298" src="https://images2.imgbox.com/b5/21/CyhUgJNY_o.png" width="1109"></p> 
<h5>双端队列【deque】的基础功能演示</h5> 
<p><img alt="" height="765" src="https://images2.imgbox.com/06/09/W4zmHajr_o.png" width="1200"></p> 
<h6>功能细节</h6> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/67/8b/jvLS6Ktd_o.png" width="1200"></p> 
<p>讲这个是为了表明一个点：如果只是一些简单的方法，可以通过接口去引用。不用直接去new 实现类<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/ec/47/0Fj8pCWa_o.png"></p> 
<h6 style="margin-left:0;"><span style="color:#4f4f4f;"><span style="background-color:#ffffff;">总结</span></span></h6> 
<blockquote> 
 <p style="margin-left:0;"><span style="color:#555666;">特殊值返回值 和 异常，跟上的普通队列返回值是一样的。<br><span style="color:#FF0000;">返回特殊值的方法，都是最常用的方法。</span></span><img alt="" height="298" src="https://images2.imgbox.com/29/2a/vQnOgbtB_o.png" width="1075"></p> 
</blockquote> 
<h4 style="margin-left:0;"><span style="color:#4f4f4f;"><span style="background-color:#ffffff;">总结</span></span></h4> 
<blockquote> 
 <p style="margin-left:0;"><span style="color:#555666;">对于 LinkedList 来说：它不仅可以当作普通的队列、双端队列、双向链表，栈 来使用。<br> 对于 LinkedList 来说，它有一项比较尴尬的功能 addIndex 给 某个下标添加一个元素</span></p> 
</blockquote> 
<p><img alt="" height="320" src="https://images2.imgbox.com/fa/bd/AtcyGlVc_o.png" width="1200"></p> 
<p><span style="color:#555666;"><span style="background-color:#eef0f4;">要知道，链表是没有下标的！</span></span><br><span style="color:#FF0000;">由此引申出 一个问题 ：<br> 顺序表 和 链表 的区别是什么？<br> ArrrayList 和 LinkedList 的区别是什么？（这个问的最多）<br> 解答：<br> 1、从共性出发：增删查改<br> 【ArrrayList支持 随机 访问，LinkedList不支持。因为链表没有下标】<br> 【 LinkedList 删除和添加元素 时间复杂 ArrrayList 要比 低，因为 不需要像顺序表做整体的位移。】<br> 2、 从内存的逻辑出发<br> 【ArrrayList 是一个顺序存储(底层为一个数组) ，内存 在 理论 和 物理上 都是 连续的】<br> 【 LinkedList 是一个链式存储(由一个个节点连接而成)，内存在理论上是连续的，在物理上不是连续的（因为不可能说每次new的节点，都是和原来的节点是紧挨着的！因为 new 对象，它是哪里有位置，它new哪里，没有规律的）】</span></p> 
<h4 style="margin-left:0;"><span style="color:#4f4f4f;"><span style="background-color:#ffffff;">模拟实现 普通队列（Queue） - 单链表实现。</span></span></h4> 
<blockquote> 
 <p style="margin-left:0;"><span style="color:#555666;">需要考虑的一点就是 哪边当队头，哪边当队尾？</span></p> 
</blockquote> 
<p><img alt="" height="1024" src="https://images2.imgbox.com/80/eb/Plf0hZXO_o.png" width="1039"></p> 
<p>当然，你可以用双向链表来实现，那就很简单了！！！ 所以我们这里才使用 单向链表实现</p> 
<h6>代码如下</h6> 
<pre><code class="hljs">public class TestDemo {
    public static void main(String[] args) {
        MyQueue myQueue = new MyQueue();
        myQueue.offer(1);// 入队
        myQueue.offer(2);
        // 出队
        try{
            System.out.println(myQueue.poll().val);// 1
        }catch (NullPointerException e){
            e.printStackTrace();
            System.out.println("队列为空 【poll】");
        }
        // 返回头数据
        try {
            System.out.println(myQueue.peek().val);// 2
        }catch (NullPointerException e){
            e.printStackTrace();
            System.out.println("队列为空【peek】");
        }
    }
}

</code></pre> 
<p>附图</p> 
<p><img alt="" height="773" src="https://images2.imgbox.com/5b/59/QyoqdVUo_o.png" width="1200"></p> 
<h6>主程序2</h6> 
<p><img alt="" height="759" src="https://images2.imgbox.com/cb/32/yZyfEfTu_o.png" width="1200"></p> 
<h6>队列实现</h6> 
<pre><code class="hljs">public class MyQueue {
    Node head;// 队头
    Node tail;// 队尾

    public void offer(int x){
        if(head == null){// 第一次入队
            head = new Node(x);
            tail = head;
        }else{// 从队尾 入队
            tail.next =  new Node(x);
            this.tail = this.tail.next;
        }
    }

    public Node poll(){
        if(head == null){// 队列为 空，返回 null
            return head;
        }
        Node node = head;
        this.head = head.next;
        return node;// 返回删除的头
    }

    public Node peek(){
        return head;
    }

}
</code></pre> 
<h4 style="margin-left:0;"><span style="color:#4f4f4f;"><span style="background-color:#ffffff;">循环队列</span></span></h4> 
<blockquote> 
 <p style="margin-left:0;"><span style="color:#555666;">实际中我们有时还会使用一种队列 叫 循环队列。如操作系统课程讲解生产者消费者模型时可以就会使用循环队列。<br> 环形队列通常使用数组实现。</span></p> 
 <p style="margin-left:0;"><img alt="" height="1200" src="https://images2.imgbox.com/09/78/BhAkQJ7j_o.png" width="1200"></p> 
</blockquote> 
<p>队列面试题</p> 
<h5><a href="https://leetcode-cn.com/problems/design-circular-queue/" rel="nofollow" title="LeetCode - 622. 设计循环队列">LeetCode - 622. 设计循环队列</a></h5> 
<h6>解题思维 与 步骤 - 使用第三种判断循环队列的方法</h6> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/95/1b/CaJXoSCy_o.png" width="1200"></p> 
<h6>代码如下</h6> 
<pre><code class="hljs">class MyCircularQueue {
    int[] elements;
    int front;
    int rear;
    public MyCircularQueue(int k) {
        elements = new int[k+ 1];
    }
    
    public boolean enQueue(int value) {
        if(isFull()){
            return false;
        }
        elements[rear] = value;
        rear = (rear+1)%elements.length;
        return true;
    }
    
    public boolean deQueue() {
        if(isEmpty()){
            return false;
        }
        front = (front+1)%elements.length;
        return true;
    }
    
    public int Front() {
        if(isEmpty()){
            return -1;
        }
        return elements[front];
    }
    
    public int Rear() {
        if(isEmpty()){
            return -1;
        }
        int index = 0;
        if(rear == 0){
            index = elements.length - 1;
        }else{
            index = rear - 1;
        }
        return elements[index];
    }
    
    public boolean isEmpty() {
        return front == rear;
    }
    
    public boolean isFull() {
        if((rear+1)%elements.length == front){
            return true;
        }
        return false;
    }
}
</code></pre> 
<h5><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" rel="nofollow" title="LeetCode - 232. 用栈实现队列">LeetCode - 232. 用栈实现队列</a></h5> 
<h6 style="margin-left:0;"><span style="color:#4f4f4f;"><span style="background-color:#ffffff;">解题思维</span></span></h6> 
<blockquote> 
 <p style="margin-left:0;"><span style="color:#555666;">很简单， 栈 的特性是：先进后出。也就是说第一个入栈的数据，将是最后一个出栈，<br> 我们利用两个栈来实现这题。</span></p> 
 <p style="margin-left:0;"><img alt="" height="879" src="https://images2.imgbox.com/c3/cf/3ideOAL6_o.png" width="1200"></p> 
</blockquote> 
<h6>代码如下</h6> 
<pre><code class="hljs">class MyQueue {
    Stack&lt;Integer&gt; stack1;
    Stack&lt;Integer&gt; stack2;
    public MyQueue() {
        stack1 = new Stack&lt;&gt;();
        stack2 = new Stack&lt;&gt;();
    }
    
    public void push(int x) {
        stack1.push(x);
    }
    
    public int pop() {
        if(stack2.isEmpty()){
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
    
    public int peek() {
    // 防止 别人一开始 就调用 peek，所以 peek 也需要 写 stack1 导入 stack2 的程序
        if(stack2.isEmpty()){
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
        }
        return stack2.peek();
    }
    
    public boolean empty() {// 如果模拟的队列 将全部数据出队，那么 stack1 和 stack2 都为空
        return stack1.isEmpty() &amp;&amp; stack2.isEmpty();
    }
}
</code></pre>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b1eec3e8a64c4ab33b3ef90ce2c2601b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pymssql._pymssql.OperationalError处理方法python无法连接sqlserver2008r2 的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d999d12ed2b0a5127ed8412cacaf4b6e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python中的列表是什么</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>