<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring Boot 配置外部化中文文档 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring Boot 配置外部化中文文档" />
<meta property="og:description" content="本文为官方文档直译版本。原文链接
Spring Boot 配置外部化中文文档 前言访问命令行属性JSON 应用程序属性外部应用程序属性可选位置通配符位置特定配置文件导入附加数据导入无扩展名的文件使用配置树属性占位符使用多文档文件 激活属性加密属性使用 YAML映射 YAML 到属性直接加载 YAML 配置随机值设置系统环境属性类型安全的配置属性JavaBean 属性绑定构造函数绑定启用 @ConfigurationProperties使用 @ConfigurationProperties第三方配置宽松绑定绑定Map从环境变量绑定缓存 合并复杂类型属性转换转换Duration转换Period转换DataSize @ConfigurationProperties 验证@ConfigurationProperties 对比 @Value 前言 Spring Boot 允许您将配置外部化，这样您就可以在不同的环境中使用相同的应用程序代码。您可以使用各种外部配置源，包括 Java 属性文件、YAML 文件、环境变量和命令行参数。
属性值可以通过 @Value 注解直接注入到 Bean 中，也可以通过 Spring 的Environment抽象访问，还可以通过 @ConfigurationProperties 绑定到结构化对象中。
Spring Boot 使用一种非常特殊的 PropertySource 顺序，旨在允许对值进行合理的覆盖。后面的属性源可以覆盖前面属性源中定义的值。属性源按以下顺序考虑：
默认属性（通过设置 SpringApplication.setDefaultProperties 指定）。配置类上的 @PropertySource 注解。请注意，在应用程序上下文刷新之前，此类属性源不会添加到环境中。这对于配置某些属性（如 logging.* 和 spring.main.*）来说为时已晚，因为这些属性是在刷新开始前读取的。配置数据（如 application.properties 文件）。RandomValuePropertySource 只包含 random.* 中的属性。操作系统环境变量。Java 系统属性（System.getProperties()）。来自 java:comp/env.NET 的 JNDI 属性。ServletContext 初始参数。ServletConfig 初始参数。SPRING_APPLICATION_JSON 中的属性（嵌入到环境变量或系统属性中的内联 JSON）。命令行参数。测试属性 在 @SpringBootTest 和测试注解中可用，用于测试应用程序的特定片段。在测试中使用 @DynamicPropertySource 注解。测试中的 @TestPropertySource 注解。Devtools 激活时，$HOME/." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/f43e0a2cfc8bc6c046963d187fcfbb93/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-14T15:05:02+08:00" />
<meta property="article:modified_time" content="2023-12-14T15:05:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring Boot 配置外部化中文文档</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>本文为官方文档直译版本。<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config" rel="nofollow">原文链接</a></p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>Spring Boot 配置外部化中文文档</h4> 
 <ul><li><ul><li><a href="#_4" rel="nofollow">前言</a></li><li><a href="#_55" rel="nofollow">访问命令行属性</a></li><li><a href="#JSON__58" rel="nofollow">JSON 应用程序属性</a></li><li><a href="#_77" rel="nofollow">外部应用程序属性</a></li><li><ul><li><a href="#_122" rel="nofollow">可选位置</a></li><li><a href="#_127" rel="nofollow">通配符位置</a></li><li><a href="#_136" rel="nofollow">特定配置文件</a></li><li><a href="#_160" rel="nofollow">导入附加数据</a></li><li><a href="#_194" rel="nofollow">导入无扩展名的文件</a></li><li><a href="#_202" rel="nofollow">使用配置树</a></li><li><a href="#_262" rel="nofollow">属性占位符</a></li><li><a href="#_276" rel="nofollow">使用多文档文件</a></li></ul> 
   </li><li><a href="#_306" rel="nofollow">激活属性</a></li><li><a href="#_328" rel="nofollow">加密属性</a></li><li><a href="#_YAML_331" rel="nofollow">使用 YAML</a></li><li><ul><li><a href="#_YAML__335" rel="nofollow">映射 YAML 到属性</a></li><li><a href="#_YAML_369" rel="nofollow">直接加载 YAML</a></li></ul> 
   </li><li><a href="#_372" rel="nofollow">配置随机值</a></li><li><a href="#_384" rel="nofollow">设置系统环境属性</a></li><li><a href="#_387" rel="nofollow">类型安全的配置属性</a></li><li><ul><li><a href="#JavaBean__391" rel="nofollow">JavaBean 属性绑定</a></li><li><a href="#_436" rel="nofollow">构造函数绑定</a></li><li><a href="#_ConfigurationProperties_485" rel="nofollow">启用 @ConfigurationProperties</a></li><li><a href="#_ConfigurationProperties_521" rel="nofollow">使用 @ConfigurationProperties</a></li><li><a href="#_557" rel="nofollow">第三方配置</a></li><li><a href="#_577" rel="nofollow">宽松绑定</a></li><li><ul><li><a href="#Map_618" rel="nofollow">绑定Map</a></li><li><a href="#_632" rel="nofollow">从环境变量绑定</a></li><li><a href="#_644" rel="nofollow">缓存</a></li></ul> 
    </li><li><a href="#_646" rel="nofollow">合并复杂类型</a></li><li><a href="#_741" rel="nofollow">属性转换</a></li><li><ul><li><a href="#Duration_744" rel="nofollow">转换Duration</a></li><li><a href="#Period_796" rel="nofollow">转换Period</a></li><li><a href="#DataSize_811" rel="nofollow">转换DataSize</a></li></ul> 
    </li><li><a href="#ConfigurationProperties__860" rel="nofollow">@ConfigurationProperties 验证</a></li><li><a href="#ConfigurationProperties__Value_904" rel="nofollow">@ConfigurationProperties 对比 @Value</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_4"></a>前言</h3> 
<p>Spring Boot 允许您将配置外部化，这样您就可以在不同的环境中使用相同的应用程序代码。您可以使用各种外部配置源，包括 Java 属性文件、YAML 文件、环境变量和命令行参数。<br> 属性值可以通过 <code>@Value</code> 注解直接注入到 Bean 中，也可以通过 Spring 的<code>Environment</code>抽象访问，还可以通过 <code>@ConfigurationProperties</code> 绑定到结构化对象中。<br> Spring Boot 使用一种非常特殊的 <code>PropertySource</code> 顺序，旨在允许对值进行合理的覆盖。后面的属性源可以覆盖前面属性源中定义的值。属性源按以下顺序考虑：</p> 
<ol><li>默认属性（通过设置 <code>SpringApplication.setDefaultProperties</code> 指定）。</li><li>配置类上的 <code>@PropertySource</code> 注解。请注意，在应用程序上下文刷新之前，此类属性源不会添加到环境中。这对于配置某些属性（如 <code>logging.*</code> 和 <code>spring.main.*</code>）来说为时已晚，因为这些属性是在刷新开始前读取的。</li><li>配置数据（如 <code>application.properties</code> 文件）。</li><li><code>RandomValuePropertySource</code> 只包含 <code>random.*</code> 中的属性。</li><li>操作系统环境变量。</li><li>Java 系统属性（<code>System.getProperties()</code>）。</li><li>来自 <code>java:comp/env.NET</code> 的 JNDI 属性。</li><li><code>ServletContext</code> 初始参数。</li><li><code>ServletConfig</code> 初始参数。</li><li><code>SPRING_APPLICATION_JSON</code> 中的属性（嵌入到环境变量或系统属性中的内联 JSON）。</li><li>命令行参数。</li><li>测试属性 在 <code>@SpringBootTest</code> 和测试注解中可用，用于测试应用程序的特定片段。</li><li>在测试中使用 <code>@DynamicPropertySource</code> 注解。</li><li>测试中的 <code>@TestPropertySource</code> 注解。</li><li>Devtools 激活时，<code>$HOME/.config/spring-boot</code> 目录中的 Devtools 全局设置属性。</li></ol> 
<p>配置数据文件按以下顺序考虑：</p> 
<ol><li>打包在 jar 中的应用程序属性（<code>application.properties</code> 和 YAML 变体）。</li><li>打包在 jar 中的特定于配置文件的应用程序属性（<code>application-{profile}.properties</code> 和 YAML 变体）。</li><li>打包在 jar 之外的应用程序属性（<code>application.properties</code> 和 YAML 变体）。</li><li>打包的 jar 之外的特定配置文件应用程序属性（<code>application-{profile}.properties</code> 和 YAML 变体）。</li></ol> 
<blockquote> 
 <p>建议整个应用程序使用一种格式。如果在同一位置同时存在 <code>.properties</code> 和 YAML 格式的配置文件，则 <code>.properties</code> 优先。</p> 
</blockquote> 
<blockquote> 
 <p>如果使用环境变量而不是系统属性，大多数操作系统不允许使用以句点分隔的键名，但可以使用下划线代替（例如，用 <code>SPRING_CONFIG_NAME</code> 代替 <code>spring.config.name</code>）。详情请参阅从环境变量绑定。</p> 
</blockquote> 
<blockquote> 
 <p>如果应用程序在 servlet 容器或应用程序服务器中运行，则可以使用 JNDI 属性（<code>java:comp/env</code> 中）或 servlet 上下文初始化参数来代替或与环境变量或系统属性一样使用。</p> 
</blockquote> 
<p>举个具体例子，假设你开发了一个使用 <code>name</code> 属性的 <code>@Component</code>，如下例所示：</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Value</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBean</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${name}"</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>

    <span class="token comment">// ...</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>在应用程序的 classpath 中（例如，在 jar 中），可以有一个 <code>application.properties</code> 文件，为 <code>name</code> 提供一个合理的默认属性值。在新环境中运行时，可以在 jar 之外提供一个 <code>application.properties</code> 文件来覆盖 <code>name</code>。对于一次性测试，可以使用特定的命令行开关启动（例如，<code>java -jar app.jar --name="Spring"</code> ）。</p> 
<blockquote> 
 <p><code>env</code> 和 <code>configprops</code> 端点有助于确定属性具有特定值的原因。你可以使用这两个端点来诊断意外的属性值。有关详情，请参阅 "生产就绪功能 "部分。</p> 
</blockquote> 
<h3><a id="_55"></a>访问命令行属性</h3> 
<p>默认情况下，<code>SpringApplication</code> 会将任何命令行选项参数（即以 <code>--</code> 开头的参数，如 <code>--server.port=9000</code>）转换为属性，并将其添加到 Spring <code>Environment</code> 中。如前所述，命令行属性总是优先于基于文件的属性源。<br> 如果不想将命令行属性添加到环境中，可以使用 <code>SpringApplication.setAddCommandLineProperties(false)</code> 将其禁用。</p> 
<h3><a id="JSON__58"></a>JSON 应用程序属性</h3> 
<p>环境变量和系统属性通常有一些限制，意味着某些属性名称不能使用。为了帮助解决这个问题，Spring Boot 允许您将一组属性编码为单一的 JSON 结构。<br> 当应用程序启动时，<code>spring.application.json</code> 或 <code>SPRING_APPLICATION_JSON</code> 属性将被解析并添加到环境中。<br> 例如，<code>SPRING_APPLICATION_JSON</code> 属性可以作为环境变量在 UNIX shell 的命令行中提供：</p> 
<pre><code class="prism language-shell">$ <span class="token assign-left variable">SPRING_APPLICATION_JSON</span><span class="token operator">=</span><span class="token string">'{"my":{"name":"test"}}'</span> <span class="token function">java</span> <span class="token parameter variable">-jar</span> myapp.jar
</code></pre> 
<p>在前面的示例中，Spring <code>Environment</code>中的 <code>my.name=test</code> 就是这样结束的。<br> 同样的 JSON 也可以作为系统属性提供：</p> 
<pre><code class="prism language-shell">$ <span class="token function">java</span> <span class="token parameter variable">-Dspring.application.json</span><span class="token operator">=</span><span class="token string">'{"my":{"name":"test"}}'</span> <span class="token parameter variable">-jar</span> myapp.jar
</code></pre> 
<p>或者，您也可以使用命令行参数提供 JSON：</p> 
<pre><code class="prism language-shell">$ <span class="token function">java</span> <span class="token parameter variable">-jar</span> myapp.jar <span class="token parameter variable">--spring.application.json</span><span class="token operator">=</span><span class="token string">'{"my":{"name":"test"}}'</span>
</code></pre> 
<p>如果要部署到经典应用服务器，也可以使用名为 <code>java:comp/env/spring.application.json</code> 的 JNDI 变量。</p> 
<blockquote> 
 <p>虽然 JSON 中的空值会被添加到生成的属性源中，但 <code>PropertySourcesPropertyResolver</code> 会将空属性视为缺失值。这意味着 JSON 无法用空值覆盖低阶属性源中的属性。</p> 
</blockquote> 
<h3><a id="_77"></a>外部应用程序属性</h3> 
<p>Spring Boot 会在应用程序启动时自动从以下位置查找并加载 <code>application.properties</code> 和 <code>application.yaml</code> 文件：</p> 
<ol><li>来自类路径 
  <ol><li>类路径根目录</li><li>类路径 <code>/config</code> 包</li></ol> </li><li>从当前目录 
  <ol><li>当前目录</li><li>当前目录中的 <code>config/</code> 子目录</li><li><code>config/</code> 子目录的直接子目录</li></ol> </li></ol> 
<p>该列表按优先级排序（较低项目的值优先于较早项目的值）。加载文件中的文档将作为 <code>PropertySources</code> 添加到 Spring <code>Environment</code> 中。<br> 如果不喜欢使用 <code>application</code> 作为配置文件名，可以通过指定 <code>spring.config.name</code> 环境属性切换到其他文件名。例如，要查找 <code>myproject.properties</code> 和 <code>myproject.yaml</code> 文件，可以按如下方式运行应用程序：</p> 
<pre><code class="prism language-shell">$ <span class="token function">java</span> <span class="token parameter variable">-jar</span> myproject.jar <span class="token parameter variable">--spring.config.name</span><span class="token operator">=</span>myproject
</code></pre> 
<p>您还可以使用 <code>spring.config.location</code> 环境属性来引用明确的位置。该属性接受一个以逗号分隔的列表，其中包含一个或多个要检查的位置。<br> 下面的示例显示了如何指定两个不同的文件：</p> 
<pre><code class="prism language-shell">$ <span class="token function">java</span> <span class="token parameter variable">-jar</span> myproject.jar <span class="token parameter variable">--spring.config.location</span><span class="token operator">=</span><span class="token punctuation">\</span>
    optional:classpath:/default.properties,<span class="token punctuation">\</span>
    optional:classpath:/override.properties
</code></pre> 
<blockquote> 
 <p>如果位置是可选的，并且您不介意它们不存在，请使用前缀 <code>optional:</code> 。</p> 
</blockquote> 
<blockquote> 
 <p><code>spring.config.name</code>、<code>spring.config.location</code> 和 <code>spring.config.additional-location</code> 很早就用于确定需要加载的文件。它们<strong>必须定义为环境属性</strong>（通常是操作系统环境变量、系统属性或命令行参数）。</p> 
</blockquote> 
<p>如果 <code>spring.config.location</code> 包含目录（而非文件），则应以 <code>/</code> 结尾。运行时，在加载这些目录之前，它们会被附加上由 <code>spring.config.name</code> 生成的名称。在 <code>spring.config.location</code> 中指定的文件将被直接导入。</p> 
<blockquote> 
 <p>目录和文件位置值也会扩展，以检查特定配置文件。例如，如果 <code>spring.config.location</code> 为 <code>classpath:myconfig.properties</code>，则也会加载相应的 <code>classpath:myconfig-&lt;profile&gt;.properties</code> 文件。</p> 
</blockquote> 
<p>在大多数情况下，你添加的每个 <code>spring.config.location</code> 项都将引用一个文件或目录。位置按照定义的顺序进行处理，后面的位置可以覆盖前面位置的值。<br> 如果您有复杂的位置设置，并且使用了特定于配置文件的配置文件，您可能需要提供进一步的提示，以便 Spring Boot 知道应该如何对它们进行分组。位置组是在同一级别考虑的位置的集合。例如，您可能想分组所有 <code>classpath</code> 位置，然后是所有外部位置。位置组内的项目应以 <code>;</code> 分隔。更多详情，请参阅 "配置文件特定文件 "部分的示例。<br> 使用 <code>spring.config.location</code> 配置的位置会取代默认位置。例如，如果在配置 <code>spring.config.location</code> 时使用了 <code>optional:classpath:/custom-config/,optional:file:./custom-config/ </code>值，则考虑的完整位置集为</p> 
<ol><li><code>optional:classpath:custom-config/</code></li><li><code>optional:file:./custom-config/</code></li></ol> 
<p>如果要添加额外位置而不是替换它们，可以使用 <code>spring.config.additional-location</code>。从附加位置加载的属性可以覆盖默认位置中的属性。例如，如果将 <code>spring.config.additional-location</code> 配置为 <code>optional:classpath:/custom-config/,optional:file:./custom-config/</code> 值，则考虑的完整位置集为：</p> 
<ol><li><code>optional:classpath:/;optional:classpath:/config/</code></li><li><code>optional:file:./;optional:file:./config/;optional:file:./config/*/</code></li><li><code>optional:classpath:custom-config/</code></li><li><code>optional:file:./custom-config/</code></li></ol> 
<p>这种搜索排序方式可让你在一个配置文件中指定默认值，然后在另一个配置文件中选择性地覆盖这些值。你可以在其中一个默认位置的 <code>application.properties</code>（或用 <code>spring.config.name</code> 选择的其他基名）中为你的应用程序提供默认值。这些默认值可在运行时用位于自定义位置之一的不同文件覆盖。</p> 
<h4><a id="_122"></a>可选位置</h4> 
<p>默认情况下，当指定的配置数据位置不存在时，Spring Boot 会抛出 <code>ConfigDataLocationNotFoundException</code> 异常，应用程序将无法启动。<br> 如果你想指定一个位置，但又不介意它并不总是存在，你可以使用<code>optional:</code>前缀。您可以在 <code>spring.config.location</code> 和 <code>spring.config.additional-location</code> 属性以及 <code>spring.config.import</code> 声明中使用该前缀。<br> 例如，<code>spring.config.import</code> 值为 <code>optional:file:./myconfig.properties</code> 时，即使缺少 <code>myconfig.properties</code> 文件，应用程序也能启动。<br> 如果想忽略所有 <code>ConfigDataLocationNotFoundException</code> 并始终继续启动应用程序，可以使用 <code>spring.config.on-not-found</code> 属性。使用 <code>SpringApplication.setDefaultProperties(...)</code> 或系统/环境变量设置忽略值。</p> 
<h4><a id="_127"></a>通配符位置</h4> 
<p>如果配置文件位置的最后一个路径段包含 <code>*</code> 字符，则视为通配符位置。通配符会在加载配置时展开，因此直接子目录也会被检查。在 Kubernetes 等环境中，当配置属性有多个来源时，通配符位置尤其有用。<br> 例如，如果您有一些 Redis 配置和一些 MySQL 配置，您可能希望将这两项配置分开，同时要求这两项配置都存在于一个 <code>application.properties</code> 文件中。这可能会导致两个独立的 <code>application.properties </code>文件被挂载到不同的位置，如 <code>/config/redis/application.properties</code> 和 <code>/config/mysql/application.properties</code>。在这种情况下，使用 <code>config/*/</code> 通配符位置将导致两个文件都被处理。<br> 默认情况下，Spring Boot 在默认搜索位置中包含 <code>config/*/</code>。这意味着将搜索 jar 之外 <code>/config</code> 目录的所有子目录。<br> 你可以通过 <code>spring.config.location</code> 和 <code>spring.config.additional-location</code> 属性使用通配符位置。</p> 
<blockquote> 
 <p>通配符位置必须只包含一个 <code>*</code>，搜索目录位置时以 <code>*/</code> 结尾，搜索文件位置时以 <code>*/&lt;filename&gt;</code> 结尾。带有通配符的位置会根据文件名的绝对路径按字母顺序排序。</p> 
</blockquote> 
<blockquote> 
 <p>通配符位置只适用于外部目录。不能在 <code>classpath:</code> 位置中使用通配符。</p> 
</blockquote> 
<h4><a id="_136"></a>特定配置文件</h4> 
<p>除了应用程序属性文件外，Spring Boot 还会尝试使用命名约定 <code>application-{profile}</code> 加载特定于配置文件的文件。例如，如果您的应用程序激活了名为 <code>prod</code> 的配置文件并使用 YAML 文件，那么 <code>application.yaml</code> 和 <code>application-prod.yaml</code> 都将被考虑。<br> 特定配置文件属性的加载位置与标准 <code>application.properties</code> 相同，特定配置文件总是优先于非特定文件。如果指定了多个配置文件，则采用后胜策略。例如，如果通过 <code>spring.profiles.active</code> 属性指定了配置文件 <code>prod、live</code>，<code>application-prod.properties</code> 中的值就会被 <code>application-live.properties</code> 中的值覆盖。</p> 
<blockquote> 
 <p>后胜策略适用于位置组级别。<code>spring.config.location</code> 的 <code>classpath:/cfg/,classpath:/ext/</code> 与 <code>classpath:/cfg/;classpath:/ext/</code> 的覆盖规则不同。<br> 例如，继续上面的 <code>prod,live</code> 实例，我们可能会有以下文件：</p> 
 <ul><li>/cfg 
   <ul><li>application-live.properties</li></ul> </li><li>/ext 
   <ul><li>application-live.properties</li><li>application-prod.properties</li></ul> </li></ul> 
</blockquote> 
<p>当我们的 <code>spring.config.location</code> 为 <code>classpath:/cfg/,classpath:/ext/</code> 时，我们会先处理所有 <code>/cfg</code> 文件，然后再处理所有 <code>/ext</code> 文件。</p> 
<blockquote> 
 <ol><li><code>/cfg/application-live.properties</code></li><li><code>/ext/application-prod.properties</code></li><li><code>/ext/application-live.properties</code></li></ol> 
</blockquote> 
<p>如果使用 <code>classpath:/cfg/;classpath:/ext/</code>（使用 <code>;</code> 分隔符），我们将在同一级别处理 <code>/cfg</code> 和 <code>/ext</code>：</p> 
<blockquote> 
 <ol><li><code>/ext/application-prod.properties</code></li><li><code>/cfg/application-live.properties</code></li><li><code>/ext/application-live.properties</code></li></ol> 
</blockquote> 
<p>环境有一组默认配置文件（默认为 <code>[default]</code>），如果没有设置激活的配置文件，就会使用这些配置文件。换句话说，如果没有明确激活任何配置文件，则会考虑<code>application-default</code>配置文件中的属性。</p> 
<blockquote> 
 <p>属性文件只加载一次。如果您已经直接导入了某个配置文件的特定属性文件，则不会再导入第二次。</p> 
</blockquote> 
<h4><a id="_160"></a>导入附加数据</h4> 
<p>应用程序属性可使用 <code>spring.config.import</code> 属性从其他位置导入更多配置数据。导入会在被发现时进行处理，并被视为紧接在声明导入的文件下方插入的附加文件。<br> 例如，在你的类路径下 <code>application.properties</code> 文件中可能有以下内容：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">"myapp"</span>
  <span class="token key atrule">config</span><span class="token punctuation">:</span>
    <span class="token key atrule">import</span><span class="token punctuation">:</span> <span class="token string">"optional:file:./dev.properties"</span>
</code></pre> 
<p>这将触发导入当前目录下的 <code>dev.properties</code> 文件（如果存在此类文件）。导入的 <code>dev.properties</code> 中的值将优先于触发导入的文件。在上例中，<code>dev.properties</code> 可以将 <code>spring.application.name</code> 重新定义为不同的值。<br> 无论导入声明多少次，都只能导入一次。导入在 properties/yaml 文件的单个文档中定义的顺序并不重要。例如，下面两个示例产生的结果是一样的：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">config</span><span class="token punctuation">:</span>
    <span class="token key atrule">import</span><span class="token punctuation">:</span> <span class="token string">"my.properties"</span>
<span class="token key atrule">my</span><span class="token punctuation">:</span>
  <span class="token key atrule">property</span><span class="token punctuation">:</span> <span class="token string">"value"</span>
</code></pre> 
<pre><code class="prism language-yaml"><span class="token key atrule">my</span><span class="token punctuation">:</span>
  <span class="token key atrule">property</span><span class="token punctuation">:</span> <span class="token string">"value"</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">config</span><span class="token punctuation">:</span>
    <span class="token key atrule">import</span><span class="token punctuation">:</span> <span class="token string">"my.properties"</span>
</code></pre> 
<p>在上述两个示例中，<code>my.properties</code> 文件中的值优先于触发导入的文件。<br> 可在单个 <code>spring.config.import</code> 关键字下指定多个位置。位置将按照定义的顺序进行处理，后导入的位置优先。</p> 
<blockquote> 
 <p>在适当情况下，也会考虑导入特定配置文件的变量。上例将同时导入 <code>my.properties</code> 和任何 <code>my-&lt;profile&gt;.properties</code> 变体。</p> 
</blockquote> 
<blockquote> 
 <p>Spring Boot 包含可插拔的 API，允许支持各种不同的位置地址。默认情况下，您可以导入 Java 属性、YAML 和 “配置树”。<br> 第三方 jar 可以提供对其他技术的支持（不要求文件是本地的）。例如，你可以想象配置数据来自外部存储，如 Consul、Apache ZooKeeper 或 Netflix Archaius。<br> 如果您想支持自己的位置，请参阅 <code>org.springframework.boot.context.config</code> 包中的 <code>ConfigDataLocationResolver</code> 和 <code>ConfigDataLoader</code> 类。</p> 
</blockquote> 
<h4><a id="_194"></a>导入无扩展名的文件</h4> 
<p>某些云平台无法为卷加载的文件添加文件扩展名。要导入这些无扩展名的文件，需要给 Spring Boot 一个提示，以便它知道如何加载这些文件。为此，您可以将扩展名提示放在方括号中。<br> 例如，假设您有一个 <code>/etc/config/myconfig</code> 文件，希望以 yaml 格式导入。你可以使用下面的方法从 <code>application.properties</code> 中导入该文件：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">config</span><span class="token punctuation">:</span>
    <span class="token key atrule">import</span><span class="token punctuation">:</span> <span class="token string">"file:/etc/config/myconfig[.yaml]"</span>
</code></pre> 
<h4><a id="_202"></a>使用配置树</h4> 
<p>在云平台（如 Kubernetes）上运行应用程序时，您经常需要读取平台提供的配置值。为此目的使用环境变量的情况并不少见，但这样做也有缺点，尤其是当配置值需要保密时。<br> 作为环境变量的替代方案，许多云平台现在都允许将配置映射到挂载的数据卷中。例如，Kubernetes 可以将<code>[ConfigMaps](https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#populate-a-volume-with-data-stored-in-a-configmap)</code> 和 <code>[Secrets](https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod)</code> 卷挂载。<br> 有两种常见的卷挂载模式可供选择：</p> 
<ol><li>单个文件包含一整套属性（通常写成 YAML）。</li><li>多个文件被写入一个目录树，文件名成为 “key”，内容成为 “value”。</li></ol> 
<p>对于第一种情况，可以如上所述使用 <code>spring.config.import</code> 直接导入 YAML 或 Properties 文件。对于第二种情况，您需要使用 <code>configtree:</code> 前缀，以便 Spring Boot 知道它需要将所有文件作为属性公开。<br> 举个例子，假设 Kubernetes 挂载了以下卷：</p> 
<pre><code>etc/
  config/
    myapp/
      username
      password
</code></pre> 
<p><code>username</code>文件的内容将是一个配置值，<code>password</code>的内容将是一个秘密。<br> 要导入这些属性，可以在 <code>application.properties</code> 或 <code>application.yaml</code> 文件中添加以下内容：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">config</span><span class="token punctuation">:</span>
    <span class="token key atrule">import</span><span class="token punctuation">:</span> <span class="token string">"optional:configtree:/etc/config/"</span>
</code></pre> 
<p>然后，您就可以通过常规方式从环境中访问或注入 <code>myapp.username</code> 和 <code>myapp.password</code> 属性。</p> 
<blockquote> 
 <p>配置树下的文件夹和文件名构成了属性名称。在上例中，要以<code>username</code>和<code>password</code>访问属性，可将 <code>spring.config.import</code> 设置为 <code>optional:configtree:/etc/config/myapp</code>。</p> 
</blockquote> 
<blockquote> 
 <p>使用点符号的文件名也能正确映射。例如，在上述示例中，<code>/etc/config</code> 中名为 <code>myapp.username</code> 的文件将导致<code>Environment</code>中的 <code>myapp.username</code> 属性。</p> 
</blockquote> 
<blockquote> 
 <p>配置树值可与字符串 <code>String</code> 和 <code>byte[]</code> 类型绑定，具体取决于预期的内容。</p> 
</blockquote> 
<p>如果要从同一父文件夹导入多个配置树，可以使用通配符快捷方式。任何以 <code>/*/</code> 结尾的 <code>configtree:</code> 位置都会将所有直接子文件夹导入为配置树。与非通配符导入一样，每个配置树下的文件夹和文件名构成了属性名。<br> 例如，给定以下卷：</p> 
<pre><code>etc/
  config/
    dbconfig/
      db/
        username
        password
    mqconfig/
      mq/
        username
        password
</code></pre> 
<p>您可以使用 <code>configtree:/etc/config/*/</code> 作为导入位置：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">config</span><span class="token punctuation">:</span>
    <span class="token key atrule">import</span><span class="token punctuation">:</span> <span class="token string">"optional:configtree:/etc/config/*/"</span>
</code></pre> 
<p>这将添加 <code>db.username</code>、<code>db.password</code>、<code>mq.username</code> 和 <code>mq.password</code> 属性。</p> 
<blockquote> 
 <p>使用通配符加载的目录按字母顺序排序。如果需要不同的顺序，则应将每个位置作为单独的导入列出</p> 
</blockquote> 
<p>配置树也可用于 Docker 秘密。当 Docker swarm 服务获准访问某个秘密时，该秘密就会被挂载到容器中。例如，如果名为 <code>db.password</code> 的秘密被挂载到 <code>/run/secrets/</code> 位置，你就可以使用下面的方法让 Spring 环境访问 <code>db.password</code>：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">config</span><span class="token punctuation">:</span>
    <span class="token key atrule">import</span><span class="token punctuation">:</span> <span class="token string">"optional:configtree:/run/secrets/"</span>
</code></pre> 
<h4><a id="_262"></a>属性占位符</h4> 
<p>在使用 <code>application.properties</code> 和 <code>application.yaml</code> 中的值时，会通过现有的环境进行过滤，因此您可以引用以前定义的值（例如，从系统属性或环境变量中）。标准的 <code>${name}</code> 属性占位符语法可用于值的任何位置。属性占位符还可以指定默认值，使用 <code>:</code> 分隔默认值和属性名称，例如 <code>${name:default}</code>。<br> 有默认值和无默认值占位符的使用示例如下：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">app</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">"MyApp"</span>
  <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"${app.name} is a Spring Boot application written by ${username:Unknown}"</span>
</code></pre> 
<p>假设<code>username</code>属性未在其他地方设置，<code>app.description</code> 的值将是<code>MyApp is a Spring Boot application written by Unknown</code>。</p> 
<blockquote> 
 <p>您应始终使用其规范形式（仅使用小写字母的kebab-case）来引用占位符中的属性名称。这将允许 Spring Boot 使用与放松绑定 <code>@ConfigurationProperties</code> 时相同的逻辑。<br> 例如，<code>${demo.item-price}</code> 将从 <code>application.properties</code> 文件中获取 <code>demo.item-price</code> 和 <code>demo.itemPrice</code> 表单，并从系统环境中获取 <code>DEMO_ITEMPRICE</code>。如果使用 <code>${demo.itemPrice}</code>，则不会考虑 <code>demo.item-price</code> 和 <code>DEMO_ITEMPRICE</code>。</p> 
</blockquote> 
<blockquote> 
 <p>您还可以使用此技术创建现有 Spring Boot 属性的 "简短 "变体。详情请参阅 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.properties-and-configuration.short-command-line-arguments" rel="nofollow"><em>howto.html</em></a> 方法。</p> 
</blockquote> 
<h4><a id="_276"></a>使用多文档文件</h4> 
<p>Spring Boot 允许您将单个物理文件分割成多个逻辑文档，每个文档都是独立添加的。文档按从上到下的顺序处理。后面的文档可以覆盖前面文档中定义的属性。<br> 对于 <code>application.yaml</code> 文件，使用标准的 YAML 多文档语法。三个连续的<code>-</code>字符代表一个文档的结束和下一个文档的开始。<br> 例如，以下文件有两个逻辑文档：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">"MyApp"</span>
<span class="token punctuation">---</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">"MyCloudApp"</span>
  <span class="token key atrule">config</span><span class="token punctuation">:</span>
    <span class="token key atrule">activate</span><span class="token punctuation">:</span>
      <span class="token key atrule">on-cloud-platform</span><span class="token punctuation">:</span> <span class="token string">"kubernetes"</span>

</code></pre> 
<p>对于 <code>application.properties</code> 文件，使用特殊的 <code>#---</code> 或 <code>!---</code> 注释来标记文档分割：</p> 
<pre><code class="prism language-properties">spring.application.name=MyApp
#---
spring.application.name=MyCloudApp
spring.config.activate.on-cloud-platform=kubernetes
</code></pre> 
<blockquote> 
 <p>属性文件分隔符不能有任何前导空白，必须有三个<code>-</code>字符。分隔符前后的行不能是相同的注释前缀。</p> 
</blockquote> 
<blockquote> 
 <p>多文档属性文件通常与激活属性（如 <code>spring.config.activate.on-profile</code>）结合使用。详见下一节。</p> 
</blockquote> 
<blockquote> 
 <p>使用 <code>@PropertySource</code> 或 <code>@TestPropertySource</code> 注解无法加载多文档属性文件。</p> 
</blockquote> 
<h3><a id="_306"></a>激活属性</h3> 
<p>有时，只有在满足特定条件时才激活特定的属性集是非常有用的。例如，你可能有一些属性只有在特定配置文件处于激活状态时才相关。<br> 你可以使用 <code>spring.config.activate.*</code> 有条件地激活属性文档。<br> 以下激活属性可用：</p> 
<table><thead><tr><th><strong>Property</strong></th><th><strong>Note</strong></th></tr></thead><tbody><tr><td>on-profile</td><td>配置文件表达式，必须匹配该表达式，文档才会激活。</td></tr><tr><td>on-cloud-platform</td><td>文档激活时必须检测到的云平台。</td></tr></tbody></table> 
<p>例如，下面指定第二个文档只有在 Kubernetes 上运行时才会激活，而且只有在 "prod "或 "staging "配置文件激活时才会激活：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">myprop</span><span class="token punctuation">:</span>
  <span class="token string">"always-set"</span>
<span class="token punctuation">---</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">config</span><span class="token punctuation">:</span>
    <span class="token key atrule">activate</span><span class="token punctuation">:</span>
      <span class="token key atrule">on-cloud-platform</span><span class="token punctuation">:</span> <span class="token string">"kubernetes"</span>
      <span class="token key atrule">on-profile</span><span class="token punctuation">:</span> <span class="token string">"prod | staging"</span>
<span class="token key atrule">myotherprop</span><span class="token punctuation">:</span> <span class="token string">"sometimes-set"</span>
</code></pre> 
<h3><a id="_328"></a>加密属性</h3> 
<p>Spring Boot 不提供任何用于加密属性值的内置支持，但它提供了修改 Spring <code>Environment</code> 中所含值所需的钩点。<code>EnvironmentPostProcessor</code> 接口允许您在应用程序启动前操作环境。详见 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.application.customize-the-environment-or-application-context" rel="nofollow"><em>howto.htm</em></a>。<br> 如果您需要一种安全的方式来存储凭证和密码，<a href="https://cloud.spring.io/spring-cloud-vault/reference/html/" rel="nofollow">Spring Cloud Vault</a> 项目支持在 <a href="https://www.vaultproject.io/" rel="nofollow">HashiCorp Vault</a> 中存储外部化配置。</p> 
<h3><a id="_YAML_331"></a>使用 YAML</h3> 
<p><a href="https://yaml.org/" rel="nofollow">YAML</a> 是 JSON 的超集，因此是指定分层配置数据的便捷格式。只要你的类路径上有 <a href="https://github.com/snakeyaml/snakeyaml">SnakeYAML</a> 库，<code>SpringApplication</code> 类就会自动支持 YAML 作为属性的替代。</p> 
<blockquote> 
 <p>如果使用 “Starters”，<code>Spring-boot-starter</code> 会自动提供 SnakeYAML。</p> 
</blockquote> 
<h4><a id="_YAML__335"></a>映射 YAML 到属性</h4> 
<p>YAML 文档需要从分层格式转换为可与 Spring <code>Environment</code> 配合使用的扁平结构。例如，请看下面的 YAML 文档：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">environments</span><span class="token punctuation">:</span>
  <span class="token key atrule">dev</span><span class="token punctuation">:</span>
    <span class="token key atrule">url</span><span class="token punctuation">:</span> <span class="token string">"https://dev.example.com"</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">"Developer Setup"</span>
  <span class="token key atrule">prod</span><span class="token punctuation">:</span>
    <span class="token key atrule">url</span><span class="token punctuation">:</span> <span class="token string">"https://another.example.com"</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">"My Cool App"</span>
</code></pre> 
<p>为了从<code>Environment</code>中访问这些属性，将对它们进行如下扁平化处理：</p> 
<pre><code class="prism language-properties">environments.dev.url=https://dev.example.com
environments.dev.name=Developer Setup
environments.prod.url=https://another.example.com
environments.prod.name=My Cool App
</code></pre> 
<p>同样，YAML 列表也需要扁平化。它们被表示为带有 <code>[index]</code> 查找器的属性键。例如，请看下面的 YAML：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">my</span><span class="token punctuation">:</span>
 <span class="token key atrule">servers</span><span class="token punctuation">:</span>
 <span class="token punctuation">-</span> <span class="token string">"dev.example.com"</span>
 <span class="token punctuation">-</span> <span class="token string">"another.example.com"</span>
</code></pre> 
<p>前面的例子将转化为这些属性：</p> 
<pre><code class="prism language-properties">my.servers[0]=dev.example.com
my.servers[1]=another.example.com
</code></pre> 
<blockquote> 
 <p>使用 <code>[index] </code>符号的属性可以使用 Spring Boot 的 <code>Binder</code> 类绑定到 Java <code>List</code> 或 <code>Set</code> 对象。有关详细信息，请参阅下面的 "类型安全配置属性 "部分。</p> 
</blockquote> 
<blockquote> 
 <p>使用 <code>@PropertySource</code> 或 <code>@TestPropertySource</code> 注解无法加载 YAML 文件。因此，如果需要以这种方式加载值，则需要使用属性文件。</p> 
</blockquote> 
<h4><a id="_YAML_369"></a>直接加载 YAML</h4> 
<p>Spring Framework 提供了两个方便的类，可用于加载 YAML 文档。<code>YamlPropertiesFactoryBean</code> 将 YAML 作为属性加载，而 <code>YamlMapFactoryBean</code> 将 YAML 作为<code>Map</code>加载。<br> 如果您想将 YAML 作为 Spring <code>PropertySource</code> 加载，还可以使用 <code>YamlPropertySourceLoader</code> 类。</p> 
<h3><a id="_372"></a>配置随机值</h3> 
<p><code>RandomValuePropertySource</code> 用于注入随机值（例如，注入到秘密或测试用例中）。它可以产生整数、longs、uuids 或字符串，如下例所示：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">my</span><span class="token punctuation">:</span>
  <span class="token key atrule">secret</span><span class="token punctuation">:</span> <span class="token string">"${random.value}"</span>
  <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token string">"${random.int}"</span>
  <span class="token key atrule">bignumber</span><span class="token punctuation">:</span> <span class="token string">"${random.long}"</span>
  <span class="token key atrule">uuid</span><span class="token punctuation">:</span> <span class="token string">"${random.uuid}"</span>
  <span class="token key atrule">number-less-than-ten</span><span class="token punctuation">:</span> <span class="token string">"${random.int(10)}"</span>
  <span class="token key atrule">number-in-range</span><span class="token punctuation">:</span> <span class="token string">"${random.int[1024,65536]}"</span>
</code></pre> 
<p><code>random.int*</code> 的语法是 <code>OPEN value (,max) CLOSE</code>，其中 <code>OPEN,CLOSE</code> 是任意字符，<code>value,max</code> 是整数。如果提供了 <code>max</code>，则 <code>value</code> 是最小值，<code>max</code> 是最大值（排他）。</p> 
<h3><a id="_384"></a>设置系统环境属性</h3> 
<p>Spring Boot 支持为环境属性设置前缀。如果具有不同配置要求的多个 Spring Boot 应用程序共享系统环境，这将非常有用。系统环境属性的前缀可以直接在 <code>SpringApplication</code> 上设置。<br> 例如，如果将前缀设置为 <code>input</code>，<code>remote.timeout</code> 等属性也将在系统环境中解析为 <code>input.remote.timeout</code>。</p> 
<h3><a id="_387"></a>类型安全的配置属性</h3> 
<p>使用 <code>@Value("${property}")</code>注解注入配置属性有时会很麻烦，尤其是在处理多个属性或数据具有层次性的情况下。Spring Boot 提供了另一种处理属性的方法，让强类型 Bean 管理和验证应用程序的配置。</p> 
<blockquote> 
 <p>另请参阅 <code>@Value</code> 与类型安全配置属性之间的区别。</p> 
</blockquote> 
<h4><a id="JavaBean__391"></a>JavaBean 属性绑定</h4> 
<p>如下例所示，可以绑定一个声明了标准 JavaBean 属性的 Bean：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span><span class="token string">"my.service"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyProperties</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">boolean</span> enabled<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">InetAddress</span> remoteAddress<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Security</span> security <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Security</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// getters / setters...</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Security</span> <span class="token punctuation">{<!-- --></span>

        <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>

        <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>

        <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> roles <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singleton</span><span class="token punctuation">(</span><span class="token string">"USER"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// getters / setters...</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>上面的 POJO 定义了以下属性：</p> 
<ul><li><code>my.service.enabled</code>，默认值为 <code>false</code>。</li><li><code>my.service.remote-address</code>（远程地址），其类型可从字符串中提取。</li><li><code>my.service.security.username</code>，嵌套 "security "对象，其名称由属性名称决定。特别要指出的是，这里根本没有使用类型，可能是 <code>SecurityProperties</code>。</li><li><code>my.service.security.password</code>。</li><li><code>my.service.security.roles</code> 包含一个默认为 <code>USER</code> 的字符串集合。</li></ul> 
<blockquote> 
 <p>映射到 Spring Boot 中可用的 <code>@ConfigurationProperties</code> 类的属性（通过属性文件、YAML 文件、环境变量和其他机制进行配置）是公共 API，但类本身的访问器（getters/setters）不能直接使用。</p> 
</blockquote> 
<blockquote> 
 <p>这种安排依赖于默认的空构造函数，<code>getter</code> 和 <code>setter</code> 通常是强制性的，因为绑定是通过标准 Java Beans 属性描述符进行的，就像在 Spring MVC 中一样。在以下情况下，可以省略<code>setter</code>：</p> 
 <ul><li><code>Map</code>（只要已初始化）需要 <code>getter</code>，但不一定需要 <code>setter</code>，因为绑定器可以更改它们。</li><li>可以通过索引（通常使用 YAML）或使用单个逗号分隔的值（属性）来访问集合和数组。在后一种情况下，必须使用<code>setter</code>。我们建议始终为此类类型添加一个设置器。如果要初始化一个集合，请确保它不是不可变的（如前面的示例）。</li><li>如果嵌套的 POJO 属性被初始化（如上例中的 <code>Security</code> 字段），则不需要<code>setter</code>。如果希望<code>Binder</code>使用默认构造函数即时创建实例，则需要使用<code>setter</code>。</li></ul> 
</blockquote> 
<p>有些人使用 Project Lombok 自动添加<code>getter</code>和<code>setter</code>。请确保 Lombok 不会为这种类型生成任何特定的构造函数，因为容器会自动使用它来实例化对象。</p> 
<blockquote> 
 <p>最后，只考虑标准的 Java Bean 属性，不支持绑定静态属性。</p> 
</blockquote> 
<h4><a id="_436"></a>构造函数绑定</h4> 
<p>上一节的示例可以用不可变的方式重写，如下例所示：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span><span class="token string">"my.service"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyProperties</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// fields...</span>

    <span class="token keyword">public</span> <span class="token class-name">MyProperties</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> enabled<span class="token punctuation">,</span> <span class="token class-name">InetAddress</span> remoteAddress<span class="token punctuation">,</span> <span class="token class-name">Security</span> security<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>enabled <span class="token operator">=</span> enabled<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>remoteAddress <span class="token operator">=</span> remoteAddress<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>security <span class="token operator">=</span> security<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// getters...</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Security</span> <span class="token punctuation">{<!-- --></span>

        <span class="token comment">// fields...</span>

        <span class="token keyword">public</span> <span class="token class-name">Security</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">,</span> <span class="token annotation punctuation">@DefaultValue</span><span class="token punctuation">(</span><span class="token string">"USER"</span><span class="token punctuation">)</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> roles<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>username <span class="token operator">=</span> username<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>password <span class="token operator">=</span> password<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>roles <span class="token operator">=</span> roles<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// getters...</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>在此设置中，<strong>单个参数化构造函数的存在意味着应使用构造函数绑定</strong>。这意味着绑定器将找到一个带有您希望绑定的参数的构造函数。如果你的类有多个构造函数，可以使用 <code>@ConstructorBinding</code> 注解来指定使用哪个构造函数进行构造函数绑定。如果类只有一个参数化的构造函数，则必须使用 <code>@Autowired</code> 注解才能退出构造函数绑定。构造函数绑定可用于记录。除非您的记录有多个构造函数，否则没有必要使用 <code>@ConstructorBinding</code>。<br> 构造函数绑定类（如上例中的 <code>Security</code>）的嵌套成员也将通过其构造函数绑定。<br> 可以在构造函数参数和记录组件上使用 <code>@DefaultValue</code> 指定默认值。转换服务将用于将注解的字符串值强制转换为缺失属性的目标类型。<br> 参考前面的示例，如果没有任何属性绑定到 <code>Security</code>，<code>MyProperties</code> 实例将包含一个<code>null</code>值的 <code>Security</code> 。要使 <code>MyProperties</code> 实例在没有绑定任何属性的情况下也包含一个非空的 <code>Security</code> 实例（在使用 Kotlin 时，这需要将 <code>Security</code> 的<code>username</code>和<code>password</code>参数声明为可空，因为它们没有默认值），请使用空的 <code>@DefaultValue</code> 注解：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">MyProperties</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> enabled<span class="token punctuation">,</span> <span class="token class-name">InetAddress</span> remoteAddress<span class="token punctuation">,</span> <span class="token annotation punctuation">@DefaultValue</span> <span class="token class-name">Security</span> security<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>enabled <span class="token operator">=</span> enabled<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>remoteAddress <span class="token operator">=</span> remoteAddress<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>security <span class="token operator">=</span> security<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>要使用构造函数绑定，必须使用 <code>@EnableConfigurationProperties</code> 或配置属性扫描启用该类。对于通过常规 Spring 机制创建的 Bean（例如 <code>@Component</code> Bean、通过 <code>@Bean</code> 方法创建的 Bean 或通过 <code>@Import</code> 加载的 Bean），您不能使用构造函数绑定。</p> 
</blockquote> 
<blockquote> 
 <p>要在本地镜像中使用构造函数绑定，必须使用 <code>-parameters</code> 对类进行编译。如果使用 Spring Boot 的 Gradle 插件，或者使用 Maven 和 <code>spring-boot-starter-parent</code>，编译会自动进行。</p> 
</blockquote> 
<blockquote> 
 <p>不建议将 <code>java.util.Optional</code> 与 <code>@ConfigurationProperties</code> 结合使用，因为它主要是用作返回类型。因此，它并不适合配置属性注入。为了与其他类型的属性保持一致，如果您确实声明了一个 <code>Optional</code> 属性，但它没有值，那么绑定的将是 <code>null</code> 而不是空的 <code>Optional</code>。</p> 
</blockquote> 
<h4><a id="_ConfigurationProperties_485"></a>启用 @ConfigurationProperties</h4> 
<p>Spring Boot 提供了绑定 <code>@ConfigurationProperties</code> 类型并将其注册为 Bean 的基础架构。您既可以按类启用配置属性，也可以启用配置属性扫描，其工作方式与组件扫描类似。<br> 有时，使用 <code>@ConfigurationProperties</code> 注解的类可能不适合扫描，例如，如果您正在开发自己的自动配置，或者您想有条件地启用它们。在这种情况下，请使用 <code>@EnableConfigurationProperties</code> 注解指定要处理的类型列表。这可以在任何 <code>@Configuration</code> 类上完成，如下例所示：</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>context<span class="token punctuation">.</span>properties<span class="token punctuation">.</span></span><span class="token class-name">EnableConfigurationProperties</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Configuration</span><span class="token punctuation">(</span>proxyBeanMethods <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token class-name">SomeProperties</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyConfiguration</span> <span class="token punctuation">{<!-- --></span>

<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>context<span class="token punctuation">.</span>properties<span class="token punctuation">.</span></span><span class="token class-name">ConfigurationProperties</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span><span class="token string">"some.properties"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SomeProperties</span> <span class="token punctuation">{<!-- --></span>

<span class="token punctuation">}</span>
</code></pre> 
<p>要使用配置属性扫描，请在应用程序中添加 <code>@ConfigurationPropertiesScan</code> 注解。通常情况下，它会被添加到使用 <code>@SpringBootApplication</code> 注解的主应用程序类中，但也可以添加到任何 <code>@Configuration</code> 类中。默认情况下，扫描将从声明注解的类的包中进行。如果你想定义要扫描的特定包，可以如下例所示进行操作：</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span></span><span class="token class-name">SpringBootApplication</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>context<span class="token punctuation">.</span>properties<span class="token punctuation">.</span></span><span class="token class-name">ConfigurationPropertiesScan</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token annotation punctuation">@ConfigurationPropertiesScan</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> <span class="token string">"com.example.app"</span><span class="token punctuation">,</span> <span class="token string">"com.example.another"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyApplication</span> <span class="token punctuation">{<!-- --></span>

<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>当使用配置属性扫描或通过 <code>@EnableConfigurationProperties</code> 注册 <code>@ConfigurationProperties</code> Bean 时，该 Bean 具有一个常规名称： <code>&lt;prefix&gt;-&lt;fqn&gt;</code>，其中 <code>&lt;prefix&gt;</code> 是 <code>@ConfigurationProperties</code> 注解中指定的环境键前缀，<code>&lt;fqn&gt;</code> 是 bean 的完全限定名称。如果注解没有提供任何前缀，则只使用 bean 的完整限定名称。<br> 假设它位于 <code>com.example.app</code> 包中，则上述 <code>SomeProperties</code> 示例的 Bean 名称为 <code>some.properties-com.example.app.SomeProperties</code>。</p> 
</blockquote> 
<p>我们建议 <code>@ConfigurationProperties</code> 只处理环境，尤其不要注入上下文中的其他 Bean。在某些情况下，可以使用<code>setter</code>注入或框架提供的任何 <code>*Aware</code> 接口（如需要访问环境时使用 <code>EnvironmentAware</code>）。如果您仍想使用构造函数注入其他 Bean，则必须使用 <code>@Component</code> 对配置属性 Bean 进行注解，并使用基于 JavaBean 的属性绑定。</p> 
<h4><a id="_ConfigurationProperties_521"></a>使用 @ConfigurationProperties</h4> 
<p>这种配置方式与 <code>SpringApplication</code> 外部 YAML 配置配合使用效果尤佳，如下例所示：</p> 
<pre><code class="prism language-java">my<span class="token operator">:</span>
  service<span class="token operator">:</span>
    remote<span class="token operator">-</span>address<span class="token operator">:</span> <span class="token number">192.168</span><span class="token number">.1</span><span class="token number">.1</span>
    security<span class="token operator">:</span>
      username<span class="token operator">:</span> <span class="token string">"admin"</span>
      roles<span class="token operator">:</span>
      <span class="token operator">-</span> <span class="token string">"USER"</span>
      <span class="token operator">-</span> <span class="token string">"ADMIN"</span>
</code></pre> 
<p>要使用 <code>@ConfigurationProperties</code> Bean，您可以像使用其他 Bean 一样注入它们，如下例所示：</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Service</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">MyProperties</span> properties<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">MyService</span><span class="token punctuation">(</span><span class="token class-name">MyProperties</span> properties<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>properties <span class="token operator">=</span> properties<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Server</span> server <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Server</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>properties<span class="token punctuation">.</span><span class="token function">getRemoteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        server<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// ...</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>使用 <code>@ConfigurationProperties</code> 还可以生成元数据文件，供集成开发环境使用，为自己的键提供自动完成功能。详情请参见<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/configuration-metadata.html#appendix.configuration-metadata" rel="nofollow">附录</a>。</p> 
<h4><a id="_557"></a>第三方配置</h4> 
<p>除了使用 <code>@ConfigurationProperties</code> 对类进行注解外，您还可以在公共 <code>@Bean</code> 方法中使用它。当您想将属性绑定到您无法控制的第三方组件时，这样做会特别有用。<br> 要从环境属性配置 Bean，请在其 Bean 注册中添加 <code>@ConfigurationProperties</code>，如下例所示：</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>context<span class="token punctuation">.</span>properties<span class="token punctuation">.</span></span><span class="token class-name">ConfigurationProperties</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Configuration</span><span class="token punctuation">(</span>proxyBeanMethods <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThirdPartyConfiguration</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"another"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">AnotherComponent</span> <span class="token function">anotherComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AnotherComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>任何以 <code>another</code> 前缀定义的 JavaBean 属性都会映射到 <code>AnotherComponent</code> Bean 上，映射方式与前面的 <code>SomeProperties</code> 示例类似。</p> 
<h4><a id="_577"></a>宽松绑定</h4> 
<p>Spring Boot 在将<code>Environment</code>属性绑定到 <code>@ConfigurationProperties</code> Bean 时使用了一些宽松的规则，因此<code>Environment</code>属性名称和 Bean 属性名称之间无需完全匹配。常见的有用例子包括以破折号分隔的环境属性（例如，<code>context-path</code> 绑定到 <code>contextPath</code>）和大写的环境属性（例如，<code>PORT</code> 绑定到 <code>port</code>）。<br> 举例来说，请看下面的 <code>@ConfigurationProperties</code> 类：</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>context<span class="token punctuation">.</span>properties<span class="token punctuation">.</span></span><span class="token class-name">ConfigurationProperties</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"my.main-project.person"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyPersonProperties</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> firstName<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getFirstName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirstName</span><span class="token punctuation">(</span><span class="token class-name">String</span> firstName<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> firstName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>通过前面的代码，可以使用以下所有属性名称：</p> 
<table><thead><tr><th><strong>Property</strong></th><th><strong>Note</strong></th></tr></thead><tbody><tr><td><code>my.main-project.person.first-name</code></td><td>Kebab-case，建议在 <code>.properties</code> 和 YAML 文件中使用。</td></tr><tr><td><code>my.main-project.person.firstName</code></td><td>标准驼峰式语法</td></tr><tr><td><code>my.main-project.person.first_name</code></td><td>下划线符号，是 <code>.properties</code> 和 YAML 文件的另一种格式。</td></tr><tr><td><code>MY_MAINPROJECT_PERSON_FIRSTNAME</code></td><td>大写格式，建议在使用系统环境变量时使用。</td></tr></tbody></table> 
<blockquote> 
 <p>注解的前缀值必须使用 kebab-case 写（小写并用 <code>-</code> 分隔，如 <code>my.main-project.person</code>）。</p> 
</blockquote> 
<table><thead><tr><th><strong>Property Source</strong></th><th><strong>Simple</strong></th><th><strong>List</strong></th></tr></thead><tbody><tr><td>Properties Files</td><td>驼峰格式、破折号或下划线连接</td><td>使用 <code>[ ]</code> 或逗号分隔值的标准列表语法</td></tr><tr><td>YAML Files</td><td>驼峰格式、破折号或下划线连接</td><td>标准 YAML 列表语法或用逗号分隔的值</td></tr><tr><td>Environment Variables</td><td>大写格式，下划线为分隔符（请参阅 “从环境变量绑定”）。</td><td>用下划线连起来的数值（请参阅从环境变量绑定）。</td></tr><tr><td>System properties</td><td>驼峰格式、破折号或下划线连接</td><td>使用 <code>[ ]</code> 或逗号分隔值的标准列表语法</td></tr></tbody></table> 
<blockquote> 
 <p>我们建议，在可能的情况下，属性以减号连接的格式存储，例如 <code>my.person.first-name=Rod</code>。</p> 
</blockquote> 
<h5><a id="Map_618"></a>绑定Map</h5> 
<p>绑定属性到 <code>Map</code> 时，可能需要使用特殊的括号符号，以便保留原始<code>key</code>值。如果键值没有用<code>[]</code>包围，任何非字母数字、<code>-</code>或<code>.</code>的字符都会被删除。<br> 例如，将以下属性绑定到 <code>Map&lt;String,String&gt;</code> 中：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">my</span><span class="token punctuation">:</span>
  <span class="token key atrule">map</span><span class="token punctuation">:</span>
    <span class="token key atrule">"[/key1]"</span><span class="token punctuation">:</span> <span class="token string">"value1"</span>
    <span class="token key atrule">"[/key2]"</span><span class="token punctuation">:</span> <span class="token string">"value2"</span>
    <span class="token key atrule">"/key3"</span><span class="token punctuation">:</span> <span class="token string">"value3"</span>
</code></pre> 
<blockquote> 
 <p>对于 YAML 文件，括号需要用引号包围，这样才能正确解析键值。</p> 
</blockquote> 
<p>上述属性将绑定到一个<code>Map</code>，<code>Map</code>中的键为 <code>/key1</code>、<code>/key2</code> 和 <code>key3</code>。由于 <code>key3</code> 没有被方括号包围，因此删除了其中的斜线。<br> 绑定到标量值时，带有 <code>.</code>的键无需用 <code>[]</code> 包围。标量值包括枚举和 <code>java.lang</code> 包中除 <code>Object</code> 之外的所有类型。将 <code>a.b=c</code> 绑定到 <code>Map&lt;String, String&gt;</code> 将保留键中的 <code>.</code>，并返回一个包含 <code>{"a.b"="c"}</code> 条目的 Map。对于其他类型，如果键包含 <code>.</code>，则需要使用括号符号。例如，将 <code>a.b=c</code> 绑定到 <code>Map&lt;String, Object&gt;</code> 将返回包含 <code>{"a"={"b"="c"}}</code> 条目的 Map，而 <code>[a.b]=c</code> 将返回包含 <code>{"a.b"="c"}</code> 条目的 Map。</p> 
<h5><a id="_632"></a>从环境变量绑定</h5> 
<p>大多数操作系统对环境变量的名称都有严格规定。例如，Linux shell 变量只能包含字母（<code>a</code> 至 <code>z</code> 或 <code>A</code> 至 <code>Z</code>）、数字（<code>0</code> 至 <code>9</code>）或下划线字符 (<code>_</code>)。按照惯例，Unix shell 变量的名称也是大写的。<br> Spring Boot 的宽松绑定规则尽可能与这些命名限制兼容。<br> 要将规范格式的属性名转换为环境变量名，可以遵循以下规则：</p> 
<ul><li>用下划线 (<code>_</code>) 代替点 (<code>.</code>) 。</li><li>删除任何破折号 (<code>-</code>)。</li><li>转换为大写字母。</li></ul> 
<p>例如，配置属性 <code>spring.main.log-startup-info</code> 就是一个名为 <code>SPRING_MAIN_LOGSTARTUPINFO</code> 的环境变量。<br> 在绑定对象列表时，也可以使用环境变量。要绑定到列表，应在变量名中用下划线括起元素编号。<br> 例如，配置属性 <code>my.service[0].other</code> 将使用名为 <code>MY_SERVICE_0_OTHER</code> 的环境变量。</p> 
<h5><a id="_644"></a>缓存</h5> 
<p>宽松绑定使用缓存来提高性能。默认情况下，这种缓存只适用于不可变属性源。要自定义此行为，例如为可变属性源启用缓存，请使用 <code>ConfigurationPropertyCaching</code>。</p> 
<h4><a id="_646"></a>合并复杂类型</h4> 
<p>当列表配置在多个地方时，覆盖的作用是替换整个列表。<br> 例如，假设 <code>MyPojo</code> 对象的 <code>name</code> 和 <code>description</code> 属性默认为空。下面的示例从 <code>MyProperties</code> 中公开了一个 <code>MyPojo</code> 对象列表：</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>context<span class="token punctuation">.</span>properties<span class="token punctuation">.</span></span><span class="token class-name">ConfigurationProperties</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span><span class="token string">"my"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyProperties</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MyPojo</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MyPojo</span><span class="token punctuation">&gt;</span></span> <span class="token function">getList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>请考虑以下配置：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">my</span><span class="token punctuation">:</span>
  <span class="token key atrule">list</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">"my name"</span>
    <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"my description"</span>
<span class="token punctuation">---</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">config</span><span class="token punctuation">:</span>
    <span class="token key atrule">activate</span><span class="token punctuation">:</span>
      <span class="token key atrule">on-profile</span><span class="token punctuation">:</span> <span class="token string">"dev"</span>
<span class="token key atrule">my</span><span class="token punctuation">:</span>
  <span class="token key atrule">list</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">"my another name"</span>
</code></pre> 
<p>如果<code>dev</code>配置文件未激活，<code>MyProperties.list</code> 会包含一个 <code>MyPojo</code> 条目，如前所述。但如果启用了<code>dev</code>配置文件，列表中仍然只有一个条目（名称为<code>my another name</code>，描述为<code>null</code>）。这种配置不会在列表中添加第二个 <code>MyPojo</code> 实例，也不会合并项目。<br> 如果在多个配置文件中指定了一个列表，则会使用优先级最高的配置文件（也只有该配置文件）。请看下面的例子：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">my</span><span class="token punctuation">:</span>
  <span class="token key atrule">list</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">"my name"</span>
    <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"my description"</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">"another name"</span>
    <span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">"another description"</span>
<span class="token punctuation">---</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">config</span><span class="token punctuation">:</span>
    <span class="token key atrule">activate</span><span class="token punctuation">:</span>
      <span class="token key atrule">on-profile</span><span class="token punctuation">:</span> <span class="token string">"dev"</span>
<span class="token key atrule">my</span><span class="token punctuation">:</span>
  <span class="token key atrule">list</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> <span class="token string">"my another name"</span>
</code></pre> 
<p>在上例中，如果<code>dev</code>配置文件处于活动状态，<code>MyProperties.list</code> 将包含一个 <code>MyPojo</code> 条目（名称为<code>my another name</code>，描述为<code>null</code>）。对于 YAML，逗号分隔列表和 YAML 列表都可用于完全覆盖列表内容。<br> 对于 <code>Map</code> 属性，可以绑定从多个来源获取的属性值。不过，对于多个来源中的同一属性，将使用优先级最高的那个。下面的示例公开了来自 <code>MyProperties</code> 的 <code>Map&lt;String,MyPojo&gt;</code>：</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">LinkedHashMap</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Map</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>context<span class="token punctuation">.</span>properties<span class="token punctuation">.</span></span><span class="token class-name">ConfigurationProperties</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span><span class="token string">"my"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyProperties</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MyPojo</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">MyPojo</span><span class="token punctuation">&gt;</span></span> <span class="token function">getMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>map<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>请考虑以下配置：</p> 
<pre><code class="prism language-java">my<span class="token operator">:</span>
  map<span class="token operator">:</span>
    key1<span class="token operator">:</span>
      name<span class="token operator">:</span> <span class="token string">"my name 1"</span>
      description<span class="token operator">:</span> <span class="token string">"my description 1"</span>
<span class="token operator">--</span><span class="token operator">-</span>
spring<span class="token operator">:</span>
  config<span class="token operator">:</span>
    activate<span class="token operator">:</span>
      on<span class="token operator">-</span>profile<span class="token operator">:</span> <span class="token string">"dev"</span>
my<span class="token operator">:</span>
  map<span class="token operator">:</span>
    key1<span class="token operator">:</span>
      name<span class="token operator">:</span> <span class="token string">"dev name 1"</span>
    key2<span class="token operator">:</span>
      name<span class="token operator">:</span> <span class="token string">"dev name 2"</span>
      description<span class="token operator">:</span> <span class="token string">"dev description 2"</span>
</code></pre> 
<p>如果<code>dev</code>配置文件未激活，<code>MyProperties.map</code> 会包含一个 <code>key1</code> 条目（名称为<code>my name 1</code>，描述为<code>my description 1</code>）。但如果启用了<code>dev</code>配置文件，<code>map</code> 会包含两个条目，键值分别为 <code>key1</code>（名称为<code>dev name 1</code>，描述为<code>my description 1</code>）和 <code>key2</code>（名称为<code>dev name 2</code>，描述为<code>dev description 2</code>）。</p> 
<blockquote> 
 <p>上述合并规则适用于所有属性源的属性，而不仅仅是文件。</p> 
</blockquote> 
<h4><a id="_741"></a>属性转换</h4> 
<p>Spring Boot 在绑定 <code>@ConfigurationProperties</code> Bean 时，会尝试将外部应用程序属性强制转换为正确的类型。如果需要自定义类型转换，可以提供 <code>ConversionService</code> Bean（使用名为 <code>conversionService</code> 的 Bean）或自定义属性编辑器（通过 <code>CustomEditorConfigurer</code> Bean）或自定义转换器（使用注释为 <code>@ConfigurationPropertiesBinding</code> 的 Bean 定义）。<br> 由于此 Bean 在应用程序生命周期的早期就会被请求，因此请确保限制 <code>ConversionService</code> 使用的依赖关系。通常情况下，您所需要的任何依赖关系在创建时可能尚未完全初始化。如果配置键强制不需要自定义 <code>ConversionService</code>，您可能需要将其重命名，并且只依赖于使用 <code>@ConfigurationPropertiesBinding</code> 限定的自定义转换器。</p> 
<h5><a id="Duration_744"></a>转换Duration</h5> 
<p>Spring Boot 为表达<code>Duration</code>提供了专门支持。如果暴露了 <code>java.time.Duration</code> 属性，应用程序属性中的以下格式就可用：</p> 
<ul><li>常规长表示法（使用毫秒作为默认单位，除非指定了 <code>@DurationUnit</code>）</li><li><code>java.time.Duration</code> 使用的标准 ISO-8601 格式</li><li>一种更易读的格式，其中值和单位是耦合的（<code>10s</code> 表示 10 秒）</li></ul> 
<p>请看下面这个例子：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span><span class="token string">"my"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyProperties</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@DurationUnit</span><span class="token punctuation">(</span><span class="token class-name">ChronoUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">Duration</span> sessionTimeout <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Duration</span> readTimeout <span class="token operator">=</span> <span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofMillis</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// getters / setters...</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>要指定会话超时 30 秒，<code>30</code>、<code>PT30S</code> 和 <code>30s</code> 都是等价的。读取超时 500 毫秒可以用以下任何一种形式指定： <code>500</code>、<code>PT0.5S</code> 和 <code>500ms</code>。<br> 您也可以使用任何支持的单位。它们是：</p> 
<ul><li><code>ns</code> 代表纳秒</li><li><code>us</code> 代表微秒</li><li><code>ms</code> 代表毫秒</li><li><code>s</code> 代表秒</li><li><code>m</code> 代表分钟</li><li><code>h</code> 代表小时</li><li><code>d</code> 代表天</li></ul> 
<p>默认单位是毫秒，可使用 <code>@DurationUnit</code> 进行重载，如上例所示。<br> 如果您喜欢使用构造函数绑定，也可以公开相同的属性，如下例所示：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span><span class="token string">"my"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyProperties</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// fields...</span>

    <span class="token keyword">public</span> <span class="token class-name">MyProperties</span><span class="token punctuation">(</span><span class="token annotation punctuation">@DurationUnit</span><span class="token punctuation">(</span><span class="token class-name">ChronoUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span> <span class="token annotation punctuation">@DefaultValue</span><span class="token punctuation">(</span><span class="token string">"30s"</span><span class="token punctuation">)</span> <span class="token class-name">Duration</span> sessionTimeout<span class="token punctuation">,</span>
            <span class="token annotation punctuation">@DefaultValue</span><span class="token punctuation">(</span><span class="token string">"1000ms"</span><span class="token punctuation">)</span> <span class="token class-name">Duration</span> readTimeout<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>sessionTimeout <span class="token operator">=</span> sessionTimeout<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>readTimeout <span class="token operator">=</span> readTimeout<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// getters...</span>

<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>如果要升级长属性，请确保定义单位（使用 <code>@DurationUnit</code>）（如果不是毫秒）。这样可以提供一个透明的升级路径，同时支持更丰富的格式。</p> 
</blockquote> 
<h5><a id="Period_796"></a>转换Period</h5> 
<p>除了Duration，Spring Boot 还可以使用 <code>java.time.Period</code> 类型。应用程序属性中可使用以下格式：</p> 
<ul><li>常规 <code>int</code> 表示法（使用天数作为默认单位，除非指定了 <code>@PeriodUnit</code>）</li><li><code>java.time.Period</code> 使用的标准 ISO-8601 格式</li><li>一种更简单的格式，其中值和单位对是耦合的（<code>1y3d</code> 表示 1 年零 3 天）</li></ul> 
<p>使用简单格式可支持以下单位：</p> 
<ul><li><code>y</code> 代表年</li><li><code>m</code> 代表月</li><li><code>w</code> 代表周</li><li><code>d</code> 代表天数</li></ul> 
<blockquote> 
 <p><code>java.time.Period</code> 类型实际上并不存储周数，它只是一个快捷方式，表示 “7 天”。</p> 
</blockquote> 
<h5><a id="DataSize_811"></a>转换DataSize</h5> 
<p>Spring Framework 有一种 <code>DataSize</code> 值类型，以字节为单位表示大小。如果公开 <code>DataSize</code> 属性，应用程序属性中的以下格式将可用：</p> 
<ul><li>常规的长表示法（使用字节作为默认单位，除非指定了 <code>@DataSizeUnit</code>）</li><li>可读性更强的格式，其中值和单位是耦合的（<code>10MB</code> 表示 10 兆字节）</li></ul> 
<p>请看下面的示例：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span><span class="token string">"my"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyProperties</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@DataSizeUnit</span><span class="token punctuation">(</span><span class="token class-name">DataUnit</span><span class="token punctuation">.</span><span class="token constant">MEGABYTES</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">DataSize</span> bufferSize <span class="token operator">=</span> <span class="token class-name">DataSize</span><span class="token punctuation">.</span><span class="token function">ofMegabytes</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">DataSize</span> sizeThreshold <span class="token operator">=</span> <span class="token class-name">DataSize</span><span class="token punctuation">.</span><span class="token function">ofBytes</span><span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// getters/setters...</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>要指定 10 兆字节的缓冲区大小，<code>10</code> 和 <code>10MB</code> 是等价的。256 字节的大小阈值可以指定为 <code>256</code> 或 <code>256B</code>。<br> 您也可以使用任何支持的单位。这些单位是：</p> 
<ul><li><code>B</code> 代表字节</li><li><code>KB</code> 代表千字节</li><li><code>MB</code> 代表兆字节</li><li><code>GB</code> 代表千兆字节</li><li><code>TB</code> 代表太字节</li></ul> 
<p>默认单位是字节，可使用 <code>@DataSizeUnit</code> 进行重载，如上例所示。<br> 如果您喜欢使用构造函数绑定，也可以公开相同的属性，如下例所示：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span><span class="token string">"my"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyProperties</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">// fields...</span>

    <span class="token keyword">public</span> <span class="token class-name">MyProperties</span><span class="token punctuation">(</span><span class="token annotation punctuation">@DataSizeUnit</span><span class="token punctuation">(</span><span class="token class-name">DataUnit</span><span class="token punctuation">.</span><span class="token constant">MEGABYTES</span><span class="token punctuation">)</span> <span class="token annotation punctuation">@DefaultValue</span><span class="token punctuation">(</span><span class="token string">"2MB"</span><span class="token punctuation">)</span> <span class="token class-name">DataSize</span> bufferSize<span class="token punctuation">,</span>
            <span class="token annotation punctuation">@DefaultValue</span><span class="token punctuation">(</span><span class="token string">"512B"</span><span class="token punctuation">)</span> <span class="token class-name">DataSize</span> sizeThreshold<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>bufferSize <span class="token operator">=</span> bufferSize<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>sizeThreshold <span class="token operator">=</span> sizeThreshold<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// getters...</span>

<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>如果要升级长属性，请确保定义单位（使用 <code>@DataSizeUnit</code>）（如果不是字节）。这样可以提供透明的升级路径，同时支持更丰富的格式。</p> 
</blockquote> 
<h4><a id="ConfigurationProperties__860"></a>@ConfigurationProperties 验证</h4> 
<p>只要 <code>@ConfigurationProperties</code> 类使用了 Spring 的 <code>@Validated</code> 注解，Spring Boot 就会尝试对其进行验证。您可以直接在配置类上使用 JSR-303 <code>jakarta.validation</code> 约束注解。为此，请确保在类路径上有符合要求的 JSR-303 实现，然后在字段中添加约束注解，如下例所示：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span><span class="token string">"my.service"</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Validated</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyProperties</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@NotNull</span>
    <span class="token keyword">private</span> <span class="token class-name">InetAddress</span> remoteAddress<span class="token punctuation">;</span>

    <span class="token comment">// getters/setters...</span>

<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>您还可以通过在创建配置属性的 <code>@Bean</code> 方法中注释 <code>@Validated</code> 来触发验证。</p> 
</blockquote> 
<p>为确保嵌套属性始终触发验证，即使没有找到任何属性，也必须用 <code>@Valid</code> 对相关字段进行注解。下面的示例以前面的 <code>MyProperties</code> 示例为基础：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span><span class="token string">"my.service"</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Validated</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyProperties</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@NotNull</span>
    <span class="token keyword">private</span> <span class="token class-name">InetAddress</span> remoteAddress<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Valid</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Security</span> security <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Security</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// getters/setters...</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Security</span> <span class="token punctuation">{<!-- --></span>

        <span class="token annotation punctuation">@NotEmpty</span>
        <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>

        <span class="token comment">// getters/setters...</span>

    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>您还可以通过创建名为 <code>configurationPropertiesValidator</code> 的 Bean 定义来添加自定义 Spring 验证器。<code>@Bean</code> 方法应声明为静态。配置属性验证器是在应用程序生命周期的早期创建的，将 <code>@Bean</code> 方法声明为静态方法可让 Bean 在创建时无需实例化 <code>@Configuration</code> 类。这样做可以避免提前实例化可能导致的任何问题。</p> 
<blockquote> 
 <p><code>spring-boot-actuator</code> 模块包含一个可公开所有 <code>@ConfigurationProperties</code> Bean 的端点。将网络浏览器指向 <code>/actuator/configprops</code>，或使用相应的 JMX 端点。有关详情，请参阅 "生产就绪功能 "部分。</p> 
</blockquote> 
<h4><a id="ConfigurationProperties__Value_904"></a>@ConfigurationProperties 对比 @Value</h4> 
<p><code>@Value</code> 注解是容器的核心功能，它不提供与类型安全配置属性相同的功能。下表总结了 <code>@ConfigurationProperties</code> 和 <code>@Value</code> 支持的功能：</p> 
<table><thead><tr><th><strong>Feature</strong></th><th><strong>@ConfigurationProperties</strong></th><th><strong>@Value</strong></th></tr></thead><tbody><tr><td>宽松绑定</td><td>Yes</td><td>支持有限（见下方说明）</td></tr><tr><td><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/configuration-metadata.html#appendix.configuration-metadata" rel="nofollow">元数据支持</a></td><td>Yes</td><td>No</td></tr><tr><td><code>SpEL</code> 评估</td><td>No</td><td>Yes</td></tr></tbody></table> 
<blockquote> 
 <p>如果您确实想使用 <code>@Value</code>，我们建议您使用其规范形式（仅使用小写字母的kebab-case）来引用属性名称。这将允许 Spring Boot 使用与宽松绑定 <code>@ConfigurationProperties</code> 时相同的逻辑。</p> 
 <p>例如，<code>@Value("${demo.item-price}")</code> 将从 <code>application.properties</code> 文件中获取 <code>demo.item-price</code> 和 <code>demo.itemPrice</code> 表单，并从系统环境中获取 <code>DEMO_ITEMPRICE</code>。如果使用 <code>@Value("${demo.itemPrice}")</code>，则不会考虑 <code>demo.item-price</code> 和 <code>DEMO_ITEMPRICE</code>。</p> 
</blockquote> 
<p>如果您为自己的组件定义了一组配置键，我们建议您将它们组合到一个注有 <code>@ConfigurationProperties</code> 的 POJO 中。这样做将为您提供结构化、类型安全的对象，您可以将其注入到自己的 Bean 中。<br> 在解析应用程序属性文件和填充环境时，不会处理这些文件中的 <code>SpEL</code> 表达式。不过，可以在 <code>@Value</code> 中写入 <code>SpEL</code> 表达式。如果应用程序属性文件中的属性值是 <code>SpEL</code> 表达式，则在通过 <code>@Value</code> 消耗时将对其进行评估。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/78b073208053e52fcb0125ca0257dfe8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用Linux查看Tensorboard</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5d47d8c2d0e4bf8f33165d70feb114b8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">安装NETDATA集群监控面板</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>