<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【读书笔记】深入理解Java虚拟机（周志明）（5）第五部分 高效并发 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【读书笔记】深入理解Java虚拟机（周志明）（5）第五部分 高效并发" />
<meta property="og:description" content="文章目录 文章说明第五部分 高效并发第12章 Java内存模型与线程12.1 概述12.2 硬件的效率与一致性12.3 Java内存模型12.3.1 主内存与工作内存12.3.2 内存间交互操作12.3.3 对于volatile型变量的特殊规则12.3.4 对于long和double型变量的特殊规则12.3.5 原子性、可见性与有序性12.3.6 先行发生原则 12.4 Java与线程12.4.1 线程的实现12.4.2 Java线程调度12.4.3 状态转换 第13章 线程安全与锁优化13.1 概述13.2 线程安全13.2.1 Java语言中的线程安全13.2.2 线程安全的实现方法 13.3 锁优化13.3.1 自旋锁与自适应自旋13.3.2 锁消除13.3.3 锁粗化13.3.4 轻量级锁13.3.5 偏向锁 文章说明 本文是《深入理解Java虚拟机（周志明）》这本书的重点摘要。
本笔记仅作为复习，不过多的对内容进行讲解。
本笔记按照书的目录进行，如遇到需要细看的，可以到书中找对应内容。
本笔记并不是按照书中原话进行摘要，而是根据自己的理解使用大白话进行记录，同时进行了少部分扩展。如有错误欢迎指出。
由于内容较多，一共分为三篇：
篇幅链接深入理解Java虚拟机（周志明）（1）第一部分 走进Java（2）第二部分 自动内存管理机制https://blog.csdn.net/zhaohongfei_358/article/details/134927759深入理解Java虚拟机（周志明）（3）第三部分 虚拟机执行子系统（4）第四部分 程序编译与代码优化https://blog.csdn.net/zhaohongfei_358/article/details/135067398深入理解Java虚拟机（周志明）（5）第五部分 高效并发https://blog.csdn.net/zhaohongfei_358/article/details/135111650 第五部分 高效并发 第12章 Java内存模型与线程 12.1 概述 无重点
12.2 硬件的效率与一致性 硬件在并行计算时处理一致性问题的方式是增加了一层“缓存一致性协议”，如图所示：
12.3 Java内存模型 Java内存模型的主要目标是：定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。
12.3.1 主内存与工作内存 Java内存分为主内存和线程工作内存。
主内存线程共享。
各个线程有自己的工作内存。
线程只能使用自己的工作内存，不能直接读写主内存，只能将主内存的变量拷贝一个副本到自己的工作内存，然后再同步给主内存。
12.3.2 内存间交互操作 Java内存模型定义了8种“原子操作”来进行工作内存和主内存的交互：
lock：锁定主内存中的某个变量；unlock：释放lock锁定的变量锁。read：将主内存的变量传输到工作内存中。load：将read到工作内存的变量生成副本。use：使用工作内存中的变量，即将变量值传递给执行引擎。assign（赋值）：将执行引擎返回的结果值赋值给工作内存中的变量。store：将工作内存的值传输到主内存。write：将store过来的变量值放入到主内存变量中。 线程读变量就是“read&#43;load”操作，写变量就是“store&#43;write”操作。
read和load之间可以插入其他操作，例如：可以 read a, read b, load a, load b。 （store&#43;write同理）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/f84943962dbb4cb40d046ef854d6802b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-25T09:15:50+08:00" />
<meta property="article:modified_time" content="2023-12-25T09:15:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【读书笔记】深入理解Java虚拟机（周志明）（5）第五部分 高效并发</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_2" rel="nofollow">文章说明</a></li><li><a href="#__20" rel="nofollow">第五部分 高效并发</a></li><li><ul><li><a href="#12_Java_22" rel="nofollow">第12章 Java内存模型与线程</a></li><li><ul><li><a href="#121__24" rel="nofollow">12.1 概述</a></li><li><a href="#122__28" rel="nofollow">12.2 硬件的效率与一致性</a></li><li><a href="#123_Java_34" rel="nofollow">12.3 Java内存模型</a></li><li><ul><li><a href="#1231__38" rel="nofollow">12.3.1 主内存与工作内存</a></li><li><a href="#1232__50" rel="nofollow">12.3.2 内存间交互操作</a></li><li><a href="#1233_volatile_75" rel="nofollow">12.3.3 对于volatile型变量的特殊规则</a></li><li><a href="#1234_longdouble_121" rel="nofollow">12.3.4 对于long和double型变量的特殊规则</a></li><li><a href="#1235__127" rel="nofollow">12.3.5 原子性、可见性与有序性</a></li><li><a href="#1236__133" rel="nofollow">12.3.6 先行发生原则</a></li></ul> 
    </li><li><a href="#124_Java_144" rel="nofollow">12.4 Java与线程</a></li><li><ul><li><a href="#1241__146" rel="nofollow">12.4.1 线程的实现</a></li><li><a href="#1242_Java_157" rel="nofollow">12.4.2 Java线程调度</a></li><li><a href="#1243__164" rel="nofollow">12.4.3 状态转换</a></li></ul> 
   </li></ul> 
   </li><li><a href="#13__179" rel="nofollow">第13章 线程安全与锁优化</a></li><li><ul><li><a href="#131__181" rel="nofollow">13.1 概述</a></li><li><a href="#132__185" rel="nofollow">13.2 线程安全</a></li><li><ul><li><a href="#1321_Java_189" rel="nofollow">13.2.1 Java语言中的线程安全</a></li><li><a href="#1322__200" rel="nofollow">13.2.2 线程安全的实现方法</a></li></ul> 
    </li><li><a href="#133__209" rel="nofollow">13.3 锁优化</a></li><li><ul><li><a href="#1331__211" rel="nofollow">13.3.1 自旋锁与自适应自旋</a></li><li><a href="#1332__221" rel="nofollow">13.3.2 锁消除</a></li><li><a href="#1333__226" rel="nofollow">13.3.3 锁粗化</a></li><li><a href="#1334__235" rel="nofollow">13.3.4 轻量级锁</a></li><li><a href="#1335__239" rel="nofollow">13.3.5 偏向锁</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_2"></a>文章说明</h2> 
<p>本文是《深入理解Java虚拟机（周志明）》这本书的重点摘要。</p> 
<p>本笔记仅作为复习，不过多的对内容进行讲解。</p> 
<p>本笔记按照书的目录进行，如遇到需要细看的，可以到书中找对应内容。</p> 
<p>本笔记并不是按照书中原话进行摘要，而是根据自己的理解使用大白话进行记录，同时进行了少部分扩展。如有错误欢迎指出。</p> 
<p>由于内容较多，一共分为三篇：</p> 
<table><thead><tr><th>篇幅</th><th>链接</th></tr></thead><tbody><tr><td><a href="https://blog.csdn.net/zhaohongfei_358/article/details/134927759">深入理解Java虚拟机（周志明）（1）第一部分 走进Java（2）第二部分 自动内存管理机制</a></td><td>https://blog.csdn.net/zhaohongfei_358/article/details/134927759</td></tr><tr><td><a href="https://blog.csdn.net/zhaohongfei_358/article/details/135067398">深入理解Java虚拟机（周志明）（3）第三部分 虚拟机执行子系统（4）第四部分 程序编译与代码优化</a></td><td>https://blog.csdn.net/zhaohongfei_358/article/details/135067398</td></tr><tr><td><a href="https://blog.csdn.net/zhaohongfei_358/article/details/135111650">深入理解Java虚拟机（周志明）（5）第五部分 高效并发</a></td><td>https://blog.csdn.net/zhaohongfei_358/article/details/135111650</td></tr></tbody></table> 
<h2><a id="__20"></a>第五部分 高效并发</h2> 
<h3><a id="12_Java_22"></a>第12章 Java内存模型与线程</h3> 
<h4><a id="121__24"></a>12.1 概述</h4> 
<p>无重点</p> 
<h4><a id="122__28"></a>12.2 硬件的效率与一致性</h4> 
<p>硬件在并行计算时处理一致性问题的方式是增加了一层“缓存一致性协议”，如图所示：</p> 
<p><img src="https://images2.imgbox.com/48/59/g2w8ByZB_o.png" alt="在这里插入图片描述" width="500"></p> 
<h4><a id="123_Java_34"></a>12.3 Java内存模型</h4> 
<p>Java内存模型的主要目标是：定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</p> 
<h5><a id="1231__38"></a>12.3.1 主内存与工作内存</h5> 
<p>Java内存分为主内存和线程工作内存。</p> 
<p>主内存线程共享。</p> 
<p>各个线程有自己的工作内存。</p> 
<p>线程只能使用自己的工作内存，不能直接读写主内存，只能将主内存的变量拷贝一个副本到自己的工作内存，然后再同步给主内存。</p> 
<p><img src="https://images2.imgbox.com/a1/57/PZ39dwFC_o.png" alt="在这里插入图片描述" width="500"></p> 
<h5><a id="1232__50"></a>12.3.2 内存间交互操作</h5> 
<p>Java内存模型定义了8种“原子操作”来进行工作内存和主内存的交互：</p> 
<ol><li><strong>lock</strong>：锁定主内存中的某个变量；</li><li><strong>unlock</strong>：释放lock锁定的变量锁。</li><li><strong>read</strong>：将主内存的变量传输到工作内存中。</li><li><strong>load</strong>：将read到工作内存的变量生成副本。</li><li><strong>use</strong>：使用工作内存中的变量，即将变量值传递给执行引擎。</li><li><strong>assign</strong>（赋值）：将执行引擎返回的结果值赋值给工作内存中的变量。</li><li><strong>store</strong>：将工作内存的值传输到主内存。</li><li><strong>write</strong>：将store过来的变量值放入到主内存变量中。</li></ol> 
<p>线程读变量就是“read+load”操作，写变量就是“store+write”操作。</p> 
<blockquote> 
 <p>read和load之间可以插入其他操作，例如：可以 read a, read b, load a, load b。 （store+write同理）</p> 
</blockquote> 
<p>并发问题举例：</p> 
<p>假设A，B线程都要对变量x进行<code>x++</code>操作：</p> 
<ul><li>正常执行顺序：① A线程从主内存读取<code>x=1</code>变量；② A线程执行<code>x++</code>操作；③ A线程将<code>x=2</code>写回主内存。④ B线程从主内存读取<code>x=2</code>变量；⑤ B线程执行<code>x++</code>操作；⑥ B线程将<code>x=3</code>写回主内存。⑦ 最终主内存中，<code>x=3</code></li><li>异常执行顺序：① A线程从主内存读取<code>x=1</code>变量；② A线程执行<code>x++</code>操作；③ B线程从主内存读取<code>x=1</code>变量；④ A线程将<code>x=2</code>写回主内存；⑤ B线程执行<code>x++</code>操作；⑥ B线程将<code>x=2</code>写回主内存；⑦ 最终主内存中，<code>x=2</code>产生并发问题，x少加了一次。</li></ul> 
<h5><a id="1233_volatile_75"></a>12.3.3 对于volatile型变量的特殊规则</h5> 
<p><code>volatile</code>的两个作用：</p> 
<ol><li>volatile是保证此变量对所有线程的<strong>可见性</strong>。</li><li>禁止指令重排序优化</li></ol> 
<p>上一节说到，每个线程都有自己的工作线程。因此，当变量增加了<code>volatile</code>修饰符，表示该变量的所有修改对其他线程都是立即可见的，即其他线程知道该变量被其他线程修改了。</p> 
<p>注意：<strong>但<code>volatile</code>变量并不是线程安全的</strong>。</p> 
<p>线程在使用<code>volatile</code>变量前，每次都要刷新。但是<strong>在后面执行引擎“做变量计算”期间，若该变量被其他线程修改，则会产生不一致问题。</strong></p> 
<p>不一致问题举例：假设A,B两个线程都要“不断地”对<code>volatile</code>的<code>x</code>变量做<code>x=x+1</code>操作：</p> 
<ol><li>A线程读取<code>x=0</code></li><li>B线程读取<code>x=0</code></li><li>A线程执行<code>x=x+1</code>操作</li><li>由于<code>x</code>是<code>volatile</code>的，B线程刷新<code>x</code>的值，此时B线程中<code>x=1</code>。</li><li>B线程执行<code>x+1</code>（即<code>1+1</code>）操作。（注意：这里B线程只是做了<code>x+1</code>操作，还没进行赋值）</li><li>A线程又一次执行了<code>x=x+1</code>操作。此时，<code>x=2</code>了。</li><li>B线程<code>1+1</code>执行完毕，执行x赋值操作，即<code>x=2</code>。</li><li>最终，A线程执行了两次，B线程执行了1次，但最终<code>x=2</code>，少了一次。</li></ol> 
<p>因此，Volatile由于具备了可见性，可以一定程度上缓解不一致问题，但并不能完全避免。</p> 
<p><code>volatile</code>的使用场景：<strong>当某个变量只会被一个线程做修改操作时，<code>volatile</code>就可以保证一致性</strong>。这就决定了它的应用场景。</p> 
<p>例如：</p> 
<pre><code class="prism language-java"> <span class="token comment">// 一个资源类只需要被关闭一次，即只有一个线程会对该变量做修改操作。</span>
<span class="token keyword">volatile</span> <span class="token keyword">boolean</span> shutdownRequested<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
    shutdownRequested <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>shutdownRequested<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// do something</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="1234_longdouble_121"></a>12.3.4 对于long和double型变量的特殊规则</h5> 
<p>对于long和double这些64位的数据类型。Java内存模型规定在做<code>read</code>和<code>write</code>（12.3.2中提到的）操作时可以将其分成两个32位进行操作，即可以不保证其原子性。（可能是为了加速吧）这样就可能会读到半个long变量</p> 
<blockquote> 
 <p>不过现在的虚拟机在实现时还是将64位的<code>read</code>和<code>write</code>按照原子操作实现，因此不用担心上述的事情。</p> 
</blockquote> 
<h5><a id="1235__127"></a>12.3.5 原子性、可见性与有序性</h5> 
<p><strong>原子性</strong>（Atomictiy）：Java内存模型的操作(<code>read</code>、<code>write</code>、<code>assign</code>等，见12.3.2节)都是原子性的。<br> <strong>可见性</strong>（Visibility）：被<code>volatile</code>修饰的变量在线程之间是可见的。（见12.3.3节）<br> <strong>有序性</strong>（Ordering）：如果在本线程来看，所有的操作都是有序的，即“线程内‘表现为’串行的语义”。但如果在一个线程中观察另一个线程，所有的操作都是无序的，即“指令重排序”和“工作内存与主内存同步延迟”现象。</p> 
<h5><a id="1236__133"></a>12.3.6 先行发生原则</h5> 
<p>Java内存模型定义了“先行发生（happens-before）”，我们可以通过这些原则来判断哪些操作一定是先执行的，帮助排查并发问题。</p> 
<p>具体有：</p> 
<ul><li><strong>程序次序规则（Program Order Rule）</strong>：一个线程内，控制流顺序一定是按照顺序执行的。</li><li><strong>管程锁定规则（Monitor Lock Rule）</strong>：<code>unlock</code>操作一定比起对应的<code>lock</code>操作后执行</li><li><strong>volatile变量规则（Volatile Variable Rule）</strong>：volatile的变量的写操作一定比其后面的读操作先执行</li><li>…</li></ul> 
<h4><a id="124_Java_144"></a>12.4 Java与线程</h4> 
<h5><a id="1241__146"></a>12.4.1 线程的实现</h5> 
<p>Java中的<code>Thread</code>类的许多方法都是<code>native</code>的，这是因为对线程的实现，不同平台区别较大，无法做到平台无关。</p> 
<p>实现线程主要有三种方式：</p> 
<ol><li><strong>使用内核线程实现</strong>：由操作系统内核进行线程管理（创建、切换、调度等）。多个线程可以同时使用多个CPU，当一个线程阻塞，不影响其他线程的继续运行。</li><li><strong>使用用户线程实现</strong>：由用户态直接进行线程管理。操作系统不知道用户线程的存在（可以理解为就是假线程），因此无法利用多CPU并行计算，只能并发运行。若一个线程阻塞，就会影响到其他线程。用户线程的优点是轻量级，创建、销毁等都比较快。</li><li><strong>混合实现</strong>：同时结合了内核线程和用户线程两种模式。</li></ol> 
<h5><a id="1242_Java_157"></a>12.4.2 Java线程调度</h5> 
<p>线程调度是指<strong>系统为线程分配CPU使用权的过程</strong>。有两种方式：</p> 
<ul><li><strong>协同式调度</strong>：线程自己决定什么时候让出CPU。</li><li><strong>抢占式调度</strong>（Java线程采用的方式）：由操作系统自行决定线程的执行和挂起。不过可以通过<code>thread.setPriority(int newPriority)</code>来设置线程的优先级。</li></ul> 
<h5><a id="1243__164"></a>12.4.3 状态转换</h5> 
<p>Java线程有5种状态：</p> 
<ol><li><strong>新建</strong>（New）：创建后尚未启动。</li><li><strong>运行</strong>（Runnable）：线程正在CPU上运行或者等待被CPU调度。</li><li><strong>无限期等待</strong>（Waiting）：线程无限等待，直到被其他线程唤醒。下面代码会产生无限等待： 
  <ul><li><code>obj.wait()</code>：当线程A对某个被<code>synchronized(obj)</code>了的<code>obj</code>对象调用了<code>obj.wait()</code>后，则线程A会暂时释放该对象的锁（表示自己需要的资源还没到，先让出锁），并且线程A开始阻塞，直到其他线程调用了<code>obj.notify()</code>。当另一个线程B在获取了<code>obj</code>的锁后，即<code>synchronized(obj)</code>，若调用了<code>obj.notify()</code>，则线程A就会恢复执行。</li><li><code>thread.join()</code>：如果线程A中调用了<code>threadB.join()</code>，那么线程A就会阻塞，直到<code>threadB</code>运行结束。</li></ul> </li><li><strong>限期等待</strong>（Timed Waiting）：线程等待，但有个等待时间。若调用了<code>obj.wait(long timeout)</code>或<code>thread.join(long millis)</code>，即给<code>wait</code>或<code>join</code>方法传了个超时时间，那就是限期等待。<code>Thread.sleep(long timeout)</code>也算限期等待。</li><li><strong>阻塞</strong>（Blocked）：当线程在等待获取锁时，就处于阻塞状态。</li><li><strong>结束</strong>（Terminated）：线程执行结束。</li></ol> 
<p><img src="https://images2.imgbox.com/ba/26/VNEeoCQ5_o.png" alt="在这里插入图片描述" width="400"></p> 
<h3><a id="13__179"></a>第13章 线程安全与锁优化</h3> 
<h4><a id="131__181"></a>13.1 概述</h4> 
<p>本章是将如何保证线程并发的安全与高效。</p> 
<h4><a id="132__185"></a>13.2 线程安全</h4> 
<p>线程安全：若一个对象具备“调用者在调用时不需要考虑多线程会带来错误的结果，所有的正确性保障手段（如互斥同步等）都在对象内部被封装好了”，那么我们就说这个对象是线程安全的。</p> 
<h5><a id="1321_Java_189"></a>13.2.1 Java语言中的线程安全</h5> 
<p>我们可以按照将一个对象的线程安全程度将其从高到低划分为5类：</p> 
<ol><li><strong>不可变</strong>（Immutable）：如果一个对象是不可变的，那么是一定线程安全的。例如：被final修饰的变量，被<code>Collections.unmodifiableCollection(...)</code>修饰的集合等。</li><li><strong>绝对线程安全</strong>：不需要任何同步措施的对象。反例：<code>Vector</code>大家都知道是线程安全的，但其并不是绝对线程安全的。假设两个线程同时对一个vector做<code>remove</code>，即<code>for (int i=0; i&lt;vector.size(); i++) {vector.remove(i)}</code>，最终会报数组越界错误。此时就要加入一些同步措施保证线程的安全。</li><li><strong>相对线程安全</strong>：通常意义上的线程安全。例如：<code>Vector</code>、<code>HashTable</code>、<code>ConcurrentHashMap</code>。在必要时候（例如2中的例子），还是需要做一些同步措施。</li><li><strong>线程兼容</strong>：一个对象虽然不是线程安全的，但是我们可以增加一些额外的同步措施来保证线程安全。例如：<code>ArrayList</code>等</li><li><strong>线程对立</strong>：无论采用什么同步方式都会产生并发问题。例如：<code>Thread.suspend</code>和<code>Thread.resume()</code>。</li></ol> 
<h5><a id="1322__200"></a>13.2.2 线程安全的实现方法</h5> 
<p>实现线程安全通常有以下几种方案：</p> 
<ol><li><strong>互斥同步</strong>（Mutual Exclusion&amp;synchronization）：对需要线程安全的对象进行加锁。可以使用<code>sychronized</code>、<code>ReentrantLock</code>等。</li><li><strong>非阻塞同步</strong>：先进行操作，如果没有其他线程争用共享数据，则操作成功。否则，就采取其他措施（例如重试或报错）。</li><li><strong>无同步方案</strong>：如果一段代码不涉及共享数据，那么这段代码就是线程安全的。</li></ol> 
<h4><a id="133__209"></a>13.3 锁优化</h4> 
<h5><a id="1331__211"></a>13.3.1 自旋锁与自适应自旋</h5> 
<p>当一个线程需要等待锁时，会有两种阻塞方式：</p> 
<ul><li><strong>挂起线程</strong>：由操作系统将线程挂起或恢复。这些操作需要在内核态完成。适合阻塞时间较长的线程。</li><li><strong>自旋</strong>：若预计阻塞时间很短，则可以采用自旋方式，即类似<code>while(true) {}</code> 这样。线程依然会在CPU上运行，没有被挂起。</li></ul> 
<p>JDK采取了一套方案来预测阻塞时长，自适应的决定要不要采用自旋方式加锁，即自适应自旋。</p> 
<h5><a id="1332__221"></a>13.3.2 锁消除</h5> 
<p>如果一段代码加了锁，但虚拟机发现其实没有必要加锁，那么在真正执行的时候实际上是不会上锁的。（即11.3.5提到的“逃逸分析”）</p> 
<h5><a id="1333__226"></a>13.3.3 锁粗化</h5> 
<p>在加锁时要把我两个原则：</p> 
<ol><li><strong>锁要细</strong>：同步操作尽可能小（即需要被加锁的代码尽可能少），这样可以让锁快速被释放，不至于其他线程等待太久。</li><li><strong>锁又要粗</strong>：由于加解锁是个比较耗资源的行为，如果太频繁也不好。</li></ol> 
<p>因此，实践中1,2最好做一个权衡取舍。例如：循环中的频繁加锁就可以看看能否挪出来放在循环外面。</p> 
<h5><a id="1334__235"></a>13.3.4 轻量级锁</h5> 
<p>在无竞争的情况下使用CAS操作消除同步使用的互斥量，以达到优化性能的目的。</p> 
<h5><a id="1335__239"></a>13.3.5 偏向锁</h5> 
<p>在无竞争的情况下，第一个获取锁的线程实际上不加锁。等到有第二个线程要获取锁时，再恢复第一个线程的锁。</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/628df68b16835d8bba56b216f519ad31/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【读书笔记】深入理解Java虚拟机（周志明）（3）第三部分 虚拟机执行子系统（4）第四部分 程序编译与代码优化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ae855888a4771ea42926f375d624e0ff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于OpenCV的图像颜色与形状识别设计与实现实验指导书</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>