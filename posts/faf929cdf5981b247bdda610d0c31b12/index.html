<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Flask Mega-Tutorial V2.0 第18章：在Heroku上部署 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Flask Mega-Tutorial V2.0 第18章：在Heroku上部署" />
<meta property="og:description" content="最近在Flask Web Development作者博客看到第二版Flask Mega-Tutorial已在2017年底更新，现翻译给大家参考，希望帮助大家学习flask。
这是Flask Mega-Tutorial系列的第十八章，我将在其中部署Microblog到Heroku云平台。供您参考，以下是本系列文章的列表。
第1章：Hello, World！第2章：模板 第3章：Web表单第4章：数据库第5章：用户登录第6章：配置文件页面和头像第7章：错误处理第8章：关注与被关注第9章：分页第10章：电子邮件支持第11章：整容第12章：日期和时间第13章：I18n和L10n第14章：Ajax第15章：大型应用程序结构第16章：全文搜索第17章：在Linux上部署第18章：在Heroku上部署（本文）第19章：Docker容器上的部署第20章：一些JavaScript Magic第21章：用户通知第22章：后台工作第23章：应用程序编程接口（API） 注意1：如果您正在寻找本教程的旧版本，请在此处。
注意2：如果您想在此博客上支持我的工作，或者只是没有耐心等待每周的文章，我将提供完整的本教程版本，打包成电子书或视频集。欲了解更多信息，请访问courses.miguelgrinberg.com。
在上一篇文章中，我向您展示了托管Python应用的“传统”方式，并且为您提供了两个实际的示例，以将其部署到基于Linux的服务器上。如果您不习惯于管理Linux系统，您可能会认为需要花很多精力在任务上，并且肯定有一种更简单的方法。
在本章中，我将向您展示一种完全不同的方法，在这种方法中，您依赖第三方云托管提供商来执行大多数管理任务，从而使您腾出更多时间来处理应用程序。
许多云托管提供商提供了一个应用程序可以运行的托管平台。 你只需提供部署到这些平台上的实际应用程序，因为硬件，操作系统，脚本语言解释器，数据库等都由该服务管理。 这种服务称为平台即服务（PaaS）。
听起来好得令人难以置信，对吧？
我将研究将Microblog部署到Heroku，Heroku是一种流行的云托管服务，对Python应用程序也非常友好。我之所以选择Heroku，不仅是因为它很受欢迎，还因为它具有免费的服务水平，使您可以跟随我并进行完整的部署而无需花任何钱。
本章的GitHub链接是：Browse，Zip，Diff。
在Heroku上托管 Heroku是最早的服务提供商平台之一。它最初是作为基于Ruby的应用程序的托管选项，但后来发展为支持许多其他语言，例如Java，Node.js，当然还有Python。
将Web应用部署到Heroku是通过git版本控制工具完成的，因此您必须将应用程序放置在git代码库中。Heroku在应用程序的根目录中查找一个名为Procfile的文件，以获取有关如何启动该应用的说明。对于Python项目，Heroku还希望有一个requirements.txt文件，其中列出了需要安装的所有模块依赖项。通过git将应用程序上传到Heroku的服务器后，您基本上已经完成，只需等待几秒钟，直到应用程序在线即可。真的就是这么简单。
Heroku提供的不同服务级别，允许您选择为应用程序获得多少计算能力和时间，因此随着用户群的增长，您将需要购买更多的计算单元，Heroku称之为“ dynos”。
准备尝试Heroku了吗？让我们开始吧！
创建Heroku帐户 您需要先拥有一个帐户，然后才能部署到Heroku。因此，请访问heroku.com并创建一个免费帐户。拥有帐户并登录到Heroku后，您将可以访问dashboard，其中列出了你的所有应用程序。
安装Heroku CLI Heroku提供了一个命令行工具，用于与其名为Heroku CLI的服务进行交互，该工具可用于Windows，Mac OS X和Linux。 该文档包括了支持的所有平台的安装说明。 如果你计划部署应用程序以测试该服务，请将其安装在你的系统上。
一旦安装了CLI，您应该做的第一件事就是登录到您的Heroku帐户：
$ heroku login Heroku CLI会要求您输入电子邮件地址和帐户密码。你的身份验证状态将在随后的命令中被记住。
设置Git git工具是Heroku应用程序部署的核心，因此如果你还没有安装它的话，则必须将它安装到你的系统上。 如果你没有可用于你的操作系统的安装包，则可以访问git站点以下载安装程序。
使用git的原因很多并且都理由充分。 如果你打算部署应用到Heroku，那么这些原因就要又增加一个，因为要部署应用到Heroku，你的应用程序必须在git代码库中。 如果你要为Microblog执行测试部署，可以从GitHub克隆应用程序：
$ git clone https://github.com/miguelgrinberg/microblog $ cd microblog $ git checkout v0.18 git checkout命令将代码库切换到指定的历史提交点，也就是本章所处的位置。
如果您喜欢使用自己的代码而不是我的代码，你可以通过在顶层目录中运行git init .来将你自己的项目转换成git代码库（注意init后面的句号，它告诉git你想要在当前目录中初始化代码库）。
创建一个Heroku应用 要向Heroku注册新应用，请使用应用程序根目录中的命令apps:create，并将应用程序名称作为唯一参数传递：
$ heroku apps:create flask-microblog Creating flask-microblog." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/faf929cdf5981b247bdda610d0c31b12/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-20T22:50:17+08:00" />
<meta property="article:modified_time" content="2021-03-20T22:50:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Flask Mega-Tutorial V2.0 第18章：在Heroku上部署</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>最近在Flask Web Development作者博客看到第二版Flask Mega-Tutorial已在2017年底更新，现翻译给大家参考，希望帮助大家学习flask。</p> 
</blockquote> 
<p>这是Flask Mega-Tutorial系列的第十八章，我将在其中部署Microblog到Heroku云平台。供您参考，以下是本系列文章的列表。</p> 
<ul><li><a href="https://blog.csdn.net/gh254172840/article/details/81409498">第1章：Hello, World！</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410270">第2章：模板</a> </li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410281">第3章：Web表单</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410292">第4章：数据库</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410296">第5章：用户登录</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410299">第6章：配置文件页面和头像</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410299">第7章：错误处理</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410311">第8章：关注与被关注</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410319">第9章：分页</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410325">第10章：电子邮件支持</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410332">第11章：整容</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410334">第12章：日期和时间</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410340">第13章：I18n和L10n</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410341">第14章：Ajax</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410350">第15章：大型应用程序结构</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410355">第16章：全文搜索</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410357">第17章：在Linux上部署</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410363">第18章：在Heroku上部署</a>（本文）</li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410368">第19章：Docker容器上的部署</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410372">第20章：一些JavaScript Magic</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410382">第21章：用户通知</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410386">第22章：后台工作</a></li><li><a href="https://blog.csdn.net/gh254172840/article/details/81410391">第23章：应用程序编程接口（API）</a></li></ul> 
<p><em>注意1：如果您正在寻找本教程的旧版本，请<a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world-legacy" rel="nofollow">在此处</a>。</em></p> 
<p><em>注意2：如果您想在此博客上支持我的工作，或者只是没有耐心等待每周的文章，我将提供完整的本教程版本，打包成电子书或视频集。欲了解更多信息，请访问<a href="https://courses.miguelgrinberg.com/" rel="nofollow">courses.miguelgrinberg.com</a>。</em></p> 
<p style="margin-left:0px;"><span style="color:#333333;">在上一篇文章中，我向您展示了托管Python应用的“传统”方式，并且为您提供了两个实际的示例，以将其部署到基于Linux的服务器上。如果您不习惯于管理Linux系统，您可能会认为需要花很多精力在任务上，并且肯定有一种更简单的方法。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">在本章中，我将向您展示一种完全不同的方法，在这种方法中，您依赖第三方<em>云</em>托管提供商来执行大多数管理任务，从而使您腾出更多时间来处理应用程序。</span></p> 
<p style="margin-left:0px;">许多云托管提供商提供了一个应用程序可以运行的托管平台。 你只需提供部署到这些平台上的实际应用程序，因为硬件，操作系统，脚本语言解释器，数据库等都由该服务管理。 这种服务称为<a href="https://en.wikipedia.org/wiki/Platform_as_a_service" rel="nofollow">平台即服务</a>（PaaS）。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">听起来好得令人难以置信，对吧？</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">我将研究将Microblog部署到<a href="http://heroku.com/" rel="nofollow">Heroku</a>，<a href="http://heroku.com/" rel="nofollow">Heroku</a>是一种流行的云托管服务，对Python应用程序也非常友好。我之所以选择Heroku，不仅是因为它很受欢迎，还因为它具有免费的服务水平，使您可以跟随我并进行完整的部署而无需花任何钱。</span></p> 
<p><em>本章的GitHub链接是：<a href="https://github.com/miguelgrinberg/microblog/tree/v0.18">Browse</a>，<a href="https://github.com/miguelgrinberg/microblog/archive/v0.18.zip">Zip</a>，<a href="https://github.com/miguelgrinberg/microblog/compare/v0.17...v0.18">Diff</a>。</em></p> 
<hr> 
<h3><span style="color:#333333;">在Heroku上托管</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">Heroku是最早的服务提供商平台之一。它最初是作为基于Ruby的应用程序的托管选项，但后来发展为支持许多其他语言，例如Java，Node.js，当然还有Python。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">将Web应用部署到Heroku是通过<code>git</code>版本控制工具完成的，因此您必须将应用程序放置在git代码库中。Heroku在应用程序的根目录中查找一个名为<em>Procfile</em>的文件，以获取有关如何启动该应用的说明。对于Python项目，Heroku还希望有一个<em>requirements.txt</em>文件，其中列出了需要安装的所有模块依赖项。通过git将应用程序上传到Heroku的服务器后，您基本上已经完成，只需等待几秒钟，直到应用程序在线即可。真的就是这么简单。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">Heroku提供的不同服务级别，允许您选择为应用程序获得多少计算能力和时间，因此随着用户群的增长，您将需要购买更多的计算单元，Heroku称之为“ dynos”。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">准备尝试Heroku了吗？让我们开始吧！</span></p> 
<h3><span style="color:#333333;">创建Heroku帐户</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">您需要先拥有一个帐户，然后才能部署到Heroku。因此，请访问<a href="https://id.heroku.com/signup" rel="nofollow">heroku.com</a>并创建一个免费帐户。拥有帐户并登录到Heroku后，您将可以访问</span>dashboard，其中列出了你的所有应用程序。</p> 
<h3><span style="color:#333333;">安装Heroku CLI</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">Heroku提供了一个命令行工具，用于与其名为<a href="https://devcenter.heroku.com/articles/heroku-cli" rel="nofollow">Heroku CLI</a>的服务进行交互，该工具可用于Windows，Mac OS X和Linux。</span> 该文档包括了支持的所有平台的安装说明。 如果你计划部署应用程序以测试该服务，请将其安装在你的系统上。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">一旦安装了CLI，您应该做的第一件事就是登录到您的Heroku帐户：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">$ heroku login</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">Heroku CLI会要求您输入电子邮件地址和帐户密码。</span>你的身份验证状态将在随后的命令中被记住。</p> 
<h3><span style="color:#333333;">设置Git</span></h3> 
<p style="margin-left:0px;"><code>git</code>工具是Heroku应用程序部署的核心，因此如果你还没有安装它的话，则必须将它安装到你的系统上。 如果你没有可用于你的操作系统的安装包，<span style="color:#333333;">则可以访问<a href="https://git-scm.com/" rel="nofollow">git站点</a>以下载安装程序。</span></p> 
<p style="margin-left:0px;">使用<code>git</code>的原因很多并且都理由充分。 如果你打算部署应用到Heroku，那么这些原因就要又增加一个，因为要部署应用到Heroku，你的应用程序必须在<code>git</code>代码库中。 如果你要为Microblog执行测试部署，可以从GitHub克隆应用程序：</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">$ git clone https://github.com/miguelgrinberg/microblog
$ cd microblog
$ git checkout v0.18</code></pre> 
<p style="margin-left:0px;"><code>git checkout</code>命令将代码库切换到指定的历史提交点，也就是本章所处的位置。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">如果您喜欢使用自己的代码而不是我的代码，</span>你可以通过在顶层目录中运行<code>git init .</code>来将你自己的项目转换成<code>git</code>代码库（注意<code>init</code>后面的句号，它告诉git你想要在当前目录中初始化代码库）。</p> 
<h3><span style="color:#333333;">创建一个Heroku应用</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">要向Heroku注册新应用，请使用应用程序根目录中的命令<code>apps:create</code>，并将应用程序名称作为唯一参数传递：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">$ heroku apps:create flask-microblog
Creating flask-microblog... done
http://flask-microblog.herokuapp.com/ | https://git.heroku.com/flask-microblog.git</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">Heroku要求应用程序具有唯一的名称。我上面使用的名称<code>flask-microblog</code>将无法使用，因为我正在使用它，因此您需要为部署选择其他不同的名称。</span></p> 
<p style="margin-left:0px;">该命令的输出将包含Heroku分配给应用程序的URL以及git代码库。 你的本地git代码库将配置一个额外的<em>remote</em>，称为<code>heroku</code>。 你可以用<code>git remote</code>命令验证它是否存在：</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">$ git remote -v
heroku  https://git.heroku.com/flask-microblog.git (fetch)
heroku  https://git.heroku.com/flask-microblog.git (push)</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">根据您创建git代码库的方式，上述命令的输出还可能包含另一个名为</span><code>origin</code>的远程仓库地址。</p> 
<h3><span style="color:#333333;">临时文件系统</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">Heroku平台与其他部署平台的不同之处在于，它具有在虚拟化平台上运行的<em>临时</em>文件系统。那是什么意思？这意味着Heroku可以随时将服务器上运行的虚拟服务器重置为干净状态。您不能假设保存到文件系统的任何数据都会保留，实际上，Heroku经常回收服务器。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">在这些条件下工作会给我的应用带来一些问题，</span>因为它使用了如下的几个文件：</p> 
<ul><li>默认的SQLite数据库引擎将数据写入磁盘文件中</li><li>该应用程序的日志也被写入磁盘文件中</li><li>编译后的语言翻译存储库也被写入本地文件</li></ul> 
<p style="margin-left:0px;"><span style="color:#333333;">以下各节将介绍这三个领域。</span></p> 
<h3><span style="color:#333333;">使用Heroku Postgres数据库</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">为了解决第一个问题，我将切换到其他数据库引擎。在<a href="https://blog.csdn.net/gh254172840/article/details/81410355">第17章中，</a>您</span>看到我使用MySQL数据库为Ubuntu部署添加健壮性。 Heroku基于Postgres数据库提供了自己的数据库产品，因此我将转而使用它来避免使用基于文件的SQLite。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">Heroku应用的数据库配备了相同的Heroku CLI。</span>在本章中，我将创建一个免费级别的数据库：</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">$ heroku addons:add heroku-postgresql:hobby-dev
Creating heroku-postgresql:hobby-dev on flask-microblog... free
Database has been created and is available
 ! This database is empty. If upgrading, you can transfer
 ! data from another database with pg:copy
Created postgresql-parallel-56076 as DATABASE_URL
Use heroku addons:docs heroku-postgresql to view documentation</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">新创建的数据库的URL存储在 <code>DATABASE_URL </code>环境变量中，该环境变量在应用程序运行时将可用。这非常方便，</span>因为应用程序已经设定为在该变量中查找数据库URL。</p> 
<h3>输出日志到标准输出</h3> 
<p style="margin-left:0px;">Heroku希望应用程序直接输出日志到<code>stdout</code>。 当你使用<code>heroku logs</code>命令时，应用程序打印到标准输出的任何内容都将被保存并返回。 所以我要添加一个配置变量，指示我是要输出日志到<code>stdout</code>，还是像我之前那样输出到文件。 这是配置的变化：</p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>config.py</em>：</span>日志到标准输出的选项。</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint">class Config(object):
    # ...
    LOG_TO_STDOUT = os.environ.get('LOG_TO_STDOUT')</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">然后在应用程序工厂函数中，我可以检查此配置，以了解如何配置应用程序的日志记录器：</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>app/__ init__.py</em>：日志到标准输出或文件。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-python">def create_app(config_class=Config):
    # ...
    if not app.debug and not app.testing:
        # ...

        if app.config['LOG_TO_STDOUT']:
            stream_handler = logging.StreamHandler()
            stream_handler.setLevel(logging.INFO)
            app.logger.addHandler(stream_handler)
        else:
            if not os.path.exists('logs'):
                os.mkdir('logs')
            file_handler = RotatingFileHandler('logs/microblog.log',
                                               maxBytes=10240, backupCount=10)
            file_handler.setFormatter(logging.Formatter(
                '%(asctime)s %(levelname)s: %(message)s '
                '[in %(pathname)s:%(lineno)d]'))
            file_handler.setLevel(logging.INFO)
            app.logger.addHandler(file_handler)

        app.logger.setLevel(logging.INFO)
        app.logger.info('Microblog startup')

    return app</code></pre> 
<p style="margin-left:0px;">一因此现在我需要在Heroku中运行应用程序时，设置环境变量<code>LOG_TO_STDOUT</code>，但在其他配置中则不需要。 Heroku CLI使得做到这一点变得简单，因为它提供了一个选项来设置运行时使用的环境变量：</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">$ heroku config:set LOG_TO_STDOUT=1
Setting LOG_TO_STDOUT and restarting flask-microblog... done, v4
LOG_TO_STDOUT: 1</code></pre> 
<h3><span style="color:#333333;">编译翻译</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">Microblog依赖本地文件的第三个方面是编译后的语言翻译文件。要确保这些文件永远不会从临时文件系统中消失，更直接的选择是将已编译的语言文件添加到git存储库中，以便一旦将其部署到Heroku中，它们便成为应用程序初始状态的一部分。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">在我看来，</span>更优雅的选择是在Heroku的启动命令中包含<code>flask translate compile</code>命令，以便在服务器重新启动时再次编译这些文件。 我打算选择这个方案，因为我知道启动过程需要多个命令，至少我还需要运行数据库迁移。<span style="color:#333333;">所以现在，我将这个问题搁置一旁，稍后在写<em>Procfile</em>时将再次进行讨论。</span></p> 
<h3><span style="color:#333333;">Elasticsearch托管</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">Elasticsearch是可以添加到Heroku项目中的众多服务之一，但是与Postgres不同的是，它不是Heroku提供的服务，而是与Heroku合作提供附加组件的第三方提供的服务。在撰写本文时，集成Elasticsearch服务的三个不同提供程序。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">在配置Elasticsearch之前，请注意，Heroku要求您的帐户在安装任何第三方附加组件之前都必须具有信用卡信息，即使您处于其免费套餐中。如果您不想将信用卡提供给Heroku，请跳过此部分。您仍然可以部署该应用程序，但是搜索功能将无法使用。</span></p> 
<p style="margin-left:0px;">在可作为附加组件提供的Elasticsearch选项中，我决定尝试<a href="https://elements.heroku.com/addons/searchbox" rel="nofollow">SearchBox</a>，它附带一个免费的初试计划。 要将SearchBox添加到你的帐户，你必须在登录到Heroku后运行以下命令：</p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">$ heroku addons:create searchbox:starter</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">此命令将部署Elasticsearch服务，</span>并将该服务的连接URL保存在与你的应用程序关联的<code>SEARCHBOX_URL</code>环境变量中。 <span style="color:#333333;">请记住，除非您将信用卡添加到Heroku帐户，否则此命令将失败。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">如果您从<a href="https://blog.csdn.net/gh254172840/article/details/81410355">第16章</a>回顾过，我的应用会在Elasticsearch连接URL中查找的是<code>ELASTICSEARCH_URL</code>变量，因此我需要添加这个变量并将其设置为SearchBox分配的连接URL：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">$ heroku config:get SEARCHBOX_URL
&lt;your-elasticsearch-url&gt;
$ heroku config:set ELASTICSEARCH_URL=&lt;your-elasticsearch-url&gt;</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">在这里，我首先要求Heroku打印<code>SEARCHBOX_URL</code>的值，</span>然后将其添加到一个名为<code>ELASTICSEARCH_URL</code>的新环境变量中。</p> 
<h3>更新依赖</h3> 
<p style="margin-left:0px;"><span style="color:#333333;">Heroku希望这些依赖项将在<em>requirements.txt</em>文件中，就像我在<a href="https://blog.csdn.net/gh254172840/article/details/81410350">第15章中</a>定义的那样。但是要使该应用程在Heroku上运行，我需要向该文件添加两个新的依赖项。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">Heroku不提供自己的Web服务器。相反，它希望应用程序在环境变量<code>$PORT</code>中给定的端口号上启动自己的Web服务器。由于Flask开发Web服务器不够强大，无法用于生产，因此我将再次使用<a href="http://gunicorn.org/" rel="nofollow">gunicorn</a>，这是Heroku推荐用于Python应用程序的服务器。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">该应用程序还将连接到Postgres数据库，为此SQLAlchemy需要<code>psycopg2</code>安装该软件包。</span></p> 
<p style="margin-left:0px;"><code>gunicorn</code> 和<code>psycopg2</code> 都需要添加到<em>requirements.txt</em>文件中。</p> 
<h3><span style="color:#333333;">Procfile</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">Heroku需要知道如何执行应用程序，为此，它在应用程序的根目录中使用了一个名为<em>Procfile</em>的文件。该文件的格式很简单，每一行都包含一个进程名称，一个冒号，然后是启动该进程的命令。在Heroku上运行的最常见的应用程序类型是Web应用程序，对于这种类型的应用程序，进程名称应为<code>web</code>。在下面，您可以看到<em>Microblog的Procfile</em>：</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><em>Procfile</em>：Heroku Procfile。</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">web: flask db upgrade; flask translate compile; gunicorn microblog:app</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">在这里，</span>我定义的启动命令中将按顺序执行三个命令作以启动Web应用程序<span style="color:#333333;">。首先，我运行数据库迁移升级，然后编译语言翻译，最后启动服务器。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;">因为前两个子命令基于<code>flask</code>命令，所以我需要添加<code>FLASK_APP</code>环境变量：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">$ heroku config:set FLASK_APP=microblog.py
Setting FLASK_APP and restarting flask-microblog... done, v4
FLASK_APP: microblog.py</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">该应用程序还依赖于其他环境变量，例如那些配置电子邮件服务器或实时翻译令牌的变量。那些需要与附加命令<code>heroku config:set</code>一起添加。</span></p> 
<p style="margin-left:0px;"><span style="color:#333333;"><code>gunicorn</code>命令比我用于Ubuntu部署的命令更简单，因为这个服务与Heroku环境具有很好的集成。</span>例如，<code>$PORT</code>环境变量默认会被设置，取代使用<code>-w</code>选项来设置worker的数量，heroku推荐添加一个名为<code>WEB_CONCURRENCY</code>的环境变量，在<code>-w</code>参数没有提供的时候，就会使用这个环境变量，因此你可以灵活地控制worker的数量而无需修改Procfile。</p> 
<h3><span style="color:#333333;">部署应用</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">所有准备步骤均已完成，因此现在该执行部署了。要将应用程序上传到Heroku的服务器以进行部署，请使用<code>git push</code>命令。</span> 这与你将本地git代码库中的更改推送到GitHub或其他远程git服务器的方式类似。</p> 
<p style="margin-left:0px;"><span style="color:#333333;">现在我到达了最有趣的部分，将应用程序推送到我们的Heroku托管帐户。这实际上非常简单，我只需要使用<code>git</code>将应用程序推送到Heroku git代码库的master分支即可。根据您创建git代码库的方式，如何执行此操作有多种变体。如果使用的是我的<code>v0.18</code>代码，则需要基于此标记创建一个分支，并将其作为远程主分支推送，如下所示：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">$ git checkout -b deploy
$ git push heroku deploy:master</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">相反，如果您正在使用自己的代码库，则您的代码已经在一个<code>master</code>分支中，因此您首先需要确保所做的更改已提交：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">$ git commit -a -m "heroku deployment changes"</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">然后，您可以运行以下命令启动部署：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">$ git push heroku master</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">无论如何推动分支，都应该从Heroku中看到以下输出：</span></p> 
<pre class="has" style="margin-left:0px;"><code class="language-prettyprint language-bash">$ git push heroku deploy:master
Counting objects: 247, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (238/238), done.
Writing objects: 100% (247/247), 53.26 KiB | 3.80 MiB/s, done.
Total 247 (delta 136), reused 3 (delta 0)
remote: Compressing source files... done.
remote: Building source:
remote:
remote: -----&gt; Python app detected
remote: -----&gt; Installing python-3.6.2
remote: -----&gt; Installing pip
remote: -----&gt; Installing requirements with pip
...
remote:
remote: -----&gt; Discovering process types
remote:        Procfile declares types -&gt; web
remote:
remote: -----&gt; Compressing...
remote:        Done: 57M
remote: -----&gt; Launching...
remote:        Released v5
remote:        https://flask-microblog.herokuapp.com/ deployed to Heroku
remote:
remote: Verifying deploy... done.
To https://git.heroku.com/flask-microblog.git
 * [new branch]      deploy -&gt; master</code></pre> 
<p style="margin-left:0px;"><span style="color:#333333;">我们在<code>git push</code>命令中使用的<code>heroku</code>标签<code>，</code>是创建应用程序时由Heroku CLI自动添加的远程服务器。<code>deploy:master</code>参数，意味着我正在将代码从本地存储库的<code>deploy</code>分支推送到Heroku代码库上的<code>master</code>分支。当您处理自己的项目时，</span>你可能会用<code>git push heroku master</code>命令推动你的本地<code>master</code>分支<span style="color:#333333;">。由于该项目的</span>代码库分支结构<span style="color:#333333;">，我要推送一个非master的分支，</span>但Heroku侧要求的目标分支是'master'，因为这是Heroku唯一接受部署的分支。</p> 
<p>就这样，应用程序现在应该已经部署在创建应用程序的命令的输出中给出的URL上了。 在我的案例中，URL是 <em><a href="https://flask-microblog.herokuapp.com/" rel="nofollow">https://flask-microblog.herokuapp.com</a></em> ，所以这就是我需要键入和访问该应用程序的URL。</p> 
<p>如果您想查看正在运行的应用程序的日志，请使用<code>heroku logs</code>命令。 如果由于任何原因导致应用程序无法启动，该命令可能很有用。 如果有任何错误，将在日志中显示。</p> 
<h3><span style="color:#333333;">部署应用程序更新</span></h3> 
<p style="margin-left:0px;"><span style="color:#333333;">要部署新版本的应用程序，您只需<code>git push</code>使用新代码运行新命令。</span>这将重复部署过程，关停旧部署，然后用新代码替换它<span style="color:#333333;">。Procfile中的命令将作为新部署的一部分再次运行，因此任何新的数据库迁移或翻译都将在此过程中进行更新。</span></p> 
<hr> 
<p>原文链接：<a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xviii-deployment-on-heroku" rel="nofollow">https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xviii-deployment-on-heroku</a></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e64adfa8ee744556fa0efaea39d0365c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Flask Mega-Tutorial V2.0 第17章：在Linux上部署</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f34f2e9fbe5f7b5d111ce6dc0f72f914/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">激光雷达点云之基础扫盲</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>