<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>lucene、lucene.NET详细使用与优化详解 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="lucene、lucene.NET详细使用与优化详解" />
<meta property="og:description" content="2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 1 lucene简介ITPUB个人空间 f F M A \5M S&amp;f3d ~
1.1 什么是luceneITPUB个人空间9^ T d1h m
Lucene是一个全文搜索框架，而不是应用产品。因此它并不像www.baidu.com 或者google Desktop那么拿来就能用，它只是提供了一种工具让你能实现这些产品。ITPUB个人空间Z i \ E8o
ITPUB个人空间&amp;v y X X L:Q
1.2 lucene能做什么ITPUB个人空间 ~&amp;s1n7e ?:g%a
要回答这个问题，先要了解lucene的本质。实际上lucene的功能很单一，说到底，就是你给它若干个字符串，然后它为你提供一个全文搜索服务，告诉你你要搜索的关键词出现在哪里。知道了这个本质，你就可以发挥想象做任何符合这个条件的事情了。你可以把站内新闻都索引了，做个资料库；你可以把一个数据库 表的若干个字段索引起来，那就不用再担心因为“%like%”而锁表了；你也可以写个自己的搜索引擎……
[ [ P.A2y#J&#39;|*n0
3b ^ f6J%J:G l/g01.3 你该不该选择lucene
-V ^ \ { N0下面给出一些测试数据，如果你觉得可以接受，那么可以选择。ITPUB个人空间,P rZ1o o o9M @9|1o:G
测试一：250万记录，300M左右文本，生成索引380M左右，800线程下平均处理时间300ms。
.? A Z w T e W0测试二：37000记录，索引数据库中的两个varchar字段，索引文件2.6M，800线程下平均处理时间1.5ms。
#w,N&#43;H0d&#39;H} J A g.B&amp;M0
&#43;Q%T x)E Q1A ] t02 lucene的工作方式ITPUB个人空间 D o [3B w&amp;C5J C%p c" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/fafc647cc22066802ddeae5dd8ca9485/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-05-12T10:12:00+08:00" />
<meta property="article:modified_time" content="2012-05-12T10:12:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">lucene、lucene.NET详细使用与优化详解</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="content" id="articleContent"> 
 <div class="ad-wrap"> 
  <p><a style="color:#A00;font-weight:bold;" href="https://my.oschina.net/u/2663968/blog/3061697" rel="nofollow">2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; </a> <img src="https://images2.imgbox.com/43/ba/NEr59Kfp_o.png" alt="hot3.png"></p> 
 </div> 
 <h2> </h2> 
 <p><span style="color:#000000;"><span style="font-size:x-small;">1 lucene简介ITPUB个人空间 f F M A \5M S&amp;f3d ~<br> 1.1 什么是luceneITPUB个人空间9^ T d1h m<br> Lucene是一个全文搜索框架，而不是应用产品。因此它并不像www.baidu.com 或者<u><strong>google</strong></u> Desktop那么拿来就能用，它只是提供了一种工具让你能实现这些产品。ITPUB个人空间Z i \ E8o<br>ITPUB个人空间&amp;v y X X L:Q<br> 1.2 lucene能做什么ITPUB个人空间 ~&amp;s1n7e ?:g%a<br> 要回答这个问题，先要了解lucene的本质。实际上lucene的功能很单一，说到底，就是你给它若干个字符串，然后它为你提供一个全文搜索服务，告诉你你要搜索的关键词出现在哪里。知道了这个本质，你就可以发挥想象做任何符合这个条件的事情了。你可以把站内新闻都索引了，做个资料库；你可以把一个<u><strong>数据库</strong></u> 表的若干个字段索引起来，那就不用再担心因为“%like%”而锁表了；你也可以写个自己的搜索引擎……<br> [ [ P.A2y#J'|*n0<br>3b ^ f6J%J:G l/g01.3 你该不该选择lucene<br>-V ^ \ { N0下面给出一些<u><strong>测试</strong></u>数据，如果你觉得可以接受，那么可以选择。ITPUB个人空间,P rZ1o o o9M @9|1o:G<br> 测试一：250万记录，300M左右文本，生成索引380M左右，800线程下平均处理时间300ms。<br>.? A Z w T e W0测试二：37000记录，索引数据库中的两个varchar字段，索引文件2.6M，800线程下平均处理时间1.5ms。<br>#w,N+H0d'H} J A g.B&amp;M0<br>+Q%T x)E Q1A ] t02 lucene的工作方式ITPUB个人空间 D o [3B w&amp;C5J C%p c<br> lucene提供的服务实际包含两部分：一入一出。所谓入是写入，即将你提供的源（本质是字符串）写入索引或者将其从索引中删除；所谓出是读出，即向用户提供全文搜索服务，让用户可以通过关键词定位源。<br> [3j"t T1[ o$t"@+Y D X O0<br>.D x Y Z0I/E Y F2C X02.1写入流程<br>B {%g ['C%?1]0源字符串首先经过analyzer处理，包括：分词，分成一个个单词；去除stopword（可选）。ITPUB个人空间 h x/p3z g'M p%R<br> 将源中需要的信息加入Document的各个Field中，并把需要索引的Field索引起来，把需要存储的Field存储起来。ITPUB个人空间"_ t5p v T-? ^+q5r&amp;@<br> 将索引写入存储器，存储器可以是内存或磁盘。<br> N1i h"d%{-F#a0<br> n O#z*{(V.v02.2读出流程ITPUB个人空间m E7G%x:S W I'b<br> 用户提供搜索关键词，经过analyzer处理。ITPUB个人空间.DN i1_ A.[ j<br> 对处理后的关键词搜索索引找出对应的Document。ITPUB个人空间$` F Q,Q ^V*R<br> 用户根据需要从找到的Document中提取需要的Field。ITPUB个人空间 s K v A ] w s i%T:k<br><br>p2X&amp;Z(? U Y ^)x03 一些需要知道的概念<br>7m J:o q v G Y o L6p ? u0lucene用到一些概念，了解它们的含义，有利于下面的讲解。ITPUB个人空间 s8u B O9N<br>ITPUB个人空间8~ e2\ `4m x h B j<br> 3.1 analyzer<br>K o C @ e!t0Analyzer 是分析器，它的作用是把一个字符串按某种规则划分成一个个词语，并去除其中的无效词语，这里说的无效词语是指英文中的 “of”、 “the”，中文中的“的”、“地”等词语，这些词语在文章中大量出现，但是本身不包含什么关键信息，去掉有利于缩小索引文件、提高效率、提高命中率。ITPUB个人空间:S E j*j)J E1QQ<br> 分词的规则千变万化，但目的只有一个：按语义划分。这点在英文中比较容易实现，因为英文本身就是以单词为单位的，已经用空格分开；而中文则必须以某种方法将连成一片的句子划分成一个个词语。具体划分方法下面再详细介绍，这里只需了解分析器的概念即可。ITPUB个人空间 v H*]0c C q V a<br>ITPUB个人空间 w4x V P B7\ i T v5d<br> 3.2 document<br>O @ Z$@ [ b0用户提供的源是一条条记录，它们可以是文本文件、字符串或者数据库表的一条记录等等。一条记录经过索引之后，就是以一个Document的形式存储在索引文件中的。用户进行搜索，也是以Document列表的形式返回。<br> O5m1l h"E3l5}2Z0<br> x G+Ka A i D6R Y03.3 field<br>+B S o5a*m"e0一个Document可以包含多个信息域，例如一篇文章可以包含“标题”、“正文”、“最后修改时间”等信息域，这些信息域就是通过Field在Document中存储的。ITPUB个人空间 b0J&amp;L#o q O;S<br> Field有两个属性可选：存储和索引。通过存储属性你可以控制是否对这个Field进行存储；通过索引属性你可以控制是否对该Field进行索引。这看起来似乎有些废话，事实上对这两个属性的正确组合很重要，下面举例说明：<br>h d'c/Q3r2?G0还是以刚才的文章为例子，我们需要对标题和正文进行全文搜索，所以我们要把索引属性设置为真，同时我们希望能直接从搜索结果中提取文章标题，所以我们把标题域的存储属性设置为真，但是由于正文域太大了，我们为了缩小索引文件大小，将正文域的存储属性设置为假，当需要时再直接读取文件；我们只是希望能从搜索解果中提取最后修改时间，不需要对它进行搜索，所以我们把最后修改时间域的存储属性设置为真，索引属性设置为假。上面的三个域涵盖了两个属性的三种组合，还有一种全为假的没有用到，事实上Field不允许你那么设置，因为既不存储又不索引的域是没有意义的。<br>(h w N%g e.j C W0ITPUB个人空间 i G%?#v a(E K<br> 3.4 term<br> z So8G9G7O T&amp;R$d0term是搜索的最小单位，它表示文档的一个词语，term由两部分组成：它表示的词语和这个词语所出现的field。<br> b"{q B/`!u0<br>1s H pe U z M R03.5 tockenITPUB个人空间.\&amp;K0Q0gd c(?L9P }<br> tocken是term的一次出现，它包含trem文本和相应的起止偏移，以及一个类型字符串。一句话中可以出现多次相同的词语，它们都用同一个term表示，但是用不同的tocken，每个tocken标记该词语出现的地方。<br>"~ e0`3`j m/R0<br> _ Y F5Ct W3Y03.6 segment<br> V I)S0K Pj)R P0添加索引时并不是每个document都马上添加到同一个索引文件，它们首先被写入到不同的小文件，然后再合并成一个大索引文件，这里每个小文件都是一个segment。<br>8A2X5@ G3_ @ ]0</span></span></p> 
 <div> 
  <span style="color:#000000;"><span style="font-size:x-small;">4 lucene的结构ITPUB个人空间 t d Z _ ^ x6H r Q<br> lucene包括core和sandbox两部分，其中core是lucene稳定的核心部分，sandbox包含了一些附加功能，例如highlighter、各种分析器。<br>| z \9e;` i7g0Lucene core有七个包：analysis，document，index，queryParser，search，store，util。<br>#J,?+g b S&amp;D x q+F04.1 analysis<br>+QO q ^ M0Analysis包含一些内建的分析器，例如按空白字符分词的WhitespaceAnalyzer，添加了stopwrod过滤的StopAnalyzer，最常用的StandardAnalyzer。<br> e | {:j#n5s K"T(|4P04.2 documentITPUB个人空间GO i)s ~ @ @<br> Document包含文档的数据结构，例如Document类定义了存储文档的数据结构，Field类定义了Document的一个域。<br> J [#n*H P4m5o T |04.3 indexITPUB个人空间4s _3s N!Q0q(t N<br> Index 包含了索引的读写类，例如对索引文件的segment进行写、合并、优化的IndexWriter类和对索引进行读取和删除操作的 IndexReader类，这里要注意的是不要被IndexReader这个名字误导，以为它是索引文件的读取类，实际上删除索引也是由它完成， IndexWriter只关心如何将索引写入一个个segment，并将它们合并优化；IndexReader则关注索引文件中各个文档的组织形式。ITPUB个人空间 U b ` b.Q:B u<br> 4.4 queryParserITPUB个人空间 w Z&amp;H2{'W [<br> QueryParser 包含了解析查询语句的类，lucene的查询语句和<u><strong>sql</strong></u>语句有点类似，有各种保留字，按照一定的语法可以组成各种查询。 Lucene有很多种Query类，它们都继承自Query，执行各种特殊的查询，QueryParser的作用就是解析查询语句，按顺序调用各种 Query类查找出结果。ITPUB个人空间 R |5S5K ? E ~ g(f<br> 4.5 search<br>"j I ] E+u8x v d0Search包含了从索引中搜索结果的各种类，例如刚才说的各种Query类，包括TermQuery、BooleanQuery等就在这个包里。<br>9i!A N.C C y7v$r1K04.6 storeITPUB个人空间 Z o'^2O5oK ^ [:m<br> Store包含了索引的存储类，例如Directory定义了索引文件的存储结构，FSDirectory为存储在文件中的索引，RAMDirectory为存储在内存中的索引，MmapDirectory为使用内存映射的索引。ITPUB个人空间;K"Nx Y Z*I v;M<br> 4.7 utilITPUB个人空间2H9d'J#A ? c j3b%iR<br> Util包含一些公共工具类，例如时间和字符串之间的转换工具。ITPUB个人空间2{ m x m5U N<br> 5 如何建索引ITPUB个人空间 H <a href="http://my.oschina.net/endfunction" rel="nofollow" class="referer">@E</a> 's v j6p<br> 5.1 最简单的能完成索引的代码片断ITPUB个人空间 eB%l'|0w e E H h [ j q<br>ITPUB个人空间 y L*] Y u l:uy<br> IndexWriter writer = new IndexWriter(“/data/index/”, new StandardAnalyzer(), true);ITPUB个人空间0[.] J b O4K;U^4v'V<br> Document doc = new Document();<br>'p z+R0s-C-A Z)X&amp;s0doc.add(new Field("title", "lucene introduction", Field.Store.YES, Field.Index.TOKENIZED));ITPUB个人空间;f ]1p4e&amp;k<br> doc.add(new Field("content", "lucene works well", Field.Store.YES, Field.Index.TOKENIZED));<br> s,t)s t g8[ _*j1o2k:H5V Z0writer.addDocument(doc);ITPUB个人空间&amp;k S*@4B7] f E [<br> writer.optimize();<br>$n t E O I0writer.close();ITPUB个人空间 M&amp;_ A[ U V!Q x<br>ITPUB个人空间 M S u [ v X)@!L y<br> 下面我们分析一下这段代码。ITPUB个人空间6v U @$C \ M.E<br> 首先我们创建了一个writer，并指定存放索引的目录为“/data/index”，使用的分析器为StandardAnalyzer，第三个参数说明如果已经有索引文件在索引目录下，我们将覆盖它们。ITPUB个人空间;B0e w t ? z%U<br> 然后我们新建一个document。ITPUB个人空间 i!@ tR t r b,G g l d<br> 我们向document添加一个field，名字是“title”，内容是“lucene introduction”，对它进行存储并索引。<br>+U J | \*v)N0再添加一个名字是“content”的field，内容是“lucene works well”，也是存储并索引。ITPUB个人空间;^ L+j5a_ V,L<br> 然后我们将这个文档添加到索引中，如果有多个文档，可以重复上面的操作，创建document并添加。ITPUB个人空间 ]#E-J _ ~ | d<br> 添加完所有document，我们对索引进行优化，优化主要是将多个segment合并到一个，有利于提高索引速度。<br>7` i }8e c F _0随后将writer关闭，这点很重要。<br>&amp;b n G x?!J g w0ITPUB个人空间5J ^5c2g0Q:S f"E<br> 对，创建索引就这么简单！ITPUB个人空间!Q x S d"K t<br> 当然你可能修改上面的代码获得更具个性化的服务。<br> U p ^9i a"F D0ITPUB个人空间;A V _!} f,S ? P\&amp;Q<br> 5.2 将索引直接写在内存<br> X B a3T(@-_0你需要首先创建一个RAMDirectory，并将其传给writer，代码如下：<br>#s M z+| q Y5?0ITPUB个人空间 ] ?3C C+w f Y+W+w K<br> Directory dir = new RAMDirectory();<br>R a;Q z Y p L%E B0IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), true);ITPUB个人空间4W x(j s ]6H4L)Z<br> Document doc = new Document();<br> b g c N X d0doc.add(new Field("title", "lucene introduction", Field.Store.YES, Field.Index.TOKENIZED));ITPUB个人空间9{2`(x ]n I ^/{<!-- --><br> doc.add(new Field("content", "lucene works well", Field.Store.YES, Field.Index.TOKENIZED));ITPUB个人空间 z~ j-x:q-Z a D<br> writer.addDocument(doc);ITPUB个人空间 l q J X o<br> writer.optimize();ITPUB个人空间3G } H v RF&amp;a%js m<br> writer.close();ITPUB个人空间6R3V h4KbX<br>ITPUB个人空间 C1g O l3a-A"n3R o<br> 5.3 索引文本文件<br> @'B u A#a { r G0如果你想把纯文本文件索引起来，而不想自己将它们读入字符串创建field，你可以用下面的代码创建field：<br>2x F e X+g!G5L0ITPUB个人空间#k3@$a h ?<br> Field field = new Field("content", new FileReader(file));<br> ]C.J S y,r Z-O4\0ITPUB个人空间'E0P0f J:e*h x<br> 这里的file就是该文本文件。该构造函数实际上是读去文件内容，并对其进行索引，但不存储。<br> }.t H6} g ]7_ R0ITPUB个人空间 { H dr y v;m D<br> 6 如何维护索引<br>+F j2y5L1F3h8r0i H0索引的维护操作都是由IndexReader类提供。ITPUB个人空间 V)F*J ~ `1N M<br>ITPUB个人空间/O T Bi d ]<br> 6.1 如何删除索引<br>*X%K r%J H#J K i8r K0lucene提供了两种从索引中删除document的方法，一种是ITPUB个人空间 V J _(e Z | g(A<br><br> c t9r x0\.A'P Z#q,JR0void deleteDocument(int docNum)<br>4Q3e q4a(T6? I R$h0ITPUB个人空间1c v w b+d A-g:B8~<br> 这种方法是根据document在索引中的编号来删除，每个document加进索引后都会有个唯一编号，所以根据编号删除是一种精确删除，但是这个编号是索引的内部结构，一般我们不会知道某个文件的编号到底是几，所以用处不大。另一种是ITPUB个人空间"S&amp;I AU ? i"l<br>ITPUB个人空间 y%p2e v5c<br> void deleteDocuments(Term term)ITPUB个人空间$T"R a,j4s m$F q<br>ITPUB个人空间8d o w0?,k+_<br> 这种方法实际上是首先根据参数term执行一个搜索操作，然后把搜索到的结果批量删除了。我们可以通过这个方法提供一个严格的查询条件，达到删除指定document的目的。<br>*\'\ P5i#l:r0r#u0下面给出一个例子：ITPUB个人空间 s"A Q%u+n f%g:a<br><br>"j \ Z q f b S0Directory dir = FSDirectory.getDirectory(PATH, false);<br> P,P L:Q,s t X0IndexReader reader = IndexReader.open(dir);ITPUB个人空间 t/` S | f V<br> Term term = new Term(field, key);ITPUB个人空间 ? n U+c,s-L1~7A<br> reader.deleteDocuments(term);ITPUB个人空间)?7m z { \;x<br> reader.close();ITPUB个人空间 g#B {5N { t8y ? i<br>ITPUB个人空间8G C8R:P v O<br> 6.2 如何更新索引ITPUB个人空间X,R,^$_8H<br> lucene并没有提供专门的索引更新方法，我们需要先将相应的document删除，然后再将新的document加入索引。例如：<br>-W3e X1d c [2k | i0<br>9O C8h L E |4K0e"w0Directory dir = FSDirectory.getDirectory(PATH, false);ITPUB个人空间"eR2S!? U2B<br> IndexReader reader = IndexReader.open(dir);ITPUB个人空间{B9q D:v<br> Term term = new Term(“title”, “lucene introduction”);<br> u x8D H2o O6i"k R9x)? y0reader.deleteDocuments(term);<br>!I _"q9A#L C)k5[0reader.close();<br>K.d q V G p e q T B7F0ITPUB个人空间-p u0I)t J1n$N.r&amp;y2G+S<br> IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(), true);ITPUB个人空间 GP(W P f z<br> Document doc = new Document();<br>H6I S E N1T;q? r0doc.add(new Field("title", "lucene introduction", Field.Store.YES, Field.Index.TOKENIZED));ITPUB个人空间 p C n F R4v b l X [<br> doc.add(new Field("content", "lucene is funny", Field.Store.YES, Field.Index.TOKENIZED));<br> u U N T e F2j n _ G0writer.addDocument(doc);<br>(D2?'C` i Y0writer.optimize();<br> x-C H(u9y Df [&amp;D0writer.close();<br>!V)R _ ?%i G8D07 如何搜索ITPUB个人空间 } }.? I o k8t7z<br> lucene 的搜索相当强大，它提供了很多辅助查询类，每个类都继承自Query类，各自完成一种特殊的查询，你可以像搭积木一样将它们任意组合使用，完成一些复杂操作；另外lucene还提供了Sort类对结果进行排序，提供了Filter类对查询条件进行限制。你或许会不自觉地拿它跟SQL语句进行比较：“lucene能执行and、or、order by、where、like ‘%xx%’操作吗？”回答是：“当然没问题！”ITPUB个人空间 E u i_+B-V*\ c:[<br>ITPUB个人空间 T8t } d-U V3s<br> 7.1 各种各样的QueryITPUB个人空间 ^ o x"[4^.h h*w<br> 下面我们看看lucene到底允许我们进行哪些查询操作：ITPUB个人空间+pT g d-| i-d<br><br> K&amp;J W.S H F6A9t9B07.1.1 TermQuery<br> @ t r {9T-Q [W&amp;^0首先介绍最基本的查询，如果你想执行一个这样的查询：“在content域中包含‘lucene’的document”，那么你可以用TermQuery：ITPUB个人空间(M7x'Z^ j-N+R |<br>ITPUB个人空间#A i ?7l3D R<br> Term t = new Term("content", " lucene";ITPUB个人空间5\ W$Cr;i.Q'C<br> Query query = new TermQuery(t);<br>i | {0T6w0ITPUB个人空间&amp;KI | Uk j<br> 7.1.2 BooleanQuery<br>3h2Y <a href="http://my.oschina.net/cescfabregas" rel="nofollow" class="referer">@C</a> ^ e#G N0如果你想这么查询：“在content域中包含<u><strong>java</strong></u>或perl的document”，那么你可以建立两个TermQuery并把它们用BooleanQuery连接起来：ITPUB个人空间 n([ N [)r s j&amp;Kn5w<br>ITPUB个人空间%i/y*y'N!S V/k5A<br> TermQuery termQuery1 = new TermQuery(new Term("content", "java");<br>7I1@ i,O o.k b0TermQuery termQuery 2 = new TermQuery(new Term("content", "perl");<br> q I%T s9L&amp;V!A B0BooleanQuery booleanQuery = new BooleanQuery();<br>0Hc dZc c0booleanQuery.add(termQuery 1, BooleanClause.Occur.SHOULD);<br>3L E5_,`C A,C L%B0booleanQuery.add(termQuery 2, BooleanClause.Occur.SHOULD);ITPUB个人空间9C d b i9^ P O7x<br>ITPUB个人空间8H L^5~*Y:I9D o<br> 7.1.3 WildcardQueryITPUB个人空间"M,l ~2] [2~,Q:x<br> 如果你想对某单词进行通配符查询，你可以用WildcardQuery，通配符包括’?’匹配一个任意字符和’*’匹配零个或多个任意字符，例如你搜索’use*’，你可能找到’useful’或者’useless’：ITPUB个人空间 }7v i$B8V A6p;]-~<br>ITPUB个人空间.@%M ^ i"M _ I<br> Query query = new WildcardQuery(new Term("content", "use*");ITPUB个人空间!}5l sc o F<br>ITPUB个人空间/S,D7p.B9C T!n&amp;R<br> 7.1.4 PhraseQueryITPUB个人空间 g w N k M L0h<br> 你可能对中日关系比较感兴趣，想查找‘中’和‘日’挨得比较近（5个字的距离内）的文章，超过这个距离的不予考虑，你可以：ITPUB个人空间 ^ Q] u \ x R$_ g3h<br><br>v4{+d U g0Q z0PhraseQuery query = new PhraseQuery();<br>7w0t I x3I [0query.setSlop(5);<br> l/N U0~8[ f cd'S0query.add(new Term("content ", “中”));<br>5Z(q;M F3W o3D{0query.add(new Term(“content”, “日”));ITPUB个人空间 U h V y8Q U4b<br>ITPUB个人空间 m9F E%R V Q C<br> 那么它可能搜到“中日合作……”、“中方和日方……”，但是搜不到“<u><strong>中国</strong></u>某高层领导说日本欠扁”。<br>I M0T5W ])x:h L9R)s Q0<br>0f U#|2L j [ n07.1.5 PrefixQueryITPUB个人空间,] v*B Q k+T2}<br> 如果你想搜以‘中’开头的词语，你可以用PrefixQuery：<br>)d+nn J ` j$f)C0ITPUB个人空间 b P7b(O _:n"X y E1u3G<br> PrefixQuery query = new PrefixQuery(new Term("content ", "中");ITPUB个人空间 Y+PKD:T"~ R<br>ITPUB个人空间%K7Q L ^ O<br> 7.1.6 FuzzyQuery<br> y t.A6i V n)e.A!P F0FuzzyQuery用来搜索相似的term，使用Levenshtein算法。假设你想搜索跟‘wuzza’相似的词语，你可以：<br>-a b6? R a!Q z G `0ITPUB个人空间 sVZ*J K<br> Query query = new FuzzyQuery(new Term("content", "wuzza");<br>1W h)a&amp;[ e8Ul S Q y1G0ITPUB个人空间7I P A B,iw t#c W<br> 你可能得到‘fuzzy’和‘wuzzy’。<br>#}6G:j(Q(N/i3j u k0ITPUB个人空间 G#@"I/X"r1B.A/i<br> 7.1.7 RangeQueryITPUB个人空间 f v1R o4l<br> 另一个常用的Query是RangeQuery，你也许想搜索时间域从20060101到20060130之间的document，你可以用RangeQuery：ITPUB个人空间 G p Z'N b R1i,}+g1G<br>ITPUB个人空间5E x%m H*Y n b<br> RangeQuery query = new RangeQuery(new Term(“time”, “20060101”), new Term(“time”, “20060130”), true);<br>dZ$hP v P j0ITPUB个人空间 k W2w,w&amp;v<br> 最后的true表示用闭合区间。ITPUB个人空间 v P ? {#o E&amp;g<br>ITPUB个人空间;@ | [ m,{ r<br> 7.2 QueryParser<br> We k6h)l:o0看了这么多Query，你可能会问：“不会让我自己组合各种Query吧，太麻烦了！”当然不会，lucene提供了一种类似于SQL语句的查询语句，我们姑且叫它lucene语句，通过它，你可以把各种查询一句话搞定，lucene会自动把它们查分成小块交给相应Query执行。下面我们对应每种 Query演示一下：ITPUB个人空间-j f ? o ` J [<br> TermQuery可以用“field:key”方式，例如“content:lucene”。<br> a _4Ep G m ` }0BooleanQuery中‘与’用‘+’，‘或’用‘ ’，例如“content:java contenterl”。ITPUB个人空间&amp;F [ I/m&amp;t J4E<br> WildcardQuery仍然用‘?’和‘*’，例如“content:use*”。ITPUB个人空间6a6E9{ Z'l p(l q<br> PhraseQuery用‘~’，例如“content:"中日"~5”。<br>x5f.\ ^'t0PrefixQuery用‘*’，例如“中*”。<br> n$M;s8E F w0FuzzyQuery用‘~’，例如“content: wuzza ~”。ITPUB个人空间2` ~ } S5[<br> RangeQuery用‘[]’或‘{}’，前者表示闭区间，后者表示开区间，例如“time:[20060101 TO 20060130]”，注意TO区分大小写。ITPUB个人空间 [8W z V c x7y ? r A N<br> 你可以任意组合query string，完成复杂操作，例如“标题或正文包括lucene，并且时间在20060101到20060130之间的文章” 可以表示为：“+ (title:lucene content:lucene) +time:[20060101 TO 20060130]”。代码如下：<br>#f9y u N T0<br> | s d B t0Directory dir = FSDirectory.getDirectory(PATH, false);ITPUB个人空间%@ r w z I K {'_<br> IndexSearcher is = new IndexSearcher(dir);<br>1^ Hu4A _0^ U0QueryParser parser = new QueryParser("content", new StandardAnalyzer());ITPUB个人空间+f"C&amp;T o"?&amp;Q;\;W/L e<br> Query query = parser.parse("+(title:lucene content:lucene) +time:[20060101 TO 20060130]";ITPUB个人空间7T V:o L w `<br> Hits hits = is.search(query);<br>.s!n V*c2i&amp;u v2a { n:we0for (int i = 0; i<span style="color:#0000ff;">&lt;</span><span style="color:#800000;">hits</span></span><span style="color:#ff0000;"><span style="color:#000000;"><span style="font-size:x-small;">.length(); i++)ITPUB个人空间 \0} i e5e<br> {<!-- -->ITPUB个人空间 U4Z*Q t;J*x d A<br> Document doc</span></span></span><span style="color:#0000ff;"><span style="color:#000000;"><span style="font-size:x-small;">= hits.doc(i);<br> s&amp;W5s KA T3S0</span></span></span><span style="color:#000000;"><span style="color:#ff0000;"><span style="color:#000000;"><span style="font-size:x-small;">System.out.println(doc.get("title");<br> D O v X)?0}ITPUB个人空间.X @!p(NH-k p6[ ]&amp;M<br> is.close();<br>2B _ E W9e0<br>(cd W u.G)M9F6T0首先我们创建一个在指定文件目录上的IndexSearcher。ITPUB个人空间 _6r1M { u G,q B<br> 然后创建一个使用StandardAnalyzer作为分析器的QueryParser，它默认搜索的域是content。<br> \ A X O;p#i!u)})W E0接着我们用QueryParser来parse查询字串，生成一个Query。<br>$r r8\ } _ i+U0然后利用这个Query去查找结果，结果以Hits的形式返回。ITPUB个人空间2O m0R f @+M N ] S Q J<br> 这个Hits对象包含一个列表，我们挨个把它的内容显示出来。<br>(J i;i*h A9V;x0ITPUB个人空间 }9J ? F'| r T d S<br> 7.3 FilterITPUB个人空间 k X+M [nv p?<br></span></span><span style="font-size:x-small;"><span style="color:#000000;">filter 的作用就是限制只查询索引的某个子集，它的作用有点像SQL语句里的 where，但又有区别，它不是正规查询的一部分，只是对数据源进行预处理，然后交给查询语句。注意它执行的是预处理，而不是对查询结果进行过滤，所以使用filter的代价是很大的，它可能会使一次查询耗时提高一百倍。<br> i1G g J9j L r y5`2]*k0最常用的filter是RangeFilter和QueryFilter。RangeFilter是设定只搜索指定范围内的索引；QueryFilter是在上次查询的结果中搜索。ITPUB个人空间.l ` Z)F _ Z!q<br> Filter的使用非常简单，你只需创建一个filter实例，然后把它传给searcher。继续上面的例子，查询“时间在20060101到20060130之间的文章”除了将限制写在query string中，你还可以写在RangeFilter中：ITPUB个人空间 e [ b o~ e d<br>ITPUB个人空间3\ i3r&amp;P*_ S<br></span><span style="color:#000000;">Directory dir</span></span></span></span><span style="color:#0000ff;"><span style="color:#000000;"><span style="font-size:x-small;">= FSDirectory.getDirectory(PATH,</span></span></span><span style="font-size:x-small;"><span style="color:#000000;"><span style="color:#ff0000;">false);<br> f%i&amp;t6E.z {.T8T0<span style="color:#000000;">IndexSearcher is</span></span></span><span style="color:#000000;"><span style="color:#0000ff;">= new</span></span></span><span style="color:#000000;"><span style="font-size:x-small;"><span style="color:#ff0000;">IndexSearcher(dir);ITPUB个人空间 F#D4@ Q5F<br> QueryParser parser</span><span style="color:#0000ff;">= new</span></span></span><span style="color:#000000;"><span style="font-size:x-small;"><span style="color:#ff0000;">QueryParser("content", new StandardAnalyzer());ITPUB个人空间-Y A/|5vU*{3O.f)H bw<br> Query query</span><span style="color:#0000ff;">= parser.parse("title:lucene</span></span></span><span style="color:#000000;"><span style="font-size:x-small;"><span style="color:#ff0000;">content:lucene";<br> },g:g O W.V B z"A j0RangeFilter filter</span><span style="color:#0000ff;">= new</span></span></span><span style="color:#000000;"><span style="font-size:x-small;"><span style="color:#ff0000;">RangeFilter("time", "20060101", "20060230", true, true);ITPUB个人空间8c ]3] @-P [;q<br> Hits hits</span><span style="color:#0000ff;">= is.search(query,</span></span></span><span style="color:#ff0000;"><span style="color:#000000;"><span style="font-size:x-small;">filter);</span></span><span style="color:#000000;">ITPUB个人空间 @ `Y G | _<br><span style="font-size:x-small;">for (int i</span></span><span style="color:#ff0000;"><span style="color:#000000;"><span style="font-size:x-small;"><span style="color:#000000;">i &lt; hits.length(); i++)</span><br> N c K!h/Q v/@ m&amp;K0{<!-- --><br> G { w c } j"X z0Document doc</span></span></span><span style="color:#000000;"><span style="color:#0000ff;"><span style="font-size:x-small;">= hits.doc(i);<br> |7h*H6N k4i5D z g0</span></span></span><span style="color:#ff0000;"><span style="color:#000000;"><span style="font-size:x-small;">System.out.println(doc.get("title");ITPUB个人空间 T5Q X._;m r%b'q Q p R<br> }ITPUB个人空间 x-P h f k!t l"t&amp;r Y#T<br> is.close();ITPUB个人空间3g,U1N { }<br><br>#h ]'tO U3@ H8z0</span></span><span style="color:#000000;"><span style="font-size:x-small;">7.4 Sort<br>+Z"C,N4M!E7h p0有时你想要一个排好序的结果集，就像SQL语句的“order by”，lucene能做到：通过Sort。ITPUB个人空间:Y4k Y b N;p W1R<br> Sort sort</span></span><span style="color:#000000;"><span style="font-size:x-small;"><span style="color:#ff0000;">Sort(“time”); //相当于SQL的“order by time”ITPUB个人空间 zB Q r/e#g1| `<br> Sort sort</span><span style="color:#0000ff;">= new</span></span></span><span style="color:#000000;"><span style="font-size:x-small;"><span style="color:#ff0000;">Sort(“time”, true); // 相当于SQL的“order by time desc”ITPUB个人空间"^4x U.F f E<br> 下面是一个完整的例子：ITPUB个人空间 x p r7U(a8{ \ l H S<br>ITPUB个人空间 F*Z0`'K _ X4b:W<br> Directory dir</span><span style="color:#0000ff;">= FSDirectory.getDirectory(PATH,</span></span></span><span style="color:#000000;"><span style="font-size:x-small;"><span style="color:#ff0000;">false);ITPUB个人空间2AD8q _!o l h<br> IndexSearcher is</span><span style="color:#0000ff;">= new</span></span></span><span style="color:#000000;"><span style="font-size:x-small;"><span style="color:#ff0000;">IndexSearcher(dir);ITPUB个人空间%O1E J4N(H m<br> QueryParser parser</span><span style="color:#0000ff;">= new</span></span></span><span style="color:#000000;"><span style="font-size:x-small;"><span style="color:#ff0000;">QueryParser("content", new StandardAnalyzer());<br>$F R { M(_8K;F7?&amp;X0Query query</span><span style="color:#0000ff;">= parser.parse("title:lucene</span></span></span><span style="color:#000000;"><span style="font-size:x-small;"><span style="color:#ff0000;">content:lucene";ITPUB个人空间 s:Q)_ F3` T<br> RangeFilter filter</span><span style="color:#0000ff;">= new</span></span></span><span style="color:#000000;"><span style="font-size:x-small;"><span style="color:#ff0000;">RangeFilter("time", "20060101", "20060230", true, true);ITPUB个人空间5h o Z N a/E<br> Sort sort</span><span style="color:#0000ff;">= new</span></span></span><span style="color:#000000;"><span style="font-size:x-small;"><span style="color:#ff0000;">Sort(“time”);<br> \9@ ] ^+c)P/p0Hits hits</span><span style="color:#0000ff;">= is.search(query,</span></span></span><span style="color:#ff0000;"><span style="color:#000000;"><span style="font-size:x-small;">filter, sort);ITPUB个人空间w Bu:uh v K<br> for (int i</span></span></span><span style="color:#0000ff;"><span style="font-size:x-small;"><span style="color:#000000;">= 0;</span></span><span style="color:#ff0000;"><span style="color:#000000;"><span style="font-size:x-small;">i &lt; hits.length(); i++)<br> w b a;P8I;O0{<!-- -->ITPUB个人空间 B9U s y X'V5X:a5z E<br> Document doc</span></span></span><span style="color:#0000ff;"><span style="color:#000000;"><span style="font-size:x-small;">= hits.doc(i);ITPUB个人空间 I%J*{$AU o:V t<br></span></span></span><span style="color:#ff0000;"><span style="color:#000000;"><span style="font-size:x-small;">System.out.println(doc.get("title");<br> } a4C o(~'h0}<br>/r t"j A @7S6Q N'F!K A0is.close();ITPUB个人空间 ] U7[ `/w<br><br> T2z7a f i)sV$R T2v;j08 分析器<br> _4v,n \N&amp;H _ L Gu)R0在前面的概念介绍中我们已经知道了分析器的作用，就是把句子按照语义切分成一个个词语。英文切分已经有了很成熟的分析器： StandardAnalyzer，很多情况下StandardAnalyzer是个不错的选择。甚至你会发现StandardAnalyzer也能对中文进行分词。ITPUB个人空间%j X C#j7g y,{<!-- --><br> 但是我们的焦点是中文分词，StandardAnalyzer能支持中文分词吗？实践证明是可以的，但是效果并不好，搜索“如果”会把“牛奶不如果汁好喝 ”也搜索出来，而且索引文件很大。那么我们手头上还有什么分析器可以使用呢？core里面没有，我们可以在sandbox里面找到两个： ChineseAnalyzer和CJKAnalyzer。但是它们同样都有分词不准的问题。相比之下用StandardAnalyzer 和 ChineseAnalyzer建立索引时间差不多，索引文件大小也差不多，CJKAnalyzer表现会差些，索引文件大且耗时比较长。<br>&amp;X |9| Uy+c'|0要解决问题，首先分析一下这三个分析器的分词方式。StandardAnalyzer和ChineseAnalyzer都是把句子按单个字切分，也就是说 “牛奶不如果汁好喝”会被它们切分成“牛 奶 不 如 果 汁 好 喝”；而CJKAnalyzer则会切分成“牛奶 奶不 不如 如果 果汁汁好好喝”。这也就解释了为什么搜索“果汁”都能匹配这个句子。ITPUB个人空间 s(_K m j(E<br> 以上分词的缺点至少有两个：匹配不准确和索引文件大。我们的目标是将上面的句子分解成“牛奶 不如 果汁好喝”。这里的关键就是语义识别，我们如何识别“ 牛奶”是一个词而“奶不”不是词语？我们很自然会想到基于词库的分词法，也就是我们先得到一个词库，里面列举了大部分词语，我们把句子按某种方式切分，当得到的词语与词库中的项匹配时，我们就认为这种切分是正确的。这样切词的过程就转变成匹配的过程，<span style="color:#ff0000;"><span style="color:#000000;">而</span><span style="color:#800000;">匹配的方式</span>最简单的有正向最大匹配和逆向最大匹配两种，说白了就是一个从句子开头向后进行匹配，一个从句子末尾向前进行匹配</span>。基于词库的分词词库非常重要，词库的容量直接影响搜索结果，在相同词库的前提下，据说逆向最大匹配优于正向最大匹配。ITPUB个人空间 X ^ V7b6Z#}<br> 当然还有别的分词方法，这本身就是一个学科，我这里也没有深入研究。回到具体应用，我们的目标是能找到成熟的、现成的分词工具，避免重新发明车轮。经过网上搜索，用的比较多的是中科院的ICTCLAS和一个不开放<u><strong>源码</strong></u>但是免费的JE-Analysis。ICTCLAS有个问题是它是一个动态链接库， java调用需要本地方法调用，不方便也有安全隐患，而且口碑也确实不大好。JE-Analysis效果还不错，当然也会有分词不准的地方，相比比较方便放心。</span></span></span></span></span><span style="color:#0000ff;"><span style="font-size:x-small;">= new</span></span></span><span style="color:#0000ff;"><span style="font-size:x-small;">= 0;</span></span></span> 
 </div> 
 <div> 
  <span style="color:#000000;"><span style="color:#ff0000;"><span style="font-size:x-small;"><span style="color:#000000;">9 性能优化<br> l/e d+s R+Y0一直到这里，我们还是在讨论怎么样使lucene跑起来，完成指定任务。利用前面说的也确实能完成大部分功能。但是测试表明lucene的性能并不是很好，在大数据量大并发的条件下甚至会有半分钟返回的情况。另外大数据量的数据初始化建立索引也是一个十分耗时的过程。那么如何提高lucene的性能呢？下面从优化创建索引性能和优化搜索性能两方面介绍。ITPUB个人空间 p'e i'w r D;l<br><br>0V-k T)I-? M09.1 优化创建索引性能ITPUB个人空间 ] ` w4xG%hR'y } T&amp;t<br> 这方面的优化途径比较有限，IndexWriter提供了一些接口可以控制建立索引的操作，另外我们可以先将索引写入RAMDirectory，再批量写入FSDirectory，不管怎样，目的都是尽量少的文件IO，因为创建索引的最大瓶颈在于磁盘IO。另外选择一个较好的分析器也能提高一些性能。ITPUB个人空间8d s `1v F&amp;r<br><br> U K J'Q N0v"v09.1.1 通过设置IndexWriter的参数优化索引建立<br>@ q2Q/p;M3{0setMaxBufferedDocs(int maxBufferedDocs)<br>+N @8D/A4[ J:W+c!d0控制写入一个新的segment前内存中保存的document的数目，设置较大的数目可以加快建索引速度，默认为10。ITPUB个人空间 X N;K j n o C2B b R<br> setMaxMergeDocs(int maxMergeDocs)ITPUB个人空间+R&amp;` q J H;E v p,~ v<br> 控制一个segment中可以保存的最大document数目，值较小有利于追加索引的速度，默认Integer.MAX_VALUE，无需修改。<br>#W T n3@+O9H ~ ^4K,s0setMergeFactor(int mergeFactor)ITPUB个人空间 F ^ Z2~T a ^(b;C<br> 控制多个segment合并的频率，值较大时建立索引速度较快，默认是10，可以在建立索引时设置为100。ITPUB个人空间-P7L5C Z)`;]1O*K yV bg<br>ITPUB个人空间 a7F.Z r J s8P)g8R<br> 9.1.2 通过RAMDirectory缓写提高性能<br>7v%Y }4m"_3t ]0我们可以先把索引写入RAMDirectory，达到一定数量时再批量写进FSDirectory，减少磁盘IO次数。ITPUB个人空间 l ~ E o.s<br><br>5a ~ f p p H_.E-s!Y0FSDirectory fsDir</span><span style="color:#0000ff;">= FSDirectory.getDirectory("/data/index",</span></span><span style="font-size:x-small;"><span style="color:#ff0000;">true);<br>:[-C9d5]%`6\0RAMDirectory ramDir</span><span style="color:#0000ff;">= new</span></span><span style="font-size:x-small;"><span style="color:#ff0000;">RAMDirectory();<br>1I D h B \$P0IndexWriter fsWriter</span><span style="color:#0000ff;">= new</span></span><span style="font-size:x-small;"><span style="color:#ff0000;">IndexWriter(fsDir, new StandardAnalyzer(), true);<br> q!O.R s n z T Y7]0IndexWriter ramWriter</span><span style="color:#0000ff;">= new</span></span><span style="color:#ff0000;"><span style="font-size:x-small;">IndexWriter(ramDir, new StandardAnalyzer(), true);<br>%S+V/K V!| q y D(c K2a0while (there are documents to index)ITPUB个人空间 | q ^ ^ Y A/V [ e<br> {<!-- -->ITPUB个人空间 b/I _ l&amp;L3q#d:X l<br></span><span style="color:#000000;"><span style="font-size:x-small;">... create Document ...ITPUB个人空间 L7E9Y x5].a<br> ramWriter.addDocument(doc);ITPUB个人空间 l3W6I3E Z1c(A<br> if (condition for flushing memory to disk has been met)ITPUB个人空间 W O o } ?'` h { I<br> {<!-- --><br>{(t p%V,J6|$a$U m0fsWriter.addIndexes(new Directory[] { ramDir });<br>a9? b7\ r#i0ramWriter.close();<br>2B#? o:W aU u1`0ramWriter</span></span></span><span style="color:#0000ff;"><span style="color:#000000;"><span style="font-size:x-small;">= new</span></span></span><span style="color:#000000;"><span style="color:#ff0000;"><span style="font-size:x-small;">IndexWriter(ramDir, new StandardAnalyzer(), true);ITPUB个人空间*M ~ |&amp;G%J8{<!-- --><br> }ITPUB个人空间 I K { U+L D N$z<br> }ITPUB个人空间 M8K7`P P ^ f$K ] [<br><br>8D8d9{ p a O ^0</span><span style="color:#000000;"><span style="font-size:x-small;">9.1.3 选择较好的分析器ITPUB个人空间4k F1j%u G7~ r<br> 这个优化主要是对磁盘空间的优化，可以将索引文件减小将近一半，相同测试数据下由600M减少到380M。但是对时间并没有什么帮助，甚至会需要更长时间，因为较好的分析器需要匹配词库，会消耗更多cpu，测试数据用StandardAnalyzer耗时133分钟；用MMAnalyzer耗时150分钟。<br>L0C$H o2r0U X:d P P0<br> p S$c ? eP [ N.\09.2 优化搜索性能<br>0g1`*X d _ _ C X"L0虽然建立索引的操作非常耗时，但是那毕竟只在最初创建时才需要，平时只是少量的维护操作，更何况这些可以放到一个后台进程处理，并不影响用户搜索。我们创建索引的目的就是给用户搜索，所以搜索的性能才是我们最关心的。下面就来探讨一下如何提高搜索性能。ITPUB个人空间)u4l U C4^<br>ITPUB个人空间5]"v Q H%| C D<br> 9.2.1 将索引放入内存ITPUB个人空间%o-T N Q X4}6z:~E<br> 这是一个最直观的想法，因为内存比磁盘快很多。Lucene提供了RAMDirectory可以在内存中容纳索引：<br>f V K+T9m2Wa p0ITPUB个人空间$V5_N | o A F<br> Directory fsDir</span></span></span></span><span style="color:#000000;"><span style="color:#0000ff;"><span style="font-size:x-small;">= FSDirectory.getDirectory(“/data/index/”,</span></span></span><span style="color:#000000;"><span style="font-size:x-small;"><span style="color:#ff0000;">false);ITPUB个人空间 l4B!v R H+<a href="http://my.oschina.net/endfunction" rel="nofollow" class="referer">@E</a> <br> Directory ramDir</span><span style="color:#0000ff;">= new</span></span></span><span style="color:#000000;"><span style="font-size:x-small;"><span style="color:#ff0000;">RAMDirectory(fsDir);ITPUB个人空间 o nD M*p3L i<br> Searcher searcher</span><span style="color:#0000ff;">= new</span></span></span><span style="color:#ff0000;"><span style="font-size:x-small;"><span style="color:#000000;"><span style="color:#000000;">IndexSearcher(ramDir);</span>ITPUB个人空间5u o'j$c(W,t&amp;K&amp;v<br>ITPUB个人空间 j#p a2s1]7Z9G&amp;^<br> 但是实践证明RAMDirectory和FSDirectory速度差不多，当数据量很小时两者都非常快，当数据量较大时（索引文件400M）RAMDirectory甚至比FSDirectory还要慢一点，这确实让人出乎意料。ITPUB个人空间 T U#m _ |Z#A _;s m<br> 而且lucene的搜索非常耗内存，即使将400M的索引文件载入内存，在运行一段时间后都会out of memory，所以个人认为载入内存的作用并不大。</span>ITPUB个人空间 F M r U S K<br><br>,v ? a L f ^z,jF/d0</span><span style="font-size:x-small;"><span style="color:#000000;">9.2.2 优化时间范围限制<br> y2M fa {,Z z d2^0既然载入内存并不能提高效率，一定有其它瓶颈，经过测试发现最大的瓶颈居然是时间范围限制，那么我们可以怎样使时间范围限制的代价最小呢？<br>.Q b C ^9EU b0当需要搜索指定时间范围内的结果时，可以：ITPUB个人空间!C3| x V G8x Y<br> 1、用RangeQuery，设置范围，但是RangeQuery的实现实际上是将时间范围内的时间点展开，组成一个个BooleanClause加入到 BooleanQuery中查询，因此时间范围不可能设置太大，经测试，范围超过一个月就会抛 BooleanQuery.TooManyClauses，可以通过设置 BooleanQuery.setMaxClauseCount(int maxClauseCount)扩大，但是扩大也是有限的，并且随着 maxClauseCount扩大，占用内存也扩大<br>2l*l&amp;J$| ^ ]02、用 RangeFilter代替RangeQuery，经测试速度不会比RangeQuery慢，但是仍然有性能瓶颈，查询的90%以上时间耗费在 RangeFilter，研究其源码发现RangeFilter实际上是首先遍历所有索引，生成一个BitSet，标记每个document，在时间范围内的标记为true，不在的标记为false，然后将结果传递给Searcher查找，这是十分耗时的。<br>8P n P H6\ | ~ Z p03、进一步提高性能，这个又有两个思路：<br>-b+K v R:^ G3HY0a、缓存Filter结果。既然RangeFilter的执行是在搜索之前，那么它的输入都是一定的，就是IndexReader，而 IndexReader是由Directory决定的，所以可以认为RangeFilter的结果是由范围的上下限决定的，也就是由具体的 RangeFilter对象决定，所以我们只要以RangeFilter对象为键，将filter结果BitSet缓存起来即可。 lucene API已经提供了一个CachingWrapperFilter类封装了Filter及其结果，所以具体实施起来我们可以 cache CachingWrapperFilter对象，需要注意的是，不要被CachingWrapperFilter的名字及其说明误导， CachingWrapperFilter看起来是有缓存功能，但的缓存是针对同一个filter的，也就是在你用同一个filter过滤不同 IndexReader时，它可以帮你缓存不同IndexReader的结果，而我们的需求恰恰相反，我们是用不同filter过滤同一个 IndexReader，所以只能把它作为一个封装类。<br> Q _ [ a&amp;` O o0b、降低时间精度。研究Filter的工作原理可以看出，它每次工作都是遍历整个索引的，所以时间粒度越大，对比越快，搜索时间越短，在不影响功能的情况下，时间精度越低越好，有时甚至牺牲一点精度也值得，当然最好的情况是根本不作时间限制。<br>j O z \ s Z.j DX0下面针对上面的两个思路演示一下优化结果（都采用800线程随机关键词随即时间范围）：ITPUB个人空间!} E _(X a y4d7D<br> 第一组，时间精度为秒：<br> i {)@&amp;z0R [ N0方式 直接用RangeFilter 使用cache 不用filterITPUB个人空间 @ e9OY8l H S$W V Y |<br> 平均每个线程耗时 10s 1s 300ms<br> z(W w6F q0ITPUB个人空间 y A9~5] n;V:e<br> 第二组，时间精度为天<br>7Y0{ Wf O X Y X P0方式 直接用RangeFilter 使用cache 不用filterITPUB个人空间 p6~*| {!_)U<br> 平均每个线程耗时 900ms 360ms 300msITPUB个人空间 u3N/u6Q S;P WB<br><br>(X1o.{ a1Bg1? a"G+~0由以上数据可以得出结论：<br> [5^?0voL2Q01、 尽量降低时间精度，将精度由秒换成天带来的性能提高甚至比使用cache还好，最好不使用filter。<br>3e k Pr)D02、 在不能降低时间精度的情况下，使用cache能带了10倍左右的性能提高。<br>+{ x [*D6n/t0<br> e k.K G Q)p R"\09.2.3 使用更好的分析器ITPUB个人空间 | s5P z ^/v$\;} x&amp;P<br> 这个跟创建索引优化道理差不多，索引文件小了搜索自然会加快。当然这个提高也是有限的。较好的分析器相对于最差的分析器对性能的提升在20%以下。<br>)l n5T O {#T r)c m0</span>ITPUB个人空间3S#[4Q d-_ b/b [<br></span><span style="color:#000000;"><span style="font-size:x-small;">10 一些经验<br> `"a e g |/w3I ]*u P1s0<br>c5q x d Z010.1关键词区分大小写ITPUB个人空间)[ u V4M K [<br> or AND TO等关键词是区分大小写的，lucene只认大写的，小写的当做普通单词。ITPUB个人空间 N J[8X%`"\ V Q H<br><br> V"t#r&amp;^0i010.2 读写互斥性<br>,Hu Q A ? v:a0同一时刻只能有一个对索引的写操作，在写的同时可以进行搜索<br>{,P Bh J0<br> \ r)@ k9U F T&amp;Z010.3 文件锁ITPUB个人空间7Z O t m K _4O,@O-u i+|<br> 在写索引的过程中强行退出将在tmp目录留下一个lock文件，使以后的写操作无法进行，可以将其手工删除<br>a+ng/M y M;G0ITPUB个人空间 K r G R/M1V T b u z<br> 10.4 时间格式<br>:h VT6w.y j { V$F w-X0lucene只支持一种时间格式yyMMddHHmmss，所以你传一个yy-MM-dd HH:mm:ss的时间给lucene它是不会当作时间来处理的<br>.r5E y q }#b I#_0<br> w J e h/L ] p t010.5 设置boostITPUB个人空间(p j e D W D5b W<br> 有些时候在搜索时某个字段的权重需要大一些，例如你可能认为标题中出现关键词的文章比正文中出现关键词的文章更有价值，你可以把标题的boost设置的更大，那么搜索结果会优先显示标题中出现关键词的文章（没有使用排序的前题下）。使用方法：<br> z2W6V S M z E)? L A(o0Field. setBoost(float boost);默认值是1.0，也就是说要增加权重的需要设置得比1大。</span></span></span></span></span> 
 </div> 
 <div class="ad-wrap"> 
  <div id="blog-title-ad"> 
   <ins class="adsbygoogle"></ins> 
  </div> 
 </div> 
</div> 
<p>转载于:https://my.oschina.net/limbusnet/blog/57135</p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/92debfd9e05642be401c52456acf7a78/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">lsnrctl start 出现错误Failed to start service, error 0.</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a787f6ad607d4eec21e7da5baf4adf65/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">查看ASM_diskgroup ,asm_disk</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>