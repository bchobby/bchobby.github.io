<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>让人头痛的大数据倾斜问题 - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="让人头痛的大数据倾斜问题" />
<meta property="og:description" content="在做Shuffle阶段的优化过程中，遇到了数据倾斜的问题，造成了对一些情况下优化效果不明显。主要是因为在Job完成后的所得到的Counters是整个Job的总和，优化是基于这些Counters得出的平均值，而由于数据倾斜的原因造成map处理数据量的差异过大，使得这些平均值能代表的价值降低。Hive的执行是分阶段的，map处理数据量的差异取决于上一个stage的reduce输出，所以如何将数据均匀的分配到各个reduce中，就是解决数据倾斜的根本所在。规避错误来更好的运行比解决错误更高效。在查看了一些资料后，总结如下。
关键词
情形
后果
join
其中一个表较小，但是key集中
分发到某一个或几个Reduce上的数据远高于平均值
大表与大表，但是分桶的判断字段0值或空值过多
这些空值都由一个reduce处理，非常慢
Count(Distinct)
某特殊值过多
处理此特殊值的reduce耗时
Group by
group by 维度过小，某值的数量过多
处理某值的reduce非常耗时
1.2原因：
1)、key分布不均匀
2)、业务数据本身的特性
3)、建表时考虑不周
4)、某些SQL语句本身就有数据倾斜
1.3表现：
任务进度长时间维持在99%（或100%），查看任务监控页面，发现只有少量（1个或几个）reduce子任务未完成。因为其处理的数据量和其他reduce差异过大。
单一reduce的记录数与平均记录数差异过大，通常可能达到3倍甚至更多。 最长时长远大于平均时长。
2数据倾斜的解决方案
2.1参数调节：
hive.map.aggr = true
Map 端部分聚合，相当于Combiner
hive.groupby.skewindata=true
有数据倾斜的时候进行负载均衡，当选项设定为 true，生成的查询计划会有两个 MR Job。第一个 MR Job 中，Map 的输出结果集合会随机分布到 Reduce 中，每个 Reduce 做部分聚合操作，并输出结果，这样处理的结果是相同的 Group By Key 有可能被分发到不同的 Reduce 中，从而达到负载均衡的目的；第二个 MR Job 再根据预处理的数据结果按照 Group By Key 分布到 Reduce 中（这个过程可以保证相同的 Group By Key 被分布到同一个 Reduce 中），最后完成最终的聚合操作。
2.2 SQL语句调节：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bchobby.github.io/posts/ff3bf9ccb5ab1e03158dc6f8ee0f8f6c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-11-05T22:40:54+08:00" />
<meta property="article:modified_time" content="2013-11-05T22:40:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">让人头痛的大数据倾斜问题</h1>
			
		</header>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在做<span style="font-family:Times New Roman">Shuffle</span><span style="font-family:宋体">阶段的优化过程中，遇到了数据倾斜的问题，造成了对一些情况下优化效果不明显。主要是因为在</span><span style="font-family:Times New Roman">Job</span><span style="font-family:宋体">完成后的所得到的</span><span style="font-family:Times New Roman">Counters</span><span style="font-family:宋体">是整个</span><span style="font-family:Times New Roman">Job</span><span style="font-family:宋体">的总和，优化是基于这些</span><span style="font-family:Times New Roman">Counters</span><span style="font-family:宋体">得出的平均值，而由于数据倾斜的原因造成</span><span style="font-family:Times New Roman">map</span><span style="font-family:宋体">处理数据量的差异过大，使得这些平均值能代表的价值降低。</span><span style="font-family:Times New Roman">Hive</span><span style="font-family:宋体">的执行是分阶段的，</span><span style="font-family:Times New Roman">map</span><span style="font-family:宋体">处理数据量的差异取决于上一个</span><span style="font-family:Times New Roman">stage</span><span style="font-family:宋体">的</span><span style="font-family:Times New Roman">reduce</span><span style="font-family:宋体">输出，所以如何将数据均匀的分配到各个</span><span style="font-family:Times New Roman">reduce</span><span style="font-family:宋体">中，就是解决数据倾斜的根本所在。规避错误来更好的运行比解决错误更高效。在查看了一些资料后，总结如下。</span></p> 
<table><tbody><tr><td> <p>关键词</p> </td><td> <p>情形</p> </td><td> <p>后果</p> </td></tr><tr><td rowspan="2"> <p></p> <p>    join</p> </td><td> <p>其中一个表较小，但是<span style="font-family:Times New Roman">key</span><span style="font-family:宋体">集中</span></p> </td><td> <p>分发到某一个或几个<span style="font-family:Times New Roman">Reduce</span><span style="font-family:宋体">上的数据远高于平均值</span></p> </td></tr><tr><td> <p>大表与大表，但是分桶的判断字段<span style="font-family:Times New Roman">0</span><span style="font-family:宋体">值或空值过多</span></p> </td><td> <p>这些空值都由一个<span style="font-family:Times New Roman">reduce</span><span style="font-family:宋体">处理，</span>非常慢</p> </td></tr><tr><td> <p>Count(Distinct)</p> </td><td> <p>某特殊值过多</p> </td><td> <p>处理此特殊值的<span style="font-family:Times New Roman">reduce</span><span style="font-family:宋体">耗时</span></p> </td></tr><tr><td> <p>Group by</p> </td><td> <p>group by <span style="font-family:宋体">维度过小，某值的数量过多</span></p> </td><td> <p>处理某值的<span style="font-family:Times New Roman">reduce</span>非常耗时</p> </td></tr></tbody></table> 
<p></p> 
<p>1.2<span style="font-family:宋体">原因：</span></p> 
<p>1)<span style="font-family:宋体">、</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">分布不均匀</span></p> 
<p>2)<span style="font-family:宋体">、业务数据本身的特性</span></p> 
<p>3)<span style="font-family:宋体">、建表时考虑不周</span></p> 
<p>4)<span style="font-family:宋体">、某些</span><span style="font-family:Times New Roman">SQL</span><span style="font-family:宋体">语句本身就有数据倾斜</span></p> 
<p>1.3<span style="font-family:宋体">表现：</span></p> 
<p>任务进度长时间维持在<span style="font-family:Times New Roman">99%</span><span style="font-family:宋体">（或</span><span style="font-family:Times New Roman">100%</span><span style="font-family:宋体">），查看任务监控页面，发现只有少量（</span><span style="font-family:Times New Roman">1</span><span style="font-family:宋体">个或几个）</span><span style="font-family:Times New Roman">reduce</span><span style="font-family:宋体">子任务未完成。因为其处理的数据量和其他</span><span style="font-family:Times New Roman">reduce</span><span style="font-family:宋体">差异过大。</span></p> 
<p>单一<span style="font-family:Times New Roman">reduce</span><span style="font-family:宋体">的记录数与平均记录数差异过大，通常可能达到</span><span style="font-family:Times New Roman">3</span><span style="font-family:宋体">倍甚至更多。 最长时长远大于平均时长。</span></p> 
<p>2<span style="font-family:宋体">数据倾斜的解决方案</span></p> 
<p>2.1<span style="font-family:宋体">参数调节：</span></p> 
<p>hive.map.aggr = true</p> 
<p>Map <span style="font-family:宋体">端部分聚合，相当于</span><span style="font-family:Times New Roman">Combiner</span></p> 
<p>hive.groupby.skewindata=true</p> 
<p></p> 
<p>有数据倾斜的时候进行负载均衡，当选项设定为 <span style="font-family:Times New Roman">true</span><span style="font-family:宋体">，生成的查询计划会有两个 </span><span style="font-family:Times New Roman">MR Job</span><span style="font-family:宋体">。第一个 </span><span style="font-family:Times New Roman">MR Job </span><span style="font-family:宋体">中，</span><span style="font-family:Times New Roman">Map </span><span style="font-family:宋体">的输出结果集合会随机分布到 </span><span style="font-family:Times New Roman">Reduce </span><span style="font-family:宋体">中，每个 </span><span style="font-family:Times New Roman">Reduce </span><span style="font-family:宋体">做部分聚合操作，并输出结果，这样处理的结果是相同的 </span><span style="font-family:Times New Roman">Group By Key </span><span style="font-family:宋体">有可能被分发到不同的 </span><span style="font-family:Times New Roman">Reduce </span><span style="font-family:宋体">中，从而达到负载均衡的目的；第二个 </span><span style="font-family:Times New Roman">MR Job </span><span style="font-family:宋体">再根据预处理的数据结果按照 </span><span style="font-family:Times New Roman">Group By Key </span><span style="font-family:宋体">分布到 </span><span style="font-family:Times New Roman">Reduce </span><span style="font-family:宋体">中（这个过程可以保证相同的 </span><span style="font-family:Times New Roman">Group By Key </span><span style="font-family:宋体">被分布到同一个 </span><span style="font-family:Times New Roman">Reduce </span><span style="font-family:宋体">中），最后完成最终的聚合操作。</span></p> 
<p>2.2 SQL<span style="font-family:宋体">语句调节：</span></p> 
<p>如何<span style="font-family:Times New Roman">Join</span><span style="font-family:宋体">：</span></p> 
<p>    关于驱动表的选取，选用<span style="font-family:Times New Roman">join key</span><span style="font-family:宋体">分布最均匀的表作为驱动表</span></p> 
<p>做好列裁剪和<span style="font-family:Times New Roman">filter</span><span style="font-family:宋体">操作，以达到两表做</span><span style="font-family:Times New Roman">join</span><span style="font-family:宋体">的时候，数据量相对变小的效果。</span></p> 
<p>大小表<span style="font-family:Times New Roman">Join</span><span style="font-family:宋体">：</span></p> 
<p>使用<span style="font-family:Times New Roman">map join</span><span style="font-family:宋体">让小的维度表（</span><span style="font-family:Times New Roman">1000</span><span style="font-family:宋体">条以下的记录条数） 先进内存。在</span><span style="font-family:Times New Roman">map</span><span style="font-family:宋体">端完成</span><span style="font-family:Times New Roman">reduce.</span></p> 
<p>大表<span style="font-family:Times New Roman">Join</span><span style="font-family:宋体">大表：</span></p> 
<p>把空值的<span style="font-family:Times New Roman">key</span><span style="font-family:宋体">变成一个字符串加上随机数，把倾斜的数据分到不同的</span><span style="font-family:Times New Roman">reduce</span><span style="font-family:宋体">上，由于</span><span style="font-family:Times New Roman">null</span><span style="font-family:宋体">值关联不上，处理后并不影响最终结果。</span></p> 
<p>count distinct<span style="font-family:宋体">大量相同特殊值</span></p> 
<p>count distinct<span style="font-family:宋体">时，将值为空的情况单独处理，如果是计算</span><span style="font-family:Times New Roman">count distinct</span><span style="font-family:宋体">，可以不用处理，直接过滤，在最后结果中加</span><span style="font-family:Times New Roman">1</span><span style="font-family:宋体">。如果还有其他计算，需要进行</span><span style="font-family:Times New Roman">group by</span><span style="font-family:宋体">，可以先将值为空的记录单独处理，再和其他计算结果进行</span><span style="font-family:Times New Roman">union</span><span style="font-family:宋体">。</span></p> 
<p>group by<span style="font-family:宋体">维度过小：</span></p> 
<p>采用<span style="font-family:Times New Roman">sum() group by</span><span style="font-family:宋体">的方式来替换</span><span style="font-family:Times New Roman">count(distinct)</span><span style="font-family:宋体">完成计算。</span></p> 
<p>特殊情况特殊处理：</p> 
<p>在业务逻辑优化效果的不大情况下，有些时候是可以将倾斜的数据单独拿出来处理。最后<span style="font-family:Times New Roman">union</span><span style="font-family:宋体">回去。</span></p> 
<p></p> 
<p>3<span style="font-family:宋体">典型的业务场景</span></p> 
<p>3.1<span style="font-family:宋体">空值产生的数据倾斜</span></p> 
<p>场景：如日志中，常会有信息丢失的问题，比如日志中的 <span style="font-family:Times New Roman">user_id</span><span style="font-family:宋体">，如果取其中的 </span><span style="font-family:Times New Roman">user_id </span><span style="font-family:宋体">和 用户表中的</span><span style="font-family:Times New Roman">user_id </span><span style="font-family:宋体">关联，会碰到数据倾斜的问题。</span></p> 
<p>解决方法<span style="font-family:Times New Roman">1</span><span style="font-family:宋体">： </span><span style="font-family:Times New Roman">user_id</span><span style="font-family:宋体">为空的不参与关联（红色字体为修改后）</span></p> 
<p>select * from log a</p> 
<p>  join users b</p> 
<p>  on a.user_id is not null</p> 
<p>  and a.user_id = b.user_id</p> 
<p>union all</p> 
<p>select * from log a</p> 
<p>  where a.user_id is null;</p> 
<p>解决方法<span style="font-family:Times New Roman">2 </span><span style="font-family:宋体">：赋与空值分新的</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">值</span></p> 
<p>select *</p> 
<p>  from log a</p> 
<p>  left outer join users b</p> 
<p>  on case when a.user_id is null then concat(‘hive’,rand() ) else a.user_id end = b.user_id; </p> 
<p>结论：方法<span style="font-family:Times New Roman">2</span><span style="font-family:宋体">比方法</span><span style="font-family:Times New Roman">1</span><span style="font-family:宋体">效率更好，不但</span><span style="font-family:Times New Roman">io</span><span style="font-family:宋体">少了，而且作业数也少了。解决方法</span><span style="font-family:Times New Roman">1</span><span style="font-family:宋体">中 </span><span style="font-family:Times New Roman">log</span><span style="font-family:宋体">读取两次，</span><span style="font-family:Times New Roman">jobs</span><span style="font-family:宋体">是</span><span style="font-family:Times New Roman">2</span><span style="font-family:宋体">。解决方法</span><span style="font-family:Times New Roman">2 job</span><span style="font-family:宋体">数是</span><span style="font-family:Times New Roman">1 </span><span style="font-family:宋体">。这个优化适合无效 </span><span style="font-family:Times New Roman">id (</span><span style="font-family:宋体">比如 </span><span style="font-family:Times New Roman">-99 , ’’, null </span><span style="font-family:宋体">等</span><span style="font-family:Times New Roman">) </span><span style="font-family:宋体">产生的倾斜问题。把空值的 </span><span style="font-family:Times New Roman">key </span><span style="font-family:宋体">变成一个字符串加上随机数，就能把倾斜的数据分到不同的</span><span style="font-family:Times New Roman">reduce</span><span style="font-family:宋体">上 </span><span style="font-family:Times New Roman">,</span><span style="font-family:宋体">解决数据倾斜问题。</span></p> 
<p>3.2<span style="font-family:宋体">不同数据类型关联产生数据倾斜</span></p> 
<p>场景：用户表中<span style="font-family:Times New Roman">user_id</span><span style="font-family:宋体">字段为</span><span style="font-family:Times New Roman">int</span><span style="font-family:宋体">，</span><span style="font-family:Times New Roman">log</span><span style="font-family:宋体">表中</span><span style="font-family:Times New Roman">user_id</span><span style="font-family:宋体">字段既有</span><span style="font-family:Times New Roman">string</span><span style="font-family:宋体">类型也有</span><span style="font-family:Times New Roman">int</span><span style="font-family:宋体">类型。当按照</span><span style="font-family:Times New Roman">user_id</span><span style="font-family:宋体">进行两个表的</span><span style="font-family:Times New Roman">Join</span><span style="font-family:宋体">操作时，默认的</span><span style="font-family:Times New Roman">Hash</span><span style="font-family:宋体">操作会按</span><span style="font-family:Times New Roman">int</span><span style="font-family:宋体">型的</span><span style="font-family:Times New Roman">id</span><span style="font-family:宋体">来进行分配，这样会导致所有</span><span style="font-family:Times New Roman">string</span><span style="font-family:宋体">类型</span><span style="font-family:Times New Roman">id</span><span style="font-family:宋体">的记录都分配到一个</span><span style="font-family:Times New Roman">Reducer</span><span style="font-family:宋体">中。</span></p> 
<p>解决方法：把数字类型转换成字符串类型</p> 
<p>select * from users a</p> 
<p>  left outer join logs b</p> 
<p>  on a.usr_id = cast(b.user_id as string) </p> 
<p>3.3<span style="font-family:宋体">小表不小不大，怎么用 </span><span style="font-family:Times New Roman">map join </span><span style="font-family:宋体">解决倾斜问题</span></p> 
<p>使用 <span style="font-family:Times New Roman">map join </span><span style="font-family:宋体">解决小表</span><span style="font-family:Times New Roman">(</span><span style="font-family:宋体">记录数少</span><span style="font-family:Times New Roman">)</span><span style="font-family:宋体">关联大表的数据倾斜问题，这个方法使用的频率非常高，但如果小表很大，大到</span><span style="font-family:Times New Roman">map join</span><span style="font-family:宋体">会出现</span><span style="font-family:Times New Roman">bug</span><span style="font-family:宋体">或异常，这时就需要特别的处理。 以下例子</span><span style="font-family:Times New Roman">:</span></p> 
<p>select * from log a</p> 
<p>  left outer join users b</p> 
<p>  on a.user_id = b.user_id;</p> 
<p>users <span style="font-family:宋体">表有 </span><span style="font-family:Times New Roman">600w+ </span><span style="font-family:宋体">的记录，把 </span><span style="font-family:Times New Roman">users </span><span style="font-family:宋体">分发到所有的 </span><span style="font-family:Times New Roman">map </span><span style="font-family:宋体">上也是个不小的开销，而且 </span><span style="font-family:Times New Roman">map join </span><span style="font-family:宋体">不支持这么大的小表。如果用普通的 </span><span style="font-family:Times New Roman">join</span><span style="font-family:宋体">，又会碰到数据倾斜的问题。</span></p> 
<p>解决方法：</p> 
<p>select /*+mapjoin(x)*/* from log a</p> 
<p>  left outer join (</p> 
<p>    select  /*+mapjoin(c)*/d.*</p> 
<p>      from ( select distinct user_id from log ) c</p> 
<p>      join users d</p> 
<p>      on c.user_id = d.user_id</p> 
<p>    ) x</p> 
<p>  on a.user_id = b.user_id;</p> 
<p>假如，<span style="font-family:Times New Roman">log</span><span style="font-family:宋体">里</span><span style="font-family:Times New Roman">user_id</span><span style="font-family:宋体">有上百万个，这就又回到原来</span><span style="font-family:Times New Roman">map join</span><span style="font-family:宋体">问题。所幸，每日的会员</span><span style="font-family:Times New Roman">uv</span><span style="font-family:宋体">不会太多，有交易的会员不会太多，有点击的会员不会太多，有佣金的会员不会太多等等。所以这个方法能解决很多场景下的数据倾斜问题。</span></p> 
<p>4<span style="font-family:宋体">总结</span></p> 
<p>使<span style="font-family:Times New Roman">map</span><span style="font-family:宋体">的输出数据更均匀的分布到</span><span style="font-family:Times New Roman">reduce</span><span style="font-family:宋体">中去，是我们的最终目标。由于</span><span style="font-family:Times New Roman">Hash</span><span style="font-family:宋体">算法的局限性，按</span><span style="font-family:Times New Roman">key Hash</span><span style="font-family:宋体">会或多或少的造成数据倾斜。大量经验表明数据倾斜的原因是人为的建表疏忽或业务逻辑可以规避的。在此给出较为通用的步骤：</span></p> 
<p>1<span style="font-family:宋体">、采样</span><span style="font-family:Times New Roman">log</span><span style="font-family:宋体">表，哪些</span><span style="font-family:Times New Roman">user_id</span><span style="font-family:宋体">比较倾斜，得到一个结果表</span><span style="font-family:Times New Roman">tmp1</span><span style="font-family:宋体">。由于对计算框架来说，所有的数据过来，他都是不知道数据分布情况的，所以采样是并不可少的。</span></p> 
<p>2<span style="font-family:宋体">、数据的分布符合社会学统计规则，贫富不均。倾斜的</span><span style="font-family:Times New Roman">key</span><span style="font-family:宋体">不会太多，就像一个社会的富人不多，奇特的人不多一样。所以</span><span style="font-family:Times New Roman">tmp1</span><span style="font-family:宋体">记录数会很少。把</span><span style="font-family:Times New Roman">tmp1</span><span style="font-family:宋体">和</span><span style="font-family:Times New Roman">users</span><span style="font-family:宋体">做</span><span style="font-family:Times New Roman">map join</span><span style="font-family:宋体">生成</span><span style="font-family:Times New Roman">tmp2,</span><span style="font-family:宋体">把</span><span style="font-family:Times New Roman">tmp2</span><span style="font-family:宋体">读到</span><span style="font-family:Times New Roman">distribute file cache</span><span style="font-family:宋体">。这是一个</span><span style="font-family:Times New Roman">map</span><span style="font-family:宋体">过程。</span></p> 
<p>3<span style="font-family:宋体">、</span><span style="font-family:Times New Roman">map</span><span style="font-family:宋体">读入</span><span style="font-family:Times New Roman">users</span><span style="font-family:宋体">和</span><span style="font-family:Times New Roman">log</span><span style="font-family:宋体">，假如记录来自</span><span style="font-family:Times New Roman">log,</span><span style="font-family:宋体">则检查</span><span style="font-family:Times New Roman">user_id</span><span style="font-family:宋体">是否在</span><span style="font-family:Times New Roman">tmp2</span><span style="font-family:宋体">里，如果是，输出到本地文件</span><span style="font-family:Times New Roman">a,</span><span style="font-family:宋体">否则生成</span><span style="font-family:Times New Roman">&lt;user_id,value&gt;</span><span style="font-family:宋体">的</span><span style="font-family:Times New Roman">key,value</span><span style="font-family:宋体">对，假如记录来自</span><span style="font-family:Times New Roman">member,</span><span style="font-family:宋体">生成</span><span style="font-family:Times New Roman">&lt;user_id,value&gt;</span><span style="font-family:宋体">的</span><span style="font-family:Times New Roman">key,value</span><span style="font-family:宋体">对，进入</span><span style="font-family:Times New Roman">reduce</span><span style="font-family:宋体">阶段。</span></p> 
<p>4<span style="font-family:宋体">、最终把</span><span style="font-family:Times New Roman">a</span><span style="font-family:宋体">文件，把</span><span style="font-family:Times New Roman">Stage3 reduce</span><span style="font-family:宋体">阶段输出的文件合并起写到</span><span style="font-family:Times New Roman">hdfs</span><span style="font-family:宋体">。</span></p> 
<p>如果确认业务需要这样倾斜的逻辑，考虑以下的优化方案：</p> 
<p>1<span style="font-family:宋体">、对于</span><span style="font-family:Times New Roman">join</span><span style="font-family:宋体">，在判断小表不大于</span><span style="font-family:Times New Roman">1G</span><span style="font-family:宋体">的情况下，使用</span><span style="font-family:Times New Roman">map join</span></p> 
<p>2<span style="font-family:宋体">、对于</span><span style="font-family:Times New Roman">group by</span><span style="font-family:宋体">或</span><span style="font-family:Times New Roman">distinct</span><span style="font-family:宋体">，设定 </span><span style="font-family:Times New Roman">hive.groupby.skewindata=true</span></p> 
<p>3<span style="font-family:宋体">、尽量使用上述的</span><span style="font-family:Times New Roman">SQL</span><span style="font-family:宋体">语句调节进行优化</span></p>
                </div>
		</div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/38e370884e9d296ff7f336dde019fe2b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【D3.js数据可视化系列教程】（二十四）--力导向图</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c8484660d80a9a7f508f39d332d37126/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">项目分享-限流框架的实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>