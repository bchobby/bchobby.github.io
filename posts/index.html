<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/babe1b5f99a0c9dd27a871c0e3a45e97/" rel="bookmark">
			推荐一款专业的图片批量处理工具：ImBatch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ImBatch是一款专业的图片批量处理工具，为你的图片处理需求提供强大支持。无论你需要进行哪种图片处理操作，ImBatch都能满足你的要求。让我们以普通用户使用率最高的图片变换处理分类为例，向你展示它的强大功能。
功能丰富，分类清晰
ImBatch的功能十分强大，拥有多项图片变换处理功能。为了让用户更便捷地找到需要的功能，ImBatch进行了分类整理，避免让你在海量功能中迷失。以图片变换为例，它提供了16个功能供你选择，让你的图片处理更加精准。
简单易用，快速上手
使用ImBatch非常简单。打开软件后，你可以通过工具栏上的按钮导入单张图片或整个文件夹。
导入图片后，只需点击右侧的"添加任务"，在任务列表中选择需要进行处理的选项。
以图像格式转换(另存为)功能为例
点击"添加任务 - 保存 - 另存为"，软件右侧将增加一个"另存为"任务。
通过点击"另存为"，你可以进入详细设置窗口，在其中设置文件类型、文件名、输出目录等参数。
完成设置后，你可以继续添加其他任务，设置方法大同小异。
多任务处理，高效完成
ImBatch支持同时处理多个任务，让你的图片处理更加高效。设置完成后，只需点击软件左上角的蓝色三角按钮或按下快捷键Ctrl+B，即可开始批量处理。
处理完成后，软件会发出声音提示，并显示处理时间等相关信息。你可以轻松完成批量处理，节省宝贵的时间。
新功能加入，提升体验
作为一款不断发展的工具，ImBatch不断增加新功能，为用户带来更好的体验。我们持续关注用户需求，并致力于为你提供更多强大的功能和工具，让你的图片处理更加多样化、高效率。
无论是个人用户还是专业用户，ImBatch都是你处理图片的最佳选择。下载ImBatch，让它成为你的图片处理利器，帮助你快速完成各种图片处理任务。
注意：在进行任何图片处理操作时，请遵循合法合规的规定，并尊重他人的版权和隐私。
本文来源于：ImBatch：高效图片批量处理工具，满足你的所有需求-下载集 (xzji.com)https://www.xzji.com/news/13078.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b004aff94762d58cad0e9eaa621ce5c/" rel="bookmark">
			12306推出购票新功能:新增购票需求预填和起售提醒订阅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中国铁路近日宣布，自1月3日起，铁路12306手机客户端将推出两项新功能，包括购票需求预填和火车票起售提醒订阅，旨在提升用户的购票体验。这一举措预计将大大简化旅客的购票流程，使得购买火车票更加方便快捷。
火车票的预售期目前为15天。购票需求预填功能的实施后，将允许旅客在车票发售当天，提前填写乘车人信息、车次、座位等相关信息。一旦车票开始销售，用户即可一键提交订单并快速完成支付，大幅提高了购票的便利性。此外，铁路12306还引入了起售提醒订阅功能。通过这一功能，旅客可以根据车票的起售时间，提前设置多个提醒，确保能够及时提交购票订单。用户可以通过铁路12306平台查询每趟列车的具体起售时间。
这些新功能的加入，标志着中国铁路在提升服务质量和乘客体验方面迈出了重要一步。它们不仅简化了购票过程，还为旅客提供了更多的便利和灵活性，有望吸引更多乘客通过官方平台购买火车票。
本文来源于：铁路12306手机客户端：新增购票需求预填和起售提醒订阅-下载集 (xzji.com)https://www.xzji.com/news/14335.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e920d587a5a2611c41f643a27b3b9922/" rel="bookmark">
			SpringBoot之项目管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 提示：这里可以添加系列文章的所有文章的目录，目录需要自己手动添加
SpringBoot之项目管理
提示：写完文章后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 系列文章目录前言一、指标监控Spring Boot Actuator的使用可视化工具展示actuator使用Spring Boot Admin服务端项目步骤 二、日志管理如何配置日志管理文件？代码中输出日志 总结指标监控日志管理 前言 提示：这里可以添加本文要记录的大概内容：
在当今的软件开发领域，项目管理是至关重要的一环。它确保了项目的按时交付、质量的保证以及团队的高效协作。而在 Spring Boot 框架的加持下，项目管理变得更加高效和便捷。
在这篇博客中，我将介绍两个在 Spring Boot 项目管理中非常重要的方面：指标监控和日志管理。这两个内容对于确保项目的顺利运行和问题的快速定位起着关键作用。
指标监控可以帮助我们实时了解项目的性能和健康状况。通过收集和分析各种指标数据，我们可以及时发现系统的瓶颈、异常情况和性能问题，并采取相应的措施进行优化和修复。日志管理则是我们了解系统运行情况的窗口。它记录了系统在运行过程中产生的各种日志信息，包括错误日志、调试日志和操作日志等。通过有效的日志管理，我们可以快速定位和解决问题，同时还可以进行数据分析和统计，为项目的优化和改进提供依据。
在接下来的博客文章中，我将深入探讨指标监控和日志管理的具体实现方法和最佳实践，分享一些实用的工具和技巧，帮助你更好地管理 Spring Boot 项目。无论你是项目经理、开发人员还是运维人员，这些内容都将对你有所帮助。
让我们一起探索 Spring Boot 的世界，提升项目管理的水平，助力项目的成功交付！
提示：以下是本篇文章正文内容，下面案例可供参考
一、指标监控 Spring Boot Actuator的使用 在 Spring Boot 中，指标监控是指对应用程序的性能指标进行实时监测和收集的过程。通过指标监控，我们可以了解应用程序的运行状况、资源利用率、请求响应时间等关键指标，以便及时发现问题、优化性能和进行故障排除。Spring Boot Actuator可以帮助程序员监控和管理SpringBoot应用，用法如下：
1.在被监控的项目中添加Actuator起步依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 2.编写配置文件
#开启所有监控端点 management.endpoints.web.exposure.include=* 3.访问项目：http://localhost:8080/actuator
通过URL可以调用actuator的功能：
URL查看的数据/env环境属性/health健康检查/mappings显示所有的@RequestMapping路径/loggers日志/info定制信息/metrics查看内存、CPU核心等系统参数/trace用户请求信息 可视化工具展示actuator Spring Boot Admin 是一个用于管理和监控 Spring Boot 应用程序的开源工具。它提供了一个集中式的界面，用于监控和管理多个 Spring Boot 应用程序。
使用 Spring Boot Admin 查看 actuator 生成的指标数据有以下几个优点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e920d587a5a2611c41f643a27b3b9922/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abc6b31caabc994ff7977d149707d931/" rel="bookmark">
			利用MATLAB绘制折线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		x=20:20:140;%x轴上的数据，第一个值代表数据开始，第二个值代表间隔，第三个值代表终止 a=[0.85, 2.2, 3.45, 2.65, 1.5, 1.9, 1.25]; %a数据y值 plot(x,a,'-*b'); %线性，颜色，标记 axis([0,160,0,4]) %确定x轴与y轴框图大小 set(gca,'XTick',[0:20:160]) %x轴范围1-6，间隔1 set(gca,'YTick',[0:1:4]) %y轴范围0-700，间隔100 legend('position1'); %右上角标注 xlabel('爬行量(cm)') %x轴坐标描述 ylabel('误差（％）') %y轴坐标描述 x=20:20:140;%x轴上的数据，第一个值代表数据开始，第二个值代表间隔，第三个值代表终止 a=[0.85, 2.2, 3.45, 2.65, 1.5, 1.9, 1.25]; %a数据y值 b=[1.2, 1, 2, 2, 1, 3, 1];%b数据y值 plot(x,a,'-*b', x,b,'-or'); %线性，颜色，标记 axis([0,160,0,4]) %确定x轴与y轴框图大小 set(gca,'XTick',[0:20:160]) %x轴范围0-160，间隔20 set(gca,'YTick',[0:1:4]) %y轴范围0-4，间隔1 legend('position_a','position_b'); %右上角标注 xlabel('爬行量(cm)') %x轴坐标描述 ylabel('误差（％）') %y轴坐标描述 x=120:120:840;%x轴上的数据，第一个值代表数据开始，第二个值代表间隔，第三个值代表终止 a=[0.17, 0.38, 0.44, 0.30, 0.36, 0.49, 0.32]; %a数据y值 b=[0.01, 0.03, 0.12, 0.22, 0.12, 0.13, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abc6b31caabc994ff7977d149707d931/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6564092e411f3085190549595ebbb44e/" rel="bookmark">
			SpringBoot之参数校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 提示：这里可以添加系列文章的所有文章的目录，目录需要自己手动添加
SpringBoot之参数校验
提示：写完文章后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 系列文章目录前言一、参数校验的重要性二、简单数据类型参数校验三、对象类型参数校验四、异常处理总结 前言 提示：这里可以添加本文要记录的大概内容：
在 SpringBoot 的世界里，参数校验是确保数据完整性和正确性的重要一环。它就像是一道坚固的防线，守护着我们的应用程序，防止恶意或错误的数据闯入。
想象一下，如果没有参数校验，我们的应用将会面临各种数据不一致、空指针异常等问题，就像是一场噩梦。但是，有了 SpringBoot 的参数校验功能，我们可以轻松地对传入的参数进行检查，确保它们符合我们的预期。
这就像是给我们的应用程序加上了一层保护罩，让我们可以放心地处理数据，而不用担心数据的质量问题。所以，让我们一起深入了解 SpringBoot 的参数校验吧，掌握它的奥秘，让我们的应用程序更加健壮和可靠！
提示：以下是本篇文章正文内容，下面案例可供参考
一、参数校验的重要性 在应用程序的各个层面，我们都需要对传入的参数进行校验，以确保它们符合预期的格式、范围和约束。参数校验可以帮助我们避免以下问题：
数据不合法：通过对参数进行校验，可以确保数据符合业务规则和数据模型的要求。异常处理：在参数校验过程中，可以提前捕获和处理非法参数，避免在后续的业务逻辑中引发异常。安全性：通过参数校验，可以防止 SQL 注入、跨站脚本攻击等安全漏洞。 二、简单数据类型参数校验 SpringBoot自带了validation工具可以从后端对前端传来的参数进行校验，用法如下：
引入validation起步依赖 &lt;!-- 参数校验 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; 在需要进行参数校验的实体类上添加@Validated注解，表示该类将进行参数校验。在参数前加校验注解，表示对这个参数进行具体的参数校验。 // 该控制器开启参数校验 @Validated @Controller public class TestController { @RequestMapping("/t1") @ResponseBody // 在参数前加校验注解，该注解的意思是字符串参数不能为null public String t1(@NotBlank String username){ System.out.println(username); return "请求成功！"; } } 访问http://localhost:8080/t1，发现当没有传来参数时，会抛出ConstraintViolationException异常。在校验参数的注解中添加message属性，可以替换异常信息。 // 该控制器开启参数校验 @Validated @Controller public class TestController { @RequestMapping("/t1") @ResponseBody // 在参数前加校验注解，该注解的意思是字符串参数不能为null public String t1(@NotBlank(message = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6564092e411f3085190549595ebbb44e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c59f7a2218cd87c2537a71b97898f841/" rel="bookmark">
			魔兽3.3.5版本AI模块代码拆分解析（魔兽3.3.5模块是状态机）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、简介1）大怪物的AI主要涉及两个类：BossAI和WorldBossAI2）普通小怪的AI，基本继承类：ScriptedAI3）传奇怪物的AI，继承CreatureAI类4）人物AI，PlayerAI类5）PassiveAI（被动AI）：6）PossessedAI（被占据AI）：7）NullCreatureAI（空生物AI）：8）CritterAI（小动物AI）：9）TriggerAI（触发器AI）10）AggressorAI（攻击者AI）：11）CombatAI（战斗AI）：12）CasterAI（施法者AI）：13）ArcherAI（弓箭手AI）：14）TurretAI（炮塔AI）：15）VehicleAI（载具AI）：16）TotemAI （图腾AI）17）GuardAI（守卫AI）18）NullGameObjectAI（空游戏对象AI）：19）GameObjectAI（游戏对象AI）：20）SmartGameObjectAI（智能游戏对象AI）： 本文是主讲怪物方向的AI
一、简介 1）大怪物的AI主要涉及两个类：BossAI和WorldBossAI ①继承顺序
BossAI和WorldBossAI都继承来自ScriptedAI类
ScriptedAI类继承来自CreatureAI类，
Creature类继承来自UnitAI类
②个例举例(继承BossAI)
&lt;1&gt;科林·狄尔布鲁（Coren Direbrew）
struct boss_coren_direbrew : public BossAI &lt;2&gt;烟网女王（Mother Smolderweb）
struct boss_mother_smolderweb : public BossAI &lt;3&gt;巨龙之王维姆萨拉克（Overlord Wyrmthalak）
struct boss_overlord_wyrmthalak : public BossAI ③WorldBossAI继承举例
1）Azuregos（艾索雷葛斯） struct boss_azuregos : public WorldBossAI 2)翡翠龙（emerald_dragon） struct emerald_dragonAI : public WorldBossAI 2）普通小怪的AI，基本继承类：ScriptedAI ①分别举例说明：
1）暮光志愿者AI
struct npc_twilight_volunteer : public ScriptedAI 2）Millhouse Manastorm（米尔豪斯·法力风暴）
struct npc_millhouse_manastorm : public ScriptedAI 3）传奇怪物的AI，继承CreatureAI类 ①the lich king巫妖王的全部AI
②Valithria Dreamwalker (瓦莉瑟瑞娅·梦行者) 的全部AI
③Algalon the Observer（奥尔加隆，观察者之眼）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c59f7a2218cd87c2537a71b97898f841/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb8c47ceff2b3ab64d56d56108fe18ac/" rel="bookmark">
			python实现简易的flask后端接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先安装插件pip install flask
新建py脚本文件编码：
# -*- coding: utf-8 -*- from flask import Flask from flask_cors import CORS	# 跨域依赖，通过pip install flask-cors安装 app = Flask(__name__) cors = CORS(app) # 跨域设置，这样设置就是所有接口均跨域 @app.route('/testApi', methods=["POST"])	# 默认为get方式 def testApi(): # 获取地址栏参数 args = request.args print('args: ', args) # 比如说要拿分页页码，就直接get pageSize = args.get('pageSize') # 获取请求体数据 data = json.loads(request.data) print('data:', data) result = { "code": "200", "message": "SUCCEED" "data": "搞咩啊！" } return json.dumps(result) if __name__ == '__main__': app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb8c47ceff2b3ab64d56d56108fe18ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35bc2595ba80f5c71e0a0c4584c717bc/" rel="bookmark">
			服务端开发中的数据库交互与数据存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的发展，服务端开发在构建强大的应用程序中扮演着至关重要的角色。在这个过程中，与数据库的高效交互和数据存储变得尤为关键。本文将探讨在服务端开发中如何处理与数据库的交互以及有效地进行数据存储。
1. 数据库的选择 在开始服务端开发之前，首先需要选择合适的数据库。不同的应用场景可能需要不同类型的数据库，例如关系型数据库（如MySQL、PostgreSQL）、NoSQL数据库（如MongoDB、Cassandra）等。选择数据库时需要考虑应用的性能要求、数据结构以及扩展性需求。
2. 数据库连接与连接池 在服务端开发中，与数据库建立连接是一个常见的操作。为了提高性能，通常会使用连接池技术，它可以维护一组数据库连接，避免频繁地创建和销毁连接。连接池可以有效地管理连接的数量，提高数据库访问的效率。
# Python中使用连接池的例子（使用SQLAlchemy） from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker # 创建数据库连接池 engine = create_engine('mysql://user:password@localhost/dbname', pool_size=10, max_overflow=20) # 创建Session类 Session = sessionmaker(bind=engine) # 使用连接池创建Session实例 session = Session() 3. SQL查询与ORM 与数据库交互的一种常见方式是使用SQL语句进行查询。另一种方式是使用对象关系映射（ORM）工具，它允许开发者使用面向对象的方式操作数据库，而不是直接编写SQL语句。ORM工具如SQLAlchemy、Django ORM等可以简化数据库交互的流程，提高开发效率。
# 使用SQLAlchemy进行查询的例子 from sqlalchemy import create_engine, Column, Integer, String, Sequence from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import sessionmaker # 定义数据模型 Base = declarative_base() class User(Base): __tablename__ = 'users' id = Column(Integer, Sequence('user_id_seq'), primary_key=True) name = Column(String(50)) age = Column(Integer) # 创建数据库连接池 engine = create_engine('sqlite:///:memory:', echo=True) # 创建数据表 Base.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35bc2595ba80f5c71e0a0c4584c717bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20ceacb838a813623e6d69b7bda128da/" rel="bookmark">
			【LeetCode 面试经典150题】12. Integer to Roman 整数转罗马数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		12. Integer to Roman Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M.
SymbolValueI1V5X10L50C100D500M1000 For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.
Roman numerals are usually written largest to smallest from left to right.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20ceacb838a813623e6d69b7bda128da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41e8666839ba583937f8d09d5cf8d1e2/" rel="bookmark">
			【LeetCode 面试经典150题】13. Roman to Integer 罗马数组转整数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		13. Roman to Integer 题目大意 Roman numerals are represented by seven different symbols: I, V, X, L, C, D, and M.
SymbolValueI1V5X10L50C100D500M1000 For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.
Roman numerals are usually written largest to smallest from left to right.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41e8666839ba583937f8d09d5cf8d1e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6db0e9a2d0e58c152a850019c4bb168f/" rel="bookmark">
			【LeetCode 面试经典150题】42. Trapping Rain Water 接雨水
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		42. Trapping Rain Water 题目大意 Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
中文释义 给定 n 个非负整数，代表以宽度为 1 的条形图的高程图，计算下雨后它能接多少雨水。
Example Example 1:
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6Explanation: 上述高程图（黑色部分）由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示。在这种情况下，被接的雨水量（蓝色部分）为 6 单位。 Example 2:
Input: height = [4,2,0,3,2,5]Output: 9 Constraints n == height.length1 &lt;= n &lt;= 2 * 10^40 &lt;= height[i] &lt;= 10^5 解题思路 算法描述 这段代码的目的是计算在一个给定的高程图中能够接多少雨水。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6db0e9a2d0e58c152a850019c4bb168f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d9525152837b0cdcd229a2a9ae5d9ef/" rel="bookmark">
			使用（C&#43;&#43;）QT实现经典小游戏（俄罗斯方块）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 学习QT有段时间了，但是也没用来做过啥，这两日就突然想到了这个游戏，于是就打算用QT写一个，也不是纯纯自己写的代码，在写之前我也是找了几个别人的项目看了一下，学习了框架的搭建，和某些类的使用。
首先我也是将整个程序分作了四块：
一、方块类：主要就是对每个方块的坐标的一个封装
二、游戏区域：根据实时的要求，根据坐标画出方块
三、下一块方块：刷新下一块方块
四、计分区域：根据得分显示关卡、分数等
二、代码实现 在代码中都已经写了注释了，外面就不多累述了
1.ui界面 NextArea和GameArea都是由Qwidget提升上来的。
2.item方块类 2.1头文件 /* * 俄罗斯方块的方块类文件 */ #ifndef ITEM_H #define ITEM_H #pragma once #include &lt;QObject&gt; #include &lt;QWidget&gt; #include &lt;QVector&gt; #include &lt;QPoint&gt; #include &lt;QPainter&gt; typedef QVector&lt;QPoint&gt; povector; //坐标容器 enum ItemType//7种方块，四种朝向 { ItemType_I = 0, ItemType_L1, ItemType_L2, ItemType_T, ItemType_O, ItemType_Z1, ItemType_Z2, ItemType_MAX, }; class Item { public: Item(){} Item(ItemType type,int direction);//有参构造方块 ~Item(){} void NewItem(int random_number);//通过随机的一个数来创建一个新的方块 void initpoint(ItemType type,int direction);//根据方块的类型和朝向初始化四个小方块的坐标 ItemType type(); //返回方块的类型 int direction(); //返回方块的朝向 void ClearPoints();//清除坐标信息 void drawItem(QPainter &amp;painter,int x,int y,int width,int height); //根据坐标和宽高画图形 void changedirection(int direction=1); //改变方块的朝向，我的朝向加1即为下一个朝向，顺时针旋转90° void moveItem(int x,int y);//横向移动x格,竖向移动y格 void movetoItem(int x,int y);//移动到（x,y）位置 void AddPoints(povector&amp; points); //添加方块格子坐标 void Deleterow(int y); //删除坐标为y的一行 void MoveDown(int nRow, int y);//删除行以后其它的方块下移 public: ItemType mytype; //我的方块 int mydirection; //我的方块朝向 QPoint mypos; //我的方块位置坐标 povector myPoint; //我的方块四小块的坐标 }; #endif // ITEM_H 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d9525152837b0cdcd229a2a9ae5d9ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d601a90b660abbdf00d5f1bf8a655f/" rel="bookmark">
			魔兽服务器学习-笔记（服务器部署、地图管理、DB、日志模块、任务模块、战斗模块）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、环境准备1）依赖安装2）源码下载和编译 二、生成数据信息1）地图数据信息（客户端信息）2）数据库信息 三、启动服务器四、日志模块五、数据库模块六、场景模块1）地图管理2）AOI算法1、静态数据讲解2、动态数据：3、动态数据结构NGrid解析4、涉及用户登录的逻辑及grid状态转变5、涉及玩家退出的逻辑及grid状态转变 3）地图数据驱动1）网络驱动2）地图定时更新做的事 4）动态数据管理（1）设计模式-访问者模式及代码表现形式 5）碰撞检测实现（BIH+AABB） 七、战斗模块1）技能模块①技能信息类SpellInfo 八、MMO常用模块（任务、副本、商店等）九、AI十、游戏实体代码1）trinitycore实体类介绍2）分开介绍各实力类（1）object类 十、背包模块 一、环境准备 1）依赖安装 sudo apt-get update sudo apt-get install git clang cmake gcc g++ libmysqlclient-dev libss-dev libbz2-dev libreadline-dev libncurses-dev libboost-all-dev mysql-server-5.7 p7zip sudo update-alternatives --install /usr/bin/cc cc /usr/bin/clang 100 sudo update-alternatives --install /usr/bin/c++ c++ /usr/bin/clang 100 // sudo yum install -y clang 2）源码下载和编译 git clone -b 3.3.5 https//github.com//TrinityCore/TrinityCore.git mkdir build cd build cmake ../ -DCMAKE_INSTALL_PREFIX=/home/lighthouse/tinycore -DCONF_DIR=/home/lighthouse/tinycore/bin make -j2 （nproc看核心数来编译） make install 二、生成数据信息 1）地图数据信息（客户端信息） 1）cd ~ 2）mkdir res (根目录创建res文件夹) 3）把客户端目录的Data和Interface移动到res目录下 4）cd res 在res目录执行游戏目录bin/下面的mapextractor， 生成dbc和maps文件夹 5）mkdir vmaps 在res目录执行游戏目录bin/下面的vmap4extractor， 生成vmaps文件夹和Buildings目录 5）在res目录执行游戏目录bin/下面的vmap4assembler， .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61d601a90b660abbdf00d5f1bf8a655f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfab7f0cdb4d0fe7b68970cdbb99656c/" rel="bookmark">
			魔兽3.3.5版本背包模块代码拆分解析（从之前的文章中拆分出来）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、涉及到的文件二、先看成员变量（单个背包的存储数据）三、再看玩家背包和DB的交互1）逐行解析db表2）sql语句变更记录(记录一些sql语句对数据存储的影响)3）额外提一嘴物品在mysql的存储4）预编译背包的物品和db交互的sql语句 四、解析成员函数1）构造函数2）析构函数3）实体添加到世界4）背包添加物品5）获得对应id的物品数量6）根据物品标签获得对应物品数量7）根据物品id获取对应背包内物品的槽位 五、背包总结七、已上阵的装备代码1）建立人物碰撞体代码讲解开始2）源码枚举 六、代码 不想写在 魔兽服务器学习-笔记之中了，之前的文章篇幅太长，代码在最后的模块 一、涉及到的文件 Object.h Item.h Bag.h 这里的背包继承了物品类，而物品类又继承了对象Object类
注意点
因为这里避免看的越多，所以这里从Bag.h看起，因为从Object.h看起来的话，根本看不完 二、先看成员变量（单个背包的存储数据） #define MAX_BAG_SIZE 36 // Bag Storage space Item* m_bagslot[MAX_BAG_SIZE]; 可以看到这里是存了指针数组，上限是36（因为c with class的关系，而且对于游戏来说内存很重要）
三、再看玩家背包和DB的交互 背包类和DB交互的代码 // DB operations // overwrite virtual Item::SaveToDB void SaveToDB(CharacterDatabaseTransaction trans) override; // overwrite virtual Item::LoadFromDB bool LoadFromDB(ObjectGuid::LowType guid, ObjectGuid owner_guid, Field* fields, uint32 entry) override; // overwrite virtual Item::DeleteFromDB void DeleteFromDB(CharacterDatabaseTransaction trans) override; 玩家背包数据的db存储sql语句 DROP TABLE IF EXISTS `character_inventory`; /*!40101 SET @saved_cs_client = @@character_set_client */; /*!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfab7f0cdb4d0fe7b68970cdbb99656c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55eadc45f7a323c541262069024ace63/" rel="bookmark">
			java.util.regex.PatternSyntaxException: Illegal repetition {
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 使用 replaceAll 替换字符串时，报如下错误：
java.util.regex.PatternSyntaxException: Illegal repetition {" at java.util.regex.Pattern.error(Pattern.java:1924) at java.util.regex.Pattern.closure(Pattern.java:3104) at java.util.regex.Pattern.sequence(Pattern.java:2101) at java.util.regex.Pattern.expr(Pattern.java:1964) at java.util.regex.Pattern.compile(Pattern.java:1665) at java.util.regex.Pattern.&lt;init&gt;(Pattern.java:1337) at java.util.regex.Pattern.compile(Pattern.java:1022) at java.lang.String.replaceAll(String.java:2162)12345678910 代码为：
String s = allData.replaceAll("{\"","{'")；1 问题原因 参数传递问题，replaceAll(String regex, String replacement) 方法的第一个参数为正则表达式，而 “{ ” 是正则表达式中的特殊字符，要匹配 {，需要转义后使用，replaceAll 方法源码如下：
public String replaceAll(String regex, String replacement) { return Pattern.compile(regex).matcher(this).replaceAll(replacement); }123 解决方法 对“{ ”转义即可：
String s = allData.replaceAll("\\{\"","{'")1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ed2c42f18468b3c3e2c1d4c7eba45a0/" rel="bookmark">
			AOP获取方法返回值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们用Spring的AOP切面做日志收集或者记录的时候，在springboot中用@Aspect注解。比如：
@Aspect public class AdviceTest { @Before("execution(* com.abc.service.*.many*(..))") public void permissionCheck(JoinPoint point) { System.out.println("@Before：模拟权限检查..."); System.out.println("@Before：目标方法为：" + point.getSignature().getDeclaringTypeName() + "." + point.getSignature().getName()); System.out.println("@Before：参数为：" + Arrays.toString(point.getArgs())); System.out.println("@Before：被织入的目标对象为：" + point.getTarget()); } @After("execution(* com.abc.service.*.many*(..))") public void releaseResource(JoinPoint point) { System.out.println("@After：模拟释放资源..."); System.out.println("@After：目标方法为：" + point.getSignature().getDeclaringTypeName() + "." + point.getSignature().getName()); System.out.println("@After：参数为：" + Arrays.toString(point.getArgs())); System.out.println("@After：被织入的目标对象为：" + point.getTarget()); } 12345678910111213141516171819202122 @Before表示方法请求前执行，@After表示方法请求后执行，一般做记录的时候会使用@After比较多。但是有时候我们需要获取方法的返回值做判断该如何处理呢？首先，我们看@After的注解源码。
@Retention(RetentionPolicy.RUNTIME) @Target({ElementType.METHOD}) public @interface After { String value(); String argNames() default ""; } 1234567 可以看到@After注解并不能获取到方法的返回值。这个时候我们需要的是@AfterReturning。
@Retention(RetentionPolicy.RUNTIME) @Target({ElementType.METHOD}) public @interface AfterReturning { String value() default "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ed2c42f18468b3c3e2c1d4c7eba45a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae295ef709445d123317ba5aad78fcd8/" rel="bookmark">
			paddle识别英文和数字python代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载模型 https://github.com/PaddlePaddle/PaddleOCR/blob/release/2.7/doc/doc_ch/models_list.md#22-%E8%8B%B1%E6%96%87%E8%AF%86%E5%88%AB%E6%A8%A1%E5%9E%8B
number_model = PaddleOCR(lang="en",det_model_dir = 'xxx\en_PP-OCRv3_det_infer',rec_model_dir=r'xxx\en_PP-OCRv3_rec_infer') number_result = number_model.ocr(img=r'xxx.jpg') 效果：只能识别英文数字，如果图片有中文或者其他语言，会错误识别
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/309f3bbab52f3a72608a8e10133da227/" rel="bookmark">
			Linux C/C&#43;&#43; 获取CPUID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现方式：
INTEL CC 格式
AT^T CC 格式
GCC/C库 __cpuid 宏
大致讲义：
AT^T 格式汇编很反人类，GCC可以改编译器选项为INTEL内嵌汇编，但一般在GCC还是按照默认的AT^T汇编来拽写把，不想用也可以让AI工具把INTEL内嵌汇编转换为AT^T汇编（让 bard、gpt、bing 干这种反人类的活很好用），AT^T汇编格式没有学的必要，这是一个反人类的东西。
__asm__ __volatile__(
"movl $0x00, %%eax\n\t"
"xorl %%edx, %%edx\n\t"
"cpuid\n\t"
"movl %%eax, %0\n\t"
"movl %%edx, %1\n\t"
: "=m" (s1), "=m" (s2)
:
: "%eax", "%edx"
);
汇编是一种面向地址标识符及通用寄存器编程的低级语言。
IL: 把立即数0移动到EAX寄存器，CPU参数（LEVEL，CPU内置指令函数取值范围0~1）
IL: 把EDX寄存器XOR（亦或）重置为0
IL: cpuid 指令（会推送值到EAX、EBX、ECX、EDX 四个寄存器之中，SN[4]）
IL: 把EAX寄存器的值复制给内链参数一（注意是压入是内存地址，%0 = s1变量）
IL: 把EDX寄存器的值复制给内链参数二（注意是压入是内存地址，%1 = s2变量）
声明内嵌所需要的寄存器与变量内存地址。
注解：
__asm__ __volatile__ ( "movl $0x00, %%eax\n\t" // 将立即数 0x00 移动到 eax 寄存器中 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/309f3bbab52f3a72608a8e10133da227/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dde752700eb1600f405a6fa36d73c161/" rel="bookmark">
			智能合约开发（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备： 注册智能合约在线开发平台，用于solidity语言的智能合约开发。在浏览器上安装metamask钱包插件，并注册账号 以太坊智能合约平台地址：
https://remix.ethereum.org
4小时速成solidity开发教程
https://www.youtube.com/watch?v=AYpftDFiIgk
基础知识： 智能合约和python一样，也可以导入库，
以下是一些常用的智能合约库，
ERC-20（Ethereum Request for Comments 20）：是以太坊区块链上的一种通用标准，用于发行代币，规定了代币合约应该遵循的一些基本功能，包括代币的转账、余额查询、代币的总供应量等。但是随着发展发现ERC20功能仍不全面，缺少对代币地销毁等功能，因此需要与其他合约共同使用，如ERC20Burnable.sol
ERC-721：主要用于创建独特、不可替代的代币，通常被称为非同质化代币（NFTs，Non-Fungible
Tokens）。每一个ERC-721代币都有独一无二的属性，使其适用于代表数字资产、艺术品、游戏物品等具有唯一性的资产。
Ownable.sol：目的是为智能合约提供拥有者（Owner）的概念，并定义了与拥有者相关的权限控制机制，主要有三个功能，合约所有权确认，合约权限管理，合约所有权转移
库的导入地址： //导入ERC20 import "@openzeppelin/contracts/token/ERC20/ERC20.sol"; import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"; import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol"; //导入erc721 import "@openzeppelin/contracts/token/ERC721/ERC721.sol"; //导入ownable.sol import "@openzeppelin/contracts/access/Ownable.sol"; 后续会写一个基于ERC20和ownable的代币例程，包括代币铸造，转账和销毁功能，并确保合约owner的权限，
预计1月7号更新在《智能合约开发（2）》里
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c590b2d4e2701d0a337080071138dbb/" rel="bookmark">
			报表生成器FastReport .Net用户指南：带图表的报告（图表编辑器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FastReport .Net是一款全功能的Windows Forms、ASP.NET和MVC报表分析解决方案，使用FastReport .NET可以创建独立于应用程序的.NET报表，同时FastReport .Net支持中文、英语等14种语言，可以让你的产品保证真正的国际性。
FastReport.NET官方版下载https://www.evget.com/product/1861/download
"Chart"对象包含许多可在图表编辑器中处理的设置。要调用编辑器，请双击 "Chart"对象：
处理系列 "Chart "对象可以包含一个或多个系列。系列列表显示在编辑器中：
要添加新系列，请按 "Add... "按钮。您将看到 "Gallery "对话框：
择需要的类别，然后选择 - 需要的系列类型。如果想将序列放在自己的图表区域中，请选中 "Add new chart area for this series "复选框。对于某些系列类型（如饼图、圆图、金融图、金字塔图），无论复选框状态如何，都会自动添加新的图表区域。
要删除序列，请按 "Delete "按钮。要更改序列顺序，请使用 "Up"和 "Down "按钮。
设置外观 使用图表编辑器，您可以设置每个图表元素的外观。所有属性（超过 100 个）分为几类。其中一些是 "Chart "对象特有的，而另一些则系列的一部分。
如果从系列列表中选择 "Chart "对象，则会看到以下属性页面：
"Appearance" - 图表的边框和填充；"Chart area" - 边框、填充、阴影；"3D" - 3D 设置；"Axes"- 设置轴的外观、标题、标签、网格、标记、自定义标签和条带；"Legend" --图例样式、停靠、边框、填充、阴影和字体；"Title"- 标题、停靠、边框、填充、阴影和字体的样式。 如果从系列列表中选择系列对象，则会看到以下属性页面：
"Appearance"--针对所选系列类型的一些特定设置；"Fill &amp; border"--系列值的填充和边框；"Labels"--系列标签。您可以选择标签类型、字体、颜色和填充；"Markers"--系列标记。可以选择标记类型、颜色和边框。 连接图表和数据 您可以通过多种方式在图表中填充数据：
使用数据源。为 "Chart "对象指明数据源，并将每个系列连接到数据列。每个系列使用固定。使用脚本为对象填充数据。 要将图表连接到数据源，请按照以下步骤操作：
在系列列表中选择 "Chart "对象；切换到 "Data"选项卡；选择数据源： 设置数据筛选表达式。该过滤器将应用于所有图表系列；在系列列表中选择系列；切换到 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c590b2d4e2701d0a337080071138dbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d39376d359e2ec776954dc82de5cd9f1/" rel="bookmark">
			PDF控件Spire.PDF for .NET【安全】演示：获取并验证 PDF 中的数字签名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 PDF 中创建数字签名广泛用于保护 PDF 文件。因此，当您查看一些带有数字签名的PDF文件时，需要获取并验证数字签名。本文向您展示了一种通过使用Spire.PDF和 C# 代码来获取和验证 PDF 中的数字签名的解决方案。
Spire.PDF for .NET 是一款独立 PDF 控件，用于 .NET 程序中创建、编辑和操作 PDF 文档。使用 Spire.PDF 类库，开发人员可以新建一个 PDF 文档或者对现有的 PDF 文档进行处理，且无需安装 Adobe Acrobat。
E-iceblue 功能类库Spire 系列文档处理组件均由中国本土团队研发，不依赖第三方软件，不受其他国家的技术或法律法规限制，同时适配国产操作系统如中科方德、中标麒麟等，兼容国产文档处理软件 WPS（如 .wps/.et/.dps 等格式
Spire.PDF for.net下载 Spire.PDF for java下载
确保 Spire.PDF for .NET（版本 2.9 或更高版本）已正确安装。在下载的 Bin 文件夹中添加 Spire.PDF.dll 作为参考，路径如下：“..\Spire.PDF\Bin\NET4.0\ Spire.PDF.dl”。
下面是如何获取和验证数字签名的C#代码片段：
加载带有数字签名的 PDF 文件。
string filename = @"..\..\DigitalSignature.pdf"; 获取 PDF 中的所有签名：
[C#]
List&lt;PdfSignature&gt; signatures = new List&lt;PdfSignature&gt;(); PdfDocument doc = new PdfDocument(filename); PdfFormWidget form = (PdfFormWidget)doc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d39376d359e2ec776954dc82de5cd9f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74c21c419bf85bc384f9cd23231eb5c8/" rel="bookmark">
			Django评论系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
创建评论模型
将新模型添加到管理站点
创建一个表单来提交评论和验证输入数据 显示评论总数和评论列表
创建评论表单，当表单成功提交时，显示一条成功消息
创建评论模型 blog/models.py
class Comment(models.Model): post = models.ForeignKey(Post,on_delete=models.CASCADE,related_name='comments') name = models.CharField(max_length=80) email = models.EmailField() body = models.TextField() created = models.DateTimeField(auto_now_add=True) updated = models.DateTimeField(auto_now=True) active = models.BooleanField(default=True) class Meta: ordering = ('created',) def __str__(self): return 'Comment by {} on {}'.format(self.name, self.post) 📌related_name让我们可以使用属性命名相互关联的对象。通过Post.comments.all()检索文章所有评论。如果没有定义related_name属性，Django将使用小写的模型名，后面跟着_set （comment_set)
更新数据库
python .\\manage.py makemigrations blog python .\\manage.py migrate
将新模型添加到管理站点 from .models import Post,Comment #... @admin.register(Comment) class CommentAdmin(admin.ModelAdmin): list_display = ('name','email','post','created','active') list_filter = ('active','created','updated') search_fields = ('name','email','body') 模型关联 API 用法示例 | Django 文档 | Django (djangoproject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74c21c419bf85bc384f9cd23231eb5c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f82610f3f22470c6acdc2cac18a45e3e/" rel="bookmark">
			后端开发——jdbc的学习（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上篇结束了Mysql数据库的基本使用，本篇开始对JDBC进行学习总结，开始先简单介绍jdbc的基本使用，以及简单的练习；后续会继续更新！以下代码可以直接复制到idea中运行，便于理解和练习。 JDBC的概念
JDBC（Java DataBase Connectivity：java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系型数据库提供统一访问，它是由一组用Java语言编写的类和接口组成的。
JDBC的作用：可以通过java代码操作数据库
JDBC的本质
JDBC实质上是java官方提供的一套规范(接口)。用于帮助开发人员快速实现不同关系型数据库的连接！
代码一： import com.mysql.cj.jdbc.Driver; import java.sql.*; //TODO 简单练习感受jdbc： public class data_test1 { public static void main(String[] args) throws SQLException { //1.注册驱动： DriverManager.registerDriver(new Driver()); //2.获取连接：（桥梁） // java程序需要和数据库建立连接； 需要调用getConnection方法，并且需要填入连接数据库的基本信息：数据库ip地址，数据库端口号；账号；密码；连接数据库的名称； //该方法第一个参数：url；第二个参数:username;第三个参数：password； Connection connection = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/atguigudb", "root", "dir99"); //3.创建statement（创建将sql语句传入mysql的载具） Statement statement=connection.createStatement(); //4.发送sql语句，并且获取返回结果： String sql="select *from jobs;"; ResultSet resultSet = statement.executeQuery(sql); //5.将结果进行解析： //先看看有没有下一行数据，有就可以获取： while(resultSet.next()){ String job_id = resultSet.getString("job_id"); String job_title = resultSet.getString("job_title"); int min_salary = resultSet.getInt("min_salary"); int max_salary = resultSet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f82610f3f22470c6acdc2cac18a45e3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c86f3dcd3b83ee31b3e1bcb1d55ee454/" rel="bookmark">
			Vue 3 中的 watch 函数：实战指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue.js 是一个功能丰富的前端框架，它允许开发者以声明式的方式创建动态和反应式的用户界面。Vue 3 引入的 Composition API 增强了代码的组织和复用，其中 watch 函数是一个非常有用的特性。本文将通过一系列的示例，展示如何在 Vue 3 应用程序中使用 watch 函数来监控数据变化。
监控响应式引用（ref） 响应式引用是 Vue 3 中最基本的响应式特性之一。下面的例子演示了如何监控一个响应式引用的变化：
import { ref, watch } from 'vue'; export default { setup() { const count = ref(0); watch(count, (newCount, oldCount) =&gt; { console.log(`Count changed from ${oldCount} to ${newCount}`); if (newCount === 10) { alert('Count reached 10!'); } }); return { count }; } }; 在这个例子中，每当 count 的值变化时，watch 回调就会执行，并打印出新旧值。
监控响应式对象（reactive） reactive 提供了一个更复杂的响应式状态管理。下面的例子展示了如何监控一个响应式对象的属性变化：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c86f3dcd3b83ee31b3e1bcb1d55ee454/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd54ab917060caca01b0b33049812227/" rel="bookmark">
			[C#]基于deskew算法实现图像文本倾斜校正
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【算法介绍】
让我们开始讨论Deskeweing算法的一般概念。我们的主要目标是将旋转的图像分成文本块，并确定它们的角度。为了让您详细了解我将使用的方法：
照常-将图像转换为灰度。应用轻微的模糊以减少图像中的噪点。现在，我们的目标是找到带有文本的区域，即图像的文本块。为了使文本块检测更容易，我们将反转并最大化图像的颜色，这将通过阈值化来实现。因此，现在文本变为白色（恰好为255,255,255白色），而背景为黑色（同样为0,0,0黑色）。要查找文本块，我们需要合并该块的所有打印字符。我们通过膨胀（扩展白色像素）来实现。在X轴上使用较大的内核可以消除单词之间的所有空间，而在Y轴上使用较小的内核可以将彼此之间的一个块的行混合在一起，但保持文本块之间的较大间隔不变。现在，用最小面积矩形包围轮廓的简单轮廓检测将形成我们需要的所有文本块。确定倾斜角度的方法有很多种，但我们将坚持简单的方法-使用最大的文本块并使用其角度。 【效果展示】
【实现部分代码】
using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Diagnostics; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; namespace FIRC { public partial class Form1 : Form { Bitmap src = null; public Form1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { OpenFileDialog openFileDialog = new OpenFileDialog(); openFileDialog.Filter = "图文件(*.*)|*.jpg;*.png;*.jpeg;*.bmp"; openFileDialog.RestoreDirectory = true; openFileDialog.Multiselect = false; if (openFileDialog.ShowDialog() == DialogResult.OK) { src = new Bitmap(openFileDialog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd54ab917060caca01b0b33049812227/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6764ad13c37e57f8ff19f6481d33d2fc/" rel="bookmark">
			“百模大战”打响，AI大模型彻底引爆应用新浪潮？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 每日一句正能量前言“百模大战”：内卷已然来袭AI+提速，引爆应用新浪潮后记 每日一句正能量 告别以前的不如意，挥手迈步走向世界。
前言 AI大模型时代，正加速而至。
对于很多科技巨头、独角兽企业而言，如果没有涉足AI领域，似乎就要被时代车轮所狠狠碾过。而最能证明自身投入时代洪流的，自然就是推出AI大模型。纵览当下的行业发展态势，在极短的时间内国内已经涌现130+AI大模型，且依据实力、方向、侧重等不同，也出现了垂直细分的现象。
这场突如其来、全面打响的“百模大战”来势汹汹，既考验科技、互联网企业的技术底蕴，又带来新的挑战：如何不再对着空气“画大饼”，力争在应用层面一马当先？在这样的集体思考下，AI应用即将进入大爆发时代。
我们能够看到，基于AI大模型，生成式AI应用的细分赛道在不断开辟或扩充。AI+办公软件、AI+创意工具、AI+企业服务、AI+网络安全、AI+金融以及医疗、教育等，处于日新月异的发展态势中。可以预见的是，这波新浪潮将有着深远影响！
“百模大战”：内卷已然来袭 近段时间，国内有关AI大模型的重磅消息接踵而至。
比如在8月31日，有11家国产大模型陆续通过《生成式人工智能服务管理暂行办法》备案，并陆续向全社会公众开放服务。简单来说，之前多款大模型主要是在进行内测，而现在通过备案后，无论是企业还是个人都可以放心使用。
这11家国产大模型都是目前国内的翘楚，包括百度的文心一言、抖音的云雀大模型、中科院的紫东太初、商汤科技的商量SenseChat、华为的盘古大模型、腾讯的混元大模型、科大讯飞的星火大模型等。而从目前看，它们基本上都已经开放。
可以说，2023年8月31日在国产大模型发展史上，是一个值得铭记的关键时间节点。因为从这一天开始，属于国产AI大模型的“命运齿轮”真正转动起来了！
此外，第二批备案的大模型也在加速推进中。9月1日，国家互联网信息办公室发布了《关于第二批深度合成服务算法备案的信息公告》。该公告显示，第二批深度合成服务共计110个算法信息完成备案。
国产大模型的开放，有着重要意义。百度创始人李彦宏曾提到，当文心一言向数以亿计的互联网用户大规模开放服务后，就能够获得大量真实世界中的人工反馈，这将进一步改进基础模型，并以更快速度迭代。对于其他国产大模型来说，开放自然也有着同样的功效。
面向未来，随着国产大模型的开放，“百模大战”将更为激烈。要知道的是，现在虽然国产大模型领域看起来AI大模型数量众多，但都尚未真正经受市场规则的洗礼，仍处于跑马圈地、格局还未完全形成的阶段，这也意味着一切都有可能。
从数据层面看，从去年至今，国内已经发生了接近100起以上的大模型行业的融资案例。从整个产业的投入估值来说，2023年这个行业新增投入大概在150亿元到200亿元。而从长远来看，海量投入是非常值得的。据大模型之家的测算，预计到2023年，全球大模型市场规模将达到210亿美元，到2028年，其规模将达到1095亿美元。
面对充满光明的未来，入局AI大模型的玩家在尘埃落定前，肯定会全情投入其中，试图从红海中杀出，成为最后的胜利者。这也能够看出，内卷是不可避免的，甚至已然来临！
盘古智库高级研究员江瀚对于国产大模型领域眼下的竞争局面，给出了自己的见解。在他看来，多家大模型通过备案代表了市场在合规的同时也保留了充分的竞争。国产大模型领域的多元化属性依然非常明显，这是符合当前市场发展初级阶段的一个状况。
国产大模型，百花齐放。通用大模型、行业大模型、垂直大模型……各大科技、互联网企业纷纷选择最擅长的模型类型起跑，竞争就此变得激烈。而这样的竞争、内卷，对于行业、大众等来说，显然都是有所裨益的。
即使未来随着洗牌期的到来，也不可能出现一家AI大模型一统天下的局面，还是会呈现群雄逐鹿的态势。只是有的AI大模型会聚焦在细分市场，追求“小而美”。
AI+提速，引爆应用新浪潮 必须要知道的是，AI大模型是生成式AI的核心。而种类多样且性能各异的AI大模型，能够激发生成式AI的潜力，让广阔的应用生态随之而至。
如果说AI大模型是一个基础设施，那么在它之上可以孵化更多专业领域的垂直模型，为各行各业的数字化转型服务。而随着国产大模型的全面成熟和开放，也为公众带来更多选择和可能。企业和大众可以尝试通过生成式AI，来探索新的应用场景，来对企业发展、日常生活和工作带来革新和机遇。
对此，百度集团副总裁、深度学习技术及应用国家工程研究中心副主任吴甜也表示，“AI大模型百花齐放的现象表明了一个趋势，即生成式AI在未来可能会对产业结构以及社会带来深刻的影响。现在只是刚刚拉开帷幕，AI对产业的渗透正在加深。”毋庸置疑的是，生成式AI将推动全球生产力革新与商业模式重塑。
直观体现是，AI+在提速，融入各个细分赛道中。尤其是AI+办公软件、AI+创意工具、AI+企业服务、AI+网络安全、AI+金融以及医疗、教育等，正在成为重点的新兴成长赛道。
以AI+医疗为例，根据市场研究咨询公司MarketsandMarkets预测，到2025年，全球医疗大模型市场规模将达到38亿美元，而到2030年，这一数字将超过100亿美元。商汤科技、科大讯飞、京东、百度、腾讯等巨头，万达信息、微脉、叮当健康等互联网科技公司，都高度关注AI+医疗，并有着大动作。
比如，商汤科技发布了升级版“SenseCare智慧医院”综合解决方案，打造了医疗大模型应用新范式。腾讯健康则在9月8日公布医疗大模型,全新发布智能问答、家庭医生助手、数智医疗影像平台等多场景AI产品矩阵。百度也在9月19日，正式发布国内首个“产业级”医疗大模型——灵医大模型，并宣布面向大健康上下游产业开放。
面向AI+办公，则有不少企业入局。如，在9月5日，金山办公官方宣布WPSAI正式面向社会开放，AI能力将率先应用在WPS智能文档中，更多WPS AI能力将在其他组件中开放。科大讯飞甚至在旗下的智能办公本等产品上以星火大模型赋能，展现出AI提升工作效率的魅力。
至于AI+教育，也是生成式AI扮演重要角色的阵地。比如相对于其他聚焦教育C端的同侪，百度另辟蹊径。就在9月15日，百度营销重磅发布首个AIGC教育行业营销解决方案，包括“轻舸”“擎舵”“商家bot”三大营销工具和“课效通”“教育商机宝”两大创新产品，旨在为教育行业广告营销全链路提质增效。
当然，生成式AI实际上已经在千行百业成功落地，成为行业革新的催化剂。整体来看，生成式AI应用按应用领域可以分为：工具、通用软件、行业软件、智能硬件四大类。
其中，工具主要包括聊天机器人、搜索引擎、文本工具、Al作画以及代码工具等，应用领域主要集中在C端，同质化程度较高，对底层模型的能力存在高度依赖。通用软件则主要涵盖办公软件、企业服务、IT运维、软件开发、网络安全、数据智能等，各个赛道上均已出现标杆产品，大多数是智能助理的形态，即将迈入商业化落地的关键阶段。
行业软件则涉及金融、医疗、教育、工业、游戏、法律等多个行业，且行业间差异化程度较大，未来对行业数据价值的充分挖掘是竞争关键。智能硬件包括汽车、机器人、智能终端等，当前的瓶颈在于感知层与决策层，仍需进一步突破。
在国产大模型愈发展现出巨大潜力时，2023年注定是生成式AI在应用层面的突破之年。生成式AI为许多行业带来的可能性，充满无限想象。不断演变、进化的生成式AI，将通过持续创新让千行百业焕发新生机，实现蓬勃发展。
后记 我对于“百模大战”的全过程感到非常兴奋和激动。从开始的预热到最后的打响，这场战役确实彻底引爆了AI大模型的应用新浪潮。
在这场战争中，各家企业纷纷投入了大量资源和精力，竞相展示自己的AI大模型的能力和潜力。他们通过推出各种创新的应用场景，向我们展示了AI大模型的广泛适用性和强大的性能。不论是自然语言处理、计算机视觉还是智能推荐等领域，AI大模型都带来了革命性的进展。
在这个过程中，我们看到了AI大模型不仅能够更准确地理解和生成自然语言，还能够更好地识别和理解图片和视频。它们还能够通过学习用户的兴趣和偏好，为用户提供更加个性化的推荐服务。这些都为我们的生活和工作带来了巨大的便利和效益。
然而，这场战争也让我们看到了AI大模型的一些挑战和问题。首先是AI大模型消耗大量的计算资源和能源，在训练和推理过程中需要庞大的算力支持。其次是AI大模型需要大量的数据进行训练，但是数据的获取和处理也面临着一些法律和隐私的限制。此外，AI大模型在处理一些复杂和具有挑战性的任务时，仍然存在一定的误判和错误。
总的来说，这场“百模大战”让我们看到了AI大模型的巨大潜力，并且在推动AI技术的发展和应用方面起到了积极的推动作用。虽然还有一些问题需要解决，但是相信随着技术的不断进步和完善，AI大模型将会在各个领域展现出更加广阔的应用前景。
转载自：https://blog.csdn.net/u014727709/article/details/134986211
欢迎 👍点赞✍评论⭐收藏，欢迎指正
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c04abeeb123cb57538b6f73438ec6b18/" rel="bookmark">
			CSS属性的计算过程和层叠规则总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨ 专栏介绍 HTML/CSS专栏合集是一个涵盖HTML和CSS两个方面的栏目。HTML是一种标记语言，用于创建网页的结构和内容，而CSS是一种样式表语言，用于控制网页的外观和布局。
在HTML/CSS专栏合集中，我们将深入探讨HTML和CSS的基础知识和高级技术。我们将介绍HTML的标签、元素和属性，以及如何使用它们来构建网页结构。同时，我们还将讨论CSS的选择器、属性和样式规则，以及如何使用它们来美化网页并实现各种布局效果。
通过阅读HTML/CSS专栏合集，您将学习如何创建语义化的HTML结构、优化网页性能、响应式设计、动画效果等。我们还将分享一些实用的技巧和最佳实践，帮助您提高编写高质量HTML/CSS代码的能力。
文章目录 ✨ 专栏介绍CSS属性的计算过程确定声明值层叠冲突使用继承使用默认值 CSS的层叠规则1. 重要性（Importance）2. 专用性（Specificity）3. 源代码次序（Source Order） CSS伪类书写顺序😶 写在结尾 CSS属性的计算过程 总的来讲，属性值的计算方法有下面 4 种，这也是属性值的计算顺序：
确定声明值层叠冲突使用继承使用默认值 确定声明值 在CSS中，可以通过选择器来选择要应用样式的元素，然后通过声明来设置样式。当多个选择器选择同一个元素时，会根据优先级来确定最终的声明值。优先级由高到低分别是：
!important &gt; 行内样式 &gt; ID选择器 &gt; 类选择器/属性选择器/伪类选择器 &gt; 元素选择器/伪元素选择器。
如果优先级相同，则后面的声明会覆盖前面的声明。
举例说明：
&lt;style&gt; p { color: blue; } .highlight { color: red; } &lt;/style&gt; &lt;p class="highlight"&gt;Hello, World!&lt;/p&gt; 在上面的例子中，p元素同时被p选择器和.highlight类选择器选中，但是.highlight类选择器具有更高的优先级，所以最终p元素的颜色为红色。
层叠冲突 当多个样式规则具有相同的优先级时，就会发生层叠冲突。层叠冲突可以通过以下几个因素来解决：重要性、特殊性和源代码顺序。
重要性：可以使用!important声明来提高样式规则的优先级。具有!important声明的样式规则将覆盖其他具有相同优先级的样式规则。
特殊性：特殊性是根据选择器的组合来计算的。选择器中包含的ID选择器的数量越多，特殊性越高。特殊性相同的情况下，后面出现的样式规则将覆盖前面出现的样式规则。
源代码顺序：如果两个样式规则具有相同的优先级和特殊性，则后面出现的样式规则将覆盖前面出现的样式规则。
举例说明：
&lt;style&gt; p { color: blue; } p { color: red; } &lt;/style&gt; &lt;p&gt;Hello, World!&lt;/p&gt; 在上面的例子中，两个p选择器具有相同的优先级和特殊性，但是后面出现的样式规则会覆盖前面出现的样式规则，所以最终p元素的颜色为红色。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c04abeeb123cb57538b6f73438ec6b18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e3b178316c8c500ca4ef838be62906e/" rel="bookmark">
			六年Android开发面试竟被Framework 知识点难到？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有位在阿里担任P7级别Android研发的工程师跳槽至腾讯面试，原以为凭借自己十年的开发经验能够顺利通过，却没想到在面试中遭遇了滑铁卢。经过沟通了解，问题主要出在他对Framework知识的掌握不够深入。
Framework知识在Android开发中具有极其重要的地位。如今热门的Android技术，如热修复、插件化等，都需要深入理解Activity启动流程和与AMS（Activity Manager Service）的交互机制。此外，对于性能优化、兼容性问题解决以及系统更新带来的挑战，Framework知识也是不可或缺的。
例如，在Handler、MessageQueue和Looper等核心组件的源码中，就隐藏着许多关于Android运行机制的秘密。理解这些底层原理，有助于更好地排查卡顿问题，优化应用性能。
此外，对于Android的卡顿掉帧问题，仅仅知道主线程耗时是原因之一是远远不够的。实际上，RenderThread耗时、Binder通信耗时等其他因素也可能导致卡顿。真正掌握了卡顿的原理，在面对问题时才能更加从容不迫。
现在的面试难度越来越大，无论是大厂还是中小公司，对于底层原理的掌握要求都非常高。尤其是与Framework层相关的知识，更是面试中的重点。对于想要在Android开发领域有所建树的小伙伴们来说，深入掌握Framework知识已经成为了必备技能。
像下面这些面试题就全是高频问题，来看看自己能不能全答上来：
什么是Handler？它在Android中有什么作用？Handler的工作原理是什么？它如何与MessageQueue和Looper相关联？如何在Handler中发送和接收消息/Runnable？什么是Message、Runnable和Callback？它们之间有什么区别？Handler有几种类型？各自的使用场景是什么？HandlerThread是什么？它与普通线程有什么区别？如何使用Handler进行异步通信和处理任务？Handler有哪些常用的方法？它们的作用是什么？如何使用Handler来更新UI？在Handler中如何处理内存泄漏问题？ 既然知道经常会碰到这些问题，那么我们该怎么答才可以获得面试官的青睐呢？
为了帮助大家更快更好的掌握其中原理，面试畅通无阻，这里特意问到一份阿里内部的《Android Framework源码开发揭秘》
由于文档内容过多，因此为了避免影响到大家的阅读体验，在此只以截图展示部分内容，详细完整版的看文末有免费的获取方式！（文末还有使用ChatGPT机器人小福利哦！！大家不要错过）
《Android Framework源码开发揭秘》 本学习手册深入剖析了Android系统源代码，详细讲解了Android框架初始化过程及主要组件的工作原理,旨在通过实例和案例介绍 Android Framework 的核心概念和技术，从而帮助开发者更好地理解 Android 应用程序的设计和开发。 该手册适合具有一定 Android 应用开发经验的程序员，希望能通过深入学习 Android Framework 来帮助开发者更好地理解和掌握这一技术。
第一章 系统启动流程分析 Android系统完整的启动过程，从系统层次角度可分为 Linux 系统层、Android 系统服务层、Zygote进程模型三个阶段； 知识要点：
第一节 Android启动概括、
第二节 init.rc解析、
第三节 Zygote、
第四节 面试题
第二章 跨进程通信IPC解析 Binder作为Android进程间通信的机制，可以看做是一个驱动。在Android中，常见的进程间通信例如系统类的：打电话、闹钟等；自己创建的：像WebView、视频播放、音频播放、大图浏览等。
第三章 Handler源码解析 第一节 源码分析
第二节 难点问题
第三节Handler常问面试题
搭建了一个基于chatGPT的微信群聊机器人，24小时为大家解答疑难技术问题， 需要的可以扫描二维码进群。
|
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9efff70d7b8dd7d1078795178c848464/" rel="bookmark">
			鸿蒙原生应用/元服务开发-Stage模型能力接口（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@ohos.app.ability.AbilityConstant (AbilityConstant)
一、说明
AbilityConstant提供Ability相关的枚举，包括设置初次启动原因、上次退出原因、迁移结果、窗口类型等。本模块首批接口从API version 9开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。本模块接口仅可在Stage模型下使用。
二、导入模块
import AbilityConstant from ‘@ohos.app.ability.AbilityConstant’;
三、属性
1.AbilityConstant.LaunchParam
启动参数。
系统能力：以下各项对应的系统能力均为SystemCapability.Ability.AbilityRuntime.Core
2.AbilityConstant.LaunchReason
Ability初次启动原因，该类型为枚举，可配合Ability的onCreate(want, launchParam)方法根据launchParam.launchReason的不同类型执行相应操作。
系统能力：以下各项对应的系统能力均为SystemCapability.Ability.AbilityRuntime.Core
示例：
import UIAbility from ‘@ohos.app.ability.UIAbility’; class MyAbility extends UIAbility { onCreate(want, launchParam) { if (launchParam.launchReason === AbilityConstant.LaunchReason.START_ABILITY) { console.log(‘The ability has been started by the way of startAbility.’); } } } 3.AbilityConstant.LastExitReason
Ability上次退出原因，该类型为枚举，可配合Ability的onCreate(want, launchParam)方法根据launchParam.lastExitReason的不同类型执行相应操作。
系统能力：以下各项对应的系统能力均为SystemCapability.Ability.AbilityRuntime.Core
示例：
import UIAbility from ‘@ohos.app.ability.UIAbility’; class MyAbility extends UIAbility { onCreate(want, launchParam) { if (launchParam.lastExitReason === AbilityConstant.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9efff70d7b8dd7d1078795178c848464/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79afa33c879948d8d45e609d2d1e7500/" rel="bookmark">
			性能优化：Spark SQL中的谓词下推和列式存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Spark是一个强大的分布式计算框架，Spark SQL是其一个核心模块，用于处理结构化数据。性能优化是大数据处理中的一个关键问题，本文将深入探讨Spark SQL中的两个性能优化技术：谓词下推（Predicate Pushdown）和列式存储（Columnar Storage），以提高查询性能和降低资源消耗。
谓词下推（Predicate Pushdown） 谓词下推是一种优化技术，它可以将过滤条件推送到数据源引擎，以减少数据传输和计算开销。在Spark SQL中，谓词下推是通过将过滤条件应用于数据源的数据文件，以减少需要加载到内存中的数据量来实现的。这可以显著提高查询性能，尤其是当处理大量数据时。
示例：谓词下推 假设有一个包含销售订单的表，其中包括订单号、销售日期和销售额。希望查询某个日期范围内的销售订单。
# 创建DataFrame orders_df = spark.read.parquet("orders.parquet") # 定义过滤条件 start_date = "2023-01-01" end_date = "2023-12-31" # 应用谓词下推 filtered_orders = orders_df.filter((orders_df["sale_date"] &gt;= start_date) &amp; (orders_df["sale_date"] &lt;= end_date)) # 执行查询 filtered_orders.show() 在上面的示例中，谓词下推将过滤条件(orders_df["sale_date"] &gt;= start_date) &amp; (orders_df["sale_date"] &lt;= end_date)应用于数据文件，只加载满足条件的数据，从而减少了不必要的数据传输和计算。
列式存储（Columnar Storage） 列式存储是一种数据存储格式，它将数据按列存储，而不是按行存储。这种存储方式具有许多优点，包括更高的压缩率、更快的查询性能和更少的I/O开销。在Spark SQL中，列式存储通常与Parquet格式一起使用，Parquet是一种列式存储的开放性文件格式。
示例：使用列式存储 假设有一个包含用户数据的表，其中包括用户ID、姓名、年龄和地址。将数据保存为Parquet格式，以利用列式存储的性能优势。
# 创建DataFrame users_df = spark.createDataFrame([(1, "Alice", 30, "123 Main St"), (2, "Bob", 25, "456 Elm St")], ["id", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79afa33c879948d8d45e609d2d1e7500/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b897facf816ccd775597ce318c92d9d/" rel="bookmark">
			使用UDF扩展Spark SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Spark是一个强大的分布式计算框架，Spark SQL是其一个核心模块，用于处理结构化数据。虽然Spark SQL内置了许多强大的函数和操作，但有时可能需要自定义函数来处理特定的数据需求。在Spark SQL中，可以使用UDF（User-Defined Functions）来自定义函数，以扩展Spark SQL的功能。本文将深入探讨如何使用UDF扩展Spark SQL，包括UDF的定义、注册、使用以及一些实际用例。
UDF简介 UDF是一种用户自定义的函数，可以在Spark SQL查询中使用自定义的计算逻辑。UDF可以用于扩展Spark SQL的功能，使其能够执行自定义操作，无论是数据清洗、数据转换还是其他复杂的计算。UDF通常由用户编写的代码组成，并且可以在SQL查询中像内置函数一样使用。
定义UDF 在使用UDF之前，首先需要定义UDF。在Spark中，可以使用Scala、Java或Python来编写UDF。下面是一个使用Python定义UDF的示例。
示例：定义一个简单的UDF 假设有一个包含员工姓名的表，并且希望将所有的名字转换为大写。可以编写一个简单的Python函数来实现这个功能，并将其定义为UDF。
from pyspark.sql.functions import udf from pyspark.sql.types import StringType # 定义UDF函数 def upper_case(name): return name.upper() # 注册UDF upper_case_udf = udf(upper_case, StringType()) 在上面的示例中，首先定义了一个名为upper_case的Python函数，它接受一个字符串参数并返回大写的字符串。然后，使用udf函数将其注册为UDF，并指定返回的数据类型为字符串类型。
注册UDF 一旦UDF函数被定义，需要将其注册到Spark SQL的会话中，以便在查询中使用。下面是如何注册UDF的示例。
示例：注册UDF函数 # 注册UDF函数 spark.udf.register("upper_case_udf", upper_case, StringType()) 在上面的示例中，使用register方法将upper_case_udf函数注册到Spark SQL的会话中。现在，可以在SQL查询中使用它。
使用UDF 一旦UDF函数被注册，可以在Spark SQL查询中使用它。下面是如何在查询中使用UDF的示例。
示例：使用UDF函数 # 使用UDF函数进行查询 result = spark.sql("SELECT name, upper_case_udf(name) AS upper_name FROM employees") result.show() 在上面的示例中，在查询中调用了upper_case_udf函数，将name列的值转换为大写，并将结果列命名为upper_name。
UDF的实际用例 看一些实际的用例，演示如何使用UDF来解决复杂的数据处理问题。
1 数据清洗 假设有一个包含电话号码的表，电话号码的格式不统一，包括带有国家代码、空格、破折号等不同的格式。可以编写一个UDF来清洗这些电话号码，使其统一为一种格式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b897facf816ccd775597ce318c92d9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c71729da81703f3fd15a5b109a81ef6/" rel="bookmark">
			十五：爬虫-Scrapy-redis分布式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：python操作redis 1.redis的安装与连接 安装 pip install redis 连接 r = redis.StrictRedis(host='localhost',port=6379,db=0) 2.redis数据类型相关操作 （1）字符串相关操作 import redis class TestString(object): # 初始化 连接redis数据库 def __init__(self): self.r = redis.StrictRedis(host='127.0.0.1', port=6379) # 设置值 def test_set(self): res = self.r.set('user1', 'yueyue-1') print(res) # 取值 def test_get(self): res = self.r.get('user1') print(res,type(res)) res = res.decode('UTF-8') print(res, type(res)) # 设置多个值 def test_mset(self): d = { 'user2': 'yueyue-2', 'user3': 'yueyue-3' } res = self.r.mset(d) print(res) # 取多个值 def test_mget(self): l = ['user2', 'user3'] res = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c71729da81703f3fd15a5b109a81ef6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6c59c142ae9ac72d52a80e15f94a430/" rel="bookmark">
			并发编程(高并发、多线程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		并发编程 1.并发编程1.1 Java程序中怎么保证多线程的运行安全？（难度：★★ 频率：★★★★★）1.1.1 并发编程三要素1.1.2 原子性、可见性、有序性问题的解决方法 1.2 Synchronized（难度：★★ 频率：★★★）1.2.1 synchronized的三种加锁方法1.2.2 提高synchronized的并发性能 1.3 volatile（难度：★★ 频率：★★★★）1.3.1 保证可见性1.3.2 禁止指令重排序1.3.3 不保证原子性 1.4 volatile和synchronized的区别（难度：★★ 频率：★★）1.5 死锁（难度：★★ 频率：★★★★★）1.5.1 形成死锁的四个必要条件是什么1.5.2 如何避免线程死锁 2.线程2.1 创建线程的几种方式（难度：★ 频率：★★★★★）2.2 runnable和callable的区别（难度：★ 频率：★★★）2.3 为什么是调用start(), 而不调用run()（难度：★ 频率：★★★★★）2.4 Future（难度：★★ 频率：★★）2.4.1 Future的常用方法2.4.2 Future的局限性2.4.3 FutureTask 2.5 CompletableFuture（难度：★★ 频率：★★★）2.5.1 异步执行2.5.2 获取异步执行结果2.5.3 任务结束后执行方法2.5.4 处理异步任务结果2.5.4.1 转换结果2.5.4.2 消费结果 2.5.5 两个结果组合2.5.6 任务竞速2.5.7 处理异常2.5.8 全部结束、任意一个结束2.5.9 异步线程阻塞主线程的情况 2.6 CompletionService（难度：★★ 频率：★★）2.7 线程的生命周期（难度：★★ 频率：★★★）2.8 sleep() 和 wait() 有什么区别?（难度：★ 频率：★★★★） 1.并发编程 1.1 Java程序中怎么保证多线程的运行安全？（难度：★★ 频率：★★★★★） 1.1.1 并发编程三要素 首先我们要了解并发编程的三要素
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6c59c142ae9ac72d52a80e15f94a430/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34b22ce8f7af36e9604a32c51b05562a/" rel="bookmark">
			【零基础入门TypeScript】TypeScript - 基本语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
你的第一个 TypeScript 代码
编译并执行 TypeScript 程序
编译器标志
TypeScript 中的标识符
TypeScript ─ 关键字
空格和换行符
TypeScript 区分大小写
分号是可选的
TypeScript 中的注释
TypeScript 和面向对象
语法定义了一组编写程序的规则。每种语言规范都定义了自己的语法。TypeScript 程序由以下部分组成：
ModulesFunctionsVariablesStatements and ExpressionsComments 你的第一个 TypeScript 代码 让我们从传统的“Hello World”示例开始 -
var message:string = "Hello World" console.log(message) 编译时，它将生成以下 JavaScript 代码。
//Generated by typescript 1.8.10 var message = "Hello World"; console.log(message); 第 1 行通过名称 message 声明一个变量。变量是程序中存储值的一种机制。
第 2 行将变量的值打印到提示符处。这里，控制台指的是终端窗口。函数log()用于在屏幕上显示文本。
编译并执行 TypeScript 程序 让我们看看如何使用 Visual Studio Code 编译和执行 TypeScript 程序。请按照以下步骤操作 -
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34b22ce8f7af36e9604a32c51b05562a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5d961a106ae2beb6f145ef9d7d56eb1/" rel="bookmark">
			【零基础入门TypeScript】类型和变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
任意类型
内置类型
Null 和 undefined ─ 它们是一样的吗？
用户定义类型
TypeScript 中的变量声明
示例：TypeScript 中的变量
TypeScript 中的类型断言
例子
TypeScript 中的推断类型
示例：推断类型
TypeScript 变量作用域
示例：变量范围
类型系统表示该语言支持的不同类型的值。在程序存储或操作所提供的值之前，类型系统会检查它们的有效性。这确保了代码的行为符合预期。类型系统还允许更丰富的代码提示和自动化文档。
TypeScript 提供数据类型作为其可选类型系统的一部分。数据类型分类如下 -
任意类型 Any数据类型是 TypeScript 中所有类型的超类型。它表示动态类型。使用any类型相当于选择不进行变量的类型检查。
内置类型 下表说明了 TypeScript 中的所有内置类型 -
Data typeKeywordDescriptionNumbernumberDouble precision 64-bit floating point values. It can be used to represent both, integers and fractions.StringstringRepresents a sequence of Unicode charactersBooleanbooleanRepresents logical values, true and falseVoidvoidUsed on function return types to represent non-returning functionsNullnullRepresents an intentional absence of an object value.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5d961a106ae2beb6f145ef9d7d56eb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fb77d78fa2ebca416a22c681070b171/" rel="bookmark">
			Redis的集群模式：主从 &amp; 哨兵 &amp; 分片集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Redis集群解决单机Redis存在的问题，在之前学Redis一直都是单节点部署 单机或单节点Redis存在的四大问题： 数据丢失问题：Redis是内存存储，服务重启可能会丢失数据 =&gt; 利用Redis数据持久化的功能将数据写入磁盘并发能力问题：单节点Redis并发能力虽然不错，但也无法满足如618这样的高并发场景 =&gt; 搭建一主多从集群，实现读写分离单点故障 - 故障恢复问题：如果Redis宕机，则服务不可用，需要一种自动的故障恢复手段 =&gt; 利用Redis哨兵，实现健康检测和自动故障恢复存储能力问题：Redis基于内存存储，单节点能存储的数据量难以满足海量数据要求 =&gt; 搭建分片集群，利用插槽机制实现动态扩容，从理论上来讲，它的存储能力是没有上限的 介绍一下Redis的集群模式？ Redis有三种主要的集群模式，用于在分布式环境中实现高可用性和数据复制，这些集群模式分别是：主从复制（Master-Slave Replication）、哨兵模式（Sentinel）和Redis Cluster模式。 1. Redis主从 搭建主从架构主从数据同步原理 单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。
主从模式简介 主从复制是Redis最简单的集群模式，这个模式主要是为了解决单点故障的问题，所以将数据复制到多个副本中，这样即使有一台服务器出现故障，其它服务器依然可以继续提供服务。主从模式中，包括一个主节点（Master）和一个或多个从节点（Slave），主节点负责处理所有写操作和读操作，而从节点则复制主节点的数据，并且只能处理读操作，当主节点发送故障时，可以将一个从节点升级为主节点，实现故障转移（需要手动实现）。 1.1.主从集群结构 Redis的集群往往都是主从集群，它往往会有一个Master主节点，多个Slave / Replica从节点。 下图就是一个简单的Redis主从集群结构：
如图所示，集群中有一个Master主节点、两个Slave从节点（现在叫Replica） =&gt; 起码要包含三个节点，要有三个Redis实例，一主两从。
在Redis 5.0以前，从节点是叫Slave的，后来改名叫Replica =&gt; 都是代表从节点 当我们通过Redis的Java客户端访问主从集群时，应该做好路由：
如果是写操作，应该访问Master主节点，Master主节点会自动将数据同步给两个Slave从节点
如果是读操作，建议访问各个Slave从节点，从而分担并发压力
Master主节点可以执行set命令（写操作），Replica从节点只能执行get命令（读操作） 。
为什么Redis要做成这种主从的集群，而不是传统的负载均衡集群呢？ 这是因为Redis应用当中大多数都是读多写少的场景，也就是查询比较多，而增删改比较少，既然如此，我们更多要应对的是读的压力，那我做了主从以后，我们还可以去做读写分离， 也就是说，我在执行写操作时，我让它去访问Master主节点，但如果执行的是读操作，那我就把你的请求分发到各个Slave或Replica从节点，这样我们一主多从，多个从节点共同承担读的请求，我们的读并发能力就可以得到一个比较大的提升，所以这就是为什么要搭建主从集群的一个原因了。但是做主从集群，必须保证一点，就是客户端在读取的时候，不管访问到哪个Slave从节点，都必须要保证拿到相同的结果 =&gt; 如何保证？ 需要让Master主节点把它上面的数据同步给每一个Slave从节点，这就是Redis主从架构的一个基本模式了 1.2 搭建主从集群 1. 准备实例和配置 我们会在同一台虚拟机中开启3个Redis实例，模拟主从集群。 我们会在同一个虚拟机中利用3个Docker容器来搭建主从集群。
要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。
在同一个机器下还要修改每个实例的端口
2. 启动 &amp; 开启主从关系
分别启动多个Redis实例，虽然我们启动了3个Redis实例，但是它们并没有形成主从关系，我们需要通过命令来配置主从关系：
# Redis5.0以前 slaveof &lt;masterip&gt; &lt;masterport&gt; # Redis5.0以后 replicaof &lt;masterip&gt; &lt;masterport&gt; 有临时和永久两种模式： 永久生效：在redis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fb77d78fa2ebca416a22c681070b171/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51cb60f605f4b51e7f3f1b2dc94cb993/" rel="bookmark">
			MINCO&#43;汽车
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 对于环境中的静态障碍物，我们构造几何自由空间来约束自我车辆的完整模型以保证安全。
对于动态障碍物，我们使用凸多边形来覆盖其形状。
然后，我们约束小车与障碍物多边形在每一时刻的符号距离[1]的下界近似，以保证小车的安全。
最小控制努力轨迹类[2]用于参数化轨迹以加快优化过程。
进一步，将原约束规划问题转化为无约束规划问题，并采用拟牛顿方法[3]进行鲁棒求解。
第三节介绍了自动驾驶汽车的时空轨迹规划。
瞬时状态约束和动态避障约束分别在第四节和第五节讨论。
在第六节中，我们重新表述了轨迹优化。
VII给出了基准和真实世界的实验。本文在第八节结束。
讨论了完整的运动规划流水线，并介绍了类车机器人的差分平面模型。然后，我们给出了平面输出空间中考虑人的舒适性、执行时间和可行性约束的轨迹优化问题的表达式。
最后分析了该问题的梯度传播链，为后续的数值优化提供了依据。
时空最优轨迹规划 A.规划管线 整个管道采用分层结构，如图3所示。在实际应用中，建议的规划器与前端规划器合作，前端规划器的主要作用是提供初始猜测。在结构化的道路环境中，我们的规划师被整合到一个多层的规划框架中[19]，其中行为策略规划器用于提供前端输出。在没有参考线的非结构化环境中，我们采用轻量级hybridA*算法寻找无碰撞路径，并由所提出的规划器进一步优化。我们定义了一个额外的变量η∈{−1,1}来表征运动方向，η =−1和η = 1分别表示车辆的前后运动。此外,η由前端输出决定，并在后端优化过程之前加上前缀。
B.差分平面车辆模型 本文采用了简化的自行车运动模型
用笛卡尔坐标系来描述四轮车辆。
假设汽车为前轮驱动和转向，具有完美的滚动和无打滑，模型如图4所示。状态向量为
其中为后轮中心位置，v为车身框架的纵向速度，at为经度加速度，an为纬度加速度，φ为前轮转向角度，κ为曲率。
其中L是汽车的轴距长度，CoG是重心的缩写。由于对差分平面汽车模型的深入研究[51]，我们选择平面输出为具有物理意义，σ = p是汽车后轮中心的位置。除px、py外，其他变量变换可表示为:
因此，利用自然的微分平坦性，我们可以利用平坦输出及其有限导数来表征车辆的任意状态量，从而简化了轨迹规划，便于优化。
C.整车平坦输出优化方案 其中n为轨迹段的数目，β(t)为自然基。系数矩阵
然后，轨迹第i段的第j段可写为 ,
考虑避障约束和动态可行性约束，涉及时间正则化的最小控制努力问题可以表示为非线性约束优化:
是一个惩罚控制的对角线矩阵。
等式（6c）为边界条件
特定的约束条件等式(6d)
D = {d： d = v，at，an，κ，ζ，Θ}包括动态可行性（v，at，an，κ）、静态和动态避障（ζ，Θ）
可行性约束条件等式（6g）施加在整个轨迹
D.梯度推导 瞬时状态约束 A.动态可行性 经度速度限制：对于自动驾驶，由于交通规则、物理车辆性能和环境不确定性等实际因素，经度速度总是需要限制在一个合理的范围内。然后，将在一个约束点处的经度速度的约束函数定义如下
B. 避免静态障碍 在本小节中，我们分析地提出了基于环境中自由空间的几何表示的有效可计算的静态安全约束。首先对语义环境进行分解，提取安全空间，构造一个由一系列凸多边形组成的驾驶走廊。然后，推导了在行驶走廊中建立全车模型的充分必要条件，并用于构造静态无碰撞约束
在进行特定的推导之前，我们将介绍约束建模的管道。我们首先将前端生成的无碰撞路径离散为与后端优化中约束点数量相同的采样点。然后，结合环境信息，利用[60]方法或根据采样点直接展开生成自由凸多边形。因此，通过将全车辆模型限制在8个约束点，每个约束点限制到相应的凸多边形，保证了整个轨迹是安全的.
还可以与其他常见的地图表示相结合，以保证静态避障，如欧几里得符号距离场（ESDF）。直观地说，我们可以从ESDF地图中获得梯度信息，以推动车辆的整个刚体远离障碍物
动态避障 动态回避约束函数的动态回避约束函数。
A.距离表示 B. 对动态避障的约束 重新对轨迹的优化的设计 A. 可行性限制 B.平等约束 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b74bd1b75f0efd17c9122e4826d91d/" rel="bookmark">
			基于多反应堆的高并发服务器【C/C&#43;&#43;/Reactor】（中）处理任务队列中的任务 添加 删除 修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）EventLoop启动 EventLoop初始化和启动
// 启动反应堆模型 int eventLoopRun(struct EventLoop* evLoop) { assert(evLoop != NULL); // 取出事件分发和检测模型 struct Dispatcher* dispatcher = evLoop-&gt;dispatcher; // 比较线程ID是否正常 if(evLoop-&gt;threadID != pthread_self()) { return -1; } // 循环进行事件处理 while(!evLoop-&gt;isQuit) { dispatcher-&gt;dispatch(evLoop,2); // 超时时长 2s // 已续写 eventLoopProcessTask(evLoop); } return 0; } 多加一句eventLoopProcessTask(evLoop); 理由在后文提到！
（2）添加任务到任务队列中（在EventLoop的任务队列中添加新任务）
// 添加任务到任务队列 int eventLoopAddTask(struct EventLoop* evLoop,struct Channel* channel,int type) { // 加锁，保护共享资源 pthread_mutex_lock(&amp;evLoop-&gt;mutex); // 创建新节点,后添加到任务队列中去 struct ChannelElement* node = (struct ChannelElement*)malloc(sizeof(struct ChannelElement)); node-&gt;channel = channel; node-&gt;type = type; node-&gt;next = NULL; // 链表为空 if(evLoop-&gt;head == NULL) { evLoop-&gt;head = evLoop-&gt;tail = node; }else { evLoop-&gt;tail-&gt;next = node; // 添加 evLoop-&gt;tail = node; // 后移 } pthread_mutex_unlock(&amp;evLoop-&gt;mutex); if(evLoop-&gt;threadID == pthread_self()) { // 当前子线程 eventLoopProcessTask(evLoop); }else{ // 主线程 -- 告诉子线程处理任务队列中的任务 // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25b74bd1b75f0efd17c9122e4826d91d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/748346c0695db4f70c5f9117e318db00/" rel="bookmark">
			React16源码: memo, Fragment, StrictMode, cloneElement, createFactory源码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		memo 1 ） 概述
memo 在react 16.6 推出的一个API它的用意是让 function component，有一个类似 PureComponent 的一个功能 PureComponent 提供了 class component 组件类型在props没有变化的情况下，它可以不重新渲染 目的是给 function component 做一个 PureComponent 的对标这个用法很简单，就不进行举例了 2 ) 源码解析
// memo.js /** * Copyright (c) Facebook, Inc. and its affiliates. * * This source code is licensed under the MIT license found in the * LICENSE file in the root directory of this source tree. */ import {REACT_MEMO_TYPE} from 'shared/ReactSymbols'; import isValidElementType from 'shared/isValidElementType'; import warningWithoutStack from 'shared/warningWithoutStack'; export default function memo&lt;Props&gt;( type: React$ElementType, compare?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/748346c0695db4f70c5f9117e318db00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6b23edac0359eaebcf5f31ae81df2b7/" rel="bookmark">
			CSS-6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		响应式网页 如何实现响应式网页？ 解决方案： 方法1. 通过媒体查询的方法 @media (条件) { html { background-color: green; } } 方法2. 使用 Bootstrap 框架 方法一 基本使用 &lt;style&gt; /* 屏幕宽度小于等于768，网页背景色是粉色 --- 小于等于 &lt;==&gt; max-width */ @media (max-width: 768px) { body { background-color: pink; } } /* 屏幕宽度大于等于1200，网页背景色是绿色 --- 大于等于 &lt;==&gt; min-width */ @media (min-width: 1200px) { body { background-color: green; } } &lt;/style&gt; 以上是媒体查询的基本使用 书写顺序 &lt;style&gt; /* 网页默认背景色是灰色 */ body { background-color: #ccc; } /* 屏幕宽度 大于等于 768px，网页背景色是粉色 */ @media (min-width: 768px) { body { background-color: pink; } } /* 屏幕宽度 大于等于 992px，网页背景色是绿色 */ @media (min-width: 992px) { body { background-color: green; } } /* 屏幕宽度 大于等于 1200px，网页背景色是skyblue */ @media (min-width: 1200px) { body { background-color: skyblue; } } &lt;/style&gt; 书写顺序： min-width（从小到大） max-width（从大到小） 左侧隐藏案例 &lt;style&gt; * { margin: 0; padding: 0; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6b23edac0359eaebcf5f31ae81df2b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/359e388c95f624e0d948a2fc6e0d68c0/" rel="bookmark">
			vue3 element plus el-table封装（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上文是对el-table的基本封装上增加slot插槽，并且对col插槽进行拓展，本文主要时增加分页组件，同时进行slot传递
//BaseTable.vue没有变
&lt;template&gt; &lt;el-table&gt; &lt;template v-for="name in tableSlots" :key="name" #[name]&gt; &lt;slot :name="name"&gt;&lt;/slot&gt; &lt;/template&gt; &lt;el-table-column v-for="(col, index) in attrs.config" :key="index" v-bind="col" &gt; &lt;template v-if="col.slot" #[getColSlot(col)]="scope"&gt; &lt;slot :name="col.slot" v-bind="scope"&gt;&lt;/slot&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/template&gt; &lt;script lang="ts" setup&gt; const attrs = useAttrs(); const slots = useSlots(); const tableSlots = computed(() =&gt; { // 原生el-table插槽只有default,append,empty // 原生el-table-column插槽只有table插槽只有default,header // 这里将header单独处理，认为是col的插槽，从table插槽中排除 return Object.keys(slots).filter((name) =&gt; name !== "header"); }); const getColSlot = (col) =&gt; { return col.slot === "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/359e388c95f624e0d948a2fc6e0d68c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/541c2f337343dedaacb16604f990bcee/" rel="bookmark">
			Linux vi/vim 教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 【 1. vi/vim 的三种模式 】1.1 命令模式1.2 输入模式1.3 底线命令模式 【 2. 实例 】【 3. vim 的其他命令 】 所有的 Unix Like 系统都会内建 vi 文本编辑器，其他的文本编辑器则不一定会存在。目前我们使用比较多的是 vim 编辑器。vim 从 vi 发展出来，vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。 【 1. vi/vim 的三种模式 】 基本上 vi/vim 共分为三种模式，命令模式（Command Mode）、输入模式（Insert Mode）和命令行模式（Command-Line Mode）。
1.1 命令模式 用户刚刚启动 vi/vim， 默认进入命令模式（也称普通模式）。此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符，比如我们此时按下 i，并不会输入一个字符，i 被当作了一个命令。 命令模式只有一些最基本的命令，因此仍要依靠底线命令行模式输入更多命令。以下是命令模式常用的几个命令： 命令作用i切换到输入模式，在光标当前位置开始输入文本。: （英文冒号）切换到底线命令模式，以在最底一行输入命令。x删除当前光标所在处的字符。a进入插入模式，在光标下一个位置开始输入文本。o在当前行的下方插入一个新行，并进入插入模式。O在当前行的上方插入一个新行，并进入插入模式。dd删除当前行。yy复制当前行。p（小写）粘贴剪贴板内容到光标下方。P（大写）粘贴剪贴板内容到光标上方。u撤销上一次操作。Ctrl + r重做上一次撤销的操作。:w保存文件。:q退出 Vim 编辑器。:q!强制退出Vim 编辑器，不保存修改。 1.2 输入模式 输入模式中，常用操作： 操作作用Esc退出输入模式，切换到命令模式字符按键以及Shift组合输入字符Enter回车键，换行Backspace退格键，删除光标前一个字符Delete删除键，删除光标后一个字符方向键在文本中移动光标HOME/END移动光标到行首/行尾Page Up/Page Down上/下翻页Insert切换光标为输入/替换模式，光标将变成竖线/下划线 1.3 底线命令模式 底线命令模式可用的命令非常多。按 ESC 键可随时退出底线命令模式。在底线命令模式中，常用的命令有（已经省略了冒号）： 命令作用:w保存文件。:q退出 Vim 编辑器。:wq保存文件并退出 Vim 编辑器。:q!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/541c2f337343dedaacb16604f990bcee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ca960b65f90726c97e6245652aa4b59/" rel="bookmark">
			【Linux Shell】1. Shell 简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 【 1. Shell 解释器、Shell语言、Shell脚本 】【 2. Shell 环境 】【 3. 一个简单的 Shell 脚本 】3.1 Shell 脚本的编写3.2 Shell 脚本的运行3.2.1 作为可执行程序运行 Shell 脚本3.2.2 作为解释器参数运行 Shell 脚本 【 1. Shell 解释器、Shell语言、Shell脚本 】 Shell 原本是一个应用程序，即 命令行解释器（如下所示），它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用 shell 来启动、挂起、停止甚至是编写一些程序。在 Shell 中可以直接调用Linux系统命令。
Shell 脚本是利用利用 Shell 的功能所写的一个程序 ，这个程序是使用纯文本文件，将一些 shell 的语法与指令(含外部指令)写在里面， 搭配正规表示法、管线命令与数据流重导向等功能，以达到我们所想要的处理目的。类似于 批处理文件，一次执行多个指令。不需要编译。Shell 语言是一个利用 C语言编写的程序，用于编写 Shell 脚本。 【 2. Shell 环境 】 Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。Linux 的 Shell 种类众多，常见的有： Bourne Shell（/usr/bin/sh或/bin/sh）、 Bourne Again Shell（/bin/bash）、C Shell（/usr/bin/csh）、K Shell（/usr/bin/ksh）、Shell for Root（/sbin/sh）…而 bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时， Bash 也是大多数Linux 系统默认的 Shell 。在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 #!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ca960b65f90726c97e6245652aa4b59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5017db1cb0079d0077b4c85264719544/" rel="bookmark">
			web前端之css、style
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 web前端之纯css实现的加载、steps、calc web前端之纯css实现的加载、steps、calc style
/* -------平滑加载------- */ .smooth_loading { background: linear-gradient(#333333 0 0) 0 / 0% no-repeat #f5f5f5; animation: smooth_loading_animation 2s infinite linear; } @keyframes smooth_loading_animation { 100% { background-size: 100%; } } /* -------按步加载------- */ .step_by_step_loading { border-radius: 20px; background: linear-gradient(#ffa500 0 0) 0 / 0% no-repeat #f5f5f5; animation: step_by_step_loading_animation 2s infinite steps(10); } @keyframes step_by_step_loading_animation { 100% { background-size: 110%; } } /* -------条纹加载------- */ .stripe_loading { border-radius: 20px; background: repeating-linear-gradient(135deg, #f03355 0 10px, #ffa516 0 20px) 0 / 0% no-repeat, repeating-linear-gradient(135deg, #f5f5f5 0 10px, #eeeeee 0 20px) 0 / 100%; animation: stripe_loading_animation 2s infinite; } @keyframes stripe_loading_animation { 100% { background-size: 100%; } } /* -------虚线加载------- */ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5017db1cb0079d0077b4c85264719544/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f65de5a55d02424fc1ef566449063fb8/" rel="bookmark">
			比丝袜还丝滑！这个简历制作软件10大优势！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看过来！看过来！
简历软件这么多，作为求职者最需要的是什么呀！
✅ 丰富专业的简历模板 —— 漂亮且免费的简历模板谁能不爱！ ✅ 量身定制的简历内容——你没看错！只需要点点点就直接生成了一份量身定制的简历！ ✅ 一键优化HR想看到的信息——还不过瘾？一键优化！ ✅ 手把手教你怎么写简历——哪里不会点哪里！ ✅ 不撞衫——简历所有的设计都是可以您自己定制的，这还需要特别说明吗！ ✅ 简历分析——想让你成功入职，我们是认真的！ 专门为国内求职市场训练的 AI Agent，不跟你说套话，Offer导向
✅ 导出免费——不跟你玩套路，如果只是想写简历，不在导出拦着你！ ✅ 简历定制——天天说匹配岗位，我们不在嘴上说，直接跟你改！ ✅ 模拟面试、简历精修、一键一页、Notion式交互… 不需要你主动去了解功能，如果你在求职时遇到问题，就能在遇到问题时利用AI简历找到对应的解决方案，我们认为能帮到您成功求职的功能才是需要存在的功能！
✅ 开发团队听劝，用户第一优先级 遇到问题了，先退款，再人工帮忙制作/优化简历，无论您是否充值，所有用户的问题都是P0问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/183f2fd8d2d58f9fa826350690b24fd4/" rel="bookmark">
			《JVM由浅入深学习【四】 2023-12-24》JVM由简入深学习提升分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM由简入深学习提升分享四 1.JVM中java堆的特点及作用2. JVM中对象如何在堆内存中分配3. JVM堆内存中的对象布局 1.JVM中java堆的特点及作用 是线程共享的一块区域虚拟机启动时就创建了是虚拟机中内存占用很大的一块存放所有的实例对象和数组GC主要的作用区域可分为新生代（刚创建）和老年代（存活很久）新生代更细化可分为Eden，From Survivor，To Survivor，比例为8:1:1
可以通过-Xms，-Xmx调节堆大小如果从分配内存的角度看，所有线程共享的 Java 堆中可以划分出多个线程私有的分配缓冲区 (Thread Local Allocation Buffer，TLAB) ，以提升对象分配时的效率无法在拓展：java.lang.OutOfMemoryError: Java heap space
例子：模拟OOM，设置JVM参数-Xmx128m -Xms128m，这里最大最小都设置128M，我的Customer里面有个bytes变量，一个就有1m，所以每个CUstomer都多于1M,所以运行程序customerList长度到达一定次数就OOM了
@Data public class Customer { private int no; private String username; private BigDecimal money; private byte[] a = new byte[1024 * 1024]; // 这里1024*1024byte等于1m } public class MyTestOOM { public static void main(String[] args) { List&lt;Customer&gt; customerList = new ArrayList&lt;&gt;(); while (true) { Customer customer = new Customer(); customer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/183f2fd8d2d58f9fa826350690b24fd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c591608f607c7c040ee22dbbb98859a5/" rel="bookmark">
			JAVAEE初阶相关内容第二十弹--HTTP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前：2024年啦！新的一年要努力学习啦
本篇博客围绕HTTP协议，对HTTP协议进行了解，需要理解其工作过程，对HTTP协议格式要清楚，通过抓包工具进行协议分析，认识“方法”、“请求报头”，后续还会进一步对HTTP这部分内容继续更新。
目录 1. HTTP协议是什么
2. 理解HTTP协议的工作过程
3. HTTP协议格式
3.1 抓包工具的使用
3.2 抓包工具的原理
3.3 抓包结果
3.3.1 【请求】 Request
(1) 认识URL
(2) URL基本格式
3.3.2 【响应】
3.4 认识“方法”
3.4.1 GET方法
(1) 认识GET请求
(2) GET特点
3.4.2 POST方法
(1) 认识POST
(2) POST特点
3.4.3 其他方法
3.4.4 面试题--谈谈GET和POST的区别
3.5 认识请求“报头”(header)
3.5.1 Host
3.5.2 Content-Length
3.5.3Content-Type
3.5.4 User-Agent(UA)
3.5.5 Referer
3.5.6 Cookie
(1) Cookie从哪来
(2) Cookie在哪存
(3) Cookie到哪去
1. HTTP协议是什么 超文本传输协议，属于应用层协议。
HTTP往往是基于传输层的TCP协议实现的（HTTP1.0,HTTP1.1,HTTP2.0均为TCP，HTTP3基于UDP实现），我们平时打开一个网站，就是通过HTTP协议来传输数据的。目前我们使用的还是HTTP1.1。
当我们在浏览器中输入一个网址（URL）时，浏览器就会给服务器发送一个HTTP请求，服务器返回一个HTTP响应。这个响应结果被浏览器解析后，就展示成了我们看到的页面内容。所谓“超文本”，就是传输的内容不仅仅时文本（比如html、css这个就是文本），还可以时一些其他的资源，比如图片、视频、音频等二进制的数据。
2. 理解HTTP协议的工作过程 当我们在浏览器中输入一个“网址”，此时浏览器就会给对应的服务器发送一个HTTP请求，对方服务器收到这个请求后，经过计算处理，就会返回一个HTTP响应。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c591608f607c7c040ee22dbbb98859a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bc62a43bdb252e36034fead9d9e4f64/" rel="bookmark">
			引导过程与服务控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开机启动的完整过程 bios加电自检测-------mbr------grub----------加载内核文件------------启动第一个进程
简述：加电后bios程序会自检硬件，硬件无故障，会根据第一启动项去找内核，一般来说，第一启动项是硬盘，找到硬盘后，会根据mbr的指引找到完整的grub程序，再根据grub的配置文件找到内核文件的具体位置，然后将内核文件加载到内存中运行，内存加载好后，会启动第一个程序。
bios作用：检测硬件是否正常，然后根据biso中的启动项设置，去找内核文件
boot：开机启动顺序(你可以把内核文件放在何处？)
1.硬盘
2.移动设备(u盘移动硬盘，光驱)
3.网络启动
mbr（二进制）：因为grub程序太大，第一个扇区存不下所有的grub程序，所以分为两部分，指引硬件找到内核文件
grub：根据grub配置文件（grub.cfg）中记录的位置，去找到内核文件（高级语言）
加载内核：把内核运行在内存中
启动进程：启动第一个祖宗进程
centos6：init
centos7：启动systemd
1.1区别 init：串行启动后续的程序，一个一个按顺序启动
systemd：并行启动程序，全部一起启动
1.2systemd systemd：是系统级的程序，代为管理系统上的程序
systemd：保姆级
yum以及rpm安装的软件可以直接使用systemctl去启动关闭，重启，开机自启等功能； 编译安装，不可以直接使用systemctl命令去管理程序，需要手写一个配置文件
systemd **unit（单元）--------描述一个软件的作用和基本信息**，systemd方便管理程序，将程序按照特定的功能分成了很多单元； 服务单元---写配置
systemctl get-default------查看默认运行级别
systemctl set-default------设置默认的级别
rpcbind：启动后，会监听111端口
1.3linux操作系统的运行级别 0：关机
1：单用户，类似于windows的急救模式
2：字符界面，少些功能 (nfs)
3：字符界面
4：字符界面，从来没用过
5：图形界面
6：重启
runlevel：查看当前运行级别
实验1：模拟破坏mbr和分区表，然后修复 1：新建一块硬盘
fdisk分区一下
格式化一下：
mkfs.xfs /dev/sdb1
挂载到mnt下：
mount /dev/sdb1 /mnt/
2：将备份文件备份到新盘
dd if=/dev/sda of=/mnt/mbr count=1 bs=512
进入mnt下：cd /mnt
3.模拟破坏：
dd if=/dev/zero of=/dev/sda count=1 bs=512
4.reboot-----重启一下
5.然后进入急救模式修复：3 2 1
6.mkdir bak
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bc62a43bdb252e36034fead9d9e4f64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5bc6c9569fd68d4928da99e9d4cda13/" rel="bookmark">
			侯捷C&#43;&#43; 2.0 新特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键字 nullptr and std::nullptr_t auto 一致性初始化：Uniform Initialization 11之前，初始化方法包括：小括号、大括号、赋值号，这让人困惑。基于这个原因，给他来个统一，即，任何初始化都能够使用大括号来实现。实现的方法使用另外一个新特性：初始化列表。下一个特性介绍。
// 11之前 Rect r1 = {3, 7, 30}; Rect r2(3, 7, 20); int ia[6] = {27, 89, 20}; // 11之后 int values[] {1, 2, 3}; vector&lt;int&gt; v {1, 2, 3}; complex&lt;double&gt; c {4.0, 3.0}; 初始化列表：Initializer Lists ERROR：narrowing 不允许窄化的转换 前面的一致性初始化中的大括号会形成一个初始化列表。具体实现代码如下：
explicit struct complex{ int real, imag; // explicit complex(int re, int im = 0) : real(re), imag(im){} complex operator+(const complex&amp; x){ return complex((real + x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5bc6c9569fd68d4928da99e9d4cda13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96cf01352d6c51cef61314ef74a96328/" rel="bookmark">
			在javascript环境实现web多标签页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript（简称“JS”）是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名，但是它也被用到了很多非浏览器环境中，JavaScript基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式、声明式、函数式编程范式。
本文是利用javascript脚本来实现网页中的多标签页功能。本例一共有1个主页面，6个标签页面，1个js脚本文件，1个CSS层叠式样式表文件。来实现多标签页功能，当选择某一个标签时，显示不同的标签页文件。
主页面文件(index.html):
&lt;!DOCTYPE html&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;选项卡&lt;/title&gt; &lt;link href="style.css" type="text/css" rel="stylesheet"/&gt; &lt;script src="javascript.js" type="text/javascript"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="topDiv"&gt; &lt;div class="btn"&gt; &lt;input class="active" type="button" name="page1.html" value="页面1" index="0" /&gt;&lt;br&gt; &lt;input class="inactive" type="button" name="page2.html" value="页面2" index="1"/&gt;&lt;br&gt; &lt;input class="inactive" type="button" name="page3.html" value="页面3" index="2" /&gt;&lt;br&gt; &lt;input class="inactive" type="button" name="page4.html" value="页面4" index="3" /&gt;&lt;br&gt; &lt;input class="inactive" type="button" name="page5.html" value="页面5" index="4" /&gt;&lt;br&gt; &lt;input class="inactive" type="button" name="page6.html" value="页面6" index="5" /&gt;&lt;br&gt; &lt;/div&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96cf01352d6c51cef61314ef74a96328/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<span class="pagination__item pagination__item--current">1/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/2/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>