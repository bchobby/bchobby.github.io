<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ae88dd575c2f3854b14031507dbc596/" rel="bookmark">
			VScode 中 C或C&#43;&#43; 结构体提示,代码补全不准确的 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1,找到项目工作区的 settings.json文件
2,修改 “C_Cpp.intelliSenseEngine”: “Tag Parser” 为 “C_Cpp.intelliSenseEngine”: “Default”
解释:
Tag Parser: 提供非上下文感知的“模糊”结果。
Default: 通过单独的 IntelliSense 流程提供上下文感知结果。
演示:
选择 Tag Parser 提示了所有的结构体成员
选择 Default 保存后, 再试一下, 只提供对应结构体的成员变量.
3,注意事项 选择 “C_Cpp.intelliSenseEngine”: “Default” 之后
需要注意 在 c_cpp_properties.json 文件中 需要正确的包含 头文件的路径.
具体看图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5308b706f76c5dbc9f44cdc565cffe7b/" rel="bookmark">
			（最优化理论与方法）第二章最优化所需基础知识-第三节：重要凸集举例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 （1）超平面（2）半空间（3）超平面和半空间与凸集和仿射集的关系A：关系B：证明（部分） （4）（范数）球和椭球（5）范数锥（6）多面体（7）单纯形（8）特殊矩阵集合和半正定锥 （1）超平面 超平面：任取非零向量 a ∈ R n a\in \R^{n} a∈Rn，形如
{ x ∣ a T x = b } , a ≠ 0 , b ∈ R \{x|a^{T} x=b\},a\not=0,b\in R {x∣aTx=b},a=0,b∈R
的集合称之为超平面
上述定义还可以表示为：
{ x ∣ a T ( x − x 0 ) = 0 } \{x|a^{T} (x-x_{0})=0\} {x∣aT(x−x0​)=0}
x 0 x_{0} x0​为超平面上任意一点 下图：是由 R 2 R^{2} R2中由法向量 a a a和超平面上一点 x 0 x_{0} x0​确定的超平面，对于超平面上任意一点 x x x， x − x 0 x-x_{0} x−x0​都垂直于 a a a
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5308b706f76c5dbc9f44cdc565cffe7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9f53547827135700a8031d6ce948c92/" rel="bookmark">
			VMware Workstation Pro详细安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，VMware Workstation Pro介绍
VMware Workstation（中文名“威睿工作站”）是一款功能强大的桌面虚拟计算机软件，提供用户可在单一的桌面上同时运行不同的操作系统，和进行开发、测试 、部署新的应用程序的最佳解决方案。VMware Workstation可在一部实体机器上模拟完整的网络环境，以及可便于携带的虚拟机器，其更好的灵活性与先进的技术胜过了市面上其他的虚拟计算机软件。对于企业的 IT开发人员和系统管理员而言， VMware在虚拟网路，实时快照，拖曳共享文件夹，支持 PXE 等方面的特点使它成为必不可少的工具。
VMware Workstation的开发商为VMware（中文名“威睿”，VMware Workstation就是以开发商VMware为开头名称，Workstation的含义为“工作站”，因此VMware Workstation中文名称为“威睿工作站”），VMware成立于1998年，为EMC公司的子公司，总部设在美国加利福尼亚州帕罗奥多市，是全球桌面到数据中心虚拟化解决方案的领导厂商，全球虚拟化和云基础架构领导厂商，全球第一大虚拟机软件厂商，多年来，VMware开发的VMware Workstation产品一直受到全球广大用户的认可，它的产品可以使你在一台机器上同时运行二个或更多Windows、DOS、Linux、Mac系统。与“多启动”系统相比，VMware采用了完全不同的概念。多启动系统在一个时刻只能运行一个系统，在系统切换时需要重新启动机器。VMware是真正“同时”运行多个操作系统在主系统的平台上，就像标准Windows应用程序那样切换。而且每个操作系统你都可以进行虚拟的分区、配置而不影响真实硬盘的数据，你甚至可以通过网卡将几台虚拟机用网卡连接为一个局域网，极其方便。因此，VMware也坐上了全球第四大系统软件公司的宝座，全球第一大电脑软件提供商微软公司董事长比尔·盖茨曾经评测过VMware；VMware的VMware Workstation产品我们也有很多的工作人员都在使用，是一款非常强大的虚拟机软件。VMware Workstation获得了美国IT杂志Dr. Dobb's颁发的Jolt Awards 2013 最佳编程工具奖
二，正式安装教程
安装包可以前往百度官网下载，我这里就不附带安装包
官网地址：下载 VMware Workstation Pro | CN
1.双击安装包，出现下面界面，开始安装
2. 选择接受协议，点击下一步
3.选择安装位置，建议安装在空间大的磁盘，我这里放在D盘，点击下一步
4.用户体验设置取消勾选两个选项，点击下一步
5.默认，下一步
6.点击安装
7.安装进行中，漫长等待中
8.安装条结束后，点击许可证（没有许可证只能体验一个月）
9.许可证可以去百度搜索，但是注意你的安装包是什么版本的，选择相应的许可证密匙版本，我安装的是14版本，就百度14版本的许可证密匙
10.完成完毕
双击打开软件，就可以创建自己的虚拟机了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07d1b0b04dbf33fbca292a562bd4890d/" rel="bookmark">
			编译原理第二章课后习题，文法的二义性判断、语法树以及最左最右推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第二章 1、文法G=（{A，B，S}，{a,b,c}P,S)，其中P为S→Ac|aB，A→ab，B→bc
写出L(G[S])的全部元素。
答：L(G[S])={abc}
2、文法G[N]为N→D|ND、D→0|2|3|4|5|6|7|8|9|，G[N]的语言是什么？
答：允许零开头的所有非负整数
3、为只包含数字、加号和减号的表达式，例如9-2+5、3-1、7等构造一个文法。
5、已知文法G[Z]为Z→aZb|ab,写出L（G[Z]）的全部元素。
答：Z =&gt;aZb =&gt;aaZbb =&gt;aaa..Z..bbb =&gt;aaa..ab..bbb
L（G[Z]）={ab|n&gt;=1}
6、已知文法G：
&lt;表达式&gt;::= &lt;项&gt;|&lt;表达式&gt;+&lt;项&gt;
&lt;项&gt;::= &lt;因子&gt;|&lt;项&gt;*&lt;因子&gt;
&lt;因子&gt;::=(&lt;表达式&gt;)|i
是给出下属表达式的推导以及语法树
（1）i （5）i+(i+i)
(6)i+i*i
7、习题1中的文法是二义的吗？为什么？
文法G=（{A，B，S}，{a,b,c}P,S)，其中P为S→Ac|aB，A→ab，B→bc
答：最右推导：S=&gt;Ac =&gt;abc
S=&gt;aB =&gt;abc，
即存在两个不同的最右推导，所以该文法是二义的。
或者：
对输入字符串abc，能够造出如下两颗不同的语法树，所以该文法是二义的。
⭐⭐⭐那么问题来啦，怎么判断文法是不是具有二义性捏？
其实很简单，就看这个文法的某个句子如果有两个不同的最右（最左）推导，那这个文法就有二义性。
⭐⭐⭐又或者说可以用如下方法判断非二义性，
1.求出文法所有非终结符号的First集，
2.求出文法所有非终结符号的Follow集，
3.进行两步判断：
（1）非终结符号A的任何两个候选式的first集合不相交
（2）f若A的某个候选式可以推导出ε，则其它候选式的First集与Follow(A)不相交。
满足以上两个条件的文法一定是非二义性的。
10、令文法G[E]为
E=&gt;T|E+T|E-T
T=&gt;F|T*F|T/F
F=&gt;(E)|i
证明E+T*F是它的一个右句型，并指出这个句型的所有的短语，直接短语和句柄。
答：此句型对应的语法树如下，
短语：E+T*F、T*F 直接短语：T*F 句柄：T*F
⭐⭐⭐那么问题又来了！！怎么找出短语，直接短语和句柄捏？
短语：一个句型的语法树中任一子树叶结点所组成的符号串都是该句型的短语。
直接短语：如果子树中不再包含其他的子树，即A只能推导出b，而b不能再推出其他的式子，则b为此句型的直接短语。
句柄：直接短语中的最左直接短语为该句型的句柄。
11、一个上下文无关文法生成句子abbaa的唯一语法树如下：
（1）给出该句子相应的最左推导和最右推导。
最左：S=&gt;ABS=&gt;aBS=&gt;aSBBS=&gt;aBBS=&gt;abBS=&gt;abbS=&gt;abbAa=&gt;abbaa
最右：S=&gt;ABS=&gt;ABAa=&gt;ABaa=&gt;ASBBaa=&gt;ASBbaa=&gt;ASbbaa=&gt;Abbaa=&gt;abbaa
(3)找出该句子的所有短语，简单短语，句柄。
短语：a是相对于A的短语，ε 是S的短语，b是B的短语，ε bb是相对于B的短语，aa是S的短语，
aεbbaa是S的短语。
直接短语：a,ε ,b
句柄：a
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44d13dd9da53ec977416472bd1b2592f/" rel="bookmark">
			springBoot整合springSecurity(认证)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springSecurity(安全) 1.什么是springSecurity? Spring Security是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富；
Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它是用于保护基于Spring的应用程序的实际标准；
Spring Security是一个框架，致力于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring Security的真正强大之处在于可以轻松扩展以满足自定义要求。
在 Java 生态中，目前有 Spring Security 和 Apache Shiro 两个安全框架，可以完成认证和授权的功能。
我们先来学习下 Spring Security 。其官方对自己介绍如下：
Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.
Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它是保护基于Spring的应用程序的事实标准。
Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirementsSpring
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44d13dd9da53ec977416472bd1b2592f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a790f2f0313d76971f2292240d6746c9/" rel="bookmark">
			Verdi使用方法（1）— 打开user guide和加载波形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Verdi使用方法（1）— 打开user guide和加载波形 一、在linux上快速打开user guide 在安装有Verdi的Linux服务器上输入如下命令即可快速的打开Verdi的user guide
verdi -doc 二、一开始就只打开一段时间的波形 打开verdi，点击load波形
选中波形后点击左下角的【Options…】选项
勾选【Open File By Time Range】选项，然后点击【OK】
点击【OK】后机会弹出这个时间选择界面
我们可以选择自己想要加载波形的时间，例如我们选择要加载“200us - 300us”的时间段的波形如下所示
然后就可以看到我们只加载了200us~300us之间的波形
我们也可以再次修改这个时间，点击【File】-&gt; 【Set View Time Range…】
这样我们就可以重新修改需要加载的时间，例如修改为190us~200us
修改后如下所示
三、折叠一段波形 点击【View】-&gt; 【Compress Time Range】
输入我们想要折叠的时间如下所示，然后点击【Insert】
可以看到5us~410us时间的波形已经被折叠了
我们也可以点击如下的【+】将折叠的波形重新打开
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5cfc52e74b2f7943ecdbafd78d08e31/" rel="bookmark">
			动态规划力扣题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、爬楼梯70 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 示例 1： 输入：n = 2 输出：2 解释：有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 思路：找到规律dp[i] = dp[i-1] + dp[i-2];
var climbStairs = function(n) { let dp = []; dp[1] = 1; dp[2] = 2; for(let i = 3;i &lt;= n;i++){ dp[i] = dp[i-1] + dp[i-2]; } return dp[n] }; 2、打家劫舍198 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 思路： 求打劫到第n个房间的最优解，规律是dp[i] = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5cfc52e74b2f7943ecdbafd78d08e31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89de82a4cb6297c41ec21e25b494e3f4/" rel="bookmark">
			超简单的Python小游戏（逢七必过）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 i = 1 guo = 0 while i &lt;= 100: if i % 10 == 7 or i % 7 == 0 or i // 10 == 7: guo += 1 i += 1 print(f"一共说了{guo}次过") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf1d7e2abf49e7e7e9a2dfecfa0801e5/" rel="bookmark">
			R语言简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R是由 Recovery这个名称演变而来的，它的全称是 Recovery Component,它是一种面向对象的编程语言，与 C++, C#, C++并称为计算机领域编程中的“四大语言”。在其发展过程中, R语言也经历了许多变化（如从 C++时代到 C#时代的发展）。R是一种面向对象的编程语言，它允许程序员在不使用语言的情况下进行代码编辑。该编程语言适用于各种类型的计算机操作系统(Windows、 Mac)、数据库软件及其它嵌入式系统工具链。R代码的特征是：编译器库是用于编译所需的所有内存的编译器，而不是与 C#兼容的存储器; R对对象（包括可执行程序）进行操作时使用标准语言进行编程；任何执行过程中使用任何工具都可以作为编译器功能程序运行时的编程语言；使用多个操作执行同一程序（即不同的操作）时使用不同于 R编码时用到的方法（代码中包含语法和字符串);使用任意类型的数据来执行新操作时使用不同于 R编码时用于执行旧操作时使用不同方法；同时, R与 C#和 C++兼容，其 C#和 C++也能被 R编译器所使用。R在结构和图形方面都很好。本文介绍关于 R编译器的特性和使用技巧，并介绍一下 R编译器和 R编码器之间的关系。
1.代码解析
在 R中，用户可以选择“解码器”，也可以选择“输入值解析器”，两个都可以通过“PHP文件来解析。首先，用户定义一个类“Recovery Data”，这个类作为接收变量可以指定一个或多个函数、索引等（例如：“slave”这个函数可以指定多个值，如：“. slave”等）。在输入文件中设置 data或者 mode为0 data;如果是用户定义的函数为1 data;如果是输出变量 mode为0 data;则输出变量都为1 data;如果 data是0 data;则输出变量则为0 data (这是用于解析用户定义类型的方式）。如果用户定义不同的函数，则输入一个参数“Recovery Data”；然后输出一个变量“Skyscan”；如果不是用户定义不合理的时候，输出结果中保留“Skyscan”；如果需要用户定义什么才是正确的。这个结果可以定义为“值解析器值”、“变量解析器值”或者“函数解析器值”等号。R的用户定义类型相同的时候即为正确的。
2. RML解析功能
解析也称为解码和获取的操作。RML通过两种方法进行解析，即先读取和解码。在解码部分, RML会先对一些特殊符号进行解析，如将特殊符号作为一种符号来使用；将特殊符号作为唯一的字符串来使用；还会使用字符串进行转换（将特殊字符串转换为一种符号进行转换）。解掉特定符号则生成一种新符号（与之对应的内容）。然后再将相应内容的数据转换为对应于该符号的新数据。当用户再次读取该符号时将使用该符号的新数据与相应的数据在同一个字符节内进行匹配；若匹配后的数据没有变化则为正常状态；若匹配后的信息与原始信息不一致的话，则为异常状态的子状态);若异常状态与原始状态完全一致且与错误状态完全吻合时则为异常状态（未完全回复为正常状态);该解析部分还具有一些特殊操作。例如：某些特殊类型的符号在读取到此符号后还可以继续读取；对于一个特殊类型的符号在读取到此符号后也可以继续读取；这种特殊情况下读取到该符号之后还可以继续读取此图形（这是唯一一个特殊类型）等都是 RML解析功能中的一个重要功能。这一功能将会使用户能够在不使用其他分析工具时同时了解系统和程序的运行情况。
3.程序编译
程序编译是通过调用程序编译器的所有功能和函数来实现的。因此，对于任何一种编程语言而言，调用不同的编译工具都可以调用程序编译器功能，如前面提到的 SIMD、 FLASH等都是这样处理的。每个程序都是由许多个调用工具组成的，这些工具将执行相同或相近功能的操作。因此，调用工具可被调用而无需重复地将执行过程从编译工具中剥离出来；所有程序都不能重新调用。通过使用不同工具对不同的操作直接调用不同的函数执行程序，对于一款较复杂的程序来说是一种可行且有用方式；但是对于一些较为复杂的问题则是非常困难的。所以在一般情况下，一般的编程人员都会选择用专门的调用器来进行编辑工作的。
4.程序调试: R编译器与 R编码器的关系
R编译器和 R编译器都可以用于调用编程语言；通过设置调用函数来调用语法，如：“client”函数等；通过调试运行函数，把代码添加到测试环境中进行测试程序执行后，会对该函数进行检查，看是否存在异常。在调试过程中，一般是将编程语言的某些关键技术（如：语法）进行转化，在调试状态下对该代码进行检验。在这种情况下则需要对测试过程中使用到的代码片段进行检查和修改操作。在运行一段时间后，当调用函数完成之后，会对该函数进行检查和修改——对于一个调用函数完成之后，再添加一个新的函数进行测试——这样循环重复几次即可。我们可以使用 RF (internal transaction of automation)指令来验证该函数中的执行情况。如果执行完毕，那么程序测试状态为“reply”；如果结果是正确的，则说明调试程序正确且执行完毕。
5.程序调试: R编译器与 R编码器的简单区别
在程序调试时，一般会使用 R编译器。如果要对程序进行调整的话，我们可以在调试时使用 R编译器。下面来看两种常用的编译制的代码：由于程序编程不需要存储和写程序，所以 R编译器与 R编码器并没有什么区别。与其他代码不同，由于 R中有一个特定的字节码，所以可以直接写入到文件中（我们常在一个特定时间对某个文件进行编写，需要很长时间）。只要把这个字节码写入到文件中，其他时间不需要任何操作，就可以对它进行修改了。但是如果不能及时更改这个字节码又要重新编写一次程序的话, R编译器就是一个很好地选择了。但是如果需要使用更长时间的话，我们可以通过 RBAC (编译器提供的扩展内存存储器）来直接从 R编码器进行修改。如果没有扩展内存存贮器以及相关的支持功能，那么 RBAC (编译器库提供的扩展内存存储器）就相当于一个 M* M^1块一样大一些了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf1d7e2abf49e7e7e9a2dfecfa0801e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e76b9eb17bcb35532ffc23de5b762875/" rel="bookmark">
			Thrift客户端服务器示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这里我采用的是Java作为服务端，C++作为客户端
官方文档
Thrift文件 namespace java com.tubai.thrift enum Action{ Hello = 1, Query = 2 } struct Request{ 1: required Action type, 2: required string name, 3: optional i32 age, } service ActionService{ void doAction(1:Request req) } 服务器 首先根据官网文档生成代码，然后我们只需要编写ActionService的实现类以及一个程序的入口（也就是main函数）
如下所示
public class ActionServiceImpl implements ActionService.Iface{ public void doAction(Request req) throws org.apache.thrift.TException{ System.out.println("===&gt;" + req); } } import org.apache.thrift.server.TServer; import org.apache.thrift.server.TSimpleServer; import org.apache.thrift.transport.TServerSocket; import java.io.IOException; import java.net.ServerSocket; public class JavaServer{ public static void main(String[] args){ ServerSocket socket = null; try { socket = new ServerSocket(9090); TServerSocket serverTransport = new TServerSocket(socket); ActionService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e76b9eb17bcb35532ffc23de5b762875/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dd9f7ed249baad54d0066f505daaf20/" rel="bookmark">
			已安装xxx模块，但报错无法找到模块“xxx”的声明文件(TS)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 在一个vue3+TS项目中，引入md5时，报错误
import md5 from "js-md5"; 已声明“md5”，但从未读取其值。ts(6133)
无法找到模块“js-md5”的声明文件。“D:/Desktop/vue3_online-retailers/project/node_modules/js-md5/src/md5.js”隐式拥有 “any” 类型。
尝试使用 npm i --save-dev @types/js-md5 (如果存在)，或者添加一个包含 declare module 'js-md5'; 的新声明(.d.ts)文件ts(7016)
解决方法 在src目录下新建文件legacy.d.ts
文件内容写上如下声明：
declare module 'js-md5'; 即可解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48a4073592e4ff95804943d50b2c2f71/" rel="bookmark">
			Vite&#43;Vue项目添加sass预处理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：安装sass vite有内置的sass配置信息，所以直接安装sass即可
npm install --save-dev sass 二：编写全局css变量/全局mixin 在assets文件夹下创建scss目录，添加globalMixin.scss和globalVar.scss文件
添加几个案例
//globalVar.scss $bg-color: #1989fa; //globalMixin.scss @mixin box-shadow($bulr: 20px, $color: #1989fa7a) { -webkit-box-shadow: 0px 0px $bulr $color; -moz-box-shadow: 0px 0px $bulr $color; box-shadow: 0px 0px $bulr $color; } 三：引入 全局引入 打开项目目录下vite.config.js文件，添加配置信息
//配置sass css: { preprocessorOptions: { scss: { // '@import "assets/scss/globalVar.scss";@import "assets/scss/globalMixin.scss";' additionalData: '@import "../assets/scss/globalVar.scss";@import "../assets/scss/globalMixin.scss";' } } }, 如图
直接使用即可
按需引入 在需要使用的style里import引入即可使用
四：注意事项 使用sass的时候，是使用lang=scss并不是lang=sass，否则样式会失去高亮且代码报错
over~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9146b901004e0fb80d1f877477958bd4/" rel="bookmark">
			Kafka锦集（二）：三种不同方式，查看kafka是否已启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Kafka的启动之前，必不可少的三个操作：
1、启动Zookeeper服务，点击进入 bin/zookeeper-server-start.sh -daemon config/zookeeper.properties
2、 Kafka的下载和安装 3、修改Kafka安装目录下./config/server.properties文件里的监听窗口，点击进入。
kafaka启动命令 #pwd //查看当前路径 /usr/src/kafka_2.13-3.3.1 #./bin/kafka-server-start.sh -daemon ./config/server.properties //启动命令 方式一、使用jps命令 jps是jdk提供的一个查看当前java进程的小工具， 全称是JavaVirtual Machine Process Status Tool。
语法：jps [options] [hostid]
#jsp #jps -ml 注意：jps仅查找当前用户的Java进程，而不是当前系统中的所有进程！
#jps --help jps命令具体 [options]选项解析：
-q：仅输出VM标识符，不包括classname,jar name,arguments in main method；
-m：输出main method的参数；
-l：输出完全的包名，应用主类名，jar的完全路径名；
-v：输出jvm参数 ；
-V：输出通过flag文件传递到JVM中的参数(.hotspotrc文件或-XX:Flags=所指定的文件 ；
常用组合
jps –l 输出主类或者jar的完全路径名
jps –v 输出jvm参数
jps –q 仅仅显示java进程号
jps -ml 方式二、使用lsof -i:port的命令 lsof命令简述：
list open files是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。
该命令的执行，需要有管理员权限，它的作用主要有三：
1）查看端口被占用的情况；
2）查看服务是否启动；
3）查看有哪些用户（IP）连接了当前的Web服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9146b901004e0fb80d1f877477958bd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f802272a6d8706222a98d1bbd3913629/" rel="bookmark">
			flink任务优化总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本博客总结为B站尚硅谷大数据Flink2.0调优，Flink性能优化视频的笔记总结。
1. 资源配置调优 Flink 性能调优的第一步，就是为任务分配合适的资源，在一定范围内，增加资源的分配与性能的提升是成正比的，实现了最优的资源配置后，在此基础上再考虑进行后面论述的性能调优策略。
提交方式主要是 yarn-per-job ，资源的分配在使用脚本提交 Flink 任务时进行指定。
标准的 Flink 任务提交脚本 （Generic CLI 模式）
从 1.11 开始，增加了通用客户端模式，使用-D&lt;property=value&gt;指定其他的参数：
bin/flink run \ -t yarn-per-job \ -d \ -p 5 \ 指定并行度 -Dyarn.application.queue=test \ 指定 yarn 队列 -Djobmanager.memory.process.size=1024mb \ 指定 JM 的总进程大小 -Dtaskmanager.memory.process.size=1024mb \ 指定每个 TM 的总进程大小 -Dtaskmanager.numberOfTaskSlots=2 \ 指定每个 TM 的 slot 数 -c com.atguigu.flink.tuning.UvDemo \ /opt/module/flink-1.13.1/myjar/flink-tuning-1.0-SNAPSHOT.jar 如果是使用 -m yarn-cluster，则使用 -yD &lt;property=value&gt; 指定其他的参数：
bin/flink run \ -m yarn-cluster \ -d \ -p 5 \ 指定并行度 -yDyarn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f802272a6d8706222a98d1bbd3913629/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18f362685339091d6b7b7ad3c5b75fb7/" rel="bookmark">
			华为RH2288 V3服务器新加硬盘不识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为服务器RH2288 V3原本6块本地硬盘配置RAID5,后新加入2块本地硬盘配置RAID(RAID卡类型LSI SAS3108)时,不能被BIOS Configuration Utility界面VD Mgmt页签识别到处理方法。
首先，检查IBMC portal,不存在硬盘故障告警信息，硬盘指示灯正常。
重启服务器，当显示器出现下图界面时，按“Ctrl+R”，进入RAID配置界面。
在BIOS Configuration Utility界面PD Mgmt页签查看新加入2块硬盘的状态,显示为Foreign。
此时，需要清除RAID卡的外部配置。按“Ctrl+P”切换到“Foreign View”页签。
选择要删除外部配置的RAID卡SAS3108,按F2,选择“Clear”清除外部配置,并按“Enter”确认。
此情况硬盘不识别的根本原因在于：服务器原有硬盘已经进行了RAID配置操作,新加入的硬盘也已经存在一个RAID配置,所以会被判定为“foreign”状态,不能在BIOS Configuration Utility界面VD Mgmt页签识别到。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1584daade868d421416e438179f298ee/" rel="bookmark">
			spring security 密码校验——用户输入的密码和数据库密码值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果控制台抛异常：security.authentication.BadCredentialsException 一定一定要仔细检查数据库密码，绝大概率就是这里的问题。
先检查数据库存的密码是否是在securityConfig配置类里注入的加密方法，加密后的结果
eg：用security自带的BC加密
public class SecurityConfig extends WebSecurityConfigurerAdapter { //创建BCryptPasswordEncoder注入容器 @Bean public PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } } 那么可以在主方法进行测试：
public class SpringBootSecurityApplication { public static void main(String[] args) { BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); //raw1是用户输入的密码 String raw1 = "cb2e6f1a703cbc1c7009b95f4709274c"; //encode1是用户输入密码加密后的结果 String encodeS1 = passwordEncoder.encode(raw1); System.out.println("15680612913："+encodeS1); } } 在控制台进行打印的结果，存到数据库中，就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9c788405f1aeacfc04575d67095d0aa/" rel="bookmark">
			基于RK1126的人工智能安防检测方案，支持AI算法二次开发定制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI BOX 是一款基于 RK1126 设计的高性能、低功耗的边缘计算设备，2Tops。RK1126 支持 4K H264/H265 解码器解码，支持1080P@60fps H264/H265 编码器编码，支持 HDMI视频输出最高可达 4K@30fps，外观上具有轻量化、灵活性强等特点，可广泛应用于新零售、智能安防、智慧课堂、电玩游戏机等领域场景。
算法可按照客户要求定制移植： 支持跌倒检测，攀爬识别，打架识别， 离岗识别，睡岗识别，火焰识别，烟雾识别， 消防通道占用，电子围栏，垃圾满溢，流量统计等
主要参数：
RV1126 HCoreV1.1 核心板采用瑞芯微RV1126 主芯片+1GB DDR3 内存+ 8GB EMMC 最大支持4路1080P/30AI运算 集成NPU 2.0T 算力，可集成adas/caffe/tensorflow/mxnet/pytorch 等算法 支持100M/千兆以太网口 可以通过SD 卡升级，提供两组USB 接口，可分别设置成 HOST、DEVICE 可选外接 WIFI/支持外置有源GPS/可选外接4/5G模块 支持串口调试/支持一路CAN总线，可通过串口扩展多路CAN 提供二次开发SDK开发包/支持屏蔽罩散热，PCBA可支持定制开发
8路边缘计算盒子，基于瑞芯微RV1126 主芯片平台芯片，自主研发生产的轻量级、可搭载多种主流算法的视频智能分析设备。 应用于：为各大企业提供了轻量级、多平台、易移植、高算力、高能低耗、支持二次开发的边缘计算产品，广泛应用于电力、能源、油站、智慧工地、智慧社区、智慧交通、智能安防等领域行为分析。
功能特点： ●算力的 2T 模组，更灵活地适配不同的算法部署环境。 ● 支持 adas/caffe/tensorflow/mxnet/pytorch 等主流深度学习框架； ● 支持人脸检测、火焰、吸烟、跟踪、识别、姿态识别、安全帽检测等网络模型 ● 支持100M/千兆以太网口，可扩展4/ 5G/WIFI 无线网络方式； ● 低功耗设计，结合外壳散热，可增加散热风扇主动散热，产品稳定可靠； ● 完全嵌入式结构，高度集成，可支持桌面放置或挂墙安装，安装和维护都非常方便 ● 丰富的外设接口资源，包括 MSATA/M2/ RS485/ RS232/TF/LINE IN/LINE OUT 等接口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9c788405f1aeacfc04575d67095d0aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/756ef91409d91ad287d0119cb8973635/" rel="bookmark">
			redis多路IO复用原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redids的IO多路复用例子： 1，2，3 三个人通过黄牛去买票，当1买的票没有时，1还可以干其他的事情，2和3一次类推，黄牛发现1的票有的时候再告知1去买票，此时1再去买票。即多路IO服用的意思是CPU在等待执行命令A的时候还可以去执行别的命令，使得CPU有充分的利用率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dc640f883070dde19b9776f1e1cdebf/" rel="bookmark">
			java超好用的文本文件读写方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在浏览了无数java文件读写的方法之后，我终于总结出来了两个超实用的读写方法~
话不多说，上干货！！！
------------------------------------------------------------------------------------------------------------------------------
一、文本文件的读取方法
void read() throws FileNotFoundException { File file = new File("registrationReview.txt");//文件名 Scanner input = new Scanner(file); while (input.hasNext()){ String s1 = input.next(); String s2 = input.next(); String s3 = input.next(); String s4 = input.next(); String s5 = input.next(); Main.registReviews.add(new RegistReview(s1,s2, s3, s4, s5)); } input.close(); } 注：Main.registReviews是ArrayList&lt;registReviews&gt; 的名字，定义方式为：
ArrayList&lt;registReview&gt; registReviews = new ArrayList&lt;&gt;();
其中registReview 是一个自定义类
二、文本文件的写入方法
void write(ArrayList&lt;RegistReview&gt; objects, String txt){ File f1 = new File(txt); PrintWriter output = null; try { output = new PrintWriter(f1); } catch (FileNotFoundException ex) { ex.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dc640f883070dde19b9776f1e1cdebf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/505904f4e309c49fe2fd5fbd5608ac32/" rel="bookmark">
			vue数据增删改查及表单验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 准备工作
2. 弹出窗口
3. 新增更新功能
4. 删除功能
5. 表单验证
5. 接口文档
1. 准备工作 后台服务接口，对书本的增删改查操作
2. 弹出窗口 进入ElementUi官网， 找到Dialog对话框，可以参考“嵌套表单的dialog”实现。
该步骤先实现弹出窗口的前端逻辑，并不会调用后台接口服务进行实际的业务操作。
BookList.vue
&lt;!-- 弹出窗口：增加和修改书本信息共用一个弹出窗口，需要根据用户的选择动态的设置弹出窗口的标题 :tile 通过绑定值的方式设置dialog的标题 :visible.sync 控制弹出窗口的显示或隐藏，.sync同步修饰符 @close="closeBookForm"，设置窗口关闭时调用的处理函数，可用于清空表单 :model="bookForm"：用于定义表单对应的model，具体model的定义可见data部分。 v-show="optiontype == 'update'" 通过操作类型控制是否显示书本编号字段，如果当前操作类型为 新增，则不用显示，书本编号在数据表中是自增的。 :label-width="formLabelWidth" 统一定义标签的宽度。 :style="{width: formEleWidth}" 统一定义form元素的宽度。 --&gt; &lt;el-dialog :title="dialogName" :visible.sync="dialogFormVisible" @close="closeBookForm" width="500px"&gt; &lt;el-form :model="bookForm"&gt; &lt;el-form-item v-show="optiontype == 'update'" label="编号" :label-width="formLabelWidth"&gt; &lt;el-input v-model="bookForm.id" autocomplete="off" :style="{width: formEleWidth}"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="书名" :label-width="formLabelWidth"&gt; &lt;el-input v-model="bookForm.bookname" autocomplete="off" :style="{width: formEleWidth}"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/505904f4e309c49fe2fd5fbd5608ac32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c8791d37c124d975e48a50b68a7c8d9/" rel="bookmark">
			spring-IOC、AOP及项目经验分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring-IOC、AOP及项目经验分享
IoC： Inversion of Control (控制反转/反转控制)，它是一个技术思想而不是一个技术实现，在Java开发领域他所描述的事情是对象的创建和管理的问题。 与传统开发方式相比在IOC的思想开发方式下，当类A需要以来类B时，我们不要自己去new对象了，而是由IOC容器帮我们实例化对象并且去管理它，我们需要什么对象直接从IOC容器中获取即可，由此我们可以省去创建和管理对象的一系列事情，也丧失了创建、管理对象的权力。 控制反转解释： 控制：指的是对象创建（实例化、管理）的权利 反转：控制权交给外部环境了（spring框架、IoC容器 IOC解决了什么问题 IoC解决对象之间的耦合问题，例如当service层调用dao层时，传统方式下我们需要在service中new出dao层的具体实现类，这时当我们实现类需要改变时，service层也需要做相应的改变，这就造成了service层和dao层的强耦合。而使用IOC实例化对像时，我们只需要关注调用的dao层的接口，在service中声明接口属性，具体的实现类在IOC容器中进行切换，因此也不会产生对象中强耦合的情况。 示例图如下： 一、IOC（Inverse of Control）：控制反转，也可以称为依赖倒置 所谓依赖，从程序的角度看，就是比如A要调用B的方法，那么A就依赖于B，因为A要用到B，所以A就必须依赖于B的方法。
所谓倒置，你必须理解如果不倒置，会怎么着，因为A必须要有B，才可以调用B，如果不倒置，意思就是A主动获取B的实例：B b = new B()，这就是最简单的获取B实例的方法（当然还有各种设计模式可以帮助你去获得B的实例，比如工厂、Locator等等），然后你就可以调用b对象了。
所以，不倒置，意味着A要主动获取B，才能使用B；到了这里，就应该明白了倒置的意思了。倒置就是A要调用B的话，A并不需要主动获取B，而是由其它人自动将B送上门来。
形象的举例就是：
通常情况下，假如你有一天在家里口渴了，要喝水，那么你可以到你小区的小卖部去，告诉他们，你需要一瓶水，然后小卖部给你一瓶水！这本来没有太大问题，关键是如果小卖部很远，那么你必须知道：从你家如何到小卖部；小卖部里是否有你需要的水；你还要考虑是否开着车去；等等等等，也许有太多的问题要考虑了。
也就是说，为了一瓶水，你还可能需要依赖于车等等这些交通工具或别的工具，问题是不是变得复杂了？那么如何解决这个问题呢？
解决这个问题的方法很简单：小卖部提供送货上门服务，凡是小卖部的会员，你只要告知小卖部你需要什么，小卖部将主动把货物给你送上门来！这样一来，你只需要做两件事情，你就可以活得更加轻松自在：
第一：向小卖部注册为会员。
第二：告诉小卖部你需要什么。
这和Spring的做法很类似！Spring就是小卖部，你就是A对象，水就是B对象
第一：在Spring中声明一个类：A
第二：告诉Spring，A需要B
假设A是UserAction类，而B是UserService类
&lt;bean id="userService" class="org.leadfar.service.UserService"/&gt; &lt;bean id="documentService" class="org.leadfar.service.DocumentService"/&gt; &lt;bean id="orgService" class="org.leadfar.service.OrgService"/&gt; &lt;bean id="userAction" class="org.leadfar.web.UserAction"&gt; &lt;property name="userService" ref="userService"/&gt; &lt;/bean&gt; 在Spring这个商店（工厂）中，有很多对象/服务：userService,documentService,orgService，也有很多会员：userAction等等，声明userAction需要userService即可，Spring将通过你给它提供的通道主动把userService送上门来，因此UserAction的代码示例类似如下所示：
package org.leadfar.web; public class UserAction{ private UserService userService; public String login(){ userService.valifyUser(xxx); } public void setUserService(UserService userService){ this.userService = userService; } } 在这段代码里面，你无需自己创建UserService对象（Spring作为背后无形的手，把UserService对象通过你定义的setUserService()方法把它主动送给了你，这就叫依赖注入！），当然咯，我们也可以使用注解来注入。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c8791d37c124d975e48a50b68a7c8d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1b8b3af8382a19c7f956439200a1420/" rel="bookmark">
			HTTP请求头-这些参数的含义你记得几个
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为互联网的职业人员，日常都需要与浏览器打交道，很多人对浏览器请求头局限于请求方式，请求状态码，请求参数的认知；对于请求头的其他辅助参数都不了解；以便于测试人员或开发人员更好的了解http的交互原理；
http请求分为三部分：
请求行（General），请求头（Request Headers）， 请求体（Query String Parameters）
请求头 报文头包含若干个属性 格式为“属性名:属性值”，服务端据此获取客户端的基本信息，其中User-Agent为常用属性，可以获取客户端基本信息； 常见的请求头（Request Headers）
属性名说明Accept览器支持的 MIME 媒体类型, 比如 text/html,application/json,image/webp,/ 等Accept-Encoding浏览器发给服务器,声明浏览器支持的编码类型，gzip, deflateAccept-Language客户端接受的语言格式,比如 zh-CNConnectionkeep-alive , 开启HTTP持久连接Host服务器的域名Origin告诉服务器请求从哪里发起的，仅包括协议和域名 CORS跨域请求中可以看到response有对应的header，Access-Control-Allow-OriginReferer告诉服务器请求的原始资源的URI，其用于所有类型的请求，并且包括：协议+域名+查询参数； 很多抢购服务会用这个做限制，必须通过某个入来进来才有效User-Agent服务器通过这个请求头判断用户的软件的应用类型、操作系统、软件开发商以及版本号、浏览器内核信息等； 风控系统、反作弊系统、反爬虫系统等基本会采集这类信息做参考Cookie表示服务端给客户端传的http请求状态,也是多个key=value形式组合，比如登录后的令牌等Content-Type HTTP请求提交的内容类型，post提交时才需要设置，比如文件上传，表单提交、json等
form表单提交：application/x-www-form-urlencodedjson方式提交：application/json 请求头参数示例 响应头content-type内容常见类型 Content-type: 用来指定不同格式的请求响应信息，俗称 MIME媒体类型
类型 说明
text/htmlHTML格式text/plain纯文本格式text/xmlXML格式image/gif gif图片格式image/jpegjpg图片格式image/pngpng图片格式application/jsonJSON数据格式application/pdfpdf格式application/octet-stream二进制流数据，一般是文件下载multipart/form-data表单中需要上传文件的文件格式类型application/x-www-form-urlencodedform表单默认的提交数据的格式，会编码成key=value格式 HTTP深入了解参考 ---&gt;HTTP | MDN
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef6e97b49b1736f3f1223026c8d11a37/" rel="bookmark">
			Cannot access aliyunmaven ( xxx ) in offline mode and the artifact
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cannot access aliyunmaven ( xxx ) in offline mode and the artifact 记一次Maven无脑报错
报错提示：
Cannot access aliyunmaven (https://maven.aliyun.com/repository/public) in offline mode and the artifact
当看到这个报错信息后，首先想到的就是maven环境变量是否配置正确，然而经过一番查看后，发现maven配置是没有问题的，然后又想到是不是idea中maven没有配置正确，因为idea没有配置正确，是极有可能出现上述报错的，然而我的idea配置如下，也是没有问题的；
随后我想到，会不会是阿里云镜像改变了，导致读不到阿里云远程maven镜像了，随之我查了下阿里云仓库镜像，发现也是没有问题的；
后来经过一系列的查看各种配置发现，是idea中一项设置所导致的；
这个选项是脱机工作，意思就是不读取远程仓库，只读取本地已有的仓库，之所以报错原因就是我本地仓库是空的，然而我还选择了脱机工作🤣，真是愚蠢的一次报错。
————————————————
版权声明：本文为CSDN博主「ITMuscle」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/ITMuscle/article/details/122397062
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3601195d190b968d6f5d25ac52a0168e/" rel="bookmark">
			Redis（十二）SpringBoot集群搭建redis【主从复制&amp;哨兵模式】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		十二、 SpringBoot实现主从复制 12.1 首先要在Linux虚拟机上安装redis # 安装包存放目录 cd /usr/local/redis # 下载最新稳定版 wget https://download.redis.io/releases/redis-6.2.6.tar.gz # 解压 tar -zxvf redis-6.2.6.tar.gz # 进入解压后的目录 cd /usr/local/redis/redis-6.2.6/ # 编译 make # 执行 "make install" 默认会安装到 /usr/local/bin,可通过PREFIX指定安装路径 make install PREFIX=/usr/local/redis # 测试是否安装成功,执行下面命令 /usr/local/redis/bin/redis-server 下载安装好的文件 测试启动，看是否能够正常运行 12.2 主从及哨兵配置 简要过程
三个redis-server服务都运行在我们虚拟机上，我这里的设置的IP地址都为192.168.159.100（根据自己的IP地址定义），端口分别为6380、6381、6382，以6380作为主节点，6381、6382作为从节点
1）主从复制（master&amp;slave） 配置redis.conf运行文件 先创建一个 redis-cluster 文件夹 拷贝三份redis.conf文件到 redis-cluster 文件夹目录下 配置文件可在解压后的源码文件根目录中找到，这里以从节点 6381 配置文件为例，其余两个配置文件几乎一致。首先将配置文件redis.conf拷贝到/usr/local/redis/redis-cluster（redis-cluster文件夹需要手动创建），拷贝三份，然后进行下面的修改
# (1)设置允许外部ip访问,需要注释掉bind配置,并关掉保护模式 # bind 127.0.0.1 -::1 protected-mode no # (2)修改端口号 port 6381 # (3)修改为以守护进程模式后台运行 daemonize yes # (4)修改pid文件名,以守护进程运行的时候,会产生pid文件,默认位置为 /run/redis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3601195d190b968d6f5d25ac52a0168e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/271838b15f3085ab658530406ea457df/" rel="bookmark">
			使用CSS进行图片自适应的两个方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.object-fit 属性 设置好图片的宽高，然后设置object-fit属性为contain就是常见的图片自适应效果。
img { width: 400px; height: 400px; object-fit: contain; } object-fit: fill|contain|cover|scale-down|none|initial|inherit; 2.background 我们把图片作为背景，然后用background-size属性进行调节
.img-container{ width:688px; height:304px; background: black url(./test.png) no-repeat center center; background-size: contain; } 本文转自链接：https://www.jianshu.com/p/78e4a240370c
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bda43064ead49b50a06d38dc1ab08ed7/" rel="bookmark">
			使用Verdi或DVE分析波形的一些小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文记录使用Verdi或DVE查看delta cycle的方法和分享一些分析波形的小技巧。
文章目录 查看Delta Cycle的方法Verilog和SV的仿真调度机制使用Verdi查看Delta Cycle的方法使用DVE查看Delta Cycle的方法 Verdi的一些其他小技巧总线拆分事件统计逻辑运算修改参数显示进制 查看Delta Cycle的方法 Verilog和SV的仿真调度机制 在仿真时可能会遇到一些设计和验证平台之间竞争冒险的问题。Verilog有一套仿真调度机制，一个时间片（time-slot）被分为Active, Inactive, NBA 区域，可以理解为分别主要用于阻塞赋值、零延时操作和更新非阻塞赋值。SystemVerilog又在这一基础上将设计和验证平台的事件分开调度，在同一时间片之后引入了Observed, Reactive, Postpone 区域，分别执行断言、验证平台和输入采样。SV-2017的IEEE标准中展示了完整的time slot region划分，如下图所示。
一个时间片可分为无限小的delta cycle，其时间精度比最小单位 fs 还小，在使用Verdi或DVE仿真时，可以通过查看delta cycle来分析硬件仿真和验证平台间的准确时序前后关系。
使用Verdi查看Delta Cycle的方法 一个非常简单的例子如下，APB总线是在每周期第二个pclk采到penable的高电平，而非在第一个pclk，那么怎么通过波形上确认呢？在使用VCS仿真时，可以在仿真simv命令后添加选项 +fsdb+region。
用Verdi打开fsdb波形后，打开波形窗口 View 选项下的"Region mode"，然后点击 Expand/Collapse Time at Cursor，或直接选中波形按w键。
然后就可以看到仿真时刻的delta cycle，并且选中还可以看到当前时刻所在的region。这里绿色区域为Active Region，红色区域为NBA Region。借助event region可以很好理解为何是在第二个pclk采到penable高电平。
另外，也通过选择 Tools -&gt; Event Sequence 来显示图形化的事件序列，效果如图所示。
使用DVE查看Delta Cycle的方法 在VCS仿真命令中添加 -gui 参数即可调用DVE仿真。DVE也可以在仿真进行时观察波形，这里如果没有事先存储波形文件的话，需要在 run 命令前执行"dump -add /*“命令，对全部或指定层次的波形采样。这里给出同样一个APB总线的例子。
在波形窗口打开 Simulator 选项下的 Capture Delta Cycle Values。
然后在波形对应时间点，右键选择"Expand Time”，即可看到展开了的delta cycle。
Verdi的一些其他小技巧 总线拆分 选中信号右键 -&gt; Bus Operation -&gt; Expand ad Sub-bus，可以将多比特bus选取特定位宽拆分成sub-bus，或者直接在弹出对话框的 Every 项内输入n值，按每n个bits拆分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bda43064ead49b50a06d38dc1ab08ed7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/443b66fd7b00f175e36d294dfd3fcab0/" rel="bookmark">
			结合Jackson Streaming API和ObjectMapper来处理JSON
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jackson Streaming API 允许我们解析巨大的JSON文档，而无需一次性将其全部内容加载到内存中。它是处理JSON内容最有效的方法，具有最低的内存和处理开销，但它也有成本: 不是处理JSON内容最方便的方法。
在这篇文章中，我们将看到如何在不失去ObjectMapper提供的强大数据绑定功能的情况下利用Jackson Streaming API。
简介 出于演示的目的，让我们考虑我们想要解析JSON数组，其中每个元素代表一个联系人:
[ { "id": 1, "firstName": "John", "lastName": "Doe", "emails": [ "john.doe@mail.com" ], "createdDateTime": "2019-08-19T20:30:00Z" }, { "id": 2, "firstName": "Jane", "lastName": "Poe", "emails": [ "jane.poe@mail.com", "janep@mail.com" ], "createdDateTime": "2019-08-19T20:45:00Z" } ] 每个联系人都可以映射到 Contact '的一个实例，定义如下:
@Data public class Contact { private Integer id; private String firstName; private String lastName; private List&lt;String&gt; emails; private OffsetDateTime createdDateTime; } 在大多数应用程序中，我们可以利用ObjectMapper提供的数据绑定功能，并使用以下代码解析数组:
ObjectMapper mapper = new ObjectMapper(); mapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/443b66fd7b00f175e36d294dfd3fcab0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d45d2e0140d1d6f3dc2ad1bafdc9e7d/" rel="bookmark">
			MySQL Innodb引擎锁的分类及死锁排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
1、概览 在实际工作过程中遇到了数据库死锁的问题，在查阅资料的时候遇到了各种锁的概念。
共享锁、排它锁、表级锁、行级锁、记录锁、间隙锁、临键锁、插入意向锁、自增锁等等等等，这些概念如果能够弄清楚其中区别自然最好，但理清这些概念是在是太麻烦了。而且从实际工作情况出发，理清这些概念再去解决实际的工作问题效率太低。
所以我这里基于MySQL数据库的Innodb引擎（注意是MySQL数据库的Innodb引擎，其它引擎或数据库以下总结不完全适用，但有一定的参考价值），以及实际的工作场景，做了以下梳理：
锁的概念进行简化以实际sql详细说明锁的产生条件常见解决死锁的方法 2、锁的分类 2.1、从产生锁的行为来划分 2.1.1、共享锁 又被称为读锁、S锁等，事务在对数据进行查询，需要先获取数据的共享锁
2.1.2、排它锁 又被称为写锁、X锁等，事务在对数据进行修改时，需要先获取数据的排它锁
2.1.3、注意 这里“需要先获取数据的共享锁、排它锁”不代表说操作哪条数据，就只锁哪条数据，有可能只操作一条数据，但却锁了某个数据区间、甚至是整张表。锁的范围见下方解释
2.1.4、互斥关系 共享锁和排它锁的兼容和互斥关系想必大家都清楚，这里还是做个简单说明：
如果一个事务给表已经加了S锁，则： 别的事务可以继续获得该表的S锁，也可以获得该表中某些记录的S锁。 别的事务不可以继续获得该表的X锁，也不可以获得该表中某些记录的X锁。 如果一个事务给表加了X锁，那么 别的事务不可以获得该表的S锁，也不可以获得该表某些记录的S锁。 别的事务不可以获得该表的X锁，也不可以继续获得该表某些记录的X锁。 2.2、从锁的范围来划分 2.2.1、表锁 即整张表的数据都被锁定了。
产生场景 sql执行语句没有合理的构建索引;
MySQL优化器自行进行了全表扫描
2.2.2、行锁 即只锁定一行的数据。
产生场景 主键索引精确查询且能查找到数据; 2.2.3、间隙锁; 即只锁定一个区间（间隙）的数据，这个产生场景最多，所以放在最后特别说明。
产生场景 主键索引范围查询主键索引精确查询但这条数据不存在普通索引进行精确查询或者范围查询都会产生间隙锁 2.2.4、锁定的范围 既然间隙锁锁定的是一个区间，那么这个区间是如何划分的呢？
根据检索条件向左寻找最靠近检索条件的记录值A，作为左区间，如果找不到记录值A，则左区间为无限小；
向右寻找最靠近检索条件的记录值B，作为右区间，如果找不到记录值B，则右区间为无限大
详细说明可以参考这里：https://blog.csdn.net/sfh2018/article/details/121016466，后续测试模拟的表格结构也参考自这里
3、测试模拟 平常学习中可以自行建表模拟事务的执行，虽然不难，但还是在这里说明下，以Navicat为例：
3.1、开启事务 新开一个sql执行界面运行命令，即可开启一个事务
start transaction ; #开启事务 insert into test_gap_table value(16,5);#事务里面可以执行多条SQL语句 COMMIT#如果没有这条指令，则事务将会一直不提交，锁将一直持有，由此便可模拟多个事务进行锁的抢占 3.2、测试表结构如下 CREATE TABLE `test_gap_table` ( `id` bigint unsigned NOT NULL AUTO_INCREMENT, `number` bigint DEFAULT NULL, PRIMARY KEY (`id`), KEY `idx_number` (`number`) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci; INSERT INTO test_gap_table ( id, number ) VALUE ( 1, 2 ); INSERT INTO test_gap_table ( id, number ) VALUE ( 3, 4 ); INSERT INTO test_gap_table ( id, number ) VALUE ( 6, 5 ); INSERT INTO test_gap_table ( id, number ) VALUE ( 8, 5 ); INSERT INTO test_gap_table ( id, number ) VALUE ( 10, 5 ); INSERT INTO test_gap_table ( id, number ) VALUE ( 13, 11 ); 4、死锁问题排查 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d45d2e0140d1d6f3dc2ad1bafdc9e7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fff516b508f6fe0b491222852bda9e4/" rel="bookmark">
			永磁同步电机的弱磁提速控制Simulink仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		控制原理
原因：转速升高-&gt;反电动势增大-&gt;反电势接近电源电压-&gt;压差降低-&gt;电流降低-&gt;驱动转矩降低-&gt;无法加速到给定转速
方法：削弱反电动势-&gt;削弱整体磁场-&gt;永磁体磁场无法改变-&gt;产生反向磁场抵消-&gt;id产生磁场
控制框图
仿真模型
仿真结果
给定转速8000r/min 负载0-0.5 15Nm -&gt; 0.5-1 20Nm 不加弱磁控制： 加入弱磁控制： 模型报错、获取、交流：见置顶文章
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/376fcff97a29dc7ee9d08befdcd64915/" rel="bookmark">
			node&#43;react项目本地使用https进行开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备好证书 对于本地来说，可以使用mkcert来生成证书
安装：
mac：
brew install mkcert brew install nss # if you use Firefox windows
#Chocolatey choco install mkcert # or use Scoop scoop bucket add extras scoop install mkcert 生成证书
mkdir -p ~/.cert #生成证书 mkcert -key-file ~/.cert/key.pem -cert-file ~/.cert/cert.pem "localhost" #让系统信任生成的证书，只有初次生成证书时需要运行这个命令，后续通过 mkcert -key-file 生成的证书会自动被系统信任 mkcert -install express启动https服务 import express from 'express' const app = express() const httpsOption = { //证书地址 key: fs.readFileSync(path.join(os.homedir(), '.cert/key.pem')), cert: fs.readFileSync(path.join(os.homedir(), '.cert/cert.pem'), } https.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/376fcff97a29dc7ee9d08befdcd64915/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fb6b48d76d5b187da5ec5e5672ec720/" rel="bookmark">
			Altium Designer 20的中英文切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
上一篇给大家介绍了怎么安装Altium Designer 20，那么今天这一篇给大家介绍怎么对Altium Designer 20进行中英文模式切换，话不多说，上图！
1.双击打开AD 20
2.此时是英文状态下的界面
3.点击设置图标
4.点击System——General——选择Use localized resources
5.点击OK
6.选择Dispaly localized dialogs——选择Apply——选择OK
7，点击关闭按钮，重新进入AD 20，就可以得到中文模式了
如果要是选择英文模式，只需要取消勾选，并重新进入就可以了
今天的分享就到这里了，下期见！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b27d9d07a3e6e549e7a600605e115861/" rel="bookmark">
			RT-Thread学习笔记二——线程的实际使用和创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程的创建和使用可以分为以下几个具体步骤：
1.创建线程入口函数，此函数内容决定线程的功能是什么。
2.确定线程的类型（静态还是动态）以及线程的优先级，栈空间以及时间片大小。
3.创建线程，实际就是定义线程的结构体内容。
1.创建线程入口函数 static void 名称(void *parameter) { “具体内容” } 其中具体内容可循环执行（包括while（1））也可顺序执行.
2.线程类型确定以及具体线程控制块参数设定 静态线程为用户手动分配栈空间，动态由系统动态分配。静态线程为rt_thread_init，动态则为rt_thread_create创建。
线程优先级为0最高，255为系统支持的最低优先级，资源紧张的系统中一般由优先级可以设置为8或者32，一般使用STM32这种ARM Cortex-M框架的MCU，默认为32个优先级。
线程栈大小需要根据实际使用去设定，一般方法为设置一个固定值（2048，1052这种），然后观察线程栈最大使用量，为70%即为合适。
对于时间片的大小，若线程中无优先级相同的线程，则时间片大小不起作用，如果需要用到多个任务同时进行，则根据每个任务完成时间确定时间片大小，需要时间多的时间片较大。
时间片单位为系统节拍。
3.线程的创建 3.1静态线程创建 static rt_uint8_t thread1_stack[512]; //线程栈 static struct rt_thread thread1;	//线程控制块 rt_thread_init(&amp;thread1,	//线程handle "thread1",	//线程名称 thread1_entry,	//线程入口函数 RT_NULL,	//线程入口参数 &amp;thread1_stack[0], //线程栈地址 sizeof(thread1_stack),	//线程栈大小 15, //线程优先级 5);	静态线程占用内存不可释放，只能使用rt_thread_detach() 函数将该线程控制块脱离对象管理器。
线程删除使用 rt_rhread_detach(&amp;xxx);
3.2动态线程创建 /* 定义线程控制块指针 */ rt_thread_t tid = RT_NULL; /* 创建线程 */ tid = rt_thread_create( "thread_test", thread_entry, RT_NULL, 512, 10, 5); 线程删除使用 rt_rhread_detach(&amp;xxx);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b27d9d07a3e6e549e7a600605e115861/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/198d1b6bc6a563dfb28f86c0630b5bff/" rel="bookmark">
			哈希表与字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、最长回文串409 给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。 在构造过程中，请注意 区分大小写 。比如 "Aa" 不能当做一个回文字符串。 示例 1: 输入:s = "abccccdd" 输出:7 解释: 我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。 思路： 字符数量为偶数，count+数量；字符数量为奇数，count+数量-1 flag=1;flag代表的是是否有中心节点，最终长度max_length=count+flag.
/** * @param {string} s * @return {number} */ var longestPalindrome = function(s) { let map = new Map(); for(let i = 0;i &lt; s.length;i++){ map.set(s[i], (map.get(s[i]) ?? 0) + 1) } let count = 0; let max_length = 0; let flag = 0; map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/198d1b6bc6a563dfb28f86c0630b5bff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5cb75f2603066e2b60623ae043cc588/" rel="bookmark">
			MySQL的事务与索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 1.事务 事务（Transaction）是并发控制的单位，是用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位。 1.1 什么是事务 要么都成功 要么都失败 事务就是将一组SQL语句放在同一批次内去执行如果一个SQL语句出错,则该批次内的所有SQL都将被取消执行MySQL事务处理只支持InnoDB和BDB数据表类型 1.SQL 执行 A给B转账 A 1000 --&gt; B 2002.SQL 执行 B收到A的钱 A 800 --&gt; B400 1.2 事务原则 ： ACID原则 原子性，一致性，持久性，隔离性 （脏读，幻读…） 参考博客链接 https://blog.csdn.net/dengjili/article/details/82468576 原子性(Atomic)
整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（ROLLBACK）到事务开始前的状态，就像这个事务从来没有执行过一样 一致性(Consist)
一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。也就是说：如果事务是并发多个，系统也必须如同串行事务一样操作。其主要特征是保护性和不变性(Preserving an Invariant)，以转账案例为例，假设有五个账户，每个账户余额是100元，那么五个账户总额是500元，如果在这个5个账户之间同时发生多个转账，无论并发多少个，比如在A与B账户之间转账5元，在C与D账户之间转账10元，在B与E之间转账15元，五个账户总额也应该还是500元，这就是保护性和不变性。 持久性(Durable)
在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 隔离性(Isolated)
隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。 隔离导致的一些问题 脏读 指一个事务读取了另外一个事务未提交的数据 不可重复读 在一个事务内读取表中的某行数据，多次读取结果不同。（这个不一定是错误 只是某些场合不对） 幻读（虚读） ​ 是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。（一般是行影响，多了一行） 幻读和不可重复读有些类似，但是幻读强调的是集合的增减，而不是单条数据的更新。 1.3 事务隔离级别 为了解决以上的问题，主流的关系型数据库都会提供四种事务的隔离级别。事务隔离级别从低到高分别是：读未提交，读已提交，可重复读，串行化。事务隔离级别越高，越能保证数据的一致性和完整性，但是执行效率也越低，所以在设置数据库的事务隔离级别时需要做一下权衡 mysql默认是可重复读读未提交 读未提交(Read Uncommitted)，是最低的隔离级别，所有的事务都可以看到其他未提交的事务的执行结果。只能防止第一类更新丢失，不能解决脏读，可重复读，幻读，所以很少应用于实际项目。 读已提交
**读已提交(Read Committed)，在该隔离级别下，**一个事务的更新操作只有在该事务提交之后，另外一个事务才可能读取到同一笔数据更新后的结果。可以防止脏读和第一类更新丢失，但是不能解决可重复和幻读的问题。 可重复读（重要）
可重复读(Repeatable Read)，mysql默认的隔离级别。在该隔离级别下，一个事务多次读同一个数据，在这个事务还没有结束时，其他事务不能访问该数据（包括了读写），这样就可以在同一个事务内两次读到的数据是一样的。可以防止脏读、不可重复读、第一类更新丢失，第二类更新丢失的问题，不过还是会出现幻读。 串行化 串行化(Serializable)，这是最高的隔离级别。它要求事务序列化执行，事务只能一个接着一个的执行，不能并发执行。在这个级别，可以解决上面提到的所有并发问题，但是可能导致大量的超时现象和锁竞争，通常不会用这个隔离级别。 1.4 测试事务实现转账 执行事务：相关命令 -- ==========事务==================== -- mysql默认开启事务自动提交的 SET autoccommit = 0;/*关闭*/ SET autoccommit = 1;/*开启（默认）*/ -- s手动处理事务 SET autoccommit = 0; -- 关闭自动提交 -- 事务开启 START TRANSACTION -- 标记一个事务的开始，从这个开始的sql 都在同一个事务中 INSERT xx INSERT yy -- 提交 持久化（成功） COMMIT -- 回滚 回到原来的样子（失败） ROLLBACK -- 事务结束 SET autoccommit = 1;-- 开启自动提交 -- 了解 SAVEPOINT 保存点名称 -- 设置一个事务的保存点 ROLLBACK TO SAVEPOINT -- 回滚到保存点 RELEASE SAVEPOINT 保存点名称 -- 删除保存点 模拟场景 /* 课堂测试题目 A在线买一款价格为500元商品,网上银行转账.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5cb75f2603066e2b60623ae043cc588/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c4cba87e331f532ac64f9778340f61b/" rel="bookmark">
			es客户端线程池配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		业务背景 原大数据团队不再维护DB数据同步至es的服务，由我们业务团队自己维护。实现方案：使用canal监听DB binlog，将数据写入es
问题描述 为啥要看es线程池呢？因为线上突然疯狂报错es线程池被打满，但竟然看不懂该如何修改es线程池配置。线上异常堆栈如下：
EsRejectedExecutionException[rejected execution of org.elasticsearch.transport.TransportService$7@4d334adf on EsThreadPoolExecutor[bulk, queue capacity = 2000, org.elasticsearch.common.util.concurrent.EsThreadPoolExecutor@3c0a3704[Running, pool size = 16, active threads = 16, queued tasks = 2009, completed tasks = 284167676]]] at org.elasticsearch.common.util.concurrent.EsAbortPolicy.rejectedExecution(EsAbortPolicy.java:50) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369) at org.elasticsearch.common.util.concurrent.EsThreadPoolExecutor.doExecute(EsThreadPoolExecutor.java:94) at org.elasticsearch.common.util.concurrent.EsThreadPoolExecutor.execute(EsThreadPoolExecutor.java:89) at org.elasticsearch.transport.TransportService.sendLocalRequest(TransportService.java:614) at org.elasticsearch.transport.TransportService.access$000(TransportService.java:73) at org.elasticsearch.transport.TransportService$3.sendRequest(TransportService.java:133) at org.elasticsearch.transport.TransportService.sendRequestInternal(TransportService.java:562) at org.elasticsearch.transport.TransportService.sendRequest(TransportService.java:495) at org.elasticsearch.transport.TransportService.sendRequest(TransportService.java:483) at org.elasticsearch.action.support.replication.TransportReplicationAction$ReroutePhase.performAction(TransportReplicationAction.java:751) at org.elasticsearch.action.support.replication.TransportReplicationAction$ReroutePhase.performLocalAction(TransportReplicationAction.java:670) at org.elasticsearch.action.support.replication.TransportReplicationAction$ReroutePhase.doRun(TransportReplicationAction.java:658) at org.elasticsearch.common.util.concurrent.AbstractRunnable.run(AbstractRunnable.java:37) at org.elasticsearch.action.support.replication.TransportReplicationAction.doExecute(TransportReplicationAction.java:147) at org.elasticsearch.action.support.replication.TransportReplicationAction.doExecute(TransportReplicationAction.java:93) at org.elasticsearch.action.support.TransportAction$RequestFilterChain.proceed(TransportAction.java:170) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c4cba87e331f532ac64f9778340f61b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96c00c19e94ef6a24962ade84783570e/" rel="bookmark">
			HTML转PDF（Java itext）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java HTML转PDF —&gt; itext 首先需要引入jar包 &lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;html2pdf&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;/dependency&gt; package com.youxue.my.time_task.util; import com.itextpdf.html2pdf.ConverterProperties; import com.itextpdf.html2pdf.HtmlConverter; import com.itextpdf.html2pdf.resolver.font.DefaultFontProvider; import java.io.*; /** * &lt;p&gt; * html 转 pdf * &lt;p/&gt; * * @author dx * @since 2021/5/18 14:13 */ public class HTMLToPDFUtil { public static void main(String[] args) { String htmlFile = "C:\\Users\\Youxue\\Desktop\\1621309621859.html"; String pdfFile = "C:\\Users\\Youxue\\Desktop\\"+System.currentTimeMillis()+".pdf"; try { HTMLToPDFUtil.html2pdf(htmlFile, pdfFile); } catch (Exception e) { e.printStackTrace(); } } public static void html2pdf(String htmlFile, String pdfFile) throws Exception { ConverterProperties converterProperties = new ConverterProperties(); DefaultFontProvider dfp = new DefaultFontProvider(); //添加字体库 dfp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96c00c19e94ef6a24962ade84783570e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/271227e2c031cc2e80e899f0d4b53617/" rel="bookmark">
			有关时间同步配置的几个说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家都知道在linux环境下，时间同步的方式主要有ntpdate和chrony两种方式，时间同步源可以使用互联网也可以使用内部的源。
在某些情况下，如果节点不能访问外网，就需要使用内部的时间同步服务器或者搭建一个时间同步服务器，用来保障集群内节点时间的时间同步。有关如何搭建时间服务器的方法不在此进行复述，大家可以自行查找相关资料。这里仅对搭建内部时间服务器和时间同步操作遇到的问题或者经验进行分享(以CentOS7.7环境操作为例)。
时间服务器的数量
在没有办法保证节点时间完全一致的情况下，建议使用1个节点作为时间服务器，而不要使用集群的方式。
集群内时间同步的重要目前是保证集群内节点的时间一致，而不是特别强调跟互联网时间一致，否则的话，直接跟互联网进行时间同步好了，没有必要再自定搭建时间服务器。
因为机器硬件的差异，不同的节点经过长时间运行的情况下，有可能出现它们之间的时间会出现偏差。这样就导致其它节点刚刚向其中一个时间服务器同步时间之后，再周期性向另一个时间服务器同步时间之后，时间来回发生变化的情况。 因此建议只使用一个节点作为时间服务器，集群所有其余节点均向此节点进行时间同步。如果该时间同步服务器故障之后，再考虑重新搭建时间服务器的问题。
chrony方式配置
chrony是目前比较推荐的一种时间同步方式。在日常的使用中，如果更换/etc/chrony.conf配置文件中的服务器地址的话：
在客户端上重启chronyd服务的话，客户端能够很快进行时间同步并且NTP synchronized参数也会是yes状态。
在 客户端不重启chronyd服务的话，需要花费较长的时间（测试中相差5分钟，时间同步花费的时间差不多也是5分钟左右）完成时间同步，并且正常情况下NTP synchronized参数也会是yes状态。
使用chrony方式进行时间同步，如果失败的话可以从以下方面进行检查：
1.防火墙的配置 防火墙是否处于关闭状态或者对应的时间同步服务所需要的端口处于开放状态。
2.机器是否配置ntpdate定时同步 笔者在使用中出现节点上使用timedatectl命令查看NTP synchronized的值从yes变为no（重启chronyd服务变为yes过一段时间之后又变为no），并且使用chronyc sources -v命令查看对应的服务器状态为^* 10.0.X.Y 或者 ^? 10.0.X.Y 来回变化的状态。查看对应的服务状态报错：
chronyd: No suitable source for synchronisation 开始是以为配置了DNS，导致该节点可以访问外网所以状态不对。之所以这样判断是因为在系统日志中出现：
dbus[1064]: [system] Activating via systemd: service name='org.freedesktop.timedate1' unit='dbus-org.freedesktop.timedate1.service' systemd: Starting Time &amp; Date Service... dbus[1064]: [system] Successfully activated service 'org.freedesktop.timedate1' systemd: Started Time &amp; Date Service. 但是经过最终的排查，跟是否可以访问外网没有关闭，根源在于使用定时任务通过ntpdate方式进行了同步。将ntpdate的定时同步任务删除就恢复正常了。
ntpdate方式配置
ntpdate主要是通过定时任务的方式进行同步。这里强调一下，使用这种方式的时候，一定不要执行timedatectl set-ntp yes命令。
因为CentOS7.X版本自带、默认同步方式为chrony，因此如果执行timedatectl set-ntp yes命令，自动会把chronyd服务启动，使用chrony方式进行时间同步。
笔者测试将chronyd服务停止之后，执行timedatectl set-ntp yes命令之后，chronyd的服务状态变为running了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/271227e2c031cc2e80e899f0d4b53617/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b27f98738c4316e901ff629b640b8673/" rel="bookmark">
			vue 3.0 内使用element plus (1.0.2-beta.32 最开始的版本)遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果使用的element plus是 最开始的版本，不是最新版，使用的时候，如果出现了以下这种错误，
或者导航啥的不能跳转，Popper不能弹出来之类的，可以先对照一下vue的版本
我这边最开始element plus用的是
vue 的版本是
然后就出现了上面那个错误
后面我把vue的版本换成了 3.0.9，就不报错可以正常使用了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1161ec28907aaf4061e03e91537946f9/" rel="bookmark">
			node : 无法将“node”项识别为 cmdlet、函数、脚本文件或可运行程序的名称 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装完node以后，cmd 运行node -v报错
两种场景报错：（确认自己的node已经安装了，整个路径不要有中文或空格）
直接将node安装到系统盘（c盘）安装完后系统自动配置环境变量，不需要手动配置 C:\Program Files\nodejs\ 解决办法：应为是系统盘一般用户找不到该命令，只需要编辑器通过管理员的身份进行运行就可以解决！
2.将node安装到非系统盘 安装完后系统需要在环境变量上手动配置 1.安装node到指定目录，如：D:\programs\nodejs
2.在node.exe安装目录下新建两个文件夹，node_cache和node_global；
cmd输入 npm config set prefix "D:\programs\nodejs\node_global"　//修改 npm 的全局安装模块路径 npm config set cache "D:\programs\nodejs\node_cache"　//修改 npm 的缓存路径 3.配置环境变量：
系统变量
1.新建【NODE_PATH】【D:\programs\nodejs\node_global\node_modules】
2.选择 path，添加【D:\programs\nodejs】
用户变量
1.选择【PATH】后点击【编辑】按钮，将默认路径【C:\Users\admin\AppData\Roaming\npm】改为【D:\Node\node_global】
2.最后查看是否安装完成 node-v npm -v
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6498bbe0b34e613d968b9b27fe7878d/" rel="bookmark">
			解构金蝶 Apusic 中间件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接触 J2EE 也有些时间了。最近打算自己写一个 EJB 容器，琢磨了一下，打算就着技术书籍和 Apusic 的源码来搞个小研究。
先在这开个坑，毕竟每天在家，除了上班准点报道，下班又准点报道，周末连坐下来想事情的时间也被各种扯淡事情打断，也是很烦的。:)
1月24日：
先把几个重要概念梳理一下。平常我们用 javax.ejb.* 的 API 时，很少需要考虑别的东西。这里面就有中间件（容器）的功劳。举例来说，我们的客户端调用一个包含业务方法的 bean（这个 bean 可以实现 javax.ejb.SessionBean 接口），而这个 bean 是由一个 EJBHome 对象创建的。出于简化 web 开发者工作的目的，EJBHome 对象应该在 web 应用中以调用 javax.ejb.* 中接口的形式来获得。所以，EJBHome 对象的默认实现就交给中间件来做。EJBHome 对象应该负责查找和缓存 bean 实例，以及删掉调用得最少的 bean 实例的缓存。
然后我们看看 Apusic 是怎么处理各种 bean 的。在源码的 com.apusic.ejb.container.EJBManager 类中，不同类型的 bean 会触发产生不同类型的容器。处理的 bean 类型是标准的 SessionBean（包含 Stateful 和 Stateless 以及 Singleton）、EntityBean、MessageDrivenBean 。而具体生成的步骤，则在源码的 com.apusic.ejb.generator.ClientDrivenGenerator 的 generate(int) 方法中。
2月20日：
怎么把各种 EJB 接口调用的方法最终转为使用其实现类，目前观察是依靠自带的 org.objectweb 包对编译后的机器码进行替换。后面继续写写这部分的内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5fdf323f7945e2bb1081ad889eca00a/" rel="bookmark">
			使用vue ui创建vue项目(基于图形化界面的方式)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提： 1.打开cmd ，安装vue脚手架
npm install -g @vue/cli 2.若之前安装过无需重新安装；直接在cmd 中输入vue ui
若输入vue ui 后无反应，则是安装的脚手架版本太低，直接升级脚手架版本就行；输入 cnpm i -g @vue/cli
安装完成后重新输入vue ui
等待自动打开浏览器；
创建项目步骤： ①点击创建
②选择目录后,点击在此创建项目
③输入项目名称，填写git仓库建议 init project ，其他项默认
④点击下一步，选择默认配置，或手动配置；若是第一次创建项目选择手动配置；
⑤选择功能；选择Bable,Router,Linter及使用配置文件 四项开启，点击下一步
⑥相关配置；点击创建项目,保存为新预设（方便下次直接使用），点击保存预设并创建项目；
⑦等待项目创建完成（首次创建较慢）
⑧配置element-ui库（以下为视频截图），添加插件–搜索到后选中，右下角点击【安装】
配置插件设置：
⑨配置axios库：点击【依赖】–【安装依赖】
⑩点击到【任务】，点击运行
运行成功后显示编译成功，点击启动app：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe2b366cb2a1eaed31e3c285c09aca0/" rel="bookmark">
			vue实战-加入购物车一系列操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue实战-加入购物车一系列操作 1.在Detail组件中点击“加入购物车” 同时完成：
①数据存入服务器
②页面组件跳转以及传参
③会话存储
1）数据存入服务器 设置API接口（reqUpdateShopCart） detail小仓库中的处理 判断是否存入成功，返回为200则为存入成功。
会话存储 跳转到AddCartSuccess组件需要传临时的商品信息到该组件动态显示出来，所以用到会话存储
由于skuInfo的数据类型是对象，而sessionStorage没法存，得转换成字符串。
所以用JSON.stringify()
使用时再转换成对象
2）添加临时游客身份uuid 为了使得能将成功添加到购物车的数据能取出来，必须要有一个身份标识，使用uuid来随机生成一个临时游客身份标识，这样在需要购物车数据时，才能从服务器中取出存入的含有身份标识的数据。
在加入购物车的同时添加uuid标识，因为只能传参固定位，于是想到在发送请求的请求头中还可以传参。
首先，在detail仓库中得到这个uuid
在src中创建一个工具文件夹utils的uuid_token.js（为了设置获得uuid的存储以及为了它的唯一性）
uuid_token.js
import { v4 as uuidv4 } from 'uuid' export const getUUID = ()=&gt;{ let uuid_token = localStorage.getItem('GETUUID') if(!uuid_token){ uuid_token = uuidv4() localStorage.setItem('GETUUID',uuid_token) } return uuid_token } 最后将仓库中获得的uuid放入请求头headers中
成功在shopCart仓库中获得数据。
2.在购物车中的操作 1）设置获取购物车数据的API 因为存在了临时id：uuid，在shopCart仓库中可以获得购物车的动态数据
2）设置shopCart仓库 ①派发actions
②store中处理
import {reqCartList} from '@/api' const state = { shopCartList:[] } const mutations = { GETSHOPCARTLIST(state,shopCartList){ state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fe2b366cb2a1eaed31e3c285c09aca0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1a4248c5d6034741cee782f635104b9/" rel="bookmark">
			递归简介&#43;递归例题(使用递归输出1~100)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.定义:递归是一种思想,应用在编程中体现为方法调用方法本身. 2.例题;使用递归的方法打印1到100 public class Print1_100Myself { public static void printx(int start,int end){ if(start&gt;end) { return; }else { System.out.println(start); start++; printx(start, end); } } //主函数(main方法)，程序入口(此处启动,调用printx方法,输入参数调用此方法) public static void main(String[] args) { printx(1,100); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b6224b17b491b5be736d91ba2a154b1/" rel="bookmark">
			idea启动报错Internal error.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		idea启动报错Internal error. Please refer to https://jb.gg/ide/critical-startup-errors java.util.concurrent.CompletionException: org.picocontainer.PicoRegistrationException: Key com.tang.intellij.lua.luacheck.LuaCheckSettings duplicated
java.util.concurrent.CompletionException: org.picocontainer.PicoRegistrationException: Key com.tang.intellij.lua.luacheck.LuaCheckSettings duplicated)
造成原因：
插件安装重复，之前安装了两个easycode插件导致idea崩溃。
解决方法
插件冲突重复：lua插件重复
进入C:\Users\xxx\AppData\Roaming\JetBrains\IntelliJIdea2021.1\plugins
删除多余重复的插件！
问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cf4832d82ed4200a5df43be4acb6897/" rel="bookmark">
			elementUI下拉选项加多选框功能实现（自己添加“全部”选项）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文包含三部分：
1.下拉加多选框
2.升级—添加全部选项
3.需求改版完善 一、下拉加多选框 效果如下图：
封装如下： &lt;template&gt; &lt;div class="select-checked"&gt; &lt;!-- 下拉加多选框 --&gt; &lt;el-select v-model="value" multiple placeholder="请选择" :popper-append-to-body="false" @remove-tag="removeTag" &gt; &lt;el-option v-for="item in options" :key="item.value" :label="item.label" :value="item.value" &gt; &lt;el-checkbox v-model="item.check" @change="isChecked(item)"&gt; {{ item.label }} &lt;/el-checkbox&gt; &lt;/el-option&gt; &lt;/el-select&gt; {{ value }} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'SelectChecked', components: {}, props: { options:{ type: Array } }, data() { return { value: [] } }, methods: { // 多选框触发 isChecked(item) { if (item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cf4832d82ed4200a5df43be4acb6897/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e786a85f4018b1c6fed3fedef717f864/" rel="bookmark">
			MySQL详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 1.初识mysql JavaEE：企业级Java开发 Web 前端（页面：展示：数据）后台 （连接点：连接数据库JDBC,连接前端（控制视图跳转，给前端传递数据））数据库（存数据，Txt,Excel,Word） 只会写代码，学好数据库，基本混饭吃！操作系统，数据结构与算法！当一个不错的程序猿！离散数学，数字电路，体系结构，编译原理。+实战经验，优秀程序猿 1.1 为什么学数据库 岗位需求 现在的世界，大数据时代，得数据者得天下被迫需求：存数据数据库是所有软件体系中最核心的存在 DBA 1.2 什么是数据库 数据库：(DB,DataBase) 概念:数据仓库，软件，安装在操作系统之（windows,Linux。mac）上的！SQL,可以存储大量的数据，500万!作用:存储数据，管理数据 Excel 1.3 数据库分类 关系型数据库：(SQL) MySQL, Oracle, sql Server, DB2, SQLite 通过表和表之间，行和列之间的关系进行数据的存储，学员信息表，考勤表，······ 非关系型数据库：(NoSQL) Not Only Redis, MongDB非关系型数据库，对象存储，通过对象自身的属性来决定。 DBMS(数据库管理系统) 数据库的管理软件，科学有效的管理我们的数据，维护和获取数据；MySQL ，数据管理系统！ 1.4 MySQL简介 MySQL是一个关系型数据库管理系统。发展史： 前世： 瑞典MySQL AB 公司 今身： 属于 Oracle 旗下产品 MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 开源的数据库软件
体积小，速度快，总体拥有成本低，招人成本比较低，所有人必须会～。
中小型网站，或者大型网站，集群
官网： https://www.mysql.com/
1.5 MySQL基本的命令行操作 mysql -uroot -p123456 -- 连接数据库 update mysql.user set authentication_string=password('123456') where user='root' and host='localhost'; -- 修改用户密码 flush privileges; -- 刷新权限 ---------------------------- -- 所有的语句都使用;结尾 show databases; -- 查看所有的数据库 mysql&gt; use school; -- 切换数据库 use 数据库名 Database changed mysql&gt; show tables; -- 显示数据库中所有表的信息 mysql&gt; describe student; -- 显示表的详细信息 create database zyy; -- 创建一个数据库（这里过于简洁，后面详细介绍） exit -- 退出连接 -- 单行注释 /** 多行注释 */ 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e786a85f4018b1c6fed3fedef717f864/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af9d5ad473f1fc5e6b87daf1d88ec242/" rel="bookmark">
			c&#43;&#43;的一些排序（数组，map）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数组 1、普通数组升序 数组升序
void displayArr(int* arr) { for(int i = 0; i &lt; 10 ; i++) printf(" %d\t",arr[i]); printf("\n"); } void sortArr() { int arr[10] = {5,43,654,88,1,6,40,7777,13,5}; displayArr(arr); cout &lt;&lt; endl; //普通排序 sort(arr,arr + 10); printf("the normal sort is : "); displayArr(arr); } console
the normal sort is : 1 5 5 6 13 40 43 88 654 7777 2、自定义升序 数组自定义
void displayArr(int* arr) { for(int i = 0; i &lt; 10 ; i++) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af9d5ad473f1fc5e6b87daf1d88ec242/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/281f4099a6bb0f4efce5d4c27383033c/" rel="bookmark">
			使用 React 为代码块创建打字机效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用打字机效果，单词一次显示一个字母，而不是一次显示所有单词，使文本看起来好像是实时书写的。您可以在Codepen 的登录页面上找到代码块打字机效果的示例，该示例使用语法高亮（一种特殊的颜色格式）来轻松地以代码的形式显示书面文本。
在本文中，我们将学习如何使用 React 从头开始构建类似的代码块打字机效果。我们还将演示一种使用预先存在的打字机包的替代方法。要学习本教程，您需要具备 React 的基本知识。我们将介绍以下内容：
安装依赖项
打造打字机效果
打字机展示区
添加闪烁的光标
将打字机效果添加到文本
删除和重新输入文本
高亮代码语法
使用打字库
您可以在此 GitHub 存储库中找到本教程的完整源代码。让我们开始吧！
安装依赖项 如果您还没有安装 React，请在您的系统中导航到您的项目目录，打开一个命令行窗口，然后在其中运行以下 bash 脚本：
npx create-react-app typewriter 上面的命令创建了一个 React 项目文件夹，该文件夹调用typewriter了构建我们的应用程序所需的所有依赖项。为了轻松设计我们的应用程序，我们将使用 Tailwind CSS。您可以通过在 CLI 中运行以下命令来安装 Tailwind CSS：
npm install -D tailwindcss postcss autoprefixer npx tailwindcss init -p 安装完成后，修改tailwind.config.js文件以允许支持jsx元素，如下所示：
/** @type {import('tailwindcss').Config} */ module.exports = { content: [ "./src/**/*.{js,jsx,ts,tsx}", ], theme: { extend: {}, }, plugins: [], } 最后，将以下 Tailwind CSS 指令添加到 的顶层index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/281f4099a6bb0f4efce5d4c27383033c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8782e99540fb278b47fdfed8c84d78b9/" rel="bookmark">
			Java控制台简易计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java控制台简易计算器（两数运算） 源代码 使用while循环，Scanner方法 ，Switch语句实现交互效果
package com.ge.method; import java.util.Scanner; public class Demo04 { //计算器 public static void main(String[] args) { //定义一个变量为true，while循环运行，变量为false while循环终止 boolean test = true; while (test) { System.out.println("======= 计算器 ========"); System.out.println("=======输入1计算加法======="); System.out.println("=======输入2计算减法======="); System.out.println("=======输入3计算乘法======="); System.out.println("=======输入4计算除法======="); System.out.println("======= 输入5退出 ======="); //创建一个扫描器对象，用用于接收键盘数据 Scanner sc = new Scanner(System.in); int i = sc.nextInt(); //定义两个变量用于接收两个数 int first; int two; //通过 Switch语句 选择加减乘除进行计算 switch (i) { case 1: //加法 System.out.print("请输入第一个数："); first = sc.nextInt(); System.out.print("请输入第二个数："); two = sc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8782e99540fb278b47fdfed8c84d78b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b1c0ec5277ffd525fe2b557656bcb5/" rel="bookmark">
			360安全卫士比2345安全卫士好
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		360安全卫士和2345安全卫士，相信这两款软件都是现在非常流行的软件了，无论是使用频率还是使用率都非常高。但是两者的区别也比较明显,360安全卫士有自己的优势和劣势。下面来看一下两者的对比。首先从功能上来说,360安全卫士是一款功能很强大的工具软件，几乎没有弱点。并且360安全卫士也支持用户自定义设置，如果安装一个软件是为了更好解决电脑安全问题的话，那么把手机和电脑上各种软件都装上360安全卫士就是一个很好的解决办法了。在这两款产品中，可以看到360都支持自定义设置以及自带卸载功能等。但是从实际体验来看，各有自己的优势和不足之处:139反病毒引擎是专门针对移动端、电脑端的木马病毒防护软件，而这款2345的反病毒引擎则采用了内置 SNMP (System Network Protection Generator)技术。而在用户使用过程中发现这两款软件有很多不同点:360提供了很多自定义设置选项以及自带卸载功能;2345则采用了最经典且实用的360安全卫士和搜狗百科（QQ浏览器）等多种常用软件。下面我们就来看一下这两款产品都有哪些不足之处吧！
一、360安全卫士支持自定义设置
360安全卫士，对于电脑的一些设置比较实用，例如病毒检测、用户隐私保护、反病毒管家等功能。但是有一些功能只能在360安全卫士上实现。比如反病毒管家可以限制恶意代码和反病毒软件对用户电脑的访问。但360安全卫士可以限制你电脑中使用的病毒数量、杀毒软件的服务权限以及病毒处理机制。其中反病毒引擎是最实用的功能之一，一般手机端的病毒防护一般都是针对手机 APP的。因此电脑中使用一款360安全卫士能够有效地帮助电脑安全防护手机端。所以360安全卫士虽然是一款免费软件，但是支持用户自定义设置这个功能还是很实用的。另外360反病毒卫士支持一些系统自订选项：例如 Windows的自动更新或者其他支持自定义功能的系统配置文件。比如 Windows 7系统自订的应用管理器、 Windows 7/8系统自订的文件管理器系统自订的更新、其他支持自定义设置的系统配置文件等等。而从具体应用管理器显示内容来看，主要是针对一些系统使用频率比较高的操作以及系统服务等设置内容。这些应用管理器中基本上是没有实用功能的。
二、自带卸载功能
360安全卫士自带卸载管理器，用户可以将未安装软件卸载到360桌面上，也可以将未安装软件卸载到360管家里，方便用户轻松完成卸载。我们将卸除部分软件在使用中所产生的垃圾删除掉后再安装到桌面上。其实从这个功能本身来说也是非常方便实用。2345安全网格中拥有该功能的软件很多了。不过安装前一定要确认是支持卸载功能的。不过在实际使用中发现两款软件均有卸载功能，并没有什么明显区别。因此想要选择卸载能力强的软件的话，最好选择360安全网格中的卸载功能更为合适。
三、不推荐使用360安全卫士作为网络安全工具
360安全卫士是一款功能强大的网络安全工具，而其最大的缺点就是没有针对木马以及病毒防护能力。虽然说360安全卫士对于安卓手机用户来说，安装程序非常方便，但是当360安全卫士出现问题的时候却不知道如何解决。而且有些时候，由于360安全卫士过于简单和粗暴，很容易让用户对其产生误解。因此在使用过程中，很多用户都会对此有一些意见甚至诟病。首先从杀毒层面来讲，现在的软件除了最基本的木马拦截外，还多了很多病毒检测功能。在某些情况下如果用户发现自己电脑存在病毒的话，只需要使用360安全卫士进行杀毒即可快速清除恶意软件并排除电脑上已经感染的病毒或木马。如果不想让一个网站成为木马攻击的目标的话，那就可以使用2345安全卫士进行全面防护了！所以说360安全卫士没有针对所有的木玛病毒进行防护而导致360并不能真正起到杀毒的作用！其次从网络安全工具来看，现在很多人都喜欢在电脑上下载各种软件来阅读、浏览网页、下载游戏、玩游戏等等。而这些软件往往存在着大量后门程序，对于用户来说存在着很大安全隐患！
四、用户安装并不困难
360安全卫士和2345安全卫士都可以在安装界面看到一个非常简单的“应用市场”，对于想要使用软件的用户来说非常友好。用户只需要在浏览器上打开360客户端和360安全卫士即可安装。360客户端只有“360桌面”一种安装方式，其它方式可以进行下载、安装和使用。而且，用户还可以选择在电脑或者手机端安装。2345用户可以选择360应用市场安装或者360浏览器安装。两款软件都可以在软件内实现本地卸载、安装以及导出工具等操作。而且都不需要用户进行额外操作就能实现安装功能以及卸载等操作。不过需要注意的是：安装程序也会占用一定的内存。可以看出360安全卫士是支持本地卸载和导出工具这两种方式分别满足一部分用户需求。而2345则是支持本地导出工具这一方式方便一部分用户。
五、总结与建议：
在对两款产品的实际体验中,360安全卫士都有自己的优势，但是2345安全卫士在功能上要更加全面一些。360安全卫士对电脑病毒的处理速度要比2345更快，并且也提供了多种自定义设置。对于用户的使用需求和功能需要有一个明确的认识。所以对于这两款产品的对比我们暂且不说哪个更优，但是我们要知道谁是优！所以才更应该关注二者的差异和不足之处吧！综上所述:360安全工程师在两款产品中都非常出色，不管是从功能都非常强大以及实用功能都非常多。但是由于2345安全卫士采用了最新的 SNMP技术和360安全卫士有很多不同之处。所以这款产品在使用过程中也需要做更多的调整和改进！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/123/">«</a>
	<span class="pagination__item pagination__item--current">124/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/125/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>