<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/648cf885d27287045ec0f6077c6e0ad0/" rel="bookmark">
			CorelDRAW2022订阅版本最新更新内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CDR2022年9月版本更新内容 利用引人注目的全新设计模式，将您的创意提升到新的高度，并探索50多个实用专案，协助您提升技能。新的缩放工具可在调整物件比例时提供完整的灵活性和精确度，而汇出工作流程的增强功能可加快产生结果的速度。从CorelDRAW Ideas Portal思想门户中获得客户要求的其他一些增强功能，包括web文件支持、重新设计的“新建文档”对话框、用户界面增强功能等。
CorelDRAW是主要用于印刷和印刷输出人员的排版软件。CorelDraw是图形设计人员必不可少的矢量绘图和排版软件。广泛用于商标设计，徽标制作，模型图，插图图，排版和分色输出等许多领域。
该软件界面设计友好，操作精微细致;它提供了设计者一整套的绘图工具包括圆形、矩形、多边形、方格、螺旋线，并配合塑形工具，对各种基本以作出更多的变化，如圆角矩形，弧、扇形、星形等。同时也提供了特殊笔刷如压力笔、书写笔、喷洒器等，以便充分地利用电脑处理信息量大，随机控制能力高的特点。
该软件的文字处理与图象的输出输入构成了排版功能;文字处理是迄今所有软件最为优秀的；其支持了大部分图象格式的输入与输出；几乎与其他软件可畅行无阻地交换共享文件。所以大部分与用PC机作美术设计的都直接在CorelDraw中排版，然后分色输出。
该软件让使用者轻松应对创意图形设计项目;市场领先的文件兼容性以及高质量的内容可帮助使用者将创意变为专业作品：从与众不同的徽标和标志到引人注目的营销材料以及令人赏心悦目的Web图形，应有尽有。
为便于设计需要，该软件提供了一整套的图形精确定位和变形控制方案。这给商标、标志等需要准确尺寸的设计带来极大的便利。
市场领先的文件兼容性以及高质量的内容可帮助您将创意变为专业作品：从与众不同的徽标和标志到引人注目的营销材料以及令人赏心悦目的Web图形，应有尽有。
CorelDRAW界面设计友好，空间广阔，操作精微细致。它提供了设计者一整套的绘图工具包括圆形、矩形、多边形、方格、螺旋线，等等，并配合塑形工具，对各种基本以作出更多的变化，如圆角矩形，弧、扇形、星形等。同时也提供了特殊笔刷如压力笔、书写笔、喷洒器等，以便充分地利用电脑处理信息量大，随机控制能力高的特点。
为便于设计需要，CorelDRAW提供了一整套的图形精确定位和变形控制方案。这给商标、标志等需要准确尺寸的设计带来极大的便利。 颜色是美术设计的视觉传达重点；CorelDRAW的实色填充提供了各种模式的调色方案以及专色的应用、渐变、图纹、材质、网格的填充，颜色变化与操作方式更是别的软件都不能及的。而CorelDRAW的颜色匹管理方案让显示、打印和印刷达到颜色的一致。
CorelDRAW的文字处理与图像的输出输入构成了排版功能。文字处理是迄今所有软件更优秀的。其支持了绝大部分图像格式的输入与输出。几乎与其他软件可畅行无阻地交换共享文件。所以大部分与用PC机作美术设计的都直接在CorelDRAW中排版，然后分色输出。 CorelDRAW深受全球各地使用者与企业的信赖，以专业的效果展现他们的构思，提升商业效益。
从以下例子可得知CorelDRAW是如何协助使用者输出各种不同的成品： 营销文宣 无论是对于初级或专业级设计师，CorelDRAW都是理想的工具，协助设计师制作营销文宣。从标志、产品与企业品牌的识别图样，乃至于宣传手册、平面广告与电子报等特定项目，CorelDRAW能让您自行建立宣传文宣，设计宣传活动数据，既能节省时间、成本，更能展现高度创意。
服饰 CorelDRAW是服饰业的理想解决方案。具有多种强大的工具和功能，准确性高且使用简便，能够协助建立服饰设计，将服装发表上市，深受设计师与打版师的信赖。愈来愈多的主要服装设计公司采用CorelDRAW作为打样和设计的解决方案。
招牌制作 CorelDRAW具有建立各式各样招牌所需的功能。其中包含超过100 种的滤镜，可用于汇入和汇出美工图案与工具，轻松建立自订的图形并配置文字。包含招牌设计人员长久以来需求的多项全新功能与增强功能。因此，CorelDRAW是招牌制作人员喜爱的图形软件包。
雕刻与计算机割字 CorelDRAW是雕刻、奖杯、奖牌制作与计算机割字等业界喜爱的绘图解决方案。
CorelDRAW 2022的主要功能有哪些? 安装CorelDRAW 2022后，我们就可以使用它进行创作和设计了。下面我带大家了解一下CorelDRAW 2022的主要功能有哪些
1、页面布局
CorelDRAW SE 2021新增了多页视图的功能，在查看菜单中，勾选多页视图，就可以启用多页视图。在多页视图中，我们可以同时查看并编辑多个页面的内容。同时，我们还可以使用标尺、辅助线，网格等工具，这些小工具能够帮助我们快速对齐内容，准确地将需要的内容放到正确的位置上，十分方便。
图5：页面布局
2、照片编辑
CorelPHOTO-PAINT具备基于图层的照片处理能力，将照片导入编辑器后，我们可以使用预设效果轻松实现照片的调光调色。同时，编辑器还提供了涂抹消除，图像校正、照片克隆、颜色替换等功能。
图6：编辑照片
3、自定义工作区
①CorelDRAW SE 2021中预设了标准、触摸和专长工作区，我们可以在软件的欢迎页面进行切换。为了满足不同用户在不同场景下的使用习惯，软件还提供了自定义工作区的功能。
②运行软件，点击工具菜单，再点击选项，然后点击自定义，会弹出自定义窗口。在这个窗口中，可以自定义CorelDRAW 的外观、命令栏、命令和调色板。
图7：自定义工作区
4、排版
CorelDRAW SE 2021的文本工具不仅拥有丰富的字体字形库，还集成了OpenType功能，它提供了数字、字母、连笔字等的替换功能，可以协助排版用户更快地设计排版。
图8：排版功能
本篇文章为大家详细介绍了CorelDRAW2022功能，CorelDRAW2022的主要功能有哪些。对于平面设计师来说，一款实用的设计软件是必不可少的。
CorelDRAW2022 订阅版 mac - 安装包下载:
https://wm.makeding.com/iclk/?zoneid=49497
CorelDRAW2022 订阅版 win - 安装包下载:
https://wm.makeding.com/iclk/?zoneid=49498
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af00d306939833bbb5c62a5a68466cd1/" rel="bookmark">
			centos安装intel i219v网卡驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先查看的网卡型号
lspci | grep -i ethernet
针对i219-v网卡的linux版本的驱动下载地址
https://downloadcenter.intel.com/zh-cn/download/15817?_ga=1.159975677.114505945.1484457019
下载完之后，通过u盘拷到安装centos的电脑里面，也只能通过u盘，移动硬盘这些工具了，因为没有联网啊
检查依赖环境
复制代码
[bigdata@slave3 ~]$ rpm -qa | grep kernel
kernel-tools-libs-3.10.0-693.el7.x86_64
kernel-headers-3.10.0-693.el7.x86_64
abrt-addon-kerneloops-2.1.11-48.el7.centos.x86_64
kernel-tools-3.10.0-693.el7.x86_64
kernel-devel-3.10.0-693.el7.x86_64
kernel-3.10.0-693.el7.x86_64
[bigdata@slave3 ~]$ rpm -qa | grep gcc
gcc-4.8.5-16.el7.x86_64
gcc-gfortran-4.8.5-16.el7.x86_64
libgcc-4.8.5-16.el7.x86_64
gcc-c+±4.8.5-16.el7.x86_64
复制代码
把安装包解压
复制代码
[bigdata@slave3 Downloads]$ ls
e1000e-3.4.0.2.tar.gz em-7.6.1.tar.gz
[bigdata@slave3 Downloads]$ ll
total 560-rw-r–r–. 1 bigdata bigdata 299609 May 25 21:28 e1000e-3.4.0.2.tar.gz-rw-r–r–. 1 bigdata bigdata 267524 May 25 22:01 em-7.6.1.tar.gz
[bigdata@slave3 Downloads]$ tar -zxf e1000e-3.4.0.2.tar.gz
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af00d306939833bbb5c62a5a68466cd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c57b3e10201d5fd373a8c460ccd01a70/" rel="bookmark">
			vue ui 创建项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：首先要确定安装了 node.js ，并且全局安装了脚手架 vue-cli 。然后才能继续以下步骤：
1、在你要创建项目的文件夹里打开 cmd ，输入 vue ui：
2、跳转到下面的页面，点击“在此创建新项目”：
3、输入项目名，点击“下一步”：
4、选择手动配置，下一步：
5、选择以下的配置，然后下一步：
6、按照如下配置，点击创建项目：
7、 这里我选择不保存为预设：（按照你自己需求）
8、安装依赖：
9、安装 axios ：
10、可以进入到项目，输入 npm run serve 运行：
11、运行成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91bc9cfc7ae9e8d642168c46b2375a6a/" rel="bookmark">
			Ant-design-vue更换主题颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package.json
"antd-theme-generator": "^1.2.5", "antd-theme-webpack-plugin": "1.2.0", "less": "^3.9.0", "less-loader": "^4.1.0", //如果高版本的less不能实现主题颜色切换less就换成2.7.3版本的 //less这个2.7.3版本应该是版本太低有个bug，在我的项目中页面加载完后会闪一下变成白屏再重新加载 vue.config.js
const AntDesignThemePlugin = require("antd-theme-webpack-plugin"); const options = { antDir: path.join(__dirname, "./node_modules/ant-design-vue"), //antd包位置 stylesDir: path.join(__dirname, "./src/styles"), //主题文件所在文件夹 varFile: path.join(__dirname, "./src/styles/variables.less"), // 自定义默认的主题色 mainLessFile: path.join(__dirname, "./src/styles/index.less"), // 项目中其他自定义的样式（如果不需要动态修改其他样式，该文件可以为空） themeVariables: [ "@primary-color", "@success-color" ], //要改变的主题变量 indexFileName: "./public/index.html", // index.html所在位置 outputFilePath: path.join(__dirname, "./public/color.less"), //提取的less文件输出到什么地方 generateOnce: false // 是否只生成一次（if you don't want to generate color.less on each chnage in code to make build process fast in development mode, assign it true value.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91bc9cfc7ae9e8d642168c46b2375a6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20d815680698ecd4bd1833e896c47591/" rel="bookmark">
			解决VUE打包后与nginx代理出现加载速度超级慢的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其中的原因是我们在vue打包的过程中打包了一些没有用的东西，造成数据量过大使得页面加载速度超级慢的原因，最常见的页面加载速度就就 看板，这种页面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62b0b1d4af56dd41aefc37b827820a1b/" rel="bookmark">
			Aurora的工程化问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Aurora的工程化问题解决方案 前言 ​针对Aurora在实际工程的例化应用问题上，本人经过以往经验进行可行性方案分享，其中有关Aurora的例化过程及不进行详细介绍，可自行查询其他博客学习，望补充指正，谢谢。
（补充：该文里的aurora默认为全双工模式）
简介 ​本文主要阐述Aurora协议在多通道例化上的应用问题，以及针对实际硬件的GTH通信质量较差（ibert眼图测试），如何继续利用Aurora的均衡模式补救，已达到正常通信的标准。
案例 场景一 主板卡与多个子板卡的Aurora通信，主板卡内需对Aurora进行多通道例化，其中主板卡与单个子板卡是单通道Aurora通信。
问题描述 设置好单通道Aurora的IP后，生成IP examp design工程，对顶层的端口进行修改后，进行多次例化后综合，place design 报错，如下：
aurora IP 设置 aurora 顶层端口修改 ​ aurora例化 ​
place design 报错 ​ 分析解决 根据报错的文件位置找到如下模块：
place design error中指出驱动gt_common必须是相同的时钟或是邻近的时钟。
简单的说多次例化，导致gt_common模块被多次例化，gt_refclk（gt参考时钟）是由IBUFDS_GTE3转换来，这里对应了多个qpll1_refclk端口，这里在实际资源布线中不需要多次定义使用qpll_refclk，因此将gt_commmn模块单独放到顶层，不用和aurora一起例化多次。这里涉及到aurora64b66b用到的gt参考时钟内部采用qpll（详见https://zhuanlan.zhihu.com/p/494758359）锁相， 其中相邻的quad可以共用同一个gt_refclk，这多次例化的aurora channel 分布在相邻的两个quad，可以共用一个gt_refclk时钟资源。
顶层代码修改后如下：
该警告可以不用管，不会影响aurora的通信，若需要可以修改所指文件，将下图约束注释重新综合即可。
场景二 板卡之间的ibert测试（5Gbps下）眼图结果如下：
ibert眼图测试 通过调整advanced settings里的红色红框的参数，主要是调整spread spectrum clocking（扩频时钟），具体需要同硬件工程师交流，因为导致眼图信号差的原因有很多，该方案主要是硬件上没有什么优化空间的情况下采用。 ibert IP核 通过设置后眼图正常，如下 设置后ibert眼图测试 问题描述 问题是aurora64b66b里的advanced不支持调整扩频时钟，即便降低线速率也无法稳定通信，因此无法使用aurora64b66b，如何继续使用aurora协议。
分析解决 方法如下：
aurora64b66b替换为aurora8b10b；aurora8b10b的设置里让gt子模块放到IP的外边，可供设置，此处打钩如下；找到aurora8b10b_0_gt的IP，修改里面的advanced设置，其中扩频时钟就可以设置了，只需将ibert眼图测试成功的参数配置进去后更新生成IP即可。
transceiver IP 本人通过实践验证该方法可以在速率降到2.5Gbps下的aurora8b10b解决，但是由于改动了相关的参数，由于原本信道的通信质量较差，两板卡间的aurora链路可能不能自适应建立，channel_up信号不能保持置1，解决方法是需在两板卡上电后分别对aurora模块中的GT_RESET进行长约1ms以上的高电平复位（本人使用1s复位）。
aurora8b10b通信测试，channel_up一直为1，链路正常 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1142e604192727646f0ad516b954a959/" rel="bookmark">
			向量数据库入坑指南：使用 Faiss 实现一个最简单的向量检索功能 (二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇内容中，我们了解了什么是 Faiss，以及如何将文本内容转换为向量数据。本篇文章中，我们来使用 Faiss 实现向量检索功能。
使用 Faiss 实现最简单的向量检索功能 接下来，我们将使用 Faiss 实现一个小功能，针对哈利波特小说全集内容，接触向量检索技术，完成相似内容搜索的功能。与我们使用 “CTRL+F” 或者把数据倒入 MySQL，使用 “%LIKE%” 去进行全文匹配不同，我们的工具性能，将会远远高于一般的检索方式。
为了能够得到“快到飞起”的执行效率，在使用 Faiss 查询大量数据之前，我们首先需要和其他追求效率的数据库软件一样，为数据建立索引，我们先来看看最简单的平面索引：IndexFlatL2。
借助平面索引，完成基础的相似内容查询功能 Faiss 中最简单的索引，便是没有使用任何花哨技巧（压缩、分区等）的平面索引：IndexFlatL2。当我们使用这种索引的时候，我们查询的数据会和索引中所有数据进行距离计算，获取它们之间的 L2 距离（欧几里得距离）。因为它会尽职尽责的和所有数据进行比对，所以它是所有索引类型中最慢的一种，但是也是最简单和最准确的索引类型，同时，因为类型简单，也是内存占用量最低的类型。而它采取的遍历式查找，也会被从业者打趣称之为“暴力搜索”。
查询数据都在空间中的进欧式距离计算 在上文中，我们已经准备好了 768 维度的高维向量数据，接下来，我们就用这些数据来建立我们的“第一堆向量数据”的索引：
import faiss dimension = sentence_embeddings.shape[1] index = faiss.IndexFlatL2(dimension) index.add(sentence_embeddings) 将我们数据的维度信息传递给 faiss.IndexFlatL2 函数，建立一个空的索引容器，然后使用 index.add(sentence_embeddings) 将我们在之前处理好的向量数据灌入这个索引容器中。
执行完毕上面的代码之后，我们执行 index.ntotal 来查看索引的数据是否正确：
# &gt;&gt;&gt; index.ntotal 60028 确认所有数据都被索引之后，我们来写一段最简单的程序，来进行查询，为了演示“相似性检索”，而不是“关键词匹配”，我们来搜索一个离谱的原文肯定没有的内容“哈利波特猛然睡醒”：
topK = 5 search = model.encode(["哈利波特猛然睡醒"]) D, I = index.search(search, topK) df['sentence'].iloc[I[0]] 执行程序之后，我们将能够看到比较符合预期的神奇结果：
# &gt;&gt;&gt; topK = 5 # &gt;&gt;&gt; search = model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1142e604192727646f0ad516b954a959/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/145924026cea622db2961d3aea7ac98c/" rel="bookmark">
			通过 pdftoppm 实现PDF转图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍如何在 Linux 系统中使用 pdftoppm 指令将 PDF 文件转为 PNG、JPEG 等图片文件。
安装 pdftoppm 指令
在 Linux 系统中 pdftoppm 指令可以透过 poppler 套件来安装，不同的 Linux 发行版会有不同的套件名称，但大同小异：
Debian、Ubuntu、Mint Linux sudo apt install poppler-utils
RHEL、CentOS、Fedora Linux sudo dnf install poppler-utils
OpenSUSE Linux sudo zypper install poppler-tools
Arch Linux sudo pacman -S poppler
将 PDF 转为图片文件
pdftoppm 指令可以将 PDF 文件转换为各种格式的图片文件。
若要将 PDF 文件转换为 PNG 图片文件，可加上 -png 参数，并指定输入的 PDF 文件，以及输出图片的文件名前缀：
将 input.pdf 转换为 PNG 图文件 pdftoppm -png input.pdf output
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/145924026cea622db2961d3aea7ac98c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b21e18e31efee06b58b04d9425ab132/" rel="bookmark">
			c#入门程序-简易计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：编写一个简易计算器程序，要求在程序中能够捕获到被0除的异常与算术运算溢出的异常。当程序退出运行时，打印出字符串“谢谢使用”。
using System; //author:小徐爱搞事 //time:2022.10.11 namespace _04 { class Program { static void Main(string[] args) { //4.编写一个简易计算器程序，要求在程序中能够捕获到被0除的异常与算术运算溢出的异常。当程序退出运行时，打印出字符串“谢谢使用”。 //Console.WriteLine("Hello World!"); bool b = true;//循环条件，目的是使程序退出while循环 try//用来捕获被0除的异常与算数溢出的异常 { while (b)//循环程序 { Console.Write("请输入第一个数："); double num1 = double.Parse(Console.ReadLine()); Console.Write("请从+-*/中选择一个,输入其它将退出程序："); string jugeinput = Console.ReadLine(); if (jugeinput == "+") { Console.Write("请输入第二个数："); double num2 = double.Parse(Console.ReadLine()); double c = Add(num1, num2); Console.Write(c); } else if (jugeinput == "-") { Console.WriteLine("请输入第二个数："); double num2 = double.Parse(Console.ReadLine()); double c = Sub(num1, num2); Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b21e18e31efee06b58b04d9425ab132/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/739fada487ef2b414ee3c9b719e8f5f5/" rel="bookmark">
			代码混淆是什么？代码混淆的方法有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是代码混淆？ 代码混淆 (Obfuscated code)是将计算机程序的代码，转换成一种功能上等价，但是难于阅读和理解的形式的行为。代码混淆可以用于程序源代码，也可以用于程序编译而成的中间代码。而混淆后的代码很难被反编译，即使反编译成功也很难得出程序的真正语义，通过进行代码混淆可以有效提升应用被逆向破解的难度。
代码混淆工具下载https://www.evget.com/category/30
作为一种跨平台的解释型语言，Java 源代码被编译成中间“字节码”存储于class文件中。由于跨平台的需要，这些字节码带有许多的语义信息，因此很容易被反编译成Java源代码。为了很好地保护Java源代码，开发者往往会对编译好的class文件进行混淆处理。就是对发布出去的程序代码进行重新组织和处理，使得处理后的代码与处理前的代码能够完成相同的功能，但是混淆后的代码很难被反编译，即使反编译成功也很难得出程序的真正语义。 二、代码混淆的方法有哪些？ 目前对于代码混淆的方法，普遍是以Collberg的理论为基础，分为布局混淆、数据混淆、控制混淆和预防混淆四种类型：
1.布局混淆：是指删除或者混淆软件源代码或者中间代码中与执行无关的辅助文本信息，增加攻击者阅读和理解代码的难度。
2.数据混淆：是修改程序中的数据域，而对代码段不作处理。常用的数据混淆方式有合并变量、分割变量、数组重组、字符串加密等。
3.控制混淆：也称流程混淆，它是改变程序的执行流程，从而打断逆向分析人员的跟踪思路，达到保护软件的目的。
4.预防混淆：一般是针对专用的反编译器设计的，目的就是预防被这类反编译器反编译。他是利用特定的反编译器或反混淆器的弱点进行专门设计。预防混淆对于特定的反编译器非常有效，所以在使用时要综合利用各种反编译器的特点进行设计。
三、有哪些常见代码混淆工具？ WinLicense是一个强劲的保护系统， 专为了那些想保护自己的程式不被先进的反向工程和黑客软件破解的软件开发者而开发的。开发者不需要更改任何的原代码，不需要程式编制的经验就可使用WinLicense。
vmprotect 是新一代的软件保护系统，将保护后的代码放到虚拟机中运行，这将使分析反编译后的代码和破解变得极为困难。使用 MAP 文件或内建的反编译引擎，您可以快速选择需要保护的代码。
.NET Reactor是用于为.NET Framework编写的软件的功能强大的代码保护和软件许可系统，并且支持生成.NET程序集的所有语言。
.NET Reactor支持所有的dotnet实现，包括.NET Framework、.NET 5.0、.NET Core和ASP.NET Core。通过这种方式，Xamarin、Unity和Blazor组件得到了全面的保护支持。
Allatori Java obfuscator 是第二代Java代码混淆器，为您的知识产权提供全方位的保护。大部分第二代混淆器都具有保护功能。Allatori除了保护功能之外，还附加了一系列的功能，几乎可以抵御一切的代码攻击。同时，Allatori可以让您的程序体积更小，速度更快，效果简直让人难以置信。
dotNet Protector 是一个功能强大的.NET代码保护系统，它可以防止程序集被反编译。dotNet Protector使用的是一个新的主体混淆技术保护应用程序和组件。程序集不再需要合并到一个win32可执行文件中，但是会保留其.net特性。dotNet Protector 采用一个命名混淆器结合一个主体混淆器来保护您的代码。
Themida是一个强劲的保护系统， 专为了那些想保护自己的程式不被先进的逆向工程和黑客软件破解的软件开发者而开发的。开发者不需要更改任何的原代码，和不需要程式编制的经验使用WinLicense。
Themida使用SecureEngine®的保护技术。它能够以最高的优先等级运行，这些保护技巧是从来都没在电脑防御技术领域出现过，使它
Code Virtualizer 是一个强大的代码搅乱系统。它可以帮助软件开发者保护他们软件内重要和敏感的代码区，防止他人使用逆向工程，而且它只消耗最小的系统资源。
代码加密，程序保护始终是信息安全的很重要的一部分，未来也将继续成为IT领域发展的重要方面，但着技术的进步，很多老的技术将会被逐步破解和淘汰，新技术也将源源不断的被开发出来，但市场需求和安全需求相信只会源源不断的增加，市面上现存的诸如VMProtect、WinLicense。这样致力于服务代码加密混淆的软件厂商也将不断迭代技术。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5f8719124603698f632eb4c57b7c260/" rel="bookmark">
			C&#43;&#43;中双感叹号!!的含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言中偶尔会遇到 !!(cond)，特别是在宏定义当中；
单!用法
一个感叹号!我们知道是取非，如下： ！（非零）=0 ！（零）=1 双!用法
两个感叹号由此推导可以知道： ！！（非零）=1 ！！（零）=0 C语言中的感叹号（!）是逻辑运算操作符。经过该操作符运算后的值只有 2 种情况，要么为 1，即 True，要么为 0，即 False；
在进行逻辑运算时，所有非 0 的值都会被认为是 True，而只有 0 值会被认为是 False。所以对变量进行 2 次非运算（!!）就能将其转化成 1 或者 0，且变量原本的逻辑值保持不变。
举例 #defined __likely(!!(x)) int x = 6 if(__likely(x&gt;9)) { do something } 补充解释:将条件转化为1或0，也就是true和false
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8639664e2fee4f3a3fa50f69b08aedad/" rel="bookmark">
			JavaScript数组操作常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数组基础遍历方法。forfor offor in 数组的基础操作方法。push：尾部追加元素pop：尾部移出元素unshift：头部追加元素shift：头部移出元素sort：数组排序splice：删除添加替换concat：连接join：分割slice：切割includes：查询indexOf：查询fill：填充/替换from：创建数组sort：数组排序 es6中带来的数组高阶方法。forEach：迭代（枚举）filter：过滤map：映射find：查找findIndex：查找下标Array.form()： 函数和方法的区别：
函数function：独立的function，那么称之为是一个函数。
function foo() {} 方法method：当我们的一个函数属于某一个对象时，我们称这个函数是这个对象的方法。
var obj = { foo: function() {} } obj.foo() 例如，对一个数组的操作方法：filter，我们就称之为是一个方法。
// filter：过滤 var nums = [10, 5, 11, 100, 55] nums.filter((item) =&gt; item &gt; 10) 在以下对数组的操作中，我们统称方法。
文章中通用常量意义：
item：某一项。当作为参数时，为遍历数组中的每一项。当作为返回值时，意思为某项数据，可以为任意类型。
index：下标。当作为参数时，为遍历数组中的item在数组中下标。当作为返回值时，意思为下标。
arr：数组。当作为返回值时，意思为改变数组本身。当作为参数时，意思为自身数组。
length：数组长度。当作为返回值时，意思为数组长度
newarr：新数组。当作为返回值时，意思为产生一个新数组，
boolean：布尔值。当作为方法体时为：条件的返回值为布尔值。
num：数值类型。
start ：数组遍历开始下标（包含）
end：数组遍历结束下标（不包含）
数组基础遍历方法。 for for(var i = 0, len = arr.length; i &lt; len; i++ ){ console.log(arr[i]) } for基础循环可以用来遍历数组，字符串，类数组，DOM节点等。
for of for (var item of arr) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8639664e2fee4f3a3fa50f69b08aedad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f707765b1db54b291a998b137dcae1ba/" rel="bookmark">
			在 Python 中将字符串转换为数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 str.split() 方法将字符串转换为数组，例如 array = string.split(',')。 str.split() 方法将在每次出现提供的分隔符时将字符串拆分为一个列表。
string = 'www,jiyik,com' # ✅ 将逗号分隔的字符串转换为数组 array = string.split(',') print(array) # 👉️ ['www', 'jiyik', 'com'] # --------------------------------------------- # ✅ 将空格分隔的字符串转换为数组 string = 'www jiyik com' array = string.split(' ') print(array) # 👉️ ['www', 'jiyik', 'com'] # --------------------------------------------- # ✅ 将字符串转换为字符数组 string = 'jiyik' array = list(string) print(array) # 👉️ ['j', 'i', 'y', 'i', 'k'] # --------------------------------------------- # ✅ 将字符串转换为整数数组 string = '1,2,3' array = list(int(char) for char in string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f707765b1db54b291a998b137dcae1ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19983b1c20473f2efcfbd3a7434d3f5e/" rel="bookmark">
			Google登录和内购简要说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Firebase-Google身份验证（登录） 我的博客：https://blog.csdn.net/qq_39574690/article/details/121246655 1、Google账号登录Firebase : https://console.firebase.google.com/
2、创建u3d项目 3、Authentication - Users - 添加用户 - 测试用户邮箱账密【按道理可不用】
4、Authentication - Sign-in method - 添加新提供方 - Google
5、齿轮图标 - 项目设置 - 添加应用 - 填写包名和SHA-1
打开cmd执行命令：
keytool -list -v -keystore F:\google.keystore
输入密钥密码，正确则会打印出SHA-1等信息内容。
填写完毕后，下载google-services.json，拷贝至工程内Assets/下任意能被打包出去的文件夹内。（例如Plugins下)
6、firebase-google登录 API文档：https://firebase.google.com/docs/auth/android/google-signin
7、API所需参数：
①获取client-ID : https://console.cloud.google.com/apis/credentials Google账号登录
进入凭据页面，找到Web client (auto created by Google Service)一项，客户端 ID即是client-ID
例如：
客户端 ID
921921056874-45l00snps5lgd69mj1i6patb0u6f33a7.apps.googleusercontent.com
客户端密钥
ZjZAO90H7gih-kIFVW67cifo
创建日期
2021年9月13日 GMT+8 22:39:48 ps:&lt;此ID在google-services.json里也有出现，位于other_platform_oauth_client属性下的client_id属性内容。&gt;
Google支付（内购） 我的博客：https://blog.csdn.net/qq_39574690/article/details/121252342 谷歌开发者官网（配置Google项目）： https://play.google.com/console/
注册谷歌开发者账号需要借记卡或信用卡(visa卡)，如若没有百度到的方法是全球付（未尝试），而内购必然是用海外的信用卡或银行卡的。【别搞全球付，试过了不行的 300块钱还没要回来呢哈哈】
【注意事项】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19983b1c20473f2efcfbd3a7434d3f5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a02f461345aaf33eb27b0f67ce635b89/" rel="bookmark">
			[R|script] 批量计算OR/HR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载搬运，感谢
写在前面 我们在做logistic回归经常要求回归分析当中的其OR值。同样的我们在做COX回归的时候也需要求HR值。在R基础包当中没有之间返回这些值的结果。我们需要用数据自己来求。同样的我们也可以使用tableone包当中的ShowRegTable来计算。但是这个包。返回的结果格式，不是自己想要的，所以就自己重新写一下函数。
tableone::ShowRegTable tableone示例
这个包当中的ShowRegTable使用方法是
library(tableone) library(survival) data(pbc) head(pbc) ## id time status trt age sex ascites hepato spiders edema bili chol ## 1 1 400 2 1 58.76523 f 1 1 1 1.0 14.5 261 ## 2 2 4500 0 1 56.44627 f 0 1 1 0.0 1.1 302 ## 3 3 1012 2 1 70.07255 m 0 0 0 0.5 1.4 176 ## 4 4 1925 2 1 54.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a02f461345aaf33eb27b0f67ce635b89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62eeeb1b0fb069a35f700fd0f10bb34e/" rel="bookmark">
			OutputStream 转 InputStream
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 开发中遇到生成文件，又不能存服务器磁盘，需要上传到某对象存储。
这个时候需要OutputStream 转 InputStream
XSSFWorkbook wb = null; try { wb = buildDownloadFile(); ByteArrayOutputStream bos = new ByteArrayOutputStream(); wb.write(bos); byte[] buffer = bos.toByteArray(); InputStream inputStream = new ByteArrayInputStream(buffer); String fileName = buildDownloadFileName(); uploadFile(inputStream, fileName); } catch (Exception e) { e.printStackTrace(); throw new RuntimeException(e.getMessage()); } finally { if (wb != null) { try { wb.close(); } catch (Exception e) { e.printStackTrace(); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a28d616db72a5ddf115a8fe19a71af4e/" rel="bookmark">
			Echarts中根据条件遍历数据改变y轴字体颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Echarts中根据条件遍历数据改变y轴字体颜色 &lt;div style="width: 100%;height: 100%" id="bottomLeft1"&gt;&lt;/div&gt; async getList(){ let axisData={} let titleList=[] let yzgList=[] let zgzList=[] let xFontColor=[] let mark='01' await queryProblemGroupBySort( { orgNo:this.oneParams.org } ).then(res =&gt; { res.data.forEach(item=&gt;{ if(mark==item.supvPrj){//判断数据中为01的数据所对应的y轴文字变为红色 item.fontColor='red' }else{ item.fontColor='black' } xFontColor.push(item.fontColor) titleList.push(item.problemSort) yzgList.push(item.yzg) zgzList.push(item.zgz) }) if(res.data){ axisData= houseFormat2(yzgList,zgzList) } }) //左下角 柱状图1 let bottomLeft1 = this.$echarts.init(document.getElementById("bottomLeft1")) setTimeout(()=&gt;{ bottomLeft1.resize() }) let bottomLeftoption1 = { tooltip: { show:true, trigger: 'axis', axisPointer: { type: "none", crossStyle: { color: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a28d616db72a5ddf115a8fe19a71af4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177d70e54ef561125e629529d0ffc7b2/" rel="bookmark">
			T型、NPC型、三电平逆变器模型预测控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拓扑结构
仿真模型
相电压（三电平）
线电压（五电平） 电流跟踪效果
中点电位平衡控制
模型获取：置顶文章底部获取方式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd479399b7025a8cf8a8a37a00c44d81/" rel="bookmark">
			吸顶效果：1.css属性sticky优缺点 2.简单js实现吸顶效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.css属性position:sticky 使用这个属性可以很方便的实现吸顶效果，并且只需要一行css
position: sticky 原理： 粘性元素根据滚动位置在相对（relative）和固定（fixed）之间切换。起先它会被相对定位，直到在视口中遇到给定的偏移位置为止 - 然后将其“粘贴”在适当的位置（比如 position:fixed。
兼容性 简单的同时，也意味着兼容性会差上一些，我简单总结一下：
浏览器兼容问题，IE/Edge 15 以及更早的版本不支持粘性定位,或者一些低版本的其他浏览器也不支持。父元素不能设置overflow：visible 以外的其他值，比如scroll和auto均不能，overflow-x和overflow-y同理。父元素不能给固定高度等于粘性定位元素，或者父元素计算高度等于粘性定位元素。必须给粘性定位元素设置一个定位值，如top或者bottom。 举个具体例子，下面随便写了个小demo：
&lt;style&gt; .wrapper { height: 800px; } .tab { margin-left: 50px; margin-top: 100px; /*核心设置*/ position: sticky; width: 200px; height: 300px; /* 一定要设置top或者bottom,否则粘性定位效果失效，参考我写的原理自然明白原因了，看不懂	打死嗷 */ top: 0; background-color: #eee; box-shadow: 1px 1px 5px #ccc; border-radius: 10px; display: flex; flex-direction: column; } .tab div { width: 100%; height: 60px; border-top: 1px solid #aaa; text-align: center; line-height: 50px; cursor: pointer; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd479399b7025a8cf8a8a37a00c44d81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5692ab482b025f6e400921fac9350a32/" rel="bookmark">
			第五节Hadoop学习案例——MapReduce案例（WordCount）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：本文章内容主要围绕案例展开
目录
1 需求分析
1.1 需求
1.2 数据准备
1.3 原理
2 编码操作
2.1 创建项目
2.2 创建包和类
2.2.1 创建包
2.2.2 创建类
2.2 引入jar包
2.2.1 引入MR相关jar
2.2.2 引入打包插件
2.3 拷贝官方样例
2.4 修改样例代码
2.4.1 main方法程序阅读
2.4.2 WordCountMapper
2.4.3 WordCountReduce
2.4.4 替换实现类
2.5 程序打包
2.5.1 父项目pom修改
2.5.2 打包
2.6 程序测试
2.6.1 创建目录
2.6.2 上传程序
2.6.3 分布式文件系统上传测试数据
2.6.4 执行程序
2.6.5 查看结果
提示：以下是本篇文章正文内容，下面案例可供参考
1 需求分析 1.1 需求 统计文件中各个单词出现的个数 1.2 数据准备 数据准备：hello.txt Once when l was six years old l saw a magnificent picture in a book called True Stories from Nature, about the primeval forest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5692ab482b025f6e400921fac9350a32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/434ad245f9cb0e0e565c57751a7972b5/" rel="bookmark">
			CorelDRAW2022中文正式版特色功能介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CDR是CorelDRAW软件的简称，这个软件主要用于平面设计领域。产品包装设计、LOGO标志设计、宣传单广告设计、服装设计、插画创作等等都会使用到这个软件。
CorelDRAW，简称CDR，CorelDRAW2022中文版免费版是一款专业的矢量绘图软件。该软件是加拿大Corel公司推出的矢量图形制作工具。经过22多年的发展和变革，CorelDRAW系列已经发布了22个版本。今年新推出的CorelDRAW 2022是该系列的最新版本。CorelDRAW2022中文版最新官方版是一款全新的平面设计工具，强大的平面设计功能和全新的外观界面，为设计师提供了更广阔的创作空间，打开了新思想的大门。无论是矢量图还是版面设计，网站制作还是位图编辑，这套完整的平面设计软件都能帮你按照自己的风格进行设计。
解压完成后按照自己的电脑系统类型选择，点击对应文件中的Setup安装；
提示输入序列号页面，右键以管理员身份打开注册机，在①处选择相应CDR版本，然后将②处的序列号复制到激活页面，点击下一步。
出现安装选项，最好选择自定义安装，因为C盘容量直接影响电脑运行速度。接着出现安装的插件，按自己需求选择。
选择安装程序功能默认就好，不做修改，点击下一步。
将“允许产品更新”取消选择，点击下一步。
默认安装路径可以点击“更改”将安装路径更改为其它盘，注意安装路径中的文件名称一定不能出现中文，否则会出错。
出现注册界面时填写邮箱和密码点击“继续”，如果有账号点击“我已有一个账户”登录。
出现“验证您的产品时出现问题”界面不用管，直接点继续就可安装完成。
下载地址CDRx8（复制浏览器打开）：
https://wm.makeding.com/iclk/?zoneid=36625
CorelDRAW2022特色
要从每个页面的中心调整页面大小，需要进一步操作才能查看所有页面
切换到多页面视图会自动缩放到所有显示页面，将视图缩放到单个页面
CorelDRAW中文版优势
将交互式网页调整为多页视图，以便有矩形对象以使布局窗口适合活动页面
此外，您可以从一系列经过精心呵护和测试的样式预设中进行选择，包括黑白
学习多个页面的基本功能是不够的重用会遇到其他问题，比如使用CorelDRAW
CorelDRAW免费亮点
改进的缩略图预览简化了页面处理此外，您现在可以在活动页面之后快速插入页面
您还可以在自定义类别中预订页面，而无需手动交换或者只是将它们分配到默认类别
单击 Ctrl+O 快捷键打开文档如果原始文档只有一个视图，则默认打开文档的第一页
CorelDRAW正版玩法
再次检查多页面视图将显示工具中包含的所有页面，只需按住 Shift 并拖动手柄即可
快速开始您的审阅过程 如何查看文档中的所有页面?以下是给您的序言、彩色和彩色样式
如果原始文档已在多个页面上查看，它将显示所有已登录的文档页面点击菜单栏中的查看
CorelDRAW新功能
1. 加速照片编辑的新功能
使用新的、非破坏性的、可堆叠的调整预设和新的调整泊坞窗，以比以往快 10 倍的速度获得令人难以置信的创意。享受对常见照片编辑功能的许多受用户启发的改进，以及带有新工具、快捷方式和命令的更新调整菜单。
2.新功能优化学习体验
在新的 Learning Docker 中查找个性化学习内容，并在创作时从“探索”选项卡中查找在线内容。由于优化的流程使定制培训触手可及，您无需离开 CorelDRAW 就可以快速掌握工具和技术。
3. 新功能受客户启发的功能
享受基于可信用户直接反馈的丰富功能，从节省时间的多页面视图和页面增强到有价值的图像编辑和导出增强。提交您自己的想法，对他人的想法进行投票，并为 CorelDRAW Graphics Suite 的设计和开发做出贡献，以帮助我们实现它!
CorelDRAW最新官方版测评
该软件广泛应用于广告设计、插画设计、网页设计、矢量图形编辑等领域。它拥有非常直观清爽的界面操作，所有功能一目了然。对于初次使用的用户，还准备了专门的动态指南，大大降低了操作难度。
特别说明
在多页视图中以交互方式调整页面大小，就好像它们是标准矩形对象一样。 要从中心调整页面大小，只需按住 Shift 并拖动手柄即可。切换到多页视图自动缩放以显示所有页面； 切换到单页视图缩放以适​​应绘图窗口中的活动页面。
CorelDRAW2022 订阅版 mac - 安装包下载
https://wm.makeding.com/iclk/?zoneid=49497
CorelDRAW2022 订阅版 win - 安装包下载
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/434ad245f9cb0e0e565c57751a7972b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef483d35253304fdfe658b34e7d08b1a/" rel="bookmark">
			操作远程仓库和Idea操作Git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大致的意思就是上面这个图的意思
目录
一、需要创建远程仓库
1.1 根据不同的项目创建不同的远程仓库名称
1.2 创建ssh公钥
1.3 生成公钥
​编辑
1.4 指定远程仓库地址
1.5 查看远程仓库
1.6 删除远程仓库的关联
1.7 把我们初始化的项目推送到远程仓库
1.8 克隆远程仓库的项目
1.9 从远程仓库拉去新的代码
二、Idea关联Git
2.1 配置路径
2.2 把项目初始化为本地仓库
2.3 提交到暂存区
2.4 把暂存区提交到本地仓库
2.5 通过Idea把本地仓库的代码提交到远程仓库
2.6 Idea克隆远程仓库的代码
2.7 idea拉取远程仓库更新的代码
2.8 演示冲突问题
一、需要创建远程仓库 1.1 根据不同的项目创建不同的远程仓库名称 1.2 创建ssh公钥 公钥的目的是允许其他人访问远程仓库。而不需要输入账号和密码。 1.3 生成公钥 ssh-keygen -t rsa不断回车 如果公钥已经存在，则自动覆盖
把公钥内容添加到指定的仓库 1.4 指定远程仓库地址 git remote add 名称 远程仓库地址。
名称: 它可以任意起 建议起名为origin
1.5 查看远程仓库 git remote
1.6 删除远程仓库的关联 git remote rm 名称 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef483d35253304fdfe658b34e7d08b1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5a54d42f706fc33a33e816b4f0bef7c/" rel="bookmark">
			django-restframework 实现筛选,搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		django-restframework 实现筛选(单个) 搜索(多个条件)
pip install django-filter -i https://pypi.tuna.tsinghua.edu.cn/simple 然后在配置文件中注册
INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'rest_framework', 'django_filters',# drf的筛选 'studentweb', ] 配置筛选类
from django_filters import FilterSet from studentweb.models import * class FacultyFilter(FilterSet): class Meta: model = Faculty fields = ('name',) class MajorFilter(FilterSet): class Meta: model = Major fields = ('name','faculty') class StudentFilter(FilterSet): class Meta: model = Student fields = ('sno','name','mobile') 在views中导入模块
# 实现筛选的后台模块 from django_filters.rest_framework import DjangoFilterBackend # 导入筛选类 from studentweb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5a54d42f706fc33a33e816b4f0bef7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ebb209514078486e9ccfef40b6c93b7/" rel="bookmark">
			c&#43;&#43; 实现邮件发送功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列服务器开发 文章目录 系列服务器开发前言一、SMTP是什么？二、使用SMTP使用步骤1.下载编译，命令行使用2.代码实现 总结 前言 常用的电子邮件协议有SMTP、POP3、IMAP4，它们都隶属于TCP/IP协议簇，默认状态下，分别通过TCP端口25、110和143建立连接。
SMTP的全称是"SimpleMailTransferProtocol"，即简单邮件传输协议
POP全称是邮局协议，负责从邮件服务器中检索电子邮件。
IMAP全称互联网信息访问协议，是一种优于POP的新协议。
一、SMTP是什么？ SMTP是一种提供可靠且有效的电子邮件传输的协议。SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知。SMTP独立于特定的传输子系统，且只需要可靠有序的数据流信道支持，SMTP的重要特性之一是其能跨越网络传输邮件，即“SMTP邮件中继”。使用SMTP，可实现相同网络处理进程之间的邮件传输，也可通过中继器或网关实现某处理进程与其他网络之间的邮件传输。
SMTP是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过telnet程序来测试一个SMTP服务器。SMTP使用TCP端口25。Sendmail是最早使用SMTP的邮件传输代理之一。
SMTP协议工作机制
虽然SMTP涉及的是发送电子邮件，但是整理和传送邮件的工作是由不同的服务器完成的，称为：POP（邮局协议）和IMAP（Internet消息访问协议）。通常它工作在两种情况下：一是邮件从客户机传输到服务器；二是从某一个服务器传输到另一个服务器。
SMTP的连接和发送过程
（a）建立TCP连接
（b）客户端发送HELLO命令以标识发件人自己的身份，然后客户端发送MAIL命令；服务器端以OK作为响应，表明准备接收
（c）客户端发送RCPT命令，以标识该电子邮件的计划接收人，可以有多个RCPT行；服务器端则表示是否愿意为收件人接收邮件
（d）协商结束，发送邮件，用命令DATA发送
（e）以.表示结束输入内容一起发送出去
（f）结束此次发送，用QUIT命令退出
二、使用SMTP使用步骤 本文基于sendemail可执行程序，通过进程调用来实现的邮件发送。
sendEmail发送邮件
sendEmail是一个轻量级，命令行的SMTP邮件客户端。如果你需要使用命令行发送邮件，那么sendEmail是非常完美的选择:使用简单并且功能强大。
1.下载编译，命令行使用 sendEmail 官网：http://caspian.dotconf.net/menu/Software/SendEmail/
sendEmail 下载：sendEmail-v1.56.tar.gz
1、sendEmail 下载 sendEmail-v1.56.tar.gz 2、解压、安装 tar zxvf sendEmail-v1.56.tar.gz cd sendEmail-v1.56 cp sendEmail /usr/local/bin/ 可以通过查看帮助 sendEmail --help 简单发送邮件案例 sendEmail -f ttlsafrom@163.com -t 12312311231@qq.com -s smtp.163.com -u "主题测试" -o message-content-type=html -o message-charset=utf-8 -o tls=no -xu ttlsafrom@163.com -xp HUKINXIAW -m "test" Feb 15 09:22:15 localhost sendEmail[3536]: Email was sent successfully!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ebb209514078486e9ccfef40b6c93b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3365df402c268fa89edcb9592ff0b2a4/" rel="bookmark">
			element ui table 导出excel表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装相关依赖 xlsx file-saver npm intall --save xlsx npm intall --save file-saver 2.在组件头里边引入插件 import FileSaver from "file-saver"; import XLSX from "xlsx"; 3.定义导出Excel表格事件 exportExcel() { let fix = document.querySelector(".el-table__fixed"); let wb; if (fix) { //判断要导出的节点中是否有fixed的表格，如果有，转换excel时先将该dom移除，然后append回去 可以避免行重复 wb = XLSX.utils.table_to_book( document.querySelector("#table").removeChild(fix) ); document.querySelector("#table").appendChild(fix); } else { wb = XLSX.utils.table_to_book(document.querySelector("#table")); } let wbout = XLSX.write(wb, { bookType: "xlsx", bookSST: true, type: "array", }); try { //文件名可以自定义 FileSaver.saveAs( new Blob([wbout], { type: "application/octet-stream" }), "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3365df402c268fa89edcb9592ff0b2a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c1ac90b30f5e96a42e9e0f541cffd0b/" rel="bookmark">
			vscode连接服务器免密码登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在windows环境下，有时候需要用到linux平台开发，如果用Ubuntu虚拟机的话，用起来很不习惯，不方便切换到windows界面，可以把代码放到服务器上，用vs code或者xshell或者其他工具连接到服务器，本人习惯用vscode，对vscode如何连接到服务器做一下总结，并且可以免密码连接。
1.在vscode安装Remote Development插件
2.打开设置，输入Show Login Terminal，并勾选。
3.点击远程资源管理器，选择SSH Targets
3.点击设置按钮，会弹出ssh的congfig,然后在config里面配置服务器地址账号
H
Host是设置在vscode中显示的服务器名称，hostname是服务器地址，user是配置的ssh的用户名，ForwardAgent yes主要用于后面设置的免密码登录，Port端口号，IdentityFile ~/.ssh/id_rsa是使用服务器中的id_rsa。
4.设置好后，点击加号开始连接服务器
首次连接服务器会提示音连接到什么系统，我用的是linux，所以选择linux。
5.选择系统后，在中端可能会提示输入密码，需要输入你在服务器中的密码，如果密码输入正确，在终端会打印类似的log，说明已经连接到服务器了。
6.以上就是vscode连接服务器的步骤，但是如果你的服务器是要输入密码的话，每次重新打开vscode连接服务器都会提示输入密码，比较繁琐，所以下面的步骤是如何设置免密码连接。
（1）确保服务器账号里面有id_rsa.pub
新建终端命令窗口：
然后输入 cat id_rsa.pub &gt;&gt; authorized_keys命令，按回车键，在文件夹中会生成新的一个文件authorized_keys，以后连接服务器就不用输入密码了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab1ce01fe66ddb4c42567c04cd0d61f8/" rel="bookmark">
			谷歌浏览器：无法翻译此网页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谷歌浏览器：无法翻译此网页 解决方案：
1.修改hosts文件 在C:\Windows\System32\drivers\etc找到hosts文件用记事本打开添加下面两行
203.208.40.66 translate.google.com
203.208.40.66 translate.googleapis.com
保存并替换原来的hosts文件
2.刷新DNS 打开控制台（win+R）
输入ipconfig /flushdns
打开谷歌浏览器尝试翻译，成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d38b1ca8ce0c93c13def2f120d44c14/" rel="bookmark">
			win10家庭版安装docker过程及问题解决记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要用于小白学习自用，第一次接触docker，新手遇见很多问题，顺手记录一下
1. 官网下载docker desktop win版
Install Docker Desktop on Windows | Docker Documentation
2. 安装WSL，网上查询方法，微软官网下载ubuntu20.04 Linux分发版
Manual installation steps for older versions of WSL | Microsoft Learn
（好像有的说20.04不支持docker，18.04可以，后续安装一切正常，可能是暂未用到相关功能）
3. 安装docker之后，start直接报错，Hyper-V blabla，和新机器未设置虚拟化有关
上网找解决办法，基本都是让开启Hyper-V服务，之前设置虚拟机时候了解一些，但win10家庭版根本没有Hyper-V选项，也从谈开启（后来知道只有专业版才有）
cmd打开命令窗口，输入systeminfo查看状态，显示虚拟化开启为否
重启BIOS（设备：Thinkpad L490 i3版，F1开启BIOS），打开虚拟化
再次systeminfo，显示已检测到虚拟机监控程序，该问题解决
4. restart docker，又蹦出WSL2 blabla，和WSL2内核需要更新有关
微软官网安装WSL2 Linux内核更新包
旧版 WSL 的手动安装步骤 | Microsoft Learn
查询ubuntu的WSL版本，cmd中输入
wsl --list --verbose ubuntu显示wsl版本为1
wsl --set -version ubuntu 2 成功后会提示转换成功，再次查询版本即可发现已变成2
docker中Settings - Resources - WSL Integration选项再把ubuntu选项勾选
重启电脑，restart docker，问题解决，可顺利运行拉取镜像
名词解释：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d38b1ca8ce0c93c13def2f120d44c14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d277acabd95e2209e71009b9f58e035e/" rel="bookmark">
			sqlmap使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sqlmap使用 看到sql发送的测试payload sqlmap对一个点是进行了怎样的尝试和读取数据的可以使用-v参数
0、只显示python错误以及严重的信息。 1、同时显示基本信息和警告信息。（默认） 2、同时显示debug信息。 3、同时显示注入的payload。 4、同时显示HTTP请求。 5、同时显示HTTP响应头。 6、同时显示HTTP响应页面。 如果想要看到sql发送的测试payload最好的等级就是3
获取目标方式 目标url -u参数
python sqlmap.py -u http://127.0.0.1/sqlilabs/Less-2/?id=1 --batch 从文件中加载http请求 -r参数
python sqlmap.py -r C:\Users\14980\Desktop\1.php --batch 从burp代理中获取日志 -i
python sqlmap.py -l D:\Download\test.log --batch 处理谷歌的搜索请求 -g
python sqlmap.py -g "inurl:\".php?id=1\"" --proxy="http://127.0.0.1:7890" --batch 请求 http参数 -data
此参数是把数据以POST方式提交，sqlmap会像检测GET参数一样检测POST的参数。
python sqlmap.py -u http://127.0.0.1/sqlilabs/Less-11/ --data="uname=admin&amp;passwd=Dumb&amp;submit=Submit" --batch HTTP cookie头 –cookie,–load-cookies,–drop-set-cookie
1、web应用需要登陆的时候。
2、你想要在这些头参数中测试SQL注入时。
可以通过抓包把cookie获取到，复制出来，然后加到–cookie参数里。
在HTTP请求中，遇到Set-Cookie的话，sqlmap会自动获取并且在以后的请求中加入，并且会尝试SQL注入。
如果你不想接受Set-Cookie可以使用–drop-set-cookie参数来拒接。
当你使用–cookie参数时，当返回一个Set-Cookie头的时候，sqlmap会询问你用哪个cookie来继续接下来的请求。当–level的参数设定为2或者2以上的时候，sqlmap会尝试注入Cookie参数
python sqlmap.py -u http://127.0.0.1/sqlilabs/Less-20/index.php --cookie "uname=Dumb" --batch --level 2 HTTP(S)代理 –proxy,–proxy-cred和–ignore-proxy
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d277acabd95e2209e71009b9f58e035e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d332c0d94ca4652e57a635b93b0d74d/" rel="bookmark">
			word参考文献后面空格太大
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写论文的时候遇到一些空格很糟心，尤其是参考文献后面的空格太大，怎么也去不掉。如下：
当要缩小这些参考文献后面的空格时，可进行如下操作：
1、选中要缩小的序号，右击选择段落
2、将磅值修改为0.35即可.（修改成合适的磅值即可）
结果如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d82a568944ddde038bccd228f06b228/" rel="bookmark">
			vue3 props属性基本使用梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 vue2中props属性的使用是比较统一的基本就一种方式，但是vue3中其实方式是比较多的，因此就打算梳理一下。
会按照选项式和组合式进行梳理，包括属性的定义、取值以及属性的监听。
应该是叫单文件组件和组合式API，不知道vue官方是根据什么区分的。
单文件组件 定义 这里大体上分为两大类进行说明，这两大类都需要使用defineProps来进行定义
非ts语法 const props = defineProps({ // 基础类型检查 // （给出 `null` 和 `undefined` 值则会跳过任何类型检查） propA: Number, // 多种可能的类型 propB: [String, Number], // 必传，且为 String 类型 propC: { type: String, required: true }, // Number 类型的默认值 propD: { type: Number, default: 100 }, // 对象类型的默认值 propE: { type: Object, // 对象或数组的默认值 // 必须从一个工厂函数返回。 // 该函数接收组件所接收到的原始 prop 作为参数。 default(rawProps) { return { message: 'hello' } } }, // 自定义类型校验函数 propF: { validator(value) { // The value must match one of these strings return ['success', 'warning', 'danger'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d82a568944ddde038bccd228f06b228/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76fcf5c2f61118f8b2c39cd0721804ca/" rel="bookmark">
			nuxt 不支持 replaceAll 方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用 nuxt 的 ssr 时使用 replaceAll 方法时报错 ‘replaceAll’ does not exist
是因为 nuxt 不支持 String 的 replaceAll 方法
可以使用 replace(new RegExp(a, "gm"), b) 来替代 replaceAll(a, b) 的写法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7073739a4e07cdd58890eedf47db0776/" rel="bookmark">
			计算机网络抓包实验记录和总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络抓包实验记录和总结 实验准备： win10系统64位计算机抓包软件：Wireshark参考资源：教程 引言 作为学习计算机网络的学生，了解网络数据包的组成，通过对网络上传输的数据进行抓取，可以对其进行分析，对于软件的Debug很大的帮助。当然也可以通过抓取用户发送的涉及用户名和密码的数据包来获取用户的密码，这样的知识可以启发我们更多的兴趣：
（1）网络通讯的真实内容。
（2）网络故障分析。
（3）程序网络接口分析。
（4）木马通讯数据内容。
实验概述： 我们的计算机通过向网络上传和从网络下载一些数据包来实现数据在网络中的传播。通常这些数据包会由发出或者接受的软件自行处理，普通用户并不过问，这些数据包一般也不会一直保存在用户的计算机上。
这次实验中，我先对于实验资料内容进行学习，初步了解了实验的要求和步骤后，发现这次的材料不仅是包含许多生词的全英文文档，而且涉及的抓包软件版本非常旧，无法立刻上手，所以我做了一下工作:
先下载要用的软件，确定当前版本；查阅英文字典，确定实验要求文档具体内容和思路；寻找辅助教程，确保自己可以按照实验教程思路，使用新版本软件完成实验 在实验中，我观察到这次实验是一个循序渐进的探索过程，从尝试抓包，获取数据包，再到确定数据包后对其内容结构的分析和阅读，所以我一步一步按照实验要求，及时记录自己的实验过程，并且对每一步的步骤和思路做简要总结，在其中，我也遇到一些问题:
新版本软件在win10系统中会频繁停止抓包，所以我尝试这个方法后只能做到每次打开抓包一次的操作；实验要求抓包同学的数据，我为了不侵犯他人隐私，最后抓包了我的和主机ip地址不同的vm虚拟机的数据，并且成功解读；自我探索内容涉及后面课程的http协议和分层的一些知识，我提前做了一些预习工作，并且查询一定资料后，完成了这项任务，可以算作一个加分项； 最后，这次实验在软件应用层面，让我了解了许多计算机网络数据传输的细节，让我对各种数据和它们绑定的协议，结构有了更深入的了解。
实验步骤： 步骤一-捕获数据包 操作：运行软件，使用过滤器“tcp port 80”，检查“enable network name resolution”；浏览网页，进行抓包，大部分应该是绿色；原理：这个过滤器将只记录标准的网络流量，检查选项将有助于识别这些数据包是否属于你的计算机交互的信息； 步骤二-观察数据包 操作：浏览数据包，以及字段层和字节层原理：Wireshark将让我们选择一个数据包（从顶部面板），并查看其协议层，它的协议层，从头字段（在中间面板）和组成数据包的字节（在底部面板）两方面来看； 步骤三-理解数据包 操作：
我选择的抓包数据：
我对这个数据包一些结构和内容的理解： 名称内容源端口号56086目的端口号80序号0确认号0报头长度32bytes标志位0x002窗口64240校验和0xccca 原理：
步骤四-查看他人数据包-通过我的虚拟机 操作：“capture packets in promiscuous mode” 我虚拟机ip:
数据包信息：
原理：通过对抓包信息可以确定，这个数据包是通过我的vm虚拟机进行信息交互，访问教学网站课堂派（ketangpai.com），协议为TLSv1.2 步骤五-自我兴趣探索-&gt;IPv6 我想要在数据包上了解其内容层次与我们课程内容的联系，试图用我上课所学到的知识解释和理解我自己实践中的捕获数据信息。
操作原理：
我的捕获：
IPv6协议数据包
内容分析：
（1）Frame: 物理层的数据帧概况
（2）Ethernet II: 数据链路层以太网帧头部信息
（3）Internet Protocol Version 6: 互联网层IP包头部信息
（4）Data：数据信息
样例中没有包含的：
Transmission Control Protocol: 传输层T的数据段头部信息，此处是TCP
Hypertext Transfer Protocol: 应用层的信息，此处是HTTP协议
通过这样的层次观察可以发现
在数据报报文中：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7073739a4e07cdd58890eedf47db0776/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e8d55ec1b0b64035aed5532d8c326ac/" rel="bookmark">
			yolov5结果解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Confusion matrix 以这种形式给出矩阵的值
g t c l a s s 1 gt_{class1} gtclass1​ g t c l a s s 2 gt_{class2} gtclass2​ g t c l a s s 3 gt_{class3} gtclass3​background FP p r e d c l a s s 1 pred_{class1} predclass1​ p r e d c l a s s 2 pred_{class2} predclass2​ p r e d c l a s s 3 pred_{class3} predclass3​background FN 若是分类的完美，则应当只有对角线是高峰，其余都是0（除了最后一行和最后一列）.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e8d55ec1b0b64035aed5532d8c326ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91f456e78edad28391a0e314355998b1/" rel="bookmark">
			css之sticky定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.属性介绍：
sticky定位（粘性定位），指的是基于用户的滚动位置来定位，默认情况下它表现就和relative定位一样，但是当页面滚动区域大于你的目标区域（即sticky对应的元素区域）时，它的表现和fixed定位一样。
元素定位也同样需要根据所设定的top,left,right,bottom来呈现。
2.sticky定位的缺点：
存在兼容性问题
Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位。 Safari 需要添加-webkit前缀。
3.案例：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;sticky&lt;/title&gt; &lt;style&gt; .userList-title{ padding: 10px; background-color: greenyellow; position: -webkit-sticky; position: sticky; top:0; } .user-list-item{ padding: 10px; background: pink; } .user-list-item:nth-child(odd){ background-color: coral; } .phone{ margin-top: 10px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="userList-title"&gt;用户列表&lt;/div&gt; &lt;div class="user-list-item"&gt; &lt;div class="username"&gt;张三&lt;/div&gt; &lt;div class="phone"&gt;18989898989&lt;/div&gt; &lt;/div&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91f456e78edad28391a0e314355998b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1b6d1374b0694f80c2d3826fb157be4/" rel="bookmark">
			Selenium基础 — CSS选择器定位大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、css属性定位 css选择器策略示例说明#id#telA选择id="telA"的所有元素。.class.telA选择 class="telA”的所有元素。[属性名=属性值][name=telA]除了id和class属性，其他属性的定位格式[attribute][target]选择带有target 属性所有元素。**选择所有元素。 2、css属性值模糊匹配定位 css选择器策略示例说明[attribute^=value]a[src^="https"]选择其src 属性值以"https”开头的每个&lt;a&gt;元素。[attribute$=value]a[src$=".pdf"]选择其src属性以".pdf“结尾的所有&lt;a&gt;元素。[attribute*=value]a[src*="abc"]选择其src 属性中包含“abc"子串的每个&lt;a&gt;元素。[attribute~=value]a[title~=flower]定位标签属性title值中有独立flower词汇的节点[attribute=value]a[lang=en]用于选取带有以指定值开头的属性值的元素。 注意：[attribute|=value]
该值必须是整个单词，比如 lang="en"，或者后面跟着连字符，比如 lang="en-us"。
3、css标签定位 css选择器策略示例说明elementp定位所有&lt;p&gt;元素。标签名[属性名=属性值]input#telA定位id属性值为telA的所有&lt;input&gt;元素 4、css层级关系定位 css选择器策略示例说明element,elementdiv,p选择所有 &lt;div&gt; 元素和所有 &lt;p&gt; 元素。element elementdiv p选择 &lt;div&gt; 元素内部的所有 &lt;p&gt; 元素。包括子孙后代。element&gt;elementdiv&gt;p选择父元素为 &lt;div&gt; 元素的所有 &lt;p&gt; 元素。只包括子代。element+elementdiv+p选择紧接在 &lt;div&gt; 元素之后的所有 &lt;p&gt; 元素。同辈元素。 示例：
css选择器策略示例说明需要使用 &gt; 或 空格表示层级关系语法父标签名[父标签属性名=属性值]&gt;子标签名p#p1&gt;input定位id属性值为p1的&lt;input&gt;元素父标签名[父标签属性名=属性值] 子标签名p#p1 input同上 5、css索引定位 css选择器策略示例说明:only-childp:only-child选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。:nth-child(n)p:nth-child(2)选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。:nth-last-child(n)p:nth-last-child(2)同上，从最后一个子元素开始计数。:nth-of-type(n)p:nth-of-type(2)选择属于其父元素第二个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。:nth-last-of-type(n)p:nth-last-of-type(2)同上，但是从最后一个子元素开始计数。 6、css逻辑运算定位 css选择器策略逻辑定位示例标签名[属性名1=属性值1][属性名2=属性值2]示例input[type='telA'][placeholder='电话A']说明同时匹配多个属性 7、css元素状态定位 选择器例子例子描述:emptyp:empty选择没有子元素的每个 &lt;p&gt; 元素（包括文本节点）。:target#news:target选择当前活动的 #news 元素。:enabledinput:enabled选择每个启用的 &lt;input&gt; 元素。:disabledinput:disabled选择每个禁用的 &lt;input&gt; 元素:checkedinput:checked选择每个被选中的 &lt;input&gt; 元素。:not(selector):not(p)选择非 &lt;p&gt; 元素的每个元素。 七 、总结 如果元素有明确id，name，class属性时，使用对应的基本定位方法。如果没有id，name，class属性时，或id，name，class属性是动态/不唯一的时候，使用XPath和css_selector定位。定位页面超链接使用link_text和partial_link_text定位可使用XPath和css_selector定位的时候，优先使用css_selector。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1b6d1374b0694f80c2d3826fb157be4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/784ab90a6826bdc2779cd35a7e219c66/" rel="bookmark">
			Java 中 List 集合 Stream 流详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Stream流介绍 在JDK8时，JAVA新增了lambda表达式，它与 java.io 包里的 InputStream和 OutputStream是完全不同的概念，他更跟流没有任何关系。它也不同于 StAX 对 XML解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的Stream。
JDK8 中的 Stream 是对集合（Collection）对象功能的增强，它借助于lambda表达式，更优雅的表达风格，极大的提高编程效率和程序可读性。它针对于对集合对象进行各种非常便利、高效的聚合操作，或者大批量数据操作。不多说，上用法。
二丶Stream流实现与传统方式实现对比 **案例：**找出列表中包含张三且姓名长度为2的名字
2.1、传统方式实现 package com.controller; import java.util.ArrayList; public class Aoo { public static void main(String[] args) { // 1.定义一个集合 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("张三"); list.add("张四"); list.add("四"); list.add("张四"); list.add("张四"); list.add("张四"); list.add("张四"); // 2.挑选list中包含张三的 ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;(); for (String s : list) { if (s.startsWith("张三")){ list1.add(s); } } System.out.println("挑选list包含张三的结果："+list1); // 3.再从list1中挑选挑选名字长度为2的 ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;(); for (String s : list1) { if (s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/784ab90a6826bdc2779cd35a7e219c66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eafb8e49c8e4b81ad7b3aa0075de034/" rel="bookmark">
			【python】端调用cmd命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、python中的os模块 OS模块调用CMD命令有两种方式：os.popen()和os.system()都被当前进程调用。
OS.system 无法获取返回值。操作完成后，程序在下面执行。用法如：OS.system(“ipconfig”)。
OS.popen带返回值的，如何获取返回值。如：
p=os.popen(cmd)
print（p.read()）得到的是个字符串。
这两个都是用当前进程来调用，也就是说它们都是阻塞式的。
如：
import os file = "./best.onnx" cmd = f"mo --help" p = os.popen(cmd) print(p.read()) 二、管道subprocess模块 运行原理会在当前进程下面产生子进程。
import subprocess file = "./best.onnx" cmd = f"mo --help" subprocess.check_output(cmd, shell=True) Refercence: Python如何调用Cmd命令
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24c659674c2845ed7060650d75a2fbd2/" rel="bookmark">
			SpringBoot解耦方案：异步、事件、消息、定时任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		四种异步
@Async、WebAsyncTask、Callable、DeferredResult
https://www.jb51.net/article/212399.htm
SpringBoot事件发布和监听详解
https://www.jb51.net/article/229046.htm
SpringBoot系列——事件发布与监听
SpringBoot系列——事件发布与监听 - huanzi-qch - 博客园
事件和消息之间的重要区别是，不希望对事件进行进一步处理。
事件发布后，所有系统都可以忽略它，而不会造成任何伤害。
但是，一条消息带有一个假设，即某处将处理该消息。
https://www.jianshu.com/p/265da3c778e1
事件：只能由用户通过外设的输入产生。
消息：（产生消息的来源有三个）
（1） 由操作系统产生。
（2） 由用户触发的事件转换而来。
（3） 由另一个消息产生。
事件和消息的区别_顺其自然~的博客-CSDN博客_事件和消息
定时任务与消息队列的区别
定时任务作业更倾向于批处理，MQ倾向于逐条处理；
定时任务与消息队列的区别_时小浅的博客-CSDN博客_定时任务和消息队列
生产者消费者模式、订阅发布模式及观察者模式之间的区别：
生产者消费者只能消费一次，同一条消息的多个消费者之间会存在竞争关系；（消息）
订阅发布模式则不存在竞争关系；（事件）
观察者模式中，被观察者需要维护观察者的信息以便事件发生时能够通知到对方；这也导致观察者模式存在逻辑上的耦合；
笔记【生产者消费者模式、订阅发布模式及观察者模式之间的区别】_臧馆长的博客-CSDN博客_消费者订阅者模式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5e002e495f45aa5efa3c92675a51de4/" rel="bookmark">
			JavaScript中数组的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Array Array描述常见操作创建数组通过索引访问数组元素遍历数组添加元素到数组末尾删除数组末尾的元素添加元素到数组头部删除数组头部元素找出某个元素在数组中的索引通过索引删除某个元素复制一个数组拼接两个数组分割数组，转为字符串数组排序数组转为字符串判断一个变量是否为一个数组反转数组 Array JavaScript 的 Array 对象是用于构造数组的全局对象，数组是类似于列表的高阶对象。
描述 数组是一种类列表对象，它的原型中提供了遍历和修改元素的相关操作。JavaScript 数组的长度和元素类型都是非固定的。因为数组的长度可随时改变，并且其数据在内存中也可以不连续，所以 JavaScript 数组不一定是密集型的，这取决于它的使用方式。一般来说，数组的这些特性会给使用带来方便，但如果这些特性不适用于你的特定使用场景的话，可以考虑使用类型数组 TypedArray。
常见操作 创建数组 // 创建一个空数组 let arr=[] //创建一个附带数据的数组 let arr1=['苹果14','华为meta50','iqoo11Pro'] 通过索引访问数组元素 let phone=arr1[2] console.log(phone);//iqoo11Pro //访问数组中最后一条最后数据 let last =arr1[arr1.length-1] console.log(last);//iqoo11Pro 遍历数组 item：是遍历数组中的每一条数据
index：索引值
arr1.forEach(function(item,index){ console.log(item+'---'+index); }) //苹果14---0 //华为meta50---1 //iqoo11Pro---2 添加元素到数组末尾 push：在数组末尾进行添加数据
arr1.push("小米12","小米11") console.log(arr1); ['苹果14', '华为meta50', 'iqoo11Pro', '小米12', '小米11'] 删除数组末尾的元素 pop：删除数组的最后一条数据，返回值就是删除的那个值
let delLast=arr1.pop() console.log(delLast);//iqoo11Pro console.log(arr1);//['苹果14', '华为meta50'] 添加元素到数组头部 unshift：在数组头部位置进行添加数据，可以同时添加多个
arr1.unshift("苹果4",'苹果5') console.log(arr1); //['苹果4', '苹果5', '苹果14', '华为meta50''iqoo11Pro'] 删除数组头部元素 shift：删除数组头部的那条数据。
这里要和unshift区分清楚，unshift是在头部添加元素
注意：返回值是删除的那条数据
let x= arr1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5e002e495f45aa5efa3c92675a51de4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e34ef0bb4b31bc213eeca94af7b858bc/" rel="bookmark">
			线索二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、线索二叉树的相关概念 1、由于二叉树链表中空指针域的数量较多：具有n个结点的二叉链表中，一共有2n个指针域;因为n个结点中有n-1个孩子，即2n个指针域中，有n-1个用来指示结点的左右孩子，其余n+1个指针域为空。
2、线索二叉树的定义：如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱;如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继——这种改变指向的指针称为 “线索"。加上了线索的二叉树称为线索二叉树，对二叉树按某种遍历次序使其变为线索二叉树的过程叫线索化。
3、研究线索二叉树的原因:当用二叉链表作为二叉树的存储结构时,可以很方便地找到某个结点的左右孩子;但一般情况下，无法直接找到该结点在某种遍历序列中的(因为在不同的遍历序列中，树结点的排列是不同的）前驱和后继结点。然而线索二叉树可以解决该问题。
二、线索二叉树的结构 1、为区分Irchid和rchild指针到底是指向孩子的指针，还是指向前驱或后继的指针，对二叉链表中每个结点增设两个标志域Itag和rtag，并约定：
Itag = 0 Ichild指向该结点的左孩子
Itag = 1 Ichild指向该结点的前驱
rtag = 0 rchild指向该结点的右孩子
rtag = 1 rchild指向该结点的后继
2、因此，结点的结构为：
3、因此线索二叉树的存储结构表示如下代码所示
typedef struct BiThrNode( int data; int ltag, rtag; struct BiThrNode *lchild,rchild;) BiThrNode,*BiThrTree ; 三、先序线索二叉树 1、一个简单的例子，有助于理解，如下图所示：
四、实际构建线索二叉树 1、增设了一个头结点:
Itag=0, lchild指向根结点，
rtag=1, rchild指向遍历序列中最后一个结点，
遍历序列中第一个结点的Ic域和最后一 个结点的rc域都指向头结点。如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee17d10854ff353709f42dc8c1a4327f/" rel="bookmark">
			fastGithub下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前登录Github时好好的，后来就怎么也查询不到该网页。搜索了很多资料，发现可以下载fastGithub来解决这个问题。仅仅用来分享经验，侵权立删。
1.登录清华大学云盘：清华大学云盘 (tsinghua.edu.cn)​​​​​​
根据电脑版本下载需要的压缩包：
2.下载后是一个压缩包，直接解压
3.解压后直接点击 FastGithub.UI.exe即可
4. 启动后直接从网页输入GitHub网址或者你所要打开的网址，即可进入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17df186d2d90f78c1ac0eba83a8fec3e/" rel="bookmark">
			CSS 浮动(float) 宝妈级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🏀标准流🏀
🥎 为什么需要浮动嘞?🥎
⚾ 什么是浮动?⚾
🥌 浮动特性🥌
🏐实战小技巧🏐
🌕清除浮动 🌕
🌒为什么要清除浮动? 🌒
🌑清除浮动方法🌑
🏀标准流🏀 标签按照规定好的默认方式排序
块级元素独占一行 从上向下顺序排列
div hr p h1-h6 ul ol form table
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;float&lt;/title&gt; &lt;style&gt; div { color: bisque; width: 300px; background-color: #c5708b; } h2 { color: #1677b3; width: 300px; background-color: #5698c3; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;h2&gt;我是h2&lt;/h2&gt; &lt;/body&gt; &lt;/html&gt; 🥎 为什么需要浮动嘞?🥎 很多的布局效果,标准流没有办法完成,就需要利用到浮动完成布局.
浮动可以改变元素标签默认的排列方式
网页布局第一准则:
多个块级元素纵向排列找标准流
多个块级元素横向排列找浮动
⚾ 什么是浮动?⚾ float 属性用于创建浮动框
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17df186d2d90f78c1ac0eba83a8fec3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cffdb51cad9e3fcdb073b6387e81fee/" rel="bookmark">
			异或 MTP 攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		符号 ⊕ 代表异或
C1 代表密文
M1 代表明文
性质 交换律结合律 (a ⊕ b ) ⊕ c = a⊕ ( b ⊕ c)任何数x x ⊕ x = 0 x ⊕ 0 = X自反性 x ⊕ b ⊕ b = x ⊕ 0 = x MTP 攻击 BUUCTF: [AFCTF2018]
25030206463d3d393131555f7f1d061d4052111a19544e2e5d54 0f020606150f203f307f5c0a7f24070747130e16545000035d54 1203075429152a7020365c167f390f1013170b1006481e13144e 0f4610170e1e2235787f7853372c0f065752111b15454e0e0901 081543000e1e6f3f3a3348533a270d064a02111a1b5f4e0a1855 0909075412132e247436425332281a1c561f04071d520f0b1158 4116111b101e2170203011113a69001b47520601155205021901 041006064612297020375453342c17545a01451811411a470e44 021311114a5b0335207f7c167f22001b44520c15544801125d40 06140611460c26243c7f5c167f3d015446010053005907145d44 0f05110d160f263f3a7f4210372c03111313090415481d49530f 设每一个字符为Ci,都是某个可以异或上明文 Mi 得到的.我们的目标是获取到这个key,已知明文是英文句子.
C 1 ⨁ C 2 = ( M 1 ⨁ k e y ) ⨁ ( M 2 ⨁ k e y ) = M 1 ⨁ M 2 C_1 \bigoplus C_2 = (M_1 \bigoplus key) \bigoplus (M_2 \bigoplus key) = M_1 \bigoplus M_2 C1​⨁C2​=(M1​⨁key)⨁(M2​⨁key)=M1​⨁M2​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cffdb51cad9e3fcdb073b6387e81fee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/971153752cc88ac3d456ac1907151651/" rel="bookmark">
			【数据结构--二维数组】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 二维数组二维数组定义二维数组的创建 二维数组的应用矩阵加法矩阵乘法 二维数组 二维数组定义 二维数组本质上是以数组作为数组元素的数组，即数组的数组。
二维数组就是一个有行和列的矩阵，每一行代表一个数组，即数组的数组；每一行数组内元素所在的位置可以用行和列号来表示 二维数组的创建 动态二维数组
动态二维数组图示 elements是动态二维数组变量，其是指向包含两个整型元素数组的指针（即指向二维数组首地址），elements[0]、elements[1]、elements[2]存储的值为一个包含两个整型元素的一维数组的首地址。
代码：
结构体定义
typedef int ElemType; /* 动态空间分配 */ typedef struct TwoDArry { int rows; int columns; ElemType** elements; } TwoDArray, *TwoDArrayPtr; 初始化
/* 初始化二维数组 */ TwoDArrayPtr initTwoDArray(int tempRows, int tempColumns) { TwoDArrayPtr resultPtr = (TwoDArrayPtr)malloc(sizeof(TwoDArray)); resultPtr-&gt;rows = tempRows; resultPtr-&gt;columns = tempColumns; resultPtr-&gt;elements = (ElemType**)malloc(sizeof(ElemType*)*tempRows); for(int i = 0; i &lt; tempRows; ++i) { resultPtr-&gt;elements[i] = (ElemType*)malloc(sizeof(ElemType)*tempColumns); } return resultPtr; } 静态二维数组
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/971153752cc88ac3d456ac1907151651/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d182bf896d4073d52b6e1e5186d7f8d/" rel="bookmark">
			【数据结构--哈夫曼编码（C语言版）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 哈夫曼树及其应用哈夫曼树哈夫曼树的特点哈夫曼树的构造哈夫曼编码 哈夫曼树及其应用 哈夫曼树 介绍哈夫曼树前先介绍下面几个名词：
1. 结点的路径长度l
从根结点到该结点的路径上分支的数目，如下图结点a的l = 3。
2. 树的路径长度
树中所有叶子结点的路径长度之和，如下图该树的路径长度为2 + 3 + 3 + 2 + 2。
3. 结点的权w
给每一个结点赋予一个新的数值，称为这个结点的权。
4. 结点的带权路径长度l * w
从根结点到该结点之间的路径长度与该结点的权的乘积,下图结点a的带权路径长度为l * w = 3。
5. 树的带权路径长度 WPL = ∑li * wi
树中所有叶子结点的带权路径长度之和。
带权路径长度WPL最小的二叉树称为哈夫曼树（又称为最优二叉树）。
哈夫曼树的特点 权值小的结点离根远，权值大的结点离根近。结点的度：没有度为1的结点。 哈夫曼树的构造 思路：
1. 对于给定的有各自权值的n个结点，从n个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新的二叉树的根结点的权值为左右孩子权值的和
2. 在原有的n个权值中删除那两个最小的权值，同时将新的权值加入到n-2个权值的行列中，以此类推
3. 重复1和2，直到所有的结点构建成了一棵二叉树为止，该树即为哈夫曼树。
按权构造哈夫曼树的过程如下图 哈夫曼编码 一般地，设需要编码的字符集为{d1, d2, …… ,dn}，各个字符在电文中出现的次数或频率集合为{w1, w2, …… , wn}，以d1，d2，…… ，dn作为叶子结点，以w1，w2，…… ，wn作为相应叶子结点的权值来构造一棵哈夫曼树。规定哈夫曼树的左分支代表0，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，这就是哈夫曼编码。
例如有一段文字内容"WINNIE WILL WIN"其中W的权值为3，I的权值为4，N的权值为3，E的权值为1，L的权值为2 ，则其按哈夫曼树规划如下。
哈夫曼编码 WINEL34312001110010011 构造以W(3)、I(4)、N(3)、E(1)、L(2)为叶子结点的哈夫曼树将该二叉树所有左分枝标记0，所有右分枝标记1根结点到叶子结点所经过的二进制序列为该叶子结点字符的编码 哈夫曼树结构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d182bf896d4073d52b6e1e5186d7f8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69a46c8c2cc6b23406cd8e440c4b5103/" rel="bookmark">
			【数据结构--栈的顺序存储结构】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 栈的顺序存储结构栈的定义栈的初始化压栈操作弹栈操作返回栈顶元素返回栈的长度将栈清空完整代码测试结果总结 栈的顺序存储结构 栈的定义 栈（stack）是限定仅在表尾进行插入和删除的线性表
允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom），不含任何数据元素的栈称为空栈。栈又称为先进后出的线性表，简称LIFO结构。
栈的插入操作，叫做进栈，也称为压栈、入栈，如下图所示。
栈的删除操作，叫做出栈，也称为弹栈，如下图所示。
栈的结构定义：
typedef struct CharStack { int top; /* 用于栈顶指针 */ int data[MAXSIZE]; } *CharStackPtr,CharStack; 栈的初始化 栈的初始化即为顺序栈动态分配一个预定义大小的数组空间
代码如下：
//初始化栈 CharStackPtr CharStackInit() { CharStackPtr resultPtr = (CharStackPtr)malloc(sizeof(CharStack)); resultPtr-&gt;top = -1; return resultPtr; } 压栈操作 压栈即为在栈顶插入一个新元素
代码如下：
//压栈 void push(CharStackPtr tempStackPtr, char tempValue) { if(tempStackPtr-&gt;top &gt;= MAXSIZE - 1) { printf("无法压入元素%c：堆栈已满!\n",tempValue); return ; } tempStackPtr-&gt;top ++; tempStackPtr-&gt;data[tempStackPtr-&gt;top] = tempValue; } 弹栈操作 弹栈即为将栈顶元素删除
代码如下：
//弹栈 char pop(CharStackPtr tempStackPtr) { if (tempStackPtr-&gt;top == -1) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69a46c8c2cc6b23406cd8e440c4b5103/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67114ca83b70aff3ae2510014118e0c9/" rel="bookmark">
			【数据结构——链表应用：多项式求和】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 链表的应用——多项式加法结构体定义初始化链表打印链表在尾部添加一个元素多项式加法完整代码及运行截图 链表的应用——多项式加法 结构体定义 typedef struct LinkNode { int coefficient; int power; struct LinkNode* next; } *LinkList, *NodePtr, Node; 初始化链表 // 初始化链表 LinkList initLinkList() { LinkList tempHeader = (LinkList)malloc(sizeof(Node)); tempHeader-&gt;coefficient = 0; tempHeader-&gt;power = 0; tempHeader-&gt;next = NULL; return tempHeader; } 打印链表 //打印链表 void printList(LinkList tempHeader) { NodePtr p = tempHeader-&gt;next; while(p) { printf("%d * 10^%d + ",p-&gt;coefficient,p-&gt;power); p = p-&gt;next; } printf("\n"); } 在尾部添加一个元素 //在尾部添加一个元素 void appendElement(LinkList tempHeader, int tempCoefficient, int tempPower) { NodePtr p,q; q = (NodePtr)malloc(sizeof(Node)); q-&gt;coefficient = tempCoefficient; q-&gt;power = tempPower; q-&gt;next = NULL; p = tempHeader; while (p-&gt;next) { p = p-&gt;next; } p-&gt;next = q; } 多项式加法 算法步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67114ca83b70aff3ae2510014118e0c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17111753fd21484dc621b218f722a3da/" rel="bookmark">
			CentOS 开启端口方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看已经开放的端口：
firewall-cmd --list-ports 查看防火墙状态：
firewall-cmd --state 开启防火墙：
systemctl start firewalld.service 开启8080端口：
firewall-cmd --zone=public --add-port=8080/tcp --permanent &amp;&amp; firewall-cmd --reload 关闭8080端口：
firewall-cmd --zone=public --remove-port=8080/tcp --permanent 让我们来解释一下上一个命令： --zone=public:表示作用域为公共的； --add-port=8080/tcp：添加tcp协议的端口8080； --permanent：永久生效；(如果没有此参数，则只能维持当前服务生命周期内，重新启动后失效；) 重新加载配置：
firewall-cmd --reload 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78eaf4a4f328d746dd1fc87f07b7de3a/" rel="bookmark">
			git 常用命令以及细节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用命令 git config --global user.name xxx：设置全局用户名，信息记录在~/.gitconfig文件中 git config --global user.email xxx@xxx.com：设置全局邮箱地址，信息记录在~/.gitconfig文件中 git init：将当前目录配置成git仓库，信息记录在隐藏的.git文件夹中 git add XX：将XX文件添加到暂存区 git add .：将所有待加入暂存区的文件加入暂存区 git rm --cached XX：将文件从仓库索引目录中删掉 git commit -m "给自己看的备注信息"：将暂存区的内容提交到当前分支 git status：查看仓库状态 git diff XX：查看XX文件相对于暂存区修改了哪些内容 git log：查看当前分支的所有版本 git reflog：查看HEAD指针的移动历史（包括被回滚的版本） git reset --hard HEAD^ 或 git reset --hard HEAD~：将代码库回滚到上一个版本 git reset --hard HEAD^^：往上回滚两次，以此类推 git reset --hard HEAD~100：往上回滚100个版本 git reset --hard 版本号：回滚到某一特定版本 git checkout — XX或git restore XX：将XX文件尚未加入暂存区的修改全部撤销 git remote add origin git@git.acwing.com:xxx/XXX.git：将本地仓库关联到远程仓库 git push -u (第一次需要-u以后不需要)：将当前分支推送到远程仓库 git push origin branch_name：将本地的某个分支推送到远程仓库 git clone git@git.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78eaf4a4f328d746dd1fc87f07b7de3a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/124/">«</a>
	<span class="pagination__item pagination__item--current">125/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/126/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>