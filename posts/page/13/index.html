<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9a2de6b85e72357d518d420bb673dc4/" rel="bookmark">
			java项目应用MQTT传输数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 近期做的一个项目需要传输数据给第三方。根据协定，采用MQTT进行数据的发送和订阅。一般来说，不通系统进行数据对接，一般采用RESTFul接口，走http。mqtt的话，顾名思义，就是一个消息队列。相比RESTFul接口，MQTT方式也许有个好处就是，数据传输给对方后，对方可以收到一个提醒。这个提醒来自于消息队列，不用自己搞。利用这个提醒，也许可以做点啥。除此之外，我不知道还有什么更多的好处。
MQTT的要素：
1）broker，经纪人，即代理地址，如：tcp://10.0.2.18:1883
2）clientID，客户端ID，如"Client001"; 客户端标识，可以自定义，但发送端和接收端不要同名
3）topic，// 要发布的主题，接收端据此接收，如”monkey/huaguo-moutain“。主题一经定义，可以多次使用。
4）qos，质量服务等级 0，1，2。2最高。
依赖：
&lt;dependency&gt; &lt;groupId&gt;org.eclipse.paho&lt;/groupId&gt; &lt;artifactId&gt;org.eclipse.paho.client.mqttv3&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;/dependency&gt; 二、发送 如果单纯发送，客户端无须安装mqtt。Java中发送消息代码如下：
import org.eclipse.paho.client.mqttv3.MqttClient; import org.eclipse.paho.client.mqttv3.MqttConnectOptions; import org.eclipse.paho.client.mqttv3.MqttException; import org.eclipse.paho.client.mqttv3.MqttMessage; import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence; public class MqttPublisher { String broker = "tcp://127.0.0.1:1883"; // 替换为你的 MQTT 服务器地址 String clientId = "Client001"; // 客户端标识 String topic = "mqttdemo/mytopic001"; // 要发布的主题 int qos = 2; // 质量服务等级 MqttClient client = null; public MqttPublisher(String broker, String clientId, String topic, int qos) throws MqttException { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9a2de6b85e72357d518d420bb673dc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abaa2a61242ab60e5ce9facd79ba02e3/" rel="bookmark">
			python股票分析挖掘预测金融大数据获取方法和实现（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人股市多年的老韭菜了，各种股票分析书籍，技术指标书籍阅历无数，萌发想法，何不自己开发个股票预测分析软件，选择python因为够强大，它提供了很多高效便捷的数据分析工具包，
我们已经初步的接触与学习其中数据分析中常见的3大利器---Numpy,Pandas，Matplotlib库。
数据是万物之源，我们做股票分析，首要条件是获取最新的，最全面的金融数据，我们才能进行下一步开发。
我们获取数据主要有二大渠道，爬虫爬取金融网站数据和金融网站主动提供API接口方式获得，上一章简单介绍一下金融数据接口的使用方法，这章重点讲讲爬虫抓取数据技巧和方法
爬虫抓取数据方法：
从金融接口获取数据方法简单，但是属于被动的，特别是免费用户受到的限制很大，所以我们学习一下爬虫主动获取金融网站数据，
爬虫技术是这几年特别热门的技术，想要学精学好，需要相当的时间和精力，我们这里先了解个大概。
爬虫解析数据有很多种，爬取不同的数据，返回的数据类型不一样，有html、json、xml、文本（字符串）等多种格式！简单的介绍几种
(1）网络爬虫常见用法 (1)Xpath获取 XPath，全称XML Path Language，即XML 路径语⾔，它是⼀⻔在XML ⽂档中查找信息的语⾔。最初是⽤来搜寻XML ⽂档的，但同样适⽤于HTML ⽂档的搜索。所以在做爬⾍时完全可以使⽤XPath做相应的信息抽取。
安装：pip install lxml 获取请求： url = 'https://pic.netbian.com/4kmeinv/index_5.html' headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36' } 注意：headers里面的浏览器版本必须对应个人开发者电脑版本，要不可能爬取错误
完整代码： import requests from lxml import etree import os url = 'https://pic.netbian.com/4kmeinv/index_5.html' headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abaa2a61242ab60e5ce9facd79ba02e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/097121c40d4488c6a40b8df3b078ceb5/" rel="bookmark">
			2007-2019年中国人口与就业统计年鉴， pdf、xls不定，多项指标可查，可预览后下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据名称: 中国人口与就业统计年鉴
数据格式: pdf、xls不定
数据时间: 2007-2019年
数据几何类型: 文本
数据坐标系: ——
数据来源：国家统计局
数据字段: ——
数据预览 目录第一部分　综合数据1-1 分地区年末人口数1-2 按性别分人口数1-3 人口年龄结构和抚养比1-4 按城乡分人口数1-5 分地区年末城镇人口比重1-6 人口出生率、死亡率和自然增长率1-7 各地区人口出生率、死亡率和自然增长率1-8 流动人口数1-9 平均预期寿命1-10 各地区人口平均预期寿命1-11 七次全国人口普查人口基本情况1-12 全国历年人口密度1-13 就业基本情况1-14 分城乡就业人员年末人数1-15 分产业就业人员年末人数1-16 分地区就业人员数(2021年底数)1-17 城镇登记失业人数及失业率(年末数)1-18 2021年全国城镇调查失业率主要数据1-19 分行业城镇非私营单位就业人员年末人数1-20 分登记注册类型城镇非私营单位就业人员年末人数1-21 分行业城镇非私营单位女性就业人员年末人数1-22 分登记注册类型城镇非私营单位女性就业人员年末人数1-23 分地区按行业分城镇非私营单位就业人员数(2021年)1-24 分登记注册类型城镇非私营单位就业人员平均工资1-25 分登记注册类型城镇非私营单位就业人员平均工资指数1-26 分行业城镇非私营单位就业人员平均工资1-27 分地区城镇非私营单位就业人员平均工资1-28 分地区按行业分城镇非私营单位就业人员平均工资(2021年)1-29 分地区按行业分城镇私营单位就业人员平均工资(2021年)第二部分　2021年人口变动情况抽样调查数据2-1 各地区人口数及人口自然变动情况2-2 各地区人口的城乡构成2-3 全国分年龄、性别的人口数2-4 全国城市分年龄、性别的人口数2-5 全国镇分年龄、性别的人口数2-6 全国乡村分年龄、性别的人口数2-7 各地区人口年龄构成和抚养比2-8 各地区城市人口年龄构成和抚养比2-9 各地区镇人口年龄构成和抚养比2-10 各地区乡村人口年龄构成和抚养比2-11 各地区户数、人口数、性别比和平均家庭户规模2-12 各地区城市户数、人口数、性别比和平均家庭户规模2-13 各地区镇的户数、人口数、性别比和平均家庭户规模2-14 各地区乡村户数、人口数、性别比和平均家庭户规模2-15 各地区按家庭户规模分的户数2-16 各地区城市按家庭户规模分的户数2-17 各地区镇按家庭户规模分的户数2-18 各地区乡村按家庭户规模分的户数2-19 各地区家庭户类别2-20 各地区城市家庭户类别2-21 各地区镇家庭户类别2-22 各地区乡村家庭户类别2-23 全国家庭户人数和户主的年龄、性别构成2-24 各地区分性别、受教育程度的人口2-25 各地区城市分性别、受教育程度的人口2-26 各地区镇分性别、受教育程度的人口2-27 各地区乡村分性别、受教育程度的人口2-28 各地区分性别的15岁及以上文盲人口2-29 各地区城市分性别的15岁及以上文盲人口2-30 各地区镇分性别的15岁及以上文盲人口2-31 各地区乡村分性别的15岁及以上文盲人口2-32 全国15岁及以上人口分年龄、性别的婚姻状况2-33 全国城市15岁及以上人口分年龄、性别的婚姻状况2-34 全国镇15岁及以上人口分年龄、性别的婚姻状况2-35 全国乡村15岁及以上人口分年龄、性别的婚姻状况2-36 各地区分性别、婚姻状况的人口2-37 各地区城市分性别、婚姻状况的人口2-38 各地区镇分性别、婚姻状况的人口2-39 各地区农村分性别、婚姻状况的人口2-40 全国育龄妇女分年龄、孩次的生育状况(2020年11月1日至2021年10月31日)2-41 全国城市育龄妇女分年龄、孩次的生育状况(2020年11月1日至2021年10月31日)2-42 全国镇育龄妇女分年龄、孩次的生育状况(2020年11月1日至2021年10月31日)2-43 全国乡村育龄妇女分年龄、孩次的生育状况(2020年11月1日至2021年10月31日)2-44 全国分年龄、性别的死亡人口状况(2020年11月1日至2021年10月31日)2-45 全国城市分年龄、性别的死亡人口状况(2020年11月1日至2021年10月31日)2-46 全国镇分年龄、性别的死亡人口状况(2020年11月1日至2021年10月31日)2-47 全国乡村分年龄、性别的死亡人口状况(2020年11月1日至2021年10月31日)2-48 各地区分性别的各种户口状况人口2-49 各地区城市分性别的各种户口状况人口2-50 各地区镇分性别的各种户口状况人口2-51 各地区乡村分性别的各种户口状况人口第三部分　2021年劳动力调查主要数据3-1 全国分地区就业人员受教育程度构成3-2 全国分地区男性就业人员受教育程度构成3-3 全国分地区女性就业人员受教育程度构成3-4 全国按年龄、性别分的就业人员受教育程度构成3-5 全国按受教育程度、性别分的就业人员年龄构成3-6 全国按行业、性别分的就业人员受教育程度构成3-7 全国按职业、性别分的就业人员受教育程度构成3-8 全国按受教育程度、性别分的就业人员职业构成3-9 全国按年龄、性别分的就业人员就业身份构成3-10 全国按就业身份、性别分的就业人员年龄构成3-11 全国按受教育程度、性别分的就业人员就业身份构成3-12 全国按就业身份、性别分的就业人员受教育程度构成3-13 城镇按年龄、性别分的就业人员就业身份构成3-14 城镇按就业身份、性别分的就业人员年龄构成3-15 城镇按受教育程度、性别分的就业人员就业身份构成3-16 城镇按就业身份、性别分的就业人员受教育程度构成3-17 城镇按年龄、性别分的就业人员行业构成3-18 城镇按行业、性别分的就业人员年龄构成3-19 城镇按受教育程度、性别分的就业人员行业构成3-20 城镇按行业、性别分的就业人员受教育程度构成3-21 城镇按年龄、性别分的就业人员职业构成3-22 城镇按职业、性别分的就业人员年龄构成3-23 城镇按受教育程度、性别分的就业人员职业构成3-24 城镇按职业、性别分的就业人员受教育程度构成3-25 城镇就业人员调查周平均工作时间3-26 城镇男性就业人员调查周平均工作时间3-27 城镇女性就业人员调查周平均工作时间3-28 城镇按年龄、性别分的就业人员工作时间构成3-29 城镇按受教育程度、性别分的就业人员工作时间构成3-30 城镇按行业、性别分的就业人员工作时间构成3-31 城镇按职业、性别分的就业人员工作时间构成3-32 城镇按年龄、性别分的失业人员结束上一份工作原因构成3-33 城镇按结束上一份工作原因、性别分的失业人员年龄构成3-34 城镇按受教育程度、性别分的失业人员结束上一份工作原因构成3-35 城镇按结束上一份工作原因、性别分的失业人员受教育程度构成3-36 城镇按年龄、性别分的失业人员受教育程度构成3-37 城镇按受教育程度、性别分的失业人员年龄构成3-38 城镇按年龄、性别分的失业人员寻找工作方式构成3-39 城镇按受教育程度、性别分的失业人员寻找工作方式构成3-40 城镇按年龄、性别分的失业人员失业前的行业构成3-41 城镇按受教育程度、性别分的失业人员失业前的行业构成3-42 城镇按年龄、性别分的失业人员失业前的职业构成3-43 城镇按受教育程度、性别分的失业人员失业前的职业构成3-44 城镇按受教育程度、性别分的失业人员失业时间构成3-45 城镇按年龄、性别分的失业人员失业时间构成第四部分　2021年城镇单位就业人员统计数据4-1 各地区分行业国有单位就业人员数4-2 各地区分行业城镇集体单位就业人员数4-3 各地区分行业其他单位就业人员数第五部分　2021年全国户籍统计人口数据5-1 各地区总户数、总人口5-2 各地区市总户数、总人口5-3 各地区县总户数、总人口5-4 各地区区县人口数5-4 续表 15-4 续表 25-4 续表 35-4 续表 45-4 续表 55-4 续表 65-4 续表 75-4 续表 85-4 续表 95-4 续表 105-4 续表 115-4 续表 125-4 续表 135-4 续表 145-4 续表 155-4 续表 165-4 续表 175-4 续表 185-4 续表 195-4 续表 205-4 续表 215-4 续表 225-4 续表 235-4 续表 245-4 续表 255-4 续表 265-4 续表 275-4 续表 285-4 续表 295-4 续表 305-4 续表 315-4 续表 325-4 续表 335-4 续表 345-4 续表 355-5 按总人口排序的市及人口数5-5 续表 15-5 续表 25-5 续表 35-5 续表 45-5 续表 55-5 续表 65-5 续表 7第六部分　世界部分国家及地区人口和就业统计数据一、世界部分国家人口和就业统计数据6-1 人口数6-2 人口出生率、死亡率、自然增长率6-3 人口年龄构成6-4 人口指标6-5 全部就业人数6-6 按三次产业分就业人员构成6-7 失业人数6-8 失业率6-9 消费价格指数二、香港特别行政区人口和就业统计数据6-10 人口主要指标6-11 劳动人口及失业状况6-12 按行业划分的就业人数6-13 按每月就业收入划分的就业人数6-14 按行业划分督导级(不包括经理级与专业雇员)及以下雇员的工资指数6-15 消费物价指数(2019年10月-2020年9月=100)三、澳门特别行政区人口和就业统计数据6-16 人口主要指标6-17 经济活动人口及失业状况6-18 按行业划分的就业人口6-19 按行业划分的月工作收入中位数6-20 消费物价指数四、台湾省人口和就业统计数据6-21 面积和人口主要指标6-22 劳动力和就业状况6-23 居民消费价格分类指数第七部分　2021年人口变动情况抽样调查和劳动力调查制度说明及主要指标解释人口变动情况抽样调查制度劳动力调查制度主要统计指标解释 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9edb39a04b9db08c3034b0c1b3ebce57/" rel="bookmark">
			3、漫谈分布式系统、拜占庭将军问题与区块链
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式系统和一致性问题 拜占庭将军问题 我们前面讨论的一致性协议，有一个重要的前提条件，就是：各个节点都是可以信任的，它们都严格遵守同样的一套规则。这个条件，在一个公司的内部网络中可以认为是基本能满足的。但如果这个条件不满足会怎么样呢？假设网络中有些节点是恶意的，它们不但不遵守协议，还故意捣乱（比如胡乱发送消息），那么其它正常的节点还能够顺利工作吗？
在分布式系统理论中，这个问题被抽象成了一个著名的问题—拜占庭将军问题(Byzantine Generals Problem)。这个问题由大名鼎鼎的Leslie Lamport提出，也就是Paxos的作者。同时，Lamport还是2013年的图灵奖得主。
这要从一个故事开始说起。拜占庭帝国的几支军队攻打到了敌人的城市外面，然后分开驻扎。每一支军队由一位拜占庭将军(Byzantine general)率领。为了制定出一个统一的作战计划，每一位将军需要通过信差(messenger)与其它将军互通消息。但是，在拜占庭将军之间可能出现了叛徒(traitor)。这些叛徒将军的目的是阻挠其他忠诚的将军(loyal generals)达成一致的作战计划。为了这一目的，他们可能做任何事，比如串通起来，故意传出虚假消息，或者不传出任何消息。 我们来看一个简单的例子。假设有5位将军，他们投票来决定是进攻还是撤退。其中两位认为应该进攻，还有两位认为应该撤退，这时候进攻和撤退的票数是2:2打平了。第五位将军恰好是个叛徒，他告诉前两位应该进攻，但告诉后两位应该撤退，结果前两位将军最终决定进攻，而后两位将军却决定撤退。没有达成一致的作战计划。
这个问题显然比我们在前一章讨论的可信任环境下的一致性问题要更难。要解决这个问题，我们是希望能找到一个算法，保证在存在叛徒阻挠的情况下，我们仍然能够达成如下目标：
A. 所有忠诚的将军都得到了相同（一致）的作战计划。比如都决定进攻，或都决定撤退，而不是有些将军认为应该进攻，其他将军却决定撤退。B. 忠诚的将军不仅得到了相同的作战计划，还应该保证得到的作战计划是合理的(reasonable)。比如，本来进攻是更有利的作战计划，但由于叛徒的阻挠，最终却制定出了一起撤退的计划。这样我们的算法也算失败了。 可以看出，上面的目标A，是比较明确的，至少给定一个算法很容易判定它有没有达到这个目标。但目标B却让人无从下手。一个作战计划是不是「合理」的，本来就不好定义。即使没有叛徒的存在，忠诚的将军们也未必就一定能制定出合理的计划。这涉及到科学研究中一个非常重要的问题，如果一个事情不能用一种形式化的方式清晰的定义出来，对于它的研究也就无从谈起，这个事情本身也无法上升到科学的层面。Lamport在对拜占庭将军问题的研究中，一个突出的贡献就是，把这个看似不太好界定的问题，巧妙地归约到了一个能用数学语言精确描述的问题上去。下面我们就看一下这个过程是怎么做的。
首先我们考虑一下将军们制定作战计划的过程（先假设没有叛徒）。每一位将军根据自己对战局的观察，给出他建议的作战计划——是进攻还是撤退，这称为作战提议。然后，每位将军把自己的作战提议通过信差传达给其他每一位将军。现在每一位将军都知道了其他将军的作战提议，再加上他自己的作战提议，他需要根据所有这些信息得到最终的一个作战计划。为了表达上更清晰，我们给每位将军进行编号，分别是1, 2, …, n，每位将军提出的作战提议记为v(1), v(2), …, v(n)，一共是n个值，这其中有些代表「进攻」，有些代表「撤退」。经过信差传递消息之后，每位将军都看到了相同的作战提议序列v(1), v(2), …, v(n)，当然这其中的一个是当前这位将军自己提出来的。然后只要每位将军采用同样的方法，对所有的v(1), v(2), …, v(n)这些信息进行汇总，就能得到同样的最终作战计划。比如，容易想到的一个方法是投票法，即对v(1), v(2), …, v(n)中不同的作战提议进行投票，最后选择得票最多的作为最终作战计划。
当然，这样得到的最终作战计划也不能保证就是最好的，但这应该是我们能做到的最好的了。我们现在仍然假设将军里没有叛徒。我们发现，前面提到的目标A和目标B的要求可以适当「降低」一些：我们不再关注将军们是否能达成最终一致的作战计划，并且这个计划是不是「合理」；我们只关注每个将军是否收到了完全相同的作战提议v(1), v(2), …, v(n)。只要每位将军收到的这些作战提议是完全相同的，他们再用同样的方法进行汇总，就很容易得到最终一致的作战计划。至于这个最终的作战计划是不是最好的，那就跟很多「人为」的因素有关了，我们不去管它。
现在我们考虑将军中出现了叛徒。遵循前面的思路，我们仍然希望每位将军能够收到完全相同的作战提议v(1), v(2), …, v(n)。现在我们仔细审视一下其中的一个值，v(i)，在前面的描述中，它表示来自第i个将军的作战提议。如果第i个将军是忠诚的，那么这个定义没有什么问题。但是，如果第i个将军是叛徒，那么就有问题了。为什么呢？因为叛徒可以为所欲为，他为了扰乱整个作战计划的制定，完全可能向不同的将军给出不同的作战提议。这样的话，不同的忠诚将军收到的来自第i个将军的v(i)可能是不同的值。这样v(i)这个定义就不对了，它需要改一改。
不管怎么样，即使存在叛徒，我们还是希望每位将军最终是基于完全相同的作战提议来做汇总，这些作战提议仍然记为v(1), v(2), …, v(n)。不过，这里的v(i)不再表示来自第i个将军的作战提议，而是表示经过我们设计的某个一致性算法处理之后，每位将军最终看到的第i个提议。这里需要分两种情况讨论。首先第一种情况，如果第i个将军是忠诚的，那么我们自然希望这个v(i)就是第i个将军发送出来的作战提议。换句话说，我们希望经过一致性算法处理之后，第i个将军如果是忠诚的，那么它的提议能够被如实地传达给其他将军，而不会被叛徒的行为所干扰。这是可能制定出「合理」作战计划的前提。第二种情况，如果第i个将军是叛徒，那么他有可能向不同的将军发送不同的提议。这时候我们不能够只听他的一面之词，而是希望经过一致性算法处理之后，各个将军之间充分交换意见，然后根据其他各个将军转述的信息，综合判断得到一个v(i)。这个v(i)是进攻还是撤退，并不太重要，关键是要保证每位将军得到的v(i)是相同的。只有这样，各位将军经过汇总所有的v(1), v(2), …, v(n)之后才能得到最终的完全一致的作战计划。
根据上面的分析，我们发现，在这两种情况中，我们都只需要关注单个将军（也就是第i个将军）所发出的提议如何传达给其他将军。重点终于来了！至此，我们就能够把原来的问题归约到一个子问题上。这个子问题，才是Leslie Lamport在他的论文中被真正命名为「拜占庭将军问题(Byzantine Generals Problem)」的那个问题。在这个问题中，我们只关注发送命令的单个将军，称他为主将(commanding general)，而其他接受命令的将军称为副官(lieutenant)。下面是「拜占庭将军问题」的精确描述。
一个主将发送命令给n-1个副官，如何才能确保下面两个条件：
(IC1) 所有忠诚的副官最终都接受相同的命令。(IC2) 如果主将是忠诚的，那么所有忠诚的副官都接受主将发出的命令。 这其实正好对应了我们前面已经讨论过的两种情况。如果主将是忠诚的，那么条件IC2保证了命令如实地传递，这时候条件IC1自然也满足了；如果主将是叛徒，那么条件IC2没有意义了，而条件IC1保证了，即使叛徒主将对每个副官发出不同的命令，每个副官仍然能最终获得一致的命令。
这里有两个地方可能让人产生疑惑。
第一，有些人会问了，难道主将还能是叛徒？主将都是叛徒了，还有啥搞头啊？其实是这样的，这个「拜占庭将军问题」只是原问题的一个子问题。当n个将军通过传递消息来决策作战计划的时候，可以分解成n个「拜占庭将军问题」，即分别以每位将军作为主将，以其余n-1位将军作为副官。如果有一个算法能够解决「拜占庭将军问题」，那么同时运行n个算法实例，就能使得每位将军都获得完全相同的作战提议序列，即前面我们提到的v(1), v(2), …, v(n)。最后，每位将军将v(1), v(2), …, v(n)使用相同的方法进行汇总（比如按多数投票），就能得到最终的作战计划。
第二，当主将是叛徒的时候，他可以向不同的副官发送不同的命令，怎么可能每个副官仍然能最终获得一致的命令呢？这正是算法需要解决的。其实这也容易解释（我们前面也提到过这个思路），由于主将可能向不同的副官发送不同的命令，所以副官不能直接采用主将发来的命令，而是也要看看其他副官转述来的主将的命令是什么。然后，一个副官综合了由所有副官转述的命令（再加上主将直接发来的命令）之后，就可能得到比较全面的信息，从而做出一致的判断（在实际中是个不断迭代的过程）。
好了，我们用了这么多篇幅，终于把「拜占庭将军问题」本身描述清楚了。这实际上也是最难的部分。我们上一章提到过，理解问题本身比理解问题的答案更重要。只要问题本身分析清楚了，如何设计一个能解决它的算法就只是细节问题了。我们这里不深入算法的细节了，感兴趣的读者可以去查阅下列论文：
我们这里只提一下论文给出的算法的结论。
使用不同的消息模型，「拜占庭将军问题」有不同的解法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9edb39a04b9db08c3034b0c1b3ebce57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/004c8afc8cf7f421685b07314bca230f/" rel="bookmark">
			编程语言的未来：创新与普及的融合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着科技的飞速发展，编程语言在计算机领域中扮演着至关重要的角色。它们是软件开发的核心，为程序员提供了与机器沟通的桥梁。然而，随着技术的不断进步，编程语言的未来又将如何呢？本文将探讨编程语言在创新与普及方面的融合，展望未来的发展趋势。
首先，编程语言将越来越注重创新。随着人工智能、大数据和区块链等技术的不断发展，编程语言需要不断适应新的应用场景和需求。未来的编程语言将更加注重简洁、高效、可扩展和安全性。新的编程语言将会出现，具备更强大的功能和更高的抽象级别，使开发人员能够更快速地构建复杂的应用程序。同时，编程语言还将更加注重可读性和可维护性，以提高团队协作和代码质量。
其次，编程语言的普及将越来越广泛。随着计算机科学的普及和人们对技术的需求增加，编程将成为一项基本的技能。未来的编程语言将更加注重易学性和友好性，使更多的人能够轻松地学习和使用。编程语言将更加贴近自然语言，采用更直观的语法和编码方式，降低了学习门槛。同时，编程语言的学习资源和教育机构也将更加丰富和多样化，为广大学习者提供更好的学习环境和支持。
此外，编程语言的跨平台性将得到进一步提升。随着移动设备和云计算的普及，软件开发需要在多种平台上进行。未来的编程语言将更加注重跨平台的能力，使开发人员能够更方便地编写一次代码，然后在不同的平台上运行。同时，编程语言将更加注重与其他技术的集成，如云计算服务、物联网设备和人工智能算法等，以提供更丰富的开发工具和功能。
最后，编程语言的社区和开源文化将变得更加重要。开源软件和社区对于编程语言的发展起到了重要的推动作用。未来的编程语言将更加注重社区的参与和贡献，鼓励开发者共同合作和分享。开源软件将变得更加普遍和成熟，为开发人员提供更多的工具和资源。同时，编程语言的标准化和规范化也将得到加强，以提高互操作性和代码的可移植性。
综上所述，编程语言在未来将继续发展和创新。它们将更加注重创新、普及、跨平台和社区的融合。作为程序员和技术爱好者，我们应该持续关注编程语言的发展，不断学习和掌握新的技术，以适应未来的需求和挑战。编程语言将继续引领技术的进步，为我们创造更美好的未来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bba8c36f0fc8b12e718f3931b837e4c2/" rel="bookmark">
			WPF 基础入门（样式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.1 一般样式 &lt;Grid Margin="10"&gt; &lt;TextBlock Text="Style test" Foreground="Red" FontSize="20"/&gt; &lt;/Grid&gt; 3.2内嵌样式 直接在控件上定义样式，如下所示：
&lt;Grid Margin="10"&gt; &lt;TextBlock Text="Style test"&gt; &lt;TextBlock.Style&gt; &lt;Style&gt; &lt;Setter Property="TextBlock.FontSize" Value="36" /&gt; &lt;/Style&gt; &lt;/TextBlock.Style&gt; &lt;/TextBlock&gt; &lt;/Grid&gt; 3.3父资源样式 使用控件的Resources部分，可以面向此控件的子控件（以及这些子控件的子控件等）。 &lt;Grid Margin="10"&gt; &lt;Grid.Resources&gt; &lt;Style TargetType="{x:Type TextBlock}"&gt; &lt;Setter Property="Foreground" Value="Red" /&gt; &lt;Setter Property="FontSize" Value="24" /&gt; &lt;/Style&gt; &lt;/Grid.Resources&gt; &lt;TextBlock Text="Style test"/&gt; &lt;/Grid&gt; 3.4窗口资源样式 写在Window窗口下面的资源样式，当前窗口下样式起作用。
&lt;Window.Resources&gt; &lt;Style TargetType="TextBlock"&gt; &lt;Setter Property="Foreground" Value="Red" /&gt; &lt;Setter Property="FontSize" Value="24" /&gt; &lt;/Style&gt; &lt;/Window.Resources&gt; &lt;Grid Margin="10"&gt; &lt;TextBlock Text="Style test"/&gt; &lt;/Grid&gt; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bba8c36f0fc8b12e718f3931b837e4c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/844cef232a6c9a14a99fa864b4938f7f/" rel="bookmark">
			数据结构入门到入土——List的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一，什么是List？
二，常见接口介绍
三，List的使用
一，什么是List？ 在集合框架中，List是一个接口，继承自Collection。
Collection也是一个接口，该接口中规范了后序容器中常用的一些方法，具体如下所示： Iterable也是一个接口，表示实现该接口的类是可以逐个元素进行遍历的，具体如下： List的官方文档 站在数据结构的角度来看，List就是一个线性表，即n个具有相同类型元素的有限序列，在该序列上可以执行增删改查以及变量等操作。 二，常见接口介绍 List中提供了好的方法，具体如下：
虽然方法很多，但是常用的如下：
方法解释boolean add(E e)尾插e void add (int index, E element) 将e插入到index位置 boolean addAll (Collection&lt;? extends E&gt; c) 尾插c中的元素 E remove (int index) 删除index位置元素 boolean remove (Object o) 删除遇到的第一个 o E get (int index) 获取下标index位置元素 E set (int index, E element) 将index位置元素设置为element void clear () 清空 boolean contains (Object o) 判断o是否在线性表中 int indexOf (Object o) 返回第一个o所在下标 int lastIndexOf (Object o) 返回最后一个o所在的下标 List&lt;E&gt; subList (int fromIndex, int toIndex) 截取部分List 三，List的使用 注意：List是个接口，并不能直接用来实例化。 如果要使用，必须去实例化List的实现类。在集合框架中，ArrayList和LinkedList都实现了List接口。 详情待下一章…… 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c61942ce42a6e3973829b16b94e46e1f/" rel="bookmark">
			VistualStudio查看类图UML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击菜单栏中的工具–》获取工具和功能。
然后在资源管理器中对应的代码中鼠标右键选择查看类图
生成一个ClassDiagram.cd文件就是类图的文件了。
根据需要拖拽就可以生成类图了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90fd9cce1aa582cd57cbc7894454a9a9/" rel="bookmark">
			【Vue】VueSlickCarousel实现轮播展览效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div class="slick"&gt; &lt;VueSlickCarousel v-bind="{ arrow: true, focusOnSelect: true, speed: 500, slidesToShow: 4, slidesToScroll: 1, touchThreshold: 5, }" &gt; &lt;div&gt;&lt;div class="slick-item"&gt;1&lt;/div&gt;&lt;/div&gt; &lt;div&gt;&lt;div class="slick-item"&gt;2&lt;/div&gt;&lt;/div&gt; &lt;div&gt;&lt;div class="slick-item"&gt;3&lt;/div&gt;&lt;/div&gt; &lt;div&gt;&lt;div class="slick-item"&gt;4&lt;/div&gt;&lt;/div&gt; &lt;div&gt;&lt;div class="slick-item"&gt;5&lt;/div&gt;&lt;/div&gt; &lt;div&gt;&lt;div class="slick-item"&gt;6&lt;/div&gt;&lt;/div&gt; &lt;div&gt;&lt;div class="slick-item"&gt;1&lt;/div&gt;&lt;/div&gt; &lt;div&gt;&lt;div class="slick-item"&gt;2&lt;/div&gt;&lt;/div&gt; &lt;div&gt;&lt;div class="slick-item"&gt;3&lt;/div&gt;&lt;/div&gt; &lt;div&gt;&lt;div class="slick-item"&gt;4&lt;/div&gt;&lt;/div&gt; &lt;div&gt;&lt;div class="slick-item"&gt;5&lt;/div&gt;&lt;/div&gt; &lt;div&gt;&lt;div class="slick-item"&gt;6&lt;/div&gt;&lt;/div&gt; &lt;template #prevArrow=""&gt; &lt;button class="arrow-btn"&gt;&amp;lt;&lt;/button&gt; &lt;/template&gt; &lt;template #nextArrow=""&gt; &lt;button class="arrow-btn"&gt;&amp;gt;&lt;/button&gt; &lt;/template&gt; &lt;/VueSlickCarousel&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import VueSlickCarousel from "vue-slick-carousel"; import "vue-slick-carousel/dist/vue-slick-carousel.css"; export default { components: { VueSlickCarousel }, }; &lt;/script&gt; &lt;style scoped lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90fd9cce1aa582cd57cbc7894454a9a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96681fe14a180f83c728acf1fb5a130e/" rel="bookmark">
			电脑系统坏了用U盘重装系统教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们平时办公、学习都会用到电脑，如果电脑系统坏了，就会影响自己正常使用电脑，这时候就可以通过U盘来重装一个正常的操作系统。如果您不知道具体的重装操作步骤，那么可以参考下面小编分享的利用U盘快速完成操作系统重装的步骤介绍。
准备工作
1. 一台正常联网可使用的电脑。
2. 一个大于8GB的空U盘。
3. 下载系统之家装机大师。
U盘启动盘制作步骤
注意：制作期间，U盘会被格式化，因此U盘中的重要文件请注意备份。如果需要安装系统的是C盘，重要文件请勿放在C盘和桌面上。
1. 退出安全软件，运行“系统之家装机大师”查看注意事项，点击“我知道了”。
2. 选择“U盘启动”点击“开始制作”。
3. 跳出提示备份U盘内重要资料，如无需备份，点击“确定”。
4. 选择自己想要安装的系统镜像，点击“下载系统并制作”。
5. 正在下载U盘启动工具制作时所需的组件，请耐心等待。
6. 正在下载系统镜像，请勿关闭软件。
7. 正在制作U盘启动工具。
8. 正在拷备系统镜像至U盘。
9. 提示制作完成，点击“确定”。
10. 选择“模拟启动”，点击“BIOS”。
11. 出现这个界面，表示系统之家装机大师U盘启动工具已制作成功。
U盘装Win10步骤
1. 查找自己电脑的U盘启动快捷键。
2. U盘插入电脑，重启电脑按快捷键选择U盘进行启动。进入后，键盘↑↓键选择第二个[02]启动Windows10PEx64（网络版），然后回车。
3. 进入PE界面后，点击桌面的一键重装系统。
4. 打开工具后，点击浏览选择U盘中的下载好的系统镜像ISO。选择后，再选择系统安装的分区，一般为C区，如若软件识别错误，需用户自行选择。
5. 选择完毕后点击下一步。
6. 此页面直接点击安装即可。
7. 系统正在安装，请等候。
8. 系统安装完毕后，软件会自动提示需要重启，并且拔出U盘，请用户拔出U盘再重启电脑。
9. 重启后，系统将自动进入系统安装界面，到此，装机就成功了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb23a19cf742c104d033771648ffb885/" rel="bookmark">
			（附源码）PHP人事信息管理系统 计算机毕设45934
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP人事信息管理系统 摘 要 科技进步的飞速发展引起人们日常生活的巨大变化，电子信息技术的飞速发展使得电子信息技术的各个领域的应用水平得到普及和应用。信息时代的到来已成为不可阻挡的时尚潮流，人类发展的历史正进入一个新时代。在现实运用中，应用软件的工作规则和开发步骤，采用PHP技术建设人事信息管理系统。
本设计主要实现集人性化、高效率、便捷等优点于一身的人事信息管理系统，完成首页、系统用户、通知公告、部门信息、员工薪资、考勤签到、员工请假、招聘信息、应聘信息等功能模块。采取面对对象的开发模式进行软件的开发和硬体的架设，能很好的满足实际使用的需求，完善了对应的软体架设以及程序编码的工作，采取MySQL作为后台数据的主要存储单元，采用PHP技术、Ajax技术进行业务系统的编码及其开发，实现了本系统的全部功能。本次报告，首先分析了研究的背景、作用、意义，为研究工作的合理性打下了基础。针对在线考试系统的各项需求以及技术问题进行分析，证明了系统的必要性和技术可行性，然后对设计系统需要使用的技术软件以及设计思想做了基本的介绍，最后来实现人事信息管理系统和部署运行使用它。
关键字：人事信息管理系统 ; PHP；数据库
PHP Personnel Information Management System
Abstracts
The rapid development of technology has caused tremendous changes in people's daily lives, and the rapid development of electronic information technology has popularized and applied the application level of electronic information technology in various fields. The arrival of the information age has become an unstoppable fashion trend, and the history of human development is entering a new era.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb23a19cf742c104d033771648ffb885/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53053518543ea01a35edf18bb2036e2e/" rel="bookmark">
			（附源码）python兴农购物网站系统 毕业设计38256
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Django兴农购物网站系统 摘 要 助农工作是当前我国全面建成小康社会的重点工作，由于我国农村地域广大，贫困人口多，区域差异大，因此，不同区域的扶贫方法也是不一样的。近年来，随着网络的普及。许多农村地区物产丰富，但由于销售渠道不畅等原因，导致农民处于无法致富的贫困状态，而兴农购物网站系统恰好能解决这个问题，农户能在系统上进行农产品发布，产品销售，用户也可以在系统进行购买，还可以进行溯源信息查看，对于扩大内需和促进农产品的销售发展有着现实而深远的意义。
兴农购物网站系统主要是提供给用户一个可以购买农产品的平台，本文主要是采用Python语言和MySQL数据库技术，基于Django框架作为开发平台，完成一个兴农购物网站系统。
关键词：Django框架；购物网站；MySQL数据库
Django Xingnong Shopping Website System ABSTRACT The work of assisting agriculture is currently the key task for China to fully build a moderately prosperous society. Due to the vast rural area, large numbers of poor people, and large regional differences, the poverty alleviation methods in different regions are also different. In recent years, with the popularization of the network. Many rural areas are rich in products, but due to poor sales channels and other reasons, farmers are in a poverty situation where they cannot become rich.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53053518543ea01a35edf18bb2036e2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c253cfa5ddc94e7491b8e54ee30e6a3d/" rel="bookmark">
			第7.4节-中文简历制作-应届生求职者在撰写该模块内容时往往存在的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(点击即可收听)
在写简历中,很多同学,针对自己的一个工作经历与项目经历
要么有丰富的经历,但是却不会表达,要么就是没有多少经历，主要有几下个点
（1）缺少实习经历，没有什么可以写；
（2）过往实习经历与应聘职位相关性不大，有的实习完全是为了应付学校考核；
（3）实习内容以打印、复印、跑腿等琐碎的工作为主，缺乏技术含量；
（4）虽然有大公司实习经历，但是因为缺乏好的内容描述方式，本来应该很闪亮的经历却被描述得平淡无奇
寻找实习机会是一个从校园步入社会的过程，是一个从无到有、从四处撒网到精准投递的过程
第一份实习往往是最难找的，从大二甚至大一开始就应该对此进行准备和筹划
如果校方或同学、朋友有一定的资源，能够代为帮忙引荐，这可能会是你获取第一份实习的捷径
第一份实习不要太在意公司规模、实习工资等，只要公司正规合法，直属领导愿意指导新人，你也愿意在工作中勤学多做，就一定会有所收获
另外就是日常多参加与今后求职目标相关的科研项目或实践比赛，有意识地弥补实习经历的缺陷
切忌移花接木，把他人的实习经历套到自己身上
如果捏造事实、编故事，在有经验的面试官面前很容易就会暴露，最后的结果就是浪费双方的时间，还给企业留下不诚信的印象
通过实习来探索自己真正感兴趣或适合的方向。在做过一两份实习之后，就要开始慢慢聚焦，不要再漫天撒网，使得自己的背景和经验沿着某一个特定的方向延续和沉淀，不要因为实习补贴多一点少一点或上班距离近一些远一些而轻易变换实习方向
如果早期实习经历不足或实习经历不对口，一些企业实践经历、相关培训经历也都可以写在简历中作为加分项
可以将整个模块命名为“实习实践经历”“商务实践”等，把与求职岗位相关的实习、实践、培训经历都放在下面
一般正规的企业都不会让实习生承担很大的责任，毕竟实习生并未和企业签署劳动合同，也缺乏相应的工作经验和技能，在工作中会有较高的犯错率
所以一般而言，实习生从事的都是偏基础的辅助性工作，俗称“打杂”
越是大规模的企业，实习生的工作往往越简单琐碎；越是小公司，因为缺乏人手，越会让实习生干更重要的活
所以在我看来，从储备实习经验的角度来说，大公司和小公司的经历都需要，利用在小公司的经历来学习技能，利用在大公司的经历来包装自己的实习背景，这样几份实习做下来，你的求职竞争力会大幅提升，也更加接近一个全职工作者的职业素养
需要强调的是，即便工作很不起眼、很琐碎，只要你有心，依然能在这个岗位上闪闪发光
任何一项琐碎的工作都有提升和改进的空间，关键看你是不是有心人，是想混一个实习证明还是在这个岗位绽放自己
很多大人物都是从小事开始做起，把每一件小事都做得超出他人预期
逐渐承担起越来越大的责任
在简历辅导的过程中，我们也确实发现有的同学在实习过程中做了不少工作，但写在简历上只是寥寥数笔，这是非常吃亏的
尤其是当实习公司并不知名时，工作内容的描述就显得更为重要
因此，实习结束后，还得善于把实习内容形成文字，并在简历中很好地表达出来
巧用规则撰写完美工作经历 如何写好一段工作经历呢？我们可以运用以下几个规则和方法
用STAR法则搭建整体内容框架 给大家介绍简历撰写中非常实用的一个法则——STAR法则，即每一段经历都可以归纳为
背景（Situation，S）、
任务（Task，T）、
行动（Action，A）、
结果（Result，R）四个部分来表述，从这四个方面来充分挖掘自己的经历，力求将其写得出彩
描述工作内容（Task）
这是指描述你的工作职责、内容、流程是什么，以及要实现的目标是什么。
例如，管理10人团队，策划一场学院公益讲座；
完成电器行业研究分析日报，并编写团队推文；负责公司产品运营，提升产品新增用户的数量和现存用户的活跃度等
所采取的行动（Action）
这是指描述面对工作任务时你所采取的行动
例如，为了将讲座举办好，你调动了5家媒体宣传，邀请到了某公司的总经理发言
为了撰写研究报告，你使用Wind资讯平台获取数据，并使用Matlab软件进行数据分析
为了增加用户数量，你策划了病毒式分享游戏，撰写了知乎爆款软文等
最终的结果（Result）
上海xxxx科技有限公司 会计助理实习生
●协助会计人员完成基础性工作，制作和整理原始凭证
●负责发票粘贴和报销
这是指描述你的行动所实现的结果，我们尝试用STAR法则来思考这段描述：
你的独特之处和价值点在哪里？
你做这份实习期望实现什么目标？
发现了什么问题？
采用了什么新的方法和流程？
你的新方法有没有提高效率？
有没有降低出错的频率？
你对团队的贡献是什么
我们可以按照STAR法则对这段经历进行修改，修改后的结果如下：
上海xx科技有限公司 会计助理实习生
●参与公司原始会计凭证的粘贴、整理、分类、录入工作，熟练使用金蝶软件，通过改进数据录入流程使效率提升了20%，任职期间零错误率
●为企业生产部门制定记账报销流程表，并完成部门成员培训工作，根据生产部门的财务数据分析结果，提出优化库存的建议
STAR法则不仅适用于简历经历的撰写，也同样适合应用在面试问题的解答中
制定了甘特图，确立了各方主要对接人的职责和分工，锁定了项目进度，并通过英文邮件完成跨国沟通（A）
最后，活动如期举办，参与人数比往期平均人数多出80%，参与方好评率达95%以上
与STAR法则相类似的还有一个PAR（Problem，Action，Result）法则，本质上两个法则是相通的
即描述你在工作中遇到了哪些问题、采取了什么解决方式、达到了怎样的结果
职场一切都是以结果为导向的，没有人在意你做了什么、花费了多少精力和心血，只在意最后是否达到了预期的结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c253cfa5ddc94e7491b8e54ee30e6a3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/384fc06e640a0835d8ca45345fbea94e/" rel="bookmark">
			uniapp通过蓝牙传输数据 （ios）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在uni-app中，可以通过uni-ble（uni-app官方提供的蓝牙插件）来实现iOS设备上的蓝牙数据传输。
首先，确保已在uni-app的manifest.json文件中添加uni-ble插件的配置：
```
"permission": {
"scope.userLocation": {
"desc": "你的位置信息将用于蓝牙设备扫描",
"bugs": []
}
},
"usingComponents": {
"uni-ble": "@dcloudio/uni-ble/uni-ble"
}
```
接下来，你可以在uni-app的页面中使用uni-ble插件的API来进行蓝牙数据传输。下面是一个简单的例子：
```html
&lt;template&gt;
&lt;view&gt;
&lt;button @click="scanDevices"&gt;扫描设备&lt;/button&gt;
&lt;button @click="connectDevice"&gt;连接设备&lt;/button&gt;
&lt;button @click="sendData"&gt;发送数据&lt;/button&gt;
&lt;/view&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
methods: {
scanDevices() {
uni.openBluetoothAdapter({
success(res) {
// 开始扫描设备
uni.startBluetoothDevicesDiscovery({
services: [], // 可选，指定蓝牙设备主 service 的 uuid 列表
success(res) {
console.log('开始扫描设备')
},
fail(err) {
console.log(err)
}
})
},
fail(err) {
console.log(err)
}
})
},
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/384fc06e640a0835d8ca45345fbea94e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a0754bef374dadc5290eb981a116d6c/" rel="bookmark">
			大数据前馈神经网络解密：深入理解人工智能的基石
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 大数据前馈神经网络解密：深入理解人工智能的基石一、前馈神经网络概述什么是前馈神经网络前馈神经网络的工作原理应用场景及优缺点 二、前馈神经网络的基本结构输入层、隐藏层和输出层激活函数的选择与作用网络权重和偏置 三、前馈神经网络的训练方法损失函数与优化算法反向传播算法详解避免过拟合的策略 四、使用Python和PyTorch实现FNN4.1 准备数据集选择合适的数据集数据预处理PyTorch数据加载器 4.2 构建模型结构定义网络架构选择激活函数权重初始化构建与任务相匹配的损失函数 4.3 训练模型选择优化器训练循环模型验证调整学习率保存和加载模型可视化训练过程 4.4 模型评估与可视化评估指标模型验证混淆矩阵ROC和AUC特征重要性和模型解释可视化隐藏层 五、前馈神经网络的先进变体与应用多层感知器（MLP）卷积神经网络（CNN）循环神经网络（RNN）Transformer结构强化学习中的FNN生成对抗网络（GAN）FNN在医学图像分析中的应用 六、总结与未来展望总结未来展望结语结语 大数据前馈神经网络解密：深入理解人工智能的基石 本文深入探讨了前馈神经网络（FNN）的核心原理、结构、训练方法和先进变体。通过Python和PyTorch的实战演示，揭示了FNN的多样化应用。
一、前馈神经网络概述 前馈神经网络（Feedforward Neural Network, FNN）是神经网络中最基本和经典的一种结构，它在许多实际应用场景中有着广泛的使用。在本节中，我们将深入探讨FNN的基本概念、工作原理、应用场景以及优缺点。
什么是前馈神经网络 前馈神经网络是一种人工神经网络，其结构由多个层次的节点组成，并按特定的方向传递信息。与之相对的是递归神经网络，其中信息可以在不同层之间双向传递。
结构特点： 由输入层、一个或多个隐藏层和输出层组成。信息流动： 信息仅在一个方向上流动，从输入层通过隐藏层最终到达输出层，没有反馈循环。 前馈神经网络的工作原理 前馈神经网络的工作过程可以分为前向传播和反向传播两个阶段。
前向传播： 输入数据在每一层被权重和偏置加权后，通过激活函数进行非线性变换，传递至下一层。反向传播： 通过计算输出误差和每一层的梯度，对网络中的权重和偏置进行更新。 应用场景及优缺点 前馈神经网络在许多领域都有着广泛的应用，包括图像识别、语音处理、金融预测等。
优点： 结构简单，易于理解和实现。可以适用于多种数据类型和任务。 缺点： 对于具有时序关系的数据处理能力较弱。容易陷入局部最优解，需要合理选择激活函数和优化策略。 二、前馈神经网络的基本结构 前馈神经网络（FNN）的基本结构包括输入层、隐藏层和输出层，以及相应的激活函数、权重和偏置。这些组成部分共同构成了网络的全貌，并定义了网络如何从输入数据中提取特征并进行预测。本节将详细介绍这些核心组成部分。
输入层、隐藏层和输出层 前馈神经网络由三个主要部分组成：输入层、隐藏层和输出层。
输入层： 负责接收原始数据，通常对应于特征的维度。隐藏层： 包含一个或多个层，每层由多个神经元组成，用于提取输入数据的抽象特征。输出层： 产生网络的最终预测或分类结果。 激活函数的选择与作用 激活函数是神经网络中非常重要的组成部分，它向网络引入非线性特性，使网络能够学习复杂的函数。
常见激活函数： 如ReLU、Sigmoid、Tanh等。作用： 引入非线性，增强网络的表达能力。 网络权重和偏置 权重和偏置是神经网络的可学习参数，它们在训练过程中不断调整，以最小化预测错误。
权重： 连接各层神经元的线性因子，控制信息在神经元之间的流动。偏置： 允许神经元在没有输入的情况下激活，增加模型的灵活性。 三、前馈神经网络的训练方法 前馈神经网络（FNN）的训练是一个复杂且微妙的过程，涉及多个关键组件和技术选择。从损失函数的选择到优化算法，再到反向传播和过拟合的处理，本节将深入探讨FNN的训练方法。
损失函数与优化算法 损失函数和优化算法是神经网络训练的基石，决定了网络如何学习和调整其权重。
损失函数： 用于衡量网络预测与实际目标之间的差异，常见的损失函数包括均方误差（MSE）、交叉熵损失等。优化算法： 通过最小化损失函数来更新网络权重，常见的优化算法包括随机梯度下降（SGD）、Adam、RMSProp等。 反向传播算法详解 反向传播是一种高效计算损失函数梯度的算法，它是神经网络训练的核心。
工作原理： 通过链式法则，从输出层向输入层逐层计算梯度。权重更新： 根据计算的梯度，使用优化算法更新网络的权重和偏置。 避免过拟合的策略 过拟合是训练神经网络时常遇到的问题，有多种策略可以减轻或避免过拟合。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a0754bef374dadc5290eb981a116d6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/895a26db43d900b7e2804f3c5ac41a29/" rel="bookmark">
			flask之文件管理系统-项目 JRP上线啦！！！ ----Bug版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		既然单人应用那么就不需要注册、登录了，太麻烦，直接上功能项，而初版太不好看了，略微修改归纳了一下，出了第一版
很有精神，为了纪念，这个网页项目我命名为JRP
主要就是：
1、定义一个类
2、集中定义路由
3、HTML模版使用一个模版，在模版内依靠变量判断是否执行
4、利用CSS进行格式定义（这块待优化，时间短，我等不及让它在我树莓派上工作起来了…）
上代码：
from flask import Flask, render_template, send_file, request import os # 定义类 class FileManagementApp: # 定义类变量，这里是放数据库根目录，我这里就是我树莓派系统上的存储盘挂载位置 gDataPath = os.path.normpath("/data/HOME_NAS/data") def __init__(self): self.app = Flask(__name__) self.app.config['UPLOAD_FOLDER'] = '' # 添加basename方法，让HTML中使用 路径|basename 输出结果是路径文件夹名或文件名而不是完整路径 self.app.add_template_filter(self.basename) # 把所有下面函数定义的路由集中到这里，清晰明了 self.app.route('/')(self.mainweb) self.app.route('/&lt;show_item&gt;')(self.index) self.app.route('/download/&lt;file_name&gt;')(self.download_file) self.app.route('/show_folder/&lt;folder_name&gt;')(self.show_folder) self.app.route('/return_folder/&lt;folder_name&gt;')(self.return_folder) self.app.route('/upload', methods=['POST'])(self.upload_file) self.app.route('/search', methods=['POST'])(self.search_file) def basename(self, value): return os.path.basename(value) # 主页面，show_main=True控制让它显示在html中，避免HTML中所有模块都显示在网页中，默认是关闭的，参考HTML模版 def mainweb(self): return render_template('index.html', show_main=True ) # 根据mainweb页面用户点击后的返回，跳转到不同的页面，show_xxx=True 则是打开显示不同的模块，其余不显示 def index(self, show_item): if show_item == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/895a26db43d900b7e2804f3c5ac41a29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4df494b4eeec6cd48a1afe407e22e8b9/" rel="bookmark">
			通过ADB来实现脚本来控制手机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ADB 简介 adb的全称为Android Debug Bridge,安卓调试桥,可以通过调试命令来控制手机,诸如开机,关机等按键控制;或者启动,关闭应用;异或进行触摸模拟.
通过学习adb,可以实现简单的脚本控制,最大的特点是不需要root,对于普通手机都可以进行,帮助我们完成一些简单的重复性事件,诸如刷资源,各种app的签到
环境配置 电脑端 将下面3个文件弄到一个文件夹里D:\android\adb,然后将其添加到path,adb环境就配置好了
AdbWinUsbApi.dll AdbWinApi.dll adb.exe 然后将这个文件夹添加到path中
cmd中 adb version检查是否添加成功
手机端 开发者选项
开启开发者选项 : 以小米手机为例,先进入开发者设置,miui版本号点5下,更多设置-&gt;开发者选项-&gt;开启
打开usb调试 : 在开发者选项中,开启usb调试以便于执行adb指令,miui还需要开启usb调试(安全设置)
获取坐标 : 开发者选项中,开启指针位置以便于模拟触摸时获取位置
设备管理 远程调试 基于内网穿透实现远程调试,就可以不用占用那少得可怜的usb口了,下面是统一管理所有设备的命令
开启关闭服务,默认会自动开启,关闭服务可用于断开多个连接的设备 adb start-server adb kill-server adb devices 查看设备列表,如果有模拟器一般会自动连接,所以如果想在开模拟器时断开设备就需要获取模拟器ip:port然后断开 实现步骤
先使用内网穿透得到虚拟IP 如100.119.133.92
推荐tailscale或蒲公英
手机通过usb调试设置监听端口adb tcpip 5555
断开手机后,电脑连接 如adb connect 100.119.133.92:5555
调试结束后可以adb disconnect 100.119.133.92:5555 断开连接
远程控制 scrcpy 使用这个软件,在上面远程连接之后就可以进行远程控制,当然也可以直接连usb获得稳定的投屏
手机adb Local ADB
先连接任意一个 Wi-Fi，就算没有接入互联网都可以；然后打开 LADB，将它调整为小窗模式（或分屏模式）——因为无线调试的配对码等信息每次点击都会动态生成，所以才需要小窗模式同时打开本应用和开发者选项；进入开发者选项，开启无线调试，首次使用需要配对设备，将配对码和端口填入本应用即可；开心使用adb 应用管理 常见命令中常见pm和am的缩写
pm package manager
am activity manager
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4df494b4eeec6cd48a1afe407e22e8b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe6db9cec94dff14eba7cf505ee8a5d1/" rel="bookmark">
			概率论基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概率论 1.1 随机事件与概率 1.1.1 基本概念 ​ 样本点(sample point)： 称为试验 S S S的可能结果为样本点，用 ω \omega ω表示。
​ 样本空间(sample space)：称试验 S S S的样本点构成的集合为样本空间，用 Ω \Omega Ω表示。于是
Ω = { ω ∣ ω 是试验 S 的样本点 } \begin{aligned} \Omega = \{\omega|\omega是试验S的样本点\} \end {aligned} Ω={ω∣ω是试验S的样本点}​
​ 事件(event)： 设 Ω \Omega Ω是试验 S S S的样本空间。当 Ω \Omega Ω中只有有限个样本点时，称 Ω \Omega Ω的子集为事件。当试验的样本点(试验结果) ω \omega ω落在 A A A中，称事件 A A A发生，否则称 A A A不发生。
​ 按照上述约定，子集符号 A ⊂ Ω A \subset \Omega A⊂Ω表示 A A A是事件。通常用大写字母 A , B , C , D A,B,C,D A,B,C,D等表示事件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe6db9cec94dff14eba7cf505ee8a5d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6ca299ffc7b3bf45e1d78b870a84ba0/" rel="bookmark">
			【iOS安全】越狱iOS安装Frida | 安装指定版本Frida
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		越狱iPhone安装Frida 本文的方法适用于已越狱的iPhone手机
打开Cydia，软件源，编辑（右上角），添加（左上角）：https://build.frida.re
然后搜索Frida，点击安装
参考：https://blog.csdn.net/boildoctor/article/details/122769942
安装指定版本Frida iOS上的Frida版本需要和PC上的Frida版本保持一致，所以有时候需要安装指定版本Frida
下载指定版本deb包：
https://github.com/frida/frida/releases
例如：frida_15.2.2_iphoneos-arm.deb
通过XFTP将deb拷贝至手机/private/var/tmp目录（也就是/tmp目录）
ssh进入手机 /tmp目录，执行安装：
dpkg -i xx.deb 参考：https://cloud.tencent.com/developer/article/2160543
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7188dbe2a383c751495f9c7b76cf268/" rel="bookmark">
			力扣热题100道-子串篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字串 560.和为K的子数组 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。
子数组是数组中元素的连续非空序列。
示例 1：
输入：nums = [1,1,1], k = 2 输出：2 示例 2：
输入：nums = [1,2,3], k = 3 输出：2 /** 思路：采用前缀和＋哈希表解决 前缀和求出来后存到哈希表中，每个试着减去k如果有值说明有连续字串和为K **/ class Solution { public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) { int n=nums.size(); vector&lt;int&gt; f(n); f[0]=nums[0]; for(int i=1;i&lt;n;i++){ f[i]=f[i-1]+nums[i]; } unordered_map&lt;int,int&gt; hash; hash[0]=1; int res=0; for(int i=0;i&lt;n;i++){ res+=hash[f[i]-k]; hash[f[i]]++; } return res; } }; 239.滑动窗口最大值 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7188dbe2a383c751495f9c7b76cf268/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a57e8c0e19f2c6f30fb08de9fa113be3/" rel="bookmark">
			第十二章 Sleuth分布式请求链路跟踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sleuth分布式请求链路跟踪 gitee:springcloud_study: springcloud：服务集群、注册中心、配置中心（热更新）、服务网关（校验、路由、负载均衡）、分布式缓存、分布式搜索、消息队列（异步通信）、数据库集群、分布式日志、系统监控链路追踪。
1. 概述 问题：在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。
是什么：Spring Cloud Sleuth提供了一套完整的服务跟踪的解决方案在分布式系统中提供追踪解决方案并且兼容支持了zipkin。 官网：https://github.com/spring-cloud/spring-cloud-sleuth
2. 搭建链路监控步骤 zipkin搭建：SpringCloud从F版起已不需要自己构建ZipkinServer了，只需调用jar包即可。网址：Central Repository: io/zipkin
下载zipkin.jar，并启动
请求链路：表示一请求链路，一条链路通过Trace ld唯一标识，Span标识发起的请求信息，各span通过parent id 关联起来。 Trace:类似于树结构的Span集合，表示一条调用链路，存在唯一标识。 span:表示调用链路来源，通俗的理解span就是一次请求信息
修改cloud-provider-payment8001和cloud-consumer-order80
pom文件：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; application.yaml：
spring: application: #应用名称，也是注册进入注册中的服务名称 name: cloud-payment-service zipkin: base-url: http://localhost:9411 sleuth: sampler: #采样/洁介于0到1之间，1则表示全部采货 probability: 1 8001controller修改：
@GetMapping("/payment/zipkin") public String paymentZipkin(){ return "hi,zipkin"; } 80controller修改：
@GetMapping("/consumer/payment/zipkin") public String paymentZipkin(){ String string=restTemplate.getForObject("http://localhost:8001"+"/payment/zipkin/",String.class); return string; } 测试：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3179ab5d9260fe43c2294c6dc27d8ba/" rel="bookmark">
			【头歌实训】kafka-入门篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第1关：kafka - 初体验任务描述相关知识Kafka 简述Kafka 应用场景Kafka 架构组件kafka 常用命令 编程要求测试说明答案代码 第2关：生产者 （Producer ） - 简单模式任务描述相关知识Producer 简单模式Producer 的开发步骤Kafka 常用配置参数 编程要求测试说明答案代码 第3关：消费者（ Consumer）- 自动提交偏移量任务描述相关知识Kafka 消费者开发步骤自动提交偏移量的优劣 编程要求测试说明答案代码 第4关：消费者（ Consumer ）- 手动提交偏移量任务描述相关知识Kafka 两种手动提交方式 编程要求测试说明答案代码 第1关：kafka - 初体验 任务描述 本关任务：使用 Kafka 命令创建一个副本数量为1、分区数量为3的 Topic 。
相关知识 为了完成本关任务，你需要掌握：1.如何使用 Kafka 的常用命令。
课程视频《Kafka简介》
Kafka 简述 类 JMS 消息队列，结合 JMS 中的两种模式，可以有多个消费者主动拉取数据，在 JMS 中只有点对点模式才有消费者主动拉取数据。
Kafka 是一个生产-消费模型。
Producer ：消息生产者，就是向 Kafka Broker 发消息的客户端。
Consumer ：消息消费者，向 Kafka Broker 取消息的客户端。
Topic ：我们可以理解为一个队列。
Consumer Group （CG）：这是 Kafka 用来实现一个 Topic 消息的广播（发给所有的 Consumer ）和单播（发给任意一个 Consumer ）的手段。一个 Topic 可以有多个CG。Topic 的消息会复制（不是真的复制，是概念上的）到所有的 CG ，但每个 Partion 只会把消息发给该 CG 中的一个 Consumer 。如果需要实现广播，只要每个 Consumer 有一个独立的 CG 就可以了。要实现单播只要所有的 Consumer 在同一个 CG。用CG 还可以将 Consumer 进行自由的分组而不需要多次发送消息到不同的 Topic。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3179ab5d9260fe43c2294c6dc27d8ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eb0969f0c314e2c5a5f508ee2f94067/" rel="bookmark">
			Crypto API - 9.1 编程接口-块密码算法定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程接口-块密码算法定义 这些数据结构定义了模块化加密算法实现，通过 crypto_register_alg（） 和 crypto_unregister_alg（） 进行管理。
struct cipher_alg single-block symmetric ciphers definition（单块对称密码定义） 定义：
struct cipher_alg { unsigned int cia_min_keysize; unsigned int cia_max_keysize; int (*cia_setkey)(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen); void (*cia_encrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src); void (*cia_decrypt)(struct crypto_tfm *tfm, u8 *dst, const u8 *src); }; 成员
cia_min_keysize
变换所支持的最小密钥长度。这是此变换算法支持的最小密钥长度。此值必须设置为预定义值之一，因为它不是特定于硬件的。此字段的可能取值可以通过 git grep "_MIN_KEY_SIZE" include/crypto/ 找到。 cia_max_keysize
变换所支持的最大密钥长度。这是此变换算法支持的最大密钥长度。此值必须设置为预定义值之一，因为它不是特定于硬件的。此字段的可能取值可以通过 git grep "_MAX_KEY_SIZE" include/crypto/ 找到。 cia_setkey
为变换设置密钥。此函数用于将提供的密钥编程到硬件中，或将密钥存储在变换上下文中以供稍后编程。请注意，此函数确实会修改变换上下文。在变换对象存在期间，可以多次调用此函数，因此必须确保密钥已正确地重新编程到硬件中。此函数还负责检查密钥长度的有效性。 cia_encrypt
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eb0969f0c314e2c5a5f508ee2f94067/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4f2dc80944bd67f6a309b6fd3cad89b/" rel="bookmark">
			【Stable diffusion inpaiting】训练自己数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://github.com/advimman/lama/tree/7dee0e4a3cf5f73f86a820674bf471454f52b74f
prepare your data: 1) Create masks named as `[images_name]_maskXXX[image_suffix]`, put images and masks in the same folder. You can use the script for random masks generation. Check the format of the files: image1_mask001.png image1.png image2_mask001.png image2.png Specify image_suffix, e.g. .png or .jpg or _input.jpg in configs/prediction/default.yaml. https://github.com/advimman/lama/blob/main/bin/gen_mask_dataset.py
如果图像不是正方形，使用crop或者transform变换
import os import argparse from PIL import Image def crop_images(input_folder, output_folder, size): # 遍历输入文件夹中的所有文件 for filename in os.listdir(input_folder): if filename.endswith(".png"): # 构建输入和输出文件的路径 input_path = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4f2dc80944bd67f6a309b6fd3cad89b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1e993c518b506978f732b7d6d152f79/" rel="bookmark">
			P2440 木材加工
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		P2440 木材加工 P2440 木材加工
题意 木材厂有 n 根原木，现在想把这些木头切割成 k 段长度均为 l 的小段木头（木头有可能有剩余），希望得到的小段木头越长越好，请求出 l 的最大值，如果连 1cm 长的小段都切不出来，输出 0。
思路 首先要定义一个函数，去查找答案。在主函数中应用函数，最后输出答案。 坑点 要想到用二分。 算法一：二分答案 时间复杂度 On
实现步骤 首先要定义一个函数，去查找答案。在主函数中应用函数，最后输出答案。在主函数中进行sort排序，为避免小错误。 代码 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;algorithm&gt; using namespace std; int n,k; int a[1000005]; int find(int l,int r) { while(l&lt;=r) { int mid=(l+r)/2; int ans=0;//n/l for(int i=0;i&lt;n;i++) { ans+=a[i]/mid; } if(ans&gt;=k) { l=mid+1; } else { r=mid-1; } } return r; } int main() { cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;n;i++) { cin&gt;&gt;a[i]; } sort(a,a+n); int l=1,r=a[n-1]; int x=find(l,r); cout&lt;&lt;x; return 0; } 总结 要掌握二分答案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fde6c74b39fd7d8e5bad12b4fd8c10c/" rel="bookmark">
			出现频率高达70%软件测试面试题及答案！——看完面试官：是你面试我还是我面试你啊！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【纯干货！！！】花费了整整3天，整理出来的全网最实用软件测试面试大全，一共30道题目+答案的纯干货，希望大家多多支持，建议 点赞！！收藏！！长文警告，全文共12000+字，涵盖软件测试面试可能遇到的所有问题，希望对大家有帮助，不过大家最好不要硬背，实战大于理论。祝大家面试顺利！
51.一个测试工程师应具备那些素质？
1、责任心2、沟通能力3、团队合作精神4、耐心、细心、信心5、时时保持怀疑态度，并且有缺陷预防的意识6、具备一定的编程经验
52、什么是安全性测试
Web应用系统的安全性测试区域主要有：
(1)现在的Web应用系统基本采用先注册，后登陆的方式。因此，必须测试有效和无效的用户名和密码，要注意到是否大小写敏感，可以试多少次的限制，是否可以不登陆而直接浏览某个页面等。
(2)Web应用系统是否有超时的限制，也就是说，用户登陆后在一定时间内(例如15分钟)没有点击任何页面，是否需要重新登陆才能正常使用。
(3)为了保证Web应用系统的安全性，日志文件是至关重要的。需要测试相关信息是否写进了日志文件、是否可追踪。
(4)当使用了安全套接字时，还要测试加密是否正确，检查信息的完整性。
(5)服务器端的脚本常常构成安全漏洞，这些漏洞又常常被黑客利用。所以，还要测试没有经过授权，就不能在服务器端放置和编辑脚本的问题。
53：你所了解的的软件测试类型都有哪些，简单介绍一下。
按测试策略分类：1、静态与动态测试2、黑盒与白盒测试 3、手工和自动测试 4、冒烟测试 5、回归测试；
按测试阶段分类：单元测试、集成测试、系统测试；
其他常见测试方法：1、功能测试 2、性能测试 3、压力测试 4、负载测试 5、易用性测试 6、安装测试 7、界面测试 8、配置测试 9、文档测试 10、兼容性测试 11、安全性测试 12、恢复测试
54：你认为做好测试计划工作的关键是什么？
明确测试的目标，增强测试计划的实用性
编写软件测试计划得重要目的就是使测试过程能够发现更多的软件缺陷，因此软件测试计划的价值取决于它对帮助管理测试项目，并且找出软件潜在的缺陷。因此，软件测试计划中的测试范围必须高度覆盖功能需求，测试方法必须切实可行，测试工具并且具有较高的实用性，便于使用，生成的测试结果直观、准确
**
坚持“5W”规则，明确内容与过程
“5W”规则指的是“What（做什么）”、“Why（为什么做）”、“When（何时做）”、“Where（在哪里）”、“How（如何做）”。利用“5W”规则创建软件测试计划，可以帮助测试团队理解测试的目的（Why），明确测试的范围和内容（What），确定测试的开始和结束日期（When），指出测试的方法和工具（How），给出测试文档和软件的存放位置（Where）。
采用评审和更新机制，保证测试计划满足实际需求
测试计划写作完成后，如果没有经过评审，直接发送给测试团队，测试计划内容的可能不准确或遗漏测试内容，或者软件需求变更引起测试范围的增减，而测试计划的内容没有及时更新，误导测试执行人员。
分别创建测试计划与测试详细规格、测试用例
应把详细的测试技术指标包含到独立创建的测试详细规格文档，把用于指导测试小组执行测试过程的测试用例放到独立创建的测试用例文档或测试用例管理数据库中。测试计划和测试详细规格、测试用例之间是战略和战术的关系，测试计划主要从宏观上规划测试活动的范围、方法和资源配置，而测试详细规格、测试用例是完成测试任务的具体战术。
55：您认为做好测试用例设计工作的关键是什么？
白盒测试用例设计的关键是以较少的用例覆盖尽可能多的内部程序逻辑结果
黑盒法用例设计的关键同样也是以较少的用例覆盖模块输出和输入接口。不可能做到完全测试，以最少的用例在合理的时间内发现最多的问题
56：你的测试职业发展目标是什么？
测试经验越多，测试能力越高。所以我的职业发展是需要时间累积的，一步步向着高级测试工程师奔去。而且我也有初步的职业规划，前3年累积测试经验，不断的更新自己改正自己，做好测试任务。
57：测试结束的标准是什么？
从微观上来说，在测试计划中定义，比如系统在一定性能下平稳运行72小时，目前Bug Tracking System中，本版本中没有一般严重的BUG，普通BUG的数量在3以下，BUG修复率90%以上等等参数，然后由开发经理，测试经理，项目经理共同签字认同版本Release。
如果说宏观的，则是当这个软件彻底的消失以后，测试就结束了。
58、怎么理解客户端兼容性测试
1、平台测试
市场上有很多不同的操作系统类型，最常见的有Windows、Unix、Macintosh、Linux等。Web应用系统的最终用户究竟使用哪一种操作系统，取决于用户系统的配置。这样，就可能会发生兼容性问题，同一个应用可能在某些操作系统下能正常运行，但在另外的操作系统下可能会运行失败。 因此，在Web系统发布之前，需要在各种操作系统下对Web系统进行兼容性测试。
2、浏览器测试
浏览器是Web客户端最核心的构件，来自不同厂商的浏览器对Java，、JavaScript、 ActiveX、 plug-ins或不同的HTML规格有不同的支持。例如，ActiveX是Microsoft的产品，是为Internet Explorer而设计的，JavaScript是Netscape的产品，Java是Sun的产品等等。另外，框架和层次结构风格在不同的浏览器中也有不同的显示，甚至根本不显示。不同的浏览器对安全性和Java的设置也不一样。 测试浏览器兼容性的一个方法是创建一个兼容性矩阵。在这个矩阵中，测试不同厂商、不同版本的浏览器对某些构件和设置的适应性。
59、一套完整的测试应该由哪些阶段组成？
可行性分析、需求分析、概要设计、详细设计、编码、单元测试、集成测试、系统测试、验收测试
如何提交高质量的缺陷报告单？
1、 缺陷的概要描述要清晰准确，要使相关开发负责人员能够一目了然问题是什么。
2、 一个完整的缺陷报告单，必须包含其必要的元素信息，例如：概要描述，缺陷发现人，测试环境，浏览器，缺陷重现步骤，严重等级，指派人，所属功能模块等等，必要元素信息必须描述全面清楚。
3、 缺陷的重现步骤必须描写清晰明了，使相关开发负责人能够根据重现步骤准确的重现所提交的缺陷，使其定位缺陷的原因所在。
4、测试数据，测试的数据作为重现缺陷的一个重要元素信息，一定要将测试时所使用的信息给描写清楚准确。让开发人员根据测试所提供的测试数据准确重现缺陷。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fde6c74b39fd7d8e5bad12b4fd8c10c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97b41f5c75cb4f2f20722bd6aae297f4/" rel="bookmark">
			P8647 [蓝桥杯 2017 省 AB] 分巧克力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		P8647 [蓝桥杯 2017 省 AB] 分巧克力 [P8647 [蓝桥杯 2017 省 AB] 分巧克力](https://www.luogu.com.cn/problem/P8647?contestId=150480
P8647 [蓝桥杯 2017 省 AB] 分巧克力)
题意 给n个边长为不等的巧克力，要分给三个小盆友，这些巧克力必须是正方形且大小必须相同，求最后要分得几块。
思路 根据样例怎么输入输出二分模版套用，然后对每块巧克力进行遍历，计算每块巧克力能分成的块数，并累加到ans中。比较大小，如果ans大于等于k，左边界l更新为mid+1，同时将ans更新为mid，如果ans小于k，说明当前mid值不满足要求，将右边界r更新为mid-1。 坑点 最难的在于怎么计算巧克力的面积，然后二分查找。 二分模版学会套用。 算法一：基础的二分答案 时间复杂度 输出大小: 1.83265209197998 MiB编译时间: 0.59s 实现步骤 首先，输入两个整数n和k，分别代表巧克力的数量和需要分的块数。二分查找对每块巧克力进行遍历，计算每块巧克力能分成的块数，并累加到ans中然后进行判断是否输出。 代码 #include&lt;iostream&gt; using namespace std; int main() { int n,k;//首先，输入两个整数n和k，分别代表巧克力的数量和需要分的块数。 int h[100000]; int w[100000];//两个巧克力的边长 cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;n;i++) cin&gt;&gt;h[i]&gt;&gt;w[i]; //二分查找 int r = 100001;//初始化一个右边界r为100001 int l = 1;//一个左边界l为1 int x = 0;//设定一个答案ans为0。 while(l&lt;=r)//然后进入while循环，当左边界小于等于右边界时，进行二分查找。 { int mid = (l+r)/2;//在每次循环中,会计算中间值mid为(l+r)/2， int ans = 0;//初始化一个计数器ans为0，用来记录巧克力最大能分成几块。 for(int i=0;i&lt;n;i++) ans += (h[i]/mid)*(w[i]/mid); //然后对每块巧克力进行遍历，计算每块巧克力能分成的块数，并累加到ans中。 if(ans&gt;=k)接着，程序会比较ans和k的大小，如果ans大于等于k.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97b41f5c75cb4f2f20722bd6aae297f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49d888050d56e3846b71d70bf5d8d092/" rel="bookmark">
			案例253:基于微信小程序的懂球短视频管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SpringBoot
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录 前言 在网络与微信小程序不断地发展，小程序技术不断发展的今天。对于一些球员和足球爱好者来说，需要时时刻刻了解，自己及自己所喜欢的足球赛事的相关信息，比赛赛事的相关事宜，比赛比分的相关信息，各个懂球短视频的小组赛。每场赛事球员发挥情况，比如查询自己所喜欢的足球视频、懂球视频、分享视频等这样才能更好的推动我国的体育事业发展,为此今后有必要对体育的发展做出更加深入的探索和研究。
对于懂球短视频微信小程序当然也不能排除在外，随着小程序的不断成熟，带动了懂球短视频微信小程序分享网站 ，它彻底改变了过去传统的管理方式，不仅使服务管理难度变低了，还提升了管理的灵活性。这种个性化的平台特别注重交互协调与管理的相互配合，激发了管理人员的创造性与主动性，对懂球懂球短视频小程序而言非常有利。
本系统采用的数据库是Mysql，小程序端采用微信开发者，结合后台eclipse使用jav语言开发，在设计过程中，充分保证了系统代码的良好可读性、实用性、易扩展性、通用性、便于后期维护、操作方便以及页面简洁等特点。
系统展示 管理员功能模块（服务端） 管理员要登录懂球懂球短视频后台服务端，需要输入用户名和密码，选择登录角色进行登录，管理员有特权，只需要登录
管理员功能：管理员登录系统后，查看首页、个人中心、用户管理、上传视频管理、懂球视频管理、分享视频管理、收藏视频管理、系统管理。
用户管理：在用户管理页面，查看用户账号、用户姓名、用户手机、邮箱、性别、出生年月日、民族、头像等信息可进行修改、删除等操作
上传视频管理：管理员在上传视频管理页面，查看视频名称、视频封面、上传时间、用户账号、用户姓名等内容，还能对用户上传视频进行审核并回复，以及修改、删除等操作等操作
懂球视频管理：管理员在懂球视频管理页面，查看视频名称、视频、封面、上传时间、作者等内容，还能对用户评论进行回复，以及修改、删除等操作 分享视频管理：在分享视频管理页面，查看视频名称、用户账号、用户姓名、视频 封面、上传时间、作者等内容进行修改、删除等操作，以及对视频名称进行统计
系统管理：管理员通过系统管理页面可新增小程序端轮播图上传修改、删除等操作 用户功能模块（微信端） 用户注册，在用户注册页面通过填写用户账号、用户姓名、密码、用户手机、邮箱、性别、出生年月日、民族等信息进行注册操作
用户登录，用户通过登录页面输入账号和密码，并点击登录进行系统登录操作 用户登陆进入小程序端后，查看底部首页、上传视频、我的等内容， 懂球视频，在懂球视频页面查看视频名称、视频、封面、上传时间、作者等信息，可对视频分享、收藏、点赞、评论等操作 我的，用户进入我的页面查看用户信息、上传视频、懂球视频、分享视频、收藏视频等详细信息 个人中心，用户通过个人信息可修改个人用户账号、用户姓名、密码、用户手机、邮箱、性别、出生年月日、民族、头像等信息，选择保存与退出登录 分享视频管理，在分享视频管理页面用户编辑填写视频名称、用户账号、用户姓名、视频 封面、上传时间、作者进行提交，后台管理员审核用户上传视频 代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.selectOne(new EntityWrapper&lt;UserEntity&gt;().eq("username", username)); if(user==null || !user.getPassword().equals(password)) { return R.error("账号或密码不正确"); } String token = tokenService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49d888050d56e3846b71d70bf5d8d092/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ae2b1780daa66a837d336501f106860/" rel="bookmark">
			2023-12-23 组合总和 III和电话号码的字母组合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		216. 组合总和 III 思路：使用回溯三部曲！① 确认需要传入的参数以及返回值 ② 回溯的终止条件 ③ 单层搜索的逻辑！这道题易错点在于单层的逻辑上的遍历起始位置以及回溯回退步骤里要执行的内容！ class Solution: def combinationSum3(self, k: int, n: int) -&gt; List[List[int]]: result = [] self.backtrack(k, n, 1,[], 0, result) return result # 回溯三部曲 # 传入参数以及返回值 def backtrack(self, k, n, start,temp_res,target, result): # 回溯条件 if k == 0: if target == n: # 使用切片 result.append(temp_res[:]) return # 单层搜索过程 for i in range(start, 10): # 剪枝操作 if target &gt; n: continue temp_res.append(i) target += i # self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ae2b1780daa66a837d336501f106860/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d739f62e4c1c1fd28ae08df563c2b96/" rel="bookmark">
			《Java系列》后端应用开发记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 后端应用开发记录一、服务器配置JAVA环境1.下载Java文件2.配置JDK，JRE3.成功测试 二、log4j.properties配置文件三、Intellij IDEA运行报Command line is too long.Shorten command linefor ...1.运行报错2.解决方案2.1 修改workspace.xml文件2.2 修改内容 四、正则表达式1.基础指令2.实例 五、Java正则表达式匹配地址获得省市县**1.正则表达式需求梳理****2.正则表达式匹配地址获得省市县****3.输出结果** 后端应用开发记录 一、服务器配置JAVA环境 1.下载Java文件 https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html [root@zxy software]# ls jdk-8u45-linux-x64.tar.gz [root@zxy /]# tar -zxvf /opt/software/jdk-8u45-linux-x64.tar.gz -C /opt/apps [root@zxy apps]# ls jdk1.8.0_45 [root@zxy apps]# cd jdk1.8.0_45/ [root@zxy jdk1.8.0_45]# pwd /opt/apps/jdk1.8.0_45 2.配置JDK，JRE [root@zxy jdk1.8.0_45]# vi /etc/profile export JAVA_HOME=/opt/apps/jdk1.8.0_45 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib export PATH=$JAVA_HOME/bin:$PATH [root@zxy jdk1.8.0_45]# source /etc/profile 3.成功测试 [root@zxy jdk1.8.0_45]# java Usage: java [-options] class [args...] (to execute a class) or java [-options] -jar jarfile [args.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d739f62e4c1c1fd28ae08df563c2b96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29b244624330eb429309d9f322377fff/" rel="bookmark">
			[Redis实战]优惠券秒杀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三、优惠券秒杀 3.1 全局唯一ID 每个店铺都可以发布优惠券：
当用户抢购时，就会生成订单并保存到tb_voucher_order这种表中，而订单表如果使用数据库自增ID就存在一些问题：
id的规律性太明显受单表数据量的限制 场景分析一：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。
场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表之后，他们从逻辑上讲是同一张表，所以他们的id是不能一样的，我们需要保证id的唯一性。
全局ID生成器，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：
为了增强ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：
ID的组成部分：
符号位：1bit，永远为0时间戳：31bit，以秒为单位，可以使用69年序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID 3.2 Redis实现全局唯一ID @Component public class RedisIdWorker { /** * 开始时间戳 */ private static final long BEGIN_TIMESTAMP = 1640995200L; /** * 序列号的位数 */ private static final int COUNT_BITS = 32; private StringRedisTemplate stringRedisTemplate; public RedisIdWorker(StringRedisTemplate stringRedisTemplate) { this.stringRedisTemplate = stringRedisTemplate; } public long nextId(String keyPrefix) { // 1.生成时间戳 LocalDateTime now = LocalDateTime.now(); long nowSecond = now.toEpochSecond(ZoneOffset.UTC); long timestamp = nowSecond - BEGIN_TIMESTAMP; // 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29b244624330eb429309d9f322377fff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5de38eae6169b6dd67e87ebd51f0eb4/" rel="bookmark">
			算法——深度优先搜索（DFS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DFS 思路： 从初始状态出发，下一步可能有多种状态；选其中一个状态深入，到达新的状态；直到无法继续深入，回退到前一步，转移到其他状态，然后再深入下去。最后，遍历完所有可以到达的状态，并得到最终的解。DFS通常使用递归来实现弊端： 递归容易超时大部分DFS搜索的题目都需要用到回溯的思路，其难度主要在于扩展子结点时如何构造停止递归并返回的条件。 递归 递归方法就是直接或间接地调用其自身
注意：
避免进入死循环
容易超时
递归 &lt;——&gt; 非递归，相互转化
回溯法 回溯法是一种采用深度优先方式进行搜索的算法，当搜索到某一步时，如果发现原先的选择不是最优选择或者达不到目标，就退回一步重新选择。剪枝函数：（在回溯中用于减少子结点扩展的函数） 1、约束函数：是问题的可行解吗？2、限界函数：确定是问题的可行解，但，是问题的最优解吗？解题步骤： 1、如何递归2、如何剪枝与回溯 一、计算阶乘（递归） 阶乘函数：
比如
3！=6 3！= 3*2*1 = 64！=24 4！= 4*3*2*1 = 245！=120 5！= 5*4*3*2*1 = 120 分析：
package no1_1; import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner input = new Scanner(System.in); int n = input.nextInt(); System.out.println(factorial(n)); } public static int factorial(int n) { if(n==0) { return 1; }else { return n*factorial(n-1); } } } 二、数字游戏（回溯） 给定一个1～N的排列a[i]，每次将相邻两个数相加，得到新序列，再对新序列重复这样的操作，显然每次得到的序列都比上一次的序列长度少1，最终只剩一个数字。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5de38eae6169b6dd67e87ebd51f0eb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/606c75ef2b8815fe03025ab32ed6192f/" rel="bookmark">
			案例224:基于微信小程序的餐厅点餐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
用户信息管理
菜品信息管理
菜品类型管理
公告信息管理
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 互联网发展至今，无论是其理论还是技术都已经成熟，而且它广泛参与在社会中的方方面面。它让信息都可以通过网络传播，搭配信息管理工具可以很好地为人们提供服务。针对餐厅点餐信息管理混乱，出错率高，信息安全性差，劳动强度大，费时费力等问题，采用餐厅点餐系统可以有效管理，使信息管理能够更加科学和规范。
餐厅点餐系统使用Java语言进行编码，使用Mysql创建数据表保存本系统产生的数据。系统可以提供信息显示和相应服务，其管理员餐厅点餐管理信息，查看餐厅点餐管理信息，管理餐厅点餐管理信息。
总之，餐厅点餐系统集中管理信息，有着保密性强，效率高，存储空间大，成本低等诸多优点。它可以降低信息管理成本，实现信息管理计算机化。
系统展示 用户信息管理 此页面提供给管理员的功能有：用户信息的查询管理，可以删除用户信息、修改用户信息、新增用户信息，还进行了对用户名称的模糊查询的条件
菜品信息管理 此页面提供给管理员的功能有：查看已发布的菜品信息数据，修改菜品信息，菜品信息作废，即可删除，还进行了对菜品信息名称的模糊查询 菜品信息信息的类型查询等等一些条件。
菜品类型管理 此页面提供给管理员的功能有：根据菜品类型进行条件查询，还可以对菜品类型进行新增、修改、查询操作等等。
公告信息管理 此页面提供给管理员的功能有：根据公告信息进行新增、修改、查询操作等等。
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.selectOne(new EntityWrapper&lt;UserEntity&gt;().eq("username", username)); if(user==null || !user.getPassword().equals(password)) { return R.error("账号或密码不正确"); } String token = tokenService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/606c75ef2b8815fe03025ab32ed6192f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b89d1142da81c579e3dc09dec394336/" rel="bookmark">
			案例214:基于微信小程序的水果销售系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：springboot
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
用户信息管理
水果信息管理
水果类型管理
论坛信息管理
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 互联网发展至今，无论是其理论还是技术都已经成熟，而且它广泛参与在社会中的方方面面。它让信息都可以通过网络传播，搭配信息管理工具可以很好地为人们提供服务。针对高校教师成果信息管理混乱，出错率高，信息安全性差，劳动强度大，费时费力等问题，采用水果销售系统可以有效管理，使信息管理能够更加科学和规范。
水果销售系统使用Java语言进行编码，使用Mysql创建数据表保存本系统产生的数据。系统可以提供信息显示和相应服务，其管理水果销售系统信息，查看水果销售系统信息，管理水果销售系统。
总之，水果销售系统集中管理信息，有着保密性强，效率高，存储空间大，成本低等诸多优点。它可以降低信息管理成本，实现信息管理计算机化。
系统展示 用户信息管理 此页面提供给管理员的功能有：用户信息的查询管理，可以删除用户信息、修改用户信息、新增用户信息，还进行了对用户名称的模糊查询的条件
水果信息管理 此页面提供给管理员的功能有：查看已发布的水果信息数据，修改水果信息，水果信息作废，即可删除，还进行了对水果信息名称的模糊查询 水果信息信息的类型查询等等一些条件。
水果类型管理 此页面提供给管理员的功能有：根据水果类型进行条件查询，还可以对水果类型进行新增、修改、查询操作等等。
论坛信息管理 此页面提供给管理员的功能有：根据论坛信息进行新增、修改、查询操作等等。
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.selectOne(new EntityWrapper&lt;UserEntity&gt;().eq("username", username)); if(user==null || !user.getPassword().equals(password)) { return R.error("账号或密码不正确"); } String token = tokenService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b89d1142da81c579e3dc09dec394336/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aed001d74893ce030203e37de77842af/" rel="bookmark">
			作为铭文跨链赛道龙头，SoBit 有何突出之处？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跨链桥赛道将是铭文市场长期的发展的刚需
在比特币网络中，Ordinals 铭文铸造的铭文总量已经超过了 5100 万枚，并累计费用收入超 5028 BTC。同时，仅 BRC-20 叙事方向的市值，就已经超过了 30 亿美元，并且随着铭文资产种类与数量的攀升，该数值仍在增长。我们看到铭文热仍在持续，每天也仍旧会有大量的铭文资产面向市场。
虽然 Ordinals 的方案对于比特币生态来说是革命性的，不仅为其带来了资产发行方案，并倒逼了生态各类技术的革新，但我们不得不承认的事实是，铭文资产到目前为止，也只能以类似于 NFT 交易的方式实现交易，比如包括 Ordinals Market、Unisat Marketplace 等在内的铭文交易市场，仍旧以点对点撮合交易的方式来推动流动性，交易效率极低。
在低定价模式的基础上，缺乏流动性的铭文资产很容易产生极为夸张的纸面涨幅。所以如何让铭文资产更好的捕获流动性、更合理的参与到 DeFi 中，才能帮助铭文板块去杠杆化，以推动该板块的正向发展。
现实情况是，比特币 Layer1 不支持智能合约，比特币 Layer2 发展仍旧滞缓短期内难以为其提供更好的支持，所以将比特币生态中的铭文资产带入到图灵完备的生态中，在 DeFi、GameFi 等成熟板块中发挥作用，捕获流动性与价值，将成为未来铭文板块发展的趋势或者主基调。
另一面，市场上已经出现了一些能够为铭文资产提供金融场景的设施，比如以太坊上的铭文借贷协议 Toka Finance、多链铭文 AMM DEX Allins 等等，但这些设施都需要长期获得跨链桥的桥接支持。
所以从整体趋势上看，铭文市场将对跨链有着极大的需求（每天铭文资产的数量、种类都在增长），所以铭文跨链桥赛道将具备极大的想象空间与发展潜力。
Multibit 是铭文板块最早的跨链桥，它主要是是将 BRC20 资产在 EVM 链（ETH链、BNB链、Polygon链）间双向跨链传递。11 月在 Multibit LaunchPad 后，目前其代币已经有了500倍涨幅，总市值约为2.32亿美元，而上线 40 多天，MultiBit 桥的交易量超 4.4 亿美金。
在 MultiBit 后，SoBit 会是铭文跨链赛道新王？ 虽然 Multibit 抢占了 EVM 链与 BRC20 资产跨链的先机，尤其是主要的流动性还在以太坊生态。但 SoBit 是首个支持 Solana 与 BRC20 资产跨链的跨链桥。同样，我们也认为 Sobit 才是铭文跨链板块真正的龙头协议。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aed001d74893ce030203e37de77842af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f608c904b7aacbe3c5c9fb78a6fbd6d2/" rel="bookmark">
			tradingview联系代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		indicator("我的脚本", overlay = false ) k_param = input(title="K length", defval = 14) // 默认时间 d_param= input(title = "D length", defval = 3) // SMA rsi_param= input(title = "RSI length", defval = 7) // rsi是在0-100的区间震动 这里的输入框是震动指标的天数 upper = input(title = "Over Brought", defval = 80) lower = input(title = "Over Sold", defval = 20) // 震荡指标 rsi = ta.rsi(close, rsi_param) // 这里获取7天的一个震荡指标强度 // 实际震荡指标算法 Stochastic = 100 * (close - ta.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f608c904b7aacbe3c5c9fb78a6fbd6d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4c8f8e7305e02601a375004f43e06ca/" rel="bookmark">
			深入理解Mysql MHA高可用集群搭建：从实验到实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 简介 MHA（Master High Availability）是一个高效的开源MySQL高可用性解决方案。由日本开发者yoshinorim（前DeNA员工，现在Facebook）创建，MHA支持MySQL的主从复制架构，自动化主节点故障转移。当主节点发生故障，MHA能迅速将最新数据的从节点升级为新主节点。这个过程中，MHA从其他从节点获取额外信息，确保数据一致性。MHA还能在线切换主节点，按需调整主从节点关系。它已被证明是一个成熟的MySQL高可用方案，能在30秒内完成故障切换，并最大限度地保证数据一致性。值得一提的是，淘宝也在开发一个类似的产品TMHA，目前支持一主一从架构。
2. MHA服务 MHA服务包括两种角色：MHA Manager（管理节点）和MHA Node（数据节点）。
MHA Manager：通常部署在一台独立的机器上，管理多个master/slave集群，每个集群称为一个application。它负责整个集群的管理和协调。MHA Node：安装在每台MySQL服务器（无论是master、slave还是manager）上。它负责监控、解析日志和加快故障恢复的过程。 工具与功能 MHA提供了一系列工具，分布在Manager节点和Node节点上：
Manager节点工具： masterha_check_ssh：检测SSH环境。masterha_check_repl：检测MySQL复制环境。masterha_manager：MHA的主服务程序。masterha_check_status：探测MHA运行状态。masterha_master_monitor：监测MySQL主节点可用性。masterha_master_switch：切换主节点的工具。masterha_conf_host：添加或删除配置节点。masterha_stop：关闭MHA服务的工具。Node节点工具：（这些通常由Manager的脚本触发，无需手动操作） save_binary_logs：保存并复制主节点的二进制日志。apply_diff_relay_logs：识别并应用差异中继日志事件。purge_relay_logs：清除中继日志。自定义扩展： secondary_check_script：通过多网络路由检测主节点可用性。master_ip_failover_script：更新应用程序使用的master IP。report_script：发送报告。init_conf_load_script：加载初始配置参数。master_ip_online_change_script：更新主节点IP地址。 工作原理 MHA的工作原理可以概括为以下几个步骤：
从故障的master节点保存二进制日志事件（binlog events）。识别拥有最新更新的slave节点。将差异的中继日志（relay log）应用到其他slave节点。应用从master节点保存的二进制日志事件。提升一个slave节点为新master。使其他slave节点开始复制新master的数据。 3.MySQL Replication 环境的实验配置 3.1 准备实验 MySQL Replication 环境 3.1.1 相关配置 在本实验中，我们将设置一个包含四个节点的 MySQL Replication 环境，运行于 CentOS 7.3 系统。MHA (Master High Availability) 对 MySQL 复制环境有特定的配置需求，例如：
所有节点必须开启二进制日志（bin-log）和中继日志（relay-log）。从节点（Slave）需设置为只读模式（read-only）。关闭中继日志自动清理功能（relay_log_purge）。 节点配置如下：
Manager (192.168.37.111): 作为控制器，负责监控和管理。Master (192.168.37.122): 数据库主服务器。配置了 bin-log 和 relay-log，关闭了 relay_log_purge。Slave1 和 Slave2 (192.168.37.133 和 192.168.37.144): 数据库从服务器。与 Master 相同的日志配置。 为方便操作，我们在所有节点的 /etc/hosts 文件中添加了对应的域名解析配置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4c8f8e7305e02601a375004f43e06ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/960883a88fb3abcebe4c3356885cb705/" rel="bookmark">
			高性能计算（HPC）-一文全面理解高性能计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AI的疯狂发展以及视频、图像、音频、3D数据的迫切需要，导致传统的CPU不能满足这样大算力的计算。由于这些数据的运算多是一些简单的运算，因此需要设计出多个算术运算单元的芯片来应对这种少控制多计算的场景。这是并行计算、高性能计算诞生的重要动力。为了适配这样的场景，设计出了以GPU为核心的并行处理芯片、包括DSP、VPU、DPU、NPU等。
本文主要介绍基于这些芯片以及网络、系统引入的高性能计算，比较全面的介绍高性能计算，希望对高性能计算的理解起到一个宏观的作用。
🎬个人简介：一个全栈工程师的升级之路！
📋个人专栏：高性能算法开发优化
🎀CSDN主页 发狂的小花
🌄人生秘诀：学习的本质就是极致重复!
目录
1 引言
1.1 高性能计算
1.2 超算（超级计算机）
1.3 并行计算
1.4 分布式计算
1.5 高性能计算的重要性
1.6 高性能计算的历史与发展
2 高性能计算的核心技术
2.1 并行计算技术
2.1.1 并行计算模型
2.1.2 并行算法设计
2.1.3 并行编程技术
2.2 分布式计算技术
2.2.1 分布式系统架构
2.2.2 分布式算法设计
2.2.3 分布式编程技术
2.3 云计算技术
2.3.1 云计算平台
2.3.2 云计算服务模式
2.3.3 云计算编程技术
2.4 网格计算技术
2.4.1 网格计算架构
2.4.2 网格计算中间件
2.4.3 网格计算应用
3 高性能计算的硬件基础
3.1 处理器技术
3.1.1 多核处理器
3.1.2 超线程技术
3.1.3 高速缓存
3.2 存储器技术
3.2.1 内存技术
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/960883a88fb3abcebe4c3356885cb705/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8cba472b2cc2df73b67122df7e16ffc/" rel="bookmark">
			springboot学习(八十五) 解决springboot3.2找不到资源无法抛出404错误的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 springboot3.2以下可以定义ErrorPageRegistrar将404错误转发到一个接口地址，但升级到springboot3.2（spring6.1）后,该配置不生效，抛出了500错误。
以前的错误页面处理如下：
@ConditionalOnClass(ErrorPageRegistry.class) public class ErrorPageAutoConfiguration implements ErrorPageRegistrar { @Override public void registerErrorPages(ErrorPageRegistry registry) { log.info("-----------错误页面路径配置------------"); registry.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, "/404"), new ErrorPage(HttpStatus.FORBIDDEN, "/403"), new ErrorPage(HttpStatus.BAD_REQUEST, "/400"), new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, "/500")); log.info("-----------错误页面路径配置结束------------"); } } 解决方式 通过查看日志发现springboot3.2默认寻找静态资源，在找不到资源后抛出了NoResourceFoundException，通过ExceptionAdivisor抓取做了处理，而并没有对NoResourceFoundException进行特殊处理，默认进入了500错误。
ExceptionAdivisor中添加一组对此异常的处理，即可：
@ExceptionHandler(value = NoResourceFoundException.class) @ResponseStatus(HttpStatus.NOT_FOUND) public ResponseEntity to404Exception(NoResourceFoundException e) { AccessLogUtils.log(SpringUtils.getRequest(), _404); return res(HttpStatus.NOT_FOUND.value(), "找不到资源", e); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb2c043f0e137e713112463c389449a5/" rel="bookmark">
			工具：绘图工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		绘图工具： 制流程图、结构图、思维导图等
Flowchart Maker &amp; Online Diagram
UI原型图
即使设计
慕客
绘图示例： 软件工程用的15种图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14f6cbdf8b7bdf045e7e8e472fe4ccd8/" rel="bookmark">
			聊一聊 JavaScript 中的作用域和闭包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈喽大家好，我是归思君~
一、引言 我们知道，作用域（Scope）就是代码中变量和函数的可访问的区域，这个区域中决定了变量和函数的生命周期。
在当前的高级程序语言中，主要有词法作用域（静态作用域）和动态作用域两种。其实这两种作用域的区别主要是作用域中的变量和函数，是在编译期还是运行期确定的，从词法分析角度讲，如果是通过静态词法分析而得出的时候，它就被称为词法作用域：
静态作用域：其作用域是在编写代码时就已经确定好，静态作用域是根据变量和函数在代码中的位置来决定。函数寻找变量时，是在函数定义的位置中寻找，而不是调用的位置。现在大多数编程语言都采用的是静态作用域，比如 C, C++, Java, JavaScript, Python 等动态作用域：是在程序运行时根据程序的调用栈来动态确定，而不是在写代码时静态确定。在函数寻找变量时，根据函数调用的位置来寻找。这意味着同一个变量名在不同的调用上下文中可能指向不同的变量，可以用 Js 中的 this 值来进行理解，只有在调用时才知道 this 值的指向，动态作用域类型语言中的所有变量都是以这种形式来确定。动态作用域在现代编程语言中较少见，在某些早期语言中比如 Lisp JavaScript 中就采用的是词法作用域（静态作用域），下面就来详细看看：
二、全局作用域和函数作用域 从范围上分，JavaScript中的作用域有三种：全局作用域、函数作用域和块级作用域。我们先来聊聊全局作用域和函数作用域：
1.全局作用域 In a programming environment, the global scope is the scope that contains, and is visible in, all other scopes. In client-sideJavaScript, the global scope is generally the web page inside which all the code is being executed.
也就是说在一个程序运行环境中，全局作用域指的是能看见的代码全部及其他的作用域；在内置JS代码中，全局作用域是**指所被执行js代码的全部区域。**其生命周期伴随着页面的生命周期
Web浏览器中，全局作用域是window对象，所有的变量和函数是作为其方法和属性创建： var test = 1000; console.log(test);//1000 //全局作用域中定义的变量可以通过，全局对象调用属性的方式来获取 console.log(window.test);//1000 Node环境中，全局作用域是global对象： var y = 200; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14f6cbdf8b7bdf045e7e8e472fe4ccd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d6bcdb3b1f0e2f8dd51667a769e2ff4/" rel="bookmark">
			Python&#43;OpenCV 零基础学习笔记(1-3):anaconda&#43;vscode&#43;jupyter环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言相关链接环境配置：AnacondaPython配置OpenCVOpencv-contrib:Opencv扩展 Notebook:python代码笔记vscode配置配置AnacondaJupyter文件导出 前言 作为一个C# 上位机，我认为上位机的终点就是机器视觉+运动控制。最近学了会Halcon发现机器视觉还是要学一下OpenCV。作为一个爱学习的程序员，我认为Python是逃不过的，毕竟Python可以使用的场景实在太多了，深度学习，人工智能。虽然我是本科学历，但是我还是想去了解一下。
【2022B站最好的OpenCV课程推荐】OpenCV从入门到实战 全套课程
CSDN标题里个括号对应视频的分P
相关链接 【2022B站最好的OpenCV课程推荐】OpenCV从入门到实战 全套课程
OpenCV+Python CSDN专栏
Gitee 项目地址
环境配置：Anaconda Anaconda是一个方便管理的Python集成包，优点如下：
集成了180个常用的科学计算的包方便管理多个版本的Python环境 Anaconda python常用配置环境
Anaconda 下载网址
一路确定就可以了，要记得安装的位置
Python配置 如果你的电脑只装了一个Python环境，就直接安装就好了。我这里提供多个python环境的解决方案。
找到你的Anaconda的安装位置，使用命令行进入，然后输入python就可以看到你安装的Python版本了。我这里的安装位置是E盘的Anaconda位置
然后再cd到Script目录，输入pip list，查看安装包
OpenCV 在Scirpt目录中，直接运行
pip install opencv-python 然后退到根目录，看看OpenCV是否安装成功
如果我们cv2.__version__能正常显示Python版本，那就说明我们python版本安装是正确的版本。
Opencv-contrib:Opencv扩展 Notebook:python代码笔记 vscode配置 我个人选择vscode，史上最强IDE。
配置Anaconda Anaconda 环境变量手动设置(详细)
Python环境部署：Anaconda &amp; VS Code on Windows
运行如下代码
import sys print(sys.version) print('hello world!') Jupyter vscode中配置jupyter（彻底解决Failed to start the Kernel问题）
运行成功，虽然我暂时也不知道有啥用
运行如下代码
#%% # 测试注释 import pandas as pd import numpy as np import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d6bcdb3b1f0e2f8dd51667a769e2ff4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bdd9ca3d363798713b48e9a0897a1ce/" rel="bookmark">
			linux中shell的流程和循环控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流程控制和循环控制 shell流程控制流程注意条件结构数值比较文件测试字符串比较 if语句单分支结构双分支结构多分支结构嵌套结构 case语句格式 shell循环控制for循环while循环until循环expect交互shell循环控制 shell流程控制 任何编程都离不开判断（流控）
流程注意 1.[]表示条件测试，这里的空格很重要 2.在shell中，then和fi是分开的语句，如果要放在一行，需要分号隔开 3.注意if判断中对变量的处理，需要加引号 4.判断不支持浮点值 5.如果单独使用&lt;或者&gt;系统会认为是重定向，如果要使用，要对这些符号转意 6.默认运行if语句中的命令，所产生的错误信息，会出现在脚本的输出结果中，一般会使用&amp;&gt;/dev/null 7.使用-n或者-z来检查长度时候，没有定义的变量也为0 8.空变量和没有初始化的变量会对shell脚本造成灾难性的影响，再不确定变量内容时，可以使用-n或者-z测试一下 9.$?变量包含了之前执行命令的退出状态，最近完成的前台进程 调试脚本 sh -n 文件名 //仅调试脚本中的语法错误 sh -x 文件名 //逐句语句追踪 sh -v 文件名 //显示执行过程详细信息 sh -vx 文件名 //以调试的方式执行，查询整个执行过程，第一行是计算机看到的 第二行是计算机执行的 第三行是计算机输出的 条件结构 test 条件 条件为真返回0；条件为假返回1 [ 条件表达式 ] [[ 条件表达式 ]] test 能够理解3种类型的表达式 文件测试 字符串比较 数字比较 数值比较 [ -gt ] 大于 [ -lt ] 小于 [ -eq ] 等于 [ -ne ] 不等于 [ -ge ] 大于等于 [ -le ] 小于等于 文件测试 -f filename ：当filename存在时返回真 -b filename ：当filename存在并且是块文件时返回真 -d pathname ：当pathname存在并且是一个目录时返回真 -h filename ：当filename存在并且是符号链接文件时返回真，软连接 -c filename ：当filename存在并且是字符文件时返回真 -e pathname ：当由pathname指定的文件或目录存在时返回真 -g pathname ：当由pathname指定的文件或目录存在并且设置了SGID位时返回真 (SGID一种特殊的权限) -k pathname ：当由pathname指定的文件或目录存在并且设置了"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bdd9ca3d363798713b48e9a0897a1ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9a1bfefa94e458febef95fdf38c920a/" rel="bookmark">
			基于ssm的家居家电维修系统微信小程序源码和论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1．本课题的研究目的和意义：
随着我国互联网的普及，微信成为了人们日常生活中必不可少的交流工具。据相关数据显示，2018年上半年微信的日均活跃用户已超过10亿。如此庞大的用户量催生了微信小程序的迅猛发展。在日常生活方面，许多的行业都提供了微信小程序让用户更加便捷的使用。
同样的家居家电维修系统小程序也能给用户带来方便。传统的家居家电维修需要用户临时出门找维修师傅，对于赶时间的用户来说十分不方便。而且他不知道维修师傅当前是否有空，能否上门维修。但家居家电维修系统小程序不同，首先它无需用户下载app，无需占用手机的空间内存。其次它可以直接在小程序上线上下单，寻找附近有空的维修师傅上门进行维修。能让用户不出家门就可以寻找到维修师傅，同时它可以提前预约维修师傅上门，能让维修师傅在用户有空的时间才上门进行维修。该小程序能让用户在日常生活中节省时间以及提供便利，对于平时不出家门的用户也能快捷找到维修师傅上门，能帮助到许多有需要帮助的人。
【588】基于ssm的家居家电维修系统微信小程序源码和论文开题报告任务书
本课题的文献综述（不少于1500字）近年来，微信小程序在大量微信用户的催生下得到迅速的发展。微信小程序从上线开始，就让很多企业蠢蠢欲动。因为，微信小程序的兴起让许多无法承担传统APP开发费用的企业看到了曙光，对于大学生创业来说，小程序的成本相比于APP的开发也十分廉价。作为微信主推的产品，小程序也从未在众人的目光中退场，它的每一个动作都牵动着互联网从业者的心。
移动互联网兴起时带来了一批创业热，相比APP而言，小程序的开发成本很低，这给独立开发者带来了机会。依附于微信国民级的聊天工具，微信小程序的灵活性让它可以基于场景聚合各种服务。手机中App的使用率不超过40%。而小程序“无需下载，即开即用，用完即走”的特质让它可以成为头部App的补充应用，同时代替一部分低频服务的App。其实小程序应用得最多的类型是生活服务类，工具类。大多都是一些基于生活场景的应用，对于一般的生活需求而言，已经可以满足大部分用户的需求。
微信对小程序的重视程度一点不亚于当年的公众号。虽然不主动宣传，功能开放速度像是在挤牙膏。但是根据网络的统计显示，微信官方发布的小程序场景入口已达41个，搜一搜、二维码、公众号、LBS、小程序系统入口等等是小程序流量引导的主要入口场景。公众号关联小程序、文章中插入小程序等功能开放，让小程序的入口场景变得十分丰富。然而，经过一番筛选，其实能够实际应用到生活中的或许只有32个左右。
微信小程序在各个行业的应用，大大节约了手机的使用空间外，使客户粘性再次加大，对于微信的依赖也有所增强。现如今，人们的使用习惯趋向于移动端，而且对于刚性需求的微信小程序可谓是依赖巨深。而对于一些低频的应用而言，用户也更加期待一种更加便捷的方式去取代APP。现在小程序已经在各个行业都实现了快速的发展，并且产生了深刻的影响，作为工具性质，低频实用性为目的开发额的小程序也正越来越深受时下消费者的支持。以低频的旅游行业为例，开发微信小程序不仅仅能够使获客半径扩大，同时能够延伸旅游相关知识、提升用户旅游体验，甚至能够直接利用微信小程序进行用户流量变现。移动互联网的每个节点都会催生新商业模式的诞生，对小程序来说，它成长的时间太短，大部分人还看不到小程序创业的未来。只有先行者才能获得巨大的发展红利。现在布局小程序，就是抢占市场。
再来说我们的家居家电维修小程序的开发有哪些优势?家居家电使用频率高，难免有时候会发生问题。当出现故障的时候，需要能快速找到维修工，来保障日常生活的正常运转。以往消费者出现维修需求时，一般都是寻找一些线下“牛皮癣”小广告或是去实体店找维修工，然而这些方式不管是沟通、还是时间效率都极低。而且这种方式不合适那些平常不喜欢出门的人，在日常生活中，工作回家后难免不想到处走动。还有一些人刚刚搬家对附近地理并不了解，这种情况下让他们寻找维修师傅上门修为家居家电是十分不方便的。
综上论述，开发一款家居家电维修小程序，用户无需出门就能在手机上下单预约维修，而维修工则可以实时收到订单通知，用完即走，不占内存，符合家电维修的这个低频使用场景。家电维修小程序的开发优势有哪些呢？
1、安全服务，性比价高
相比路边上的小广告，维修平台为供需双方做信誉担保，价格透明、服务可追溯。小程序商提供的维修服务不仅在维修效率上有严格规定，在维修人才的选择上也是经过严格筛选，还有口碑评价机制，保障双方的权益。
2、数据整合，提高服务水平
家居家电维修小程序，在用户下单，在完成订单后可以对该订单评价，对维修师傅打分。可以知道哪些维修师傅的服务水平更高。
3、提前预约，无需等待
在家居家电维修小程序里，用户可以提前下单，预约师傅在自己有空的时候上门进行维修，这样能更加的快速便捷有效的帮用户维修。
4、方便快捷，无需占用内存空间
相比传统app，小程序对于用户来说“无需下载，即开即用，用完即走”，达到真正的便捷效率。
【588】基于ssm的家居家电维修系统微信小程序源码和论文开题报告任务书
package com.controller; import java.io.File; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Iterator; import java.util.List; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.apache.commons.fileupload.FileItem; import org.apache.commons.fileupload.FileItemFactory; import org.apache.commons.fileupload.FileUploadException; import org.apache.commons.fileupload.disk.DiskFileItemFactory; import org.apache.commons.fileupload.servlet.ServletFileUpload; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.ResponseBody; import com.model.Gginfo; import com.model.Pinglun; import com.model.Userinfo; import com.model.Wxuser; import com.model.Zhaopin; import com.response.GonggaoListResponse; import com.response.GonggaoResponse; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9a1bfefa94e458febef95fdf38c920a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9819154dbd5506f1e784e1fbf6388bbd/" rel="bookmark">
			stm32H743编译器关于浮点类型强制转换传参的bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		局部函数，正常传参 当测试函数作为局部函数和main函数写在同一个文件中时，参数可以正常传递。函数参数和形参都为3.14
float value = 0.0; void float_test(float _v) { value = _v; } int main(void) { float_test(3.14f); while(1); } keil仿真截图，形参正常
全局函数，异常传参 当测试函数放到另一个文件中，在main函数中进行调用时，会发生异常参数，函数形参转换出错
test.c
float value = 0.0; void float_test(float _v) { value = _v; } main.c
int main(void) { float_test(3.14f); while(1); } keil仿真截图，形参出错，变为了一个极小值，可能是数据对齐有问题
原因分析 可能是编译器在保存单精度浮点参数时还是按double类型，读取参数时确按float类型来进行读取，所以出现了错误
解决方案 浮点数传参不要使用float类型，采用默认的double类型进行传参，就可以正常传参了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca64322b183b1ebcca3bed60a61b81fb/" rel="bookmark">
			基于springboot农副产品交易平台的微信小程序源码和论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于微信的农产品交易商城设计与开发
摘要：伴随着移动互联网的进一步发展趋势，传统式手机应用程序的问题慢慢出現在技术性关心的行业。原生态Android运用的安裝和卸载掉危害用户体验，一个轻量的内嵌式WEB程序流程为用户体验吸引住了愈来愈多开发人员的关心。自打微信小程序明确提出后，愈来愈多的互联网公司竞相开发设计单独的微信小程序运用，大有作为。
根据现阶段盛行的微信小程序应用程序开发技术性，融合农产品买卖商城系统的用户需求，开发设计了一套易于器重、可配备、面对小店的农产品买卖商城系统开发。系统软件根据现阶段流行的Java后端工程师框架SpringBoot、流行的数据库配备框架MyBatis和实用的MySQL数据库搭建后台管理网络服务器新项目，应用Vue网站前端开发框架和Element-ui插口原素完成小程序管理员的操作系统插口，依据微信小程序给予的设计方案文档制作原生态农产品买卖商城小程序。微信小程序可以达到现阶段小店的商业要求，完成控制模块的信息配备，易于二次开发。有利于迅速构建成形系统软件，具备一定的社会经济实际效果。
【587】基于springboot农副产品交易平台的微信小程序源码和论文
关键词：农产品交易商城，小程序，动态配置，SpringBoot，Vue
Design and Development of Online Mall Based on WeChat
Abstract: With the further development trend of mobile Internet, the problems of traditional mobile phone applications are slowly emerging in industries of technical concern. The installation and uninstallation of the original Android application endanger the user experience. A lightweight embedded web program process has attracted more and more developers' attention for the user experience. Since the wechat applet was clearly put forward, more and more Internet companies have competed to develop and design separate wechat applets, which have made great achievements。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca64322b183b1ebcca3bed60a61b81fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c6c54d080d4f0a2c9fe2ce6f66bb9da/" rel="bookmark">
			PHP序列化总结1--序列化和反序列化的基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序列化和反序列化的作用 1.序列化：将对象转化成数组或者字符串的形式
2.反序列化：将数组或字符串的形式转化为对象
为什么要进行序列化 这种数据形式中间会有很多空格，不同人有不同的书写情况，可能还会出现换行的情况
为此为了方便数据传输，我们可以进行序列化操作将其变为一个字符串的形式进行传输
案例分析 我们在写PHP代码的时候会写到类这种数据形式
&lt;?php class demotest{ public $name='xiaodi'; public $sex='man'; public $age=29; public $arr=array('abc',123,'demo'); } $dd=new demotest(); echo serialize($dd); 类似于这样，原来的数据中就有很多的空格、换行、缩进等额外的数据，这些数据没有用，而且不同人写代码的习惯不同，这些东西都会有差异，而且不可避免在传输过程中可能会产生错误，为此，绕过将数据进行了序列化，就会将传输的数据以统一的格式进行传输，这样就比较规范而且减少出错的概率。
因此为了保证数据传递的效率和正确性，我们可以把数据进行序列化后进行传输
序列化后各字段的含义
O：表示的是序列化一个对象，8是对象名称的长度，3 表示有3个属性 s表示第一个属性是字符串类型 4 表示的是第一个属性的字符串长度 name是第一个属性的属性名称，以分号结尾，s表示对象的属性为字符串，长度是6，值为xiaodi，后面的以此类堆......对象的属性相关信息都使用 {}括起来，当然对于数组这样复杂的数据结构我们直接进行输出查看格式内容即可
序列化的内容是什么 序列化只序列化成员变量，不序列化成员函数
案例分析 &lt;?php class a{ public $username='xxxxxx'; public $password='xxxxxx'; public function daying(){ echo 'hello'; } public function __destruct(){ echo 'over'; } } $aa= new a(); echo serialize($aa); 我们在序列化的时候一个类中可能有属性也会有方法，但是我们在序列化的时候只会序列化一个对象的属性，不会序列化对象的方法。如图，我们定义的类a中有username和password两个属性，也有daying()和__destruct()两个方法，我们可以看到在序列化后a对象中之序列化了两个属性，为此两个方法并没有被序列化，输出的over是因为触发了destruct()方法打印出来的结果，与序列化无关（ps：主要是说明序列化只要是函数都不会被序列化)
反序列化--将序列化的数据还原成对象 将序列化的数据还原成对象
反序列化后的对象里面的值是反序列化里面的值决定，与原来的预定义的值无关--通过反序列化我们可以修改原来类中属性的值
&lt;?php class demotest{ public $a='hello'; public function demo(){ echo $this-&gt;a; }	} $dd=new demotest(); echo(serialize($dd)); $ee='O:8:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c6c54d080d4f0a2c9fe2ce6f66bb9da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93289ecee970e30e4d827a6494f99fc0/" rel="bookmark">
			linux ext3/ext4文件系统（part1格式化）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ext4文件系统结构 ext3的代码已经在v4.3被删除掉了（ARM: tegra: Rebuild default configuration on v4.3-rc1 · torvalds/linux@241e077 · GitHub） ext4格式化的代码可以参考e2fsprogs的实现：mke2fs.c
格式化后的文件系统结构如下图：
flexible group 如果支持flexible group功能，默认可将16个group打包为一个flexible group。
每个group 都有四个主要区域：
block bitmapinode bitmapinode tabledata 其中前三部分是元数据，元数据在 flexible 模式下有两种布局方式：
一种是全部放在第一个flexible group的第一个group上。另一种是每个flexible group中第一个group上存放这个flexible group 的元数据 当元数据占用达到一个group的四分之三时，会将这个group的全部作为元数据存储，称meta_group。
如果不启用flexible，则每个group维护自己的元数据（参考：linux 中 ext2文件系统实现）
group 中块数在256～8*block_size之间，默认8 * block_size（比如一块4096大小的话，一个group有32k个block）。
元数据备份 ext2支持为0、1、3/5/7的n次方块加入super block 与group desc block的备份 （参考：linux 中 ext2文件系统实现）。ext4将这标记成了deprecated。如果开启备份，则只备份一份，默认备份在最后一个group上。
block cluster ext4将block打包成了cluster（默认16个block 为一个cluster），在分配块时，以cluster为最小单位去分配。格式化过程中会先在内存中存一个 block bitmap， 以block为最小单位去分配块，在分配完block/inode bitmap和inode table 后，会将bitmap将为以 cluster 为单位，存到磁盘上。
初始文件 初始文件至少有root 和 lost_and_found目录，其它：
如果有bad block，会将bad block 的位置以数组形式存到bad block inode上如果启用日志功能，则生成日志文件，它包含了fast commit 日志和普通的日志（fast commit 记录更精练，是一种优化的日志，具体实现还没有看，参考：LWN: ext4 文件系统的快速提交！-CSDN博客）两部分日志的大小的和限制在1k-10m个block之间。如果启用orphan file 功能（删除文件时，先将inode记入orphan file，在inode的data块完全释放后才将inode从orphan file移除，防止系统崩溃后文件删除了，但内容块没有回收的情况），创建orphan file 它的大小在32-512个block之间（总块数除以4k）。 e2fsprogs对ext4格式化的实现 main(): // 1、解析用户参数，有些参数从profile读 PRS(argc, argv)： blocksize：1024~65536之间 block per group：默认8 * block_size块 inodes_count：默认第8192字节对应一个inode meta group：是否指定了完全存元数据的 group num_backups: super + group desc 的备份group号，默认是１号和最后一个group cluster_size：默认16个block // ２、计算参数 ext2fs_initialize(): 计算 s_clusters_per_group 计算 desc_blocks：每个group一个desc 计算 s_inodes_count 默认平均4096byte一个inode 计算 s_inodes_per_group 计算 s_reserved_gdt_blocks：为以后扩展ext4大小预留的group desc，预计filesystem大小可以增长到1024倍 group desc block 大于3/4的group时，启用meta block group，并　s_reserved_gdt_blocks为0 最后一个group要装备份super + group desc block，如是太小，要删掉最后一个group重算上面的参数 在分配内存记录格式化占用的block，此时的block bitmap单位是block，不是cluster 分配其它内存，比如inode bitmap，group desc ３、检测标记坏块，并标记在block bitmap上 ４、分配block bitmap、 inode bitmap、 inode table，有两种模式packed/unpacked（packed_allocate_tables、ext2fs_allocate_tables） ５、将block bitmap 转为以cluster 为单位的bitmap ６、分配inode初始文件 root lost_and_found 标记reserve inode 创建bad block inode 记录哪些块不能用 添加journal inode　占用1k-10m个块之间　添加orphan file 最多32-512个block 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9775f6fa5f62db8a2704e6280d8d97be/" rel="bookmark">
			基于springboot农产品交易商城源码和论文（管理员 商家 用户三种角色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
伴随着互联网技术的进步，各种电商平台也如雨后 春笋不断涌现。一个好的电商平台应该具有用户体验度高，用户信息安全等特点, 从而可以满足更多的用户需求。现有的电商平台虽然在不断完善，但仍然存在着 不少问题。本设计是一个基于SSM框架开发的农产品商城项目，在较好地实现传 统电商平台的基础上又有创新和改善之处，比如分层搭建的设计思想，md5加密 算法的改进以及设计更为友好的操作界面等，以更好地服务大众。
本农产品商城网站以IDEA+mysql为开发环境，JSP+CSS+JavaScript为页面编辑语言，springboot+mybatis为后台编辑语言来设计开发,开发一个农产品商城正是为了企业独立开发的目的。J2EE体系的农产品商城 具备很高的安全性和稳定性，以及更加出色的可扩展性和跨平台特点。在国外 J2EE 已经成为开发电子商务平台的主流技术，本文研发的农产品商城系统使消费者进行购物时，不但农产品推荐更为符合消费者的消 费习惯，且农产品的质量安全以及用户个人信息能够得到有效保障，提升了消费者的购物体验，本系统主要设计用户选购，加入购物车，下单等功能，当然对应的有一个后台系统管理，主要是对前端即用户端的一个数据的支持管理，只有管理员角色才可以登陆。
本文基于springboot mybatis框架完整的实现了一个农产品商城系统，可以为用户提供购买农产品、等多个功能。从测试结果来看，系统完整实现了所需功能，而且具有一定的 稳定性和可靠性，并能够为用户提供良好的用户体验。总之，本系统基本符合客户的 需求，并达到了预期的目标。
【586】基于springboot农产品交易商城源码和论文（管理员 商家 用户三种角色
关键词：农产品商城 idea mysql springboot
Abstract With the progress of Internet technology, various e-commerce platforms have sprung up. A good e-commerce platform should have the characteristics of high user experience and user information security, so as to meet more user needs. Although the existing e-commerce platform is constantly improving, there are still many problems.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9775f6fa5f62db8a2704e6280d8d97be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6a5c52c76b3dd5dee51a77db7c1c6b3/" rel="bookmark">
			sheng的学习笔记-卷积神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源自吴恩达的深度学习课程，仅用于笔记，便于自行复习
导论 1）什么是卷积神经网络 卷积神经网络，也就是convolutional neural networks （简称CNN），使用卷积算法的神经网络，常用于计算机视觉等领域
2）卷积神经网络的一些应用场景 2.1 图片分类，或者说图片识别。比如给出这张64×64的图片，让计算机去分辨出这是一只猫。
2.2 目标检测，比如在一个无人驾驶项目中，你不一定非得识别出图片中的物体是车辆，但你需要计算出其他车辆的位置，以确保自己能够避开它们。所以在目标检测项目中，首先需要计算出图中有哪些物体，比如汽车，还有图片中的其他东西，再将它们模拟成一个个盒子，或用一些其他的技术识别出它们在图片中的位置。注意在这个例子中，在一张图片中同时有多个车辆，每辆车相对与你来说都有一个确切的距离
2.3 神经网络实现的图片风格迁移，比如说你有一张图片，但你想将这张图片转换为另外一种风格。所以图片风格迁移，就是你有一张满意的图片和一张风格图片，实际上右边这幅画是毕加索的画作，而你可以利用神经网络将它们融合到一起，描绘出一张新的图片。它的整体轮廓来自于左边，却是右边的风格，最后生成下面这张图片
3）应用计算机视觉时面临一个挑战 应用计算机视觉时要面临一个挑战，就是数据的输入可能会非常大。举个例子，在过去的课程中，你们一般操作的都是64×64的小图片，实际上，它的数据量是64×64×3，因为每张图片都有3个颜色通道。如果计算一下的话，可得知数据量为12288，所以我们的特征向量维度为12288。这其实还好，因为64×64真的是很小的一张图片。
如果你要操作更大的图片，比如一张1000×1000的图片，它足有1兆那么大，但是特征向量的维度达到了1000×1000×3，因为有3个RGB通道，所以数字将会是300万。
如果你要输入300万的数据量，这就意味着，特征向量的维度高达300万。所以在第一隐藏层中，你也许会有1000个隐藏单元，而所有的权值组成了矩阵 。如果你使用了标准的全连接网络，这个矩阵的大小将会是1000×300万。因为现在的维度为，通常用来表示300万。这意味着矩阵会有30亿个参数。在参数如此大量的情况下，会有这些问题：神经网络的过拟合，耗费高内存，计算时间长
卷积算法 卷积运算是卷积神经网络最基本的组成部分，使用边缘检测作为入门样例
1）边缘检测示例（Edge detection example） 给了这样一张图片，让电脑去搞清楚这张照片里有什么物体，你可能做的第一件事是检测图片中的垂直边缘。比如说，在这张图片中的栏杆就对应垂直线，与此同时，这些行人的轮廓线某种程度上也是垂线，这些线是垂直边缘检测器的输出。同样，你可能也想检测水平边缘，比如说这些栏杆就是很明显的水平线，它们也能被检测到，结果在这。所以如何在图像中检测这些边缘？
这是一个6×6的灰度图像。因为是灰度图像，所以它是6×6×1的矩阵，而不是6×6×3的，因为没有RGB三通道。为了检测图像中的垂直边缘，你可以构造一个3×3矩阵。在共用习惯中，在卷积神经网络的术语中，它被称为过滤器。我要构造一个3×3的过滤器，下面的filter。注意，下面的*是卷积的符号
这个卷积运算的输出将会是一个4×4的矩阵，你可以将它看成一个4×4的图像。下面来说明是如何计算得到这个4×4矩阵的。为了计算第一个元素，在4×4左上角的那个元素，使用3×3的过滤器，将其覆盖在输入图像，如下图所示。然后进行元素乘法（element-wise products）运算，然后将该矩阵每个元素相加得到最左上角的元素，即
把这9个数加起来得到-5，当然，你可以把这9个数按任何顺序相加，我只是先写了第一列，然后第二列，第三列。
接下来，为了弄明白第二个元素是什么，你要把蓝色的方块，向右移动一步，像这样，把这些绿色的标记去掉：
为了说得更清楚一点，这个-16是通过底部右下角的3×3区域得到的。
因此6×6矩阵和3×3矩阵进行卷积运算得到4×4矩阵。这些图片和过滤器是不同维度的矩阵，但左边矩阵容易被理解为一张图片，中间的这个被理解为过滤器，右边的图片我们可以理解为另一张图片。这个就是垂直边缘检测器，下一页中你就会明白。
在往下讲之前，多说一句，如果你要使用编程语言实现这个运算，不同的编程语言有不同的函数，而不是用“”来表示卷积。所以在编程练习中，你会使用一个叫conv_forward的函数。如果在tensorflow下，这个函数叫tf.conv2d。在其他深度学习框架中，在后面的课程中，你将会看到Keras这个框架，在这个框架下用Conv2D实现卷积运算。所有的编程框架都有一些函数来实现卷积运算。
为什么这个可以做垂直边缘检测呢？让我们来看另外一个例子。为了讲清楚，我会用一个简单的例子。这是一个简单的6×6图像，左边的一半是10，右边一般是0。如果你把它当成一个图片，左边那部分看起来是白色的，像素值10是比较亮的像素值，右边像素值比较暗，我使用灰色来表示0，尽管它也可以被画成黑的。图片里，有一个特别明显的垂直边缘在图像中间，这条垂直线是从黑到白的过渡线，或者从白色到深色。
如果把最右边的矩阵当成图像，它是这个样子。在中间有段亮一点的区域，对应检查到这个6×6图像中间的垂直边缘。
2)更多边缘检测内容（More edge detection） 它的颜色被翻转了，变成了左边比较暗，而右边比较亮。现在亮度为10的点跑到了右边，为0的点则跑到了左边。如果你用它与相同的过滤器进行卷积，最后得到的图中间会是-30，而不是30。如果你将矩阵转换为图片，就会是该矩阵下面图片的样子。现在中间的过渡部分被翻转了，之前的30翻转成了-30，表明是由暗向亮过渡，而不是由亮向暗过渡。
如果你不在乎这两者的区别，你可以取出矩阵的绝对值。但这个特定的过滤器确实可以为我们区分这两种明暗变化的区别。
再来看看更多的边缘检测的例子，我们已经见过这个3×3的过滤器，它可以检测出垂直的边缘。所以，看到右边这个过滤器，我想你应该猜出来了，它能让你检测出水平的边缘。提醒一下，一个垂直边缘过滤器是一个3×3的区域，它的左边相对较亮，而右边相对较暗。相似的，右边这个水平边缘过滤器也是一个3×3的区域，它的上边相对较亮，而下方相对较暗。
再次强调，我们现在所使用的都是相对很小的图片，仅有6×6。但这些中间的数值，比如说这个10（右边矩阵中黄色方框标记元素）代表的是左边这块区域（左边6×6矩阵中黄色方框标记的部分）。这块区域左边两列是正边，右边一列是负边，正边和负边的值加在一起得到了一个中间值。但假如这个一个非常大的1000×1000的类似这样棋盘风格的大图，就不会出现这些亮度为10的过渡带了，因为图片尺寸很大，这些中间值就会变得非常小。
总而言之，通过使用不同的过滤器，你可以找出垂直的或是水平的边缘。但事实上，对于这个3×3的过滤器来说，我们使用了其中的一种数字组合。
随着深度学习的发展，我们学习的其中一件事就是当你真正想去检测出复杂图像的边缘，你不一定要去使用那些研究者们所选择的这九个数字，但你可以从中获益匪浅。把这矩阵中的9个数字当成9个参数，并且在之后你可以学习使用反向传播算法，其目标就是去理解这9个参数。
Padding 为了解决这两个问题，一是输出缩小。当我们建立深度神经网络时，你就会知道你为什么不希望每进行一步操作图像都会缩小。比如当你有100层深层的网络，如果图像每经过一层都缩小的话，经过100层网络后，你就会得到一个很小的图像，所以这是个问题。另一个问题是图像边缘的大部分信息都丢失了。
valid and same padding 卷积步长（Strided convolutions） 卷积中的步幅是另一个构建卷积神经网络的基本操作，让我向你展示一个例子。
如果你想用3×3的过滤器卷积这个7×7的图像，和之前不同的是，我们把步幅设置成了2。你还和之前一样取左上方的3×3区域的元素的乘积，再加起来，最后结果为91。
现在我们继续，将蓝色框移动两个步长，你将会得到83的结果。当你移动到下一行的时候，你也是使用步长2而不是步长1，所以我们将蓝色框移动到这里：
注意到我们跳过了一个位置，得到69的结果，现在你继续移动两个步长，会得到91，127，最后一行分别是44，72，74。
输出维度计算公式 三维卷积（Convolutions over volumes） 你已经知道如何对二维图像做卷积了，现在看看如何执行卷积不仅仅在二维图像上，而是三维立体上。
我们从一个例子开始，假如说你不仅想检测灰度图像的特征，也想检测RGB彩色图像的特征。彩色图像如果是6×6×3，这里的3指的是三个颜色通道，你可以把它想象成三个6×6图像的堆叠。为了检测图像的边缘或者其他的特征，不是把它跟原来的3×3的过滤器做卷积，而是跟一个三维的过滤器，它的维度是3×3×3，这样这个过滤器也有三层，对应红绿、蓝三个通道。
给这些起个名字（原图像），这里的第一个6代表图像高度，第二个6代表宽度，这个3代表通道的数目。同样你的过滤器也有一个高，宽和通道数，并且图像的通道数必须和过滤器的通道数匹配，所以这两个数（紫色方框标记的两个数）必须相等。下个幻灯片里，我们就会知道这个卷积操作是如何进行的了，这个的输出会是一个4×4的图像，注意是4×4×1，最后一个数不是3了。
首先先换一张好看的图片。这个是6×6×3的图像，这个是3×3×3的过滤器，最后一个数字通道数必须和过滤器中的通道数相匹配。为了简化这个3×3×3过滤器的图像，我们不把它画成3个矩阵的堆叠，而画成这样，一个三维的立方体。
为了计算这个卷积操作的输出，你要做的就是把这个3×3×3的过滤器先放到最左上角的位置，这个3×3×3的过滤器有27个数，27个参数就是3的立方。依次取这27个数，然后乘以相应的红绿蓝通道中的数字。先取红色通道的前9个数字，然后是绿色通道，然后再是蓝色通道，乘以左边黄色立方体覆盖的对应的27个数，然后把这些数都加起来，就得到了输出的第一个数字。
如果要计算下一个输出，你把这个立方体滑动一个单位，再与这27个数相乘，把它们都加起来，就得到了下一个输出，以此类推。
这是我们上一张幻灯片的图片，我们让这个6×6×3的图像和这个3×3×3的过滤器卷积，得到4×4的输出。（第一个）这可能是一个垂直边界检测器或者是学习检测其他的特征。第二个过滤器可以用橘色来表示，它可以是一个水平边缘检测器。
所以和第一个过滤器卷积，可以得到第一个4×4的输出，然后卷积第二个过滤器，得到一个不同的4×4的输出。我们做完卷积，然后把这两个4×4的输出，取第一个把它放到前面，然后取第二个过滤器输出，我把它画在这，放到后面。所以把这两个输出堆叠在一起，这样你就都得到了一个4×4×2的输出立方体，你可以把这个立方体当成，重新画在这，就是一个这样的盒子，所以这就是一个4×4×2的输出立方体。它用6×6×3的图像，然后卷积上这两个不同的3×3的过滤器，得到两个4×4的输出，它们堆叠在一起，形成一个4×4×2的立方体，这里的2的来源于我们用了两个不同的过滤器。
单层卷积网络（One layer of a convolutional network） 最终各自形成一个卷积神经网络层，然后增加偏差，它是一个实数，通过Python的广播机制给这16个元素都加上同一偏差。然后应用非线性函数，为了说明，它是一个非线性激活函数ReLU，输出结果是一个4×4矩阵。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6a5c52c76b3dd5dee51a77db7c1c6b3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/12/">«</a>
	<span class="pagination__item pagination__item--current">13/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/14/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>