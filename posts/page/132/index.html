<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2748656800b3ede5469360a4e9b4684/" rel="bookmark">
			bat脚本常用指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所有文本处理为UTF8:
REM 声明采用UTF-8编码
chcp 65001
设置整个窗口背景和字体颜色：
color 背景色+字体色
color help //查看
例如：
color 07
表示黑底白字，0表示黑 7表示白
关闭语句执行本身的打印：
方法1：文件开始时写上：@echo off
方法2：每个语句前面加上@，或&gt;nul或&gt;nul 2&gt;nul
延迟变量：用户定义变量
setlocal enabledelayedexpansion
窗口大小：
mode con cols=30 lines=20
注意：这里会修改缓冲区大小变为20，因此要使用修改缓冲区方法来处理一次
缓冲区大小：
powershell.exe -command "&amp; {$pshost = Get-Host;$pswindow = $pshost.UI.RawUI;$newsize = $pswindow.BufferSize;$newsize.height = 1500;$pswindow.buffersize = $newsize;}"
注意：这里的大小为1500，可以调整此值实现；bat命令本身没有可以单独设置缓冲区大小的命令，因此只能用powershell方式；也可以使用其它手动设置方法；
设置窗口名称：
title 窗口名称
注意：
1.所有路径最好使用双引号，否则会有很多奇怪的报错
2.所有路径最好用'\'而不要用'/',因为最后一个是文件的话会索引不到
查看端口连接数：
netstat -an |find /c ":80"
查看端口占用的程序：
1.netstat -aon|findstr "49157" //观察最后一个ID,如2720
2.tasklist|findstr "2720"
例：
@echo off
setlocal enabledelayedexpansion
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2748656800b3ede5469360a4e9b4684/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5f3175b36db389bfe6eaa2a79944cff/" rel="bookmark">
			cdr2022更新24.1版CorelDRAW2022稳定版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CorelDRAW是我最早接触的矢量绘图软件，一直用它绘图、排版、打印、输出，一直感觉它功能很强大，CorelDRAW是加拿大的corel公司出品的，corel公司的产品强调的是编辑功能，它将各种要实现的功能直接表现于具体操作中，动动鼠标基本就能实现你想要的效果。CorelDRAW侧重于技术绘图，你可以看到你身边有些小公司没有装CAD软件，就拿CDR软件去绘制一些简单的室内布置图和示意图（这点从corel公司出品的corelcad也可以看出corel公司的优势在此），CorelDRAW的优势在于一个广度，CorelDRAW每次更新都是增加一个小功能，功能多，矢量绘图、文字排版、照片处理、甚至网页编辑，它都可以。CDR更像个无所不能的多面手，绘图、排版、编辑、输出无所不能，就像个能拉客又能拉货的五菱神车或昌河北斗星，有了它你什么都能干。
CorelDRAW（简称CDR）是一款专业的图形设计软件。该软件是加拿大Corel公司开发的一款功能强大的专业平面设计软件、矢量设计软件、矢量绘图软件。这款矢量图形制作工具软件广泛应用于商标设计、标志制作、封面设计、CIS设计、产品包装造型设计、模型绘制、插图描画、时装/服饰设计、印刷制版、排版及分色输出等诸多领域。经历二十多年的发展与蜕变，CorelDRAW系列已经发布了22个版本，其被广泛应用足以说明，其用户涵盖图形设计、平面设计、图文设计、广告设计、商业设计和美术设计等多个领域行业。
CorelDRAW Graphics Suite 2022 v24.1 图形设计软件2022年8月更新推送.该更新包含了针对CorelDRAW Graphics Suite 2022年3月版(24.0版)的功能增强以及性能与稳定性改进.CorelDRAW2022主要增强了图像编辑和导出功能,新功能加快了图片编辑速度,带来新工具,快捷方式和命令菜单,优化了学习工具.
新增和增强功能
CorelDRAW Graphics Suite 2022 年8 月更新（24.1 版）仅限持有有效 CorelSure Maintenance 计划的订阅用户和许可证用户使用，其中包含了针对 CorelDRAW 多方面的功能增强。
在欢迎界面（帮助 &gt; 欢迎 &gt; 教程）中根据您的个人资料调查访问个性化的学习内容。
在导出泊坞窗 (Windows) 或导出检查器 (macOS) 中，通过单击名称标签并输入新的名称对资产或页面进行重命名。在 Windows 上，您可以自定义提交想法和反馈菜单命令，并将更改保存至自定义工作区。如果在 macOS 上，应用程序在会话期间意外退出，系统会自动向 Corel 发送错误日志报告，以便修复问题并改进应用程序。个人资料调查最后一页的文本两侧均添加了内边距，以改善布局。当学习泊坞窗 (Windows) 或学习检查器 (macOS)的探索选项卡中没有与查询词条精确匹配的项目时，您将收到一条消息称应用程序将显示相似的词语或字符。当您在学习泊坞窗 (Windows) 或学习检查器 (macOS)的探索选项卡中搜索菜单命令时，搜索结果现在包括可以用来访问命令的所有相关位置的列表。现在，当您在学习泊坞窗 (Windows) 或学习检查器 (macOS)的探索选项卡中搜索菜单命令时，在用于访问命令的位置列表中，在上下文菜单栏之前会列出菜单栏。当您在学习泊坞窗 (Windows) 或学习检查器 (macOS) 的探索选项卡中搜索菜单命令时，搜索结果现在包括命令的完整路径。在个性化调查的最后一页，您将收到一条信息称应用程序正在根据您的个人资料更新推荐学习资源列表。 性能和稳定性
CorelDRAW Graphics Suite 2022 年 8 月更新（24.1 版）还包括针对客户所报诸多问题的性能和稳定性修复。当您在 EPS 导出对话框的高级选项卡中启用页面选项后，将文件保存为 EPS 格式，然后在 Corel PHOTO-PAINT中打开时，文档现在可以显示为正确的页面大小。当您在 Windows 10 和 Windows 11 上使用 Win+SHIFT+S 快捷键截屏时，现在可以将剪贴板的内容粘贴到CorelDRAW 文档中。当您在 Windows 上导出文件为 EPS 格式时，在应用了合并模式（例如“如果更暗”）且具有透明度的曲线将不再栅格化。JPEG 压缩失真去除功能现在可以正常工作。UsePageBoundingBox 属性已添加到 PDFVBASettings 类中，PDF 导出页面大小设置（PDF 设置 &gt;通用）的脚本功能现在可以正常工作。当在 Windows 上使用 VBA 脚本设置轮廓属性时，CorelDRAW 会按照预期改变轮廓宽度。移动对象时缩放和平移的性能和稳定性问题已得到解决。不需要的非功能性工具和其他命令已从 Windows 上 Adobe Illustrator 工作区中的工具箱中删除。CorelDRAW 现在可以记住您在一次会话中在首选项（CorelDRAW 菜单 &gt; 首选项 &gt; macOS 上的颜色）或选项（工具&gt; 选项 &gt; Windows 上的颜色）对话框中选择的 PANTONE® 调色板。在学习泊坞窗 (Windows) 或学习检查器 (macOS) 中探索选项卡的搜索字段中输入特殊字符，例如 / 和%，再也不会导致“找不到页面”错误。macOS 上的个人资料调查中出现圆角的问题已经得到解决。当使用土耳其语、荷兰语和瑞典语等版本的应用程序时，学习泊坞窗 (Windows) 或学习检查器 (macOS)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5f3175b36db389bfe6eaa2a79944cff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb2a5ff55f7e64619a2adc725a046d3a/" rel="bookmark">
			千峰HTML5&#43;CSS3学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		千峰HTML5+CSS3学习笔记 文章目录 千峰HTML5+CSS3学习笔记写在前面1. 前言2. HTML3. CSS3.1 选择器3.2 CSS属性 4. 盒子模型4.1 溢出属性4.2 元素显示类型4.3 定位4.4 精灵图4.5 宽高自适应4.6 窗口自适应 5. 表单进阶6. HTML5新特性7. CSS3基础7.1 CSS3选择器7.2 伪类选择器7.3 阴影7.4 圆角边框7.5 字体引入7.6 怪异盒模型7.7 弹性盒 8. 移动端布局9. 多列布局10. 响应式布局11. 布局单位12. 渐变13. 动画14. 网格布局15. 杀青 写在前面 学习链接：千锋HTML5前端开发教程1000集：[1集: 183集]，共183集感想 | 摘抄 查询标签在各大浏览器中的兼容问题：caniuse费曼学习技巧：以教促学行内元素转块元素的方法： display: block;position: absolute;float: left; 浮动和绝对定位的区别： float：半脱离，文字环绕absolute：全脱离，不会出现文字环绕效果 伪类和伪元素的区别（:和::的区别）Animate.css动画演示 学习时遇到的问题 1. 前言 居中：&lt;center&gt;居中文字&lt;/center&gt;WEB（网页）的组成部分 HTML结构：W3C制定了机构HTML的语法、标准CSS表现：W3C制定了表现CSS的语法、标准JS行为：W3C、ECMA制定了行为标准（W3C DOM，ECMAScript） 2. HTML 标记
常规标记，双标记空标记，单标记 &lt;!DOCTYPE html&gt;：特殊切固定的文档声明标签
hr：水平线
特殊符号
div标签
没有具体含义，用来划分页面的区域，独占一行。输入div*3 可以直接键入三行div span标签
没有实际意义，主要应用在对于文本独立修饰的时候，内容有多宽就占用多宽的空间距离。 li标签
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb2a5ff55f7e64619a2adc725a046d3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b249b8403af3d1606b591e72c078910f/" rel="bookmark">
			vue上传文件夹的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 功能性需求与非功能性需求
要求操作便利，一次选择多个文件和文件夹进行上传；
支持PC端全平台操作系统，Windows,Linux,Mac
支持文件和文件夹的批量下载，断点续传。刷新页面后继续传输。关闭浏览器后保留进度信息。
支持文件夹批量上传下载，服务器端保留文件夹层级结构，服务器端文件夹层级结构与本地相同。
支持大文件批量上传（20G）和下载，同时需要保证上传期间用户电脑不出现卡死等体验；
支持文件夹上传，文件夹中的文件数量达到1万个以上，且包含层级结构。
支持断点续传，关闭浏览器或刷新浏览器后仍然能够保留进度。
支持文件夹结构管理，支持新建文件夹，支持文件夹目录导航
交互友好，能够及时反馈上传的进度；
服务端的安全性，不因上传文件功能导致JVM内存溢出影响其他功能使用；
最大限度利用网络上行带宽，提高上传速度；
二、 设计分析
对于大文件的处理，无论是用户端还是服务端，如果一次性进行读取发送、接收都是不可取，很容易导致内存问题。所以对于大文件上传，采用切块分段上传
从上传的效率来看，利用多线程并发上传能够达到最大效率。
三、解决方案：
文件上传页面的前端可以选择使用一些比较好用的上传组件，例如百度的开源组件WebUploader，泽优软件的up6，这些组件基本能满足文件上传的一些日常所需功能，如异步上传文件，文件夹，拖拽式上传，黏贴上传，上传进度监控，文件缩略图，甚至是大文件断点续传，大文件秒传。 在web项目中上传文件夹现在已经成为了一个主流的需求。在OA，或者企业ERP系统中都有类似的需求。上传文件夹并且保留层级结构能够对用户行成很好的引导，用户使用起来也更方便。能够提供更高级的应用支撑。
文件夹数据表结构
CREATE TABLE IF NOT EXISTS `up6_folders` (
`f_id` char(32) NOT NULL ,
`f_nameLoc` varchar(255) default '',
`f_pid` char(32) default '',
`f_uid` int(11) default '0',
`f_lenLoc` bigint(19) default '0',
`f_sizeLoc` varchar(50) default '0',
`f_pathLoc` varchar(255) default '',
`f_pathSvr` varchar(255) default '',
`f_pathRel` varchar(255) default '',
`f_folders` int(11) default '0',
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b249b8403af3d1606b591e72c078910f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6348750ff9a2e63d02f7de9d558b5924/" rel="bookmark">
			GPU、CUDA和cuDNN分别是什么，之间又有什么关系？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 GPU、CUDA和cuDNN分别是什么，之间又有什么关系？1. GPU2. CUDA3. cuDNN GPU、CUDA和cuDNN分别是什么，之间又有什么关系？ 1. GPU GPU，图形处理单元（Graphics processing unit），为数据的并行处理而设计，可以更好的进行图形和视频渲染，应用广泛。
GPU的发展是对CPU的补充，CPU被设计用来处理通用任务，具有更为复杂的控制单元。虽然CPU通过架构创新、更快的时钟速度和核心的增可以进行性能提升，但是GPU是专门为加快图像工作负载而设计的，主要用来处理逻辑性不强的大规模数据计算任务，在这方面有着远胜于CPU的优势。
GPU和显卡通常被用来表达同一概念，但是两者之间存在一定的区别。GPU之于显卡，就像CPU之于主板，显卡指的是集成GPU的扩展板，板子上还包括大量的其它部件，既能让GPU运行，又能连接到系统的其它部分。GPU有集成和独立两种类型，集成的GPU是嵌入在CPU旁边，而独立的GPU是单独的芯片，安装在自己的电路板上。
GPU最初被设计用来加速图形的渲染，但是随着时间的推移，GPU变得更加灵活和可编程，可以用其创造出更有趣的视觉效果和逼真的场景。开发人员也开始利用GPU强大的能力来大幅度加速深度学习等领域的计算工作。
2. CUDA CUDA是NVIDIA专门为GPU上通用计算开发的并行计算平台和编程模型。借助CUDA，开发者可以利用GPU的强大性能显著加速计算应用。在经 GPU 加速的应用中，工作负载的串行部分在 CPU 上运行，且 CPU 已针对单线程性能进行优化，而应用的计算密集型部分则以并行方式在数千个 GPU 核心上运行。
也就是说，CUDA是一个并行计算平台，利用这个平台接口，可以高效、灵活的利用GPU的并行计算能力，完成大规模数据计算任务。
3. cuDNN cuDNN是NVIDIA开发的深度神经网络库，一个 GPU 加速的深度神经网络基元库，能够以高度优化的方式实现标准例程（如前向和反向卷积、池化层、归一化和激活层）。
借助cuDNN可以实现高性能 GPU 加速，研究人员和开发者可以专注于训练神经网络及开发软件应用，而不必花时间进行低层级的 GPU 性能调整，也避免了每个使用者都需要自己实现底层的CUDA编程。如果用GPU训练模型，cuDNN也并不是必须的，但是一般会采用这个加速库。cuDNN 可加速广泛应用的深度学习框架，包括 Caffe2、Keras、PaddlePaddle、PyTorch 、TensorFlow等
在明白GPU、CUDA和cuDNN分别是什么之后，三者之间的关系就明晰了
在GPU上进行深度学习开发的过程中，我们利用Pytorch等深度学习框架编写代码，然后深度学习框架依赖cuDNN深度神经网络库，利用CUDA并行计算平台，实现深度学习代码在高性能GPU上的加速运行。可以看作是深度学习框架依赖于cuDNN -&gt; cuDNN依赖于CUDA -&gt; CUDA依赖于GPU。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/299aaf42259720f08328b31594ec6d49/" rel="bookmark">
			多线程之线程同步与协助
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程 1.线程同步 1.1线程同步：多个线程操作同一个资源 并发： 同一个对象被多个线程同时操作
现实生活中，我们会遇到”同一个资源，多个人都想使用”的问题，比如，食堂排队打饭，每个人都想吃饭，最天然的解决办法就是，排队一个个来。 处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象.这时候我们就需要线程同步.线程同步其实就是一种等待机制，多个需要同时访问！此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用。 形成线程安全的条件：队列+锁锁机制【synchronized】
由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可 锁机制存在以下问题： 一个线程持有锁会导致其他所有需要此锁的线程挂起。在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题；如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题 1.2三大不安全案例 1.21 不安全买票代码演示 package threads.demo03; //不安全的买票 //线程不安全，有负数 public class UnsafeBuyTicket { public static void main(String[] args) { BuyTicket bt = new BuyTicket(); new Thread(bt,"牛逼的黑客").start(); new Thread(bt,"可恶的黄牛").start(); new Thread(bt,"傻傻的我").start(); } } class BuyTicket implements Runnable{ //票 private int tikcetNum=10; boolean flag=true; //外部停止方式 @Override public void run() { //买票 while (flag){ try { buytick(); } catch (InterruptedException e) { e.printStackTrace(); } } } void buytick() throws InterruptedException { //判断是否有票 if(tikcetNum&lt;=0){ flag=false; return; } //模拟延时 Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/299aaf42259720f08328b31594ec6d49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99e3a6abf499ef5de7c51e0e60a71311/" rel="bookmark">
			五种常见的聚类算法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、关于聚类的基础描述
1.1 聚类与分类的区别
1.2 聚类的概念
1.3 聚类的步骤
二、几种常见的聚类算法
2.1 K-means聚类算法
1) K-means算法的流程：
2）K-means算法的优缺点及算法复杂度
3）K-means算法的调优与改进
4）K-means算法的python代码实现
2.2 GMM高斯混合模型聚类算法
2.3 Mean shift聚类算法
1）单点mean shift算法基本流程
2）整个数据集的meanshift聚类流程
3）meanshift聚类算法的优缺点及算法复杂度
4）meanshift在图像分割和目标跟踪领域的应用
5）单点meanshift的python代码实现
2.4 基于密度的DBSCAN聚类算法
1）DBSCAN算法的基本概念
2）DBSCAN的基本流程
3）DBSCAN的优缺点及算法复杂度
4）DBSCAN的代码实现
2.5谱聚类spectral clustering
一、关于聚类的基础描述 1.1 聚类与分类的区别 聚类是一种无监督学习，即数据不需要有标签即可。它与分类不同，分类是对有标签的数据进行的，是一种有监督学习。这是两者的区别。（举个例子，一堆人站在这里，没有标签，我们可以采用聚类来对这群人分组，如选取身高这个指标来对他们聚类。而如果是分类，比如男女分，按照每个人的性别标签即可。聚类不需要标签，只要我们自己选择一个指标，按指标来分簇即可。）
1.2 聚类的概念 聚类是按照某个指标（如样本之间的距离）把数据集分割成不同的类或者簇，使类内元素的相似性尽可能的大，类间元素的相似性尽可能小，通过这样来对相似的数据进行归簇，从而达到聚类的效果。
1.3 聚类的步骤 1.数据准备 ： 特征标准化（白化）
2.特征选择 ： 特征降维，选择最有效的特征
3.特征提取： 对选择的特征进行转换，提取出更有代表性的特征
4.聚类： 基于特定的度量函数进行相似度度量，使得同一类数据的相似度尽可能的贴近，不同类的数据尽可能分离，得到各个类的中心以及每个样本的类标签。
5.评估： 分析聚类结果，如距离误差和误差平方和（SSE）等
二、几种常见的聚类算法 2.1 K-means聚类算法 1) K-means算法的流程： 1.随机选取K个中心点
2.遍历数据集里面的每个点，看距离哪个中心点最近就分为哪一类，遍历完一共K类
3.把属于一类的点取平均值，得到的平均值作为新的中心点
4.然后不断重复步骤2，3，直到达到结束条件为止。（当中心点不再变动或变动很小，当达到最大迭代次数）
2）K-means算法的优缺点及算法复杂度 优点：
原理简单，算法复杂度较低
缺点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99e3a6abf499ef5de7c51e0e60a71311/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a73793191d3ab804be7f1d74b65b465/" rel="bookmark">
			手把手开发Admin 系列七（部署篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文档：https://docs.arklnk.com
前端：https://github.com/arklnk/ark-admin-vuenext
后端：https://github.com/arklnk/ark-admin-zero
go-zero：https://go-zero.dev/cn
演示： http://arkadmin.si-yee.com
账号密码备注demo123456演示账号 构建镜像 docker build -f app/core/cmd/api/Dockerfile -t imagesName:version . 应用部署 注：图片来源于go-zero官方文档
项目前期，我们可能不需要太多功能，所以我们可以根据自己的项目需求简化一下部署，
ark-admin核心core模块没用到rpc，只用了api和model。
git clone https://github.com/arklnk/ark-admin-zero.git cd ark-admin-zero docker-compose up -d version: '3' services: ark-admin-zero: image: arklnk/ark-admin-zero:latest container_name: ark-admin-zero volumes: - ./deploy/service/core/etc:/app/etc - ./data/service/logs:/app/logs restart: always networks: - ark_admin_net mysql: image: mysql:5.7 container_name: mysql environment: TZ: Asia/Shanghai MYSQL_ROOT_PASSWORD: root MYSQL_DATABASE: ark_admin ports: - "3306:3306" volumes: - ./data/mysql/data:/var/lib/mysql - ./deploy/sql/:/docker-entrypoint-initdb.d/ privileged: true restart: always networks: - ark_admin_net phpmyadmin: image: phpmyadmin:latest container_name: phpmyadmin restart: always ports: - "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a73793191d3ab804be7f1d74b65b465/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2755c3c05f4d375bc9a477e5b4163318/" rel="bookmark">
			go语言入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 介绍 golang消耗内存少，消耗cpu少，特别适合在k8s里面运行。
工具 goland或者vscode都不错，我倾向于用vscode，因为vscode是开源的免费的。
开始 安装golang创建项目目录，比如myapp在项目目录下执行：`go mod init aaa.com/myapp` （说明：init后面的参数是module path，module path类似java的package name是个虚拟路径）在vscode里面安装golang插件在vscode里面打开项目目录可以写代码调试运行了特别说明一下，我选择了module模式来开发项目。在module模式下代码里`import aaa.com/myapp/packageName`就可以引用本地module。 学习路径 语法基础学习项目标准结构 https://github.com/golang-standards/project-layoutgorm库gin库cron库去网上搜索golang最佳实践的文章看看在github上找golang的流行项目看看动手写个项目 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80d06bd27e25bd9e9b6ed9e447322744/" rel="bookmark">
			又一微信自动化框架wxauto横空出世了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面有一款微信自动化的框架itchat比较火爆，可以实现网页版的微信登录以及完成一系列微信自动化的功能实现。
但是，由于很多用户实际上是不用使用网页版的微信进行登录的，这就造成了很大的限制。今天在论坛上发现了这款不使用网页版登录的框架wxauto同样可以实现自动化的操作。
wxauto，它是在PC客户端直接实现，使得我们操作起来更加的安全、便捷。
1、准备环境
在开始之前我们先来看看若是实现自动化需要什么条件。下面将我的python版本以及操作系统要求列出来。
python 版本：3.8.10
操作系统：windows7
wxauto版本：3.3.5.3
通过pip的安装方式命令进行安装，pycharm默认使用的还是清华大学的镜像站。
pip install wxauto 2、获取聊天内容
准备完成之后，便可以使用wxauto实现自己的自动化功能。为了演示我就以获取我们自己的聊天记录信息来实现自动化。
其他的实现自动化的功能可以自行挖掘，希望大家都可以做出自己的自动化操作工具。欢迎前往我的知识星球进行分享！
# 首先，将wxauto模块导入到我们的代码块中。 from wxauto import * # 初始化我们已经登录的客户端对象WeChat。 wx_cli = WeChat() # 获取当前的客户端的联系人列表。 wx_cli.GetSessionList() # 输出当前所在的聊天窗口的信息。 messages = wx_cli.GetAllMessage for message in messages: print('%s : %s' % (messages[0], messages[1])) # 获取到当前的聊天信息，还可以获取更多，使用LoadMoreMessage函数就可以实现。 wx_cli.LoadMoreMessage() more_messages = wx_cli.GetAllMessage for more_message in more_messages: print('%s : %s' % (more_message[0], more_message[1])) 通过上面的两个python函数的调用我们的小功能就已经实现了，我们是将获取到的信息打印在控制台上面的。
3、测试功能
最重要的环节就是测试功能，我先在PC端将我自己的微信登录好，使用’微信运动’作为我的默认窗口。
这里有两个注意点：
（1）不能将客户端最小化。
（2）不能将客户端缩小到后台运行的小菜单。
因为，如果放到最小化时，它实际上是读取不到客户端的信息的，这点在测试时候需要特别注意。
然后，我直接启动写好的小功能就可以实现读取当前窗口的消息内容，看看效果如何！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adc670d57471c6a662e28ce122255518/" rel="bookmark">
			PAT 1163 Dijkstra Sequence（30）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1163 Dijkstra Sequence 题目代码参考代码复现代码 参考文章注意123 题目 代码 参考代码 // 相等的时候有多种取法, 逐一判断 #include&lt;bits/stdc++.h&gt; using namespace std; int inf = 0x7f7f7f7f; int edge[1100][1100]; int dist[1100]; bool visit[1100]; int main() { fill(edge[0], edge[0] + 1100 * 1100, inf); int nv, ne; cin &gt;&gt; nv &gt;&gt; ne; for(int i = 0; i &lt; ne; i++) { int a, b, weight; cin &gt;&gt; a &gt;&gt; b &gt;&gt; weight; edge[a][b] = edge[b][a] = weight; } //cout &lt;&lt; edge[3][4] &lt;&lt; endl; // 开始判断 int k; cin &gt;&gt; k; for(int i = 0; i &lt; k; i++) { // 记录一下待判断的seq vector&lt;int&gt; v(nv); // 存一下 for(int j = 0; j &lt; nv; j++) cin &gt;&gt; v[j]; //cout &lt;&lt; v[0] &lt;&lt; endl; // 开始判断 // 初始化dist, visit fill(dist, dist + 1100, inf); fill(visit, visit + 1100, false); // 起始点 dist[v[0]] = 0; // 依次检查 bool flag = true; for(int j = 0; j &lt; nv; j++) { // 寻找最小的dist, 判断是否符合 int minn = inf; vector&lt;int&gt; record; for(int k = 1; k &lt;= nv; k++) { if(visit[k] == false) { if(dist[k] == minn) record.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adc670d57471c6a662e28ce122255518/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec695a6c0f34b323ae86c796ee2123d8/" rel="bookmark">
			常见的功能函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文会不定时更新，有需要的随便拿走不谢
一、解析URL参数 解析URL参数在前端开发中是非常常见的功能
const _getParams = (url) =&gt; { // 补全代码 const params=url.split('?')[1].split('&amp;') const obj={} params.forEach(item=&gt;{ obj[item.split('=')[0]]=item.split('=')[1] }) return obj } 二、格式化时间函数 后端返回时间戳，前端显示年月日，时分秒
function formatDate (value) { if (typeof (value) == 'undefined') { return '' } else { let date = new Date(parseInt(value)) let y = date.getFullYear() let MM = date.getMonth() + 1 MM = MM &lt; 10 ? ('0' + MM) : MM let d = date.getDate() d = d &lt; 10 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec695a6c0f34b323ae86c796ee2123d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f7012d9714452192c8f0e3f112207e/" rel="bookmark">
			使用vmware tools压缩Ubuntu虚拟机所占用的空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
虚拟机使用久了，在D盘里的对应文件夹越来越大，并且vmware workstation的“碎片整理”“压缩”功能都没有用太大用处.
解决方法：
压缩磁盘所占据的空间
1.使用df -h 指令可查找到磁盘真实占据的磁盘空间。
（及时清理回收站文件）
2.当虚拟机安装文件夹所剩余的空间大于df -h 显示的磁盘空间占用量时，推荐使用vmware tools清理：
在此之前肯定要先安装vmware tools啦
安装方法：
方法①vmware软件菜单栏直接安装
方法②手动安装
在虚拟机设置中的CD/DVD选项的ISO映像文件中选择VMware安装目录下的Linux.iso文件：
打开虚拟机，在左侧菜单打开VMware tools，选中此目录界面在终端打开
将压缩包复制到其他目录，并解压，进入解压完的目录，sudo运行vmware-install.pl :
安装完毕！
第一次用vmware tools清理的时候报错说虚拟机禁用了磁盘清理，要退出安全模式+删除所有快照+禁用undo disks：
确保您的虚拟机没有暂停并且没有在安全模式下运行。 如果在安全模式下运行，请关闭，然后在尝试压缩。
同时请注意压缩虚拟机磁盘只能在该虚拟机没有快照且禁用Undo disks选项的情况下进行。 若要禁用Undo disks选项：
1. 打开虚拟机菜单或在 Mac 菜单栏（在 Crystal 视图模式下）里按 Alt 并单击（选择单击）Parallels 图标并点击配置。
2. 在虚拟机配置窗口里，进入选项 选项卡并在侧边栏里选择 安全 。
3. 设置Undo disks选项以禁用。
前两个操作（安全模式+删除所有快照）顺利完成，关于如何禁用undo disks（我也不知道是哪个操作生效的，我两个都做了）：
最后输入以下命令即可：
sudo vmware-toolbox-cmd disk wipe / sudo vmware-toolbox-cmd disk shrink / 在宿主机中查看虚拟机文件夹，可以看到所占空间大大减小，和虚拟机中df-h显示的大小差不多了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abde8c68ca05c3820b8fdec4d1670ab7/" rel="bookmark">
			Android四大组件之activity（活动）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、activity简介二、activity知识点1.生命周期2.生命周期示例验证2.activity的启动模式3.activity的启动模式示例1.在 AndroidMainifest 设置2.通过Intent设置1.在 AndroidMainifest 设置的实例 4.activity间的数据传递与回传 前言 本文主要是整理Android四大组件之一的activity的相关知识；
其他相关内容可以跳转至 Android学习与巩固查看
一、activity简介 Activity是Android四大组件之一，主要功能就是实现一个可以让用户与程序交互的窗口。一般来说一个activity表示一个与用户交互的界面；
二、activity知识点 1.生命周期 activity的生命周期代表了一个activity从产生到被销毁的整个流程，包含了七个周期，如图：
1. onCreate()
首次创建 Activity 时调用。在此方法中执行资源绑定，视图创建等静态界面初始化；此时用户不可见。在一个activity的生命周期中只会调用一次。
2. onStart()
当前Activity由用户不可见变为用户可见时调用，但是此时用户还无法进行交互。
3. onResume()
当前Activity状态属于运行状态，此时Activity获得焦点，用户可以与之进行交互。
4.onPause()
当另外一个activity覆盖当前的acitivty时，此时当前activity会进入到onPouse()方法中，当前activity是可见的，但不能与用户交互状态。
5.onStop()
onPouse()方法完成之后，此时activity进入onStop()方法，此时activity对用户是不可见的，但是Activity还未被销毁，在系统内存紧张的情况下，有可能会被系统进行回收。所以一般在当前方法可做资源回收。如果重新启动activity将进入onRestart（）方法
6.onDestroy()
此方法回调时表示Activity被销毁，如果需要重启Activity需要重新新建，绑定资源及从onCreate()开始执行。
7.onRestart()
重新启动已经停止但未被销毁的 Activity 时调用。重新将Activity显示出来。调用顺序onPouse()-&gt;onStop()-&gt;onRestart()-&gt;onStart()-&gt;onResume().
2.生命周期示例验证 新建项目来看看app的各个状态所经历的生命周期；示例代码如下：
MainActivity
public class MainActivity extends AppCompatActivity { private Button btDialog; private Context context; @Override protected void onCreate(Bundle savedInstanceState) { Log.e("MainActivity","onCreate()"); super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); context = this; btDialog = (Button) findViewById(R.id.bt_dialog); btDialog.setOnClickListener(new View.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abde8c68ca05c3820b8fdec4d1670ab7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a177cab0d20df9ab4318e292ba64c6b4/" rel="bookmark">
			Java基础篇——Java运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java运算符按功能可分为：算数运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和条件运算符
目录
算数运算符
关系运算符
逻辑运算符
位运算符
赋值运算符 条件运算符
运算符的优先次序
算数运算符 算术运算符包括通常的加（+）、减（-）、乘（*）、除（/）、取模（%），完成整数型和浮点型数据的算术运算
许多语言中的取模运算只能用于整数型，Java对此做了扩展，它允许对浮点数进行取模操作。例如，3%2 的结果是 1, 15.2%5 的结果是 0.2。取模操作还可以用于负数，结果的符号与第一个操作数的符号相同，例如，5%-3 的结果是 2，-5%3 的结果是-2。
此外，算术运算符还有“++”和“--”两种，分别称为加1和减1运算符。这两种运算符有前缀形式和后缀形式，含有有所不同。例如，i++ 和 ++i 的执行顺序是不一样的，i++ 在 i 使用之后再 +1，++i 在 i 使用之前先 +1。i-- 和 --i 的情况于此类似。
关系运算符 关系运算符用来比较两个值，包括大于（&gt;）、小于（&lt;）、大于等于（&gt;=）、小于等于（&lt;=）、等于（==）和不等于（!=）6种。关系运算符都是二元运算符，也就是每个运算符都带有两个操作数，运算的结果是一个逻辑值。Java允许“==”和“!=”两种运算符用于任何数据类型。例如，既可以判断两个数的值是否相等，也可以判断对象或数组的实例是否相等。判断实例时比较的是两个对象在内存中的引用地址是否相等。
逻辑运算符 逻辑运算符包括逻辑与（&amp;&amp;）、逻辑或（||）和逻辑非（!）。前两个是二元运算符，后一个是一元运算符。Java对逻辑与和逻辑或提供“短路”功能，也就是在进行运算时，先计算运算符左侧的表达式的值，如果使用该值能得到整个表达式的值，则跳过运算符右侧表达式的计算，否则计算运算符右侧表达式，并得到整个表达式的值
位运算符 位运算符用来对二进制位进行操作，包括按位取反（~）、按位与（&amp;）、按位或（|）、异或（^）、右移（&gt;&gt;）、左移（&lt;&lt;）和无符号右移（&gt;&gt;&gt;）。位运算符只能对整数型和字符型数据进行操作。 1. 取反（~）
参加运算的一个数据，按二进制位进行“取反”运算。
运算规则：~1=0； ~0=1；
即：对一个二进制数按位取反，即将0变1，1变0。
2. 按位与（&amp;）
参加运算的两个数据，按二进制位进行“与”运算。
运算规则：0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1；即：两位同时为“1，结果才为“1，否则为0。
例如：3&amp;5 即 0000 0011 &amp; 0000 0101 = 0000 0001 因此，3 &amp; 5的值得1
3. 按位或（|）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a177cab0d20df9ab4318e292ba64c6b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81b80fa02aed94e64361ef54483da3ff/" rel="bookmark">
			性能测试：工具篇：jmeter-命令行使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jmeter命令行使用
jmeter在Windows或macOS启动都会有一个GUI界面的，一般GUI界面都用于脚本的编写和调试。通常对编写好和调试更好的脚本会放在服务器上利用命令来运行。
首先，利用GUI界面编写并调试成功的一个简单的压测脚本，图片如下：
其次，使用命令行模式执行脚本，命令如下：
PS E:\git_code\python-code\jmeterProject&gt; jmeter -n -t .\测试登录.jmx -l report.jtl -e -o report Creating summariser &lt;summary&gt; Created the tree successfully using .\测试登录.jmx Starting standalone test @ Mon Aug 29 17:45:25 CST 2022 (1661766325874) Waiting for possible Shutdown/StopTestNow/HeapDump/ThreadDump message on port 4445 summary = 5 in 00:00:01 = 5.6/s Avg: 32 Min: 22 Max: 40 Err: 0 (0.00%) Tidying up ... @ Mon Aug 29 17:45:26 CST 2022 (1661766326995) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81b80fa02aed94e64361ef54483da3ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0de008960a835775472c2820cdc20f43/" rel="bookmark">
			5G NR LDPC编译码汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.LDPC概述
低密度校验码（LDPC码）是一种前向纠错码，LDPC码最早在20世纪60年代由Gallager在他的博士论文中提出，但限于当时的技术条件，缺乏可行的译码算法，此后的35年间基本上被人们忽略，其间由Tanner在1981年推广了LDPC码并给出了LDPC码的图表示，即后来所称的Tanner图。1993年Berrou等人发现了Turbo码，在此基础上，1995年前后MacKay和Neal等人对LDPC码重新进行了研究，提出了可行的译码算法，从而进一步发现了LDPC码所具有的良好性能，迅速引起强烈反响和极大关注。经过十几年来的研究和发展，研究人员在各方面都取得了突破性的进展，LDPC码的相关技术也日趋成熟，甚至已经开始有了商业化的应用成果，并进入了无线通信等相关领域的标准。
LDPC码是一种分组码，其校验矩阵只含有很少量非零元素。正是校验矩阵的这种稀疏性，保证了译码复杂度和最小码距都只随码长呈现线性增加。除了校验矩阵是稀疏矩阵外，码本身与任何其它的分组码并无二致。其实如果现有的分组码可以被稀疏矩阵所表达，那么用于码的迭代译码算法也可以成功的移植到它身上。然而，一般来说，为现有的分组码找到一个稀疏矩阵并不实际。不同的是，码的设计是以构造一个校验矩阵开始的，然后才通过它确定一个生成矩阵进行后续编码。
译码方法是LDPC码与经典的分组码之间的最大区别。经典的分组码一般是用ML类的译码算法进行译码的，所以它们一般码长较小，并通过代数设计以减低译码工作的复杂度。但是LDPC码码长较长，并通过其校验矩阵H的图像表达而进行迭代译码，所以它的设计以校验矩阵的特性为核心考虑之一。
总结一下：
LDPC编码从本质上是一种线性分组码，与经典的线性分组码相比的不同之处在于：
(1)LDPC通过构造校验矩阵H实现
(2)LDPC采用迭代译码算法
(3)LDPC码没有固定的结构
LDPC校验矩阵需满足如下要求：
(1)稀疏性：即校验矩阵中含有极少数量的1
(2)行列约束(R-C)：任意两行或两列同为非零元素的元素个数不超过1
2.LDPC校验矩阵的图形表示——Tanner图
Tanner图是一种二部图，其中的节点可分为两部分
(1)校验节点(约束节点)——CN
(2)变量节点(比特节点)——VN
当校验矩阵中的元素不为0时第i个校验节点与第j个比特节点相连接
每个校验节点与一个校验方程相对应
每个变量节点与一个编码比特相对应
由校验矩阵生成对应Tanner图举例如下：
3.非规则LDPC校验矩阵的引入——度分布多项式
非规则LDPC校验矩阵：列数与列重的比值不等于行数与行重的比值
由于非规则LDPC校验矩阵的上述性质，为衡量其对应Tanner图的各对应节点度的分布情况（若为规则码，各节点度满足均匀分布）引入度分布多项式。从边的角度来说：
4. 5G-NR中LDPC编码方法
(1)BG选择
根据TBS大小（记作A）及码率（记作R）确定LDPC基本图（BaseGraph，BG）选择和TB-CRC的长度。BG1适用于长码块高码率。BG2适用于短码块低码率。细节参照协议TS 38.212-7.2.1。
(2)LDPC校验矩阵获取
5. LDPC译码 LDPC独特的消息传递译码算法是其区别于一般的线性分组码的主要方面，也正是这样的译码方法，使得在即使码长很长的情况下，其译码算法的复杂度仍在可控的范围内。而且，码长越长，其译码算法的性能越好。由此，为讲清楚消息传递译码算法，首先就需要知道其传递的“消息”究竟是什么。
1)外信息传递
为了讲清外信息传递的概念，首先思考这样的问题：
在上图中所示的士兵排列网络中，每个士兵只能与其相邻的士兵互通消息。那么通过怎样的消息传递方式才能使所有士兵得知士兵的总人数？
我们很容易想到通过“报数”的方法解决，当士兵排成一排时，从士兵队列的两端同时报数，每个人将从两个方向得到的士兵数加1传到另一端。如此一来，每个士兵知道了它的两端各有多少人，也就知道了士兵的总数。
其实上图中已经使用了“外信息”的思想。因为对于每个士兵而言，其最终得到的士兵数量信息是“6”，而他向其他士兵传递消息时，传递的数值为其已知的总信息减去目标士兵向他传递的信息。由此，每个士兵相当于向其相邻的士兵传递了“外信息”。
当士兵排列的拓扑发生变化时，该方法同样适用，如下图：
在上图中，每个士兵得到的最终士兵数量信息为“8”，而任意一个士兵向其他士兵传递消息时，其数值相当于“外信息”。
但是，当网络中有“环“存在时，该消息传递方法会出现问题，如下图所示：
可以看出，当消息在右端的环中传播时，其数值会无限地增长下去，造成消息传递的错误，这也是LDPC校验矩阵设计时，尽量避免产生“环“的原因
总结起来，通过外信息传递的方法，可以使一个分布式网络中的每个节点得知整个网络中的一些信息。反过来讲，当消息传递完成时，等效于整个网络将它的信息传递给了每个节点。
2)外信息传递译码器
若将上述问题中的每个士兵换成一个个级联的译码器，将各士兵间传递的“士兵数量”消息改变为各变量节点的“LLR信息”，那么这就是消息传递译码的大体结构。下图所示为每两个级联的译码器间传递消息的示意图：
3)LDPC的SPA译码器
LDPC的SPA算法是一种典型的以外信息传递为核心的译码算法
LDPC编码中，由于校验矩阵与tanner图对应关系的引入，各校验节点与变量节点可以看作级联的译码器，其中每个变量节点可以看作一个REP(重复码)的译码器(因为多个校验节点为一个变量节点提供信息)，其示意图如下所示：
而对于每个校验节点，则相当于一个SPC(单奇偶校验码)码译码器，其示意图如下图所示：
总结：在SPA算法中，所有VN对其输入进行处理，并将外信息传递给它们相邻的校验节点，然后校验节点对其输入进行处理，并将外信息传递给与它们相邻的变量节点；从变量节点开始，重复这个过程，直到达到最大迭代次数或者满足某个准则进行及计算判决。
在SPA译码器的推导中，内在最优准则是基于符号的最大后验概率（MAP）准则，当图上的环较大时，估计非常精确，可达到近似最优（MAP）性能。另外，SPA的演进基于独立性假设：每个节点从它的相邻节点接收到的LLR都是独立的。显然，当迭代次数超过Tanner图中围长的一半时，这种独立性假设不成立。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59069e92256ce53d43f632460d0938cf/" rel="bookmark">
			读取服务器文件，并进行移动-ChannelSftp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要求：
读取服务器上某个目录的文件下的txt的内容，读取里面的数据，进行处理，保存入库。保存后，把文件移到该目录下的bak目录。
处理：
要操作服务器文件，需要使用 ChannelSftp，文档
常用方法： put()： 文件上传
get()： 文件下载
cd()： 进入指定目录
ls()： 得到指定目录下的文件列表
rm()： 删除指定文件
rename() 移动文件
java代码： 引用： gradle: // 添加sftp的工具包 implementation group: 'com.jcraft', name: 'jsch', version: '0.1.55' maven: &lt;dependency&gt; &lt;groupId&gt;com.jcraft&lt;/groupId&gt; &lt;artifactId&gt;jsch&lt;/artifactId&gt; &lt;version&gt;0.1.55&lt;/version&gt; &lt;/dependency&gt; 业务 CustomerService @Slf4j @Service public class CustomerService { public void readFile() throws SftpException { SftpConfig sftpConfig = SftpUtils.getSftpConfigVal(); ChannelSftp sftp = SftpUtils.connect(sftpConfig); String path = sftpConfig.getPath(); String newpath = path + "/bak"; // 判断文件路径是否存在 SftpUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59069e92256ce53d43f632460d0938cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bfbcaf1b03b812b9d4b076a114c11c9/" rel="bookmark">
			socket.io常见用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		io.on('connect', onConnect);
function onConnect(socket){
// 只发给sender。 sending to the client
socket.emit('hello', 'can you hear me?', 1, 2, 'abc');
// 发给所有人，除了sender。 sending to all clients except sender
socket.broadcast.emit('broadcast', 'hello friends!');
// 发给game房间所有人，除了sender。 sending to all clients in 'game' room except sender
socket.to('game').emit('nice game', "let's play a game");
// 发给game1和/或game2所有人，除了sender。 sending to all clients in 'game1' and/or in 'game2' room, except sender
socket.to('game1').to('game2').emit('nice game', "let's play a game (too)");
// 发给game房间所有人，包含sender。 sending to all clients in 'game' room, including sender
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bfbcaf1b03b812b9d4b076a114c11c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fde424fe2880b6053ba22bbba90e6ff8/" rel="bookmark">
			前端如何使用hutool生成的sm2公私钥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 后台可以通过使用hutool中的SmUtil类动态生成公钥私钥，将公钥私钥提供给前端进行加解密，前端基于sm-crypto依赖，可以通过sm2.doDecrypt和sm2.doRecrypt方法进行加解密，介绍在网上很多，再此不过多赘述。
SmUtil生成的公钥私钥拼接了一些其它数据，在前端无法直接使用，需要进行一定的转化，数据的加解密也需要做处理。
解密方式如下代码所示：
// 后台Sm2Util类返回的私钥字符串 const privateKeyBySm2Util = "XXXXXXXXXXXXXXXXXXXXXXX"; // 后台返回的加密数据 const dataByEncrypt = "XXXXXXXXXXXXXXXXXXXXXXX" // 前端真正可用的基于后台生成的私钥 const privateKey = privateKeyBySm2Util.split("047930770201010420")[1].split('a00a')[0] // 前端真正可用的基于后台生成的加密数据 const dataByKey = dataByEncrypt.substring(2,dataByEncrypt.length).toLowerCase() // 解密出来的数据 const data = sm2.doDecrypt(dataByKey, privateKey, 1) 加密方式如下代码所示：
// 后台Sm2Util类返回的公钥字符串 const publicKeyBySm2Util = "XXXXXXXXXXXXXXXXXXXXXXX"; // 待加密数据 const data = "XXXXXXXXXXXXXXXXXXXXXXX" // 前端真正可用的基于后台生成的公钥 const publicKey = publicKeyBySm2Util.split("034200")[1] // 加密的数据 const dataByEncrypt = sm2.doEncrypt(data, publicKey, 1) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f0c144a64f9466221ac58573bacd44c/" rel="bookmark">
			【论文阅读】Semi-supervised classification with graph convolutional networks
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文地址：[1609.02907] Semi-Supervised Classification with Graph Convolutional Networks (arxiv.org)
引言 图神经网络GCN旨在解决的问题是“图中节点的分类问题，且数据集只有一小部分的节点有标签”，称之为“graph-based semi-supervised learning”。
这类问题在GCN之前的一种解决方法用如下公式表示：
这里的 L0是指有标签的那部分节点的分类损失，而 Lreg 是指对于没有标签的节点来讲，根据相邻节点的相似性，限制模型在无标签节点上的输出与和它相邻节点上的输出接近（ Aij 是邻接矩阵的元素）。这是个很强的假设，许多实际情况并不是这样的，因此GCN旨在消除这个显式的图正则化限制。
公式 GCN的方式是直接将图中节点的连接关系A（邻接矩阵）作为模型的输入直接参与计算，而不是像上面那个方法那样“稍微有些隐晦地利用”。
GCN的层之间的递推公式如下：
Hl~ 是神经网络第l层的激活输出， H0~ 就是 X （各个节点的值组成的矩阵）；
Wl 是可学习的权重矩阵；
A~=A+I ，是邻接矩阵再加上自连接，对角线元素从0变为1，表示每个节点和自身是连接着的；
D~ 是节点的度矩阵， Dii=∑j Aij ，代表与节点i直接连接的节点数（包括此节点自身）。
至于这个公式的来源，论文有提到推理过程，出发点是“图傅里叶变换、图卷积”，经过各种各样的简化（包括为了减少计算复杂度用切比雪夫多项式大致估算并做截断、利用神经网络尺度可学习的特性假设矩阵的最大特征值为2等），就得到了上述公式。
图傅里叶变换、图卷积我并不了解，是通过博客Dwzb：图傅里叶变换大致有了些了解，可参考。
GCN网络 损失的计算只在有标签的那部分节点上计算，不考虑无标签节点的输出。
此外，网络的输入中邻接矩阵A是在层与层的推进中是不变的（这与我之前的一个误解有关，我之前以为图神经网络是一种可以学习并输出图的连接结构的网络，这个假设导致刚开始看的时候总是理解不了，后来才醒悟GCN并不是为了学习图结构而设计，图结构必须是预先就知道并作为网络的输入。GCN不具备学习图结构的能力，只是对利用图结构更好更准确地对节点进行分类，解决的是分类问题。）
相关工作、实验、结果、讨论 （还没看）
工程实践用 作者公开了GCN的源码，地址：tkipf/pygcn: Graph Convolutional Networks in PyTorch (github.com)
一些带讲解的博客：
CODE 01: GCN on Pytorch - 知乎 (zhihu.com)
(1条消息) pytorch框架下—GCN代码详细解读_MelvinDong的博客-CSDN博客_gcn代码
此外，好像有一些与图数据、模型等相关的库，如Pytorch-Geometric、NYU的DeepGraphLibrary等，是从博客(1条消息) [PyG] 1.如何使用GCN完成一个最基本的训练过程(含GCN实现)_sooner高的博客-CSDN博客_gcn训练里看到的，以后有时间我要去学习了解下，说不定在用到的时候能省不少事。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6efeac59a5dd832f99d08f0b97896c3f/" rel="bookmark">
			爱奇艺视频wasm转js分析，cmd5x算法脱离环境限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爱奇艺视频wasm转js分析，cmd5x算法脱离环境限制 1.js代码扣取2.ast反混淆，平坦流3.脱离环境与调用 1.js代码扣取 文献1：XX视频H5解析分析过程
文献2：爱奇艺视频cmd5x解析算法的移植分析和实现（2019-08）
本篇文章建立在上面两篇文章的前提下，所以部分已经提到过的内容，就不再重复叙述
首先直接过滤视频信息接口
可以看到来自于pcweb.wonder.js，打开这个js
搜索【vf=】，只有一个结果，在生成之前下一个断点，重新加载网页。断点断下后可以看到，【r】参数是由【cmd5x】方法的得到，参数就是视频url的一部分。
进入cmd5x方法后，可以看到这个是webpack打包的js，使用了里面的第295个方法。那先把这个js下载，然后扣出来本地先测试一下。
在一般的webpack前面还有一段其他的函数，先手动删除，然后用之前的一键扣webpack来测试一下
非常漂亮，没有报错，跑一下导出函数是否正常
可惜报错了，这里出现了document，那么直接上jsdom。
可以出结果了，难道就这么简单？经过测试发现，生成的值和浏览器的不一样，这就是被检测node环境了
2.ast反混淆，平坦流 不着急，接下来单独把295的整个函数体拿出来调试
可以看到一开始有一个大数组，明显的ob混淆特征，用ast先去掉这个混淆看看
这时字符串都被还原回去了，但是还有很多了类似【“jxnRC” !== “fsFmd”】这样恒真或者恒假的代码，把这也处理一下
这时逻辑就更加清晰了，但是还有一些代码是在break或者return后面，是一定不会执行的废代码，也一起去掉吧
这时分析就更加方便了
通过上图可以确定，这个其实就是调用的wasm，但是网页并没有加载wasm文件，也没有把文件在写js中，哪里来的wasm呢？
实际上这个js是把wasm转换成了js，所有的逻辑都用js来完成
通过fd替换js文件后可以发现，js调用【cmd5x】方法实际就是调用的是【g】方法，这里的【g】方法应该理解成一个js层的方法
下面就可以分析出这个方法内部的逻辑，这里需要一个wasm调用的基本知识
1.首先是计算参数url的长度
2.然后申请申请长度+1的内存空间（因为字符串是以字节0结尾的，需要把这个算上）
3.然后把参数url复制到内存，然后调用【f】方法计算，这里的【f】应该理解为wasm层的方法
4.计算完成后释放之前申请的参数url的内存
5.然后把cmd5x计算的结果从内存中读出来，最后把这个计算结果的内存也释放掉
这里的重点明显就是这个【f】的函数了
wasm层的cmd5x函数绑定的是【ca】这个函数
但是【ca】函数这个控制流太恐怖了，有170+个case，直接分析明显是不明智的
3.脱离环境与调用 这里有一个点是，实际我们可以不分析这个【ca】函数，因为我们之前试过计算vf，是因为被检测了node的环境。但是wasm又无法直接操作BOM和DOM，如果wasm中要检测环境，这是一定要通过导入函数，才能进行检测的。所以，可以先分析一下调用到的所有导入函数。
这里的【bL】就是导入函数，就是参数的【b7】，也就是上面的【aI、L、M、aU、aV、aY、aX、aQ】
查看各个函数后发现，除了【aU】这个函数，其他都是非常短的，没有出现检测点
【aU】这个函数非常长，还有控制流，并且存在明显的检测点，所以这时应该分析的是这个函数。首先还是尝试使用ast去除控制流。过程稍微有点长，就不详细叙述
去除了控制流后，分析就简单很多，可以很明显的看出检测的地方。在我调试的时候，就发现了其中的秘密。我替换网页的js后发现，当环境检测正确时，这个函数的返回值必定是6，否则就会得出和浏览器不一致的结果。所以可以直接进行以下的修改
function aU() { return 6; } 此时再运行js可以发现，结果就和网页的一模一样了
js调用方法
const t = require('./295_decrypt'); const vf = t.cmd5x('/dash?tvid=114869400&amp;bid=300&amp;vid=eac5b7e5c7d6c471a6635725f0173fdc&amp;src=01010031010000000000&amp;vt=0&amp;rs=1&amp;uid=1626142844&amp;ori=pcw&amp;ps=0&amp;k_uid=49c360579e9a7cf874d599de913c6bff&amp;pt=0&amp;d=0&amp;s=&amp;lid=&amp;cf=&amp;ct=&amp;authKey=b66ff0001e1568368db1f0827830ffeb&amp;k_tag=1&amp;ost=0&amp;ppt=0&amp;dfp=a11d64e2e196534268a0b9ab3908bffd86cec25e335c3269344667023b08b60afe&amp;locale=zh_cn&amp;prio=%7B%22ff%22%3A%22f4v%22%2C%22code%22%3A2%7D&amp;pck=4aT95ShhWNgoEXxVzhFwU28qb6fXgiMIWS7d3DjB1t2KBKGj8m1Npt3LUz3KQauw35i99&amp;k_err_retries=0&amp;up=&amp;qd_v=2&amp;tm=1637337797663&amp;qdy=a&amp;qds=0&amp;k_ft1=706436220846084&amp;k_ft4=1162183859249156&amp;k_ft5=262145&amp;bop=%7B%22version%22%3A%2210.0%22%2C%22dfp%22%3A%22a11d64e2e196534268a0b9ab3908bffd86cec25e335c3269344667023b08b60afe%22%7D&amp;ut=1'); console.log(vf); python调用方法
首先安装依赖库 pip install node_vm2
def get_vf(url): from node_vm2 import NodeVM with open('295_decrypt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6efeac59a5dd832f99d08f0b97896c3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95ed7ded6e7ac8010bd6415e7d34ed45/" rel="bookmark">
			CentOS7开启ssh服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开启ssh服务 1.先检查有没有安装ssh服务：rpm -qa | grep ssh
2.如果没有就安装openssh-server：yum install openssh-server
3.查看并修改ssh配置：vim /etc/ssh/sshd_config
ssd_config是sshd服务的配置文件，可在其中配置参数，登陆用户等，文件位置位于/etc/ssh/sshd_config，这里可以直接通过vi（不会vi编辑的自己查）命令打开文件进行主要参数的配置(把对应参数前面的警号去掉就可以了)：
（1）、Port 22，sshd服务的端口
（2）、Protocol 2，也就是外部连接的协议用ssh2，当然如果不设置也可。
（3）、PermitRootLogin no/yes,如果允许使用root登陆则设为yes,否则为no
（4）、PasswordAuthentication no/yes，no为不允许使用密码登陆，yes为允许使用密码登陆，一般如果用自己账户登录都用密码，所以这一项最好设为yes，否则会导致window中能ping通linux系统，但是ssh连接不上。
设置好后保存退出。
注：需要的vi命令如下：
vi /ect/ssh/sshd_config //打开文件 按i键 //进入vi编辑模式，能够更改文件 esc //编辑完文件后按esc退出编辑模式 shift+: //可以输入退出命令 q! //退出不保存 wq //退出并保存 4、启动ssh服务：/bin/systemctl start sshd.service
systemctl restart sshd.service //重启命令 systemctl start sshd.service //启动命令 5、检查ssh服务是否开启：ps -e | grep sshd
6、检查 22端口 是否开启：netstat -ntlp | grep 22
7、将ssh服务添加到自启动列表中：systemctl enable sshd.service
注：如果系统开启了防火墙，想要访问ssh，还要通过下一步开放ssh（22）端口
二、开启防火墙 由于CentOS7防火墙默认的是firewall，网上许多人说改成iptables（如果是用iptables的自己配置）。
首先，我们查看ssh所用的端口是否已经打开，这里我已22端口为例：
firewall-cmd --state //查看防火墙是否打开，打开为running firewall-cmd --zone=public --query-port=22/tcp //端口如果开放则为yes,否则为no 如果22端口没有开放，我们可以用以下两种方法解决：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95ed7ded6e7ac8010bd6415e7d34ed45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5ad6a3e2e070e5bd392e1dbb8cfce19/" rel="bookmark">
			（附源码）springboot学生宿舍管理系统 毕业设计 211955
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
科技进步的飞速发展引起人们日常生活的巨大变化，电子信息技术的飞速发展使得电子信息技术的各个领域的应用水平得到普及和应用。信息时代的到来已成为不可阻挡的时尚潮流，人类发展的历史正进入一个新时代。在现实运用中，应用软件的工作规则和开发步骤，采用java技术建设学生宿舍管理系统。
本设计主要实现集人性化、高效率、便捷等优点于一身的学生宿舍管理系统，完成首页、用户管理（管理员、学生、宿管人员）更多管理（宿舍信息、宿舍报修、宿舍分配、宿舍通知）等功能模块。系统通过浏览器与服务器进行通信，实现数据的交互与变更。本系统通过科学的管理方式、便捷的服务提高了工作效率，减少了数据存储上的错误和遗漏。学生宿舍管理系统使用Java语言，采用基于 MVVM模式的spring boot技术进行开发，使用 Eclipse 2017 CI 10 编译器编写，数据方面主要采用的是微软的SQLserver数据库来作为数据存储媒介，配合前台HTML+CSS 技术完成系统的开发。
关键词 ：学生宿舍管理系统；java技术；Mysql数据库；
Abstract
The rapid development of scientific and technological progress has caused great changes in people's daily life. The rapid development of electronic information technology has popularized and applied the application level of electronic information technology in various fields. The advent of the information age has become an irresistible fashion trend, and the history of human development is entering a new era.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5ad6a3e2e070e5bd392e1dbb8cfce19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6adf92b464548083b2e7429ee409b330/" rel="bookmark">
			如何从API中获取数据（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、执行一个请求。通过以上的内容学习，现在是时候去请求一些显示在RecyclerView上的真正的数据。我们将会使用OpenWeatherMap API来获取数据，还有一些普通类来现实这个请求。多亏Kotlin非常强大的互操作性，比如可以用Retrofit来执行服务器请求。点击测试
当只是执行一个简单的API请求，我们可以不使用任何第三方库来简单地实现。而且，Kotlin提供了一些扩展函数来让请求变得更简单。首先，我们要创建一个新的Request类：我们的请求很简单，就是接收一个url，然后读取结果并在logcat上打印json。实现非常简单，因为我们使用readText，这是Kotlin标准库中的扩展函数。这个方法不推荐用于返回结果很大的响应，但是在这个例子中使用没有一点问题。
如果你用这些代码去比较Java，你会发现我们仅使用标准库就节省了大量的代码。比如HttpURLConnection、BufferedReader和需要达到相同效果所必要的迭代结果，管理连接状态、reader等部分的代码。很明显，这些就是场景背后函数所作的事情，但是我们却不用关心。
二、在主线程以外执行请求。我们都知道HTTP请求不被允许在主线程中执行，否则它会抛出异常。这是因为阻塞住UI线程是一个非常差的体验。Android中通用的做法是使用异步任务AsyncTask，但这个也有不少缺陷。如果你使用不小心，AsyncTasks会非常危险，因为当运行到postExecute时，如果Activity已经被销毁了，这里就会崩溃。Anko提供了非常简单的DSL来处理异步任务，它满足大部分的需求。它提供了一个基本的async函数用于在其它线程执行代码，也可以选择通过调用uiThread的方式回到主线程。在子线程中执行请求如下这么简单：
UIThread有一个很不错的一点就是可以依赖于调用者。如果它是被一个Activity调用的，那么如果activity.isFinishing()返回true，则uiThread不会执行，这样就不会在Activity销毁的时候遇到崩溃的情况了。
点击获取测试key和secret
测试结果展示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf75e846e18abd85a2fa3df2ef5356a7/" rel="bookmark">
			用C语言API(常用)操作MySql数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		连接数据库的步骤 MySql数据库是一个典型的C/S结构，包括客户端和服务器。当部署好了MySql服务器，想通过程序访问服务端的数据，在编写程序的时候，可以通过官方提供的C语言API来实现。
在程序中连接MySql服务器主要分为以下几个步骤：
初始化连接环境连接MySql服务器。需要提供如下连接数据： MySql服务器IP地址MySql服务器监听端口。默认是3306连接MySql服务器使用的用户名(默认是root)和对应用户的密码。需要操作的数据库名字连接已经建立，后续操作就是对数据库数据进行增删查改。 这些操作都需要通过sql语句来完成。数据的查询：通过调用api指定一个查询语句数据的修改(增/删/改)：通过调用api来执行修改数据的sql语句如果要进行事务的处理 需要对执行的结果进行判断。 成功：提交事务失败：数据回滚查询数据进行数据库的读操作，得到数据的结构集。遍历结构集，得到查询的数据。释放资源。 MySql C语言API 初始化数据库 MYSQL* mysql_init(MYSQL* mysql) 参数：mysql填写null
返回值：返回一个MYSQL初始化的新对象地址。可以用该指针来连接MySql服务器，并操作对应数据库。如果没有足够内存分配新对象，返回NULL。
实际是用结构体对MySql数据库进行描述，实例化并初始化该类型的对象，在内存中开辟空间。
连接MySql数据库 MYSQL* mysql_real_connect( MYSQL* mysql, //mysql_init()函数返回值 const char* host, //mysql服务器主机地址，写IP地址即可 //localhost，null 代表本地连接 const char* user, //连接mysql服务器的用户名，默认root const char* passwd, //对应用户名的密码 const char* db, //要操作的数据库名 unsigned int port, //连接的mysql服务器监听的端口 //==0使用默认端口3306， const char* unix_socket, //本地套接字，不使用指定为NULL unsigned long client_flag//通常指定为0 ); 作用：连接对应ip主机上对应端口的mysql服务。
返回值：
成功：返回MYSQL*连接句柄，与函数的第一个参数值相同。指向同一块空间。
失败：返回NULL
执行sql语句 int mysql_query(MYSQL* mysql, const char* query); 参数：
mysql：mysql_real_connect()返回值
query：增删查改的sql语句，结尾不需要加 ';'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf75e846e18abd85a2fa3df2ef5356a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0a38b25e4db7cf89c545bb4270efda8/" rel="bookmark">
			Springboot内置Tomcat线程数测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot 2.7.3
本文主要介绍SpringBoot内置Tomcat的主要参数，解析最大线程数和最大连接数的作用方式。SpringBoot各版本的参数配置可能不完全一样，本文以2.7.3版本为例进行试验。
一、默认配置 SpringBoot内置Tomcat的配置存放在 spring-configuration-metadata.json 文件中，配置以 server.tomcat 开头
最小线程数
# 最小工作空闲线程数，默认10 server.tomcat.threads.min-spare=10 最大线程数
# 最大工作线程数，默认200 server.tomcat.threads.max=200 最大连接数
# 最大连接数默认是8192 server.tomcat.max-connections=8192 队列长度
# 等待队列长度，默认100 server.tomcat.accept-count=100 二、测试各参数的作用 1、准备测试接口 import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * Tomcat测试类 * * @author Administrator * @date 2022/8/28 */ @RestController @RequestMapping("/tomcat") public class TomcatController { /** * localhost:8080/tomcat/getString * * @return */ @RequestMapping("/getString") public String getString() { try { // 将线程挂起3秒，方便观察结果 Thread.sleep(3000); } catch (InterruptedException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0a38b25e4db7cf89c545bb4270efda8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2745a61b7219720df348c72035364fc0/" rel="bookmark">
			clickhouse centos7安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：
安装 | ClickHouse Docs
[root@node2 local]# cd clickhouse/ [root@node2 clickhouse]# ll 总用量 0 [root@node2 clickhouse]# ll 总用量 0 [root@node2 clickhouse]# sudo yum install -y yum-utils 已加载插件：langpacks, product-id, search-disabled-repos, subscription-manager This system is not registered with an entitlement server. You can use subscription-manager to register. base | 3.6 kB 00:00:00 docker-ce | 3.5 kB 00:00:00 docker-ce-stable | 3.5 kB 00:00:00 extras | 2.9 kB 00:00:00 updates | 2.9 kB 00:00:00 (1/3): docker-ce-stable/x86_64/primary_db | 81 kB 00:00:00 (2/3): docker-ce/x86_64/primary_db | 81 kB 00:00:01 (3/3): updates/7/x86_64/primary_db | 17 MB 00:00:29 软件包 yum-utils-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2745a61b7219720df348c72035364fc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bbcfb880dc1257ed2ae65a56faa2bd0/" rel="bookmark">
			超好看的个人主页官网源码&#43;带动态特效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 正文: 这款个人主页源码感觉是我有史以来见过最好看的，功能和页面也比较多，简约又不失格调。
官网带动态特效视频源码，修改主页文件即可。
程序: wwvwd.lanzouw.com/i6RWe0ag8gde
图片: 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/020f99e5b58e13b73efd8fc0047e8e1c/" rel="bookmark">
			21、前端开发：CSS知识总结——transform变形属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、属性定义 Transform属性应用于元素的2D或3D转换。这个属性允许你将元素旋转，缩放，移动，倾斜等。可以改变元素的形状或位置，不会影响到页面的布局。
2、语法 transform: none|transform-functions;
值描述none定义不进行转换。matrix(n,n,n,n,n,n)定义 2D 转换，使用六个值的矩阵。matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)定义 3D 转换，使用 16 个值的 4x4 矩阵。translate(x,y)定义 2D 转换。translate3d(x,y,z)定义 3D 转换。translateX(x)定义转换，只是用 X 轴的值。translateY(y)定义转换，只是用 Y 轴的值。translateZ(z)定义 3D 转换，只是用 Z 轴的值。scale(x[,y]?)定义 2D 缩放转换。scale3d(x,y,z)定义 3D 缩放转换。scaleX(x)通过设置 X 轴的值来定义缩放转换。scaleY(y)通过设置 Y 轴的值来定义缩放转换。scaleZ(z)通过设置 Z 轴的值来定义 3D 缩放转换。rotate(angle)定义 2D 旋转，在参数中规定角度。rotate3d(x,y,z,angle)定义 3D 旋转。rotateX(angle)定义沿着 X 轴的 3D 旋转。rotateY(angle)定义沿着 Y 轴的 3D 旋转。rotateZ(angle)定义沿着 Z 轴的 3D 旋转。skew(x-angle,y-angle)定义沿着 X 和 Y 轴的 2D 倾斜转换。skewX(angle)定义沿着 X 轴的 2D 倾斜转换。skewY(angle)定义沿着 Y 轴的 2D 倾斜转换。perspective(n)为 3D 转换元素定义透视视图。 扩展：水平垂直居中（宽高位置的情况下） position：absolute；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/020f99e5b58e13b73efd8fc0047e8e1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96f3b686bdfcd036285a86a49f22323e/" rel="bookmark">
			MVC, MVP, MVVM比较以及区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MVC, MVP和MVVM都是用来解决界面呈现和逻辑代码分离而出现的模式。以前只是对它们有部分的了解，没有深入的研究过，对于一些里面的概念和区别也是一知半解。现在一边查资料，并结合自己的理解，来谈一下对于这三种模式思想的理解，以及它们的区别。欢迎各位高手拍砖。
阅读目录:
一. MVC, MVP, MVVM诞生的需求?
二. 一段典型的耦合代码
三. MVC模式
3.1 主动MVC
3.2 被动MVC
3.3 Web应用中的MVC框架
3.4 MVC总结
一，MVC, MVP, MVVM诞生的需求? 软件中最核心的，最基本的东西是什么? 是的，是数据。我们写的所有代码，都是围绕数据的。
围绕着数据的产生、修改等变化，出现了业务逻辑。
围绕着数据的显示，出现了不同的界面技术。 没有很好设计的代码，常常就会出现数据层(持久层)和业务逻辑层还有界面代码耦合的情况。
ORM等框架，解耦合了业务逻辑和数据之间的耦合，业务逻辑不再关心底层数据如何存储和读取。所有数据呈现给业务逻辑层的就是一个个的对象。
而MVC, MVP, MMVM用来解决业务逻辑和视图之间的耦合。
二，一段典型的耦合代码 { SqlDataAdapter adapter = new SqlDataAdapter("select * from Table1","server=.;database=db;uid=sa;pwd=password"); DataSet ds = new DataSet("ds1"); adapter.Fill(ds); this.GridView1.DataSource = ds; this.GridView1.DataBind(); } 上面的这段代码中，既包含了数据访问，还包含的页面展示。当项目复杂程度更高，这种代码就会变得非常难以维护，层次也不清晰。
三，MVC模式 MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写。MVC开始是存在于桌面程序中的，M是指业务模型，V是指用户界面，C则是控制器，使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式
3.1 主动MVC MVC的理论思想对应的是主动MVC, 这里的主动的意思是, Model会主动通知View更新。而我们使用MVC框架, Struts, asp.net mvc等都不是主动MVC(视图的更新都是通过Controller完成的)
Model
用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。
模型中数据的变化一般会通过一种刷新机制被公布。为了实现这种机制，那些用于监视此模型的视图必须事先在此模型上注册，从而，视图可以了解在数据模型上发生的改变。
View
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96f3b686bdfcd036285a86a49f22323e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88e6ece949bea7f76e40ba825e0260cb/" rel="bookmark">
			Jmeter如何做响应断言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先新建测试计划-文件-新建
二、创建线程组-在测试计划-右击-添加-线程组用户-线程组
三、在线程组底下添加取样器http请求-在线程组-右击添加-取样器-HTTP请求
四、给HTTP请求注释一下这个http的请求是干嘛用的
五、再HTTP请求添加响应断言（右击HTTP请求-选择添加-断言-响应断言）
六、在HTTP请求里面添加请求的url，域名，端口，协议
七、响应断言的属性说明
八、例子-对百度的请求-响应的文本进行断言-可在响应断言里面添加多个预期结果
九、添加查看结果树-线程组-右键-添加-监听器-察看结果树
十、运行-在查看结果树中查看断言结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a4dc301b81d1baed4456a011d543682/" rel="bookmark">
			Vue 如何将封装好的UI组件库打包发布到npm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、目录调整二、更改配置项三、vue.js插件四、导入测试五、打包六、发布到npm 一、目录调整 根目录创建两个文件夹packages和examples packages：用于存放所有的组件（把components中所有的组件放入到packages中），该文件夹主要用于打包发布。
examples：用于进行测试（这里是把src改成examples）。
二、更改配置项 更改目录结构后，vue项目是无法启动的，此时需更改配置项。
在根目录下新建文件vue.config.js，配置内容如下： const path = require('path'); module.exports = { lintOnSave: false, pages: { index: { // 修改项目入口文件 entry: 'examples/main.js', template: 'public/index.html', filename: 'index.html', }, }, // 扩展webpack配置，使packages加入编译 // 高版本js语法转为低版本 chainWebpack: config =&gt; { config.module .rule('js') .include.add(path.resolve(__dirname, 'packages')) .end() .use('babel') .loader('babel-loader') .tap(options =&gt; { // 修改它的选项 return options; }); }, }; 三、vue.js插件 上诉中提到packages文件夹是用于打包发布的，但是如何将该文件夹打包发布呢？此时需要了解vue.use(plugin)。这里不做太多说明，可自行翻阅官方文档。具体实现如下。
在packages文件夹下新建index.js文件，该文件作为整个包的入口文件，内容如下： // 定义 install 方法，接受 Vue 作为参数，如果使用 use 注册插件，则所有的组件都将被注册 // 导入组件 import Button from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a4dc301b81d1baed4456a011d543682/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c5dc1e7c60d9132872f84830a8e0f60/" rel="bookmark">
			简单易懂CDN 的技术原理！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源公众号：计算机网络工程师
来源链接 https://mp.weixin.qq.com/s/0g67mC-G-DvG9JBdr8hnMQ
对于 CDN 这个东西，相信大家都有耳闻，感觉既陌生但又熟悉。最近深入了解了一下 CDN，这才发现原来它如此重要！今天就跟大家分享下关于 CDN 的那些事儿。
浏览器的网络请求 要理解 CDN 这件事情，我们就得先理解浏览器发出一个请求的过程是怎样的，其整体过程如下图所示。
1.用户在浏览器中输入要访问的网址域名。
2.浏览器向本地 DNS 服务器请求对域名的解析。
3.如果本地 DNS 服务器有域名的解析结果，那么直接响应用户请求，返回该域名对应的 IP 地址。
4.如果本地 DNS 服务器没有域名的解析结果，那么则会递归地向 DNS 系统请求解析，随后将该结果返回给用户。
5.浏览器得到域名解析结果后，其实也就是域名对应的 IP 地址。
6.随后浏览器向服务器请求内容。
7.服务器将用户请求内容返回给浏览器。
通过这么复杂的步骤，用户就可以看到页面内容了。但实际上，在第 6、7 这两步的时候，其中间也经过了非常复杂的过程。为了更清晰地表述，我们可以将这个过程分为 3 个主要节点，如下图所示。
网站服务器通过公网出口，再通过长途骨干网，最后通过用户的宽带广猫到达用户所在的局域网，最终才到达用户电脑的浏览器。
其中长途骨干网的传输是最为耗时的，它需要经过网站服务器所在的机房、骨干网、用户所在城域网、用户所在接入网等，其物理传输距离非常遥远。
在这种情况下，如果传输的数据非常多，访问的用户特别大，那么就会出现很长的延时，影响用户体验。同时，每请求一次数据都需要经过漫长的数据传输，对于长途骨干网来说，都是一次负担。
刚刚说的这个场景，很形象的一个例子是春节抢票的场景。当我们春节抢票时，我们都会登陆 12306 网站，网站上肯定有不少图片资源。这时候可能同时会有 1 个亿的人，同时去请求一张一模一样的图片。
这时候如果我们都按照上面的过程去请求一次图片数据，那么将会产生 1 亿次的网络数据传输，这对于我们整个国家的互联网基础设施是个灾难啊！
但事实情况是：12306 貌似也没有挂掉呀！
那么他们是如何解决这个问题呢？答案就是：CDN！
什么是 CDN ？ 其实 CDN 就是内容分发网络的意思，其英文全称为 Content Delivery Network。简单地说，CDN 可以提前把数据存在离用户最近的数据节点，从而避免长途跋涉经过长途骨干网，最终达到减少骨干网负担、提高访问速度的目的。
按照我们上面的场景，如果没有 CDN 的话，每次请求都需要从网站服务器经过公网出口、长途骨干网、用户接入局域网，最终到达浏览器。但是当有了 CDN 之后，可能就变成了下面这样：
浏览器请求图片数据时，会先去 CDN 缓存服务器获取。如果获取到数据，那么就直接返回。否则才会经过长途骨干网，最终到达网站服务器获取图片数据。那么只要我们提前在 CDN 缓存服务器上传图片，那么我们就可以极大地减少网络流量，同时减少网络延迟。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c5dc1e7c60d9132872f84830a8e0f60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d24761ce119681d2175094f784a9d99e/" rel="bookmark">
			QT之XML文件解析DOM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt之XML文件解析(DOM) XML简介 ​ 和HTML的语法很相似，但不同之处在于： HTML 被设计用来显示数据，其关注的是数据的外观，XML 被设计用来传输和存储数据，其关注的是数据的内容，因此，XML主要用来作为数据的存储和共享。
​ XML文档是一种树的结构，从根部扩展到枝叶。以下是一个XML示例
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;root&gt; &lt;!--写入矩形图元的信息--&gt; &lt;class name="Rect"&gt; &lt;object name="obj1"&gt; &lt;x1&gt;10&lt;/x1&gt; &lt;y1&gt;10&lt;/y1&gt; &lt;x2&gt;50&lt;/x2&gt; &lt;y1&gt;50&lt;/y1&gt; &lt;linewidth&gt;2&lt;/linewidth&gt; &lt;scale&gt;0&lt;/scale&gt; &lt;rotate&gt;0&lt;/rotate&gt; &lt;/object&gt; &lt;/class&gt; &lt;/root&gt; 其中第一行 是XML 声明。它定义 XML 的版本和所使用的编码格式，&lt;root&gt; &lt;/root&gt;为根节点的起始（在XML中可以自定义节点名称），&lt;class&gt; &lt;/class&gt;为子元素，其中name为其属性，值为Rect；每一个子元素都可以拥有子元素，故class的子元素为object，依次类推； 所有的元素都可以有文本内容和属性，如x1的文本为10，x2的文本为50。
DOM类介绍 Classes说明QDomAttr表示 QDomElement 的一个属性QDomCDATASection表示 XML CDATA 部分QDomCharacterData表示 DOM 中的通用字符串QDomComment表示 XML 注释QDomDocument表示一个 XML 文档QDomDocumentFragmentQDomNodes 树，不是完整的QDomDocumentQDomDocumentTypeDTD 在文档树中的表示QDomElement表示 DOM 树中的一个元素QDomEntity表示一个 XML 实体QDomEntityReference表示 XML 实体引用QDomImplementation有关 DOM 实现的功能的信息QDomNamedNodeMap包含可以按名称访问的节点集合QDomNodeDOM 树中所有节点的基类QDomNodeListQDomNode 对象列表QDomNotation表示 XML 表示法QDomProcessingInstruction表示 XML 处理指令QDomText表示解析的 XML 文档中的文本数据 其相关继承关系如下：
一个XML文档如果只做保存数据使用，那么以下XML的构成就足够使用了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d24761ce119681d2175094f784a9d99e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00601a4e0f70326aa0c8b8b7a7cd296b/" rel="bookmark">
			关于宏`uvm_info和$display的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、$display $display可以直接打印一条文本信息，并在每一次$display执行后会自动换行，比如：
`timescale 1ns/1ns module test_tb(); initial begin $display("I am display1"); $display("I am display2"); end endmodule 打印结果：
I am display1
I am display2
2、`uvm_info `uvm_info的功能与$display语句的功能相似，但比display更加灵活，以下是`uvm_info的格式：
`uvm_info("A","I am uvm_info",UVM_LOW) `uvm_info有以下三种格式：
`uvm_info("TRACE",$sformatf("%m"),UVM_HIGH)`uvm_info("TRACE",$sformatf("port_id value of %0d",port_id),UVM_HIGH)`uvm_info("TRACE",{"\n",req.sprint()},UVM_HIGH) 第一个参数是字符串，用于把打印的信息归类。第二个参数也是字符串，是具体需要打印的信息，第三个参数则是冗余级别。冗余级别为UVM_LOW,表示信息非常关键，冗余级别为UVM_HIGH，表示信息可有可无，UVM_MEDIUM介于这两者之间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f78e1cbbef1dbf2c32a802028d3b390/" rel="bookmark">
			Windows常用快捷键与查询命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows快捷键
1. Win
Win # 开始 Win + Tab # 时间轴 Win + T # 切换Tab Win + A # 操作中心 Win + D # 清屏 Win + E # 快速访问 Win + F # 反馈中心 Win + I # Windows设置 Win + K # 连接 Win + L # 锁屏 Win + M # 关闭所有 Win + P # 投影 Win + Q | S # 打开搜索（cmd右击以管理员身份运行） Win + R # 运行 Win + U # 设置 Win + V # 粘贴板 Win + W # 笔和windows link设置 Win + X # 开始菜单 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f78e1cbbef1dbf2c32a802028d3b390/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21a3fc4fae5ee8443e2ff256697ceb67/" rel="bookmark">
			深入解析MySQL分区（Partition）功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		= 水平分区（根据列属性按行分）=
举个简单例子：一个包含十年发票记录的表可以被分区为十个不同的分区，每个分区包含的是其中一年的记录。
水平分区的模式：
Range（范围） – 这种模式允许DBA将数据划分不同范围。例如DBA可以将一个表通过年份划分成三个分区，80年代（1980’s）的数据，90年代（1990’s）的数据以及任何在2000年（包括2000年）后的数据。
Hash（哈希） – 这种模式允许DBA通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如DBA可以建立一个对表主键进行分区的表。
Key（键值） – Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。
List（预定义列表） – 这种模式允许系统通过DBA定义的列表的值所对应的行数据进行分割。例如：DBA建立了一个横跨三个分区的表，分别根据2004年2005年和2006年值所对应的数据。
Composite（复合模式） - 很神秘吧，哈哈，其实是以上模式的组合使用而已，就不解释了。举例：在初始化已经进行了Range范围分区的表上，我们可以对其中一个分区再进行hash哈希分区。
垂直分区（按列分）：
举个简单例子：一个包含了大text和BLOB列的表，这些text和BLOB列又不经常被访问，这时候就要把这些不经常使用的text和BLOB了划分到另一个分区，在保证它们数据相关性的同时还能提高访问速度。
分区表和未分区表试验过程
*创建分区表,按日期的年份拆分
复制代码
复制代码
mysql&gt; CREATE TABLE part_tab (
c1 int default NULL,
c2 varchar(30) default NULL,
c3 date default NULL
) engine=myisam
PARTITION BY RANGE (year(c3)) (PARTITION p0 VALUES LESS THAN (1995),
PARTITION p1 VALUES LESS THAN (1996) , PARTITION p2 VALUES LESS THAN (1997) ,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21a3fc4fae5ee8443e2ff256697ceb67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/607327000e12b33b3afe4f1a9b1f96a1/" rel="bookmark">
			UVM—virtual sequencer and virtual sequence详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、前言
2、virtual sequencer使用环境
3、 virtual sequencer 和virtual sequence的作用
4、m_sequencer与p_sequencer
4.1 m_sequencer
4.2 p_sequencer
5、实例
1、前言 在UVM里Sequence层次化这一块是重点，这里主要介绍virtual sequence。 对于顶层的测试环境， 测试序列所要协调的不再只是面向一个sequencer的sequence群，而是要面向多个sequencer的sequence群， 面向不同sequencer的sequence群如何挂载到不同的sequencer上呢？ 这就需要用到virtual sequence和virtual sequencer来解决。对于单一的sequencer下的sequence群，其挂接较为简单，通过uvm_sequence::start()来挂载root sequence，而在内部的child sequence可以通过宏`uvm_do()来实现。
2、virtual sequencer使用环境 考虑到环境的可扩展性，一般会在一开始生成环境的时候就把virtual sequencer给加上。即使暂时用不到，也比以后再去加的要好。而且目前的验证环境大部分是脚本生成的，加virtual sequencer其实也不存在什么额外的工作量 。
使用条件：
环境中只有一个driver agent，此时不需要virtual sequencer；环境中有多个driver_agent，但是这些driver之间不需要同步，此时不需要virtual sequencer；环境中有多个driver_agent，且这些driver之间需要同步，此时需要virtual sequencer。 3、 virtual sequencer 和virtual sequence的作用 virtual sequence：承载不同目标sequencer的sequence群落，实现sequence同步；virtual sequence一般只会挂载到virtual sequencer上，且没有自己的sequence_item,只用于控制其他的sequence执行顺序，起统一调度作用。virtual sequencer：桥接其它sequencer，即连接所有底层sequencer的句柄(指针)，是一个中心化的路由器。virtual sequencer本身并不传送item数据对象，因此不需要与driver进行TLM连接。所以用户需在顶层的connect阶段做好virtual sequencer中各个sequencer句柄与sequencer实体对象的一一连接，避免句柄悬空。 virtual sequencer和(real) sequencer都继承自uvm_sequencer；
virtual sequence 和(real) sequence 都继承自uvm_sequence；
virtual sequence/sequencer的virtual主要是指这种sequence/sequencer不像直接作用在具体driver上的sequence/sequencer，它不处理具体的transaction，主要是来做不同类型sequence间的控制和调度的。
4、m_sequencer与p_sequencer 4.1 m_sequencer 当我们使用宏`uvm_do或者xxx_seq.start(sqr)方法启动sequence后（当sequence和sequencer关联后），sequence内部自有的m_sequencer句柄就自动地指向了对应的sequencer上了。这个操作是start()方法内部实现的，对用户不可见，因此一般我们都不会直接去操作m_sequencer变量。事实上，uvm中直接以'm_'开头的变量都不应该直接被用户使用。
但通过m_sequencer不能直接使用seqr里的变量，否则会出现编译错误。只能使用cast强制向子类转换后，才能通过m_sequencer.xxx来访问该seqr内的xxx变量。
4.2 p_sequencer 与m_sequencer变量作用相反，p_sequencer变量就是为了方便用户而提供的。p_sequencer变量需要用户使用宏`uvm_declare_p_sequencer去定义和设置。
`uvm_declare_p_sequencer宏一般在sequence的内部使用，主要完成以下两件事情：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/607327000e12b33b3afe4f1a9b1f96a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f15455b1de2ce9c5146dc2d9ac77ee94/" rel="bookmark">
			vue3 elementui-plus的input框点击弹窗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 需求 点击如图input框：
出现如图选择器弹框：
2. 踩坑 我尝试了获取焦点时的方法@focus，但是每次在点击弹框的“确定”按钮后，input框都会自动聚焦，弹框又自动出现了，我就想通过blur()方法主动失焦，但是失败了：
2.1 获取ref元素 2.2 获取ref结果 按理来说，我可以打印出input框元素，但是不知道哪里出现了问题，ref始终为null，麻烦知道的朋友评论告诉我一下TAT
3. 解决方式 既然无法通过ref来主动失焦，那我就直接给input框添加点击事件，不通过焦点来控制弹窗的显示了，之前想的太复杂了，直接用@click就可以了…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a42b7598d93f2bfc104d73b03d39ec66/" rel="bookmark">
			使用easyexcel将图片批量写入excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class Tupian { public static void main(String[] args) throws MalformedURLException { String fileName = "E:\\image.xlsx"; String path = "D:\\2022\\1022\\"; File file = new File(path); System.out.println(file.isDirectory()); ArrayList&lt;ImageData&gt; list = new ArrayList&lt;&gt;(); File[] files = file.listFiles(); for (File image : files) { // System.out.println(image.getName()); if(image.getName().endsWith(".jpg")){ // list.add(image); ImageData imageData = new ImageData(); imageData.setUrl(new URL("file:/D:\\2022\\1022\\"+image.getName())); list.add(imageData); } // } EasyExcel.write(fileName, ImageData.class).sheet().doWrite(list); } public static void test01() throws MalformedURLException { //生成excel的路径 String fileName = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a42b7598d93f2bfc104d73b03d39ec66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cf2be3d9e48b31d0822f18c69bc230a/" rel="bookmark">
			springboot中使用配置文件解耦合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、前言 今天在做项目的时候，写一个无session登录拦截以及部分页面放行的功能时，使用的传统方法，当配置项过多、并且这些配置项以后可能会更改，这种传统的方式将所有的配置项都写死在了java类中，感觉耦合度非常高，所以我就想：能不能对这种方式做一些优化？我想了很多种方案，不断尝试，例如使用注解注入配置文件的方式，我试了以下几种注解注入，结果要不就是报一堆异常，要不就是不能达到目的：
@ImportResource("classpath:ListUrl.yml") @PropertySource("classpath:ListUrl.yml") @ConfigurationProperties("whitelist") @EnableConfigurationProperties(LoginFilterConfig.class) 最后，功夫不负有心人，我找到了一种堪称完美的方式：使用springboot配置文件+Data赋值注入的方式，实现解耦合！
（我也将它记录到了我的个人网站：https://doublepeach.gitee.io，欢迎来访！）
再介绍我这种方式之前，先给大家看看传统的方式完成登录拦截和放行功能的写法：
1、传统写法 （1）定义一个拦截器，并实现HandlerInterceptor并配置拦截条件以及页面跳转 （2）定义过滤器类，并实现WebMvcConfigurer接口中的addInterceptors 手动创建List集合，并将放行的页面的字符串一个个添加到list中
完成 这样就使用传统的方式完成了登录拦截和部分页面放行的功能，但这种方式从代码上看，很明显的一个缺陷就是设置放行页面时，代码耦合度太高，将来某一天想取消放行或增加额外的放行页面时，还需要修改java源代码。
所以我想到了使用配置文件的方式，将这些放行页面的路径字符串添加为springboot的list集合配置项，然后在java代码中注入该集合，实现配置文件的读取。 将来修改放行页面时直接在配置文件中改，这样不就耦合度大大降低了吗？
下面说说今天的主角：
2、配置文件的方式 （1）配置拦截器，这步同上，没有变化 （2）springboot主配置文件声明放行页面的配置项 这里一定要注意List集合在yml配置文件中的书写方式
- 与 list元素之间有空格！
（3）配置拦截器 ***注解作用以及原理解释： - 使用Lombok中的@Data注解进行属性的赋值注入
- 添加了@Configuration注解后，此类会被spring容器标记为配置类，springboot会将其主配置文件application.yml中的配置项与此类中的属性进行”按名对应“，并通过Set方法注入（此步使用@Data自动完成）
- @ConfigurationProperties注解设置配置项的前缀
完成 这样，优化后的这种读取配置文件的方式实现登录拦截放行功能就完成了，相比传统的那种，不仅代码更简洁，而且耦合度更低，代码更易于修改维护管理，以后遇到类似的可以使用配置文件解耦合的地方可以经常使用！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3256d287e179e4b83d46e1ff27bad93d/" rel="bookmark">
			用python自动出小学加减法程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 朋友们大家好，今天我给大家带来的内容是：用python做自动出题程序。
这个程序可以随机出两位数加减法的程序。
先看代码：
import time import random ops=['+','-'] random.shuffle(ops) ops1=ops[0] numbers=1 numbers1=0 while True: add1=random.randint(1,99) add2=random.randint(1,99) ops1=ops[0] eq=str(add1)+ops[0]+str(add2) val=eval(eq) if add1-add2&lt;0: continue print('第',numbers,'题') time.sleep(1) print(add1,ops1,add2,'=') ask=int(input('答案是几：')) if ask==val: print('恭喜你，答对了') print() numbers+=1 random.shuffle(ops) else: print('答错了，正确答案是',val) print() numbers+=1 random.shuffle(ops) 来看看效果：
可以看到，程序自动出了几道两位数加减法的题目，只要输入正确的答案，程序就会告诉你你答对了。
好了，本文章的内容就到这里，感谢观看！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/489dbd024863626fb8f5ada3226fa04c/" rel="bookmark">
			Xmodem operation was canceled by remote peer问题已解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Xmodem operation was canceled by remote peer.
传输的时候就会出现注意的问题
2.使用df -h命令查看内存状况，可以发现root已经满了。
3.进入根目录，ls显示，使用rm命名将其中的文件删除
4.显示，可以看见内存占用变少。
5.最后传输文件，可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5da8b19ebdf9ef7ff6671f82d996f283/" rel="bookmark">
			Java 导出Excel利用模版导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java导出Excel和word的方式大体相同 1、Excel模版导出到页面下载 首先，导入依赖在pom.xml中我选择的事1.03的版本 第二、在项目或是自己需要的地方建立个文件夹放导出文件的模版，并且配好模版 第三，controller层写入export方法，这里我写的没有将可以作为工具的部分单独写一块而是直接写在controller的方法中这样更直观，并且是使用注解的方式进行的项目配置 @RequestMapping("/export") private void export(Queryable queryable, PropertyPreFilterable propertyPreFilterable, HttpServletRequest request,HttpServletResponse response) throws Exception { //根据系统的需要获取数据源 List&lt;Model&gt; resultList = pagejson.getResults(); //获得模版 String tempFileName = request.getSession().getServletContext().getRealPath("/excelTemplate"); //将结果放入这个list中 List values = new ArrayList(); Map beans = new HashMap(); Date date = new Date(); SimpleDateFormat simpl = new SimpleDateFormat("yyyyMMddHHmmss"); String currntTime = simpl.format(date); tempFileName += "/policyDemo.xls"; //导出列表名 String fileName = currntTime+"列表.xls"; values.addlist); beans.put("values", values); //文件名称统一编码格式 fileName = URLEncoder.encode(fileName, "utf-8"); //生成的导出文件 File destFile = File.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5da8b19ebdf9ef7ff6671f82d996f283/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34bf0e676a415b434146624a13f0c7b9/" rel="bookmark">
			vue-element-admin-master框架结合element UI 组件 权限的问题以及element 组件使用中遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线预览
https://github.com/PanJiaChen/vue-element-admin/blob/master/README.zh-CN.md （总连接）
使用文档
一、权限问题 1.settings.js 文件
1.showSettings: false,//右边设置 是否关闭 2.tagsView: false,导航栏是否关闭 3.fixedHeader: false, 4.sidebarLogo: true,左边菜单顶部是否显示标题和logo 2.登录逻辑 权限控制 代码分析
A. permission.js 是权限控制的 （其实就是路由拦截器）登录逻辑
import router from './router' import store from './store' import { Message } from 'element-ui' import NProgress from 'nprogress' // progress bar一个进度条的插件 import 'nprogress/nprogress.css' // progress bar style import { getToken } from '@/utils/auth' // get token from cookie import getPageTitle from '@/utils/get-page-title' NProgress.configure({ showSpinner: false }) // NProgress Configuration 是否有转圈效果 const whiteList = ['/login', '/auth-redirect'] // no redirect whitelist 没有重定向白名单 router.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34bf0e676a415b434146624a13f0c7b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61de31ac373e18f3b451d5ceca32a54f/" rel="bookmark">
			【例4-3】利用数组，给定N个正整数数据（N＜=100），查找最大值和最小值并输出。【输入输出样例】Input length (N＜=100):（此处括号、冒号为英文符号，后面无空格；leng
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【例4-3】利用数组，给定N个正整数数据（N&lt;=100），查找最大值和最小值并输出。
【输入输出样例】
Input length (N&lt;=100):（此处括号、冒号为英文符号，后面无空格；length和左括号间有空格）
6
8 10 13 1 23 7
The max is 23
The min is 1（此处输出结束不换行，is后面有一个空格）
（20.0分）
参考答案：
#include&lt;stdio.h&gt;
#define N 100
int main()
{
int i,n,max=0,a[N],min=0;
printf("Input length (N&lt;=100):\n");
scanf("%d",&amp;n);
for(i=0;i&lt;n;i++)
{
scanf("%d",&amp;a[i]);
}
max=a[0];
for(i=1;i&lt;n;i++)
{
if(a[i]&gt;max)
max=a[i];
}
printf("The max is %d\n",max);
min=a[0];
for(i=1;i&lt;n;i++)
{
if(a[i]&lt;min)
min=a[i];
}
printf("The min is %d",min);
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e03a44c7b03bc69fdc1cc689bd23721/" rel="bookmark">
			JS——利用JS实现简易留言板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、成果图二、使用步骤 1.需求解析2.HTML结构3.CSS样式4.JS行为总结 一、成果图 二、使用步骤 1.需求解析 实现留言板的基本功能
提交留言——用户输入留言（当输入内容为空时，提示用户，且不可提交留言），输入完成后点击提交留言，留言列表中将会出现对应用户输入的内容，且留言列表第一条应该时用户最新提交的内容与当日日期统计输入字数——输入框下方也会自动统计用户输入的字数，当输入字数大于一定长度时，提示用户且不可提交留言删除留言——当用户提交留言后，每一条留言后会出现删除按钮用于删除本条留言记录 2.HTML结构 &lt;!-- 外部容器 --&gt; &lt;div class="wrapper"&gt; &lt;!-- 内部容器 --&gt; &lt;div class="inner"&gt; &lt;!-- 输入留言区域 --&gt; &lt;textarea name="student" id="student" cols="40" rows="10"&gt;&lt;/textarea&gt; &lt;!-- 统计文本域中的字数 --&gt; &lt;p id="text"&gt;已输入字数： &lt;span id="text-now"&gt;0&lt;/span&gt;/100 &lt;/p&gt; &lt;!-- 提交留言按钮 --&gt; &lt;input type="button" id="btn" value="提交留言"&gt; &lt;p&gt;留言列表&lt;/p&gt; &lt;!-- 呈现留言区域 --&gt; &lt;ul&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; 3.CSS样式 &lt;style&gt; body { background-color: #f4f4f4; } /* 外部容器样式设置 */ .wrapper { width: 400px; height: 500px; background-image: url(../img/689334441.jpg); background-size: contain; border-radius: 15px; opacity: .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e03a44c7b03bc69fdc1cc689bd23721/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05ff56a07c79e73d037d15c9457d5282/" rel="bookmark">
			SpringBoot多数据源及事务解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个主库和N个应用库的数据源，并且会同时操作主库和应用库的数据，需要解决以下两个问题：
如何动态管理多个数据源以及切换？如何保证多数据源场景下的数据一致性（事务）？ 本文主要探讨这两个问题的解决方案，希望能对读者有一定的启发。
2. 数据源切换原理 通过扩展Spring提供的抽象类AbstractRoutingDataSource，可以实现切换数据源。其类结构如下图所示：
targetDataSources&amp;defaultTargetDataSource
项目上需要使用的所有数据源和默认数据源。
resolvedDataSources&amp;resolvedDefaultDataSource
当Spring容器创建AbstractRoutingDataSource对象时，通过调用afterPropertiesSet复制上述目标数据源。由此可见，一旦数据源实例对象创建完毕，业务无法再添加新的数据源。
determineCurrentLookupKey
此方法为抽象方法，通过扩展这个方法来实现数据源的切换。目标数据源的结构为：Map&lt;Object, DataSource&gt;其key为`lookup key。
我们来看官方对这个方法的注释：
lookup key通常是绑定在线程上下文中，根据这个key去resolvedDataSources中取出DataSource。
根据目标数据源的管理方式不同，可以使用基于配置文件和数据库表两种方式。基于配置文件管理方案无法后续添加新的数据源，而基于数据库表方案管理，则更加灵活。
3. 配置文件解决方案 根据上面的分析，我们可以按照下面的步骤去实现：
定义DynamicDataSource类继承AbstractRoutingDataSource，重写determineCurrentLookupKey()方法。配置多个数据源注入targetDataSources和defaultTargetDataSource，通过afterPropertiesSet()方法将数据源写入resolvedDataSources和resolvedDefaultDataSource。调用AbstractRoutingDataSource的getConnection()方法时，determineTargetDataSource()方法返回DataSource执行底层的getConnection()。 其流程如下图所示：
3.1 创建数据源
DynamicDataSource数据源的注入，目前业界主流实现步骤如下：
在配置文件中定义数据源
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource spring.datasource.driverClassName=com.mysql.jdbc.Driver # 主数据源 spring.datasource.druid.master.url=jdbcUrl spring.datasource.druid.master.username=*** spring.datasource.druid.master.password=*** # 其他数据源 spring.datasource.druid.second.url=jdbcUrl spring.datasource.druid.second.username=*** spring.datasource.druid.second.password=*** 复制代码 在代码中配置Bean
@Configuration public class DynamicDataSourceConfig { @Bean @ConfigurationProperties("spring.datasource.druid.master") public DataSource firstDataSource(){ return DruidDataSourceBuilder.create().build(); } @Bean @ConfigurationProperties("spring.datasource.druid.second") public DataSource secondDataSource(){ return DruidDataSourceBuilder.create().build(); } @Bean @Primary public DynamicDataSource dataSource(DataSource firstDataSource, DataSource secondDataSource) { Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;(5); targetDataSources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05ff56a07c79e73d037d15c9457d5282/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba2ba40e3f7fb72a8749fa2eef03ce56/" rel="bookmark">
			ZYNQ DDR读写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 很不错的一篇文章，mark一下： 使用Xilinx SDK对Zynq的PCIE，SRIO等高速接口进行调试的过程中，经常会涉及到DMA对DDR数据的读写，此时就会引入会引入cache一致性问题。Zynq的PS在运行过程中，通过DDR控制器对DDR存储器进行访问，为了加快访问速度，常常将一些数据缓存在cache中，而且不是针对一个数据数据缓存，而是一批(Xilinx称为一行，即line，一行长度为32)，这样的好处是下次访问速度会加快，但是坏处也很明显，cache数据发生变化，不能马上反映到DDR中，反之亦然。当通过DMA修改DDR数据时，CPU可能还不知道发生了什么，拿到的数据还是cache中没有修改的数据，导致读写数据的错误。
解决的办法有以下两种：
调试过程中，直接禁用cache，即使用Xil_DCacheDisable()；CPU将直接访问DDR内存，读写都是直接的，这会降低CPU性能，但简化了数据传输操作，属于极端方法。使用CacheFlush和Cache Invalidate操作，CacheFlush把Cache里的数据清空，将Cache内容推到DDR中；而Cache Invalidate表示当场宣布Cache内容无效，需要从DDR中重新加载数据，即把数据从DDR中拉到Cache中。 #include "xil_cache.h" //将内容刷新至DDR(写数据后） Xil_DcacheFlushRange((u32)sendram,sizeof(buffer)); //将DDR内容拉近Cache中（读数据前） Xil_DcacheInvalidRange((u32)recvram,sizeof(buffer)); 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/131/">«</a>
	<span class="pagination__item pagination__item--current">132/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/133/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>