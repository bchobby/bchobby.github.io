<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e310755132b8f84bb11c96064231fd08/" rel="bookmark">
			C&#43;&#43; 十大数组排序（冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简单总结： 1.冒泡排序：不断把大的往后移一步，排序终点随着循环往前移；
2.选择排序：维护排序起点，把最小挑出来放前面；
3.插入排序：维护排序起点，从链表起点开始找插入位置，把小的往前插；
4.希尔排序：可以理解为分组的插入排序，按增长量作为分组的依据，将一定间隔的数据分为一组进行插入排序，不断减小增长量，重复插入排序的操作，直到增长量为1；
5.归并排序：先递归对数组进行二分，直到每一组只剩一个元素(绝对有序)，再进行有序数组的合并；
6.快排排序：将最左边的节点作为参照数(传统快排)，双指针，右指针负责找比参照数小的节点，左指针负责不断将大于参照数的节点与快指针节点进行值交换（注意这里一定要右指针先动，否则可能遇到参照数刚好为最大元素，左指针一直找不到大于参照数的数值，参照数没有被正确交换到数组尾部）；
7.堆排序：建立一个大顶堆，不断的将堆顶的元素与数组末端的元素交换位置，关键在于维护堆性质的函数heapify C++自建堆
8.计数排序：设立一个大小为数组最大值的数组count(n)，记录count[num]，通过计数累计和的方式定位原数组中每个元素在排序数组的位置
9.桶排序：根据数组的值域区间设定桶数量和桶大小，将每个元素根据大小放到对应的桶上面，在桶内使用快速排序，最后合并每个排序好的桶
10.基数排序：结合了计数排序和桶排序的思想，从个位开始，按照数字的每一位进行0-9的桶排序，桶合并采用计数累计和的思想确认桶内元素合并后的位置
二、代码及注释 #include &lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; void printArray(vector&lt;int&gt;&amp;nums) { for (const int&amp; num : nums) { cout &lt;&lt; num &lt;&lt; ' '; } cout &lt;&lt; endl; } // 冒泡排序 void bubbleSort(vector&lt;int&gt;&amp;nums) { int n = nums.size(); for (int i = 0; i &lt; n; ++i) { // 每次循环把最大的数换到n-i-1的位置 for (int j = 1; j &lt; n-i; ++j) { if (nums[j - 1] &gt; nums[j]) swap(nums[j], nums[j - 1]); } } } // 选择排序 void selectSort(vector&lt;int&gt;&amp; nums) { int n = nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e310755132b8f84bb11c96064231fd08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57a7f38a65711e7ef31f29392a6eda5a/" rel="bookmark">
			为华生物PCL-MPEG 聚己内酯甲氧基聚乙二醇的简介和应用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		甲氧基聚乙二醇聚己内酯（mPEG-PCL）可以作为各种药物的载体材料。应用于医药研究、药性缓释、纳米新材料研究、细胞培养，在取用时，从冰箱取出之后，放置于干燥处让其缓慢升至室温，现配现用，取用完之后充入惰性气体，及时放入低温环境，长期保存需放入-20℃干燥避光存放。
甲氧基聚乙二醇-聚己内酯（mPEG-PCL）是一种嵌段共聚物，一端是亲水链段-甲氧基聚乙二醇，一端是亲油链段-聚己内酯。通过调整分子量或者亲水/亲油链段比值，甲氧基聚乙二醇-聚己内酯可以作为不同种类药物的载体材料
Methoxypolyethylene glycol polycaprolactone (MPEG PCL) can be used as a carrier material for various drugs. It is used in pharmaceutical research, drug release, nano new material research and cell culture. When it is taken out of the refrigerator, it is placed in a dry place to slowly rise to room temperature. It is ready for use. After it is taken out, it is filled with inert gas and put into a low-temperature environment in time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57a7f38a65711e7ef31f29392a6eda5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a665b1d1101381e472b1f68f6b824b8/" rel="bookmark">
			因果推断-【The MineThatData E-Mail Analytics And Data Mining Challenge】思路分析与Python实现代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、数据集介绍
二、问题及分析思路
1、问题
2、分析思路
三、代码
一、数据集介绍 数据集来源于用户在网上的购物行为，涵盖了过去一年有购买行为的64000个用户，这些用户被用于电子邮件营销活动的实验分析。实验的目的是衡量哪个版本的电子邮件营销活动最有效，以及针对哪部分人群最有效。用户被随机地分为以下三组：
1/3的用户会收到一封以男士商品为主的电子营销邮件（实验组-男士版）1/3的用户会收到一封以女士商品为主的电子营销邮件（实验组-女士版）1/3的用户不会收到邮件（对照组） 两周后收集实验结果，可用的特征有：
Recency：距离最近一次购买行为，经过了多少个月History：过去一年用户实际花费的金额Mens: 1/0，1-过去一年用户购买过男士用品Womens: 1/0，1-过去一年用户购买过女士用品Zip_Code:：地区Newbie: 1/0，1-过去一年内的新用户Channel: 过去一年用户的购物渠道 用于描述用户的分组信息：
Segment：有三个枚举值分别是Mens-E-mail、Womens-E-mail和No-E-mail 实验有三个评价指标，分别是：
Visit：1/0，1-用户在两周内访问了网站Conversion：1/0，1-用户在两周内有购买行为Spend：用户在两周内实际消费的金额 二、问题及分析思路 1、问题 数据集的提供者提出了8个问题：
哪个电子邮件活动最有效，男士版还是女士版？男士版电子邮件活动为每位顾客带来了多少销售额的增加？女士版电子邮件活动为每位顾客带来了多少销售额的增加？如果你只能给10000个顾客发送Email，你会选择哪些顾客？为什么？如果你可以从收到电子邮件的顾客中剔除10000个人，不让他们参加此活动，你会选择哪些顾客？为什么？对于不同的客户群体，男士版本和女士版本的活动效果有差异吗？当选择不同的评价指标，比如访问、转化和消费额时，活动效果有差异吗？你是否观察到任何异常或奇怪的发现？根据实验结果，你会将男士版和女士版的投放定位到哪些顾客？你会用哪些数据来支持你的建议？ 2、分析思路 Q1&amp;Q6：
结论：
男士版活动最有效，visit、conversion、spend三个指标均比女士版效果明显。
思路：
这两个Q思路是一样的，本质都是在计算ATE。先做PSM匹配合适的对照样本，然后分别计算vist、conversion和spend三个指标的ATE，比较男士版本和女士版本的差异。
实验结果：
Q2：
思路：
这道题本质是在问，选择spend作为评价指标时的ITE是多少，和第一题的思路差不多，先做PSM，然后计算实验组每个用户的ITE。
Q3&amp;Q4：
思路：
这两个Q本质上是一个问题，即如何按发送邮件的优先级给用户排个序？然后我们只需要取排序后的前10000和后10000个用户即可。
首先，我们可以根据用户的自然行为和受处理后行为这两个维度将用户分成四类，那么第二象限的用户是对营销活动最敏感的，如果发送邮件，应该优先发送给这部分用户。 其次，应该给第一象限的用户发送邮件，邮件对这部分用户也有一定的作用。最后，剩余的用户按照消费间隔(recency)和消费等级(history_segment)综合排序，距离上次购买间隔越久远越优先发送，消费等级越高越优先发送。
Q5&amp;Q8：
结论：
男士版建议投放人群：
1）历史消费段在$350-1000用户群
2）多渠道购物用户群
女士版本建议投放人群：
1）历史消费段在$500-750和$1000+的用户群
2）多渠道购物用户群
3）新用户群
思路：
这两个Q本质都是进行HTE分析，通过比较实验在不同细分群体的效果，从而决定最佳投放人群。我们可以以ATE作为benchmark，如果细分群的CATE明显高于ATE，证明细分群的实验效应是显著的。
消费段(history_segment)比较，男士版在$350-500，$500-750和$750-1000这三个消费段的uplift是显著的，而女士版则是在$500-750和$1000+这两个消费段显著。说明男士版对中高档消费人群是有效的，而女士版则是对高档消费人群更有效。
购物渠道(channel)比较，可以看出男士版和女士版都在Multichannel渠道有显著的uplift，说明过去曾在多个渠道有购物行为的用户（各处买买买），对邮件营销更加敏感。
新老用户(Newbie)比较，男士版对新老用户的效果差不多，而女士版显然对新用户更有效果。
Q7：
这里有一个很有意思的发现：女士版的营销邮件对曾购买过女士用品的顾客效果很好，但对购买过男士用品的顾客效果一般。而男士版本的营销邮件却没有存在这个问题。 这反映了现实中的两个现象：
1）女士一般是家庭购物决策者，所以既会关注女士用品，也会关注男士用品；
2）男士一般很少给女士买东西，除非在一些纪念日、节假日等有意义的日子，所以女士用品的推荐对男士可能起不到太大作用。
三、代码 import pandas as pd import psmatching.match as psm import numpy as np import random import operator random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a665b1d1101381e472b1f68f6b824b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7485074eaaa239af3f56f7a8850824ee/" rel="bookmark">
			Ubuntu更换国内源（apt更换源）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上的教程大部分都是文本命令行的方式更换国内源的，其实Ubuntu18.04也提供了图形界面的方式，这里主要讲图形界面的方式，毕竟点点鼠标就能完成的事儿谁愿意去输命令啊，而且还容易出错，当然这里也附上命令行的方式。
可能很多人会问到底什么是源呢？
其实吧它就像苹果和案桌的软件应用商店一样，为Linux用户提供软件下载及更新服务的。
Linux家族有三个软件源系统：
yum源，使用这种软件管理器的主要是：RedHat，CentOS
apt源，使用这种软件管理器的主要是：Ubuntu
Pacman源，使用这种软件管理器的主要是：archlinux还有新近崛起的Manjaro
Ubuntu是外国人开发的系统，默认使用的也是国外的源，但是从国内翻^qiang下载国外的软件（插件）源太慢。其实国内也有很多的镜像源，比如说阿里源，网易源，清华园（源），中科大源。
一般这些源都是做为自己公司的业务服务的，比如说阿里的源，就是为阿里上百万台云服务器提供软件源的，你可以想像一下它的速度能不快吗？
这里实现切换阿里云源，别看截图很多，其实操作起来很简单滴
方式一：图形界面 第一步：打开软件和更新
第二步：设置163源
这是原来的/etc/apt/sources.list配置文件
选择其他站点
选择阿里云源并保存
关闭配置页面，即保存所有配置
第三步：正在更新缓存
关闭之后会弹出一个对话框问你要不要重新载入软件的列表信息
切换国内源，需要更新缓存，点击重新载入
更新过以后可以看下/etc/apt/sources.list配置文件
可以发现sources.list配置文件已经修改成了阿里云源
方式二：命令行 第一步：修改sources.list配置文件：
sudo vim /etc/apt/sources.list 在文件最前面添加以下条目，保险起见，的操作之前做好备份
deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7485074eaaa239af3f56f7a8850824ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e330595cc1e84033d8035a392dbe49b/" rel="bookmark">
			python模块：Scipy.optimize.minimize规划问题求解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、模块介绍
二、模块源分析与参数解释
三、实例求解
四、参考
一、模块介绍 1.1模块功能 Scipy.optimize是Scipy中一个用于解决数学模型中优化类模型的子包，该子包中又包含了多个子功能模块见下表，不同方法不同条件求解最优化模型。本节介绍minimize对一般规划问题的模型建立与求解。
问题类型模块多元标量函数的有/无约束最小化minimize最小二乘法最小化least_squares单变量函数最小化器minimize_scalar线性规划linprog 1.2模型介绍 多元标量函数的最小化，是数学规划模型中更为一般的模型，该模块包括有限制性约束和无限制性约束的最小化，而对于限制性约束又分为线性约束和非线性约束。这种更为一般的模型需要针对具体的问题假设选择特定的方法进行求解。
在数学规划模型中，minimize提供的方法能够解决无/有（线性、非线性）约束的多个决策变量目标函数的最优化问题，但是由于该模块是依据函数导数与梯度进行求解，不能够求解整数规划、01规划等问题。
二、模块源分析与参数解释 2.1模块整体介绍 对于整个多元标量的最小化问题，主要的api为optimize包下的minimize函数。该minimize函数的完整参数详情如下。同时，对于不同的method方法，函数的参数也会有相应的限制，这在具体的方法介绍中具体介绍。
minimize(fun, x0, args=(), method=None, jac=None, hess=None, hessp=None, bounds=None, constraints=(), tol=None, callback=None, options=None) 该函数主要参数意义解释：
fun待求解的目标函数x0初始猜测的数组args目标函数带参数时需要指定method选择的方法jacjacobian矩阵或梯度函数（梯度求解的方法需要传入）hesshessian矩阵hessp黑塞向量积bounds寻优范围constraints限制约束tol浮动，可以理解为单次寻找的步长上限，越小精度越高callback回调函数options选项字典，不同方法有不同选项 完整的方法options可通过optimize的show_options方法访问
from scipy.optimize import show_options print(show_options(method='minimize')
该模块提供求解方法字典如下, 通过optimize包导入minimize后，对minimize传入method参数指定方法。而对于不同方法的选用,便有不同的求解策略。我们选择部分主要方法介绍。
MINIMIZE_METHODS = ['nelder-mead', 'powell', 'cg', 'bfgs', 'newton-cg', 'l-bfgs-b', 'tnc', 'cobyla', 'slsqp', 'trust-constr', 'dogleg', 'trust-ncg', 'trust-exact', 'trust-krylov'] 无约束多元标量最小化选择以下4个方法：
nelder-mead powellbfgsnewton-cg 有约束多元标量最小化选择方法：
trust-constr 对于更多的方法可以访问该文档查询：完整方法文档
2.2 各方法详细介绍 2.2.1 nelder-mead 方法完名称为Nelder-Mead Simplex algorithm Nelder-Mead单纯形法，该方法通过对可行域顶点不断迭代选出最优解。由于是迭代寻优策略，可以指定寻优范围。
该方法对应参数：
scipy.optimize.minimize(fun, x0, args=(), method='Nelder-Mead', bounds=None, tol=None, callback=None, options={'func': None, 'maxiter': None, 'maxfev': None, 'disp': False, 'return_all': False, 'initial_simplex': None, 'xatol': 1e-5, 'fatol': 1e-5, 'adaptive': False})
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e330595cc1e84033d8035a392dbe49b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4af749e8e3ccff1d7a95ee5b5ecd50e3/" rel="bookmark">
			多线程之callable详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试有人会问：线程的实现方式有几种？
很多人可能回答：2种，继承Thread类，实现Runnable接口。
很多忽略了callable这种方式。
也许有人知道callable，也知道callable和Runnable的区别是callable可以有返回值，也可以抛出异常的特性，而Runnable没有。
这里估计很多人懵逼，接下来我们就从源码层次讲解这个问题。
注意callable可以有返回值，也可以抛出异常这点很关键。
很多时候我们让多线程去帮我们处理事情，是需要拿到返回值的，有了异常也可以处理，比如某宝的APP页面，一个页面展示3个块，而每个块展示的信息从后端获取的接口都不一样，那么是让前端调后端3次接口吗？
肯定不行，后端可以把3个块的信息，包装成一个接口，全部返回，那么问题来了，后端调用3个接口，比如第一个接口需要1秒，第二个需要2秒，第三个需要3秒，那么包装的这个接口响应时间最少6秒，怎么解决这个问题呢，可以用多线程来帮我们解决。
启动3个线程，每个线程去调用一个接口，那么3个线程一共执行完的时间就是最慢的那个线程的执行时间，这样接口的响应时间就变成了3秒，一下节省了一半的时间。
那么问题来了，线程如何把执行的业务代码的结果返回来呢？这时候就用到callable了。
FutureTask futureTask=new FutureTask(new Callable() {
@Override
public String call() throws Exception {
Thread.sleep(3000);
System.out.println("calld方法执行了");
return "call方法返回值";
}
});
futureTask.run();
System.out.println("获取返回值: " + futureTask.get());
FutureTask futureTask1=new FutureTask(new Callable() {
@Override
public String call() throws Exception {
Thread.sleep(3000);
System.out.println("calld方法执行了1");
return "call方法返回值1";
}
});
futureTask1.run();
System.out.println("获取返回值1: " + futureTask1.get());
我们可以调用futureTask.get()方法去获取线程异步的执行结果，
这时候问题又来了
那如果2个线程一起执行，futureTask执行完了，futureTask1没执行完会不会有问题。是不是futureTask1就拿不到结果了？
当然不会，futureTask.get（）方法会保证线程在执行完之前是阻塞的。
我们看下futureTask源码
2个一个有时间，一个没有时间，最终都是调用的awaitDone（）这个方法，我们继续看awaitDone
线程没有执行完，也就是没有到达COMPLETING的状态，会执行LockSupport.park，让线程等待，那什么时候去唤醒呢？
我们继续看 最后返回线程的执行结果：
那么再问callable和Runnable有什么联系呢？
相信大家通过对源码的分析都明白了，callable的call（）方法是被Runnable的run（）方法调用的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/223ea51c7e1db4291cec430c2de9efdb/" rel="bookmark">
			ExecutorService详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在我们的日常开发中，难免会使用到线程，部分还会用到多线程并发问题。我们知道，线程的创建和释放，需要占用不小的内存和资源。如果每次需要使用线程时，都new 一个Thread的话，难免会造成资源的浪费，而且可以无限制创建，之间相互竞争，会导致过多占用系统资源导致系统瘫痪。不利于扩展，比如如定时执行、定期执行、线程中断，所以很有必要了解下ExecutorService的使用。
ExecutorService是Java提供的线程池，也就是说，每次我们需要使用线程的时候，可以通过ExecutorService获得线程。它可以有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞，同时提供定时执行、定期执行、单线程、并发数控制等功能，也不用使用TimerTask了
1.ExecutorService的创建方式 public ThreadPoolExecutor(int corePoolSize,
int maximumPoolSize,
long keepAliveTime,
TimeUnit unit,
BlockingQueue&lt;Runnable&gt; workQueue,
ThreadFactory threadFactory,
RejectedExecutionHandler handler) 所有线程池最终都是通过这个方法来创建的。
corePoolSize : 核心线程数，一旦创建将不会再释放。如果创建的线程数还没有达到指定的核心线程数量，将会继续创建新的核心线程，直到达到最大核心线程数后，核心线程数将不在增加；如果没有空闲的核心线程，同时又未达到最大线程数，则将继续创建非核心线程；如果核心线程数等于最大线程数，则当核心线程都处于激活状态时，任务将被挂起，等待空闲线程来执行。
maximumPoolSize : 最大线程数，允许创建的最大线程数量。如果最大线程数等于核心线程数，则无法创建非核心线程；如果非核心线程处于空闲时，超过设置的空闲时间，则将被回收，释放占用的资源。
keepAliveTime : 也就是当线程空闲时，所允许保存的最大时间，超过这个时间，线程将被释放销毁，但只针对于非核心线程。
unit : 时间单位，TimeUnit.SECONDS等。
workQueue : 任务队列，存储暂时无法执行的任务，等待空闲线程来执行任务。
threadFactory : 线程工程，用于创建线程。
handler : 当线程边界和队列容量已经达到最大时，用于处理阻塞时的程序
2.线程池的类型 2.1 可缓存线程池 ExecutorService cachePool = Executors.newCachedThreadPool(); 看看它的具体创建方式： public static ExecutorService newCachedThreadPool() {
return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
60L, TimeUnit.SECONDS,
new SynchronousQueue&lt;Runnable&gt;());
} 通过它的创建方式可以知道，创建的都是非核心线程，而且最大线程数为Interge的最大值，空闲线程存活时间是1分钟。如果有大量耗时的任务，则不适该创建方式。它只适用于生命周期短的任务。 2.2 单线程池 ExecutorService singlePool = Executors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/223ea51c7e1db4291cec430c2de9efdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6641e342f3d7622cfba52bef13baa353/" rel="bookmark">
			SpringAop之joinPoint讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、学习背景 摸鱼的时候继续复刻demo，没错，同之前一篇文章，在写aop时又发现自己对aop只停留在面试阶段，甚至还不如，完全不会实践，所以在此记录复刻aop用到的的一些且自己已经遗忘的知识。
那么复刻的一个需求点我以最简单来说对于此次要学习的内容：就是通过joinPoint获取方法上的特定注解。
注解代码如下：
import com.uum.common.core.enums.BusinessType; import java.lang.annotation.*; /** * 自定义注解--操作日志记录 */ @Documented @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Operation { /** * 模块 */ String description() default ""; /** * 功能 */ BusinessType businessType() default BusinessType.OTHER; /** * 是否保存请求的参数 */ boolean isSaveRequestData() default true; /** * 是否保存返回结果 */ boolean isSaveResponseData() default true; } 那么这个就是系统操作日志的注解，主要到时候用aop的joinPoint获取标注在方法上该注解联合方法的相关内容将其转化为系统日志并进行存储。那么问题来了，什么是joinPoint？
二、joinPoint对象 2.1、joinPoint 在AOP中，我们知道描述切面的术语有通知（advice），切点（pointcut），连接点（join point）。连接点（joinPoint）就是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。这个类的主要作用就是可以让我们在Advice中获取被增强方法相关的所有信息。通过JoinPoint可以获取被代理方法的各种信息，如方法参数，方法所在类的class对象，然后执行反射操作
它的主要方法及相关解释如下表格： 方法名功能Signature getSignature();获取封装了署名信息的对象,在该对象中可以获取到目标方法名,所属类的Class等信息Object[] getArgs();获取传入目标方法的参数对象Object getTarget();获取被代理的对象Object getThis();获取代理对象其中关键方法就是这个getSignature(),该方法返回Signature对象，而通过该对象我们可以获得被增强方法的信息。 2.2、ProceedingJoinPoint ProceedingJoinPoint继承JoinPoint,是它的子接口，在joinPoint的基础上对其增强功能。其实主要是在JoinPoint的基础上暴露出 proceed 这个方法。proceed很重要，这个是aop代理链执行的方法。
public interface ProceedingJoinPoint extends JoinPoint { public Object proceed() throws Throwable; public Object proceed(Object[] args) throws Throwable; } 环绕通知=前置+目标方法执行+后置通知，proceed方法就是用于启动目标方法执行的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6641e342f3d7622cfba52bef13baa353/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/871c349d86cac2c6a41d1c6b5da66c3f/" rel="bookmark">
			利用scikit中的遗传算法求解(整数01)约束规划实例详解教程&#43;利用scipy.optimize求解约束规划问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意标准形式 下面两个方法约束规划的一般标准形式为：
利用scikit-opt的遗传算法求解约束规划问题 先放上链接：scikit-opt网址
主要四个步骤：
下面依照此题多约束为例
可知该题有5个不等式约束，且决策变量为01整数，后面将具体讲解如何将目标函数的约束条件加入GA模型中
一：import scikit-opt库 import pandas as pd import numpy as np import matplotlib.pyplot as plt from sko.GA import GA ###########此行为调出scikit-opt中的遗传算法 ########### #若安装 #则： pip install scikit-opt ##################################### 二：定义目标函数 看线面的代码我们发现里面有个参数p，这个参数我理解就是GA中的某一个种群，真正调用这个函数的时候我们不需要写参数和括号
def schaffer(p): ''' 目标函数: min(xi)求和 决策变量维度：n 决策变量类型：0 1 整数 :param p: :return: ''' x=np.array(p)###转化为数组 return sum(x)###返回将目标函数的值 三：定义约束 注意这里遗传算法中的约束应该默认为≤0的形式，而且不管有多少个约束，最终将约束的值及你给过一个max函数累加后返回，同样这里也需要决策变量，这里也是参数P，我们真正调用时，不需要写括号和参数
def constraint_yueshu(p): ####注意这里的p就是种群，对应本约束问题，就是x，但是p是个一维的数据，若想利用矩阵计算，可将p reshape，即进行尺寸的转化 x=np.array(p)###转化为一维数组 #注意需要将原约束转化为标准形式，&lt;=0的形式。即求和1000-求和x*a&lt;=0, he = 0 for j in range(5):###由于这里面涉及到5个约束，且形式相似，因此利用for循环计算，也可单独计算，而决策变量的约束系数aij是一个二维数组 tem=0 for i in range(n):###这里的n就是决策变量的维度（个数） tem+=x[i]*a[i][j] ##这一层for循环结束后计算出了一个约束条件的值 he+=max(0,1000-tem) #这里用1000-tem就相当于转化为了标准形式 ###这一层的for循环结束后就计算出了所有的约束条件的值（不是严格意义的数值，而是大于或小于0） #这里的max（0，tem）是关键，因为第二层for循环结束后就是计算出了一个约束条件的值，如果该值＜0证明满足约束，max（0，tem）将返回0，对结果没有影响，若＞0则返回该值，最终的约束条件值得和-&gt;he必然＞0，即只要有一个约束不成立，那么最终返回值就是＞0得，也即这个种群对应的决策变量值不满足约束 print(he)###这个只是便于检测约束和，看是否满足约束 return he constraint= [constraint_yueshu] ###注意这里的调用计算约束函数的函数并没有写括号，传参数 四：代入模板函数，设定相关参数 n=10##设定决策变量x的个数 ga = GA(func=schaffer, n_dim=n, size_pop=50, max_iter=800, prob_mut=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/871c349d86cac2c6a41d1c6b5da66c3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dd52b23123da8df8aa9b59f9ef4a1bb/" rel="bookmark">
			【无标题】gateway 503
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/applesnt/p/14846691.html 第十三章第四节： 注册renren-fast服务以及修改网关访问
https://www.cnblogs.com/chenkx6/p/13373651.html 开源项目renren-fast开发环境部署（后端部分
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.xunqi.gulimall&lt;/groupId&gt; &lt;artifactId&gt;gulimall-gateway&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;gulimall-gateway&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR3&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.xunqi.gulimall&lt;/groupId&gt; &lt;artifactId&gt;gulimall-common&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-alibaba-sentinel-gateway --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-sentinel-gateway&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dd52b23123da8df8aa9b59f9ef4a1bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ef43bb8c6d9965635be0f9caee80807/" rel="bookmark">
			工作一点遐想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近写代码，有一点遐想，我是在linux上写C语言代码的，写完代码，经过编译就可以在linux系统上，便可以运行起来，本质上也就是cup执行汇编指令。
那么，就是可以类比一下，对于cpu来说，汇编代码类似配置文件，cpu按照配置文件执行而已。
进一步类比，如果我写一个程序也可以读取汇编代码执行响应指令，那么我的这个程序就是虚拟cpu，
换另一种方式就是，如果我写一个程序，可以读取我的配置文件，并执行响应动作。那我的配置文件就相当于是某种编程语言。
也就是说，虚拟一个cup，或者创建一门新的编程语言，功能越简单，实现越容易。😁
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25a0e089936be985ce4eae0d09abf60f/" rel="bookmark">
			正确解决：FTP文件夹错误，将文件复制到FTP服务器时发生错误。请检查是否有权限将文件放到该服务器上。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Win10上传文件到Linux服务器报错：正确解决方式： Win10上传文件到Linux服务器报错： FTP文件夹错误，将文件复制到FTP服务器时发生错误。请检查是否有权限将文件放到该服务器上。
谷歌了半天，全是同个答案，压根无法解决，无语到爆炸（内心：几十篇文章，全都一个样，他们是怎么做到几十个人在那里互抄的，然后还没用）：
正确解决方式： 右键，点登录，输入账号密码就好了，搞那么复杂（当然，可能我是单纯忘记登账号了，他们是登了账号，还不行）（前面那么无语，还是因为，所有文章，都一样，在那里水，也没一个人说登录账号）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20af8772e4a794b493909ee7f944cad1/" rel="bookmark">
			Matlab绘制带误差线的柱状图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matlab可绘制带误差线的柱状图（需下载barweb (BARgraph With Error Bars) - File Exchange - MATLAB Central并设置路径），成图如下所示。 代码：
close all;clear;clc; X = [0.2267 0.1423 0.1427 0.1038; 0.1567 0.1184 0.1479 0; 0.1199 0.1035 0.1643 0; 0.1900 0.1540 0.1631 0]; %(系列数据) E = [0.2808 0.1069 0.1092 0.1006; 0.1614 0.1003 0.1001 0; 0.1277 0.0789 0.1181 0; 0.2398 0.1518 0.1433 0];%（标准差） legends = {'2019','2020','2021','2022'};%（图例） groupnames = cell(4,1); groupnames{1} = '1';groupnames{2} = '2';groupnames{3} = '3';groupnames{4} = '4';%（分组名称） Title = ''; Xlabel = 'X'; Ylabel = 'Y'; barweb(X,E,1,groupnames,Title,Xlabel,Ylabel,jet,'none',legends,2,'plot'); 设置配色及颜色对应可参考：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20af8772e4a794b493909ee7f944cad1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23117ece8e5cb9e4e98bb7ac9a34c20e/" rel="bookmark">
			KITTI 数据集简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据集简介 KITTI数据集由德国卡尔斯鲁厄理工学院和丰田美国技术研究院联合创办，是目前国际上自动驾驶场景下常用的数据集之一。KITTI数据集的数据采集平台装配有2个灰度摄像机，2个彩色摄像机，一个Velodyne 64线3D激光雷达，4个光学镜头，以及1个GPS导航系统。
官网 国内下载地址1 国内下载地址2
为了生成双目立体图像，相同类型的摄像头相距54cm安装。由于彩色摄像机的分辨率和对比度不够好，所以还使用了两个立体灰度摄像机，它和彩色摄像机相距6cm安装。为了方便传感器数据标定，规定坐标系方向如下[2] ：
• Camera: x = right, y = down, z = forward
• Velodyne: x = forward, y = left, z = up
• GPS/IMU: x = forward, y = left, z = up
Dataset详解 文件组织形式 calib:相机标定参数，可根据参数将2D、3D数据坐标进行转换image2: 左侧彩色相机图像数据veloyne:雷达点云数据label2:对应文件标签 calib标定校准文件解析 内参矩阵： P0-P3分别表示4个相机（左边灰度相机、右边灰度相机、左边彩色相机和右边彩色相机）的内参矩阵，或投影矩阵, 大小为 3x4。相机内参矩阵是为了计算点云空间位置坐标在相机坐标系下的坐标，即把点云坐标投影到相机坐标系。将相机的内参矩阵乘以点云在世界坐标系中的坐标即可得到点云在相机坐标系中的坐标。校准矩阵： R0_rect 为0号相机的修正矩阵，大小为3x3，目的是为了使4个相机成像达到共面的效果，保证4个相机光心在同一个xoy平面上。在进行外参矩阵变化之后，需要于R0_rect相乘得到相机坐标系下的坐标。外参矩阵：根据上述介绍，我们知道存在三种坐标系世界坐标系、相机坐标系、激光雷达坐标系。世界坐标系反映了物体的真实位置坐标，也是作为相机坐标系和激光雷达坐标系之间相互变换的过渡坐标系。点云位置坐标投影到相机坐标系前，需要转换到世界坐标系下，对应的矩阵为外参矩阵。外参矩阵为Tr_velo_to_cam ，大小为3x4，包含了旋转矩阵 R 和 平移向量 T。将相机的外参矩阵乘以点云坐标即可得到点云在世界坐标系中的坐标。综上所述，点云坐标在相机坐标系中的坐标等于
相机坐标 = 内参矩阵 * 外参矩阵 * R0校准矩阵 * 点云坐标
例如要将Velodyne激光雷达坐标系中的点x投影到左侧的彩色图像中y，使用公式：
y = P2 * R0_rect *Tr_velo_to_cam * x激光雷达坐标转换图像像素坐标代码def velodyne2img(calib_dir, img_id, velo_box): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23117ece8e5cb9e4e98bb7ac9a34c20e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fdd5190d98c9559da51cfec27aa9259/" rel="bookmark">
			（看这篇就够了）idea操作git commit后，撤销commit，恢复到提交前的状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 为什么会有提交（commit）代码到git本地仓库后，想要撤销的操作呢？一般来讲，是我们需要commit后，发现，有一些文件不应该提交到仓库。或者该次提交中，还不想包含，某些修改了的文件。亦或者说在做本地调试的时候，修改了某些文件，但是这些文件，在测试环境或者生成环境是不能被修改的。针对这些情况，在没有注意到的情况下，都commit到了本地，此时为时还不晚。git命令，就不说了，直接用idea操作吧，简单实用。
操作 点击idea下方工具栏的git，打开git日志窗口，如下图所示：
一共显示了两次提交，当第二次提交，发现有的文件不想提交了。此时，我们就需要撤销当前提交了。
此时，因为要撤销当前的第二次提交，所以要将鼠标点击到第一次提交的日志上，右键弹窗菜单
选择reset current branch here 选择，（重置当前分支到这里）翻译也明白是啥意思了，重置当前分支到选择的第一次提交的日志版本的位置。这还没完，点击后会弹出框，有四个选项，如下图所示：
Soft
Files won’t change,differences will be staged for commit.
文件不会更改，不同之处将被暂存，等待commit.（此时，恢复的后的状态新增的文件是绿色，修改的文件是蓝色）
Mixed
Files won’t change,differences won’t be staged. （won’t 是 will not的缩写）
文件不会更改，不同之处将不会被暂存。（此时，恢复的后的状态新增的文件是红色，修改的文件是蓝色）
Hard
Files will be reverted to the state of the selected commit.
Warning:any local changes will be lost.
文件将被恢复到所选择提交的那个版本的状态.（此时，你所修改的或者是新增的文件都会丢失，所有的文件都是白色）
Keep
Files will be reverted to the state of the selected commit.
but local changes will be kept intact.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fdd5190d98c9559da51cfec27aa9259/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/044b23e22dc155f388eacc27d946e9ff/" rel="bookmark">
			flink run常用参数说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 flink run参数： 参数参数全称描述-c–class需要指定的main方法的类-C–classpath向每个用户代码添加url，他是通过UrlClassLoader加载。url需要指定文件的schema如（file://）-d–detached在后台运行-p–parallelismjob需要设置env的并行度-q–sysoutLogging禁止logging输出作为标准输出。-s–fromSavepoint基于savepoint保存下来的路径，进行恢复。-sae–shutdownOnAttachedExit如果是前台的方式提交，当客户端中断，集群执行的job任务也会shutdown。 flink run -m yarn-cluster参数 参数参数全称描述-m–jobmanageryarn-cluster集群-yd–yarndetached后台-yjm–yarnjobManagerjobmanager的内存-ytm–yarntaskManagertaskmanager的内存-yz-yarnzookeeperNamespacezookeeper命名空间-yn–yarncontainerTaskManager的个数-yid–yarnapplicationIdjob依附的applicationId-ynm–yarnnameapplication的名称-ys–yarnslots分配的slots个数 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ab3c8aee522ace2ad0d85b777986303/" rel="bookmark">
			Ubuntu软件包升级失败的终极修复方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		升级失败
apt upgrade -y 尝试修复
apt autoremove Reading package lists... Done Building dependency tree Reading state information... Done You might want to run 'apt-get -f install' to correct these. The following packages have unmet dependencies: powerd : Depends: repowerd (&gt;= 2018.04+ubports+0~20220810204931.7~1.gbp40e09b) but 2018.04+ubports+0~20220324230500.5~1.gbp47f5a2 is installed E: Unmet dependencies. Try using -f. 使用建议命令，失败
apt-get -f install 尝试删除包，失败
dpkg --remove --force-remove-reinstreq package_name 解决办法
找到之前安装的包，逐个降级
cat /var/log/dpkg.log | grep 2022-08-18 | grep upgrade | awk '{print $4"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ab3c8aee522ace2ad0d85b777986303/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68067c707521a871b32e8ead40fca8b9/" rel="bookmark">
			rust 基于Cargo的宏展开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考命令：
https://blog.csdn.net/hbuxiaofei/article/details/113958825
安装cargo expand 插件：
cargo +nightly install cargo-expand 展开宏：
cargo expand 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/817acb18bc0d97aacdb952b996e16494/" rel="bookmark">
			编程实用工具大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前端、后端、大数据等编程实用工具 截图工具SnipasteFSCapture 截图工具 Snipaste 下载地址：Snipaste
FSCapture 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ee7a5d2a6ccb92fe6dbdf7a7a87aa5/" rel="bookmark">
			MCU当中比较常见的数据类型转换学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据转换方法 通过阅读各个博客的文章也学习总结下：基本有两种比较常用：1.移位法；2.共用体法。 其中移位法用起来比较灵活，共用体法适合固定数据类型格式的转换，共用体法时常用在上下位机的通信当中。 方法一：移位法 一般有8位、16位、32位用的比较多 例如：8位转16位：将2个8位数据分别为high、low合成一个16位数据data_u16，注意：不同单片机可能high、low可能放在数据后面，也可能在前面，这个需要了解芯片低端在前还是高端在后。 因此，实际程序实现方法可以为： 8位转16位 //8位转16位 data_u16 = (high&lt;&lt;8) | low; 16位转8位
//16位转8位 //将一个16位数据data_u16拆分成2个8位数据high、low： high = (data_u16 &gt;&gt; 8) &amp; 0xff;	//高8位 low = data_u16 &amp; 0xff; //低8位 8位转32位
//将4个8位数据data_u8[4]合成一个32位数据data_u32： data_u32 = (data_u8[0]&lt;&lt;24)|(data_u8[1]&lt;&lt;16)|(data_u8[2]&lt;&lt;8)|data_u8[3]; 32位转8位
//将2个16位数据data_u16[2]合成一个32位数据data_u32： data_u8[0] = (data_u32 &gt;&gt; 24) &amp; 0xff;	data_u8[1] = (data_u32 &gt;&gt; 16) &amp; 0xff; data_u8[2] = (data_u32 &gt;&gt; 8) &amp; 0xff; data_u8[3] = data_u32 &amp; 0xff; //高位在前，低位在后 16位转32位
//将2个16位数据data_u16[2]合成一个32位数据data_u32： data_u32 = (data_u16[0]&lt;&lt;16)|data_u16[1]; 32位转16位
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7ee7a5d2a6ccb92fe6dbdf7a7a87aa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c453f54a7f690660effcbcfe71004c68/" rel="bookmark">
			cocos creator 3.5版本远程下载资源跨域问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序调用方法： assetManager.loadRemote("这里是远程url",function(a,b){
console.log("aaaaaaaaaaaaa")
})
运行报错关键字： ORS policy: No 'Access-Control-Allow-Origin' header is present on the reques
解决方案： 我的nginx服务器，安装在本地，查找了很多的资料，修改conf配置即可，配置如下
找了很多解决跨域的文章，说的比较复杂，其实对于我们内部开发来说，只要可以访问实现代码就可以了，相当于解决bug。如上，我解决了自己遇到的问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65bb1da5fbfb7fd3cbc5885879bc5f20/" rel="bookmark">
			python爬虫 文本含有&amp;nbsp该如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用爬虫爬取网页标题时，利用bs4解析p标签的内容后，某些标题里掺杂了字符，该字符并没有以真正的空格显示，而是显示为字符串，所以我使用了replace()方法去除。
原代码：
for it in result3: title=it.group("title") print(title) 修改后：
for it in result3: #通过replace()方法将字符串'&amp;nbsp;'替换成了空字符串'' title=it.group("title").replace(u'&amp;nbsp;', u'') print(title) replace(u’需要被替换掉的字符串’, u’想要替换成的字符串’)
——END——
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71c0c94392d25d7f2bce1c36d792182c/" rel="bookmark">
			C语言折半查找算法及代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.折半查找的定义： 在计算机中，折半查找，也称二分搜索。它是一种在有序数组中查找某一特定元素的搜索算法。
2.折半查找的实现原理： 搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半 。
以下是折半查找和顺序遍历的算法实实现动态图
3.折半查找算法优点： 折半查找法的优点是比较次数少，查找速度快，平均性能好；
其缺点是要求待查表为有序表，且插入删除困难。
因此，折半查找方法适用于不经常变动而查找频繁的有序列表。
4.代码实现： # include&lt;stdio.h&gt; # include&lt;string.h&gt; int main() { int arr[] = { 1,2,3,4,5,6,7,8,9,10 };//下标：0，1，2，3，4，5，6，7，8，9 int k = 8; int left = 0; int sz = sizeof(arr) / sizeof(arr[0]); int right = sz - 1; while (left &lt;= right) { int mid = (left + right) / 2; if (arr[mid] &gt; k){ right = mid - 1; } else if (arr[mid] &lt; k){ left = mid + 1; } else{ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71c0c94392d25d7f2bce1c36d792182c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f035a82b961a2429829640104f3c08eb/" rel="bookmark">
			response实现文件下载功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DownloadServlet.java
package com.heima.web; import javax.servlet.ServletException; import javax.servlet.ServletOutputStream; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.File; import java.io.FileInputStream; import java.io.IOException; /* 【文件下载】两个头+两个流（流拷贝） 1. 设置响应头：Content-Disposition 告诉浏览器以附件的形式来处理文件； 2. 设置响应头： response.setContentType(mimeType) 告诉浏览器下载的文件的类型； 3. 流拷贝： 1. 将文件读取到流里边： FileInputStream fin = new FileInputStream(file)； 2. 将流写给浏览器：response.getOutputStream().write(arr,0,len); */ @WebServlet(urlPatterns = "/download") public class DownloadServlet extends HttpServlet { protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request, response); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //文件下载 //1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f035a82b961a2429829640104f3c08eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d630aed2646b2be0863570b49b4d83a/" rel="bookmark">
			日志技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Windows事件日志分类
Windows日志分析方法
Linux日志简介
Linux日志分析技巧
Web服务器日志(windows)
日志用来记录系统、程序运行中发生的各种事件，有助于定位问题的根本原因。不同的操作系统、程序都有不同的日志， 如：Linux系统日志、Windows系统日志、MySQL数据库日志、mssql数据库日志以及
各种WEB日志(如apache、tomcat、nginx日志等)
Windows事件日志分类 系统日志、应用程序日志、安全日志
Windows日志分析方法 1.查看管理员登陆时间、用户名是否存在异常
（1）不借助工具
开始——&gt;所有程序——&gt;管理工具——&gt;事件查看器
window+R，输入“eventvwr.msc”，进入事件查看器
对于Windows事件日志分析，不同的EVENT ID 代表不同意义，每个成功登录的事件都会标记一个登录类型，不同登陆类型代表不同方式。
事件ID说明4624登陆成功4625登陆失败4634注销成功4647用户启动的注销4672使用超级用户(如，管理员)进行登录4720创建用户 登陆类型描述说明2交互式登录用户在本地进行登录3网络最常见的情况就是连接到共享文件夹或共享打印机4批处理通常表明某计划任务启动5服务每种服务都被配置在某个特定的用户账号下运行7解锁屏保解锁8网络明文登录的密码在网络上是通过明文传输的，如FTP9新凭证使用带/Netonly参数的RUNAS命令运行一个程序10远程交互通过终端服务，远程桌面或远程协助访问计算机11缓存交互以一个域用户登录而又没有域控制器可用 2.借助工具Event Log Explorer
Linux日志简介 Linux日志默认存放位置：/var/log/
查看日志配置情况：more/etc/rsyslog.conf
Linux日志分析技巧 grep(egrep)、awk、sed文本编辑三剑客，可以按照用户的需求，过滤出用户有价值的信息
第一条：查找登录root账号失败的事件，从/var/log/secure文件中，只显示第11行信息(ip)，然后排序sort，去重计数，再排序，more分屏显示。
Web服务器日志(windows) Web服务器为例，其日志包括：安全日志、系统日志、应用程序日志、WWW日志、FTP日志等。eventvwr.msc打开事件查看器进行查看。
(1).安全日志文件:C:\WINDOWS\system32\config\SecEvent.Evt
(2).系统日志文件:C:\WINDOWS\system32\config\SysEvent.Evt
(3).应用程序日志文件:C:\WINDOWS\system32\config\AppEvent.Evt
(4).FTP日志默认位置:C:\WINDOWS\system32\Logfiles\MSFTPSVC1
(5).WWW日志默认位置:C:\WINDOWS\system32\Logfiles\W3SVC1
补充：
以上都是单机模式，如果架构比较大的时候，n台服务器，需要用一个log server统一管理日志。
ELK
logstash负责对日志进行过滤，Elasticsearch对日志处理，Kibana通过图像界面展示出来
图片非原创，视频学习时截取，方便自己查看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ef00435cef369797c492f49d07f6571/" rel="bookmark">
			前端免费API接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要是统计前端可以免费使用的API接口信息，商用（不以盈利为目的）需缴费使用；反之，则可以免费使用，有些接口会有次数限制，会单独注明。
一、北京时间 1、便民查询接口(传送门) 1)、接口返回值 window.baidu_time({ "time": 1650790777162.8 }) 2)、示例代码 (function () { // 时间正则 年月日时分秒 // const TIME_FORMAT = "{0}-{1}-{2} {3}:{4}:{5}"; const TIME_FORMAT = "{0}\u5e74{1}\u6708{2}\u65e5 {3}:{4}:{5}"; // 北京时间为东八区时间，所以比格里尼治时间（世界时）早8个小时，即：北京时间 = 世界时 + 8小时 const TIME_ZONE = +8; // 更新日期时间定时器 let updateDateTimeTimer = null; // 将日期时间转为标准的日期时间 function formatTime(str, arr) { return str.replace(/{(\d)}/g, (value, index) =&gt; { return arr[index]; }); } // 前缀补零，默认数字不大于10的时候前面补零 function prefixZero(num, size = 10) { return num &lt; size ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ef00435cef369797c492f49d07f6571/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/002e1a8a48b9c19bd0c89f69aabe157e/" rel="bookmark">
			在 Ubuntu 上安装 Bazel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Ubuntu 上安装 Bazel 链接: https://github.com/bazelbuild/bazel
本页面介绍了在 Ubuntu 上安装 Bazel 的选项。 此外，它还提供指向 Bazel 完成脚本和二进制安装程序的链接（如果需要），例如，如果您没有管理员访问权限。
支持的 Ubuntu Linux 平台：
18.04 (LTS)
16.04 (LTS)
20.04（LTS）
Bazel 应该与其他 Ubuntu 版本和 Debian“stretch”及更高版本兼容，但未经测试，不能保证正常运行。
使用以下方法之一在 Ubuntu 上安装 Bazel：
建议：使用 Bazelisk
使用我们的自定义 APT 代码库
使用二进制安装程序
从源代码编译 Bazel
注意：对于基于 ARM 的系统，APT 代码库不包含 arm64 版本，也没有可用的二进制文件安装程序。请使用 Bazelisk ，或从源代码进行编译。
Bazel 附带两个完成脚本。安装 Bazel 后，您可以执行以下操作：
访问 bash 完成脚本
安装 zsh 完成脚本
第 1 步：添加 Bazel 分发 URI 作为软件包源 使用 Bazel 的 apt 代码库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/002e1a8a48b9c19bd0c89f69aabe157e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b547ab9835182e1366ad8f2e5eb76ab3/" rel="bookmark">
			几款常用的Git图形化工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几款常用的Git图形化工具 独立客户端工具GitHub for DesktopSource TreeTortoiseGit IDE集成的Git客户端XcodeEclipse – EgitVisual Studio – Git Integration &amp; GitHub ExtensionVisual Studio Code 原文链接 作为一名开发人员，你不可能不知道git，无论你是开发自己的开源项目还是和团队一起进行大规模产品的开发，git都已经是源代码管理工具的首选。当然，那些hardcore developer会说，command line才是最好的工具，但并不是所有的时候command line都是高效的（不服？在command line里面做个compare试试你就知道了）。小编日常用的最多的也是command line，但是总还是会把几个好用的GUI Git客户端放在手边备着。
独立客户端工具 GitHub for Desktop 全球开发人员交友俱乐部提供的强大工具，功能完善，使用方便。对于使用GitHub的开发人员来说是非常便捷的工具。界面干净，用起来非常顺手，上面的这条timeline非常漂亮，也可以直接提交PR。
唯一让我失望的是GitHub for Desktop不带三方合并工具，你必须自己手动解决冲突才可以。
免费同时支持 Windows 和 Mac：对于需要经常在不同的操作系统间切换的开发人员来说非常方便漂亮的界面：作为每天盯着看的工具，颜值是非常重要的支持Pull Request：直接从客户端提交PR，很方便Timeline 支持：直接在时间线上显示每次提交的时间点和大小支持git LFS：存储大文件更加节省空间和高效不支持三方合并：需要借助第三方工具才行 Source Tree SourceTree是老牌的Git GUI管理工具了，也号称是最好用的Git GUI工具。我的体验是确实强大，功能丰富，基本操作和高级操作都设计得非常流畅，适合初学者上手。
这个工具很有特色的一个功能就是支持Git Flow，你可以一键创建Git Flow的工作流。Git Flow是非常高效的团队协作模型和流程，Git的一大特色就是灵活轻量的分支，但如何在自己的团队中用好这个功能来匹配自己的研发流程是个问题。内置Git Flow让那些不太熟悉的开发人员也可以很快上手，并且将研发的业务流程固化在工具中，可以说是非常贴心的设计。
在 Windows 环境下，SourceTree是多语言的，但是不知道为什么我的Mac版总是显示英文。
免费功能强大：无论你是新手还是重度用户，SourceTree 都会让你觉得很顺手。对于非常重度用户，Source Tree还支持自定义脚本的执行同时支持 Windows 和 Mac 操作系统同时支持 Git 和 Mercurial 两种 VCS内置GitHub, BitBucket 和 Stash 的支持：直接绑定帐号即可操作远程repo TortoiseGit 对这只小乌龟估计没有开发人员会不认识，SVN的超广泛使用也使得这个超好用的Svn客户端成了几乎每个开发人员的桌面必备软件。小乌龟只提供Windows版本，提供中文版支持的，对于中国的开发者来说者绝对是福音。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b547ab9835182e1366ad8f2e5eb76ab3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06fa7c0bb2f36ae5d12ff9a004204373/" rel="bookmark">
			node npm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm warn config global --global, --local are deprecated. use --location=global instead.
问题出现在，以前版本npm的命令一般时XXX -g 但是随着版本更替，这个老方法被弃用了，这时我们需要修改两个文件npm和npm.cmd
修改完成后，重新打开cmd,npm -v就不会报错了(如果还报错，可以尝试重启电脑一下)
但是， 在使用npm一些常用命令时，使用XXX -g 还是会报错，这是由于高版本-g命令已经被弃用，所以应该使用现有方法XXX --location=global
其实报错内容就告诉我们了，npm WARN 配置全局 ‘–global’， ‘–local’ 已弃用。
请改用“–location=global”。
例如：
npm install express -g
npm install express --location=global //安装常用express模块
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81d22a9096229de565c8b12d318787e5/" rel="bookmark">
			M1 MacBook安装LGB，报错：‘/usr/lib/libomp.dylib‘ (no such file)的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pip install lightgbm
jupyter lab的notebook中执行
会报错OSError: dlopen(/Users/lihuilong/opt/anaconda3/lib/python3.9/site-packages/lightgbm/lib_lightgbm.so, 0x0006): Library not loaded: '/usr/local/opt/libomp/lib/libomp.dylib' Referenced from: '/Users/lihuilong/opt/anaconda3/lib/python3.9/site-packages/light
import lightgbm as lgb lgb_classifier = lgb.LGBMClassifier() 看了很多教程都不太能用，还修改了PATh路径下载。
最后用虚拟conda环境中重新安装才可以使用。
conda install lightgbm import lightgbm as gbm
摘自：【老码农随心记】Mac安装LGB，报错：'/usr/lib/libomp.dylib' (no such file)的解决办法 - 腾讯云开发者社区-腾讯云
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7870929eef6ababb92f92f0dfc5a63f1/" rel="bookmark">
			【Bug解决】yum提示Another app is currently holding the yum lock； waiting for it to exit...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 通过CentOS 7 ✖64位系统安装软件包
问题描述 今天想要尝试通过centos 7来制作一个小游戏,结果安装相应软件包时出现报错
出现的问题是：“Another app is currently holding the yum lock; waiting for it to exit...”
这句话的意思就是有一个应用程序正在锁定yum，等待退出
yum命令报错代码：
Another app is currently holding the yum lock; waiting for it to exit... 另一个应用程序是：PackageKit 内存： 31 M RSS （451 MB VSZ） 已启动： Wed Aug 17 09:08:40 2022 - 00:59之前 状态 ：睡眠中，进程ID：2833 解决办法:1|rm -f /var/run/yum.pid 然后重新运行yun命令即可 原因分析： 可能是系统自动升级正在运行，yum在锁定状态中，要等待那个进程结束退出:
看报错的那一段话：
Another app is currently holding the yum lock; waiting for it to exit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7870929eef6ababb92f92f0dfc5a63f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23258edd0b88654c85616091deb43f0d/" rel="bookmark">
			腾讯云http域名升级为https
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：
在学习做微信小程序开发的过程中，在本地开发完成后需要把小程序部署上线。将小程序部分上传至服务器后，同时小程序内部调用的后端服务接口也需要部署到自己的云服务器上。早就了解到小程序调用后端服务接口不能通过IP去调用，还需要用到域名。有了域名还不行，你还需要在小程序开发中平台中-开发设置-服务器域名 中配置request 合法域名。配置时候你会发现，不经需要域名，而且还需要https 开头的域名。于是只能将腾讯云http域名升级为https；
准备：
腾讯云http域名、SSL证书、Nginx服务器。
过程：
1，腾讯云平台内购买的.cn 域名；
在腾讯云平台内-我的域名，找到指定域名后添加解析（即将域名映射到你的服务器IP，从此访问域名访问你的服务器了）
2，下载SSL证书；
通过网上搜索可以找到其他下载免费证书的地方进行证书的下载，
我就在腾讯云平台内搜索【我的证书】进行了免费证书的申请，有效期1年的。按照提示步骤完成证书的申领；
3，证书的部署安装
腾旭云平台内 ：文档中心 &gt; SSL 证书 &gt; 证书安装 &gt; 一键 HTTPS
找到SSL证书安装部署。我选择的是通过Nginx 安装。
腾讯云 Nginx 服务器 SSL 证书安装部署官方文档教程
将免费申领的证书下载下来，上传至服务器后解压；参照文档进行Nginx 配置文件的修改；启动Nginx服务器，即可通过Https 访问；（https默认端口为443）启动或者验证配置的过程中可能会出现错误，复制错误信息网上都能找到解决办法。常见错误为 未安装ssl模块； 贴上本人的Nginx配置：
server { #listen 80; #server_name localhost; #SSL 默认访问端口号为 443 listen 443 ssl; #请填写绑定证书的域名 server_name codelead.cn; #请填写证书文件的相对路径或绝对路径 ssl_certificate /usr/local/nginx/data/codelead.cn_nginx/codelead.cn_bundle.crt; #请填写私钥文件的相对路径或绝对路径 ssl_certificate_key /usr/local/nginx/data/codelead.cn_nginx/codelead.cn.key; ssl_session_timeout 5m; #请按照以下协议配置 ssl_protocols TLSv1.2 TLSv1.3; #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / { root /home/ruoyi/projects/ruoyi-ui/dist; try_files $uri $uri/ /index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23258edd0b88654c85616091deb43f0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82e7b38334d0f81966495231a77e7578/" rel="bookmark">
			kvm学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KVM 1、 虚拟化技术分类 1 平台虚拟化
2 资源虚拟化
3 应用程序虚拟化
2、 平台虚拟化技术分类 虚拟机中运行的操作系统为guest os，运行虚拟机监控器的操作系统称之为host os。运行虚拟机的真实系统称之为主机系统。 1、操作系统级虚拟化
openvz:最便宜的vps平台。共用宿主机的内核。
2、部分虚拟化
vmm只模拟部分底层硬件
3、全虚拟化
模拟了完整的底层硬件，包括处理器、物理内存、时钟、外设等。（特权CR3寄存器）
4、超虚拟化
是一种修改guest os部分访问特权状态的代码以便直接与vmm交互的技术。部分硬件接口以软件的形式提供给客户机操作系统，通过hypercall的方式提供。
5、硬件辅助虚拟化
借助硬件的支持来实现搞笑的全虚拟化。
3、 KVM 架构 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vTugjA7E-1660663650853)(C:\Users\heistester\Desktop\kvm.png)]
4、 KVM架构解析 kvm针对运行在x86硬件上的、驻留在内核中的虚拟化基础结构。KVM是作为内核模块实现的，只要linux加载该模块就会成为一个hypervisor。 5、 KVM软件安装 1、查看cpu是否支持vt技术 cat /proc/cpuinfo | grep -E ‘vmx|svm’
2、卸载kvm yum remove rpm -qa |egrep 'qemu|virt|KVM' -y
rm -rf /var/lib/libvirt/ /etc/libvirt/
3、安装软件 yum install -y qemu virt librbd1-devel
qemu-KVM: 主包
libvirt：API接口
virt-manager: 图形化管理程序
kvm技术，应用到qemu+kvm kvm负责cpu虚拟化+内存虚拟化，实现了cpu和内存的虚拟化，但不能模拟其他设备 qemu是模拟IO设备（网卡+磁盘...）。 libvirt是调用kvm虚拟化技术的接口管理工具。 4、启动服务 systemctl start libvirtd
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82e7b38334d0f81966495231a77e7578/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8fdaa5597e1df72f46126df012cf074/" rel="bookmark">
			Java基础知识----字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建字符串 1、声明字符串
在Java语言中的字符串必须在一对“ ”（双引号）之内。
例如：
"33"、"Hello"、"世界"
2、创建字符串
String类即字符串类型，并不是Java的基本数据类型，但可以像基本数据类型一样使用，用双引号括起来进行声明。
（1）String（char a[]）用数组创建字符串
char arr[]={'n','b','a'}; String str=new String(arr); //以上操作相等于 String str=new String("nba"); （2）String（char a[],int offset,int length）提取字符数组
offset开始提取字符的位置，length提取字符的长度。
char arr[]={'a','b','c','d','e','f',g}; String str=new String(arr,2,4); //以上操作相等于 String str=new String("cdef"); （3）String str="value" String str=new String("abcd"); 二、连接字符串 1、连接多个字符串
使用“+”运算符可完成对多个字符串连接的功能。
String str1="aa"; String str2="bb"; String str=str1+str2; System.out.println(str); //输出结果：aabb 2、连接其他数据类型
字符串也可同其他基本数据类型进行连接。
String str1="葫芦娃"; int i=7; String str2="兄弟"; System.out.println(str1+i+str2); //输出结果：葫芦娃7兄弟 三、获取字符串信息 1、获取字符串长度
使用String类的length()方法可获取声明的字符串对象的长度。
语法如下： str.length();
String str1="Hello World"; int str=str1.length(); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8fdaa5597e1df72f46126df012cf074/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cffde95eb35cef47c4404dce44f43c9/" rel="bookmark">
			字符串与base64相互转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // btoa()：字符串或二进制值转为Base64编码 // atob()：Base64编码转为原来的编码 // 字符串转base64 export function baseToa(str) { // 对字符串进行编码 var encode = encodeURI(str) // 对编码的字符串转化base64 var base64 = btoa(encode) return base64 } // base64转字符串 export function strTob(base64) { // 对base64转编码 var decode = atob(base64) // 编码转字符串 var str = decodeURI(decode) return str } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30a5144d4cde7b52602dc553dfee5fa9/" rel="bookmark">
			前端解决百度地图地址逆解析（BMap.Geocoder()）异步问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端解决百度地图地址逆解析（BMap.Geocoder()）异步问题 需求：将接口返回的坐标数据转换成详细的地址并渲染在页面上 问题：页面先渲染，地址后解析，导致渲染时没有数据显示 解决方法：new Promise() // 处理导出轨迹明细地址解析异步操作 getPosition(data) { return new Promise((resolve, reject) =&gt; { const temp = {}; let point = new BMap.Point(data.longitude, data.latitude); let geoc = new BMap.Geocoder(); geoc.getLocation(point, (result) =&gt; { let addr = result.addressComponents; var full_address = addr.city + addr.district + addr.street + addr.streetNumber; temp.position = full_address; return resolve(temp); }); }); } 在想要获取转换后的地址数据的地方调用
exportFu() { var params = { imei: this.imei, start_time: start, end_time: end, }; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30a5144d4cde7b52602dc553dfee5fa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e25e0d29a5543a042497d54ee85531/" rel="bookmark">
			io,nio,aio总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I/O简介 I/O（Input/Outpu） 即输入／输出 。
我们先从计算机结构的角度来解读一下 I/O。
根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。
输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。
输入设备向计算机输入数据，输出设备接收计算机输出的数据。
从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。
我们再先从应用程序的角度来解读一下 I/O。
根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 用户空间（User space） 和 内核空间（Kernel space ） 。
像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。
并且，用户空间的程序不能直接访问内核空间。
当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。
因此，用户进程想要执行 IO 操作的话，必须通过 系统调用 来间接访问内核空间
我们在平常开发过程中接触最多的就是 磁盘 IO（读写文件） 和 网络 IO（网络请求和响应）。
从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。
当应用程序发起 I/O 调用后，会经历两个步骤：
内核等待 I/O 设备准备好数据内核将数据从内核空间拷贝到用户空间。 同步/异步，阻塞/非阻塞 同步和异步关注的是消息通信机制.
同步是指: 发送方发出数据后, 等待接收方发回响应后才发下一个数据包的通讯方式. 就是在发出一个调用时, 在没有得到结果之前, 该调用就不返回, 但是一旦调用返回, 就得到返回值了. 也就是由"调用者"主动等待这个"调用"的结果.
异步是指: 发送方发出数据后, 不等待接收方发回响应, 接着发送下个数据包的通讯方式.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89e25e0d29a5543a042497d54ee85531/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d826e9ca73820dc6a82503be1b6c125a/" rel="bookmark">
			Docker轻量级可视化工具Portainer汉化教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Portainer 的主要用途与介绍 Portainer 是一个用于管理容器化应用程序的开源工具。它在数据中心和边缘与Kubernetes、Docker、Docker Swarm、Azure ACI一起使用。
Portainer 消除了与编排器相关的复杂性，因此任何人都可以管理容器。它可用于部署和管理应用程序、观察容器的行为并提供广泛部署容器所需的安全性和治理。
Portainer CE（开源）受到全球超过 500,000 名用户的信赖。Portainer Business建立在开源基础之上，使组织能够大规模运行容器化应用程序，而无需雇用新人员或重新培训现有团队。
2.汉化过程 1.创建 portainer 工作目录 mkdir -p /data/portainer/data /data/portainer/public 2.进入Portainer文件夹 cd /data/portainer 3.下载汉化文件 wget https://labx.me/dl/4nat/public.zip 网盘下载：https://pan.baidu.com/s/1SJSB732KZOFjrpkARxYpMw?pwd=1q0l
提取码：1q0l
4.解压汉化文件 unzip public.zip 5.安装Portainer docker run -d --restart=always --name portainer -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /data/portainer/data:/data -v /data/portainer/public:/public portainer/portainer:latest 或者
docker run -d -p 8000:8000 -p 9000:9000 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer 本文结束，Good Luck
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d109471c13c602404c7b56c68e6eb4a7/" rel="bookmark">
			软件设计师备考笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.程序设计语言 1.1后缀表达式 1.已知中缀式（a-b）*c+d,求后缀式，可以用二叉树表示
​ 中缀表达式对应中序遍历，后缀式对应后序遍历
2.逻辑与运算优先级高于逻辑或运算
1.2传值与传址 1.传值：将实参的值传递给形参，实参可以是表达式（常量），也可以是变量（或数组元素），这种传递时单方向的，形参不能再将值传回给实参
2.传址：将实参的地址传给形参，实参必须是变量（数组名或数组元素），不能是表达式（常量），被调用函数中对形式参数的修改实际上就是对实际参数的修改，因此客观上可以实现数据的双向传递
1.3中间代码 1.中间代码的表达形式有语法树，后缀式，三地址代码
2.计算机组成与体系结构 2.1中断向量 1.中断向量提供中断服务程序入口地址，中断向量表：用来保存歌个中断源的中断服务程序的入口地址
2.2层次化储存体系 1.DRAM:动态随机存取器存储器，又叫主存，是与CPU直接交换数据的内部存储器。它可以随时读写（刷新时除外)，而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储媒介，通过周期性刷新来保持数据的存储器件，断电丢失。
SRAM:静态随机存取器存储器，静态随机存取存储器是随机存取存储器的一种。所谓的”静态"，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。
FLASH:闪存，特性介于EPROM和EEPROM之间，类似于EEPROM，也可以使用电信号进行信息的擦除操作。整块闪存可以在数秒内删除。
EEPROM:电擦除可编程的只读存储器，于EPROM相似，EEPROM中的内容既可以读出，也可以进行改写。
2.3CISC与RISC 1.RISC适合流水线，精简指令集系统计算机简称，使用简单的指令，多寄存器寻址，在实现过程中增加通用寄存器，采用硬布线逻辑（组合逻辑控制器）
2.CISC不适合流水线，复杂指令，不需要采用很多通用寄存器，采用微码（微程序）实现
3.信息安全 3.1防火墙 1.包过滤防火墙工作在网络协议IP层，它只对IP包的源地址、目标地址及相应端口进行处理，因此速度比较快，能够处理的并发连接比较多，缺点是对应用层的攻击无能为力，包过滤成本与它的安全性能没有因果关系，而应用程序和用户对于包过滤的过程并不需要了解，因此该技术对应用和用户是透明的。
2.代理服务器防火墙将收到的IP包还原成高层协议的通讯数据，比如http连接信息，因此能够对基于高层协议的攻击进行拦截。缺点是处理速度比较慢，能够处理的并发数比较少，所以不能提高网络整体性能，而代理对于用户认证可以设置。
3.数字签名是对签名真实性的保护
3.2网络攻击 1.DoS是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络带宽攻击和连通性攻击。举例：街头的餐馆是为大众提供餐饮服务，如果一群地痞流氓要DoS餐馆的话，手段会很多，比如霸占着餐桌不结账，堵住餐馆的大门不让路，骚扰餐馆的服务员或厨子不能干活，SYN Flooding攻击便是Dos攻击的典型代表，该攻击以多个随机的源主机地址向目的路由器发送SYN包，而在收到目的路由器的SYNACK后并不回应，这样，目的路由器就为这些源主机建立了大量的连接队列，而且由于没有收到ACK一直维护着这些队列，造成了资源的大量消耗而不能向正常请求提供服务，甚至导致路由器崩溃。服务器要等待超时(Time Out)才能断开已分配的资源。
2.特洛伊木马：寄宿在计算机里的一种非授权的远程控制程序
4.软件工程 4.1软件维护相关概念 1.在软件外部，可以用MTTR来度量软件的可维护性，它指出处理一个有错误的软件需要花费的平均时间。如果用M表示可维护性指标，那么M=1/(1+MTTR)。MTTF(1+MTTF)一般用来表示可靠性或可用性指标。MTBF/(1+MTBF)用来度量可用性
2.MTTF(平均失效前时间) MTTR（平均恢复前时间）MTBF（平均失效间隔时间
4.2黑盒测试 1.测试用例不能同时覆盖俩个无效等价类
2.测试用例应尽可能多地覆盖尚未被覆盖的有效等价类，重复至所有有效等价类都被覆盖为止
4.3软件质量保证 1.McCall软件质量模型从软件产品的运行、修正和转移三个方面确定了11个质量特性，其中运行方面包含了正确性、可靠性、效率、完整性、使用性这些质量特性。修正方面包含了维护性、测试性、灵活性这3个质量特性。转移方面包含了维护性移植性、复用性、共运行性这3个质量特性。
2.[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jpFr22LT-1660637583639)(C:\Users\OMEN\AppData\Roaming\Typora\typora-user-images\image-20220420173300336.png)]
4.4 模块结构图 1.由模块，调用，数据，控制信息，和转接符号组成
4.5 软件容错技术 冗余技术一般包括时间冗余，信息冗余，结构冗余，冗余附加技术，结构冗余按照工作方法可以分为静态，动态和混合冗余
4.6 内聚性 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0Grkhm5A-1660637583640)(C:\Users\OMEN\AppData\Roaming\Typora\typora-user-images\image-20220524201057676.png)]
4.7 耦合性 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-YreeroxQ-1660637583641)(C:\Users\OMEN\AppData\Roaming\Typora\typora-user-images\image-20220525203134051.png)]
5.数据结构与算法基础 5.1排序 1.插入排序比较适合在数列基本有序时
2.计数排序对于整数排序复杂度低，快于任何比较排序算法
5.2二叉树的遍历 1.先序遍历：根左右， 中序遍历：左根右，后序遍历：左右根
2.平衡二叉树：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
3.完全二叉树：二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层从右向左连续缺若干结点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d109471c13c602404c7b56c68e6eb4a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a2b888c253c484c699e51b601de4ac/" rel="bookmark">
			cacti断图-流量大/超过10G
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在工作中出现了cacti 断图的情况，开始以为是设备返回数据的问题，安装snmpwalk进行了测试
1 填写脚本进行接口数据读取
#/bin/bash ############################################### #这是一个测试cacti数据读取的脚本 #基于cacti的原理15s读取一次接口的数据，获取两者之间的差值 #by px 2022-08-16 ################################################ while true comm=$1 #echo $comm do num1=`$comm | awk -F ":" '{print $4}' | awk -F " " '{print $1}'` sleep 15 num2=`$comm | awk -F ":" '{print $4}' | awk -F " " '{print $1}'` end=`expr $num2 - $num1` echo `expr $end \* 8 / 1000000 / 15` "Mbps" # / 8 byte to bit /15 time 15 s avg done 脚本使用案例 [root@cactifans ~]# .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01a2b888c253c484c699e51b601de4ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beb9f7b1244f25775236ef15f111ba40/" rel="bookmark">
			路径xxx 超过 OS 最大路径限制。完全限定的文件名必须少于 260 个字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误 MSB3491 未能向文件“obj\Debug\net5.0\xxx”写入命令行。路径: obj\Debug\net5.0\xxx 超过 OS 最大路径限制。完全限定的文件名必须少于 260 个字符。 xxx C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\MSBuild\Current\Bin\Roslyn\Microsoft.Managed.Core.targets 150
此问题是由于 Windows 操作系统对处理长度大于 260 的长路径的限制引起的。VS2019 的此问题的解决方案非常简单。
VS 2019此问题解决方案：
打开 run 窗口（windows-key + r），然后输入 regedit 并按 Enter。在注册表编辑器的地址栏中，输入：HKLM\SYSTEM\CurrentControlSet\Control\FileSystem在右侧，找到键 LongPathsEnabled，双击它，将值从 0 更改为 1重新启动 VS2019，清理（如果需要）并再次构建您的项目。应该修复错误。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f02c37528458269714f798d1ee8f5730/" rel="bookmark">
			join()、park()、yield()会不会释放当前线程持有的锁？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/kitor/p/14724244.html
stop()、suspend()、Thread.sleep()都不会释放线程所持有的锁。但join()、park()、yield()会不会释放当前线程持有的锁？下面通过一些实例来验证一下
代码如下
import java.util.Date; import java.util.concurrent.TimeUnit; import java.util.concurrent.locks.LockSupport; public class ThreadLockTest { public static void main(String[] args) throws InterruptedException { // yieldTest(10); // parkTest(); // joinTest(); } /** * 测试yield会不会释放锁：yield调用的是本地方法，建议seconds设置大一些结果更明显 * 结论：yield不会释放线程持有的锁 * * @param seconds */ private static void yieldTest(int seconds) { String lock = "lock"; //首先执行并获得锁 Thread preThread = new Thread() { @Override public void run() { synchronized (lock) { log("=============获取了锁=============="); long start = System.currentTimeMillis(); while (true) { //将让出当前线程的执行权，线程状态由RUNNING ----&gt; RUNNABLE log("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f02c37528458269714f798d1ee8f5730/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6af4ac3093eed49ae0f0e2573a2ca7f/" rel="bookmark">
			PDF转Excel（PS：学习使用VBA处理Excel）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天接到一个任务要将pdf中的表格转成excel，打开一看pdf有一百多页，看来手打是不可能了，只能想办法处理。
由于我拿到的PDF是这样的，第一步先把PDF转成word形式，我这里使用的是Adobe Acrobat，也可以使用wps等软件，转换完后效果如下：
发现还有个小问题，就是每页都有个大水印，这个水印由于是从pdf中转换来的，不是word里添加的，所以在word中关闭水印并不能处理这个问题。
双击水印发现其实是艺术字，学习网上方法采用VBA编写宏批量删除艺术字，代码如下：
Sub 删除艺术字() Dim sh As Shape For Each sh In ActiveDocument.Shapes If sh.Type = msoTextEffect Then sh.Delete End If Next End Sub 具体使用方法是点击视图-宏，然后在弹出的窗口中点创建，点完就会弹出VBA的编辑器，将代码粘进去即可，使用宏的时候在刚才点创建的窗口点执行即可。
艺术字就顺利删除了（ps：可能会有个别骨骼惊奇的艺术字没被删掉，多执行几遍还没被删掉的智只能手动删除）
下一步是将word中的表格转换成Excel，我们先将word保存成mht格式，点击文件-另存为，在弹出的窗口保存类型选择单一文件网页。
之后在保存的位置就有这个文件了，下一步打开Excel，点击文件-打开，打开刚才我们保存的mht文件，将表格选中复制，粘贴到新的Excel文件中，效果如下：
发现效果非常不好啊，一个格子里面由很多小格，格子里的一段话还分布在不同小格里，直接合并单元格会只保留最左上单元格的内容，同一个格子里的一段话势必会缺失很多，如果人工操作不知道要搞到猴年马月。
因此我把目光转向了宏，之前从没用过宏，经过网上学习，写出了第一个宏，可以将选中区域合并单元格的同时内容全部保留拼接起来
Sub 合并() Application.DisplayAlerts = False '关闭提醒 SelectionSum = "" For Each cell In Selection '遍历选取区域的单元格 SelectionSum = SelectionSum &amp; cell.Value '将单元格内容拼接起来 Next cell Selection(1, 1).Value = SelectionSum '将拼接后内容赋值给单元格 Selection.Merge '合并 Application.DisplayAlerts = True '开启提醒 End Sub 在Excel中使用宏比Word复杂些，第一次使用首先要点击文件-选项-自定义功能区，然后在右边勾选开发工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6af4ac3093eed49ae0f0e2573a2ca7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2986105a8d4355ce18c5fd89a87885e9/" rel="bookmark">
			Java 堆空间(Heap Space)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 堆空间(Heap Space) 概述 在Java程序中，堆是JVM内存空间中最大的一块，同时我们知道，每个线程都拥有一个虚拟机栈，但是堆不同，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。
在《Java虚拟机规范》中对Java堆的描述是：“所有 的对象实例以及数组都应当在堆上分配“，但是实际情况是几乎所有的对象都是分配在堆空间的，也有少部分情况比较特殊。这是因为由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换优化手段已经导致一些微妙的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。
《Java虚拟机规范》里对Java堆进行了更进一步的细致划分：“Java虚拟机的堆内存分为新生代、老年代、永久代、Eden、Survivor……”，并且会根据区域的不同设计不同的垃圾回收期(GC)。
总结一下要点：
一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。
Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，堆是JVM管理的最大一块内存空间，并且堆内存的大小是可以调节的。
《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。
所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，简称 TLAB）。
《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。
从实际使用角度看：“几乎”所有的对象实例都在堆分配内存，但并非全部。因为还有一些对象是在栈上分配的（逃逸分析，标量替换） 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。
在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
也就是触发了GC的时候，才会进行回收
如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word
堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。
Java堆空间结构 存储在JVM中的Java对象可以被划分为两类：
一类对象的生命周期较短，这种对象的创建和消亡都十分迅速另一类对象的生命周期很长，在某些极端情况下甚至可以和JVM的生命周期保持一致 Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）
其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）
在默认的情况下(可以根据实际情况修改设置)，新生区占堆空间的三分之一，老年代占堆空间的三分之二。在HotSpot中，Eden区空间和其他两个Survivor区空间的默认比例是 8 : 1 : 1。同时开发人员可以通果设置选项-XX:SurvivorRatio调整这个空间的比例。大部分对象都是在Eden区中被创建出来的。绝大多数的Java对象都在新生代中销毁(朝生暮死) 对象分配过程 对象分配是一个严谨且复杂的过程， 设计者需要考虑内存的分配，以为实际的分配与垃圾回收算法密切相关。
流程说明：
创建出的新对象正常先放到Eden区，但是要判断Eden空间是否足够。 如果足够，就放入Eden区。如果Eden区空间不足，会对Eden区进行垃圾回收(Minor GC)，将伊甸区中不被引用的对象进行销毁操作，将新创建的对象放入Eden区。同时将Eden区存活的对象移动到Servivor0区 如果之后触发垃圾回收机制，在Servivor0区中存活的对象会放到Servivor1区中，在经历垃圾回收机制Servivor1区存活的对象就在移动到Servivor0区，同时对象有一个"年龄"就是经历垃圾回收的次数，当经历过15次GC时，就会将这个对象移动到Old区。对于S0和S1区来讲：复制有交换，谁空谁是to如果Eden区内经历过GC后存活下来的对象转移到Servivor区，但是Servivor存放不下，就将这个对象移动到Old区在Old区，GC的次数相对少一些，当Old区不足时进行Major GC。如果进行了Major GC后仍然无法将对象进行储存，就会报OOM 流程图：
关于GC的说明(Minor GC、Major GC、Full GC) JVM的调优的一个环节，也就是垃圾收集GC，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（Stop the World）的问题，而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上。JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC） 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为： 新生代收集（Minor GC/Young GC）：只是新生代（Eden，s0，s1）的垃圾收集老年代收集（Major GC/Old GC）：只是老年代的圾收集。目前，只有CMS GC会有单独收集老年代的行为。注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为 整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。 MinorGC 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满。Survivor满不会主动引发GC，在Eden区满的时候，会顺带触发s0区的GC，也就是被动触发GC（每次Minor GC会清理年轻代的内存）因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。Minor GC会引发STW（Stop The World），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行 Major/Full GC 指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了出现了MajorGC，经常会伴随至少一次的Minor GC。（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程） 也就是在老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足，则触发Major GC Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。如果Major GC后，内存还不足，就会报OOM Major GC通常是跟full GC是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是old GC。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2986105a8d4355ce18c5fd89a87885e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d50d9179918ae230e2af08d50178e954/" rel="bookmark">
			Matlab simulink 代数环问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 最近在仿真中遇到报错，提示存在代数环
无法求解涉及 'Unknown_Extrinsic_Parameters/Subsystem2/vel_controller/v,w' 的代数环，因为它包含不能向其分配代数变量的模块，例如具有离散值输出的模块、具有非双精度或复数输出的模块、Stateflow 模块或非虚拟子系统。请考虑打破代数环。例如，向代数环中添加一个 Delay 或 Memory 模块。要查看有关代数环的更多详细信息，请使用命令 Simulink.BlockDiagram.getAlgebraicLoops(bdroot) 原因分析： 代数环的概念：代数环概念 - MATLAB &amp; Simulink - MathWorks 中国
简而言之：当模块计算输出时，需要用到输入，而输入却是自身的输出（尚未计算）。此时，Simulink 会通过迭代计算模块的输出，并获得正确的结果。
例如：
t=0.时计算y（0）需要y（0）和u（0），但是很显然y（0）此时没有值，因此程序自然会报错。
解决方案： 经过广泛查阅得知有以下几种解决方案：
参考：代数环（algebraic loop）是什么？在 Simulink 中如何解决？ – MATLAB中文论坛 (ilovematlab.cn)
如何解决simulink中的代数环问题 – MATLAB中文论坛 (ilovematlab.cn)
1，修改、重新建模模型，通过数学变换，使得避免出现代数环。（未尝试，仿真模型过于复杂难以修改）
2，增加延时环节，simulink中有delay与memory两个模块可以实现此功能。但是有人建议不要用memory打破代数环（）
Why you should never break a continuous algebraic loop with a Memory block » Guy on Simulink - MATLAB &amp; Simulink (mathworks.com)
3，给定变量初始值。如上述例子所说，只要有了y（0）的初始值，那么程序正常计算，打破代数环。使用IC模块，或者有积分环节时指定积分起始值也可以。
IC：设置信号的初始值 - Simulink - MathWorks 中国
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cec31099956d1e1802f8ad778a9ab32f/" rel="bookmark">
			容器中运行pytest报错：ImportError: cannot import name ‘resultlog_key‘ from ‘_pytest.resultlog‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pytest在容器里运行时候一直报错_pytest.resultlog
网上几乎所有文章都说是pytest-rerunfailures和pytest版本的问题（其实是ModuleNotFoundError: No module named ‘_pytest.resultlog’ ），但是显然和本文的报错不是同一个，如下
我重装了很多个版本的pytest和pytest-rerunfailures都不行
但是考证了一下，6.1.0版本中确实删除了_pytest.resultlog
https://githubmemory.com/repo/pytest-dev/pytest-rerunfailures/issues/128
大概率问题原因也相似
于是尝试手动卸载pytest，发现卸载后site-packages/_pytest/resultlog.py仍然存在
尝试删除这个文件后，原因找到了：
所用的镜像中原本是低版本的pytest，这一版中有_pytest/resultlog.py这个文件，然而升级pytest后这个本应该被删除的文件不知道什么原因被保留了下来，而pytest-rerunfailures则误认为找到了_pytest/resultlog.py这个文件，调用过程中报错cannot import name ‘resultlog_key’
解决方法
镜像生成时，卸载一次pytest即可，这样原本的镜像里就不存在低版本的pytest了，也就没有_pytest/resultlog.py这个文件，然后直接装高版本的pytest即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b99c5d4502458bcd05aa5c1c2f83a9ca/" rel="bookmark">
			MobaXterm安装使用设置快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MobaXterm MobaXterm简介 MobaXterm是进行远程计算的终极工具箱。在单个Windows应用程序中，它提供了为程序员，网站管理员，IT管理员以及几乎所有需要以更简单的方式处理远程作业的所有用户量身定制的功能。
MobaXterm为Windows桌面提供了所有重要的远程网络工具（SSH，X11，RDP，VNC，FTP，MOSH等）和Unix命令（bash，ls，cat，sed，grep，awk，rsync等）。可直接使用。
MobaXterm是程计算的终极工具箱。里面集合了SSH等远程网络工具和Unix命令。
官网: https://mobaxterm.mobatek.net/
MobaXterm的下载 (1)输入官网网址访问
(2)点击get MobaXterm下载
(3)选择免费版下载
(4)安装完运行MobaXterm
二. MobaXterm的使用 1.使用ssh安全连接主机 界面连接 (1)定义要连接主机的账户和密码
(3)连接成功
命令连接 通过ssh命令，远程访问Linux系统：输入命令ssh hank@192.168.241.130
2.上传和下载文件 点击 (1)上传文件
(2)下载文件
//这个nginx包就下载到桌面了
拖拽 scp命令 从Windows上传文件到Linux虚拟机:
scp drives/g/1.txt 用户名hank@192.168.241.130:/home/hank/ 释义：拷贝当前windows的G盘下的1.txt文件，到远程linux系统hank的家目录中 从Linux虚拟机下载文件到windows:
scp hank@192.168.241.130:/home/hank/1.txt drives/g/ 释义：反过来，拷贝远程linux系统hank的家目录中1.txt文件，到当前windows的G盘下	3.其他功能 ssh：SSH是一种网络协议，广泛用于计算机之间的加密登录。
RDP：远程桌面协议 (RDP) ，用于终端服务器和终端服务器客户端之间的通信，可参考Windows上自带的远程桌面服务。
VNC：VNC(Virtual Network Computing)是虚拟网络计算机的缩写。VNC是一款优秀的远程控制工具软件，由著名的AT&amp;T 的欧洲研究实验室开发的。
FTP：文件传输协议（File Transfer Protocol，FTP）是用于在网络上进行文件传输的一套标准协议。
SFTP：sftp（Secure File Transfer Protocol）是一种安全的文件传送协议，是ssh内含协议，也就是说只要sshd服务器启动了，sftp就可使用，不需要额外安装，它的默认端口和SSH一样为22。
Serial：Serial串行接口通信，在单片机中很常用。File：打开保存在本地的终端链接文件。Shell：配置shell终端。
Browser：内嵌浏览器。
Mosh：Mosh表示移动Shell(Mobile Shell)，是一个用于从客户端跨互联网连接远程服务器的命令行工具。mosh连接中断不会导致当前正在执行的命令中断，这是ssh做不到的。
WSL：WSL适用于 Linux 的 Windows 子系统可让开发人员直接在 Windows 上按原样运行GNU/Linux 环境（包括大多数命令行工具、实用工具和应用程序），且不会产生传统虚拟机或双启动设置开销。
4. MobaXterm的常用设置及快捷键 快捷键 Ctrl+Shift+N	创建一个新的远程会话 F11	当前窗口进入全屏，再按F11退出全屏 Ctrl+Tab键：向右切换标签 Ctrl+Shift+Tab键：向左切换标签 设置字体大小 调整MobaXterm字体大小和字符集设置 保持SSH连接 MobaXterm 使用 ssh 直接连接远程主机，或者通过跳板机登陆远程服务器可能会出现一段时候不操作就会自动关闭连接。要解决这个过一会就断开连接的问题，我们需要在勾选 Setting 下的 SSH Keepalive 选项。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b99c5d4502458bcd05aa5c1c2f83a9ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/361bf875f8ecb275da19f83e619340c9/" rel="bookmark">
			docker容器Jar包jmap jstack使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入Jar包容器内 docker exec -it xxx /bin/bash 或
docker exec -it xxx /bin/sh 获取线程ID
jps 1 jar
573 Jps
jstack 1 1: Unable to get pid of LinuxThreads manager thread 原因：Docker 自1.10版本开始加入的安全特性。类似于 jmap 这些 JDK 工具依赖于 Linux 的 PTRACE_ATTACH,而是Docker自1.10在默认的seccomp配置文件中禁用了ptrace
解决方案
如果使用docker-compose启动容器,如下加入 cap_add即可
test: image: test.jar ports: - 8081:8081 cap_add: - SYS_PTRACE init: true 或
在启动命令行添加
docker run --init --cap-add=SYS_PTRACE ... 方案2、镜像安装tini，由它管理进程 Dockerfile中使用如下方式
RUN apk --update --no-cache add tini #利用ENTRYPOINT一定会执行的特点，将它作为PID=1托管进程 ENTRYPOINT ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/361bf875f8ecb275da19f83e619340c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d153ff03aa184098b8001da2a6a68f2e/" rel="bookmark">
			EasyExcel单字段自定义转换@ExcelProperty::converter无效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EasyExcel单字段自定义转换@ExcelProperty::converter无效 前提实体转换器调用 注意事项实体构造器声明实体属性命名规范源码分析 实现Converter接口实现Converter方法…… 本文仅总结了本人所经历、发现的注意事项，如果无法解决可留言，再进行补充 本文是基于EasyExcel v3.1.0分析的 前提 实体 实体按照官方文档（日期数字或者自定义格式转换）声明注解
转换器 实现Converter接口（一定要是com.alibaba.excel.converters.Converter因为别的框架也有Converter），实现“读Excel”convertToJavaData方法，“写Excel”convertToExcelData方法
public class CustomStringStringConverter implements Converter&lt;String&gt; { @Override public Class&lt;?&gt; supportJavaTypeKey() { return String.class; } @Override public CellDataTypeEnum supportExcelTypeKey() { return CellDataTypeEnum.STRING; } /** * 这里读的时候会调用 * * @param context * @return */ @Override public String convertToJavaData(ReadConverterContext&lt;?&gt; context) { return "自定义：" + context.getReadCellData().getStringValue(); } /** * 这里是写的时候会调用 不用管 * * @return */ @Override public WriteCellData&lt;?&gt; convertToExcelData(WriteConverterContext&lt;String&gt; context) { return new WriteCellData&lt;&gt;(context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d153ff03aa184098b8001da2a6a68f2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0de0f24751c216921bedab62cfb4eed9/" rel="bookmark">
			Observability：如何使用 Elastic Agents 把定制的日志摄入到 Elasticsearch 中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我之前的文章 “Observability：使用 Elastic Agent 来摄入日志及指标 - Elastic Stack 8.0”，我详细地描述了如何安装 Elasticsearch，Stack 及 Elastic Agents 来采集系统日志及指标。很多开发者可能会有疑问，在我们的实际使用中，我们更多的可能是需要采集定制的应用日志，而不是系统日志。那么在这个时候，我们该如何使用 Elastic Agents 来把这些日志摄入呢？在以前的系统中，我们可以使用如下的几种方式来采集日志：
我们可以直接使用 Beats 把数据传入到 Elasticsearch 中。对数据的处理，我们可以使用 Beats 的 processors 来处理数据，或者通过 Elasticsearch 集群的 ingest nodes 来处理数据。我们可以通过 Beats =&gt; Logstash =&gt; Elasticsearch。针对这种情况，我们可以分别在 Beats，Logstash 或者 Elasticsearch 集群的 ingest nodes 来处理数据。我们可以直接使用各种编程语言来直接向 Elasticsearch 集群进行写入。我们可以使用 Elasticsearch 集群的 ingest nodes 来处理数据。 在今天的文章里，我们来详细地描述如何使用 Elastic Agents 把应用中的定制日志摄入到 Elasticsearch 中并进行分析。在今天的演示中，我将使用如下测试环境：
我将使用 Elastic Stack 8.3 来进行安装并展示。
如何使用 Elastic Agents 把定制的日志摄入到 Elasticsearch 中
准备日志 为了方便，我们使用我之前的一个教程写的文章里的例子来生成日志。我使用 Python 应用来生成日志。请参考文章 “Beats: 使用 Filebeat 进行日志结构化 - Python”。我们按照如下的步骤在 Ubuntu OS 的机器上来运行应用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0de0f24751c216921bedab62cfb4eed9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/133/">«</a>
	<span class="pagination__item pagination__item--current">134/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/135/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>