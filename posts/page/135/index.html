<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d024445b7a8936620bd268b6d1faf20e/" rel="bookmark">
			【MXNet报错】OSError: libnccl.so.2: cannot open shared object file: No such file or directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方案 1.https://developer.nvidia.com/nccl/nccl-legacy-downloads
找到cuda 对应的NCCL版本，需要账号登录，我的是cuda11.2 +ubuntu20.04
&lt;Download NCCL 2.8.3, for CUDA 11.2, January 06,2021&gt;
&lt;Local installer for Ubuntu 20.04&gt; 下载.deb
sudo dpkg -i nccl-repo-对应版本.deb sudo apt update sudo apt install libnccl2=2.8.3-1+cuda11.2 libnccl-dev=2.8.3-1+cuda11.2（换成自己的版本） 参考链接 https://blog.csdn.net/weixin_45653647/article/details/116306628
https://blog.csdn.net/fyfugoyfa/article/details/124203296
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2877f58d04abbbd13ff456d488994dcf/" rel="bookmark">
			解决this.$refs调用方法为undefined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在开发中，经常会使用到this.$refs ，用来操作真实的DOM节点，实现父子组件的通信。
在近期的开发中，遇到了需要根据父组件中的点击事件调用子组件中的方法修改页面数据，在父组件初始化时要调用一次子组件的方法渲染页面，但给子组件绑定好ref属性后，使用this.$refs.XX调用子组件中的方法，显示该方法为undefined。
&lt;PollutionMap ref="pollutionMap" v-if="level" :pointArea="problemData" @initData="initMapData" :problemData="problemData" @toLevel="toLevelFn" &gt;&lt;/PollutionMap&gt; this.problemDetailsData = res res.map(item =&gt; { this.$refs.pollutionMap.detailAddmarker(item, flag) }) 原因：
vue 官方中对ref的使用中写道：关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。
也就是说也就是说如果在DOM结构中的某个DOM节点使用了v-if、v-shou、v-for（即根据获取到的后台数据来动态操作 DOM，即响应式）、 那么这些DOM事不会在mounted阶段中找到的，ref 只有等页面加载完成好之后才能调用 this.$refs获取子组件中的数据或者方法 。
解决方法：
1、使用this.$refs如果要在mouend()中使用，必须要在this.$nextTick(()=&gt;{ } ) 这里面实现，$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM。
2、可以直接在updata()的生命周期函数中使用，由于mounted阶段是加载阶段，而updata阶段则是完成了数据更新到 DOM 的阶段(对加载回来的数据进行处理)。
3、在methods:{ } 方法中使用，也需要使用this.$nextTick(()=&gt;{ } ) 等到页面完全渲染完毕之后在调用即可。
this.$nextTick(() =&gt; { this.problemDetailsData = res res.map(item =&gt; { this.$refs.pollutionMap.detailAddmarker(item, flag) }) }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6884db3b3e757b55a9b0334765b6212/" rel="bookmark">
			CorelDRAW2022标准专业订阅版下载及功能介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CorelDRAW® Graphics Suite2022订阅版涵盖了全部CorelDRAW图形处理组件，能够高效地完成矢量插图、布局、照片编辑和排版等项目，无论是个人用户还是大型企业，订阅版可以满足几乎所有设计从业者的工作需要，并且将免费获得在订阅周期内的所有更新。
CorelDRAW2022功能介绍
设计
使用 CorelDRAW.app™ 随时随地在 Windows 或 Mac 上制作独特的插图、广告牌、徽标等。
协作
通过 CorelDRAW.app 与客户和同事进行协作，实时沟通，快速交付作品。
高效
支持导出包括PSD/AI/PDF/DOCX/PPT等在内的60+格式，更强的兼容性形成更高效的工作流！
CorelDRAW2022所需软件工具介绍
CorelDRAW® 矢量插图和页面布局
作为CorelDRAW® Graphics Suite的主程序，高效完成图形编辑，排版布局，打印导出等主要设计工作。
CAPTURE™ 截屏
轻松一键即可捕获并保存计算机屏幕的图像，包括整个屏幕、单个窗口或菜单列表。
Corel PHOTO-PAINT™ 图像编辑和基于像素的设计
基于 AI技术的 Corel PHOTO-PAINT 具备高速处理图像能力，并享受 CorelDRAW 集成工作流带来的效率倍增！
Corel® Font Manager 字体开发和管理
使用简单而直观的 Corel Font Manager 组织并管理您的字体库，无需安装即可直接使用自己喜欢的字体。
CorelDRAW.app™ 基于浏览器的矢量插图和图形设计
在网络或 iPad 上使用 CorelDRAW.app 进行方便的协作文件审查或在旅途中进行设计。
AfterShot™ HDR RAW 照片编辑器
为 RAW 或 JPEG 照片进行专业级矫正和强化，使用 AfterShot HDR 创建高动态范围 (HDR) 图像。提供英语、德语和日语版
为什么选择CorelDRAW Graphics Suite 订阅版?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6884db3b3e757b55a9b0334765b6212/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c55a2e29b7532865ab5c005a9f9bafab/" rel="bookmark">
			【python报错解决】findfont: Font family [‘Arial‘] not found. Falling back to DejaVu Sans.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matplotlib字体报错解决 字体上传删除缓冲，重启终端 在使用matplotlib进行绘图时，ubuntu系统报错找不到字体，具体报错信息如下：
findfont: Font family [‘Arial’] not found. Falling back to DejaVu Sans.
【解决方法】
从windows系统中找到相应的字体文件，然后复制上传到ubuntu系统中
字体上传 在windows电脑系统中找到Arial字体文件，路径：C:\Windows\Fonts
接着复制Arial字体文件至桌面，一共有九个文件
找到ubuntu运行环境下的matplotlib字体文件所在位置
比如，我运行matplotlib是在py38环境，那么字体文件所在路径为：
anaconda3/envs/py38/lib/python3.8/site-packages/matplotlib/mpl-data/fonts/ttf
将Arial字体文件复制到该目录下
删除缓冲，重启终端 复制完Arial字体文件后，删除该运行环境下matplotlib缓冲文件，具体操作为：rm -rf ~/.cache/matplotlib
使用命令关闭终端：Ctrl + D
重新进入终端，即可完成字体配置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b54cde13362d74e0ee4f53ab88867733/" rel="bookmark">
			后台服务器启动命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		forever start app.js 启动
forever stop app.js 停止
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6425bb86e7dace7e36162efb54e32e89/" rel="bookmark">
			【隔离继电器模块输出电路分析】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 气阀等隔离继电器输出模块 继电器电路最大可控制交流250AC/7A环路的通断，用于交流电机交流电压输入的通断，如电机控制、电泵开启，气阀开启等需要开断控制的执行机构。
2 继电器控制器原理图 3 优选器件 4 电路计算 如下图所示，当F_RELAY为低电平时，IF=(3.3V-VF)/470=(3.3-1.2)/470=4.5mA，光耦EL817导通，进而使得Q11导通，使得继电器导通。
光耦驱动三极管控制继电器，继电器线圈额定功率是200mW，三极管集电极电路Ic=10mA。D11的作用：续流二极管，释放继电器线圈的电流。
5 其它友商参考电路 （1）维宏朗达4S继电器电路：
如图，采用低失调电压以及高压摆率的运算放大芯片OPA2197;采用正负电源以满足设计负压输入的情况，其特性参数如下：依据规划零点位置抬高到1.5V基准。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b66d0a03dc4f431f03a00ef9a832194/" rel="bookmark">
			《我想进大厂》之Dubbo普普通通9问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是面试专题系列第四篇，Dubbo系列。Dubbo本身并不复杂，而且官方文档写的非常清楚详细，面试中dubbo的问题一般不会很多，从分层到工作原理、负载均衡策略、容错机制、SPI机制基本就差不多了，最大的一道大题一般就是怎么设计一个RPC框架了，但是如果你工作原理分层都搞明白了这个问题其实也就相当于回答了不是吗。
说说Dubbo的分层？
从大的范围来说，dubbo分为三层，business业务逻辑层由我们自己来提供接口和实现还有一些配置信息，RPC层就是真正的RPC调用的核心层，封装整个RPC的调用过程、负载均衡、集群容错、代理，remoting则是对网络传输协议和数据转换的封装。
划分到更细的层面，就是图中的10层模式，整个分层依赖由上至下，除开business业务逻辑之外，其他的几层都是SPI机制。
能说下Dubbo的工作原理吗？
服务启动的时候，provider和consumer根据配置信息，连接到注册中心register，分别向注册中心注册和订阅服务
register根据服务订阅关系，返回provider信息到consumer，同时consumer会把provider信息缓存到本地。如果信息有变更，consumer会收到来自register的推送
consumer生成代理对象，同时根据负载均衡策略，选择一台provider，同时定时向monitor记录接口的调用次数和时间信息
拿到代理对象之后，consumer通过代理对象发起接口调用
provider收到请求后对数据进行反序列化，然后通过代理调用具体的接口实现
为什么要通过代理对象通信？
主要是为了实现接口的透明代理，封装调用细节，让用户可以像调用本地方法一样调用远程方法，同时还可以通过代理实现一些其他的策略，比如：
1、调用的负载均衡策略
2、调用失败、超时、降级和容错机制
3、做一些过滤操作，比如加入缓存、mock数据
4、接口调用数据统计
说说服务暴露的流程？
在容器启动的时候，通过ServiceConfig解析标签，创建dubbo标签解析器来解析dubbo的标签，容器创建完成之后，触发ContextRefreshEvent事件回调开始暴露服务
通过ProxyFactory获取到invoker，invoker包含了需要执行的方法的对象信息和具体的URL地址
再通过DubboProtocol的实现把包装后的invoker转换成exporter，然后启动服务器server，监听端口
最后RegistryProtocol保存URL地址和invoker的映射关系，同时注册到服务中心
说说服务引用的流程？
服务暴露之后，客户端就要引用服务，然后才是调用的过程。
首先客户端根据配置文件信息从注册中心订阅服务
之后DubboProtocol根据订阅的得到provider地址和接口信息连接到服务端server，开启客户端client，然后创建invoker
invoker创建完成之后，通过invoker为服务接口生成代理对象，这个代理对象用于远程调用provider，服务的引用就完成了
有哪些负载均衡策略？
加权随机：假设我们有一组服务器 servers = [A, B, C]，他们对应的权重为 weights = [5, 3, 2]，权重总和为10。现在把这些权重值平铺在一维坐标值上，[0, 5) 区间属于服务器 A，[5, 8) 区间属于服务器 B，[8, 10) 区间属于服务器 C。接下来通过随机数生成器生成一个范围在 [0, 10) 之间的随机数，然后计算这个随机数会落到哪个区间上就可以了。
最小活跃数：每个服务提供者对应一个活跃数 active，初始情况下，所有服务提供者活跃数均为0。每收到一个请求，活跃数加1，完成请求后则将活跃数减1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求。
一致性hash：通过hash算法，把provider的invoke和随机节点生成hash，并将这个 hash 投射到 [0, 2^32 - 1] 的圆环上，查询的时候根据key进行md5然后进行hash，得到第一个节点的值大于等于当前hash的invoker。
加权轮询：比如服务器 A、B、C 权重比为 5:2:1，那么在8次请求中，服务器 A 将收到其中的5次请求，服务器 B 会收到其中的2次请求，服务器 C 则收到其中的1次请求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b66d0a03dc4f431f03a00ef9a832194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/848adfc5b9b59e093751ce0097caacb0/" rel="bookmark">
			Python中的列表（清晰易懂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		列表是用来存放数据的
Python中的列表关键字是list
我们来定义一个列表
lista = ["a", "b", "c", 666, "a"] 可以看到列表lista中
有字符型数据"a", "b", "c"
还有整型数据666
而且还有两个重复的字符"a"
小结1：
1、Python列表中可以存放多种类型的数据
2、Pyton列表中的数据可以重复
怎么获取Python列表中的值了
通过下标即可
例如：lista[0] 里面存放的就是字符"a"
我们可以通过print()命令打印输出看一下
lista = ["a", "b", "c", 666, "a"] print(lista[0]) # 输出结果：a 小结2：
1、Python列表中可以存放多种类型的数据
2、Pyton列表中的数据可以重复
3、Python列表中的数据有顺序（从0开始）
Python还能分段获取列表中的数据
lista = ["a", "b", "c", 666, "a"] print(lista[1:4]) # 输出结果：['b', 'c', 666] 可以看到下标为4 即 lista[4] 中的数据并没有输出
我们再来看一个例子
lista = ["a", "b", "c", 666, "a"] print(lista[:3]) # 输出结果：['a', 'b', 'c'] 可以看到只输出了下标3 即 lista[3] 之前的数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/848adfc5b9b59e093751ce0097caacb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edecd3f84ac152227adf9603b05fa77d/" rel="bookmark">
			【指针进阶：C语言进阶（Day2）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符指针 对于一般字符指针的使用方式如下：
int main() { char ch = 'w'; char *pc = &amp;ch; *pc = 'h'; return 0; } 还有一种使用方式如下：
当出现把字符串赋值给指针变量的这种形式时，实际上是把字符串首个字符的地址赋给指针变量，千万不要认为指针变量里放的是字符串！！！
来看一道相关的面试题：
#include &lt;stdio.h&gt; int main() { char str1[] = "hello bit."; char str2[] = "hello bit."; const char *str3 = "hello bit."; const char *str4 = "hello bit."; if(str1 ==str2) printf("str1 and str2 are same\n"); else printf("str1 and str2 are not same\n"); if(str3 ==str4) printf("str3 and str4 are same\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edecd3f84ac152227adf9603b05fa77d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fbe08af7be473363c1d3be7858459a4/" rel="bookmark">
			前端页面大小自适应的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于第一次搞前端的开发，学习完就直接自己摸索着开始搞这个网站，所以经常遇到一些问题，然后再针对性的学习怎么解决，解决完后再进行记录。
问题是这样的：因为第一次没经验，开发的时候基本上给各组件都是固定的宽高值，而平时又是在大显示屏上进行开发，今天偶然间用笔记本的屏幕一看，发现网站的排版完全乱了。因为笔记本的屏幕更小，固定的宽高值显然是安排不下的。那就需要进行大小自适应了。
确定了问题，那就开始找哪里出了错，首先我的整体结构是用的el-container布局容器，分为头部、主体、尾部三个部分。我给头部和尾部宽度都是100%，主体我是为了突出结构层次，想只给它设置70%的宽度。 /* 头部 */ .el-header{ width: 100%; height: 900px; } /* 主体 */ .el-main{ width: 70%; } /* 底部 */ .el-footer{ height: 35px; } 这里css样式中只写了宽高样式，其余样式就省略了。 主体用的浮动，最后设置了清除浮动，所以没给它加高度。
这样子的安排似乎感觉没啥问题，所以我就思考，那要怎么改。
上图就是画了一个网站的整体的布局，红色框是el-container容器，黑色宽是div盒子，肉色是Vue组件。里面的值是固定的宽高（画完才发现，好像2个600的组件高度不一致，忽略这些细节） 于是，我就准备将它们不再使用固定值，打算一个一个换算成百分比，于是改了6个组件的宽度，设为百分比（对应到main的70%宽度的像素值，各占比多少），以为改好了，一试发现还是不对。右边的组件有一部分没了。
这时候我才意识到，我的想法是如果屏幕足够用的时候，我让main区域只占比70%，可是不一定需要让它的宽度只等于70%啊，我可以给他100%，然后让它水平居中（因为我的组件大小是按照70%来设置的，所以它的显示仍然是70%）。
这时候发现，哎！有点效果了。这时候网页放在大显示器上是上图的样子，一样的视觉效果，放到笔记本屏幕上是下图这样
这时候，我又以为自己搞好了，因为确实解决了之前的需求。 但是我又测试了一下它的鲁棒性，所以又作死的将窗口拖大缩小，然后发现又有问题了。放大没什么好说的，当缩小页面的时候，它的排版又不对了，又看不到右边的内容了（甚至缩到一定小的程度时，header区的导航栏各按钮全坨到一起去了，特别丑）。
试图说服自己，我的笔记本是13.3英寸的屏幕已经够小了，其他的电脑打开后应该也是没问题的，谁有事没事打开了网页后会去缩小窗口大小。但是既然自己测出了bug，不改它心里总痒痒。于是我突然想到了之前改组件宽度把它原本的固定值全换算成了相应百分比值，但是我设置的margin和padding等还是固定值，还是会影响的，要么把它们也全换了？ 肯定不啊。所以我又把组件挑回了固定值。
那怎么才能将窗口变小的时候，还尽量使结构可以自适应呢？我就查到了CSS3中Media媒体查询技术，实现在大PC端、普通PC端、平板、移动端呈现不同的样式
简单来说，就是如果我的窗口现在缩小到1500px以下（这个值是我自己缩放试验以后找到的一个阈值），那我就改变这些组件的样式，不然的话，我就维持原样式。
/* 屏幕自适应 */ @media screen and (max-width: 1500px){ .firstLine ,.secondLine{ width: 930px; } .researchNews,.ResearchSeminars,.joinUs,.NewsAnnouncement,.ResearchDirection{ width: 270px; margin-left: 30px; } .Row { width: 300px; } .NewsHighlight { width: 600px; margin-left: 30px; } } /* 再往下缩小，就可以再根据需求加其他的阈值 */ 以上就是设定的如果此时屏幕最大值为1500px，改变各类的样式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fbe08af7be473363c1d3be7858459a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e27cb566d7040c8c058e321e029ab3a/" rel="bookmark">
			策略梯度(Policy Gradient)算法学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面介绍的是Value-based 算法，每次都需要评估动作或者状态的价值。还有一种算法是直接学习参数化策略的方法。这个策略就是马尔科夫过程所讲的，给定一个状态s，智能体会采取什么样的动作，即 π ( s , a ) \pi(s,a) π(s,a)。这个概率分布，也就是我们的学习目标。
假设策略的待学习参数为 θ \theta θ，则在 t t t时刻、状态 s s s和参数 θ \theta θ下选择动作 a a a的概率为 π ( a ∣ s , θ ) = P r { A t = a ∣ S t = s t , θ t = θ } \pi(a|s,\theta)=Pr\{A_{t}=a|S_{t}=s_{t},\theta_{t}=\theta\} π(a∣s,θ)=Pr{At​=a∣St​=st​,θt​=θ}。
一、算法原理 算法的目标就是找到一组参数 θ \theta θ来最大化性能指标（即奖励函数）。
1、性能指标or策略目标函数 性能指标 J θ J_{\theta} Jθ​的选择依赖于不同的问题类型，主要有以下三类：
在回合性(episodic)的环境中,我们用起始值（Start Value），也就是起始状态的价值：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e27cb566d7040c8c058e321e029ab3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab5351e114e8176fccc4316facff779e/" rel="bookmark">
			父子组件之间的三种通讯方式（小程序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 父子组件之间的三种通讯方式（小程序） 文章目录 父子组件之间的三种通讯方式（小程序）三种通讯方式一、属性绑定二、事件绑定三、获取组件实例三、behavior 三种通讯方式 1.属性绑定
●用于父组件向 子组件的指定属性设置数据，仅能设置JSON兼容的数据
2.事件绑定
●用于子组件向父组件传递数据， 可以传递任意数据
3.获取组件实例.
●父组件还 可以通过this.selectComponent()获取子组件实例对象
●这样就可以直 接访问子组件的任意数据和方法
一、属性绑定 1.属性绑定用于实现父向子传值，而且只能传递普通类型的数据，无法将方法传递给子组件。父组件的示例代码如下:
&lt;view&gt;这是父组件count:{{count}}&lt;/view&gt; //子组件组件 &lt;my-text1 count="{{count}}"&gt;&lt;/my-text1&gt; 子组件在properties节点中声明对应的属性并使用。示例代码如下: properties: { count:Number }, //子组件 &lt;view&gt;这是子组件count:{{count}}&lt;/view&gt; 二、事件绑定 事件绑定用于实现子向父传值，可以传递任何类型的数据。使用步骤如下:
①在父组件的js 中，定义一个函数，这个函数即将通过自定义事件的形式，传递给子组件
②在父组件的wxml中，通过自定义事件的形式，将步骤1中定义的函数引用，传递给子组件
③在子组件的js 中，通过调用this.triggerEvent(‘自定义事件名称’， { /参数对象/})，将数据发送到父组件
④在父组件的js 中，通过e.detail获取到子组件传递过来的数据
三、获取组件实例 可在父组件里调用this.selectComponent(“id或class选择器”)，获取子组件的实例对象，从而直接访问子组件的任意数据和方法。调用时需要传入一个选择器
三、behavior 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/309fc5ba7efbf217a80dcd9c4f90fa22/" rel="bookmark">
			3 移动机器人路径规划（4- A*路径规划算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3 移动机器人路径规划 4.1 Astat路径规划算法原理4.2 Astat路径规划例子示例4.3 Astat路径规划算法MATLAB代码4.3.1 MATLAB代码示例4.3.2 主代码：Astat.m4.3.3 函数代码：Astat_NextNode.m 4.4 Astat路径规划算法Python代码4.4.1 Python实现示例4.4.2 辅助函数PathPlanning.py4.4.3 Astar路径规划Python代码 4.5 对角线路径过滤4.5.1 优化对角线的例子4.5.2 优化方法4.5.3 MATLAB子节点过滤函数Astat_NextNode.m4.5.3 Python子节点过滤函数Astat_NextNode 4.1 Astat路径规划算法原理 A-Star算法是一种静态路网中求解最短路径最有效的直接搜索方法，也是许多其他问题的常用启发式算法。注意其是最有效的直接搜索算法，之后涌现了很多预处理算法（如ALT，CH，HL等等），在线查询效率是A*算法的数千甚至上万倍。
公式表示为： f(n)=g(n)+h(n),其中， f(n) 是从初始状态经由状态n到目标状态的最小代价估计，g(n) 是在状态空间中从初始状态到状态n的最小代价，h(n) 是从状态n到目标状态的路径的最小估计代价。对于路径搜索问题，状态就是图中的节点，代价就是距离） 参考文档
Astat算法-百度百科
Astat中文博客
Astat最火英文博客
4.2 Astat路径规划例子示例 4.3 Astat路径规划算法MATLAB代码 4.3.1 MATLAB代码示例 地图信息和示例是一致的，最后得到的最短路径，和搜寻的地图区域如图所示：
4.3.2 主代码：Astat.m %% 定义基础数据，包括地图行列的长度，起点位置等 clc;clear;close all rows = 6;cols = 7; % 地图的尺寸 dy_SearchArea =[]; % 动态绘制搜索区域 searchHead = 2;searchEnd = searchHead; % 动态绘制搜索区域的速度 startSub = [3,2]; % 起点行列位置 goalSub = [3,6]; % 终点行列位置 obsSub = [2,4;3,4;4,4]; % 障碍物行列位置(n*2) %% 定义栅格地图，并初始化，此部分以后内容，均不用修改------------------------------------------------- % 初始化地图数值为1，代表全空白区域 field = ones(rows, cols); % 起点、终点、障碍物区域的权值 % Tips:对于单个点，Filed(x,y) = 2是可以的，但是多个点需要转成索引数组才能 field(startSub(1),startSub(2)) = 4; field(goalSub(1),goalSub(2)) = 5; % 后续路径规划算法，对于点的位置，均用索引值进行表示（输入变量只需要一个就行） obsR = obsSub(:,1);obsC = obsSub(:,2); obsIndex = sub2ind([rows,cols],obsR,obsC); startIndex = sub2ind([rows,cols],startSub(1),startSub(2)); goalIndex = sub2ind([rows,cols],goalSub(1),goalSub(2)); field(obsIndex) = 2; %% ******建立openList(n*4)和closeList(n*2)并初始化************************************ % 初始时，openList只有起点，closeList为空 % openList(n*4),分别记录记录点的位置信息，G、H、F值 openList = [startIndex,0,0,0]; % closeList(n*2)记录位置信息和距离权值F值，初始化时候为空 closeList = []; %% *************初始化path，即从起点到地图任意点的路径矩阵(n*2)*************************** for i = 1:rows*cols path{i,1} = i; % 存放地图任意点的索引 path{i,2} = []; % 存放起点到该点的路径 end % 对于起点，其路径是已知的，写入起点路径 path{startIndex,2} = startIndex; %% 绘制地图-------------------------------------------------------------------------- % 定义函数，列数，以及障碍物坐标 cmap = [1 1 1; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/309fc5ba7efbf217a80dcd9c4f90fa22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7bc5a5f0b13928c2ccc11c6c883aecd/" rel="bookmark">
			【已解决】MySQL 服务无法启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 启动mysql时出错
解决方法 重新初始化
删除安装目录的data文件夹
cd到bin目录下，输入mysqld --initialize 重新初始化后再启动检查端口
mysql默认端口3306，在命令行输入netstat -ano,查看端口3306（mysql默认端口）是否被占用：
如果是，输入 taskkill /f /pid xxxx终止进程：
重新启动即可：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8cf5f4b15d4c40befd6c66b5f5968f9/" rel="bookmark">
			Python爬虫实战-小说网站爬虫开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求： 从http://www.kanunu8.com/book3/6879爬取《动物农场》所有章节的网址，再通过一个多线程爬虫将每一章的内容爬取下来。在本地创建一个“动物农场”文件夹，并将小说中的每一章分别保存到这个文件夹中。每一章保存为一个文件。
涉及到的知识点
1、requests爬虫网站内容
2、正则表达式提取内容
3、文件写入
4、多线程
插话：做这类需求，最好还是先自己想，自己实现，实现后再去看自己跟书上的有什么不一样。
单线程实现 #使用requests获取网页源代码 import requests import re import time #获取首页源码 html=requests.get('https://www.kanunu8.com/book3/6879/').content.decode(encoding='gbk') # print(html) #获取所有章节链接 herf=re.findall('&lt;a href="(13.*?)"&gt;',html,re.S) print(herf) start=time.time() for i in herf: #通过链接获取每一章的源码 chapter_html=requests.get('https://www.kanunu8.com/book3/6879/'+i).content.decode(encoding='gbk') # print(chapter_html) title=re.search('size="4"&gt;(.*?)&lt;',chapter_html,re.S).group(1)#获取章节名称 content=re.findall('&lt;p&gt;(.*?)&lt;/p&gt;',chapter_html,re.S)#获取每一张p标签内的内容,结果返回为列表 content_str="\n".join(content).replace("&lt;br /&gt;","")#列表转为字符串并替换多余符号 with open('动物农场/'+title+'.txt','w',encoding='utf-8') as f: f.write(title) f.write(content_str) end=time.time() print(f'单线程耗时{end-start}') 结果，文件夹是自己手动创建的，生成如下十个章节txt文件。
文件为每个章节的内容。
如果看不到，在文件夹右键，reload from disk
这个记录了下耗时，可以看到是13秒多。
单线程耗时13.868733167648315
多线程 #使用requests获取网页源代码 import requests import re import time from multiprocessing.dummy import Pool def get_html(): #获取首页源码 html=requests.get('https://www.kanunu8.com/book3/6879/').content.decode(encoding='gbk') # print(html) #获取所有章节链接 herf=re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8cf5f4b15d4c40befd6c66b5f5968f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9e921b8787cb577a2725d96e582fca1/" rel="bookmark">
			esp32 vscode 开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考链接:VSCode安装ESP32开发环境ESP-IDF_大神与小汪的博客-CSDN博客_vscode配置esp32
很详细有图文，构建起来非常方便 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d40d479ceb71b97743fb224ddca12c66/" rel="bookmark">
			使用Hexo部署静态网站或博客到github(gitee)时css或js样式无法显示的问题原因以及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题： 使用hexo部署静态网站或博客时，经常会有一个问题：明明导入了js文件以及css文件，也成功部署了网站，但访问时，样式就是加载不出来，如下所示：​​​​​​​ 2、问题原因查找： 首先我打开网页调试窗口，发现有一个报错：
我一看这不就是语法错误吗？我第一反应是这些静态文件未编译或者语法有问题，但找半天后并没有发现语法上有什么问题。
既然不是语法的问题那就是路径的问题了，可能是路径问题导致的css或js文件未导入或未加载到，我就开始检查我的hexo里的_config.yml文件
首先先看deploy中推送的仓库路径是否正确：
嗯...无误，接着检查url和root，果然这里发现问题了 ：
url 是github的仓库地址，无误，但root是要填仓库所在的根路径，这里却填成了仓库路径，导致路径找不到，所以样式无法加载，这样把错排出来后面就简单多了！
3、解决方案： （1）首先确保静态文件语法等正确，推送仓库路径正确 （2）如下把root后的仓库根路径修改为：/ ，别忘了保存，很多人会忽略这一步 （3）hexo三件套重新部署网站： hexo clean hexo g hexo d 4、问题解决 最后一定记得先把github仓库刷新一下，然后再访问目标网页地址，这时就会发现样式都出现了，问题解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cadf47b924658d212752bba0bf9ef748/" rel="bookmark">
			Java策略模式实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		策略模式介绍 意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。
主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。
何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。
如何解决：将这些算法封装成一个一个的类，任意地替换。
关键代码：实现同一个接口。
应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。
优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。
缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。
使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。
注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。
策略模式实现图示 实战阶段 1.Controller @RestController @RequestMapping public class xxxController { @Autowired private Map&lt;String, BuryingPointService&gt; map; @PostMapping("/xxx") public X X(@RequestBody X x) throws Exception { String moduleType = x.getModuleType(); //只需要和前端定义好每个service的名字,传入具体名字即可 A a= map.get(moduleType); a.b(x); return XX; } } 2.Service public interface XService{ //定义一个父接口,子类只需要去实现这个父接口即可 void action(X x); } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cadf47b924658d212752bba0bf9ef748/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7beba80b42e5c6d422c381ea58fc22bb/" rel="bookmark">
			光速掌握-CSS预处理器SASS从入门到高级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 什么是sass Sass (英文全称：Syntactically Awesome Stylesheets) 是一个最初由 Hampton Catlin
设计并由 Natalie Weizenbaum 开发的层叠样式表语言， Sass 是一个 CSS 预处理器。Sass 是 CSS
扩展语言，可以帮助我们减少 CSS 重复的代码，节省开发时间。Sass 完全兼容所有版本的 CSS。
为什么使用 Sass?
CSS 本身语法不够强大，导致重复编写一些代码，无法实现复用，而且在代码也不方便维护。
Sass 引入合理的样式复用机制，增加了规则、变量、混入、选择器、继承、内置函数等等特性。
我们可以举个例子，我们会在 CSS 中重复使用很多次十六进制的颜色代码，当有了变量之后，如果要改变颜色代码，只要修改变量的值就好了：
二、 vscode集成sass 在vscode中配置sass，下载插件
下载完成后在扩展设置里面，点击，然后在settings.json里面添加
代码如下
// 是否生成对应map "liveSassCompile.settings.generateMap": true, "liveSassCompile.settings.autoprefix": ["&gt; 1%", "last 2 versions"], "liveSassCompile.settings.excludeList": ["**/node_modules/**", ".vscode/**"], "liveSassCompile.settings.formats": [ { // compressed 压缩格式 // expanded展开格式 // compact 紧凑格式 // nested 嵌套格式 "format": "expanded", "extensionName": ".css", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7beba80b42e5c6d422c381ea58fc22bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78ce871d2084e0f87a6e32d8e7e9a6a0/" rel="bookmark">
			Altium Designer基础使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Altium Designer基础使用 目录 Altium Designer基础使用一、元器件符号库1.Mode功能2.新部件功能使用3.多功能管脚的名称自定义4.利用Excel智能创建多管脚元器件符号 二、原理图界面1.原理图大小的调整2.原理图图纸自动标号3.原理图中元器件的标注调整4.多通道设计 未完待续。。。 一、元器件符号库 1.Mode功能 元器件符号绘制，每个人都有自己的使用习惯，因此同一个元器件符号会有不同的样式。在元器件符号库中给同一个元件添加多个Mode，之后在原理图中使用时就可以根据设计者的喜好来摆放自己喜欢看到的元器件符号样式。Mode的功能使用就在于此。（以下电阻为例）
新建工程后，来新建一个元件符号库。
将其命名为“RES”。
放置管脚，绘制主体。
电阻大小现在受限于栅格设置，利用快捷键调制栅格大小
英文输入下 v-g-s 打开栅格设置默认设置为100mil，可以调整至最小10mil。
接着调整主体的长和宽，就绘制出较为美观的电阻符号。
绘制好一种之后就可以添加Mode。
在View菜单栏下，选择Mode功能。
选择之后，菜单栏下会出现下图中所示的一个项目栏，点击“+”进行添加Mode。
添加后“Rename”会亮起，就可以对新的Mode进行一个命名。新的Mode里是一个空白的界面。根据上述元器件绘制过程可以绘制一个不一样的电阻Mode。
在走线时发现不能走一个直线，可以用空格键切换走线的一个模式。
绘制出了一个样式不同的电阻。
元器件绘制完成后，就可以放置到原理图当中了。
点开元器件的属性面板，就可以随意切换两种Mode了
2.新部件功能使用 新部件功能的使用，将一个元器件划分多个部件（part），在原理图电路连接时，可以使电路设计的可读性更加方便。并且划分的结果不会影响元器件的封装，只需要将管脚位号标记准确即可。
此文档说明以LMV385IDGKR-P元器件符号绘制为例。
进入原理图符号库界面后，在菜单栏下“工具”→“新器件”，创建一个新的原理图库元器件，并为元器件进行重命名。
在菜单栏下“工具”→“新部件”，给元器件新建三个部件。
在Part A中绘制第一个部件，单击原理图绘制工具栏中的“放置多边形”进行绘制元器件主体结构。
放置管脚，单击原理图符号绘制工具栏中的“放置管脚”，将管脚属性设置正确。
【 对照数据手册，管脚1为输出管脚OUT1，管脚2和管脚3为输入管脚IN1-和IN1+ 】
全选后复制，进入Part B 粘贴。只需要进行管脚位号的修改即可。
【 对照数据手册，管脚7为输出管脚OUT2，管脚6和管脚5为输入管脚IN1-和IN1+ 】
在 Part C 中绘制公共电源管脚。
【 管脚8和管脚4→VSS与VDD】
放置在原理图中，可以使该元器件的电路连接的可读性增强。原理图线路上的连接更加简洁。
3.多功能管脚的名称自定义 这个功能时AD22版本中，新增功能，具体操作如下。
在原理图符号创建页面中，管脚Name下多了一个功能添加栏。
当该管脚有多个功能时每次填入一个功能，点击“+”或“Enter”，就可以添加一个选项框。
多个功能，全都创建选项框。
将创建好的元件符号，放置到原理图中，点开管脚面板可以看到每个管脚的下拉选框出现了每个给管脚的功能选项，还可以在元器件上直接修改。
多功能管脚的名称自定义，这个新功能的出现使得原理图符号管脚存在多功能定义时，可以让使用者方便的使用某一种管脚功能，不用去修改里层的设置，也使得原理图布局在示意管脚功能更加明确。
4.利用Excel智能创建多管脚元器件符号 首先创建一个Excel表格，基础信息包括：
Object kindX1Y1OrientationNamePin Designator 将表格中的信息全部复制，然后打开原理图库编辑界面，打开SCHLIB List面板。
打开面板看到面板信息是“View”，需要切换模式，在面板中右键进入“Edit”模式。
在面板的空白区域右键，执行“智能栅格插入”命令，将Excel表格中复制的信息粘贴到SCHLIB List中。
在弹出的对话框中，分为两个部分，上面的信息是从Excel中复制的信息，下面的表格是将要制作原理图符号的信息，单击Automatically Determine Paste按钮，将上面的信息自动复制并粘贴到下面的表格中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78ce871d2084e0f87a6e32d8e7e9a6a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2de37e76eb8a5ab62b97f8e567a7a13f/" rel="bookmark">
			Window下安装SDP测试工具 sdpoker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.下载安装node.js。路径如下(Node.js)
2.保证电脑有公钥，在C:\Users\xxx\.ssh下是否存在id_rsa.pub文件，没有的话ssh -keygen -t rsa -C 'guochengabc' //guochengabc 你的git账号
一路回车就会生成一个公钥。将生成的公钥应用到你的github上。
1.复制生成的公钥
2.登入github
3.右击自己的图像，选择Setting
4.点击右侧SSH and GPG keys
5.点击new SSH key
3.在cmd下敲写npm install -g AMWA-TV/sdpoker
4.如果一直卡的话，可以设置成淘宝的。
1.npm config set registry https://registry.npm.taobao.org
2.npm config get registry
5.设置环境变量，找到NODEJS下载的位置，然后在用户环境变量中选中Path，添加global路径。
我的是D:\Software\Nodejs\global。在系统变量中选中Path，添加global下node_modules路径，
这个路径是为了方便下载下来的包，执行命令时能找到位置。我的路径是D:\Software\Nodejs\global\node_modules 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d966d994e353d082d23548e5b06d8ae9/" rel="bookmark">
			maven的Plugins报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：Maven 的 Plugins 报错 一开始使用的 IDEA 自带的 maven，虽然便捷还是会有很多劣势。
在网上找了一下自行配置 maven 的好处：
如果是新手，建议自行配置 maven，有助于更好的学习和理解 maven。idea 自带的 maven 在它自己的路径和配置中，为避免升级（无论是 idea 还是 maven 升级）时发生莫名其妙的问题，自定义配置更能少遇到问题。不依赖 IDEA，你也可以在其他工具上开发，如果你恰好还要同时使用 eclipse，独立出来会更好管理，可在两个环境间共享配置和仓库。idea 自带的 maven 配置文件和仓库都在 C 盘，而且 C 盘一般不要放东西，自行配置 maven，不仅可以自由管理配置文件和仓库的位置，而且可以任意换 maven 的版本。 于是自行下载了 maven：
环境变量的配置setting.xml 的配置IDEA 中 maven 路径的配置 这里不做详细赘述，但是一定要确保上面的配置都没有问题。
但是 Maven 的 Plugins 始终报错，发现本地仓库中对于某些依赖并没有下载下来，试了很多办法都没有效果。
解决办法 mvn dependency:resolve-plugins
只需要执行上面的命令，便解决了这个问题。
该命令的作用是：解决依赖关系，根据POM文件，下载或者更新该项目所依赖的库文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f70204004d8415b962169f1cd470244/" rel="bookmark">
			MySQL中inner join/left join连表查询的查询速度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过对比inner join/left join多表链接查询，分析两个语句的查询速度：
a表：5000万条（id主键）
b表：1000万条
c表：2000万条
d表：2000条
表内id均建立索引
查询结果：一致
查询速度：inner join查询时间222秒；left join 查询时间454秒
通俗原因：inner join为查询交集，查询结果较少；left join 为并集查询，查询结果较多
学艺不精，请指正！！
left join 查询优势，可利用其来进行去重处理，减少使用not in（子查询）：
select *
from a left join b on a.id = b.id
where b.id is null
#代码1： #通过inner join 链接 select d.name,COUNT(a.re_id) from a INNER JOIN b on a.id = b.id INNER JOIN c on a.id = c.id INNER JOIN d on concat(left(a.re_id,4),'00') = d.CODE WHERE (c.r_1 &gt; 0 or c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f70204004d8415b962169f1cd470244/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/966f06d7d8132818f8da0f66b1a2005a/" rel="bookmark">
			Spring Boot项目学习10之发帖模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.帖子的表设计 最显著的三个字段是帖子标题、帖子内容、帖子类别。但是除了这些字段外，还有一些必要的字段。
用户 id阅读数量评论数量收藏数量发布时间 同时，在发布帖子时，为了防止有人重复提交、重复发帖，提交表单时又加了一个验证码字段。
USE `my_bbs_db`; DROP TABLE IF EXISTS `tb_post_category`; CREATE TABLE `tb_post_category` ( `category_id` int NOT NULL AUTO_INCREMENT COMMENT '分类表主键', `category_name` varchar(16) NOT NULL COMMENT '分类的名称', `category_rank` int NOT NULL DEFAULT '1' COMMENT '分类的排序值 被使用的越多数值越大', `is_deleted` tinyint NOT NULL DEFAULT '0' COMMENT '是否删除 0=否 1=是', `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', PRIMARY KEY (`category_id`) ) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC; insert into `tb_post_category`(`category_id`,`category_name`,`category_rank`,`is_deleted`,`create_time`) values (1,'提问',10,0,'2021-08-10 14:47:38'),(2,'分享',9,0,'2021-08-10 14:47:38'),(3,'建议',8,0,'2021-08-10 14:47:38'),(4,'讨论',7,0,'2021-08-10 14:47:38'),(5,'动态',6,0,'2021-08-10 14:47:38'),(6,'其它',5,0,'2021-08-10 14:47:38'); DROP TABLE IF EXISTS `tb_bbs_post`; CREATE TABLE `tb_bbs_post` ( `post_id` bigint NOT NULL AUTO_INCREMENT COMMENT '帖子主键id', `publish_user_id` bigint NOT NULL COMMENT '发布者id', `post_title` varchar(64) NOT NULL DEFAULT '' COMMENT '帖子标题', `post_content` mediumtext NOT NULL COMMENT '帖子内容', `post_category_id` int NOT NULL COMMENT '帖子分类id', `post_category_name` varchar(50) NOT NULL COMMENT '帖子分类(冗余字段)', `post_status` tinyint NOT NULL DEFAULT '1' COMMENT '0-未审核 1-审核通过 2-审核失败', `post_views` bigint NOT NULL DEFAULT '0' COMMENT '阅读量', `post_comments` bigint NOT NULL DEFAULT '0' COMMENT '评论量', `post_collects` bigint NOT NULL DEFAULT '0' COMMENT '收藏量', `last_update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '最新修改时间', `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '添加时间', PRIMARY KEY (`post_id`) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/966f06d7d8132818f8da0f66b1a2005a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f61c19ab6ac60958232766fc653a241/" rel="bookmark">
			Vue3与Vue2的区别（组合式API）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、响应式数据
2、vue2和vue3的响应式原理
3、计算属性Computed
4、监听函数Watch
vue3中watch函数对ref的响应式数据的监听
vue3中watch函数对reactive的响应式数据的监听
总结
5、vue3的生命周期
6、hooks函数
7、toRef和toRefs
8、readonly与shallowReadonly
9、toRaw与MarkRaw
10、组合式API的优势
1、响应式数据 在vue2中，vue向我们承诺data中的数据，即使是嵌套很多层的对象，他也是响应式的数据。
在vue3中，数据和方法都是在setup中定义返回的，这种直接赋值的写法无法做到数据的响应式
export default { name: 'App', setup() { let a='aaaa' function show(){ console.log(a); } return {a,show} } } 此时我们需要引用vue中的ref和reactive函数。
通常基本数据类型用ref实现数据的响应式，经过ref函数包裹的数据，会返回一个RedImpl，是一个对象，它里面用了我们熟悉的vue2的数据代理的方法，在原型上有get set函数，实现了数据的响应式。但是当我们需要获取值的时候需要用过 .value才能获取到他的值
对象这种引用数据类型往往用reactive函数实现数据的响应式，返回的是一个ES6中Proxy的对象，对象里就是我们定义的值，且不需要通过value的方式取值
（在模板中是不需要.value来取值渲染页面的）
&lt;script&gt; import {ref,reactive} from 'vue' export default { name: 'App', setup() { let a=ref('aaaa') let b=reactive({ city:'南京', word:'前端' }) function show(){ console.log(a,b); } return {a,b,show} } } &lt;/script&gt; 2、vue2和vue3的响应式原理 在vue2中，通过Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f61c19ab6ac60958232766fc653a241/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a839d139981e5792f49d7b69a4228c46/" rel="bookmark">
			spark写带sasl认证的kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景描述 spark任务写kafka集群是常规操作，一直很稳健。最近运维提供了带ACL功能的kafka集群，启用sasl认证，spark任务写kafka集群时异常。
异常日志 22/08/11 16:02:15 INFO TransactionManager: [Producer clientId=producer-2] Transiting to fatal error state due to org.apache.kafka.common.errors.ClusterAuthorizationException: Cluster authorization failed.
22/08/11 16:02:15 INFO TransactionManager: [Producer clientId=producer-1] Transiting to fatal error state due to org.apache.kafka.common.errors.ClusterAuthorizationException: Cluster authorization failed.
22/08/11 16:02:16 ERROR Executor: Exception in task 0.0 in stage 0.0 (TID 0)
org.apache.kafka.common.KafkaException: Cannot execute transactional method because we are in an error state
at org.apache.kafka.clients.producer.internals.TransactionManager.maybeFailWithError(TransactionManager.java:1125)
at org.apache.kafka.clients.producer.internals.TransactionManager.maybeAddPartition(TransactionManager.java:442)
at org.apache.kafka.clients.producer.KafkaProducer.doSend(KafkaProducer.java:998)
at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a839d139981e5792f49d7b69a4228c46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58ebee1018b638792d3ee69bad3dca85/" rel="bookmark">
			【数据结构C&#43;&#43;】删除顺序表的最小值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码如下
#include&lt;iostream&gt; using namespace std; #define Max 50 //定义全局变量不需要等号和分号 struct Sqlist { int a[Max] = { 2,3,6,9,7,6,1,8,10 }; int length = 9; }; bool ListDel(Sqlist&amp; s, int&amp; a) { if (s.length == 0)return false; int min = s.a[0]; int index = 0; for (int i = 0; i &lt; s.length; i++) { if (s.a[i] &lt;= min) { min = s.a[i]; index = i; } } a = min; //由于这里没说删除后后面的元素依次替补， //因此为了减少时间复杂度可以将最后一个元素替补过去 s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58ebee1018b638792d3ee69bad3dca85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a550916b49e29ae8db5e49cce2ccfb75/" rel="bookmark">
			【aspose】 word/excel转pdf，实现在线预览文件功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 需求描述：上传附件后，可实现在线预览，这里就会存在一个问题，很多附件的类型是没法在线预览的，点击就会下载。除pdf/jpg/jpeg等，于是技术方案定，将word/excel等类型的文件转成pdf，并且使用nginx代理附件路径，实现预览效果。
技术实现 提示：要考虑到，一个附件肯定会被多人点击预览，从表结构设计的角度，要多加一个preview_path（预览文件地址）字段，第一次生成pdf后，将链接持久化到数据库，之后只有该值不为空，查询直接返回即可。
aspose从maven仓库拉取不下来，需手动下载本地添加到项目中。
aspose-cells-8.5.2.jar
aspose-words-15.8.0-jdk16.jar
链接:https://pan.baidu.com/s/1YBAfBJF2mzPDaJqxjQ6jkg 密码:srco pom.xml添加
注意：maven打包的时候，要加上这句，不然打包有问题
ok，堆代码吧
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;License&gt; &lt;Data&gt; &lt;Products&gt; &lt;Product&gt;Aspose.Total for Java&lt;/Product&gt; &lt;Product&gt;Aspose.Words for Java&lt;/Product&gt; &lt;/Products&gt; &lt;EditionType&gt;Enterprise&lt;/EditionType&gt; &lt;SubscriptionExpiry&gt;20991231&lt;/SubscriptionExpiry&gt; &lt;LicenseExpiry&gt;20991231&lt;/LicenseExpiry&gt; &lt;SerialNumber&gt;8bfe198c-7f0c-4ef8-8ff0-acc3237bf0d7&lt;/SerialNumber&gt; &lt;/Data&gt; &lt;Signature&gt;sNLLKGMUdF0r8O1kKilWAGdgfs2BvJb/2Xp8p5iuDVfZXmhppo+d0Ran1P9TKdjV4ABwAgKXxJ3jcQTqE/2IRfqwnPf8itN8aFZlV3TJPYeD3yWE7IT55Gz6EijUpC7aKeoohTb4w2fpox58wWoF3SNp6sK6jDfiAUGEHYJ9pjU=&lt;/Signature&gt; &lt;/License&gt; 枚举类，支持的附件类型，按自己需求增减
package com.szls.enums; import lombok.AllArgsConstructor; import lombok.Getter; /** * com.szls.enums * * @author smallNorth_Lee * @date 2022/8/11 */ @Getter @AllArgsConstructor public enum FileTypeEnum { PDF(".pdf"), XLSX(".xlsx"), DOCX(".docx"), DOC(".doc"); /** * 文件类型 */ private final String fileType; } package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a550916b49e29ae8db5e49cce2ccfb75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee3f29c9c117f4f5a84a28034685c0c8/" rel="bookmark">
			Android 内存优化(四) —— 未取消注册或回调导致内存泄露
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		未取消注册或回调导致内存泄露
比如我们在 Activity 中注册广播，如果在 Activity 销毁后不取消注册，那么这个刚播会一直存在
系统中，同上面所说的非静态内部类一样持有 Activity 引用，导致内存泄露。因此注册广播后在
Activity 销毁后一定要取消注册。
public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); this.registerReceiver(mReceiver, new IntentFilter()); } private BroadcastReceiver mReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // 接收到广播需要做的逻辑 } }; @Override protected void onDestroy() { super.onDestroy(); this.unregisterReceiver(mReceiver); } } 在注册观察则模式的时候，如果不及时取消也会造成内存泄露。比如使用 Retrofit+RxJava 注册网
络请求的观察者回调，同样作为匿名内部类持有外部引用，所以需要记得在不用或者销毁的时候
取消注册。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/624c2f58e5c02062ceee7b63b9d307c0/" rel="bookmark">
			将C&#43;&#43;类纳入存储池管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日在做一个项目，遇到一个比较棘手的问题。程序在执行一次任务的时候会new大量的处理类和各种Buffer，在任务执行完成后，这些类和Buffer会被释放掉，但会产生一些内存碎片，当时项目时间比较紧凑，所以没有考虑内存管理这方面的事情。程序在多次执行任务后，在new一些较大块内存的时候会出现分配内存失败的异常，导致任务失败，但整体程序占用内存其实并不高。个人猜测可能是内存碎片过多导致。
在处理问题的过程中，我想到，如果对内存进行统一管理，那就尽可能的减少了内存碎片的产生，降低了内存泄露的风险，如果以后有时间，还可以使用GC等内存管理技术来优化。
我们来做一些实验。
首先，我们分配一块Buffer，接下来所有要分配的内存都从那里取得。如果是基本数据类型，比如char*，int*等，还好处理，直接存储即可，但是类就比较麻烦了，这就涉及到malloc和new的一个不同点：malloc只负责分配内存，new除了分配内存，还对类进行了初始化。
看如下代码
class A { public: A() { memcpy(m_s, "abcd\0", 5); } ~A() {}; int GetA() { return m_a; } int SetA(int a) { m_a = a; } private: int m_a = 5; char m_s[5]; }; int main() { A* b = (A*)malloc(sizeof(A)); A* a = new A; free(b); delete a return 0; } 使用VS2019调试查看b 和 a的值
b中的值是无效的。如果我们直接将Buffer强转成类，效果跟使用malloc是一样的，无法对类成员进行初始化。
那么怎么对malloc出来的类成员进行初始化呢？
网上找到有几种做法：
第一种：根据类的内存布局直接赋值
int main() { A* b = (A*)malloc(sizeof(A)); A* a = new A; int n = 3; memcpy(((int*)b), &amp;n, sizeof(int)); memcpy(((char*)b + sizeof(int)), "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/624c2f58e5c02062ceee7b63b9d307c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dd821405b3373bcc18b1e4e25b83e28/" rel="bookmark">
			HTML&#43;CSS——网页设计项目完整版本（阿里矢量图标库）分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、页面展示二、首页实现步骤 1.HTML结构2.CSS样式总结 前言 HTML+ CSS部分相关知识点的学习已经告一段落，在这里将自己完成PC端的项目分享给大家，以供参考，也算是记录一下过去一段时间的学习过程吧~
一、页面展示 本项目参照的是PC端的阿里矢量图标库网页，这里我主要实现了三个页面包括主页面以及资源管理页面，用户登录页面。
主页面： 二、首页实现步骤 文件结构图： 1.HTML结构 主页面: &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;iconfont-阿里巴巴矢量图标库&lt;/title&gt; &lt;link rel="icon" href="../img/首页图库/little-logo.png" type="image"&gt; &lt;link rel="shortcut icon" href="../img/首页图库/little-logo.png" type="image"&gt; &lt;link rel="stylesheet" href="../css/reset.css"&gt; &lt;link rel="stylesheet" href="../css/footer.css"&gt; &lt;link rel="stylesheet" href="../css/index.css"&gt; &lt;link rel="stylesheet" href="../css/common.css"&gt; &lt;link rel="stylesheet" href="../css/font_3542053_0eoy0eld3lj5/iconfont.css"&gt; &lt;link rel="stylesheet" href="../js/swiper-master/package/swiper-bundle.css"&gt; &lt;script src="../js/swiper-master/package/swiper-bundle.min.js"&gt;&lt;/script&gt; &lt;script&gt; var context; var arr = new Array(); var starCount = 800; var rains = new Array(); var rainCount = 20; function init() { var stars = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dd821405b3373bcc18b1e4e25b83e28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1400df18fcd0c5cfd0f0b6fadef0dc2c/" rel="bookmark">
			异步编程概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异步编程是一个统一的概念。
常见的多线程是异步编程的一种实现方式，还有其他的异步方式，如：协程、多进程、甚至是多主机都可以称为异步编程（个人理解）。
并发：一段时间内做多件事
并行：同一时刻有做多个事
异步是目的
多线程是实现异步的一种方式。
一个程序就一个主线程也可以实现异步：例如，一个耗时任务，分隔成很多份，在主线程分帧执行（协程）。
更多的百度谷歌一下就有了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef76ab14f2eb0864738b3f71ed936171/" rel="bookmark">
			mybatis plus or and 合并写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		int count =hrDeliverEmployContractService.selectCount(new EntityWrapper&lt;HrDeliverEmployContractEntity&gt;() .eq("pool_id",hrDeliverEmployContract.getPoolId()).andNew().lt("contract_start_date",hrDeliverEmployContract.getContractStartDate()).or().gt("contract_end_date",hrDeliverEmployContract.getContractEndDate()) ); 对应的SQL
SELECT COUNT(1) FROM hr_deliver_employ_contract WHERE (pool_id = 1) AND (contract_start_date &lt; '2018-07-01 00:00:00.0' OR contract_end_date &gt; '2018-10-31 00:00:00.0'); mybatis plus or使用
1
2
3
QueryWrapper queryWrapper = new QueryWrapper();
queryWrapper .and(wrapper -&gt; wrapper.isNull(“sim”).or().eq(“sim”, “”));
queryWrapper .eq(“is_delete”, “0”);
对应SQL
select * from vehicle where name=‘测试' or sim=‘2'
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5761294ab281e2396280fc220034b3ce/" rel="bookmark">
			颜色码对照表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ade0a10f2c6901d351964a3d08ba234/" rel="bookmark">
			基于深度学习的三维点云分割综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文连接在这里
传统的点云分割方法包括： 基于边缘检测的方法基于区域增长的算法基于特征聚类的算法基于模型拟合的算法基于图形的算法 深度学习方法相对于传统方法的优势： 传统方法过分依赖于人工设计的特征，成本高，计算量大，并且普适性差，在面向大数据集时表现不佳。
三维点云数据集： 点云模型的评价指标： 评价指标用于 分割算法 之间的性能比较，包括：平均交并比（mIoU）、总体分割精度（Overall Accuracy，OA）、平均精确率（mean Accuracy Precision，mAP）、参数量（Parameters）和每秒的浮点运算数（FLOPs）等。
TP（True Positive） 预测为正样本且是预测结果是正确。FP（False Positive） 预测为正样本但是预测结果错误。FN（False Negative） 预测结果为负样本但是预测结果错误。 3D点云语义分割方法发展脉络 基于体素化的方法 基于体素化的方法是一种结构化的表示方法，其将无序的点云分割成一系列占用一定空间的体素，然后送入3D CNN逐步进行体素级别的特征学习，最后为每一格体素内的所有点匹配与该体素相同的语义标签。该方法有效地促进无序点云规则化，但是存在较高的计算和内存成本。
基于多视图的方法 多视图方法将一个3D对象按照多个角度投影成多个2D视图并提取各视图特征，然后融合这些特征以预测结果。
这种方法一个比较经典的网络就是MVCNN。它模拟相机从若干不同角度获取3D物体的2D图像，再利用预训练CNN模型提取特征，最后通过全局最大池化将不同视角的特征聚合达到形状识别的目的。
但是该方法所提取的特征冗余性很高，且没有很好的考虑多视角下的特征之间的关系。
基于点云的方法 1.基于多层感知机MLP的方法
PointNet直接将3D点云作为输入，引入T-Net结构实现点云的旋转不变，利用共享的多层感知机(MLP)提取输入的每个点的特征，通过最大池化将所有点的信息聚合得到全局特征。该方法有效改善了原始点云旋转不变性差的问题，广泛应用于分类、部件分割和语义分割等任务。
但存在过分关注全局特征而忽略局部特征的问题，没有考虑点与点之间的结构信息，也没有充分考虑到点云密度不均匀所造成的不利影响等问题，难以适应复杂场景。
针对以上问题， 在PointNet基础上进一步提出了PointNet++。如图2所示，该方法通过层级下采样来捕捉局部几何细节信息。此外，该方法还提出了多尺度分组和多分辨率分组的策略，以克服由于点云数据密度不均匀引起的稀疏点信息可能被忽视问题。虽然有效解决了PointNet在采样和特征提取方法上存在的问题，但仍然没有充分考虑如何有效利用点与点之间的结构信息，且所采用的K近邻搜索方法可能使得采样点集中在一个方向上，容易出现标签错分。
2.点卷积的方法
代表作：PointCNN，PointConv。
3.基于RNN的方法
将循环神经网络应用于3D点云语义分割模型。
4.基于图卷积的方法
基于图卷积的点云语义分割将点云中的每个点视为图的顶点，与邻域点生成图有向边,在空间域或频谱域中学习点、边特征，以捕获3D点云的局部几何结构特征。
代表作：DGCNN
DGCNN提出了一个用于学习边缘特征的边缘卷积(EdgeConv)，通过构建局部邻域图和对每条邻边进行EdgeConv操作，动态更新层级之间的图结构。EdgeConv可以捕捉到每个点与其邻域点的距离信息。
但是同样DGCNN忽视了相邻点之间向量的方向信息，忽略了一些结构信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2fdb81a311e35bb9c0e6bcedcd1cd14/" rel="bookmark">
			多线程07--yield和join
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
yield和join皆为Thread提供的基本方法，供开发者在不同场景下应用。
1. yield 创建线程类实现Runnable接口，代码如下： package yield; public class MYieldThread implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName() + "开始执行..."); Thread.yield(); System.out.println(Thread.currentThread().getName() + "执行完毕...."); } } 主测试类： package yield; public class TestYield { public static void main(String[] args) { MYieldThread yieldThread = new MYieldThread(); new Thread(yieldThread, "111").start(); new Thread(yieldThread, "222").start(); } } 执行结果（说明：礼让不一定会成功，因为具体要看CPU调度，可能A线程开启礼让并释放CPU使用权，但是CPU再次调度从队列中获取A线程继续执行）： 礼让成功结果：
礼让失败结果：
总结：
Thread.yield()方法作用是暂停当前正在执行的线程对象（及放弃当前拥有的cup资源），并执行其他线程。yield()做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间。
2. join 2.1使用join()方法控制线程执行顺序 调用Thread的start()方法启动线程时，线程的执行顺序是不确定的。也就是说，在同一个方法中，连续创建多个线程后，调用线程的start()方法的顺序并不能决定线程的执行顺序。例如如下程序：
public class ThreadStartOrderTest { public static void main(String[] args) { Thread thread1 = new Thread(()-&gt;{ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2fdb81a311e35bb9c0e6bcedcd1cd14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97d23bbeafcb09623b1ed9351b46518e/" rel="bookmark">
			Docker 容器内存：我的容器为什么被杀了？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不知道你在使用容器时，有没有过这样的经历？一个容器在系统中运行一段时间后，突然消失了，看看自己程序的 log 文件，也没发现什么错误，不像是自己程序 Crash，但是容器就是消失了。
那么这是怎么回事呢？接下来我们就一起来“破案”。 问题再现 容器在系统中被杀掉，其实只有一种情况，那就是容器中的进程使用了太多的内存。具体来说，就是容器里所有进程使用的内存量，超过了容器所在 Memory Cgroup 里的内存限制。这时 Linux 系统就会主动杀死容器中的一个进程，往往这会导致整个容器的退出。
我们可以做个简单的容器，模拟一下这种容器被杀死的场景。做容器的 Dockerfile 和代码，你可以从这里获得。
接下来，我们用下面的这个脚本来启动容器，我们先把这个容器的 Cgroup 内存上限设置为 512MB（536870912 bytes）。
#!/bin/bash docker stop mem_alloc;docker rm mem_alloc docker run -d --name mem_alloc registry/mem_alloc:v1 sleep 2 CONTAINER_ID=$(sudo docker ps --format "{{.ID}}\t{{.Names}}" | grep -i mem_alloc | awk '{print $1}') echo $CONTAINER_ID CGROUP_CONTAINER_PATH=$(find /sys/fs/cgroup/memory/ -name "*$CONTAINER_ID*") echo $CGROUP_CONTAINER_PATH echo 536870912 &gt; $CGROUP_CONTAINER_PATH/memory.limit_in_bytes cat $CGROUP_CONTAINER_PATH/memory.limit_in_bytes 好了，容器启动后，里面有一个小程序 mem_alloc 会不断地申请内存。当它申请的内存超过 512MB 的时候，你就会发现，我们启动的这个容器消失了。
这时候，如果我们运行docker inspect 命令查看容器退出的原因，就会看到容器处于"exited"状态，并且"OOMKilled"是 true。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97d23bbeafcb09623b1ed9351b46518e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3d67b41aabd11ee29424d68f858a1d3/" rel="bookmark">
			prerender-spa-plugin报错处理，prerender-spa-plugin-next长江后浪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言Unable to prerender all routes! 方案一：修改源码方案二：[prerender-spa-plugin-next](https://www.npmjs.com/package/prerender-spa-plugin-next)vue.config.js打包后的效果图 方案三：vite+**[vitesse](https://github.com/antfu/vitesse)**使用SSR渲染完成SEO 前言 由于业务需求需要用到预渲染，vite+vue3没有找到好的库。
考虑使用prerender-spa-plugin这个插件满足需求。
以下是我的配置信息。
const PrerenderSpaPlugin = require("prerender-spa-plugin"); const Renderer = PrerenderSpaPlugin.PuppeteerRenderer const path = require("path"); module.exports = { configureWebpack: config =&gt; { if (process.env.NODE_ENV !== "production") return; return { plugins: [ new PrerenderSpaPlugin({ staticDir: path.join(__dirname, 'dist'), routes: ['/', '/home', '/test', '/about'], renderer: new Renderer({ timeout: 0, maxConcurrentRoutes: 1, renderAfterTime: 5000, headless: false }) }), ] }; } }; 使用过程中诸多报错，但后续都以解决。
最终卡在这个条报错信息上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3d67b41aabd11ee29424d68f858a1d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39594954c78190b881f51416c94f1a7e/" rel="bookmark">
			基于Antd的模态框modal不显示 确认和取消按钮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		csdn上有几篇类似的，不过好像是基于react的，或者只取消一个按钮，保留另一个。
因为业务要求，现在两个按钮都不能显示。
基于Antd的模态框modal不显示确认和取消按钮
&lt;a-modal title="组员信息" :visible="visiblegroup" :confirm-loading="confirmLoading" :width="850" @ok="handleCancelgroup" @cancel="handleCancelgroup" cancelText="关闭1" &gt; &lt;template slot="footer"&gt; &lt;a&gt;&lt;/a&gt; &lt;/template&gt; &lt;/a-modal&gt; &lt;/template&gt; 原理是 对vue底部footer组件的重写。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9585ebbaf8dfe85a7bb36077c3eb2239/" rel="bookmark">
			封装的three.js饼图vue组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于three.js的3d饼图
使用 &lt;template&gt; &lt;div id="app"&gt; &lt;three-pie ref="pie" :data="pieData" :delay="3000" :colors="[0x3da6ff, 0x2ceef5, 0xf2c62a, 0x26c7b7, 0xff823b]" :opacity="0.7" class="pieCanvas" &gt; &lt;template v-slot:default="slotProps"&gt; &lt;div class="pieCanvas-content"&gt; &lt;div class="pieCanvas-content-value"&gt; &lt;count-to ref="countTo" :startVal="0" :endVal="getNumber(slotProps)" :decimals="2" :duration="1000" :autoplay="true" &gt;&lt;/count-to&gt; % &lt;/div&gt; &lt;div class="pieCanvas-content-name"&gt;{{ slotProps.data.name }}&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;/three-pie&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import ThreePie from '@/components/threePie' import CountTo from '@/components/CountTo' export default { components: { ThreePie, CountTo, }, data() { return { pieData: [ { name: '搜索引擎', value: 22, }, { name: '邮件', value: 23, }, { name: '广告', value: 27, }, { name: '视频广告', value: 19, }, { name: '地推', value: 25, }, ], } }, methods: { getNumber(slotProps) { return Number(((slotProps.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9585ebbaf8dfe85a7bb36077c3eb2239/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6b4b356a2fa10df69f2980dcb50cdfd/" rel="bookmark">
			解决：UnicodeDecodeError: ‘utf-8‘ codec can‘t decode byte 0xb1 in position 1142: invalid start byte
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
操作描述
错误现象
原因分析
解决方案1
解决方案2
执行结果
操作描述 利用configparser库函数，读取配置文件中的字段，就是反复报错，什么编解码出问题。找了一圈教程，没有找到有效的解决方案，不过最终还是解决了，把解决思路写在下面供参考。
错误现象 图1 原因分析 把原有的配置文件复制到了另外一个文件夹，并用记事本打开重新保存了一下，然后调用复制过去的配置文件就报如上图1 的错误；
调用源路径下的配置文件就不会出问题，所以怀疑这个操作过程出现了编解码不一致的问题，所以导致UnicodeDecodeError问题。
想到这里，我重新把源文件夹下的配置文件，复制到新的地址，然后直接调用，发现程序执行正常。
解决方案1 点击[pycharm]中的settings, 点击[File Encodings] 进入如下界面
注意如下位置，全部改成UTF-8
解决方案2 如果解决方案1，还是不行，再给大家说一个方法，确保万无一失。在需要配置文件的package名，右击选择[New]新建[File]
详细如下操作
然后点击【OK】，完成配置文件创建，如此可以保证配置文件的编码是按照pycharm设置的编码方式进行的。
执行结果 修改完成后，再次执行程序，调用配置文件结果如下： 图2 从图2执行结果看，上述分析是正确的，打开文件在保存过程一定要看清楚编解码方式，选择正确的编码方式，推荐一个网址：在打开和保存文件时选择文本编码，如果有这方面更好的解释，麻烦留言交流~
希望对看到的你有所帮助，祝好~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c2cd74edd0c207cad52ab9a8c25cdae/" rel="bookmark">
			Verdi查看force信号的四种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题由来 一次仿真中发现信号的变化跟预期不一致，分析之下感觉不合逻辑，因此怀疑是有某个地方有force的动作，那么如何check是否有force呢？
因此做了一个小实验来检查是否有force动作，简单代码如下：
解决办法 最直接的办法，就是在波形中不合理的时刻，双击该信号的跳变沿，可以直接在工程中显示出该信号跳变的驱动位置
如果因为驱动的位置较多，可以进一步点击Verdi下方Message窗口，可以显示出所有驱动该信号的位置，看下有没有force的动作
注：这里显示的每行信号都可以双击跳转到工程中相应的位置
仿真时添加参数+fsdb+force重新仿真一遍，如果有force动作，那么波形中会有显示
注：是仿真阶段，不是编译阶段
示例如下：
波形中效果如下：
通过fsdbreport命令来打印环境中所有的force信息
fsdbreport ./work/wave.fsdb -find_forces -s "/tb/*" -of h -o force.log
命令中参数定义如下： -find_forces：即查找波形中force信息-s：制定查找的层次-of：指定结果中变量值得格式， 可选b/o/d/u/h分别表示二进制/八进制/十进制/无符号十进制/十六进制，默认为二进制 -o：指定查找结果的输出文件，也可以不指定，默认为report.txt
注：fsdbreport还有很多作用和参数，后续再讲，也可以通过fsdbreport -help查看详细信息
在当前目录下找到force.log文件，显示如下：
使用Verdi自带的APP：
使用方法如下：
在当前目录下（打开verdi的那级目录）查找生成的文件
注1：如果没有找到文件，那么可以在生成时候，看下生成目录
注2：Verdi的APP很多都非常实用，后续详细讲解，感兴趣的话也可以逐个点击玩儿一下，生命的意义在于探索嘛 结语 方法1和方法2，在只是debug某个信号是否被force的情况下，比较直接和高效；方法3和方法4，在查找工程中都有哪些信号被force的时，比较实用。我们项目中有项checklist就是检查环境中是否有不当的force操作，就是采用方法4来实现的
最后留个小悬念吧：为什么检查环境中是否有不当操作时，为什么我们不用方法3呢？相信你如果把上述方法尝试了一遍之后，心中自有分晓。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7bf90e9246b7355abb0e095568bc400/" rel="bookmark">
			[转] Typora_Markdown_图片标题(题注)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Typora_Markdown_图片标题(题注) 总体有两种方法，一种是简单粗暴的,直接在图片下加文字作标题，而另一种是封装可拓展性强。
1 直接下加标题 \qquad 效果如下，下图即为在Typora中该做法的效果，还是可以达到预期的效果，标题在图片正下方，但由于是默认图片显示和自加html标题，二者分开编程，在Typora中显示略有逊色，标题和图片会有隔一行的感觉，让人觉得标题和图片贴合度不高，不够排版美观。
\qquad 代码如下：
&lt;img src="这里放图片路径" alt="这里放图片显示不出的时候出现的文字" style="zoom:这里写缩放的百分比，比如:30%"/&gt; &lt;!--上面的是Typora默认的，不用自己写--&gt; &lt;center&gt;&lt;p&gt;这里放标题&lt;/p&gt;&lt;/center&gt; 2 封装型 \qquad 封装型效果如下，整个html代码在一起没有分开，整个代码要自己写。但从下图可以看出，在Typora的显示中，图片和标题(题注)贴合性高，整体感觉比直接下加标题的方法更美观。
\qquad 代码如下：
&lt;div&gt;	&lt;!--块级封装--&gt; &lt;center&gt;	&lt;!--将图片和文字居中--&gt; &lt;img src="图片路径放这里" alt="无法显示图片时显示的文字" style="zoom:这里写图片的缩放百分比"/&gt; &lt;br&gt;	&lt;!--换行--&gt; 这里是图片的标题	&lt;!--标题--&gt; &lt;/center&gt; &lt;/div&gt; ---------------------
作者：An_Lord
来源：CSDN
原文：https://blog.csdn.net/m0_47098916/article/details/117827687
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df8a53708b93103cc2df8dce19ee8969/" rel="bookmark">
			petalinux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、配置petal inux运行环境
1、 source settings.sh
2、 PATH
二、petalinux设计流程介绍
1、搭建vivado.工程，导出hdf文件
2、创建一个petalinux工程
3、需要将hdf文件导入到petalinux.工程(将vivado设 计应用到petalinux工程)
4、配置petalinux.工程(其中就包括配置内核、配置U-Boot以及根文件系统)
5、编译petalinux.工程(U-Boot镜像、 内核镜像以及rootfs，bitstream， fsbl镜像文件)
6、启动开发板.
三、petalinux使用实战
petalinux-boot 启动开发板
petalinux-build 编译
petalinux-config 配置
petalinux-create 创建项目
petalinux-package 打包
petalinux-util 没用过、不知道干嘛的
注意：每个命令的查询与帮助 eg:petalinux-config --help
1)、导入hdf 文件:
petalinux-config --get-hw-description ~ /hdf/Navigator_ 7020.sdk (路径)
导入hdf文件后，就会打开配置界面
2)、单独打开petalinux工程的配置界面:
petalinux-config
u-boot配置:
petalinux-config -C u-boot
Linux内 核配置:
petalinux-config -C kernel
rootfs (根文件系统)配置:
petalinux-config -C rootfs
3)、 编译:
编译整个petalinux工程(U-boot、 kernel和设备树、rootfs、 fsbl、 bit文件)
petalinux-build单独编译U-boot、kernel、 rootfs
petalinux-build -C u-boot #编译U-boot
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df8a53708b93103cc2df8dce19ee8969/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6271438ccc5ae93d57f1c9acd70723c9/" rel="bookmark">
			JS百度地图PC端API基本使用(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、事件交互和this
百度地图API的dom事件的回调函数也会有一个默认的事件对象e，通过e可以知道关于事件的一些信息
marker.addEventListener('click', function(e) { alert(e.point.lng + ", " + e.point.lat); }) 事件函数中的this也是指向发生该事件的dom元素
map.addEventListener("zoomend", function() { alert("地图缩放至：" + this.getZoom() + "级"); }); 2、Geocoder：逆/地址解析
用于经纬度坐标以及真实地址的一个转换。
地址解析：首先先创造出一个地址解析器实例，然后调用他的getPoint方法，第一个参数为具体的一个地址，第二个为处理函数，第三个为省市名称，它可以自动将地图跳转要你输入的那个地址中，并且创造出一个点标注
var myGeo = new BMap.Geocoder(); myGeo.getPoint("南京市南京南站", function(point) { if (point) { map.centerAndZoom(point, 16); map.addOverlay(new BMap.Marker(point)); } }, "南京市"); 逆地址解析就是通过他的经纬度坐标 返回一个真实的地址
var myGeo = new BMap.Geocoder({ extensions_town: true }); myGeo.getLocation(new BMap.Point(115.364, 39.993), function(result) { if (result) { alert(result.address); } }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5f56f1a44cb419618544d6c5193c73f/" rel="bookmark">
			Flutter 学习之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Container 设置最大和最小宽度 Container( width: 220, // 宽度 constraints: BoxConstraints( minWidth: 200, // 最小宽度 minHeight:200, maxWidth: 500, // 最大宽度 maxHeight:500, ), 2. flutter打包 旧项目开启web端构建
flutter config --enable-web web的渲染模式 HTML渲染模式 flutter会采用HTML的custom element，CSS，Canvas和SVG来渲染UI元素。
优点：应用体积更小。
缺点：渲染性能差；跨端一致性可能受影响。
打包命令： flutter build web --web-renderer html
CanvasKit渲染模式 当canvaskit渲染模式：flutter将 Skia 编译成 WebAssembly 格式，并使用 WebGL 渲染。应用在移动和桌面端保持一致，有更好的性能，以及降低不同浏览器渲染效果不一致的风险。但是应用的大小会增加大约 2MB。
打包命令：flutter build web --web-renderer canvaskit
优点：像素级跨端一致性、更好的渲染性能。
缺点：应用体积变大，需要加载一个2.5MB的webaseembly格式的代码。
auto的渲染模式（默认） 会自动根据是运行在移动浏览器端还是桌面浏览器端来选择渲染模式。
实践遇到的问题 命令1 flutter build web --release
使用该命令打包的工程，放置在http链接下的时候，无法显示 image的图片。
目前发现比较好用的是这个：
flutter build web --release --dart-define=FLUTTER_WEB_CANVASKIT_URL=.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5f56f1a44cb419618544d6c5193c73f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/156fc173a593ca6cc0fddb92714c6504/" rel="bookmark">
			JS百度地图PC端API基本使用(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、创建地图
创建一个百度地图实例，类似Echarts首先先创建一个容器（盒子），如何通过new操作符创建一个地图实例，然后通过类构造函数Point new出一个中心点坐标，第一个参数为经度第二个参数是纬度。最后用centerAndZoom方法初始化一个地图，第一个参数就是我们刚才new出来的中心点坐标，第二个参数是地图级别（放大的倍数为3-19）
&lt;script type="text/javascript" src="https://api.map.baidu.com/api?v=3.0&amp;ak=TwtrRswKZltecLVCWH00lLOFIseNNwXG"&gt;&lt;/script&gt; &lt;body&gt; &lt;div id="container"&gt;&lt;/div&gt; &lt;/body&gt; &lt;script&gt; var map = new BMap.Map("container"); var point = new BMap.Point(116.404, 39.915); map.centerAndZoom(point, 15); map.enableScrollWheelZoom() &lt;/script&gt; 地图默认是没有常用的鼠标滚轮缩放的功能的，需要调用map.enableScrollWheelZoom方法来开启。
2、地图控件
通过addControl方法可以创造出各种控件。在创建的时候可以往new出的实例里添加配置项，可以配置控件放置的位置，以及控件的功能大小类型。
map.addControl(new BMap.NavigationControl()); //地图默认左上角的控件，用来控制地图的平移和缩放功能 map.addControl(new BMap.ScaleControl()); //默认在地图左下角的比例尺 map.addControl(new BMap.OverviewMapControl()); //默认在地图右下角的可折叠的缩略地图 map.addControl(new BMap.MapTypeControl()); //默认在地图右上角 用来控制地图类型的 map.addControl(new BMap.NavigationControl({ type: BMAP_NAVIGATION_CONTROL_SMALL, anchor: BMAP_ANCHOR_BOTTOM_LEFT })) 3、在地图上绘制
（1）点的绘制
var marker = new BMap.Marker(point); // 创建标注 map.addOverlay(marker); // 将标注添加到地图中 marker.addEventListener("click", function() { alert("你是最帅的"); }); //给添加点添加点击事件 创建一个标注实例，用map.addOverlay将这个实例添加到地图中，然后给点绑定点击事件（百度地图上默认会有商家或者地标之类的点点击之后会显示信息）
（2）信息窗口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/156fc173a593ca6cc0fddb92714c6504/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efcc2e64ad2d128f1d6f50f3d6c09ad5/" rel="bookmark">
			C#字符串(字节)的长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System; public class Test { public static void Main() { string str1 = "abced.,.某某某"; int len2 = str1.Length; int leng = System.Text.Encoding.Default.GetBytes(str1.ToCharArray()).Length; Console.WriteLine("字符串为"+str1); Console.WriteLine("字符串的长度"+len2); Console.WriteLine("字节的长度"+leng); Console.ReadLine(); } } 顺便看一下Sql Server中char nchar varchar nvarchar
char类型： 对英文(ASCII)字符占用1个字节，对一个汉字占用2个字节，CHAR存储定长数据很方便，CHAR字段上的索引效率极高，比如定义char(10)，那么不论你存储的数据是否达　到了10个字节，都要占去10个字节的空间。因为是固定长度，所以速度效率高。
VARCHAR:存储变长数据，如果一个字段可能的值是不固定长度的，我们只知道它不可能超过10个字符，把它定义为 VARCHAR(10)是最合算的。VARCHAR类型的实际长度是它的值的实际长度+1。为什么“+1”呢？这一个字节用于保存实际使用了多大的长度。
Nchar类型和Nvarchar类型是怎么一回事呢？为了与其他多种字符的转换，如中文，音标等，对每个英文(ASCII)字符都占用2个字节，对一个汉字也占用两个字节，所有的字符都占用2个字节。
nchar(n):包含n个字符的固定长度Unicode字符数据。n的值必须介于1与4,000之间。存储大小为n字节的两倍。
varchar(n):变长型字符数据类型，存储最长长度为8,000 个字符
nvarchar(n):可变长度 Unicode 数据，其最大长度为 4,000 字符.字节的存储大小是所输入字符个数的两倍，就是说它是双字节来存储数据的。如果存储数据如果存在单字节时，它也是以双字节来占用存储空间的。
varchar一般适用于英文和数字，Nvarchar适用中文和其他字符，其中N表示Unicode常量，可以解决多语言字符集之间的转换问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af8acf97b7b592fdb58cba14964b8ff6/" rel="bookmark">
			Ip2region 离线IP地址定位库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ip2region 是什么 ip2region v2.0 - 是一个离线IP地址定位库和IP定位数据管理框架，10微秒级别的查询效率，提供了众多主流编程语言的 xdb 数据生成和查询客户端实现。
GitHub首页
xdb包下载
java使用首页
支持Python、Java、Go 等多种主流开发语言，详情见首页
ip2region xdb java 查询客户端实现 使用方式 maven 仓库： &lt;dependency&gt; &lt;groupId&gt;org.lionsoul&lt;/groupId&gt; &lt;artifactId&gt;ip2region&lt;/artifactId&gt; &lt;version&gt;2.6.5&lt;/version&gt; &lt;/dependency&gt; 完全基于文件的查询 import org.lionsoul.ip2region.xdb.Searcher; import java.io.*; import java.util.concurrent.TimeUnit; public class SearcherTest { public static void main(String[] args) { // 1、创建 searcher 对象 String dbPath = "ip2region.xdb file path"; Searcher searcher = null; try { searcher = Searcher.newWithFileOnly(dbPath); } catch (IOException e) { System.out.printf("failed to create searcher with `%s`: %s\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af8acf97b7b592fdb58cba14964b8ff6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a26822a051c4a6692619b5b49bdbcca5/" rel="bookmark">
			爬虫实战案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 实战携程案例，也是一个学习总结
目标： 全国景区名
1.数据分析 目标网站pc段实在不好分析，于是想到了手机端
目标网站异步加载，目标数据存放在名为getAttractioList?*****下
分析一遍后发现一个头疼的事，下一页的token参数在上一页的响应数据里，这里后面代码要注意一下
因为目标要求是全国景区数据，这里只是上海，通过分析负载数据，得知count是每页的数据条，districtId是城市Id，上海就是2，北京是1
通过对响应数据的分析，这里用xpath解析最方便，在postman分析一段时间后也是将初步数据拿下来了
代码块 self.jq_payload ={ "index": 1, "count": 20, "sortType": 1, "isShowAggregation": True, "districtId": 2, "scene": "DISTRICT", "pageId": "214062", "traceId": "63675663-049d-d442-3189-93e543806482", "extension": [ { "name": "osVersion", "value": "13.2.3" }, { "name": "deviceType", "value": "ios" } ], "filter": { "filterItems": [] }, "crnVersion": "2020-09-01 22:00:45", "isInitialState": True, "head": { "cid": "09031138417081694673", "ctok": "", "cver": "1.0", "lang": "01", "sid": "8888", "syscode": "09", "xsid": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a26822a051c4a6692619b5b49bdbcca5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/134/">«</a>
	<span class="pagination__item pagination__item--current">135/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/136/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>