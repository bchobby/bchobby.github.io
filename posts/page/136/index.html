<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65cf511f665e6961fd526b16f1ee5167/" rel="bookmark">
			学长告诉我，大厂MySQL都是通过SSH连接的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是咔咔 不期速成，日拱一卒
一、背景 之前待的几个公司，数据库、服务器权限都是给所有后端直接拉满的，但也会出现员工离职的情况，每次有人离职时都需要改数据库密码、服务器密码。
每次密码修改后得告知所有开发修改本地密码，但这样的事情也不是经常发生，公司虽小但很稳定。
假设你所待的公司是一个开发非常多的公司，有可能你待了一年还没认识全，人员流动的速度也非常快，这时上面那种方案的执行成本就非常高了。
若此时把这个问题抛给你，让你解决你会有什么方案？
接下来给大家介绍两种方案，一种传统方案另一种是通过SSH来实现的。
二、传统方案 MySQL版本：8.0.26
其中最简单的方案就是给每个人在数据库添加一个账号，具体步骤如下：
创建新用户
create user "kaka"@"%" identified by 'qwerty123456'; 其中kaka为自定义的用户名；%为登录域名，host为’%'时表示为 任意IP，为localhost时表示本机，或者填写指定的IP地址；qwerty123456为密码
为用户授权
grant all privileges on kaka.* to "kaka"@"%" with grant option; 或 grant all on *.* to "kaka"@"%"; 其中kaka.*,kaka为数据名，*为所有表，如果想授权全部表就把kaka.*写成*.*，当然这里是以开发库为基础的，所有的权限都得给。当前也可以给予部分权限。
刷新权限
flush privileges; 使用用户名：kaka进行登录
发现kaka用户只有两个库，kaka库就是授权的库，当切换系统库时发现是没有权限的。
在切到kaka库，是可以做正常的curd操作的
给予部分权限
grant update on kaka.* to "kaka"@"%"; flush privileges; 若想给多个权限，则逗号隔开即可，update,select,insert …，执行完切记需要刷新权限，否则不会生效
撤销全部权限
这块有点小插曲，当执行撤销命令后报了这样一个错
Access denied; you need (at least one of) the SYSTEM_USER privilege(s) for this operation 查阅了一下官方文档，原因是由于root用户没有SYSTEM_USER权限，把权限加入后即可解决
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65cf511f665e6961fd526b16f1ee5167/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d51bd0f8992675b65f3266b9fc52c857/" rel="bookmark">
			多线程_线程插队_join()方法与锁的释放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程插队 线程执行join()方法后，其他线程将会等待该线程终止后再执行
若给join()方法添加参数，则效果为：仅允许该线程插队参数毫秒
锁的释放 join()方法对于锁的释放，在不同的情况下会有不同的表现
先说结论：join()方法只会释放被调用线程的对象锁
情景一：String对象被上锁，锁为String的对象锁
package cn.alan.threadState; //测试插队线程 public class TestJoin implements Runnable{ String hello; public TestJoin(String hello) { this.hello = hello; } @Override public void run() { synchronized (hello){ for (int i = 0; i &lt; 5; i++) { System.out.println("插队线程执行" + hello); } } } public static void main(String[] args) throws InterruptedException { String hello = "hello"; //启动插队线程 Thread thread = new Thread(new TestJoin(hello)); thread.start(); synchronized (hello){ //主线程 for (int i = 0; i &lt; 10; i++) { if (i==5){ thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d51bd0f8992675b65f3266b9fc52c857/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5a37a4cf1ec745b9539ec0f84969c7b/" rel="bookmark">
			@ExcelProperty 使用占位符，实现动态表头效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@ExcelProperty 使用占位符，实现动态表头效果
@ExcelProperty 使用占位符，实现动态表头效果 easyexcel 想实现动态表头，根据官方文档，采用以下方式：
private List&lt;List&lt;String&gt;&gt; head() { List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;List&lt;String&gt;&gt;(); List&lt;String&gt; head0 = new ArrayList&lt;String&gt;(); head0.add("字符串" + System.currentTimeMillis()); List&lt;String&gt; head1 = new ArrayList&lt;String&gt;(); head1.add("数字" + System.currentTimeMillis()); List&lt;String&gt; head2 = new ArrayList&lt;String&gt;(); head2.add("日期" + System.currentTimeMillis()); list.add(head0); list.add(head1); list.add(head2); return list; } 个人感觉该方式不够灵活，且实体类中定义的样式也失效了，如果表格字段较多，需要写一大堆List。经过研究，通过另一种方式实现动态表头效果。
定义导出实体类，此处省略get、set方法 public class UserModel { @ExcelProperty(value = {"${title}", "姓名"}) private String name; @ExcelProperty(value = {"${title}", "生日"}) @DateTimeFormat(value = "yyyy-MM-dd") private Date birth; @ExcelProperty(value = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5a37a4cf1ec745b9539ec0f84969c7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7050474b4150fdeaf7c475da08889539/" rel="bookmark">
			爬虫-爬取某小说网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：要爬取某个小说所有章节的网址，再通过爬虫将每一章的内容爬取下来，再本地创建一个文件夹，并且把小说分别保存到这个文件夹中。每一章保存为一个文件。思路：首先是再网址里面获取每一章节的链接，再解析每一个章节的链接中获得文章的标题以及内容，之后再存储。代码如下所示： import re import os import requests # 获取每一章的链接，拼接成网址 def get_toc(html): """ 获取每一章的连接存储到一个列表中并返回 :param html:目录页源代码 :return:每章节链接 """ toc_url_list = [] start_url = 'https://www.kanunu8.com/book3/6879/' toc_block = re.findall('正文(.*?)&lt;/tbody&gt;', html, re.S)[0] toc_url = re.findall('href="(.*?)"', toc_block, re.S) for url in toc_url: toc_url_list.append(start_url + url) return toc_url_list def get_article(html): """ 获取每一章的正文并返回章节名和正文 :param html:正文源代码 :return:章节名，正文 """ chapter_name = re.search('size="4"&gt;(.*?)&lt;', html, re.S).group(1) text_block = re.search('&lt;p&gt;(.*?)&lt;/p&gt;', html, re.S).group(1) text_block = text_block.replace('&lt;br /&gt;', '') text_block = re.sub('\r\n\r\n', '\r\n', text_block) return chapter_name, text_block # 保存的代码 def save(chapter, article): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7050474b4150fdeaf7c475da08889539/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b895be506cfcda519316b6551a21eb89/" rel="bookmark">
			Linux常见目录说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录/bin存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里。/etc存放系统管理和配置文件/home存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示/devdev是device的缩写 存放的是Linux的外部设备 在Linux中访问设备的方式和访问文件的方式是相同的/root这里存放的是启动Linux时使用的一些核心文件 包括一些连接文件以及镜像文件/usr用于存放系统应用程序，比较重要的目录/usr/local 本地系统管理员软件安装目录（安装系统级的应用）。这是最庞大的目录，要用到的应用程序和文件几乎都在这个目录。/usr/x11r6 存放x window的目录/usr/bin 众多的应用程序 /usr/sbin 超级用户的一些管理程序 /usr/doc linux文档 /usr/include linux下开发和编译应用程序所需要的头文件 /usr/lib 常用的动态链接库和软件包的配置文件 /usr/man 帮助文档 /usr/src 源代码，linux内核的源代码就放在/usr/src/linux里 /usr/local/bin 本地增加的命令 /usr/local/lib 本地增加的库/user/bin系统用户使用的应用程序/user/src内核源代码默认的防止目录/opt额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里。/proc虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息。/root超级用户（系统管理员）的主目录/sbin存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等。/dev用于存放设备文件。/mnt系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统。/boot存放用于系统引导时使用的各种文件/lib存放跟文件系统中的程序运行所需要的共享库及内核模块。共享库又叫动态链接共享库，作用类似windows里的.dll文件，存放了根文件系统程序运行所需的共享文件。/tmp用于存放各种临时文件，是公用的临时文件存储点。/var用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等。/lost+found这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里/run是一个临时系统文件 存储系统启动以来的信息 当系统重启时 这个目录下的文件应该被删掉或清除 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96539822ee9016195d719979987f749e/" rel="bookmark">
			jmeter教程系列（21）阶梯压测找到适合的最大并发数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jmeter阶梯压测找到最大并发数 1.设置阶梯压测方案
说明：
在5秒内增加10个并发用户数，并运行60秒，再继续在5秒内增加10个并发用户数，重复循环，直至并发用户数达到100后，脚本持续运行60秒。然后在每1秒内减少5个并发用户数，直到减为0，结束脚本的运行。
2.设置监控插件
监测吞吐量
监测响应时间
监测用户执行情况
说明：
首先明确平均响应时间的指标2秒，查看吞吐量是都连续并且正常，查看响应时间图表，找到2秒范围内对应的日期范围，在用户表中找到对应的日期范围，明确支持的最大并发数区间。
（3）根据最大并发数区间，减少阶梯线程的步长
说明：
减少步长数据能够判断最准确的支持的最大并发数，之后通过上述的验证方法推断出最合理的支持的最大并发数。
注意：
以上数据均以响应时间为2秒为基准
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/206e34808de92e29a992b54ac8885db7/" rel="bookmark">
			【重铸Java根基】Java中的IO基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IO 即 Input/Output，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。
Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。
InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 从类型上分，分为字节流和字符流
字节流 InputStream（字节输入流） InputStream用于从源头（通常是文件）读取数据（字节信息）到内存中，java.io.InputStream抽象类是所有字节输入流的父类。
InputStream 常用方法 ：
read() ：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 -1 ，表示文件结束。read(byte b[ ]) : 从输入流中读取一些字节存储到数组 b 中。如果数组 b 的长度为零，则不读取。如果没有可用字节读取，返回 -1。如果有可用字节读取，则最多读取的字节数最多等于 b.length ， 返回读取的字节数。这个方法等价于 read(b, 0, b.length)。read(byte b[], int off, int len) ：在read(byte b[ ]) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字节数）。skip(long n) ：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。available() ：返回输入流中可以读取的字节数。close() ：关闭输入流释放相关的系统资源。 FileInputStream 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/206e34808de92e29a992b54ac8885db7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf0437ee1e92823713c161645d73df3f/" rel="bookmark">
			【重铸Java根基】集合相关知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近带应届新员工，教然后知不足，发现自己把很多基础知识已经还给了大学老师，因此开贴，温故而知新！
在网上找了系统的学习资源，从头复习
从最基础的Java知识开始由浅入深，在某个知识点中遇到有疑惑的点会额外多写几句或者单独开帖子展开。
Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 Collection接口，主要用于存放单一元素；另一个是 Map 接口，主要用于存放键值对。对于Collection 接口，下面又有三个主要的子接口：List、Set 和 Queue。 Java 集合框架如下图所示：
List, Set, Queue, Map 四者的区别 List(对付顺序的好帮手): 存储的元素是有序的、可重复的。Set(注重独一无二的性质): 存储的元素是无序的、不可重复的。Queue(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。Map(用 key 来搜索的专家): 使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。 集合框架底层数据结构总结 先来看一下 Collection 接口下面的集合。
List
ArrayList： Object[] 数组Vector：Object[] 数组LinkedList： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环) Set
HashSet(无序，唯一): 基于 HashMap 实现的，底层采用 HashMap 来保存元素LinkedHashSet: LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的 LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的TreeSet(有序，唯一): 红黑树(自平衡的排序二叉树) Queue
PriorityQueue: Object[] 数组来实现二叉堆ArrayQueue: Object[] 数组 + 双指针 再来看看 Map 接口下面的集合。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf0437ee1e92823713c161645d73df3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/064ba9c649dfaffe45d93792d688b00b/" rel="bookmark">
			shopping高级篇-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Elastisearch-介绍及安装 简介 mysql用作持久化存储，ES用作检索 基本概念：
index索引 名词：相当于mysql的db，数据库
Type类型 在index中，可以定义一个或多个类型
类似于mysql的table，每一种类型的数据放在一起
index库&gt;type表&gt;document文档
Document文档 保存在某个index下，某种type的一个数据document，文档是json格式的，
document就像是mysql中的某个table里面的内容。每一行对应的列叫属性
检索机制 102、全文检索-ElasticSearch-简介_哔哩哔哩_bilibili
安装elastic search dokcer中安装elastic search
下载ealastic search（存储和检索）和kibana（可视化检索）
docker pull elasticsearch:7.4.2
docker pull kibana:7.4.2
注意版本要统一
配置
mkdir -p /usr/local/elasticsearch/plugins
mkdir -p /usr/local/elasticsearch/config
mkdir -p /usr/local/elasticsearch/data
# es可以被远程任何机器访问
echo "http.host: 0.0.0.0" &gt;/usr/local/elasticsearch/config/elasticsearch.yml
# 递归更改权限，es需要访问
chmod -R 777 /usr/local/elasticsearch
启动Elastic search
# 9200是用户交互端口 9300是集群心跳端口
# -e指定是单阶段运行
# -e指定占用的内存大小，生产时可以设置32G
sudo docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/064ba9c649dfaffe45d93792d688b00b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8b6f6a5f1d8307b26a34b01231bc900/" rel="bookmark">
			Centos 7 用户密码忘记解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、重启系统，开机进入GRUB界面，在引导程序菜单上进行选择
2、按"e"键进入
3、用上下箭头翻到最后，编辑修改两处：ro改为rw,在LANG=en_US.UFT-8后面添加init=/bin/sh（若LANG=en_US.UFT-8 可以为LANG=zh_CN.UFT-8，不改也没关系，如果汉化了，个别地方会有乱码，但是，并不影响修改密码）
4、修改好后，按clter+x键进入命令行修改密码。修改用户root与用户meng密码。
5.由于selinux开启着的需要执行以下命令更新系统信息,否则重启之后密码未生效
touch /.autorelabel
6、输入exec /sbin/init 命令，重启进入登录界面，输入新密码进行登录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fa1bb6e16492b6577df49596508e5c7/" rel="bookmark">
			linux下docker搭建Nexus3私有镜像仓库，超详细版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先先拉取nexus3镜像，输入
docker pull sonatype/nexus3 不输入标签默认拉取最新的镜像，如下：
2、输入
docker images 查看是否拉取成功。
3、创建两个子目录
mkdir docker_nexus3 mkdir docker_nexus3/nexus-data 用于等会挂载内部目录。
4、输入
chown -R 200 docker_nexus3/nexus-data 修改刚刚创建的目录属组权限，用于在nexus3内拥有写入权限。
5、输入
chmod 777 docker_nexus3/nexus-data/ 修改目录权限。
6、开始启动容器，输入如下，等待几分钟。（这里楼主云服务器配置较弱，需要改启动容器的配置，这里改为1核2G，以防启动报错；配置强大的同学可以不用加这一条命令，直接使用下面的命令。配置弱的同学可以拉到最底看下面有情景处理方法）
docker run -d \ --privileged=true \ --name=the_nexus3 \ -p 6000:6000 \ -p 8088:8081 \ -v /root/docker_nexus3/nexus-data:/nexus-data \ sonatype/nexus3 #-e INSTALL4J_ADD_VM_PARAMS="-Xms256M -XX:MaxDirectMemorySize=2048M" \ 命令解读 --privileged=true 用于在容器内也拥有root权限 -p 6000:6000 此端口号是用于使用docker账号推送下载的端口号 -p 8088:8081 此端口号是浏览器上查看nexus3服务的端口 -v /root/docker_nexus3/nexus-data:/nexus-data 挂载本地目录到容器内部目录，记住本地目录一定是绝对路径 7、用如下命令：
docker logs the_nexus3 -f 查看运行日志是否安装成功；出现如下则启动成功。
8、初始登录需要去查看初始密码，在挂载的本地目录下查看初始密码，输入
cat docker_nexus3/nexus-data/admin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fa1bb6e16492b6577df49596508e5c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b8f6671f654b8c18a63a8b48834e6a3/" rel="bookmark">
			加法器、半加器、全加器、超前进位加法器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、半加器二、全加器三、超前进位加法器关键点 一、半加器 简单来讲，半加器不考虑低位进位来的进位值，只有两个输入，两个输出。由一个与门和异或门构成.
真值表：
输入输出ABCS0000010110011110 半加器不考虑低位向本位的[进位]，因此它不属于[时序逻辑电路]，有两个输入端和两个输出。
设加数（输入端）为A、B ；和为S ；向高位的进位为Ci+1
逻辑表达式：
verilog 数据流级描述：
//半加器模块 module adder_half( input	wire	a, input	wire	b, output	reg	sum, output	reg	cout); always @(*) begin sum = a ^ b; cout = a &amp; b; end endmodule RTL电路
二、全加器 全加器比半加器多了一位进位：
输入：A、B、Ci-1
输出：S、Ci
真值表：
输入输出Ci-1AiBiSiCi0000000110010100110110010101011100111111 一位全加器的表达式如下：
Si=Ai⊕Bi⊕Ci-1
第二个表达式也可用一个异或门来代替或门对其中两个输入信号进行求和：
verilog代码实现一(用两个半加器和一个或门实现一个全加器)结构性描述：
//full_adder module adder_full(a,b,cin,,cout,sum); input a,b,cin; output cout,sum; wire w1,w2,w3; adder_half u1(.a(a),.b(b),.sum(w1),.cout(w2)); adder_half u2(.a(cin),.b(w1),.sum(sum),.cout(w3)); assign cout = w2 | w3; endmodule 结构性描述的RTL电路
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b8f6671f654b8c18a63a8b48834e6a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70268951bb31fb872d71f266a5c65dcd/" rel="bookmark">
			银河麒麟操作系统（kylin os）学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 poweroff # 关机命令sudo su # 进入超级用户su username # 切普通用户Ctrl+Alt+t # 打开终端terminal窗口Ctrl+Alt+d # 最小化全部应用，然后显示桌面dpkg -i libqt5.deb # 安装deb类型的软件包./abc # 运行Qt编译后的可执行文件abcCtrl+Alt+d # 锁屏chown -R root demo #修改文件夹demo以及其子文件的拥有者为root用户 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48b661db04c7c0e16f5cafe937184564/" rel="bookmark">
			【Matlab绘图进阶第5弹】Matlab绘制三维散点图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		散点图又称之为气泡图、主要分为二维散点图与三维散点图、常用于反映数值之间的相对位置、在工科方面常见于机器学习和深度学习分类算法中的特征密度展示。本期为三维散点图绘制、后续会出二维散点图教程。下面来和我一起实现散点图的绘制吧！
成图效果展示 绘图三步走 取色
取色的核心是获取0-1之间的RGB值矩阵、配色的好坏直接决定着图形的颜值高低、论文的门面即是图表。
数据准备
三维散点图的数据主要包括X、Y、Z、ZF三维或者四维度数据矩阵、其中ZF为数据点的特征列、决定颜色深浅与散点大小。
函数使用
三维散点图的函数主要为scatter3、二维散点图函数为scatter。
👉 1. 取色 此次取色步骤和之前取色过程不同、三维散点图需要很多种颜色渐进、即colormap，大小约为n*3的数据矩阵，需要选取两种基础色进行线性插值、具体基础色如下图： 接着对两种颜色进行线性插值、生成n组RGB值，实现一个颜色柱的绘制、从而得到一个完整的色系。生成后的色系图如下：
如上图所示、由两种基础色——完整的色彩柱就生成啦，大小为n*3，并将其保存为mycolor.mat文件用于matlab读取。
👉 2. 数据准备 数据是小编用随机数函数randperm生成的四维度数据，分别为X、Y、Z、ZF，其中前者为三维数据点、后者为数据特征大小与颜色深浅，具体代码如下：
%% 随机生成X,Y,Z数据 X = 1:64; Y = randperm(64); Z = randperm(64); ZF = randperm(64)*30;% 散点特征：散点值大小/颜色深浅 👉 3. 函数使用 绘制三维散点图主要函数为scatter、参数分别为X、Y、Z、ZF与颜色矩阵n*3。下面为主要绘图代码：
%% 导入所有颜色矩阵 % 颜色文件有8种颜色map load mycolor.mat; %% 开始绘制三维散点图 mycolor_value= mycolor1; figure('color',[1 1 1]); scatter3(X,Y,Z,ZF,mycolor_value,'.'); colormap(mycolor_value); colorbar() 接下来是完善坐标区与各个标题信息。
%% 完善图例与坐标区 xlabel('X','Fontname','微软雅黑'); ylabel('Y','Fontname','微软雅黑'); zlabel('Z','Fontname','微软雅黑'); title('三维散点','Fontname','微软雅黑'); set(gca,'Box','on'); ax = gca; ax.BoxStyle = 'full'; set(gca,'Xgrid','off','Ygrid','off','Zgrid','off'); set(gca,'Linewidth',1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48b661db04c7c0e16f5cafe937184564/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7936c856a44fea4fbf96bc6d009d35da/" rel="bookmark">
			【C语言基础】12 字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、字符串与字面串 字面串：
用一对双引号括起来的字符序列(程序文本)，是源文件的组成部分，仅表示字面意思。如“Hello”（占6个字符，默认含0），与字符串常量不同，字面串是可更改的。
字符串：
字面串经编译后生成字符串，位于系统存储器内、以空字符结尾的字符序列。
如char word[] = {'H', 'e', 'l', 'l', 'o', '!', '\0'}; （是字符数组，也是字符串）
字符数组：
如char word[] = {'H', 'e', 'l', 'l', 'o', '!'}; （是字符数组，但不是字符串）
说明：
字面串中的空格（如"Good morning!"）不是空字符，空格的ASCII码是32，空字符的ASCII码是0。 1.1 字面串中的转义序列 字面串中可以使用转义序列，如\n等。
“Hello, \nWorld!”
**/八进制数转义序列： 在3个数字或非八进制数字符处结束。例如："\1234"包含两个字符(\123和4)，"\189"包含三个字符(\1，8和9)。 十六进制数转义序列：结束于第一个非16进制数字符处。范围通常在\x0~\xff之间。 见本章的转义序列部分
1.2 延续字符串 字符串太长，在下一行延续。
1.2.1 使用字符'\' 次行需顶格写，否则Tab符会被输出。
printf("Amateurs sit and wait for inspiration, \ the rest of us just get up and go to work. -Stephen King"); 1.2.2 分割成多条字符串 编译器会将相邻字符串自动相连，无需顶格写。
*820
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7936c856a44fea4fbf96bc6d009d35da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b11155276375438096b0c61d43c59a/" rel="bookmark">
			Threejs基础代码段（三）科技感线框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提到线框，第一想到的是wireframe，显示几何体的内部线条，通常的方式为：
child.material.wireframe = isShow; 其效果如下：
对于简单几何体，其线框模式能勾勒外部轮廓线，效果尚可，但对于复杂模型，显示wireframe后会出现许多三角形，如下所示，这是我们所不需要的。
我们的目的是显示几何体，勾勒模型简易轮廓，赋予半透明材质，突出科技感。
先看效果，线框之前：
线框后效果： 这里主要用到了EdgesGeometry（几何体边框辅助线）
EdgesGeometry( geometry : Geometry, thresholdAngle : Integer ) 示例代码：
1.需要创建一个几何体
2.将几何体传给EdgesGeometry的构造函数
3.创建基础线条材质，并创建线框分段THREE.LineSegments
4.最后将创建的线框加入的几何体中
// EdgesGeometry线框1 var line = null; const lineMaterial = new THREE.LineBasicMaterial({color: '#1E90FF'}); function edgeGeometryWireframe(model, isShow){ if(model){ if(!line){ line = new THREE.Group(); model.traverse(function(child){ if (child.isMesh){ let edges = new THREE.EdgesGeometry(child.geometry); let lineS= new THREE.LineSegments(edges, lineMaterial); line.add(lineS); } }); scene.add(line); } model.visible = !isShow; line.visible = isShow; } } // EdgesGeometry线框2 var gbg2 = mFloor2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58b11155276375438096b0c61d43c59a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96a6889db46e7d946a36c08629aec1fa/" rel="bookmark">
			华为防火墙USG6000V三种管理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为防火墙USG6000V三种管理方法 Web登录管理 Telnet登录管理 SSH登录管理 本次实验的拓扑 首先完成基本的网络配置： 1.打开添加完成的网卡，配置IP 地址：192.168.74.254 255.255.255.0。（这里需要创建一个环回口网卡，创建方法，我的上一篇博客有介绍）
2.添加云，点击 增加。
3.然后，选择刚刚添加的网卡，点击 增加。
4.选择 入端口 和 出端口 编号，打钩 双向通道，点击 增加。
5.最后，端口映射表出现则表示成功。
启动防火墙 接下来就配置防火墙，由于第一次打开防火墙，需要修改密码，否则无法进入。
防火墙的G0/0/0是网管口，不跑业务数据，仅做网管 ；默认ip是 192.168.0.1/24
华为防火墙默认账号：admin
华为防火墙默认密码：Admin@123
修改的密码可以自定义，本实验以该密码为例：huawei@123
Web登录管理防火墙 1.进入防火墙之后，配置网管口的IP地址：192.168.74.100/24；并切允许 ping、http、 https、服务的流量通过，默认是拒绝一切服务。
命令如下：
&lt;FW&gt;system-view [FW1]interface GigabitEthernet0/0/0 [FW1-GigabitEthernet0/0/0]ip address 192.168.74.100 255.255.255.0 [FW1-GigabitEthernet0/0/0]service-manage http permit [FW1-GigabitEthernet0/0/0]service-manage https permit [FW1-GigabitEthernet0/0/0]service-manage ping permit 2.然后在Windows 上打开 CMD ，检查网络的连通性。
3.然后打开浏览器，输入http://192.168.74.100 进入防火墙的web界面。输入账户名密码登录。
到此，web登录防火墙的实验到此结束。
Telnet登录管理防火墙 1.首先打开路由器，配置IP地址 192.168.74.200/24
[AR1]interface GigabitEthernet 0/0/0 [AR1-GigabitEthernet0/0/0]ip add 192.168.74.100 24 2.在防火墙上做如下配置：
&lt;FW1&gt;system-view [FW1]telnet server enable [FW1]user-interface vty 0 4 [FW1-ui-vty0-4]protocol inbound all 支持所有的协议 [FW1-ui-vty0-4]set authentication password cipher huawei@123 [FW1-ui-vty0-4]user privilege level 3 [FW1]interface gi0/0/0 [FW1-GigabitEthernet0/0/0]service-manage telnet permit 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96a6889db46e7d946a36c08629aec1fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/852a3f8eaee48a7e8bea8438ef7df0bc/" rel="bookmark">
			【前端面试之缓存】js本地缓存、浏览器缓存、服务器缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、javaScript本地缓存的方法 cookie、sessionStorage、localStorage、indexedDB 下表是cookie、sessionStorage、localStorage之间的区别
––––Cookie4K只能被同源的页面访问共享、每次发起同源请求的时候，会发送给服务器结合token来使用，这样服务器就知道是谁发起的请求了、可以用来统计页面的点击次数LocalStorage5Mb持久化存储，不会随着页面的关闭而消失、同源访问网站换肤、不常变更的个人信息sessionStorage5MB表示一次会话中保存的数据、当前窗口关闭会失效、只能被同一个窗口的同源页面访问共享敏感账号一次性登录，推荐使用sessionStorage Cookie通过设置Expires，来决定什么时候过期。
localStorage 有两个缺点：
- 无法像Cookie一样设置过期时间
- 只能存入字符串，无法直接存对象
关于cookie的使用如下： document.cookie = '名字=值'; 关于localStorage的使用 localStorage.setItem('username','cfangxu'); localStorage.getItem('username') localStorage.removeItem('username') localStorage.clear() indexedDB
是一种低级API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该API使用索引来实现对该数据的高性能搜索。基本上数据库能干的事它都能干。
2、强缓存、协商缓存 缓存的定义：浏览器在本地磁盘上将用户之前请求的数据存储起来，当用户再次请求该数据时，不用发送http请求，直接从浏览器本地获取。
1、强缓存：
不会像服务器发送请求，直接从本地缓存中获取数据请求资源的状态码为200比如说是百度的Logo图标，马上到8-1建军节，那么只需要把Cache-Control的值设为0就可以了。
下面这个图就是百度的Logo图片的响应头：
2、协商缓存： 协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。
存在etag还有last-modified这两个参数时用于控制协商缓存的时间的。请求头里面的if-modified-since还有if-none-match这俩参数是很有用的。服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。协商缓存是由服务器来确定缓存资源是否可用，所以客户端与服务器端都通过某种标识来进行通信，从而让服务端判断请求资源是否可以缓存访问。 强缓存和协商缓存的区别：都是从浏览器端读取资源。不同点是：1、强缓存不发请求给服务器。2、协商缓存发请求给服务器，根据服务器返回的信息决定是否使用缓存。
3、什么是CDN CDN(内容分发网络)：是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠的将 音乐、图片、视频、应用程序及其他文件发送给用户来提高性能。
当用户群激增的时候，公司就必须在多个地理位置不同的服务器上部署，为了缩短http请求时间，我们应该把大量的静态资源放置的离用户近一点。CDN本质上就是根据用户区域的不同，让用户从CDN服务器集群中最近的节点，去做访问。
用户使用CDN缓存资源的过程：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a10b8f114f6cb2d69e72b4c11a0d138/" rel="bookmark">
			移除超出规定List最大数量的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 List&lt;int&gt; _lstInfos = new List&lt;int&gt;(); int _maxCountHold = 10; // 移除超出最大数量的行 private void RemoveList() { var countNeedRemove = _lstInfos.Count - _maxCountHold; if (countNeedRemove &gt; 0) { _lstInfos.RemoveRange(0, countNeedRemove); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e572e38abadb18b5c31fc9dbf810fb48/" rel="bookmark">
			因果推断-PSM的原理及python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、背景：员工技能培训真的是浪费时间吗
二、PSM的原理及python实现
1、PSM的原理
1.1 计算倾向性得分
1.2 匹配对照组样本
1.3 平衡性检查
1.4 敏感度分析
2、PSM的python实现
一、背景：员工技能培训真的是浪费时间吗 假设你是一家大企业的老板，你希望知道员工技能培训对员工生产率的提升有多大帮助。已知参加培训的员工有500人，于是你又随机抽取了500个未参加培训的员工，观察两组之间生产率的差值（ATE），并打算以此作为培训对生产率提升的因果效应。结果发现，两组员工的生产率相差不大，于是你得出“员工培训都是浪费时间”的结论。
试问，这个老板得到的结论正确吗？我们且不说结论本身是否正确，但是可以确定老板得到结论的过程缺乏科学性（不满足CIA假设）。因为我们知道这两组员工本身生产能力可能就有差别，参加培训的员工往往都是技能水平不足想要提升的，而技能优秀的员工一般都不会参加培训。直接将两组生产率作差值忽略了两组员工本身技能水平的差异，这样计算得到的因果效应会偏小。那该怎么做才能得到正确的结论呢？
最理想的做法是说，让参加了培训的张三再倒退回参加培训前的时间点（回溯），然后不参加培训再过一遍人生，看看这两个人生的张三生产率有什么差异（ATT）。很明显，时光无法倒流，最真实的因果效应只停留在理论层面。但是可以退而求其次，尽最大努力去寻找一个没有参加培训的李四，他在各方面都和张三是一样的（替身），简直是张三的翻版。于是我们通过比较张三和李四生产率的差异，也能够得出比较准确的因果效应（ATT估计值）。那么该如何寻找李四呢？
二、PSM的原理及python实现 1、PSM的原理 这里倾向得分匹配（PSM，Propensity Score Matching）就要登场了。PSM通俗理解是说，首先计算每个人参加培训的倾向性，然后根据倾向性最相似的原则，为每个参加培训的人匹配未参加培训的人，最后计算两组人群的均值差异作为ATT的估计值（因果效应）。下面是PSM的详细步骤：
1.1 计算倾向性得分 关于PSM倾向性得分的计算方式，不能用简单的欧氏距离来计算是因为欧氏距离对每个协变量的权重是一样的，当协变量维度很高时会影响得分的计算效果。一般用LR来计算倾向性得分，因为LR能够赋予协变量不同的权重。还有很多方法比如用Propensity Tree来计算得分等等。
1.2 匹配对照组样本 倾向性得分计算完成后，还需要为实验组的每个样本，从对照组中采集合适的样本去做匹配。PSM匹配环节有以下几个要点：
1）采样方式，有放回or无放回采样：从对照组抽取样本去匹配实验组样本时，被抽到的对照组样本是否允许放回。
2）匹配方式，局部最优or全局最优：应当追求为实验组每个样本找到的替身都是最匹配的（局部最优），还是整体来看实验组找到的替身是最匹配的（全局最优）。
3）匹配数量，一对一or一对多：一个实验组样本匹配一个对照组样本（一对一，偏差小，方差大），还是一个实验组用户匹配多个对照组用户（一对多，偏差大，方差小）。
4）匹配质量，有卡尺or无卡尺：实验组和对照组做匹配时，他们之间相似度是否需要限制在一定范围内（有卡尺），还是只要当前对照组样本是最匹配的即可（无卡尺）。
1.3 平衡性检查 如何衡量PSM的匹配效果？或者说怎么判断PSM后实验组和对照组是否是同质的呢？下面介绍3种评估平衡性的方法：
1）观察法：直接做协变量分布的直方图或QQ-Plot，观察实验组和对照组的协变量是否符合同一分布。
2）量化法：计算每个混淆变量的标准化差值（stddiff），stddiff越小说明混淆变量在实验组和对照组间越均衡，因果效应的估计值也就越可靠。
3）卡方检验：每个协变量和treatment做卡方检验，若检验通过（p&gt;0.05）则说明协变量和treatment是相互独立的，检验未通过（p&lt;0.05）说明协变量对treatment是有影响的，因果效应中来自协变量的影响没有剔除干净。
目前为止，我们已经有一对接近同质的实验组和对照组了，接下来就可以估算实验的ATT了，最简单的做法是计算实验组和对照组均值的差值。
如果平衡性检查都通过了，说明已经得到了同质的实验组和对照组，下面就可以放心估计因果效应了。最简单的方法，是将两组样本均值直接做差，将差值作为因果效应的估计值。
1.4 敏感度分析 如何衡量我们估计的因果效应是不是可靠的呢？具体地说，混淆变量的主观选择会得到不一样的结论吗？当干预变量T不存在时，因果效应还会存在吗？下面介绍常用的评估方法，即反驳测试：
1）安慰剂数据法：随机生成一列数据替代真实的treatment列，每个个体接收处理的事实已经不存在了，因此如果反驳测试中的因果效果大幅下降且接近0，说明了treatment对target具有一定的因果效应。
2）添加随机混淆变量法：添加一列随机生成的混淆变量，若反驳测试的因果效应较真实因果效应估计值变化不大，则说明其因果效应的估计值是可靠的。
2、PSM的python实现 下面介绍一个用Python实现PSM的案例，即新建诊所是否能降低新生儿死亡率。
数据样例：
OPTUM_LAB_IDCASEinfant_mortalitypoverty_rateper_capita_doctors11100.50.0121150.60.0231220.70.0141190.60.0250250.60.0160190.50.027040.10.048080.30.059060.20.04 其中OPTUM_LAB_ID表示样本序号，CASE(T)表示“是否有诊所”，infant_mortality(Y)表示新生儿死亡率（百分比）。两个混淆变量，poverty_rate贫穷率和per_capita_doctors人均医生数量。
下面直接上完整的PSM代码，包括详细的注释：
import psmatching.match as psm import numpy as np # 数据集的地址，默认数据文件是csv格式，其他格式可能会报错 path=r'infant mortality.csv' # 计算倾向性得分的模型格式，格式：Y~X1+X2+...+Xn，其中Y为treatment列，X为协变量列 model = "CASE ~ poverty_rate + per_capita_doctors"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e572e38abadb18b5c31fc9dbf810fb48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e77bb451e0277fae9bc2a847cf87bc5e/" rel="bookmark">
			【重铸Java根基】理解Java代理模式机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近带应届新员工，教然后知不足，发现自己把很多基础知识已经还给了大学老师，因此开贴，温故而知新！
从最基础的Java知识开始由浅入深，在某个知识点中遇到有疑惑的点会额外多写几句或者单独开帖子展开。
​
什么是代理模式 简单来说就是 我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。
代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。
先来看一下最基本的静态代理 1.先创建一个接口，定义方法，并创建一个被代理类实现这个接口和方法
2.再创建一个代理类同样实现这个接口和方法，并且将被代理类注入到代理类中
3.在代理类中调用被代理类的同名方法，这样就可以在调用前后做更多的业务操作
静态代理中，我们对目标对象的每个方法的增强都是手动完成的（后面会具体演示代码），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类)。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。
下面说一下动态代理，动态代理在日常开发的业务代码中其实也很少见，但是在框架型项目中几乎是必不可少的，因此理解动态代理的原理有利于理解框架。
JDK动态代理 JDK动态代理基于接口、JDK提供的Proxy类和InvocationHandler类
调用Proxy类的newProxyInstance方法来创建一个代理对象
这个方法一共有 3 个参数：
public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException { ...... } loader : 目标类的类加载器。
interfaces : 目标类实现的一些接口；
h : 实现了 InvocationHandler 接口的对象；
其中h需要自己定义一个对象来实现InvocationHandler 接口，并重写里面的invoke方法，invoke方法内部就是具体的业务逻辑
public interface InvocationHandler { /** * 当你使用代理对象调用方法的时候实际会调用到这个方法 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; } invoke() 方法有下面三个参数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e77bb451e0277fae9bc2a847cf87bc5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8c084b1f1f307d3fbdaed32b2ce00d0/" rel="bookmark">
			git忽略文件不生效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.gitignore文件不生效
使用git提交代码希望忽略某些文件时，需要配置.gitignore。
不过已经提交后文件，再修改.gitignore文件会没有效果。
解决方案 # 清除缓存文件 git rm -r --cached . git add . git commit -m ".gitignore重写缓存" git push 重新提交后发现.gitignore文件生效了
原理解读 .gitignore文件只会在第一次提交项目的时候写入缓存，也就是说如果你第一次提交项目时候忘记写.gitignore文件，后来再补上是没有用的，.gitignore文件是不生效的。因为在缓存中已经标记该项目不存在ignore文件了（boolean）
所以我们使用git rm -r --cached .去清除所有的缓存。然后再次提交代码就可以了，这样.gitignore文件就会生效了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/262b755f058b612ed4b2bd45d40c5c10/" rel="bookmark">
			Docker -- sonarqube（ 这一款静态代码质量分析工具，支持Java、Python、PHP、JavaScript、CSS等25种以上的语言，而且能够集成在IDE、Jenkins、Git）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、sonarqube介绍 sonarqube是一款静态代码质量分析工具，支持Java、Python、PHP、JavaScript、CSS等25种以上的语言，而且能够集成在IDE、Jenkins、Git等服务中，方便随时查看代码质量分析报告；sonar通过配置的代码分析规则，从可靠性、安全性、可维护性、覆盖率、重复率等方面分析项目，风险等级从A~E划分为5个等级；同时，sonar可以集成pmd、findbugs、checkstyle等插件来扩展使用其他规则来检验代码质量；
二、sonarqube的安装 1、sonarqube最新版本已经不支持mysql数据库了，所以在安装之前需要先安装一个postgre数据库作为数据存储支持，编写文档的时候最新的版本为13.3（postgre）
docker pull postgres docker run -itd --hostname "jn-postgres" -p 10007:5432 \ --name "postgres" \ -e POSTGRES_PASSWORD=123456 \ -v /root/docker_vol/postgres/pgdata:/var/lib/postgresql/data \ postgres postgres默认用户名是postgres，可以使用工具软件来验证数据库是否安装成功。 2、设置参数vm.max_map_count
使用root账户修改etc下的sysctl.conf文件追加vm.max_map_count=262144 后保存。使用sysctl -p 查看是否生效 3、安装sonarqube
sudo docker run -itd --hostname "jn-sonar" -p 10008:9000 \ --name sonar \ --link postgres \ -e SONARQUBE_JDBC_URL=jdbc:postgresql://postgres:5432/sonar \ -e SONARQUBE_JDBC_USERNAME=postgres \ -e SONARQUBE_JDBC_PASSWORD=123456 \ -v /root/docker_vol/sonar/config:/opt/sonarqube/conf \ -v /root/docker_vol/sonar/extensions:/opt/sonarqube/extensions \ -v /root/docker_vol/sonar/logs:/opt/sonarqube/logs \ -v /root/docker_vol/sonar/data:/opt/sonarqube/data \ sonarqube:latest 三、使用sonarqube做代码质量检查 1、创建项目
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57bcae139b1fcd01241358f8da9fb7fa/" rel="bookmark">
			【自己写的.exe封装为Windows服务后开机自启动失败解决办法】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每天学习一点点 问题描述问题查找解决办法 问题描述 项目介绍：python Flask apcheduler
使用pyinstaller -F 将项目打包为.exe文件。
注册为windows服务，公司一个墨西哥项目，系统为win7 X64。
开机自启动失败（某些项目是可以开机自启动的）
注册为服务的.bat文件内容
# install.bat @echo.service begin.... @echo off cd /d %~dp0 set b=%cd% @sc query 你的服务名 &gt; NUL @if errorlevel 1060 goto notexist @goto exist :notexist @echo %b% @sc create你的服务名 binPath= "%b%\你的.exe文件名" displayname= "服务显示的名字" @goto end :exist @net stop 你的服务名 @sc delete 你的服务名 @goto notexist :end @net start 你的服务名 @sc config 你的服务名 start= AUTO @echo off @echo.service success..... @pause # uninstall.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57bcae139b1fcd01241358f8da9fb7fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c245805dadf4da362e2b539fb266220/" rel="bookmark">
			node中package解析、npm 命令行npm详解，node中的common模块化，npm、nrm两种方式查看源和切换镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		建立一个项目时： 初始化npm配置文件，生成一个package.json npm init -y package.json文件详解
{ "name": "0804", 项目名，不能有大写可以使用- / @连接 不能与现有的包名重名 "version": "1.2.3", 当前项目的版本 1大版本 2 小版本 3 微版本 大版本 当这个项目做了重构，有了重大改变时，大版本做调整 小版本 添加新的方法，逻辑，修改部分内容，迭代开发 微版本 修改代码bug，补充功能但是没有新增方法 "description": "", 描述如果将这个项目发布到npm云平台上，描述有利于别人搜索 "type": "commonjs", 说明nodejs的模块化方式 "main": "a.js", 入口文件 "scripts": { 脚本 "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" "脚本名":"命令内容" npm run 脚本名 就可以运行命令内容 运行命令优先查找当前的node_modules路径下是否有这个命令 start install 这种脚本名比较特殊 直接通过 npm 脚本名 start 开始 install 在执行npm i 以后自动运行 }, "keywords": [], 关键词 为了便于搜索 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c245805dadf4da362e2b539fb266220/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b13dd497319fff59d8e152b6ad6215aa/" rel="bookmark">
			使用python爬取招聘网站数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		八、九月份是一年中的求职高峰期，一大波应届毕业生涌入市场，加上疫情因素下，很多行业都没有那么景气，很多人应届生表示想要找到理想工作变得难上加难！
现在大家找工作都是通过各种招聘app,信息全部罗列出来，可是招聘信息有一些是错综复杂的。而且不能把全部的信息全部罗列出来,这样也让人很苦恼，所以今天我们就通过爬虫技术，为大家解决这个问题。首先我们的爬取目标是获取招聘信息，并批量把地点、 公司名、工资 、等详细资料做成文档。这里我们就以boss直聘为例。在获取数据之前简单的对网站进行了分析，该网站上的反爬主要有两点。1、 直接使用requests库，在不设置任何header的情况下，网站直接不返回数据。2、同一个ip连续访问多次，直接封掉ip。
为了解决这两个问题，最后经过研究，使用以下方法，可以有效解决。1、获取正常的 http请求头，并在requests请求时设置这些常规的http请求头。2、使用代理IP进行访问。代理IP的选择比较多，比如现在我们使用的亿牛云代理，简单实现过程如下：
#! -*- encoding:utf-8 -*- import requests import random # 要访问的目标页面 targetUrl = "http://httpbin.org/ip" # 要访问的目标HTTPS页面 # targetUrl = "https://httpbin.org/ip" # 代理服务器(产品官网 www.16yun.cn) proxyHost = "t.16yun.cn" proxyPort = "31111" # 代理验证信息 proxyUser = "username" proxyPass = "password" proxyMeta = "http://%(user)s:%(pass)s@%(host)s:%(port)s" % { "host" : proxyHost, "port" : proxyPort, "user" : proxyUser, "pass" : proxyPass, } # 设置 http和https访问都是用HTTP代理 proxies = { "http" : proxyMeta, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b13dd497319fff59d8e152b6ad6215aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6921412dcfbb283d2d823e217686be8e/" rel="bookmark">
			C&#43;&#43;快速读写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 为何要使用快读快写 通常在竞赛题目中时间是我们的一大难题，一些常见的题目还可以通过某种方式优化算法，从而提高速度减少超时。但一些数据极为bt的题目是需要用快读和快写才能解决时间超限的问题的。
快读快写的原理是什么 快读和快写都采用字符输入输出，快读先采用字符读入再转化为数字，而快写则是先将数字转化为字符再进行输出。
在这里补充一个知识点，C++中scanf、printf要比cin、cout快一倍左右。
代码示例 //快读 int read() { int x=0,f=1; char c=getchar(); while(c&lt;'0'||c&gt;'9'){if(c=='-') f=-1;c=getchar();} while(c&gt;='0'&amp;&amp;c&lt;='9') x=x*10+c-'0',c=getchar(); return x*f; } //快写 void write(int x) { if(x&lt;0) putchar('-'),x=-x; if(x&gt;9) write(x/10); putchar(x%10+'0'); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16f6c217faf86ccdea6e3697cbe9d3b8/" rel="bookmark">
			springcloud、springcloud Netflix、springcloud alibaba的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springcloud、springcloud Netflix、springcloud alibaba的区别 springcloud:
解决方案框架
springcloud Netflix:
实际解决方案，包括组件Eruka/hystrix/feign/load balance/ribbon/zuul
springcloud alibaba
实际解决方案，包括组建nacos/sentinal/seata/dubbo/RocketMq
总结：
SpringCloud Alibaba 优于 SpringCloud Netflix
SpringCloud Netflix 核心组件停止维护。
SpringCloud Alibaba 2019年孵化成功，是SpringCloud中最成熟全面的子项目。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8f630b8620ced589be89922294b72ed/" rel="bookmark">
			Vue 前端 实现 HTML 转 PDF 并导出（方案一：html2canvas &#43; jspdf 前端直接实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期公司提出了一个新需求，希望将用户在前端填写的一系列数据生成一个报告给用户，报告大概有8个表格，表格涉及到分页。于是查询了资料，做出两个方案。
方案二请点击这里
方案一 html2canvas + jspdf 使用html2canvas将使用canvas将页面转为base64图片流，并插入jspdf插件中，保存并下载pdf
使用 安装： npm install --save html2canvas npm install --save jspdf 绘制页面，页面上一共有两个表格 &lt;template&gt; &lt;div class="table-wrapper"&gt; &lt;div class="tables"&gt; &lt;div class="pdf-dom"&gt; &lt;div class="title"&gt; 表 A.1 xxx汇总表 &lt;/div&gt; &lt;table class="table" border="1" cellspacing="0"&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;类别&lt;/td&gt; &lt;td&gt;商品&lt;/td&gt; &lt;td&gt;小计&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;T恤&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;外套&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;羽绒服&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;短袖&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;短裤&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;连衣裙&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;半身裙&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;td&gt;5&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8f630b8620ced589be89922294b72ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6d295e58bccc93c8f1e8e5f58b42f60/" rel="bookmark">
			【重铸Java根基】理解Java反射机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近带应届新员工，教然后知不足，发现自己把很多基础知识已经还给了大学老师，因此开贴，温故而知新！
从最基础的Java知识开始由浅入深，在某个知识点中遇到有疑惑的点会额外多写几句或者单独开帖子展开。
本篇内容围绕Java反射机制，后续分享Java代理机制
先搞清楚什么是反射？
通过反射可以获取一个类的名称、属性和方法，可以调用方法、修改属性
反射为我们提供了在运行时分析类的属性和调用类的方法的能力
反射在哪里运用？
平时在编写业务代码时很少用到反射，但是反射被大量运用于我们常用的开发框架中,像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。
这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。
比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 Method 来调用指定的方法。
public class DebugInvocationHandler implements InvocationHandler { /** * 代理类中的真实对象 */ private final Object target; public DebugInvocationHandler(Object target) { this.target = target; } public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException { System.out.println("before method " + method.getName()); Object result = method.invoke(target, args); System.out.println("after method " + method.getName()); return result; } } Java提供的反射相关接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6d295e58bccc93c8f1e8e5f58b42f60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b8e3556be6d35f63ed362f00a515fa/" rel="bookmark">
			分布式理论CAP，BASE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是CAP理论？ CAP理论指的是一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。
Consistency 一致性
对于客户端的每次读操作，要么读到的是最新的数据，要么读取失败。换句话说，一致性是站在分布式系统的角度，对访问本系统的客户端的一种承诺：要么我给您返回一个错误，要么我给你返回绝对一致的最新数据，不难看出，其强调的是数据正确。
（1）强一致性
对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。
（2）弱一致性
数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性。
（3）最终一致性
如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。
Availability可用性
任何客户端的请求都能得到响应数据，不会出现响应错误。换句话说，可用性是站在分布式系统的角度，对访问本系统的客户的另一种承诺：我一定会给您返回数据，不会给你返回错误，但不保证数据最新，强调的是不出错。
Partition tolerance分区容忍性
由于分布式系统通过网络进行通信，网络是不可靠的。分区容错性指在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。换句话说，分区容忍性是站在分布式系统的角度，对访问本系统的客户端的再一种承诺：我会一直运行，不管我的内部出现何种数据同步问题，强调的是不挂掉。
CAP权衡 之前提到,CAP理论说一个分布式系统不可能同时满足C、A、P这三个特性。那么我们就来分析C、A、P的权衡吧。
对于一个分布式系统而言，P分区容忍性是前提，必须保证，因为只要有网络交互就一定会有延迟和数据丢失，这种状况我们必须接受，必须保证系统不能挂掉。所以只剩下C、A可以选择。要么保证C数据一致性（保证数据绝对正确），要么保证A可用性（保证系统不出错）。
满足CA舍弃P，也就是满足一致性和可用性，舍弃容错性。但是这也就意味着你的系统不是分布式的了，因为涉及分布式的想法就是把功能分开，部署到不同的机器上。
其实这里有个关于CAP理论理解的误区。不要以为在所有时候都只能选择两个特性。在不存在网络失败的情况下（分布式系统正常运行时），C和A能够同时保证。只有当网络发生分区或失败时，才会在C和A之间做出选择。
当选择了C（一致性）时，要求返回的是最新的正确数据，如果由于网络分区而无法保证特定信息是最新的，则系统将返回错误或超时。
当选择了A（可用性）时，要求请求都能得到响应数据，不会出现响应错误。系统将始终处理客户端的查询并尝试返回最新的可用的信息版本，即使由于网络分区而无法保证其是最新的。
举例：
对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P分区容忍性和A可用性，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。像12306还有淘宝网，就好比是你买火车票，本来你看到的是还有一张票，其实在这个时刻已经被买走了，你填好了信息准备买的时候发现系统提示你没票了。这就是牺牲了一致性。
对于涉及到钱财这样不能有一丝让步的场景，C一致性必须保证。网络发生故障宁可停止服务，这是保证CA，舍弃P。貌似这几年国内银行业发生了不下10起事故，但影响面不大，报到也不多，广大群众知道的少。还有一种是保证CP，舍弃A。例如网络故障事只读不写。
什么是BASE理论？ BASE理论是基于CAP理论逐步演化而来的，是CP（强一致性）和AP（强可用性）权衡的结果。
BASE理论的核心思想是：即使无法做到强一致性，但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。也就是说它是通过牺牲数据的强一致性来保证可用性的。
BASE是指基本可用BA（Basically Available）、软状态S（ Soft State）、最终一致性E（ Eventual Consistency）。
基本可用（Basically Available）
基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。
电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。
软状态（ Soft State）
软状态也称为弱状态，与硬状态相对，是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。即允许不同节点间数据副本之间进行数据同步的过程存在延时
最终一致性（ Eventual Consistency）
最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。
BASE理论并没有要求数据的强一致性，而是允许数据在一定的时间段内是不一致的，但在最终某个状态会达到一致。在生产环境中，很多公司，会采用BASE理论来实现数据的一致，因为产品的可用性相比强一致性来说，更加重要。比如在电商平台中，当用户对一个订单发起支付时，往往会调用第三方支付平台，比如支付宝支付或者微信支付，调用第三方成功后，第三方并不能及时通知我方系统，在第三方没有通知我方系统的这段时间内，我们给用户的订单状态显示支付中，等到第三方回调之后，我们再将状态改成已支付。虽然订单状态在短期内存在不一致。但是用户却获得了更好的产品体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaab490ab98ce39de04983d0d2c4a8bc/" rel="bookmark">
			Mockjs请求及Url取参（分页查询）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Mockjs实现模拟分页数据，获取列表的接口一般是后台需要接收页码以及每页条数，接着后台会返回总条数之类的信息。
学习mockjs以后觉得get请求十分麻烦，首先是需要处理接口地址由于携带参数而无法与后台匹配的问题，然后是mockjs没有内置的从url取参的方法，而是要自己通过对url不断地判断、截取、以及和参数名进行匹配才能取出参数，而post请求取参就相对很容易。
get请求：
组件内发送get请求获取后台返回的数据，向后台传了页码和每页条数：
//组件内 getList () { axios.get('/api/get/list',{ params: { pageindex: this.pageindex, pagesize: 10 } }).then(res=&gt;{ this.list = res.data.list this.pageMax = res.data.totalPage }).catch(err=&gt;{ console.log('err',err) }) } 解决携带参数的接口地址与后台定义无法匹配的问题：
//mockjs //url为：/api/get/list?pageindex=1&amp;pagesie=10 //无法与/api/get/list匹配，因此要用到正则 Mock.mock(/\/api\/get\/list/,'get',(options)=&gt;{ console.log(options) //业务代码省略 }) 定义方法解决mockjs无内置url取参的问题：
// 根据url获取query参数 const getQuery = (url,name)=&gt;{ console.log(url); // /api/get/news?pageindex=1&amp;pagesize=10 const index = url.indexOf('?') console.log(index); //13 if(index !== -1) { const queryStrArr = url.substr(index+1).split('&amp;') console.log(queryStrArr); //['pageindex=1', 'pagesize=10'] //0: "pageindex=1" //1: "pagesize=10" for(var i=0;i&lt;queryStrArr.length;i++) { const itemArr = queryStrArr[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaab490ab98ce39de04983d0d2c4a8bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9491e0722468285fae0f41407298e89b/" rel="bookmark">
			k8skubeadm生成Token以及设置过期时间kubeadm删除token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查看Token [root@m1 admin]# kubeadm token list TOKEN TTL EXPIRES USAGES DESCRIPTION EXTRA GROUPS bwa8py.ghf5s0vfsxz1d7fx &lt;invalid&gt; 2022-08-01T19:06:15+08:00 authentication,signing kubelet-bootstrap-token system:bootstrappers:worker mbwfv6.lbasbfken6or58re 23h 2022-08-04T21:29:20+08:00 authentication,signing kubelet-bootstrap-token system:bootstrappers:worker yvsocr.b40go6o23ee85wrs &lt;forever&gt; &lt;never&gt; authentication,signing kubelet-bootstrap-token system:bootstrappers:worker 2.设置用不过期Token
# 不加只有24H小时 [root@m1 admin]# kubeadm token create # 加上 kubeadm token create --ttl 0 [root@m1 admin]# export BOOTSTRAP_TOKEN=$(kubeadm token create --ttl 0 \ --description kubelet-bootstrap-token \ --groups system:bootstrappers:worker \ --kubeconfig kube.config) 获取CA公钥的哈希值 openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed 's/^ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9491e0722468285fae0f41407298e89b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35bbedb1a36034f09adc19c5234a6a20/" rel="bookmark">
			【一步到位】Jenkins的安装、部署、启动(完整教程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、测试环境 Linux系统 Centos 7 二、安装步骤： 1、安装jdk 我安装的是jdk8，此处就不多说了，自己百度哈，很简单
2、安装jenkins 首先依次执行如下三个命令：
2.1、导入镜像：
[root@centos7 ~]# sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo --2019-12-24 17:59:44-- https://pkg.jenkins.io/redhat-stable/jenkins.repo Resolving pkg.jenkins.io (pkg.jenkins.io)... 52.202.51.185 Connecting to pkg.jenkins.io (pkg.jenkins.io)|52.202.51.185|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 85 Saving to: ‘/etc/yum.repos.d/jenkins.repo’ 100%[=====================================================================================================================================================&gt;] 85 --.-K/s in 0s 2019-12-24 18:00:47 (17.4 MB/s) - ‘/etc/yum.repos.d/jenkins.repo’ saved [85/85] 2.2、导入公钥
[root@centos7 ~]# sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key 2.3、安装jenkins：
[root@centos7 ~]# yum install jenkins Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile Resolving Dependencies --&gt; Running transaction check ---&gt; Package jenkins.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35bbedb1a36034f09adc19c5234a6a20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f69ebd1d9c21099eff85b4d0318070b5/" rel="bookmark">
			koa框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 koa和express的区别同步代码异步代码 koa下载安装koa的基本使用koa的路由koa静态资源koa获取请求参数get请求参数获取post请求参数获取 koa的ejs模板koa- 登录鉴权cookie和sessionkoa-cookiekoa-session JWT koa 文件上传koa 操作MongoDB koa是由Express原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的Web框架。使用koa编写web应用,通过组合不同的generator,可以免除重复繁琐的 回调函数嵌套 ，并极大地提升错误处理的效率。koa不在内核方法中绑定任何中间件，它仅仅提供了-个轻量优雅的函数库，使得编写Web应用变得得心应手。 koa和express的区别 Koa采用洋葱模型
通常都会说Koa是洋葱模型,这重点在于中间件的设计。但是按照上面的分析,会发现Express也是类似的，不同的是Express中间件机制使用了Callback 实现，这样如果出现异步则可能会使你在执行顺序上感到困惑，因此如果我们想做接口耗时统计、错误处理Koa的这种中间件模式处理起来更方便些。最后一点响应机制也很重要,
Koa不是立即响应，是整个中间件处理完成在最外层进行了响应，而Express则是立即响应。
Koa更轻量
koa不提供内置的中间件;
koa不提供路由，而是把路由这个库分离出来了(koa/router)
Context对象
koa增加了一个Context的对象，作为这次请求的上下文对象(在koa2中作为中间件的第一个参数传入)。同时Context上也挂载了Request和Response两个对象。Express类似, 这两个对象都提供了大量的便捷方法辅助开发这样的话对于在保存一些公有的参 数的话变得更加合情合理。
异步流程控制
express采用callback来处理异步，koa采用async/await。
async/await使用同步的写法来处理异步，明显好于callback和promise,
中间件模型
express基于connect中间件,线性模型;
koa中间件采用洋葱模型(对于每个中间件,在完成了-些事情后，可以非常优雅的将控制权传递给下一个中间件，并能够等待它完成，当后续的中间件完成处理后，控制权又回到了自己)
代码示例：
同步代码 同步方法没有什么区别：
01-express-同步.js const express = require("express") const app = express() app.use((req, res, next) =&gt; { console.log("111111") next() console.log("333333") res.send("hello world") }) app.use((req, res, next) =&gt; { // 同步操作 console.log("22222") }) app.listen(3000) 运行输出
111111 22222 333333 01-koa-同步 .js const Koa = require("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f69ebd1d9c21099eff85b4d0318070b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c67390c590e2842b7a116c0a014dd621/" rel="bookmark">
			IDEA运行selenium程序提示错误：Exception in thread “main“ org.openqa.selenium.SessionNotCreatedException:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
Starting ChromeDriver 100.0.4896.60 (6a5d10861ce8de5fce22564658033b43cb7de047-refs/branch-heads/4896@{#875}) on port 50749
Only local connections are allowed.
Please see https://chromedriver.chromium.org/security-considerations for suggestions on keeping ChromeDriver safe.
ChromeDriver was started successfully.
Exception in thread "main" org.openqa.selenium.SessionNotCreatedException: Could not start a new session. Response code 500. Message: session not created: This version of ChromeDriver only supports Chrome version 100
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c67390c590e2842b7a116c0a014dd621/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d648aba22cb055bb3a7e1df1c1118a5/" rel="bookmark">
			QGraphicsView框架的界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在view中创建一个item，思路:相当于用qgraphicsItem绘制了一个边框，在自定义的item中添加一个总的QWidget,里面的控件可以通过stylesheet设置透明等等，这样就可以在qt的界面编辑器中进行界面布局，方便，效果如下
具体代码:
DialogItem类的.c文件
#include "MyGraphicsItem.h" #include &lt;QFontMetrics&gt; #include &lt;QPainter&gt; #include &lt;QMouseEvent&gt; #include &lt;QGraphicsSceneHoverEvent&gt; #include &lt;QGraphicsScene&gt; #include &lt;QPushButton&gt; #include &lt;QGraphicsProxyWidget&gt; #include &lt;QVBoxLayout&gt; #include &lt;QHBoxLayout&gt; #include &lt;QGraphicsSceneMouseEvent&gt; #include &lt;QGraphicsLayout&gt; #include &lt;QDebug&gt; TitleBarItem::TitleBarItem(qreal x,qreal y,qreal width,qreal height): m_bInPath(false) { m_rect = QRectF(x,y,width,height); setAcceptHoverEvents(true); setAcceptedMouseButtons(Qt::LeftButton); } void TitleBarItem::updateGeometry() { prepareGeometryChange(); //setPos(); } void TitleBarItem::setItemTitle(const QString &amp;strText) { m_strtitle = strText; } void TitleBarItem::setItemTitleFont(QFont font) { m_font = font; } void TitleBarItem::setRect(qreal x, qreal y, qreal width, qreal height) { prepareGeometryChange(); m_rect = QRectF(x,y,width,height); m_closeRect = QRectF(m_rect.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d648aba22cb055bb3a7e1df1c1118a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e901e1275d2c4de942e7b7ae4d226c9/" rel="bookmark">
			Redis IO多路复用理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IO多路复用在Redis中的应用 Redis 服务器是一个事件驱动程序， 服务器处理的事件分为时间事件和文件事件两类。
文件事件：Redis主进程中，主要处理客户端的连接请求与相应。时间事件：fork出的子进程中，处理如AOF持久化任务等。 由于Redis的文件事件是单进程，单线程模型，但是确保持着优秀的吞吐量，IO多路复用起到了主要作用。
文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。
IO多路复用程序负责监听多个套接字并向文件事件分派器传送那些产生了事件的套接字。文件事件分派器接收IO多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器。示例如图所示
Redis的IO多路复用程序的所有功能都是通过包装常见的select、poll、evport和kqueue这些IO多路复用函数库来实现的，每个IO多路复用函数库在Redis源码中都有对应的一个单独的文件。
Redis为每个IO多路复用函数库都实现了相同的API，所以IO多路复用程序的底层实现是可以互换的。如图：
多个IO复用库实现可选
Redis把所有连接与读写事件、还有我们没提到的时间事件一起集中管理，并对底层IO多路复用机制进行了封装，最终实现了单进程能够处理多个连接以及读写事件。这就是IO多路复用在redis中的应用。
改进 Redis 6.0 之后的版本开始选择性使用多线程模型。
Redis 选择使用单线程模型处理客户端的请求主要还是因为 CPU 不是 Redis 服务器的瓶颈，使用多线程模型带来的性能提升并不能抵消它带来的开发成本和维护成本，系统的性能瓶颈也主要在网络 I/O 操作上；
而 Redis 引入多线程操作也是出于性能上的考虑，对于一些大键值对的删除操作，通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程阻塞的时间，提高执行的效率。
参考：一文搞懂 Redis高性能之IO多路复用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2b9f82d16706960ade1079839585eb6/" rel="bookmark">
			csv导出文件名乱码解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public void exportCsv(ExamineDTO examineDTO, HttpServletRequest request, HttpServletResponse response) throws ServiceException { try { // 文件名 String fileName = "报表导出_" + System.currentTimeMillis() + ".csv"; String excelName = excelName(fileName, request); response.setContentType("application/octet-stream;charset=ISO8859-1"); response.setHeader("Content-Disposition", "attachment;filename=" + excelName); response.addHeader("Pargam", "no-cache"); response.addHeader("Cache-Control", "no-cache"); // 查询具体数据 List&lt;String[]&gt; list = this.examineDao.queryExamineCsvReportList(examineDTO); CSVUtil.write(response, list); } catch (ServiceException e) { logger.error("报表数据导出异常,异常信息为：{}", e.getMessage(), e); throw new ServiceException("报表数据导出异常", e.getMessage(), e); } } private String excelName(String name, HttpServletRequest request) throws ServiceException { String userAgent = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2b9f82d16706960ade1079839585eb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc0725526a44c4e664dde580d565f51f/" rel="bookmark">
			如何找到系统支持的最大并发数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何找到系统支持的最大并发数 1.Jmeter搭建性能测试脚本
（1）创建阶梯压测策略（200用户并发）
场景为在5秒内增加10个并发用户数，并运行30秒，再继续在5秒内增加10个并发用户数，重复循环，直至并发用户数达到50个后运行脚本60秒。然后在每1秒内减少5个并发用户数，直到减为0，结束脚本的运行。
（2）创建需要压测的接口
（3）放置监控结果数据的插件
3.性能结果分析找到支持的最大并发数
通过检测结果可以得出结论：
响应时间2秒内为基准，当并发用户数为200时，90%响应时间为3.964秒，响应时间超过2秒，吞吐量为：56/sec,TPS在并发用户150的用户下出现明显的下降趋势，响应时间出现上升趋势，由此判定外部聊天接口支持150用户并发。
注意：
1.需要安装Jmeter对应的监控插件
2.结合TPS曲线及响应时间曲线去判断支持的并发用户范围
3.TPS越大说明系统处理能力越强，响应时间越短说明处理能力越强
4.在区间中逐步增加步长，出现以下任意现象时，即是最大并发用户数：
（1）出现接口连续报错
（2）平均响应时间超过2秒（2秒是行业标准）
（3）TPS呈现下降趋势
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc56d2cfc9c31682f5c31b0e14d6dfb9/" rel="bookmark">
			解决Apache JMeter Dashboard报告缺失一部分图表的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景 使用jmeter命令行模式执行脚本生成html报告，查看报告发现有一部分图表的展示为空，分别是Response Times Over Time、 Latencies Over Time、Connect Time Over Time、Transactions Per Second、Response Time Percentiles、Time Vs Threads、Response Time Distribution这些图表的数据缺失 初始解决思路 调整脚本线程数以及运行时间修改jmeter/bin目录下的user.properties、reportgenerator.properties、jmeter.properties配置进行调试多次尝试后无果下载更高版本的jmeter进行试验，结果并没有什么不同 正解 查看jmeter官网关于报告的先决条件后并未发现有何差异，随根据第二种方案进行排查原因竟是jmx脚本里的线程名带有特殊字符导致的问题，将线程名改成中文/英文即解决，Apache JMeter Dashboard所有报告模板都可正常展示谨记命名需规范，空格和特殊字符以及中文等等，排查起来真的费劲… 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42aa40fa566b0bc0c2729e8a611a2d2d/" rel="bookmark">
			python代替wget下载文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python代替wget下载文件 背景：wget下载http文件有时显示forbidden，尝试过后发现python挺好使
使用request直接下载小文件 import requests url = "my_url" r = requests.get(url) with open("file_name",'wb') as f: f.write(r.content) 使用request下载大文件 import requests file_url = "myurl" r = requests.get(file_url, stream=True) with open("file_name", "wb") as f: for chunk in r.iter_content(chunk_size=1024**2): if chunk: f.write(chunk) 好使😀 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd788fac820c5c368d9e859231ff3a54/" rel="bookmark">
			【图像处理】c&#43;&#43;使用opencv对图像进行轮廓识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标：学习使用C++对图像轮廓进行提取
文章目录 轮廓提取的代码实现运行结果 轮廓提取的代码实现 #include &lt;opencv2/imgcodecs.hpp&gt; #include &lt;opencv2/highgui.hpp&gt; #include &lt;opencv2/imgproc.hpp&gt; #include &lt;iostream&gt; using namespace cv; using namespace std; Mat src; Mat src_gray; int thresh = 100; int max_thresh = 255; RNG rng(12345); void thresh_callback(int, void*); int main(int argc, char** argv) { String imageName("./1.jpg"); if (argc &gt; 1) { imageName = argv[1]; } src = imread(imageName, IMREAD_COLOR); if (src.empty()) { cerr &lt;&lt; "No image supplied ..." &lt;&lt; endl; return -1; } cvtColor(src, src_gray, COLOR_BGR2GRAY); blur(src_gray, src_gray, Size(3, 3)); const char* source_window = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd788fac820c5c368d9e859231ff3a54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e621955532a456beb129f248396d203/" rel="bookmark">
			git删除commit方法和误删commit后的恢复方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、如果你在git上提交了错误的commit，不要慌，通过下面的方法可以回退到之前的commit 如果只误提交了一个commit， 直接执行
git reset --hard HEAD^ 这一条命令就OK了（但是这条命令会把最近一次commit的代码删除哦，如果要保留代码，请看本文最后面部分）
如果你要回滚多个 commit 可以使用下面的方法：
第一步：通过git log可以查看我们之前提交的commit_id：
第二步：复制你需要回滚的commit_id。不过windows下的命令行是不能复制文本的，为此你可以到github上查看仓库的commit历史，上面是可以直接复制的：
复制好后在命令行执行：git reset --hard &lt;commit_id&gt;
git reset --hard 4458e09 第三步：执行: git push origin HEAD --force 提交当前HEAD
这样就能够将错误的提交删除，回滚至其之前的代码
但是如果当你回滚代码以后发现commit_id复制错了或者回滚错了怎么办呢？不要慌！！！按下面的方法做：
第一步：执行 git reflog
你能在命令行中看到你的历史操作，复制你要恢复操作最前面的hash值
第二步：执行 git reset --hard &lt;hash&gt;
命令中最后要输的hash就是你要恢复的历史记录最前面黄色部分的hash值
比如：
git reset --hard 4458e09 这样就成功解决问题了。
但是上面的操作仍然有缺陷，我们经常遇到的情况是：在错误的分支写了大量代码，并且已经push到远程仓库，这个时候我们要的不仅是回退commit，并且要保留自己新写的代码并且合并到正确的分支上。
接下来不要眨眼，我们来演示如何解决问题：
第一步：找到你提交之前的最新commit id，执行如下命令：
git reset --soft 4458e09 这条命令会把你本地的当前分支回退到之前的commit，并且保留你在这条commit 之后写的代码。
第二步：执行git stash 将新写的代码放到缓存中
git stash 第三步：把当前分支强行覆盖远程分支
git push --force 第四步：切换到正确的开发分支，这里假设是dev分支
git checkout dev 第五步：把缓存的代码从内存中 pop 出来
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e621955532a456beb129f248396d203/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceb75a0673bed9d49f7f667295acb24e/" rel="bookmark">
			C&#43;&#43;中“ ? : ”三目运算符的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景原因解决方法 背景 刷洛谷的题时，我写了这行代码：
dp[i][j]=dp[i][j]+obstacleGrid[i][j-1]?0:dp[i][j-1]+obstacleGrid[i-1][j]?0:dp[i-1][j]; 我觉得没啥问题，但答案就是异常，搞得我很崩溃
原因 因为三目运算符也是要遵循运算顺序了，具体的我没细想，但如果不加以限制肯定会出错，比如这两个dp[i][j-1]+obstacleGrid[i-1]会先加在一起之类的
解决方法 加括号！
dp[i][j]=dp[i][j]+(obstacleGrid[i][j-1]?0:dp[i][j-1])+(obstacleGrid[i-1][j]?0:dp[i-1][j]); 希望能帮到大家
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/988a5a5a807c8864012236e9811cdce6/" rel="bookmark">
			Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connection to database server. Attempted reconnect 3 times. Giving up.
现象：同一服务器上同时启动多个相同项目做分服测试，结果是有的服务器成功启动，有的服务器启动失败，原因均为：mysql连接超时；
服务器情况：单服 centos7(32c64g) 上同时部署了 26个相同的多服拓展测试项目 + mysql5.7.18
问题解析：同服同项目情况下，多数（21个）项目成功启动，后续（5个）启动失败，而且均报mysql连接超时。那么可证明不是测试项目问题，而是mysql存在问题，再结合启动顺序和错误出现的时间来看，问题的关节点多半与连接数有关。结合这个结论，进入mysql后台，查看mysql最大连接数及当前连接数使用情况
show variables like '%max_connection%'; ----- 查看最大连接数（查询后默认值为：152）
查看当前mysql连接数使用情况：show status like 'Threads%'; Threads_cached 0
Threads_connected 151 --- 当前连接数
Threads_created 157 --- 创建过的线程数
Threads_running 1 --- 当前激活的连接数（数值一般小于connected）
从以上查询结果中可以看出，连接数已经达到上限了，所以后续第22个项目启动时，自然是无连接可用了，所以需重新设置一下mysql的最大连接上限了。
set global max_connections=1000; ----- 重新设置最大连接数（将连接上限改为：1000）
后续再次启动第22个项目成功了，那么证明后续项目也是同样原因造成的，直接逐一启动即可。
最后再次查看一下当前连接数：
Threads_cached 0
Threads_connected 189
Threads_created 193
Threads_running 1
结语：该问题存在诸多特殊性情况，单服模拟多项目分服拓展下造成了对同一mysql的大量连接。所以看了下网上的mysql版本原因对我并不适用，同时存在成功启动的项目，那么也在一方面证明了mysql是可用的，而结合连接数量的叠加以及启动顺序的差异，可以大概确认为mysql连接数上限存在问题。所以问题排查时需要先剖析问题本质，再对症下药。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/577410da513bb35d42878789df80d6ab/" rel="bookmark">
			云原生数据仓库AnalyticDB Mysql(ADB分析型数据库)-DML语法之新增插入数据详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云原生数据仓库AnalyticDB Mysql(ADB分析型数据库)-DML语法之新增插入数据 ADB分析型数据库，是阿里云平台上资源，原名叫云原生数据仓库AnalyticDB Mysql，俗称ADB分析型数据库，那么ADB的语法与mysql关系型数据库语法存在一定的差异。
本文为笔记，介绍ADB的DML语法的应用。
1. INSERT INTO INSERT INTO用于向表中插入数据，主键重复时会自动忽略当前写入数据不做更新，作用等同于INSERT IGNORE INTO。
语法：
INSERT [IGNORE] INTO table_name [( column_name [, …] )] [VALUES] [(value_list[, …])] [query]; IGNORE：可选参数，判断是否有与之相同的主键数据，新记录不会被写入。 column_name：可选参数，列名。 query：通过定义查询，将一行或多行数据插入表中。 注意：
如果插入数据时不指定列名，则要插入的数据必须和CREATE TABLE语句中声明的列的顺序一致。
示例：
CREATE TABLE adb_order.order_info ( order_no varchar NOT NULL COMMENT '订单号', stt_ym varchar NOT NULL COMMENT '统计年月', mount decimal(16, 2) NOT NULL COMMENT '订单金额', order_num int NOT NULL COMMENT '订单量', PRIMARY KEY (order_no) ) PARTITION BY HASH KEY (stt_ym) PARTITION NUM 128 TABLEGROUP adb_order_test OPTIONS (UPDATETYPE='realtime') COMMENT '订单表表' 向order_info 表中插入一条数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/577410da513bb35d42878789df80d6ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17bf574edd5c943c4120ed4cc64324f5/" rel="bookmark">
			windows中Ubuntu子系统的连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 连接Ubuntu子系统，除了在上一篇Xshell的下载与安装中已经提到的使用类似于Xshell的SSH远程终端工具外，还可以使用Notepad++，前者可以执行任何shell命令，而后者只能对服务器中的文件进行编辑。本篇章介绍两种不同的方式连接Ubuntu子系统。
xshell连接Ubuntu子系统 1.安装ssh
# 安装ssh sudo apt-get install openssh-server 2.修改配置文件
vim /etc/ssh/sshd_config #编辑文件 修改配置文件允许明文密码，将PasswordAuthentication， 改为yes可以使用密码登录，如果使用ssh秘钥对登录，则不修改原有的值no；设置端口号为22
Port 22 PasswordAuthentication yes 注：可以修改默认端口号，但是后续如果要安装hadoop，修改了port参数会带来很多不必要的麻烦，所以建议不修改。
可能遇到的问题：
1）文件修改后，输入:wq保存退出，如果提示E45: 'readonly' option is set (add ! to override) ，则输入:wq!强制保存退出。
2）如果输入:wq!强制保存退出失败，显示"/etc/ssh/sshd_config" E212: Can't open file for writing ，原因为权限不够，普通无法保存，需要使用超级用户才可以，则进行下面的操作：
sudo su # 切换到root用户 然后就可以编辑配置文件vim /etc/ssh/sshd_config，修改后直接:wq保存退出。
3.重启ssh服务
sudo service ssh --full-restart 重启成功后提示：
* Stopping OpenBSD Secure Shell server sshd [ OK ] * Starting OpenBSD Secure Shell server sshd [ OK ] 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17bf574edd5c943c4120ed4cc64324f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5455ac1cfd2259d9118926a44cf040f8/" rel="bookmark">
			Windows允许tomcat报错 The APR based Apache Tomcat Native
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在允许tomcat的的时候出现PATH
The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path: C:\jdk1.6.23_112\bin;C:\Windows\Sun\Java\bin;C:\Windows\system32;C:\Windows;
问题解决方法
win + r ## 输入cmd set path ## 查看当前环境的path 在后面增加 一个 jdk的路径,不需要bin目录 然后重启下tomcat就okl
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/991217b5a7c47bf87b6ebce3c423d6be/" rel="bookmark">
			Windows10蓝屏的诸多解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		买回一台组装机，性能强悍，但是随着使用时间的延长，Windows 10操作系统经常崩溃，显示蓝屏。报错码如下：
WHEA_UNCORRECTABLE_ERROR 方法一：在BIOS中，更改“Intel C-State”、“XMP”和CPU核心电压解决。 1、组装机的主板是华硕，所以可以在开机时，进入BIOS界面，在Advanced(高级设置)——CPU Configuration(CPU设置)中禁用“Intel C-State”，更改后进行保存，查看蓝屏重启问题是否有改善。
2、华硕的ROG主板在打开ai core enhancement选项，而未打开XMP时也会出现终止代码WHEA_UNCORRECTABLE_ERROR蓝屏的问题，所以可以尝试打开XMP选项。
3、CPU超频也会导致蓝屏问题，可以在BIOS中将核心电压设置为1.2V或者直接将主板上的纽扣电池扣掉，重新安装回去试试。
方法二：将虚拟内存由手动改为自动 右键点击“此电脑”选择“属性”，我们再点击高级系统设置，在系统属性的高级选项卡界面中，在性能一栏点击“设置”，在性能选项界面中，虚拟内存一栏中点击“更改”，勾选“自动管理所有驱动器分页文件大小。 我尝试了以上方法，蓝屏重启的问题居然得到了解决。但是大家也要谨慎尝试。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/135/">«</a>
	<span class="pagination__item pagination__item--current">136/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/137/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>