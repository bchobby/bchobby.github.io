<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/527f97563c03aadbc60c249ac4d5a359/" rel="bookmark">
			vivado中的PACKAGE_PIN与BOARD_PIN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vivado中的PACKAGE_PIN与BOARD_PIN 在阅读xilinx设计示例时，常常在部分IP约束中看到采用BOARD_PIN的形式分配管脚，该方法与常见的PACKAGE_PIN分配管脚区别如下。
针对新建工程时通过选择评估板来确定芯片的工程，例如采用KCU105，VCU118等评估板的特定工程，vivado开发工具内置了对应管脚的名称，可以通过BOARD_PIN的方式来约束管脚，且通过该方式可以省略对管脚电平标准的约束。
需要注意的是，该类约束方法只针对特定的评估板，且需要在对应的原理图中找到相应的特定名称，容易出错，若能够确定管脚位置，还是推荐使用PACKAGE_PIN的形式。
例子：
set_property PACKAGE_PIN {AP8} [get_ports {led[0]}] set_property IOSTANDARD {LVCMOS18} [get_ports {led[0]}] set_property BOARD_PIN {CPU_RESET} [get_ports {rst}] 参考链接：Xilinx社区关于BOARD_PIN的解释
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61bbe64b1409e93d26692521929edc27/" rel="bookmark">
			Java并发编程--自旋锁的实现和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.自旋锁介绍 自旋锁是这样一类锁：当线程等待加锁时，不会阻塞，不会进入等待状态，而是保持运行状态。大致的思路是：让当前线程不停地的在循环体内执行，当循环的条件被其他线程改变时才能进入临界区。
2.自旋锁实现方式 一种实现方式是通过CAS原子操作：设置一个CAS原子共享变量，为该变量设置一个初始化的值；加锁时获取该变量的值和初始化值比较，若相等则加锁成功，让后把该值设置成另外一个值；若不相等，则进入循环（自旋过程），不停的比较该值，直到和初始化值相加锁成功。
3.自旋锁的优势 （1）性能较高：自旋锁不会使线程状态切换，始终处于用户态，即线程始终处于活动状态，不会让线程进入阻塞状态，减少不必要的上下文切换，性能较高；
（2）避免死锁：自旋锁不会让线程阻塞或等待，也就不需要唤醒，所以可以避免产生死锁；
4.自旋锁的缺点 （1）在等待锁时进入循环会占用CPU，若等待的线程很多，对CPU的消耗会比较大；
（2）不适合需要长时间等待的任务或线程；
（3）不适合大量线程等待的场景。
5.自旋锁的使用场景 （1）等待时间比较短的任务中；
（2）线程数量不太多的应用中；
（3）当等待时间长或线程数量很大时，可以使用其他锁（比如：可重入锁）。
6.自旋锁和互斥锁 （1）自旋锁和互斥锁都是保护资源共享的机制；
（2）无论是自旋锁还是互斥锁，任何时候最多只能有一个持有者；
（3）如果锁已被占用，则获取互斥锁的线程将进入阻塞状态；获取自旋锁的线程不会阻塞。
7.自旋锁的实现 使用AtomicReference变量的CAS机制来实现自旋锁。由于AtomicReference变量能够保证多个线程同时对其读写时的原子性（这种原子性是通过sun.misc.unsafe包来实现的，后面会专门介绍），所以，可以使用这种类型 的共享变量作为判断条件。
public class SpinLock { // 定义一个原子引用变量 private AtomicReference&lt;Thread&gt; sign = new AtomicReference&lt;&gt;(); public void lock(){ Thread current = Thread.currentThread(); // 加锁时：若sign为null，则设置为current；若sihn不为空，则进入循环，自旋等待； while(!sign.compareAndSet(null, current)){ // 自旋：Do Nothing！！ } } public void unlock (){ Thread current = Thread.currentThread(); // 解锁时：sign的值一定为current，所以直接把sign设置为null。 // 这样其他线程就可以拿到锁了（跳出循环）。 sign.compareAndSet(current, null); } } 注意：这种自旋锁的实现方式是不可重入的。也就是说：若一个已经加锁成功的线程再次获取该锁时，会失败。那么如何实现一个可重入的自旋锁呢？其实就是比较目前的线程引用是否和锁中记录的线程引用相等，若相等加锁成功。可重入自旋锁会在下面章节进行分析。
8.可重入自旋锁 当一个使用自旋锁加锁成功的线程，再次尝试加锁时可以加锁成功（可重入）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61bbe64b1409e93d26692521929edc27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf0aa15ba5e34eff6e824eddef713c93/" rel="bookmark">
			远程调试 idea配置remote debug、在远程服务器的程序中，添加JVM启动参数-Xdebug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1. idea配置remote debug1.1 在服务器的程序中，添加JVM启动参数1.2 idea连接远程服务器，进行远程调试 2. 远程调试原理 前言 在本地开发的程序运行在服务器上报错且缺少日志信息甚至没有错误日志时，需要通过远程调试来调试服务器上的程序
1. idea配置remote debug 1.1 在服务器的程序中，添加JVM启动参数 在启动程序的脚本中，即java -jar命令后，添加支持远程调试的参数(默认选择5005端口，为避免端口冲突，可选用其他不常用端口)
-Xdebug -Xrunjdwp:transport=dt_socket,address=5005,server=y,suspend=n 参数含义：
-XDebug 启用远程调试 -Xrunjdwp 加载JDWP的JPDA参考执行实例 transport 用于在调试程序和VM使用的进程之间通讯 dt_socket socket传输 server=y/n VM是否需要作为调试服务器执行 address=5005 调试服务器监听的端口号 suspend=y/n 是否在调试客户端建立连接之后启动VM 如：
1.2 idea连接远程服务器，进行远程调试 点击Add Configuration后选择Remote
设置远程服务器的Ip和远程调试的端口
在本地代码中添加断点后，即可调试远程服务器上代码
注：
若远程服务器和本地之间防火墙未打开，则无法进行远程调试，可通过telnet ip 端口命令测试通信
2. 远程调试原理 Java程序统一以字节码的形式在JVM中运行，只要本地代码和远程服务器上的类文件相同，两个JVM通过调试协议进行通信，本地的源码就可以连接到远程服务器上的JVM，进而执行远程调试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/926c269938dab2c43f7e29ee2e31d187/" rel="bookmark">
			关于el-select自动校验的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期在做项目的时候用到了选择框，并且还需要校验选择框的值。但是出现了一个问题就是：首次加载页面或者刷新页面会触发select选择框校验（select一般设置change触发校验）。
解决：
检查为select中v-model的初始值（null或undefine或者空字符串啥的）是否与接口获取的值为空时对其赋值一致，这种情况常常是接口数据为空，给其从新赋值与初始值不一致造成的。
例子：
v-model绑定的变量为a
let a = “” ; // a的初始值
此时我获取接口数据，但是a的值为null（此变量记为b吧），如果直接将b的值给a就会报错，这时候应该使两个初始值保持一致，要么改a的初始值，要么处理一下接口的空值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e316e2651bf5b951cbc70c8036201fe/" rel="bookmark">
			~/.bash_profile(mac环境下)配置环境变量失效的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、分析问题 当我们在 ~/.bash_profile 中配置环境变量, 但每次在IDE或者终端，重新开启新的窗口或者重启终端后，配置的环境变量都不生效了，还需要重新执行以下命令才会重新生效: source ~/.bash_profile 2、分析原因 1、我们是在bash中配置的环境变量，而当前系统是使用的是shell。
2、查看当前使用的shell：
1、终端输入：echo $SHELL 2、输出是/bin/zsh，说明使用的是zsh 3、解决方案 .zshrc文件加中添加source ~/.bash_profile cd ~ ls -a sudo vim .zshrc i编辑 source ~/.bash_profile :wq 具体步骤：
1、进入主目录 cd ~
2、显示隐藏文件，找到.zshrc文件夹 ls -a（如果没有可以只直接创建）
3、编辑文件 sudo vim .zshrc
4、按i进入编辑模式，加入source ~/.bash_profile后，esc
5、:wq保存退出
希望对大家有所帮助，希望和大家一起成长，进步。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1769bcaa07ce71445b18fb28c949c2cd/" rel="bookmark">
			解决UnicodeDecodeError: ‘utf-8‘ codec can‘t decode byte 0xb1 in position 376: invalid start byte
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python 读取数据出现UnicodeDecodeError: 'utf-8' codec can't decode byte 0xb1 in position 376: invalid start byte 该情况是由于出现了无法进行转换的 二进制数据造成的，
in_file = open(os.path.join(VOCdevkit_path, 'VOC%s/Annotations/%s.xml'%(year, image_id)), encoding='utf-8') in_file = open(os.path.join(VOCdevkit_path, 'VOC%s/Annotations/%s.xml'%(year, image_id)), encoding='gb2312') 修改字符集参数，一般这种情况出现得较多是在国标码(GBK)和utf8之间选择出现了问题。出现异常报错是由于设置了decode()方法的第二个参数errors为严格（strict）形式造成的，因为默认就是这个参数，将其更改为ignore等即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/317a4bf3cd0adf2e56e15980b6f0aca4/" rel="bookmark">
			Ganet车道线检测小数据训练模型的多场景测试demo(测试集)，山城重庆的高速路、快速路测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ganet车道线检测小数据训练模型的多场景测试demo(测试集)，山城重庆的高速路、快速路测试
车道线检测小数据训练模型的多场景测试demo(测试集)，山城重庆的高速路、快速路测试
视频链接：https://www.bilibili.com/video/BV1vS4y1E7yU?spm_id_from=333.337.search-card.all.click&amp;vd_source=7b48517996bf2f4992321feee888517d
车道线检测在3000张小数据训练模型的多场景测试demo，测试集的结果，山城重庆的高速路、快速路测试。欢迎也在做车道线检测的同行朋友一起讨论交流。
算法出处：A Keypoint-based Global Association Network for Lane Detection（CVPR2022），做了相应的改进。
欢迎对车道线检测、车位检测、目标跟踪、目标检测、目标分类、语义分割、深度估计等计算机视觉任务及自动驾驶技术（感知、融合、规控、预测、定位、建图、传感器、嵌入式移植、测试、产品等）感兴趣的朋友、同行，加入技术交流群4群，一起学习，一起玩！
推荐阅读：
车道线检测2022新工作整理，2D、3D都有
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5ca7d5f9064a20accf942ec046e6007/" rel="bookmark">
			Cannot find module ‘core-js/core/object‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因： core-js版本问题
解决方案 换个版本，直接安装
npm install core-js@2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e62c5070c23bdabdb22ae04e27d61274/" rel="bookmark">
			Jenkins系列——jenkins 的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JenKins 是一个开源的、提供友好操作界面的持续集成（CI）工具，起源于 Hudson（Hudson是商用的），主要用于持续、自动地构建/测试软件项目、监控外部任务的运行。
JenKins 用 java 语言编写，可在 Tomcat 等流行的 servlet 容器中运行，也可独立运行。通常与与版本管理工具（SCM）、构建工具结合使用。常用的版本控制工具有 SVN、GIT，构建工具有 Maven、Ant、Gradle。
jenkins 官方网址为：https://www.jenkins.io/‘’
一、安装 java 因为 jenkins 用 java 语言编写，需要先安装 jdk 环境。
运行以下命令安装 jdk8
yum install java-1.8.0-openjdk 二、安装 jenkins 1、官方提供的安装步骤进行安装，根据自身实际情况，选择对于的安装包，本次安装环境为 centos，选择 CentOS/Fedora/Red Hat；
根据提供的指令进行安装
将 jenkins.repo 源文件添加到 yum 库中：
wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo 导入jenkins公钥：
rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key 通过 yum 安装 jenkins：
yum install jenkins 2、下载 rpm 包安装
jenkins rpm包地址为：https://get.jenkins.io 根据自己机器的情况，选择合适的 rpm，LTS为长期稳定版，获取到地址。
通过 wget 获取到 rpm：
wget https://get.jenkins.io/redhat-stable/jenkins-2.289.1-1.1.noarch.rpm 解压：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e62c5070c23bdabdb22ae04e27d61274/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c630fc6699551958708e124c160d2ab/" rel="bookmark">
			Qt编译mysql驱动-总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言通过qt编译MySQL驱动打开mysql.pro文件修改pro文件编译驱动测试效果 VS编译mysql驱动可能出现的问题解决方法问题一 如果你出现了error MSB8036: The Windows SDK version xxx was not found问题或者报了一大堆的无法打开包文件等等的错误，出现无法定位程序输入点，找不到某个库 前言 由于本人下载的是qt5.14.2的版本，近期项目需要用到mysql，但是qt5.12.3是最后提供mysql数据库插件的版本，以后都需要自己编译对应的mysql数据库插件。让我重新下载qt显然不可能，这也就导致我接下来痛苦n天。若有怕麻烦的小伙伴也可以自己下载以前的qt版本，可以不用看下文了。
通过qt编译MySQL驱动 打开mysql.pro文件 如果你在下载qt时已经选择了下载源码，那么恭喜你可以直接打开mysql对应的.pro文件进行编译。如果你在下载qt时没有下载源码也不用担心，链接: qt下载然后选择与你自己qt版本相对于的源码打开解压后即可找到mysql的源码。
这里的E:\QT是你自己安装的路径，只要后面的路径一样就好。你第一次打开应该只有阴影部分的文件，然后打开.pro文件就可以进入qt。 - 如果你此时直接选择mingw套件进行构建，那么将会给你报好多错误，解决这些问题我们需要对pro文件进行如下修改 - 修改pro文件 1.如果不注释第六行，编译的时候就会出现一个错误“mysql is not defined”
2.添加mysql的include文件夹，和第11行引用mysql安装路径lib的libmysql.lib静态库
3.第12行将我们生成的MYSQL驱动库放入指定位置
编译驱动 因为qt中用msvc需要进行一些配置，所以我先以qt默认的mingw来生成驱动
做完这些修改后，就可以重新用mingw进行构建（注意数据库的版本位数要和编译器（构建套件kit）的版本位数一致），可以使用mysql -V命令查看自己的数据库位数。我这里因为是64为因此我选择的是mingw64位的编译器.。
编译成功后，你就会在程序运行目录的上一级目录下发现生成三个文件夹（有些可能是在该盘符下的根目录，比如我这里有可能是在E:\），
然后我们打开plugins这个文件夹将下图两个文件拷贝到你的相应的构建套件的sqldrivers目录下，网上有些说会生成qsqlmysql.dll和qsqlmysqld.dll将这两个拷贝到aqldrivers目录下。，但我这里没生成qsqlmysqld.dll，如果你和我一样，拷贝这两个也可以。
在你的mysql安装路径找到mysql的libmysql.dll和libmysql.lib拷贝到相应的编译套件的bin目录下。
测试效果 新建一个qt项目，记得勾选sql模块，我这里继承的是QMainWindow，这个不重要继承什么窗口类都不重要，你也可以继承QWidget等，然后将main.cpp修改如下 #include "mainwindow.h" #include &lt;QApplication&gt; #include &lt;QSqlDatabase&gt; #include&lt;qmessagebox.h&gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); // MainWindow w; // w.show(); QSqlDatabase db = QSqlDatabase::addDatabase("QMYSQL"); db.setDatabaseName("school");//数据库名 db.setHostName("127.0.0.1");//主机名 db.setUserName("root");//用户名 db.setPassword("xxxxxxxx");//密码 db.setPort(3306);//端口号 if (db.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c630fc6699551958708e124c160d2ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c24523f0b5fa05e4f2fd1ff1f83e5bad/" rel="bookmark">
			FCN图像分割【飞桨】class2(附代码和注释）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FCN 全卷积网络 上图是一个FCN-32s网络的结构图。在这个网络中，图片经过骨干网络（VGG Network）提取特征后，得到长宽缩小32倍的特征图，随后直接将特征图上采样32倍，得到和输入图片一样大小的分割图。
是不是特别简单直接。别看这个网络设计的这么简单，但确实可以得到分割图。
当然，因为是直接将特征图上采样32倍，这种方式得到的分割精度不会很高。
为了提高分割精度，作者还提出将骨干网络的中间层提取出来，与上述分割结果融合，得到最终的输出结果。这样就可以得到FCN-16s, FCN-8s, FCN-4s以及FCN-2s网络。
上图展示的是FCN-8s网络，该网络将Pool3和Pool4的输出取出，与FCN-32s的输出结果融合，得到最终的分割图。具体的融合方式见下图：
首先将FC7（FCN-32s的输出）上采样2倍，与Pool4输出结果相加，得到与Pool4融合的特征图。随后将这个特征图再上采样2倍，与Pool3层的结果相加，得到融合了Pool4、Pool3信息的特征图。再将这个特征图上采样8倍，经过一个softmax层，就得到了与输入图片一样大小的分割图。因为最终上采样8倍，所以称为FCN-8s。
import numpy as np import paddle.fluid as fluid from paddle.fluid.dygraph import to_variable from paddle.fluid.dygraph import Conv2D from paddle.fluid.dygraph import Conv2DTranspose from paddle.fluid.dygraph import Dropout from paddle.fluid.dygraph import BatchNorm from paddle.fluid.dygraph import Pool2D from paddle.fluid.dygraph import Linear from vgg import VGG16BN class FCN8s(fluid.dygraph.Layer):#本质上是复杂的basic_model def __init__(self, num_classes=59): super(FCN8s, self).__init__()#初始化父类 backbone=VGG16BN(pretrained=False)#选择vgg作为backbone #backbone指的是网络的主干网络，对图像进行特征提取（常见的有vggnet，resnet，谷歌的inception），这一部分是整个CV任务的根基 self.layer1=backbone.layer1#直接从vgg中拿就好了 self.layer1[0].conv._padding=[100,100] self.pool1=Pool2D(pool_size=2,pool_stride=2,ceil_mode=True)#ceil_mode我们应对不同尺寸的输入时取整等操作 self.layer2=backbone.layer2 self.pool2=Pool2D(pool_size=2,pool_stride=2,ceil_mode=True) self.layer3=backbone.layer3 self.pool3=Pool2D(pool_size=2,pool_stride=2,ceil_mode=True) self.layer4=backbone.layer4 self.pool4=Pool2D(pool_size=2,pool_stride=2,ceil_mode=True) self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c24523f0b5fa05e4f2fd1ff1f83e5bad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83422ec8f44b6a594002f1de8d939c83/" rel="bookmark">
			因果推断-重要概念：ATE/CATE/ITE/ATT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开个专栏记录一下数据分析中因果推断的知识点，这篇会先引入一些因果推断中的重要概念。
ATE：Average Treatment Effect，平均处理效应。实验组的平均处理效应。比如实验组上线了新的推荐策略，实验组与对照组之间平均效果的差别就是ATE。
CATE：Conditional Average Treatment Effect，条件平均处理效应。实验组中某个细分群的平均处理效应。比如实验组的活跃用户与对照组活跃用户平均效果的差别就是CATE。
ITE：Individual Treatment Effect，个体处理效应。实验组中每个个体的处理效应差异。
ATT：Average Treatment Effects on Treated，受处理群体的平均处理效应。比如实验组受处理的这群人如果不受处理，会是怎样的（这群人受处理与不受处理之间效果的差异）。但是对照组中不存在与实验组中一模一样的人，一般通过PSM来找到实验组人群的替身。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/315258f64ac736cefd6cd5c2734f86a2/" rel="bookmark">
			SQL专题-between and的边界问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		between and是否包含边界不可一概而论，要根据限制变量的格式而定
笔者之前认为between and语法是包含边界的，语句select * from tmp where worktime between 2021-04-06 and 2021-04-09取出来的数据应该是包含06/07/08/09四天，注意这时worktime是精确到天的，例如2021-04-09。
然而近期在取数据时发现between and并不总是包含边界的，具体是否包含边界与变量的格式有关。语句select * from tmp where worktime between 2021-04-06 and 2021-04-09取出来的数据也有可能只包含06/07/08三天的，因为worktime的格式是精确到秒的，比如2021-04-09 14:52:27就没有包含在条件内。所以between and是否包含边界不可一概而论，要根据限制变量的格式而定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e9cddc1557c9cf3f59429b6079a69f4/" rel="bookmark">
			谷歌浏览器调试工具使用基础版（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识采集出处 一. 先来认识一下这些按钮 先来看这张图最上头的一行是一个功能菜单，每一个菜单都有它相应的功能和使用方法，依次从左往右来看
1.箭头按钮：用于在页面选择一个元素来审查和查看它的相关信息，当我们在Elements这个按钮页面下点击某个Dom元素时，箭头按钮会变成选择状态
2.设备图标：点击它可以切换到不同的终端进行开发模式，移动端和pc端的一个切换，可以选择不同的移动终端设备，同时可以选择不同的尺寸比例，chrome浏览器的模拟移动设备和真实的设备相差不大，是非常好的选择
可选择的适配
3.Elements 功能标签页：用来查看，修改页面上的元素，包括DOM标签，以及css样式的查看，修改，还有相关盒模型的图形信息，下图我们可以看到当我鼠标选择id 为lg_tar的div元素时，右侧的css样式对应的会展示出此id 的样式信息，此时可以在右侧进行一个修改，修改即可在页面上生效， 灰色的element.style样式同样可以进行添加和书写，唯一的区别是，在这里添加的样式是添加到了该元素内部，实现方式即：该div元素的style属性，这个页面的功能很强大，在我们做了相关的页面后，修改样式是一块很重要的工作，细微的差距都需要调整，但是不可能说做到每修改一点即编译一遍代码，再刷新浏览器查看效果，这样很低效，一次性在浏览器中修改之后，再到代码中进行修改
对应的样式 盒模型信息 同时，当我们浏览网站看到某些特别炫酷的效果和难做的样式时候，打开这个功能，我们即可看到别人是如何实现的，学会它这知识就是你的了，仔细钻研也会有意想不到的收获
4.Console控制台：用于打印和输出相关的命令信息，其实console控制台除了我们熟知的报错，打印console.log信息外，还有很多相关的功能，下面简单介绍几个：
a: 一些对页面数据的指令操作，比如打断点正好执行到获取的数据上，由于数据都是层层嵌套的对象，这个时候查看里面的key/value不是很方便，即可用这个指令开查看，obj的json string 格式的key/value，我们对于数据里面有哪些字段和属性即可一目了然
其他功能
b: 除了console.log还有其他相关的指令可用
console也有相关的API
5.Sources js资源页面：这个页面内我们可以找到当然浏览器页面中的js 源文件，方便我们查看和调试，在我还没有走出校园时候，我经常看一些大站的js代码，那时候其实基本都看不懂，但是最起码可以看看人家的代码风格，人家的命名方式，所有的代码都是压缩之后的代码，我们可以点击下面的{}大括号按钮将代码转成可读格式
Sources Panel 的左侧分别是 Sources 和 Content scripts和Snippets
对应的源代码 格式化后的代码 关于打断点调试的内容，下面介绍，先来说一些，其他平时基本没人用但是很有用的小点，比如当我们想不起某个方法的具体使用时候，会打开控制台随意写一些测试代码，或者想测试一下刚刚写的方法是否会出现期待的样子，但是控制台一打回车本想换行但是却执行刚写的半截代码，所以推荐使用Sources下面的左侧的Sinppets代码片段按钮，这时候点击创建一个新的片段文件，写完测试代码后把鼠标放在新建文件上run，再结合控制台查看相关信息（新建了一个名叫：app.js的片段代码，在你的项目环境页面内，该片段可执行项目内的方法）
自己书写的片段 Content scripts 是 Chrome 的一种扩展程序，它是按照扩展的ID来组织的，这些文件也是嵌入在页面中的资源，这类文件可以读写和操作我们的资源，需要调试这些扩展文件，则可以在这个目录下打开相关文件调试，但是几乎我们的项目还没有相关的扩展文件，所以啥也看不到，平时也不需要关心这块
无结果
6.Network 网络请求标签页：可以看到所有的资源请求，包括网络请求，图片资源，html,css，js文件等请求，可以根据需求筛选请求项，一般多用于网络请求的查看和分析，分析后端接口是否正确传输，获取的数据是否准确，请求头，请求参数的查看
所有的资源 以上我选择了All，就会把该页面所有资源文件请求下来，如果只选择XHR 异步请求资源，则我们可以分析相关的请求信息
请求的相关信息 打开一个Ajax异步请求，可以看到它的请求头信息，是一个POST请求，参数有哪些，还可以预览它的返回的结果数据，这些数据的使用和查看有利于我们很好的和后端工程师们联调数据，也方便我们前端更直观的分析数据
预览请求的数据 7.Timeline标签页可以显示JS执行时间、页面元素渲染时间，不做过多介绍
8.Profiles标签页可以查看CPU执行时间与内存占用，不做过多介绍
9.Resources标签页会列出所有的资源，以及HTML5的Database和LocalStore等，你可以对存储的内容编辑和删除 不做过多介绍
10.Security标签页 可以告诉你这个网站的安全性，查看有效的证书等
11.Audits标签页 可以帮你分析页面性能，有助于优化前端页面，分析后得到的报告
分析结果 二.Sources资源页面的断点调试 1.如何调试：
调试js代码，肯定是我们常用的功能，那么如何打断点，找到要调试的文件，然后在内容源代码左侧的代码标记行处点击即可打上一个断点
2.断点与 js代码修改
看下面这张图，我在一个名为toggleTab的方法下打了两个断点，当开始执行我们的点击切换tab行为后，代码会在执行的断点出停下来，并把相关的数据展示一部分，此时可以在已经执行过得代码处，把鼠标放上去，即可查看相关的具体数据信息，同时我们可以使用右侧的功能键进行调试，右侧最上面一排分别是：暂停/继续、单步执行(F10快捷键)、单步跳入此执行块(F11快捷键)、单步跳出此执行块、禁用/启用所有断点。下面是各种具体的功能区
在代码中打断点 在当前的代码执行区域，在调试中如果发现需要修改的地方，也是可以立即修改的，修改后保存即可生效，这样就免去了再到代码中去书写，再刷新回看了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e9cddc1557c9cf3f59429b6079a69f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7796409d0d13fc00a2e181c6cd520f9a/" rel="bookmark">
			c#简易 完成计算器(2022)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		…这次是优化过的,学习的话,请大家放心使用,如果有任何问题,尽管私聊问我,如果要源文件,私聊发邮箱给我,我看见了就会发给你们,感谢支持,互相学习!谢谢各位
using System; using System.Drawing; using System.Windows.Forms; namespace Calc { public partial class Form1 : Form { public Form1() { InitializeComponent(); } //变量声明开始 //记录程序第一次1启动 Boolean system_one = false; //判断用过小数点后,是否有输入数字如果没有输入数字就不能使用四则运算符 Boolean dian_number = false; //newValue 用来记录每一次的新值 decimal newValue = 0.0m; //value 是最后的结果 decimal value=0.0m; //fh 是用来记录我们正在使用的符号 String fh; //eco 用来记录 用户摁过多少次等于号, eco = 0 就是还没用过, 如果用过的话 就++ int eco = 0; //oftenValue 用来记录 一直被处理的数字 decimal oftenValue = 0.0m; //record 用来判断使用四则运算符后,是否输入数字,输入了就是true没有就是false Boolean record = true; //numberButton 是用来判断数字键是否使用过,numberButton = false 就是没用过 等于 numberButton =true 就是使用过; Boolean numberButton = false; //符号的次数 false就按原来的样式 true就是其他样式 Boolean numberOfSymbols = false; //用来装记忆的盒子 decimal memory = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7796409d0d13fc00a2e181c6cd520f9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db9ed89c386ccb006dfbd0265fe002e1/" rel="bookmark">
			关于OpenFeign的源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		核心流程图 首先是初始化流程 当我们在使用的时候首先启用Feign，即 启动类中添加注解@EnableFeignClients
@EnableFeignClients public class GatewayApplication { public static void main(String[] args) { SpringApplication.run(GatewayApplication.class, args); } } 进入@EnableFeignClients注解类中
@Import(FeignClientsRegistrar.class) public @interface EnableFeignClients { } 关于@Import的使用可以查看@Import注解了解，此处加载FeignClientsRegistrar类，我们可以继续进入该类中
class FeignClientsRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware, EnvironmentAware { } FeignClientsRegistrar有多个接口实现，ImportBeanDefinitionRegistrar用于自定义实现Bean定义信息、ResourceLoaderAware、EnvironmentAware
我们重点看下ImportBeanDefinitionRegistrar的接口方法registerBeanDefinitions的实现
@Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { registerDefaultConfiguration(metadata, registry); registerFeignClients(metadata, registry); } 其中registerDefaultConfiguration(metadata, registry);方法主要是获取@EnableFeignClients注解参数defaultConfiguration的值…
我们重点看下registerFeignClients(metadata, registry);
public void registerFeignClients(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { LinkedHashSet&lt;BeanDefinition&gt; candidateComponents = new LinkedHashSet&lt;&gt;(); //获取注解中的属性信息 Map&lt;String, Object&gt; attrs = metadata .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db9ed89c386ccb006dfbd0265fe002e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0248ee2dccb3576fe0beb2accccdc21b/" rel="bookmark">
			vue再读23-v-blink绑定class
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 数据渲染界面 --&gt; &lt;!-- 绑定表单元素 --&gt; &lt;div id="abc"&gt; &lt;!-- v-bind 绑定其他属性 --&gt; &lt;!-- 当 a和b的值为true的时候生效 --&gt; &lt;p :class="{active:a,left:b}"&gt;&lt;/p&gt; &lt;p :class="obj"&gt;内容&lt;/p&gt; &lt;/div&gt; &lt;script src="./js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ //v-on里面的methods方法 el: '#abc', //模板ajax返回的数据 data: { obj: { a: true, b: true }, a: true, b: false }, methods: { } }) &lt;/script&gt; &lt;!-- 列表渲染 --&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0248ee2dccb3576fe0beb2accccdc21b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a4dbf236bfa2a98ad91555bdc3b4d69/" rel="bookmark">
			《隐私计算应用研究报告（2022年）》：规模将达到145.1亿元
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年7月13日，在2022隐私计算大会上，中国信通院云计算与大数据研究所副主任闫树发布了《隐私计算应用研究报告（2022年）》。报告系统梳理了隐私计算应用发展现状，深入剖析典型案例，并从项目管理角度详细阐述隐私计算在部署建设中遇到的应用难点及解决方案。报告指出了未来隐私计算的应用展望：通过软硬件产品结合提升隐私计算技术在实际应用场景的可用性，推动隐私计算大规模商业化落地。2025年隐私计算市场规模将达到145.1亿元。
关注公众号并回复 20220723 获取完整报告
隐私计算应用背景
(一)隐私计算概述
隐私计算是“隐私保护计算”(Privacy-Preserving Computation)的简称，有时也被称为“隐私增强计算”(Privacy.-EnhancingComputation),是指在保证数据提供方不泄露原始数据的前提下，对数据进行分析计算，有效提取数据要素价值的一类信息技术，保障了数据在产生、存储、计算、应用、销毁等各个环节中的“可用不可见”、隐私计算交叉融合了人工智能、密码学、数据科学、计算机硬件等多个学科，并逐渐形成了以多方安全计算(Secure Multi-partyComputation,MPC)、联邦学习(Federated Learning,FL)、可信执行环境(Trusted Execution Environment,TEE)为代表的三大技术路线，以同态加密、差分隐私、零知识证明等其他密码学技术为辅助的成熟技术体系，能够在不泄露原始数据的前提下，对数据进行加工、分析处理、分析验证和联合建模等，为数据的开放共享与隐私保护提供丰富的解决方案。
目前主流隐私计算技术分为三大方向：第一类是以多方安全计算为代表的基于密码学的技术；第二类是以联邦学习为代表的人工智能与隐私保护技术融合衍生的技术；第三类是以可信执行环境为代表的基于可信执行环境的技术。每种技术都解决了如何安全地使用保护中的数据的问题，并具有相应的优点和缺点。
由于技术路径的不同，各类隐私计算技术均有其更加适用的场景，可满足不同的业务需求。多方安全计算是基于密码学的可证安全计算，具有高安全性，但对网络要求高，可应用在银行、政府等高安全要求场景。联邦学习效率高，适合数据量大的联合机器学习场景，针对梯度泄露风险，可结合差分隐私或者密码学等方式来提升安全性。可信执行环境属于数据加密后集中计算，具有高安全性、高精度等特点，但需要数据加密集中到第三方环境。相关技术的主要对比如表1-1所示。
(二)政策、需求推动隐私计算应用发展
数据作为新型生产要素已成为国家基础性的战略资源。为解决数据权属界定不清、要素流转无序、隐私保护不足等影响数据要素价值发挥的关键“命门”，随着政策与需求的双重推动，隐私计算已成为需求强烈的数据流通“技术解”之一。
随着政策法规成为隐私计算发展和应用的重要基石，各行业出于数据流通的实际需求布局并应用隐私计算。自2019年起，隐私计算的落地需求呈逐递增趋势（见图1-1），市场层面从落地初期验证阶段进入加速落地阶段，重点呈现出以下趋势：
一是隐私计算应用行业广泛，金融行业应用最多。根据2019-2022年政府公开招标项目整理，金融、通信、政务、医疗等行业均已进行隐私计算平台招标，且需求逐年增长（见图1-2）。其中金融行业招标数量占比最高，为53%，主要包含银行、金融科技、保险、证券等；通信行业招标数量占比为17%，主要包含运营商；政务行业占比13%，主要包含政府、政府部门、事业单位；医疗行业占比9%，主要包含医院、医疗机构或研究所；互联网占比5%，主要包含车联网类、网站类、信息科技类；能源占比3%，主要包含电力。
二是隐私计算不同行业间的招标目的分布不同。主要有对内赋能、对外赋能和双向赋能等形式。对内赋能指招标方通过隐私计算平台引入外部数据价值或能力提升内部业务效果，主要包含科研、数据应用，比如引入外部数据进行联合风控、联合营销等。对外赋能指招标方通过隐私计算平台对外输出数据价值或能力，主要包含数据运营、数据服务，比如对外提供数据安全查询或对外输出联合建模能力等。双向赋能指招标方通过隐私计算平台同时对内、外赋能。
如图1-3所示，金融行业55%的招标项目目的为对内赋能；互联网、通信、医疗、能源行业对外赋能占比均超50%；政务行业双向赋能占比较高。分析其背后产生的原因：首先，金融领域具有高度数字化的特点，具备隐私计算试点的良好条件。同时，金融领域也有大量的隐私计算需求，金融业务中重要的联合风控、联合营销、反欺诈等应用场景，也是隐私计算技术重点支撑场景。其次，通信运营商的数据包括个人实名信息、上网信息、通话信息等，可覆盖个人信息的多个维度。因此，在各种隐私计算应用场景中扮演着重要的数据提供者的角色。再者，政务数据不仅价值高、规模大，而且种类多。近年来，我国各地政府积极推进政务数据的开放共享。隐私计算可以帮助实现跨机构间的个人身份确认、企业经营监管等。
隐私计算应用展望
(一)技术提升
目前整个隐私计算行业的产品化能力仍处于初期，市场上隐私计算产品众多，水平参差不齐，可用性是个值得思考的角度。在隐私计算场景中，会涉及到大量的密文运算及节点间通信，所以计算和通信的代价会非常高昂，而且很容易使其性能远远劣于传统的本地算法，性能的巨大差异可能导致实际落地场景无法忍受。面对大规模场景，数十亿数量级数据运算时，分布式计算节点的故障、网络波动等引发的稳定性问题，隐私计算平台该如何来保证其可用性；不同的行业、不同的场景下，隐私计算的安全性和性能该如何保障；这些都是产品可用性遇到的问题。
在未来的发展中，隐私计算平台需应对数据量的不断增长，那么算力和通信问题的解决必然是一个趋势，技术厂商们也将会通过软硬件结合的方式在兼顾性能和安全性。在3月初结束的全国两会上，“建设数字信息基础设施“提升关键软硬件技术创新和供给能力”被政府确定为2022年重点工作内容。软硬件协同隐私计算方案可有效降低应用落地的部署门槛，同时加强软硬件的全栈能力。软硬件协同产品从底层芯片的选择、硬件电路的涉及、国产密码算法的研发，到上层的隐私计算平台，一键式实现完全的国产自主可控。通过软硬协同方案，可将隐私计算核心算法、算子等进行功能抽取，将其能力下沉并部分托管至硬件环境中，通过调用芯片的加速能力提升平台算力；在“存储”和“传输”方面，可引入物理隔离的通信通道，实现算法及算子的单独运行、数据的单独传输，从逻辑上封装算法/算子的安全加速单元，完成数据“算、存、传”的安全隔离处理。通过结合硬件可插拔的特性，让企业服务器一插即用，即可将之变为隐私计算专用服务器，这无疑提升了产品的可用性，推动隐私计算基础设施的快速落地进程。
在软硬件结合的探索中，隐私计算一体机方案被广泛采用。隐私计算一体机为需求方提供开箱即用的一套隐私计算解决方案，与此同时通过软硬结合的方式实现性能和安全性的增强，更好得提升隐私计算技术在实际应用场景的可用性，推动隐私计算大规模商业化落地。
(二)规模丰富
随着隐私计算技术提升及可用性增强，隐私计算应用规模将持续增强。其市场空间将来自于两个方面：一是传统数据流通模式（数据包传输、AP1调用等)将被隐私计算的可信数据流通方案所重构；另一方面，传统模式下难以共享的数据（如政务数据等）将在隐私计算的加持下实现安全合规开放。
根据Gartner《2021年隐私成熟度曲线》报告中预测：2023年之前全球80%以上的企业将面临至少一项以隐私为重点的数据安全保护规定；到2024年以数据隐私驱动的合规投入将突破150亿美元。到2025年60%的大型企业组织将在分析、商业智能或云计算中使用一种或多种隐私增强计算技术。根据艾瑞咨询报告《中国隐私计算行业研究报告：云程发轫，精耕致远》，2021年中国隐私计算市场规模为4.9亿元，预计2025年将达到145.1亿元，数据运营占比持续升高。Gartner发布的2022年十二大重要战略技术趋势中指出，预计到2025年，60%的大型企业机构将使用一种或多种隐私计算技术（其称为隐私增强计算技术)。　(三)行业拓展
2019年，Gartner首次将隐私计算列为处于启动期的关键技术。
2020年，Gartner又将隐私计算列为2021年企业机构九大重要战略科技之一。近两年来，伴随着技术的不断成熟，国内外隐私计算产业化的步伐明显加快。可以预见，未来几年将是技术产品加速迭代，应用场景快速升级，产业生态逐步成熟的重要阶段。
隐私计算的主要应用领域在金融、通信、政务、医疗、能源等方面。目前的拓展方向一是新的行业领域，二是原有行业的细分领域。
1)证券基金行业拓展
隐私计算在金融行业主要应用在银行风控和营销领域，目前在向保险、证券及基金行业拓展。
对于证券基金行业，证券基金公司总部及其子公司的客户隐私数据无法在内部整合，在满足法律合规要求前提下，通过隐私保护计算技术可以进行一体化风险度量和管理，可以降低证券公司内部金融风险的隐蔽性和复杂性。探索合格投资者判断、穿透式风控、联合反洗钱及黑名单共享等应用场景，能够帮助证券公司全面提升综合风控能力。在联合营销场景中，可以探索通过联邦学习技术丰富业务数据和模型，能够更精准有效地定位业务目标，挖掘数据最大价值。
2)能源电力行业拓展
能源电力领域数据具有数据质量参差不齐、成熟度不高、复杂度较高、协同性较差等特点。目前业内部分领先厂商已经开始探索能源电力领域的技术应用。
在虚拟电厂运营、充配电网协同、电力市场交易等与能源区块链关联的业务场景中，可采用区块链实现数据流通与融合的可信、可溯、可审计。在此基础上，借助隐私计算进一步提升业务系统对黑客解密、篡改数据的难度，确保数据流通融合的隐匿、安全、合规，实现源网荷储一体化数据协同。
在与工业互联网关联的业务场景中，可通过区块链和隐私计算实现数据流通的可信、可塑、可审计、隐匿、安全、合规，建立工业互联网设备画像，并实现设备、数据及网络层面的互联互通。
3)车联网行业拓展
在泛车联网行业，可通过建立省级的平台部署，提供覆盖全省的业务服务，面向全国示范应用。推动车联网数据安全共享生态的建立，推进车联网数据可信体系建立，研究多企业数据联合应用的合作模式，促进车联网行业数据安全共享应用。
在车联网隐私计算平台的应用示范、逐省推广和业务拓展的基础上，可进一步推广至智能交通领域，进行积极拓展商业化项目推广，建立领先、高安全、高性能、高可靠的隐私计算产品和应用示范，树立跨平台车联网数据安全应用的示范标杆；研发跨行业、跨领域的数据融合应用技术，建立合作机制，通过技术服务为智能交通领域企业赋能；支持隐私计算技术在智能交通领域的商业化、规模化应用，引领智能交通全行业的隐私计算技术发展。
报告目录
公众号后台回复“20220723”，即可获取《报告》PDF
来源：隐私计算联盟，版权归属原作者，分享仅供学习参考，如有不当，请联系我们处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b04ee2afacecf578cd72bca95b462c30/" rel="bookmark">
			详细地址通过正则抽取省市区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 let str="(?&lt;province&gt;[^省]+自治区|.*?省|.*?行政区|.*?市)(?&lt;city&gt;[^市]+自治州|.*?地区|.*?行政单位|.+盟|市辖区|.*?市|.*?县)(?&lt;county&gt;[^区]+区|.+旗|.+海域|.+岛)?(?&lt;town&gt;[^区]+区|.+镇)?(?&lt;village&gt;.*)"; let regex = new RegExp(str); let execResult = regex.exec('地址'); let groups = execResult.groups; console.log(groups) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/825b7bde03345d742fd885aecea48771/" rel="bookmark">
			Pytest：yield的简单使用（方法执行后的数据处理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在基于 Pytest 框架编写接口自动化用例时，遇到了这样的一个场景： 1、我需要编写一个「根据用户id查信息」的接口 2、在执行这条用例之前，我准备了一个 fixture 方法用来「新增用户」 3、我现在有一个需求是：在执行完「根据用户id查信息」的接口后，自动将「新增用户」创建的用户自动删除，防止脚本造成垃圾数据 4、于是我把目光转到了「yield」方法：使用 yield 替代 return，并在yield 后添加需要执行的方法 一、首先创建文件，使用 Flask 来 mock 三个接口Api【记得Run起来】 # -*- -*- -*- -*- -*- -*- -*- -*- # -*- coding: utf-8 -*- # @文件名称 : mock_api.py # @创 建 者 : PythonKimo # -*- -*- -*- -*- -*- -*- -*- -*- # coding=gbk from flask import request, Flask, jsonify app = Flask(__name__) @app.route('/api/v1/addUser', methods=['POST']) def addUser(): return jsonify({ "code": 1, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/825b7bde03345d742fd885aecea48771/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d80b8e8276b77ccf9d70ad434cae15b9/" rel="bookmark">
			一维数组转化为二维数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; int main() { int i,j,k=0,arr[5]={0,1,2,3},arr2[2][2]={0}; for(i=0;i&lt;2;i++) for(j=0;j&lt;2;j++) { arr2[i][j]=arr[k]; k++; } return 0; } 1. 这里通过引入第三个变量将一维数组的值挨个赋值给二维数组，实现一维到二维的转化。
#include &lt;stdio.h&gt; int main() { int i,arr[4]={0,1,2,3},arr2[2][2]={0}; for(i=0;i&lt;5;i++) arr2[0][i]=arr[i]; return 0; } 2.利用定义的二维数组的边界条件，通过一次循环实现一维数组向二维数组的转换。
#include &lt;stdio.h&gt; int main() { int i,arr[4]={0,1,2,3},arr2[2][2]={0}; for(i=0;i&lt;4;i++) arr[i/2][i%2]=arr[i]; return 0; } 3.通过运算，利用一次循环的i值，确定被赋值的二维数组的下标，从而实现一维数组向二维数组的转化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a073dbe861c53759dd00088cbcac0252/" rel="bookmark">
			服务器如何搭建虚拟主机？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟主机或称共享主机，又称虚拟服务器，是一种在单一主机或主机群上，实现多
网域服务的方法，可以运行多个网站或服务的技术。虚拟主机之间完全独立，并可由用户自行管理，虚拟并非指不存在，而是指空间是由实体的服务器延伸而来，其硬件系统可以是基于服务器群，或者单个服务器。现在有很多服务器管理工具，使用管理工具，可以快速搭建出一个个虚拟主机。虚拟主机实现方式一般分为网址名称对应、IP地址对应以及Port端口号对应。
一、基于IP的方法：
服务器上绑定多个IP，接着配置WEB服务器，将多个网站绑定在不同的IP上。浏览不同的IP，即可看到不一样的网站。
二、基于端口的方法：
一个IP地址，通过不同的端口实在不同网站的访问。
三、基于主机名的方法：
装备多个域名的A记录，让它们解析到同一个IP地址上，也就是一样的服务器上。随后，在服务器上安装WEB服务端，增加多个网站，在每个网站上拟定一个主机名称。因为HTTP协议访问请求里包含有主机名信息，当WEB服务器收到访问请求时，会根据不同的主机名来访问不同的网站。
虚拟主机技术是互联网服务器采用的节省服务器硬件成本的技术，虚拟主机技术主要应用于HTTP（Hypertext Transfer Protocol，超文本传输协议）服务，将一台服务器的某项或者全部服务内容逻辑划分为多个服务单位，对外表现为多个服务器，从而充分利用服务器硬件资源。
虚拟主机是使用特殊的软硬件技术，把一台真实的物理服务器主机分割成多个逻辑存储单元。每个逻辑单元都没有物理实体，但是每一个逻辑单元都能像真实的物理主机一样在网络上工作，具有单独的IP地址（或共享的IP地址）、独立的域名以及完整的Internet服务器（支持WWW、FTP、E-mail等）功能。
虚拟主机的关键技术在于，即使在同一台硬件、同一个操作系统上，运行着为多个用户打开的不同的服务器程式，也互不干扰。而各个用户拥有自己的一部分系统资源（IP地址、文档存储空间、内存、CPU等）。各个虚拟主机之间完全独立，在外界看来，每一台虚拟主机和一台单独的主机的表现完全相同。所以这种被虚拟化的逻辑主机被形象地称为“虚拟主机”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebd969a3f702364888f4fe0da9c55b4d/" rel="bookmark">
			阿里数据库连接池Druid 连接MySQL失败：javax.net.ssl.SSLHandshakeException: No appropriate protocol
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天电脑蓝屏开不了机，一查是SSD坏了，还好项目这些在机械硬盘没有丢失。今天换了台新电脑，将项目复制过来，运行却出错了，Druid 连接不上MySQL，报了以下异常：
com.alibaba.druid.pool.DruidDataSource : create connection SQLException, url: jdbc:mysql://118.178.112:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai, errorCode 0, state 08S01 com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure ... Caused by: javax.net.ssl.SSLHandshakeException: No appropriate protocol (protocol is disabled or cipher suites are inappropriate) at sun.security.ssl.HandshakeContext.&lt;init&gt;(HandshakeContext.java:171) at sun.security.ssl.ClientHandshakeContext.&lt;init&gt;(ClientHandshakeContext.java:101) at sun.security.ssl.TransportContext.kickstart(TransportContext.java:238) at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:394) at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:373) at com.mysql.cj.protocol.ExportControlled.performTlsHandshake(ExportControlled.java:315) at com.mysql.cj.protocol.StandardSocketFactory.performTlsHandshake(StandardSocketFactory.java:188) at com.mysql.cj.protocol.a.NativeSocketConnection.performTlsHandshake(NativeSocketConnection.java:99) at com.mysql.cj.protocol.a.NativeProtocol.negotiateSSLConnection(NativeProtocol.java:352) ... 13 common frames omitted 百度一查，发现是jdk1.8版本导致SSL调用权限上有问题，新电脑装的jdk是jdk1.8.0_291，版本比较高。搜到的解决方法是：
找到jdk 1.8安装目录，找到C:\Program Files\Java\jre里面的lib\security 下面有个java.security。找到对应的SSLv3，删除掉，重启项目就好了。（删掉SSLv3就是允许SSL调用）
我找到Java安装目录下D:\Java\jdk1.8.0_291\jre\lib\security中的java.security文件，将对应的SSLv3删掉了，但运行还是出错。最后发现SSLv3后面有两个和它后缀一样的算法，将它们一起删掉后重启项目，成功解决问题。
删除后的文件如下图所示。
参考链接：https://blog.csdn.net/weixin_38111957/article/details/80577688
更新 此贴评论里的@fireinjava大佬提出了一种更简单的方法，在此复制出来方便大家查看
方法：url 加个 ?useSSL=false 参数就好
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebd969a3f702364888f4fe0da9c55b4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/319a18bab4aba413827ffabd76d2229a/" rel="bookmark">
			手机端访问本地编写的html页面【亲测有效】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境 1. 首先你的手机要和电脑是在同一个局域网，例如手机和电脑连接同一个wifi，此次举例我是笔记本电脑连接我的手机热点，也是同属一个局域网下。
2. 确保电脑上已经安装node.js 正题开始： 1. cmd 命令行中 安装
cmd 命令行中 安装 npm install http-server -g 2. cmd进入项目盘目录:
3. 输入http-server指令开启服务，cmd就会提示:
例如我的，第一个就是你手机可以访问的内网地址，第二个是你电脑的回环地址。
别急啊，现在你的手机还是访问不了。打开你的防火墙设置–高级设置
二、关闭指定端口的防火墙 新建个入站规则： 这里开放和http-server服务里一样的端口，例如我的是8080
名字随便取：
同样的操作，给出站的创建一个：
这样，8080端口就被完全打开了。 打开手机输入上述地址： http://192.168.2.19:8080 链接成功
默认访问的是index.html文件，如果你想访问其他文件，例如css效果测试，应该这样172.20.10.4:8080/css效果测试，就可以访问了。
每次修改完html文件后，手机浏览器页面要刷新一下才会更新哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c98a1e33b4fbffc39319ac56801ea0f3/" rel="bookmark">
			VantUI组件在Vue2项目当中CSS样式不显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 在Vue2项目当中，按需引入Vant组件会出现CSS样式不显示的问题
解决方案 在使用vant组件的时候，出现样式不显示的问题，首先需要确保自己使用的vant组件的版本，由于项目开发使用的是Vue2所以对应的vant组件不能是最新版本，需要使用vant2
yarn add vant@latest-v2 -S or npm i vant@latest-v2 -S 其次，需要在main.js入口文件当中，引入组件，并且使用。在项目开发中，单独建立了一个ui文件夹，负责管理所有的vant组件。
ui/index.js
import { Button } from 'vant'; const vant = { install: function (Vue) { // 标签栏 Vue.use(Button); } } export default vant main.js
import Vue from 'vue' import App from './App.vue' // 引入vant import vant from '@/ui' // 使用vant Vue.use(vant) Vue.config.productionTip = false new Vue({ render: h =&gt; h(App) }).$mount('#app') 由于vant组件我们采用的是默认暴露的形式，所有需要下载一个插件，并且配置babel，才能自动帮助我们按需引入
yarn add babel-plugin-import -S or npm i babel-plugin-import -S 接着在babel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c98a1e33b4fbffc39319ac56801ea0f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45abd6d94ae6b193e8b82f7fc43550a6/" rel="bookmark">
			FactoryBean的getObject调用时机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://blog.csdn.net/u022812849/article/details/114368497?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2aggregatepagefirst_rank_ecpm_v1~rank_v31_ecpm-1-114368497-null-null.pc_agg_new_rank&amp;utm_term=FactoryBean%E5%9C%A8%E5%93%AA%E9%87%8C%E6%89%A7%E8%A1%8C%E7%9A%84&amp;spm=1000.2123.3001.4430
先编写测试代码：
public class Dog { private String name; public Dog(String name) { System.out.println("new dog"); this.name = name; } } import org.springframework.beans.factory.FactoryBean; public class DogFactoryBean implements FactoryBean&lt;Dog&gt; { @Override public Dog getObject() throws Exception { return new Dog("WangWang"); } @Override public Class&lt;?&gt; getObjectType() { return Dog.class; } } import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class FactoryBeanDemo { public static void main(String[] args) { AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); applicationContext.register(DogFactoryBean.class); applicationContext.refresh(); System.out.println(applicationContext.getBean("&amp;dogFactoryBean")); System.out.println(applicationContext.getBean("dogFactoryBean")); } } 执行结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45abd6d94ae6b193e8b82f7fc43550a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/829061a295efe104c2ec9a999c2ce98c/" rel="bookmark">
			使用VRRP技术实现网关设备冗余，附详细配置实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、VRRP技术的原理二、VRRP实验与配置1、实验拓扑2、实验拓扑介绍3、实验配置VRRP配置命令设备配置 三、实验结果总结 前言 企业的网络中一般会使用三层交换机或路由器来当作网关设备，这个网关设备上面连着出口路由器或防火墙来通向外网，如果企业中的这个网关设备出现故障，就会导致内网的终端设备无法访问公网。为了避免这种情况的发生，VRRP（虚拟路由器冗余协议）技术可以实现网关设备的冗余备份，即使有一台网关设备宕机，另一台也能转发流量，保证内网的终端正常上网。
一、VRRP技术的原理 因为一个网卡只能配置一个网关地址，所以两台网关设备就共同虚拟出一个ip地址，当其中一台设备宕机时，另一台设备也能继续维护这个虚拟ip，实现网关设备的冗余备份效果。
二、VRRP实验与配置 1、实验拓扑 2、实验拓扑介绍 PC1是内网的终端设备。LSW3是接入交换机。LSW1和LSW2是网关设备，用于实现网关冗余。LSW1的GE0/0/1口的ip地址是192.168.1.252/24，LSW2的GE0/0/1口的IP地址是192.168.1.253/24，它们使用VRRP技术共同虚拟出一个网关地址192.168.1.254/24。网关设备上面是一个出口路由器。路由器AR3模拟运营商网络，回环口模拟公网中的某个地址。 3、实验配置 VRRP配置命令 命令备注vrrp vrid 10 virtual-ip 192.168.1.254在此端口下配置VRRP，并设置虚拟地址为192.168.1.254vrrp vrid 10 priority 200设置此端口的主路由优先级为200，默认优先级是100vrrp vrid 10 track interface g0/0/2 reduced 150当检测到上行端口故障时，自动将优先级减少150，使备用端口变成主端口display vrrp显示vrrp配置结果 设备配置 LSW3: vlan 10 int e0/0/2 port link-type trunk port trunk allow-pass vlan 10 //允许带标签VLAN10的数据帧通过 int e0/0/3 port link-type trunk port trunk allow-pass vlan 10 //允许带标签VLAN10的数据帧通过 int e0/0/1 port link-type access port de v 10 LSW1: vlan 10 int vlanif 10 //创建vlanif接口 ip add 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/829061a295efe104c2ec9a999c2ce98c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e25dcf437a906626008d8fc71cc9b56e/" rel="bookmark">
			JavaScript原型链(重要)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 构造函数与原型 先了解一个概念：
类就是对象的模板，对象就是类的实例。
在构造函数内部的this指向它的实例对象。
2. new关键字 这个也是面试常考的知识点
在实例化构造函数时，做了什么？或者说在JavaScript中new
创建空对象 var zs = { }
将构造函数内部的this指向空对象 this -&gt; zs 把属性和方法挂载到实例对象上。 zs.name zs.age zs.sing()
隐式返回新对象。
3. 实例成员与静态成员 实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问。静态成员：在构造函数本身上添加的成员称为静态成员，只能由构造函数本身来访问。 var arr = new Array() console.dir(arr); console.dir(Array); 4. 构造函数与静态成员 同一个函数，会在内存中保存多份，会造成内存的浪费。
&lt;script&gt; function Cup(color, size) { this.color = color this.size = size this.save = function () { console.log("储水"); } } var mycup1 = new Cup("紫色", "3400ml") var mycup2 = new Cup("绿色", "400ml") console.log(mycup1); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e25dcf437a906626008d8fc71cc9b56e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e96c16e03c22e37efe27fbceb21084df/" rel="bookmark">
			Microsoft_Store保姆级安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Microsoft_Store安装教程 简介： 有些Windows系统（如LTSC）并不内置Microsoft_Store，在有需要的时候会造成不便。（亲身感受） 网上有些教程太局限，不同的架构mo的安装，所以我亲自写一份使用多种架构的教程。接下来，我就介绍下怎么安装Microsoft_Store。
1.首先，下载安装包。 这里，我整理了一些通用安装包(适用多WIN10系统架构）。在这里可以下载
2.下载解压 解压软件这里不做推荐，任意即可。
然后在D盘根目录新建一个文件夹microsoftstore(如果没有就C盘根目录)
解压后得到：
3.获取目录地址 我们打开《microsoftstore》文件夹，
然后，我们可以得到
然后，复制地址。
4.调起Powershell管理员 我们搜索
5.进入安装目录 输入cd 安装包目录(第一步复制的),如
然后，输入 Add-Appxpackage *执行安装
提示错误也没关系，因为只安装了适合的架构安装包。
6.安装成功 还有疑问的请私信。
末尾PS:关注我，获取更多教程。（会更新的！）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4515c656fbc267e978b35a9821dff821/" rel="bookmark">
			深度学习之 9 前馈神经网络2：实现前馈神经网络，模型调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇我们了解了前馈神经网络的基础概念知识之后，本文来实现前馈神经网络。本文是接着上一篇深度学习之 9 前馈神经网络 基本概念_水w的博客-CSDN博客
目录
手动实现前馈神经网络
（1）数据集介绍
➢ Fashion-MNIST数据集下载
➢ 批量读取数据，采用torch.utils.data.DataLoader读取小批量数据
（2）模型设计（包含一个隐藏层）
（3）代码实现
➢ 模型参数定义及初始化
➢ 定义激活函数，我们选用ReLU作为激活函数
➢ 定义模型，随机梯度下降函数，交叉熵损失函数，
➢ 计算模型在某个数据集上的准确率
➢ 定义模型训练函数
➢ 训练模型
Torch.nn实现前馈神经网络
（3）代码实现
➢ 实现FlattenLayer层 ➢ 模型定义和参数初始化
➢ 计算模型在某个数据集上的准确率和loss
➢ 设置训练轮次、学习率、损失函数和优化器
➢ 模型训练，保存训练集和验证集的loss
➢ 训练结果和loss曲线绘制 ➢ 绘制loss曲线
模型调优
（1）实验数据划分
◼ 手动实现K折交叉验证
（2） 模型选择、欠拟合、过拟合
◼ 多项式函数拟合实验探究影响欠拟合、过拟合的因素
（3）过拟合问题的常用方法——L 2 范数正则化
◼ 以高维线性回归为例来引入一个过拟合问题
◼ 手动实现𝑳𝟐范数正则化
◼ 利用torch.optim的weight_decay参数实现𝑳𝟐范数正则化
（4）应对过拟合问题的常用方法——Dropout
◼ 手动实现dropout
◼ 利用torch.nn.Dropout层实现dropout
手动实现前馈神经网络 （1）数据集介绍 采用Fashion-MNIST数据集完成多分类任务。
训练集：60,000 测试集：10,000每个样本的数据格式为：28*28*1（高*宽*通道）Fashion-MNIST中包含的10个类别分别为： t-shirt（T恤）、trouser（裤⼦）、pullover（套衫）、dress（连⾐裙）、coat（外套）、sandal（凉鞋）、shirt（衬衫）、sneaker（运动鞋）、bag（包）和ankle boot（短靴）。 ➢ Fashion-MNIST数据集下载 ➢ 批量读取数据，采用torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4515c656fbc267e978b35a9821dff821/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/303d22184fe3a3593548c173049381eb/" rel="bookmark">
			VS2022的下载和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、VS2022的下载
二、VS的一些使用技巧
1.如何使用VS写代码
2.scanf函数在VS上的使用
3.下载后怎么安装新的工作负荷
4.VS的调试与监视功能
如何进行调试
如何进行监视
三、结语
一、VS2022的下载 VS官网链接
1.打开VS的官网链接，选择下载Visual Studio，选择社区版，点击下载。
2.工作负荷选择使用c++的桌面开发即可，单个组件不需要选择，语言包默认勾选中文简体，安装位置默认c盘，如果感觉自己的c盘内存不够，建议把c改成d，其余不要动就好了。确认无误后，点击安装。
这个时候可能有的小伙伴就要问了，我多选几个不是更好吗，没准以后学别的就用到了，像小编有的朋友，一下子把所有的工作负荷都打上了√，需求的总空间达到了40多个GB，其实并没有这个必要，因为VS下载之后还是可以再安装工作负荷的。当我们真正使用到了在安装更好，后续再功能介绍这一块我会讲解安装方法的。
二、VS的一些使用技巧 1.如何使用VS写代码 打开VS，在开始使用一栏中选择创建新项目。
项目模板选择空项目，下一步。
取一个项目名称。（尽量不要用中文），路径可以选择默认路劲，也可以自己选择。解决方案管理器建议选择“将解决方案和项目放在同一目录中”，然后就可以创建了。
打开项目后，看向右边的解决方案资源管理器（如果发现没有也没关系，再最上方找到视图，点击，第一个就是解决方案资源管理器，点击打开就好），选择源文件。
右击，选择添加，选择新建项。
选择c++文件，但名称需要以.c为后缀，像图片中那样，因为我们目前学的是c语言，而不是c++。设置好之后，选择右下角的添加就可以了。
如此，大功告成，开始写第一个程序吧！
2.scanf函数在VS上的使用 下面我们来看一个简单的程序。这个程序乍一看并没有问题，但在VS上就是运行不了。
#include&lt;stdio.h&gt; int main() { int n = 0; scanf("%d", &amp;n); return 0; } 在错误列表中会显示这么一段话。
这是因为在VS当中，scanf被认为成是不安全的函数。（其实，像这样不安全的函数，VS认为有很多，比如说strcpy，strcat，gets函数等，不过，采用我下面所讲的第二种解决办法，这些函数就都可以在VS上运行）这里有两种解决办法，第一种办法是直接使用scanf_s函数作为替代，但我不推荐这个做，一来，scanf函数是c语言的函数，而scanf_s函数是VS的特有函数，在别的编译器无法运行。二来，scanf_s函数与scanf函数类似，但不完全一样，要使用scanf_s函数还需要单独学习。我推荐使用第二种方法，这种方法只要在原有的基础上添加一个宏定义即可（放在文件第一行）。代码如下。
#define _CRT_SECURE_NO_WARNINGS 1 这样scanf函数就可以正常使用了。但如果每次创建一个项目都需要加上这么一串代码的话未必太过麻烦，这里有个很好的解决办法，可以让文件自动生成这段代码。首先，我们需要找一个文件，这里要用到一个软件，叫Everything（点击下方链接即可，当中有很多版本，都可以下载来用）。
Everything下载链接
下载完成后打开这个软件，搜索框输入newc++file.cpp，找到这个文件，右击，选择打开路径。（当然，也可以不下载，直接在电脑中查找，不过这样查找比较慢）
我们来到指定路劲，右击，选择复制，然后在桌面上选择粘贴。（为什么要复制到桌面进行操作呢，因为如果还是在安装的位置当中操作的话，会遇到无法保存的问题）
粘贴完成后，右击，选择打开方式，选择记事本打开。
将下述代码复制到记事本中就可以了。
#define _CRT_SECURE_NO_WARNINGS 1 就像这样，点击保存（小技巧：保存的快捷键是ctrl+s）。
保存完成后，将该文件拖回原来的路劲，选择替换目标中的文件。
这一步完成后，把桌面剩下的那个文件拖入回收站就好了。到此，大功告成，虽然有些繁琐，不过后面我们创建的所有文件都会自动生成“#define _CRT_SECURE_NO_WARNINGS 1”了，可谓一劳永逸。现在使用scanf函数系统就不会报错了。
3.下载后怎么安装新的工作负荷 其实这很简单，在页面的最上分找到工具，选择获取工具和功能。
此时，选择你想要安装的组件或者工作负荷就好了。
4.VS的调试与监视功能 这里建议读者阅读完之后亲自动手实践一下，一定会有不一样的收获
如何进行调试 VS中，使用fn+f10或fn+f11（有的电脑是f10，后面的快捷键也类似，此处我以带fn为例）可以进入调试页面，调试过程中按f10或f11执行语句即可。（f10是逐过程，通常用来处理一个过程，一个过程可以是一次函数调用，或者是一条语句。而f11是逐语句，每次都执行一条语句，但是这个快捷键可以使我们的执行逻辑进入函数内部，而f10不会，这是最长用的。）
如何进行监视 页面上方找到调试，选择窗口，选择监视，选择监视1。
这样就会出现监视1的窗口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/303d22184fe3a3593548c173049381eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a96ffd8db81075e76c1698ea464193c3/" rel="bookmark">
			DOM - 查看当前节点下有无子元素节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 for 循环版 Element.prototype.hasChildren = function () { const childNodes = this.childNodes, len = childNodes.length; for (let i = 0; i &lt; len; i++) { const item = childNodes[i]; if (item.nodeType === 1) { return true; } } return false; } while 循环版 Element.prototype.hasChildren = function () { const childNodes = this.childNodes, len = childNodes.length; while (len) { item = childNodes[len - 1]; // 倒着遍历 if (item.nodeType === 1) { return true; } len--; } return false; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14618ef56f3475309cb60ac523718799/" rel="bookmark">
			[已解决]SpringCloud集群分布Eureka依赖问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Eureka分布式警告问题 在学习SpringCloud时,配置Eureka集群分布式抛出警告 WARN — [ restartedMain] arterDeprecationWarningAutoConfiguration : spring-cloud-starter-eureka-server is deprecated as of Spring Cloud Netflix 1.4.0, please migrate to spring-cloud-starter-netflix-eureka-server
eureka-server
说明该依赖已经废弃,需要使用spring-cloud-starter-netflix-eureka-server这个依赖（下面有链接）
eureka-client
同样在使用spring-cloud-starter-eureka也是同样情况
建议使用spring-cloud-starter-netflix-eureka-client这个依赖
获取地址
spring-cloud-starter-netflix-eureka-server
spring-cloud-starter-netflix-eureka-client
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c3e81d42806f862b065e69fa9fcadd7/" rel="bookmark">
			IO流之 字节流 &amp; 字符流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、了解IO流
1.IO流的特点
2.流的三种分类方式
3.流的层次结构
二、字节流
1.什么是字节流
2.使用字节流实现文件拷贝
3.使用try - catch - finally 优化资源释放
4.使用try - catch - resource 进一步优化资源释放
三、字符流
1.什么是字符流
2.文件字符输入流 - 每次读取单个字符
3. 文件字符输入流 - 每次读取一个字符数组
4.字符输出流
总结
前言 大多数应用程序都需要实现与设备之间的数据传输，例如键盘可以输入数据，显示器可以显示程序的运行结果等。在Java中，将这种通过不同输入输出设备（键盘，内存，显示器，网络等）之间的数据传输抽象的表述为“流”，程序允许通过流的方式与输入输出设备进行数据传输。Java中的“流”都位于Java.io包中，称之为IO（输入输出）流。 IO流：即InputOutput的缩写。
一、了解IO流 1.IO流的特点 IO流用来处理设备间的数据传输。
Java对数据的操作是通过流的方式。
Java用于操作流的对象都在IO包中。
流按操作数据分为两种：字节流和字符流。
流按流向分为：输入流和输出流
2.流的三种分类方式 按流的方向分为：输入流和输出流
按流的数据单位不同分为：字节流和字符流
按流的功能不同分为:节点流和处理流
3.流的层次结构 IO流的常用基类：
字节流的抽象基流：InputStream和OutputStream字符流的抽象基流：Reader和Writer 二、字节流 1.什么是字节流 一切文件数据在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。
2.使用字节流实现文件拷贝 无论是音视频文件还是文本文件底层都是字节组成，因此可以使用字节输入流&amp;字节输出流完成任何形式文件拷贝（只要保证前后文件格式、编码一致没有任何问题）
注意： 字节流不适合读取中文内容输出，（在UTF-8编码中，一个中文字符是3个字节）容易出现截断导致乱码
public static void main(String[] args) { try { //创建字节输入流管道 InputStream is = new FileInputStream("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c3e81d42806f862b065e69fa9fcadd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33cf06f14f7b16625533642e075d2703/" rel="bookmark">
			VMware中安装FusionCompute8.1.1 CNA和VRM镜像安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware中安装FcusionCompute8.1 一、VMware Workstation分别安装CNA、VRM
注意事项：
根据自身电脑的规格，一般8G+内存的电脑配置可以支持
若自己电脑是4G规格建议跳过该实验
若自己电脑是8G规格建议测试分开VRM，CNA
若自己电脑是16G规格可以同时测试CNA，VRM
VRM手动安装：
创建一台虚拟机，规格：6核CPU、8G内存、200G磁盘（不立即分配） ，挂载VRM的镜像，配置相关参数，具体参数如下
1.创建虚拟机，勾选自定义
2.选择稍后安装操作系统
3.操作系统版本选择SUSE Linux Enterprise 12 64位（不要选错了啦！）
4.建议选择非系统盘，非还原盘存放虚拟机文件，防止磁盘空间不足或数据丢失
5.网络类型可以自行进行配置，可以选择桥接，NAT，仅主机，但后续配置静态配置VRM的地址需要跟桥接网络，NAT网络，仅主机网络同一个网段!
6.选择推荐
7.磁盘类型选择IDE
8.分配200G，不立即分配（精简）
9.为虚拟机挂载VRM镜像（VRM.ISO）
10虚拟化引擎勾选vt -x
11.打开虚拟机，选择install
12.系统加载中
13.配置相关参数（Tab键移动）配置网络，主机名，密码即可，网络配置与NAT网络相同网段（根据个人虚拟网络适配器配置进行选择）
配置IP地址和子网掩码
配置网关
选择IPV4
给主机命名
设置密码
配置都没问题，选择yes，等待安装
14.等待进度条
15.安装成功
16.输入用户名密码，正常访问VRM主机，在浏览器输入VRM的IP地址，登陆 FusionCompute（FusionCompute用户名：admin 密码：IaaS@PORTAL-CLOUD8!）
注意：VRM安装完毕后，需要稍等片刻，才能访问FusionCompute界面
CNA手动安装:
创建一台虚拟机，规格：4核CPU ，8GB内存，150GB硬盘（不立即分配），挂载CNA的镜像，配置相关参数，具体配置参数可以参考VRM手动安装。
1、输入用户名密码，正常访问CNA主机，输入virsh list –all
注意：通过Vmware安装的VRM可能无法对接CNA，存在不同厂商不兼容的问题，也无法通过工具部署VRM与CNA。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/386a28d47e72efb48015ec9c112d89ab/" rel="bookmark">
			电源接头DC002的PCB封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DC电源接口2、3脚接地，1脚是VCC（电源）。
AD16的元器件PWR2.5，可直接使用。但只有5.5规格的PCB封装，DC002型号的要自己做。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1978b30049cd8511bd11ba57edc8aa65/" rel="bookmark">
			Redis配置Kryo序列化和Snappy压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 redis自带的StringSerializer性能相对较差，redis官方推荐kryo来提高序列化和反序列化速度，推荐snappy来节约redis内存和网络带宽，在springboot中可以通过配置快速实现这个功能
maven配置 &lt;dependency&gt; &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt; &lt;artifactId&gt;kryo&lt;/artifactId&gt; &lt;version&gt;5.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.xerial.snappy&lt;/groupId&gt; &lt;artifactId&gt;snappy-java&lt;/artifactId&gt; &lt;version&gt;1.1.8.4&lt;/version&gt; &lt;/dependency&gt; 配置KryoRedisSerializer import com.esotericsoftware.kryo.Kryo; import com.esotericsoftware.kryo.io.Input; import com.esotericsoftware.kryo.io.Output; import lombok.extern.slf4j.Slf4j; import org.springframework.data.redis.serializer.RedisSerializer; import org.springframework.data.redis.serializer.SerializationException; import java.io.ByteArrayOutputStream; /** * @author 后厂村老司机 */ @Slf4j public class KryoRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt; { public static final byte[] EMPTY_BYTE_ARRAY = new byte[0]; private static final ThreadLocal&lt;Kryo&gt; KYROS = ThreadLocal.withInitial(Kryo::new); private Class&lt;T&gt; clazz; public KryoRedisSerializer(Class&lt;T&gt; clazz) { super(); this.clazz = clazz; } @Override public byte[] serialize(T t) throws SerializationException { if (t == null) { return EMPTY_BYTE_ARRAY; } Kryo kryo = KYROS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1978b30049cd8511bd11ba57edc8aa65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f61a4cf60647ba1900236842191d4e71/" rel="bookmark">
			ChromeDriver下载-自用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 官网地址：https://chromedriver.chromium.org/downloads 仓库地址：http://chromedriver.storage.googleapis.com/index.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40ad104c4321e507f84ec4b2e2393591/" rel="bookmark">
			Java8 Stream流中的 collect() 方法，远比你想象中的强大
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击关注公众号，利用碎片时间学习
Stream流 collect() 方法的使用介绍
//1. &lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner); //2. &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector); Stream 流的注意事项：Stream不调用终止方法，中间的操作不会执行。
但是，当我们对 Stream 流中的数据操作完成之后，如果需要将流的结果进行保存，方便我们接下来对结果的继续操作，该怎么办呢？
Stream 流提供了一个 collect() 方法，可以收集流中的数据到【集合】或者【数组】中去。
1.收集 Stream 流中的数据到集合中 //1.收集数据到list集合中 stream.collect(Collectors.toList()) //2.收集数据到set集合中 stream.collect(Collectors.toSet()) //3.收集数据到指定的集合中 Collectors.toCollection(Supplier&lt;C&gt; collectionFactory) stream.collect(Collectors.joining()) 示例如下：
/** * 收集Stream流中的数据到集合中 * 备注：切记Stream流只能被消费一次,流就失效了 * 如下只是示例代码 */ public class CollectDataToCollection{ public static void main(String[] args) { //Stream 流 Stream&lt;String&gt; stream = Stream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40ad104c4321e507f84ec4b2e2393591/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bfdc8900b0b5e2656ae2bf2a5a550c0/" rel="bookmark">
			【SpringBoot】The dependencies of some of the beans in the application context form a cycle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这句话的意思是：应用程序上下文中某些bean的依赖关系形成了一个循环
有时候在写项目时会忘记类的依赖关系，很容易导致两个对象互相注入，形成了一个循环，但是官方是不鼓励依赖循环，默认情况下禁止它们。
解决办法1 Update your application to remove the dependency cycle between beans 更新应用程序以删除bean之间的依赖关系循环。一般控制台会打出来告诉你是哪里的类导致的互相依赖。比如以下日志：
The dependencies of some of the beans in the application context form a cycle: ┌─────┐ | springLoopService1 (field com.jiefei.jdbc.service.impl.SpringLoopService2 com.jiefei.jdbc.service.impl.SpringLoopService1.springLoopService2) ↑ ↓ | springLoopService2 (field com.jiefei.jdbc.service.impl.SpringLoopService1 com.jiefei.jdbc.service.impl.SpringLoopService2.springLoopService1) └─────┘ 直接根据自己需要，让他们不要互相依赖就行了。
解决办法2 在application.yml 中使用以下配置，好像是SpringBoot2.6.0之后默认禁止的。
spring: main: allow-circular-references: true #允许循环引用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/433ae4087e38a5adc61f15765b55da57/" rel="bookmark">
			java基础面试题2022（常见）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现网上很多Java面试题都没有答案，所以花了很长时间搜集整理出来了这套Java面试题大全，希望对大家有帮助哈~
本套Java面试题大全，全的不能再全，哈哈~
博主已将以下这些面试题整理成了一个Java面试手册，是PDF版的。
关注博主的微信公众号：Java团长，然后回复“面试手册”即可获取~
一、Java基础知识面试题 1、Java概述 ①. 何为编程 编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。
为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。
②. 什么是Java Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。
③. jdk1.5之后的三大版本 Java SE（J2SE，Java 2 Platform Standard Edition，标准版）
Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版）
Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEEJava ME（J2ME，Java 2 Platform Micro Edition，微型版）
Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。 ④.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/433ae4087e38a5adc61f15765b55da57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9921d5c00031984fe65751408b36343d/" rel="bookmark">
			QT&#43;OpenGL(1)——包含头文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于智能提示建议放弃Cmake生成，直接包含头文件，包含方法如下
如果找不到头文件，直接用everything搜相应文件，再给包含进去
需要新建文件夹，新建文件
c_cpp_properties.json
​ { "configurations": [ { "name": "Win32", "includePath": [ "${workspaceFolder}/**", "C:\\Qt\\Qt5.9.1\\5.9.1\\mingw53_32\\include\\**", "C:\\Qt\\Qt5.9.1\\Tools\\mingw530_32\\lib\\gcc\\i686-w64-mingw32\\5.3.0\\include\\**", "C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\8.1.0\\include\\c++\bits", "D:\\QT\\OpenGLDemoCode\\Chap03\\build-Sampl_3_3Exercise-Desktop_Qt_5_9_1_MinGW_32bit-Debug\\**" ], "defines": [ "_DEBUG", "UNICODE", "_UNICODE" ], "cStandard": "c17", "cppStandard": "c++17", "intelliSenseMode": "windows-msvc-x64" } ], "version": 4 } ​ 智能提示如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/166b2e91cb3c9dbb09fdb4109e82adaa/" rel="bookmark">
			【Docker】docker启动nacos,Client not connected,current statusSTARTING
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Client not connected,current status:STARTING
楼主nacos的版本是2.0.3，之前安装nacos是在window上安装，这一次是想用docker安装nacos,然后微服务项目注册进去，但是在启动的过程中报错，提示Client not connected,current status:STARTING,这是因为2.X之后加了一个grpc的远程通信端口，所以在你的docker run 原命令之上再加一个 9848的端口进行映射就可以了。
楼主的原命令大致是以下这样
docker run --name docker-quick -e MODE=standalone -p 8848:8848 -d nacos/nacos-server:v2.0.3 现在改为
docker run --name docker-quick -e MODE=standalone -p 8848:8848 -p 9848:9848 -d nacos/nacos-server:v2.0.3 解决了的话，记得给楼主点个赞哟。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1982034c766e0f5f2f9597961e5a4d2d/" rel="bookmark">
			Spring Boot 里面引入hive-jdbc包，依赖冲突，tomcat启动不了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SpringBoot 版本不管多少， 只要引入了hive-jdbc， 他指定会让你jar包冲突， 因为不是内嵌tomcat问题，就是和tomcat jar包冲突
遇到了大坑，所以在这里记录下，让各位不要遇到这种问题了
这次使用tomcat进行启动的时候，有遇到了错误
tomcat 作为容器进行启动的时候爆出的错误
上面这个错误tomcat8.0启动会报这个错误
tomcat8.5会报这个错误
Caused by: java.lang.StackOverflowError at org.apache.logging.log4j.spi.Logg
就是因为引入了这个jar包
org.apache.hive hive-jdbc 3.1.1 这个Hive-jdbc的jar包中，引入了很多的jar包，所以要是冲突了需要把个别的冲突jar包进行排除掉 &lt;dependency&gt; &lt;groupId&gt;org.apache.hive&lt;/groupId&gt; &lt;artifactId&gt;hive-jdbc&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.eclipse.jetty.orbit&lt;/groupId&gt; &lt;artifactId&gt;*&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.eclipse.jetty.aggregate&lt;/groupId&gt; &lt;artifactId&gt;*&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;tomcat&lt;/groupId&gt; &lt;artifactId&gt;*&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;*&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 以上之后重新打包，tomcat启动成功！
=2019年5月8日08:48:04更新=
最后再说一句：如果你只需要hive-jdbc这个jar包
请这样写
org.apache.hive hive-jdbc 3.1.1 * * 排除所有其他无关jar包 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92e3ea8496d5b106064df5c09f66c0eb/" rel="bookmark">
			远坂凛壁纸
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03ef5ee88f3f0bbc66765eee39a6e566/" rel="bookmark">
			python数组和字符串之间的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python数组和字符串之间的转换 字符串转数组
str = '1,2,3'
arr = str.split(',')
数组转字符串
arr = ['a','b']
str = ''.join(arr)
arr = [1,2,3]
str = ''.join(str(i) for i in b)
2. 解决方案
2.1 分割字符串（仅含有字母或数字）
import re string1 = "asd33fghjk44lqwert5yuiop" st1 = re.findall(r'\w{5}', string1) print(st1) #['asd33', 'fghjk', '44lqw', 'ert5y'] 输出如上，且最后不足5位的（无法匹配到5个位点），直接舍弃。
2.2 分割字符串（包含任意字符）
string2 = "as_d33er==tyui+5+op" st2 = re.findall(r'.{5}', string2) print(st2) # ['as_d3', '3er==', 'tyui+'] 输出如上，且最后不足5位的，直接舍弃。
2.3 正则匹配相关库介绍
这里使用了re模块的findall函数：
re ：这个模块提供了正则表达式匹配操作，正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。re.findall：findall(pattern, string, flags=0)，返回string中所有与pattern相匹配的全部字串，返回形式为数组（更多用法参见该文档）。 完结撒花🎉！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/113833bc3eb445b0da7fd023b1646afa/" rel="bookmark">
			linux下基于vscode cmake调试动态库和静态库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 创建工程目录结构 首先创建工程文件（文件名mymath），VScode打开，进行目录结构创建。工程目录结构如下：
.vscode是存放task.json和launch.json编译调试的文件夹。task.json和launch.json是自动生成的，但是需要根据自己的工程进行修改，后面会具体介绍。
bin是存放最终可执行文件的文件夹；
build是工程编译时生成的一些文件，有点类似于VS中的Debug；
include是工程头文件；
lib是存放生成的动态库和静态库（.a/.so）文件夹；
myadd是动态库库工程；
mymain是主工程；
mysub是静态库库工程；
根目录下的CMakeLists.txt是起到加载子目录，然后编译调试的功能。
2 代码和文件的具体实现
2.1 动态库myadd
头文件myadd.h
源文件myadd.cpp
CMakeLists.txt文件
2.2 静态库mysub
头文件mysub.h
源文件mysub.cpp
CMakeLists.txt文件
2.3 主工程mymain
头文件mymain.cpp
CMakeLists.txt文件
2.4 根目录下的CMakeLists.txt
3 编译和调试 3.1 编译
1、按住ctrl+shift+p，打开命令命令面板，输入CMake: Configure，配置CMake。
2、选择GCC7.5.0 xxxxx选项
3、配置完成后，在最下方会出现一条状态栏。先后执行Build和 run，输出结果。
3.2 调试
工程调试需要配置json文件，task.json 编译，launch.json调试。 配置c_cpp_properties.json文件 按住ctrl+shift+p，打开命令命令面板，输入CMake: Configure，配置CMake。
2.配置任务tasks.json文件
按住ctrl+shift+p，打开命令命令面板，输入Tasks: Configure Default Build Task，进行配置。
3. 配置launch.json文件
按下F5进行launch.json文件配置。
4. 最后按下ctrl+F5即可打断点进行调试。
单步运行就可以进入到库工程中，进行调用库的调试。
3.3 结果
当调试完成后，在lib文件夹下会生成动态库和静态库文件（.so/.a），在bin下生成可执行文件exe。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/511a273916babe868280809a82fac57a/" rel="bookmark">
			VirtualBox启动报错 E_FAIL (0x80004005) SessionMachine
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题描述
解决方法
问题描述 很无语，启动就报错，也不写具体原因。但是每次卸载重装virtualbox后的第一次启动是成功的，只有就又报错。0x80004005报错的类别很多， 本文指的是SessionMachine，长这样：
网上找到一个说法是，在最新的测试版中修复了该问题：
原贴链接：#20574 (VBoxManage 'start --type headless' cannot be correctly closed by 'controlvm acpipowerbutton') – Oracle VM VirtualBoxhttps://www.virtualbox.org/ticket/20574
测试版下载链接：
Testbuilds – Oracle VM VirtualBoxhttps://www.virtualbox.org/wiki/Testbuilds
至少我装完，直接啥都不能用了，我是真的会谢。。。
解决方法 初步分析是安装镜像系统时的virtualbox版本和后来新装的virtualbox版本之间有点不兼容，因为新装的镜像系统时可以正常启动的。
1、可以尝试使用“管理员身份”运行virtualbox，再打开虚拟机。
2、可以尝试先“导出虚拟机”，然后再“导入虚拟机”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04c745347f224975138f00ee5acabc90/" rel="bookmark">
			用C语言编写程序，给出年、月、日，计算该日是该年的第几天。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.用C语言编写程序，给出年、月、日，计算该日是该年的第几天。 #include &lt;stdio.h&gt; //给出年、月、日，计算该日是该年的第几天 int day(int l,int m,int n); int leap(int year); int main() { int year,m,n,sum; printf("请输入年月日:\n"); scanf("%d %d %d",&amp;year,&amp;m,&amp;n); sum=day(year,m,n); printf("%d年%d月%d日是第%d天",year,m,n,sum); return 0; } int day(int l,int m,int n) //判断天数 { int a[12]={31,29,31,30,31,30,31,31,30,31,30,31}; int b[12]={31,28,31,30,31,30,31,31,30,31,30,31}; int i,sum; if(leap(1)) //判断 { for(i=0;i&lt;m;i++) sum+=a[i]; } else { for(i=0;i&lt;m;i++) sum+=b[i]; } sum+=n; return sum; } int leap(int year) //判断闰年 { if(year%4==0 &amp;&amp; year%100!=0 || year%400 == 0) return 1; else return 0; } 运行结果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9add0c4dec88c76a4fc51a16d09896bc/" rel="bookmark">
			java堆、栈、方法区里面都有些啥（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内存管理：由JVM管理 堆：
存储的是new出来的对象(包括实例变量、数组的元素)
垃圾：没有任何引用所指向的对象
垃圾回收器(GC)不定时到堆中清扫垃圾，回收过程是透明的(看不到的)，并不一定一发现垃圾就立刻回收，通过调用System.gc()建议虚拟机尽快调度GC来回收
实例变量的生命周期：
在创建时对象时存储在堆中，对象被回收时一并被回收
内存泄漏：不再使用的对象还没有被及时的回收，严重的泄漏会导致系统的崩溃
建议：不再使用的对象应及时将引用设置为null
栈：
存储正在调用的方法中的局部变量(包括方法的参数)
调用方法时会在栈中为该方法分配一块对应的栈帧，栈帧中存储局部变量(包括方法的参数)，方法调用结束时，栈帧被自动清除，局部变量一并被清除
局部变量的生命周期：
调用方法时存储在栈中，方法调用结束时与栈帧一并被清除
方法区：
存储.class字节码文件(包括静态变量、所有方法)
方法只有一份，通过this来区分具体的调用对象
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/137/">«</a>
	<span class="pagination__item pagination__item--current">138/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/139/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>