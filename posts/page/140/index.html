<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/933d345dd411fe5707da3ad0588e4be9/" rel="bookmark">
			java培训4种Map遍历 key-value 的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		四种方法
先用keySet()取出所有key值，再取出对应value——增强for循环遍历先用keySet()取出所有key值，再取出对应value——使用迭代器遍历通过entrySet来获取key-value——增强for循环遍历通过entrySet来获取key-value——使用迭代器遍历 Map是java中的接口，Map.Entry是Map的一个内部接口。Map提供了一些常用方法，如keySet()、entrySet()等方法，keySet()方法返回值是Map中key值的Set集合；entrySet()的返回值也是返回一个Set集合，此集合的类型为Map.Entry&lt;K, V&gt;_java培训。
Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry&lt;K,V&gt;。它表示Map中的一个实体（一个key-value对）。接口中有getKey(),getValue方法。
1、构造HashMap，给hashMap添加元素
HashMap hashMap = new HashMap();
hashMap.put("三国演义","罗贯中");
hashMap.put("水浒传","施耐庵");
hashMap.put("西游记","吴承恩");
hashMap.put("红楼梦","曹雪芹");
2、 方法一：先用keySet()取出所有key值，再取出对应value——使用迭代器遍历
2.1 代码
/*1、先用keySet()取出所有key值，再取出对应value——增强for循环遍历*/
System.out.println("====1、先用keySet()取出所有key值，再取出对应value——增强for循环遍历====");
Set keyset = hashMap.keySet();
for(Object key:keyset){
System.out.println(key+"-"+hashMap.get(key));
}
2.2 运行结果
3、 方法二：先取出所有的key，再通过key取出对应的value——使用迭代器遍历
3.1 代码
/*2、先用keySet()取出所有key值，再取出对应value——使用迭代器遍历*/
System.out.println("====2、先用keySet()取出所有key值，再取出对应value——使用迭代器遍历====");
Iterator iterator = keyset.iterator();
while(iterator.hasNext()){
Object key = iterator.next();
System.out.println(key+"-"+hashMap.get(key));
}
3.2 运行结果
4、 方法三：通过entrySet()获得key-value值——增强for循环遍历
4.1 代码
/*3、通过entrySet()获得key-value值——增强for循环遍历*/
System.out.println("====3、通过entrySet()获得key-value值——增强for循环遍历====");
Set set = hashMap.entrySet();
for(Object key:set){
Map.Entry entry = (Map.Entry) key;
System.out.println(entry.getKey()+"-"+entry.getValue());
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/933d345dd411fe5707da3ad0588e4be9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22df739d1087781bda13b4a978187a76/" rel="bookmark">
			不用工具，如何快速计算文件的MD5？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络安全现在是信息化系统中的必备要素。大家在各种软件下载站上下载的文件，到底有没有被植入木马，是否安全，你心里有底吗？植入木马的一种常用手段，就是黑客先拿下软件下载站点，甚至自己搭建一个站点，然后等你下载……。
恶意篡改文件下载网站导致的网络安全事件已经屡见不鲜。2019年，国内某知名的PHP网站环境程序集成包“phpstudy”就遭到黑客恶意篡改，其中Windows版本自带的php_xmlrpc.dll模块被植入后门。攻击者在请求中构造特定字符串，可实现远程命令执行控制服务器。
出于安全考虑，越来越多的文件下载网站都利用公示md5校验值的方式来校验一个文件的数据完整性，那么我们在下载网站文件后如何快速计算此文件的md5值呢？再从网上下一个MD5校验工具？好像又有点不放心啊，谁来保证这个MD5校验工具的安全性？下面我介绍四种快速计算文件md5值的方法，供大家参考。
问题：
计算互联网下载的文件，校验文件md5与官网公示md5是否一致，防止文件被篡改，确保数据的完整性，以免造成不必要的损失。
方法一：Windows环境下计算文件md5
命令：certutil -hashfile 【filename】 MD5，这个是windows自带的命令，非常好用：
MD5快速计算出来了。
方法二：Linux环境下计算文件md5
Linux的md5sum命令便用于生成和校验文件的md5值，需要注意的是，md5sum检验的是文件内容，而不是文件名。
md5sum命令执行方法：md5sum 【filename】，下面在md5sum的命令帮助，直接敲就行了。
-b, --binary 以二进制模式读取 -c, --check 从文件中读取MD5 的校验值并予以检查 --tag create a BSD-style checksum -t, --text 以纯文本模式读取(默认) Note: There is no difference between binary and text mode option on GNU system. The following four options are useful only when verifying checksums: --quiet don't print OK for each successfully verified file --status don't output anything, status code shows success --strict exit non-zero for improperly formatted checksum lines -w, --warn warn about improperly formatted checksum lines --help 显示此帮助信息并退出 --version 显示版本信息并退出 方法三：在Mac环境下计算文件md5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22df739d1087781bda13b4a978187a76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b9da9b1694221f8700fb2cb4d3410c5/" rel="bookmark">
			g1和cms介绍(适合面试)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CMS垃圾回收器:
CMS是作用于老年代的并发垃圾回收器,使用标记清除算法,工作流程是:初始标记,并发标记,再次标记,并发清除
优点
耗时最长的并发标记和并发清除阶段gc线程和用户线程是并发执行的,因此其STW时间短,适合对延迟有要求的任务 缺点:
CMS在老年代使用的是标记清除算法,会产生大量内存碎片GC线程与用户线程并发执行,二者会抢占cpu,并且会产生浮动垃圾 初始标记阶段会发生短暂的stw,用于标记GCRoot对象能够直接到达的对象
并发标记阶段gc线程根据GCRoot对象标记可到到的存活对象,应用程序可以和gc线程并行进行,不需要stw
再次标记阶段会进行stw,目的是为了修正因为并发标记阶段应用程序和gc线程并发执行产生的浮动垃圾
并发清除阶段gc线程清除垃圾对象,gc线程和应用线程并发执行因此会产生浮动垃圾,在下一次gc清理该浮动垃圾
G1垃圾回收器:
G1垃圾回收器是一款可以同时管理新生代和老年代,在老年代使用标记整理算法,其最大的特点是将内存划分为多个大小相等region,每个region都可以作为伊甸区,survivor区,老年代
优点:
老年代使用标记整理算法,不会产生内存碎片使用region,不会出现新生代或者老年代分配空间过大而造成浪费每次只选择垃圾对象多的region,而不是整个堆,大幅减少了STW时间(但region与region之间是有依赖关系的,g1维护了一个Remembered Set记忆集记录了region的依赖关系,只需要扫描关联的region,而不是整个堆)用于可预测停顿的模型,可以指定STW时间(也就是可预测停顿),比如在一小时内垃圾回收导致的"stop the world"时间不超过一分钟。 G1垃圾回收过程主要包含三个阶段,
当伊甸区慢时,年轻代使用标记复制算法进行回收当堆空间的内存占用达到阈值时,老年代使用标记整理算法进行回收,前三个过程和cms类似,都为初始标记,并发标记,并发清除,区别在于最终清除阶段,CMS是并发的,而G1会进行STW,不是并发的当老年代占比达到阈值,触发混合回收,为了防止堆内存耗尽,会回收所有年轻代和部分老年代 CMS和G1比较:
G1和CMS都分为4个阶段,前三个阶段基本相同都为初始标记,并发标记,再次标记,区别在于最后清除阶段CMS是并发的,G1不是并发的,因此CMS最终会产生浮动垃圾,只能等待下次gc才能清除G1可以管理整个堆,而CMS只能作用于老年代,并且CMS在老年代使用的是标记清除算法,会产生内存碎片,而G1使用标记整理算法,不会产生内存碎片G1相比于CMS最大的区别是G1将内存划分为大小相等的Region,可以选择垃圾对象多的Region而不是整个堆从而减少STW,同时使用Region可以更精确控制收集,我们可以手动明确一个垃圾回收的最大时间 补充:
因为耗时最长的并发标记和并发清除gc线程和应用线程都是并发执行的,所以总体来看cms收集器的gc线程和应用线程是并发执行的
G1之所以能做到回收时间可控，主要是得益于Region这个结构。G1会记录每个Region里的对象有多少是垃圾对象，如果要对某个Region进行垃圾回收，他会计算出对该Region回收的时间，可以回收多少垃圾。
实际上除了CMS收集器，其他都不存在只针对老年代的收集。
但是每个region之间是有互相引用的依赖关系的！这导致在MinorGC的时候会同时对老年代进行扫描（甚至是整个堆扫描），那就会导致MinorGC的效率低下，时间变长！
解决方法是:维护一个Remebered Set集合来存放各个Region之间的引用关系！当进行GC Roots Tracing 的时候就可以只扫描set里的关联region！而不用全堆扫描啦！！！ 在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b881f3be695d94939c5554b686902668/" rel="bookmark">
			perforce(P4)常用命令(命令行)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序号
命令
说明
1p4 -c &lt;clientName&gt; sync &lt;filename&gt;全部同步， 注意需要指定客户端名称 如 -c test, 后面可以 具体文件名称2p4 edit filename修改文件3p4 client &lt;cliName&gt;在某个目录下执行，创建一个client，注意修改 里面的View,对应的是要下载server里面的代码4 export P4CLIENT=autoconfig
export P4PASSWD=123456
export P4USER=test
export P4PORT=localhost:1666
可以指定默认的client
没设置可能会报以下 错误：
Perforce client error:
SSL connect to ssl:1666 failed (Connection reset by peer).
Remove SSL protocol prefix from P4PORT or fix the TLS settings.
5p4 changes查看变更6p4 client -o -S "//streamsDepot/mainline" "test123" | p4 client -i创建client， 并修改对应关系7p4 client -d test123删除clientp4 client -o -S "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b881f3be695d94939c5554b686902668/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7392bad9c02eed08628eea090590c120/" rel="bookmark">
			web前端培训如何使用CSS自定义属性实现骨架屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目要不要加载loading状态通常是在项目完成后才考虑的事情，当然，有时候直接就不考虑了。
开发人员的职责不只是提高性能，同时优化网络差时，请求接口缓慢导致的页面的慢渲染也是非常重要的。
速度的错觉
随着我们对移动体验的期望的变化，我们对性能的理解也在变化。我们期望，无论当前的网络如何，web页面都能像原生应用程序一样顺滑，一样快速响应。
骨架屏的出现。这个想法使得用户更有耐心，因为他们知道正在发生什么，并且在内容实际存在之前能够预测内容，那么他们会认为系统更快。这在很大程度上保持了用户等待的热情。
骨架屏
这个概念可能包括显示文本，图像或其他内容元。可以在网上可以看到骨架屏的使用已经非常广泛，Facebook，Google，Slack等公司都在使用。
每当有人从服务器请求新内容时，您可以立即开始显示骨架，同时在后台加载数据。内容准备就绪后，只需将骨架换成实际卡即可。
您可以使用图像来显示骨架，但这会引入额外的请求和数据开销。我们本身已经在这里加载了东西，所以还要去等待另一个图像先加载，这可不是一个好主意。另外图片不是响应式的，如果我们决定调整卡片的样式，我们将不得不更改骨架图像，以便它们再次匹配_前端培训。
一个更好的解决方案是只用 CSS 创建骨架屏。没有额外的请求，最小的开销。而且以后修改更加的方便快捷。
CSS 中绘制骨架
首先，我们需要绘制构成卡片骨架的基本形状。
我们可以通过向background-image属性添加不同的渐变来做到这一点。默认情况下，线性渐变从上到下运行，具有不同的颜色过渡。如果我们只定义一个色标，其余的保持透明，我们就可以绘制形状。
请记住，多个背景图像在这里堆叠在一起，因此顺序很重要。最后一个渐变定义将展示在后面，最先定义的展示在前面。
.skeleton {
background-repeat: no-repeat;
background-image:
/* layer 2: avatar */
/* white circle with 16px radius */
radial-gradient(circle 16px, white 99%, transparent 0),
/* layer 1: title */
/* white rectangle with 40px height */
linear-gradient(white 40px, transparent 0),
/* layer 0: card bg */
/* gray rectangle that covers whole element */
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7392bad9c02eed08628eea090590c120/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb781a9c6f297fe38aad79501a45d840/" rel="bookmark">
			【毕业设计】python opencv 深度学习 指纹识别算法实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 前言2 指纹识别方式2.1 电容式指纹识别2.2 光学式指纹识别 3 指纹识别算法实现3.1 指纹识别算法流程3.2 指纹图像预处理3.3 指纹图像目标提取3.4 指纹图像增强3.5 指纹特征提取3.6 指纹识别结果 4 整体效果5 最后 1 前言 🔥 这两年开始毕业设计和毕业答辩的要求和难度不断提升，传统的毕设题目缺少创新和亮点，往往达不到毕业答辩的要求，这两年不断有学弟学妹告诉学长自己做的项目系统达不到老师的要求。
为了大家能够顺利以及最少的精力通过毕设，学长分享优质毕业设计项目，今天要分享的是
🚩 python opencv 深度学习 指纹识别算法实现
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：4分创新点：4分 🧿 选题指导, 项目分享：
https://gitee.com/dancheng-senior/project-sharing-1/blob/master/%E6%AF%95%E8%AE%BE%E6%8C%87%E5%AF%BC/README.md
2 指纹识别方式 目前市面上有两种指纹识别，分别是光学式和电容式指纹识别。
2.1 电容式指纹识别 电容式指纹识别要比光学式的复杂得多，其原理是将压力感测、电容感测、热感测等感测器整合于一块芯片中，当指纹按压芯片表面时，内部电容感测器会根据指纹波峰与波谷而产生的电荷差（或是温差），形成指纹影像，再通过与算法内部的指纹库进行匹配，从而完成指纹识别。
电容式指纹识别技术较为复杂，对技术研发和积累有较高要求，并且涉及大量专利，算法得实现也相对困难，所以目前全球只有少数公司能在这方面提供领先的技术产品。
2.2 光学式指纹识别 然后是光学式指纹识别，大家常见的指纹考勤机就是光学式指纹识别。
这类光学式指纹识别主要包括4个方面功能
1.指纹模块负责采集指纹图像。2.数字信号处理器主要把采集到的指纹图像转化为数字信号。3.微控制器是整个系统的控制单元，在这里将进行指纹的验证以及输出指令。4.液晶显示器将输出指纹验证结果。 当我们把手指放在指纹考勤机上时，通过镜面反射原理，指纹模块就会采集指纹图像
接着指纹图像就会被数字信号处理器转换成数字信号
然后通过微控制器将数字信号与指纹库里的指纹进行匹配，匹配结果将通过液晶显示器显示出来。这就是光学式指纹识别的工作原理。
电容式与光学式指纹识别主要在指纹的采集方式上拥有较大差异，而在指纹的验证过程中则基本类似。然而因为电容式指纹识别拥有体积小、适用性广的优点，已经有越来越多的设备采用电容式指纹识别，未来的主流将是电容式指纹识别。
3 指纹识别算法实现 3.1 指纹识别算法流程 3.2 指纹图像预处理 1.图像归一化2.图像分割3.图像二值化4.细化 几个步骤 当然有一些算法为了追求极致，中间还利用了增强、多重滤波等方式，但最根本的目的都是为了在细化之后保留指纹信息并且方便后续处理。
预处理之后是特征点的提取，也就是找到指纹图像当中有价值，具有唯一性和不变性的信息。主要特征点有端点、分叉点几类，在提取部分除了简单的遍历检索确认之外，还有比较重要的一步是伪特征点的去除，主要是针对图像不清晰、不完整导致的断点和边缘端点等。
最后一步是特征点的匹配，将指纹库中的指纹信息与提取的目标图像特征点进行对比。主流算法是以指纹中心点为依据，根据特征点所在的角度及距离，确认其所在位置，根据匹配度计算是否是同一手指的指纹。
3.3 指纹图像目标提取 指纹图像目标提取主要是将指纹图片中提取出来，也叫做指纹图像分割。
图片的前景通过观察可知是由条状或者圆形的一些组成，而底图其他部分只是一个均匀的底色而已。
我们使用非常简单的手段，基于局部梯度就可以很容易实现我们的目标。
方差梯度法提取指纹:
指纹图像通常由前景区域（包含有指纹的脊线和谷线）和背景区域这两部分组成。一般来说，在指纹图像的前景区域中，指纹的脊线和谷线的灰度差是较大的，因而其灰度统计特性局部灰度方差很大；而在指纹图像的背景区域中，两者的方差是很小的。基于这一特性，可以利用指纹图像的局部方差来进行分割。因此，这种方法也被称为方差梯度法。
的灰度平均值 M和方差 Var计算方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb781a9c6f297fe38aad79501a45d840/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdc0dbdf406fb2a807e3ebc690d83c42/" rel="bookmark">
			运放 &#43; MOS管构成的恒流电路分析及实用环境器件参数选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运放 + MOS管构成的恒流电路分析 先看下下面的电路，想知道这个电路的原理，可以参考: link
这里使用的
运放是 LM358
mos管是2N6755 (Nmos)
想让其能够输出 1A 的恒流 （当然恒流限定了所带负载范围，下面说）
设计恒定电流为： I= V2/R3 = 2.5/2.5 = 1 A
R2为负载，运放供电电源为15V
先来看下这个电路的带负载能力，见下图：
可以看出，要想让其恒定输出1A电流，负载则不能大于20Ω，即R2不能大于20Ω，因为受到电源V3 （24V）的限制。想让带负载能力增强，增大电源V3也是一种办法。
正常工作时，电源V3的电压，一部分落在负载R2上，一部分落在电阻R3上，剩下的全都落在MOS管的上
这里为了使电路能够正常输出1A恒定电流，将R2修改为 15Ω，如下图所示:
VM1测量 MOS电压 ：6.49V
VM2测量 R2电压：15.01V
VM3测量 R3电压：2.5V
AM1测量 干路电流：1A
可知：6.49+ 15.01+2.5 = 24 V
说明
UGS = 3.66V
手册参数
实用环境器件参数选择 承接上文的参数及计算结果现在来计算下各器件功率：
R2 : P = 15.01 *1 = 15 W
电阻功率很大，发热厉害，当然这里用的是电阻，实际使用可能是别的非电阻类的负载。是否适用，根据负载额定功率而定。
R3: P = 2.5*1 = 2.5W
功率适中，选型需要选择功率电路，首选水泥电阻，功率保留50%余量
MOS: P = 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdc0dbdf406fb2a807e3ebc690d83c42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd2238923996fe0f7915aa4b7486dc9a/" rel="bookmark">
			KoaJS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 koa致力于成为一个更小、更富有表现力、更健壮的、更轻量的web开发框架。因为它所有功能都通过插件实现，这种插拔式的架构设计模式，很符合unix哲学。
一个简单的服务，如下：
const Koa = require('koa') let app = new Koa() app.use((ctx, next) =&gt; { console.log(ctx) }) app.listen(4000) 复制代码 然后在浏览器端打开http://127.0.0.1:4000即可访问
若没有指定返回body，koa默认处理成了Not Found
本文内容：
中间件原理（结合代码） 原理中间件实现思路理解上述洋葱模型阅读源码 app.listen()ctx挂载内容 context.jsrequest.jsresponse.js挂载ctxnext构建的洋葱模型 app.use((ctx, next) =&lt; { ... })中间件含异步代码如何保证正确执行返回报文解决多次调用next导致混乱问题基于事件驱动去处理异常koa2, koa1 和 express区别 一、中间件原理（结合代码） 原理 中间件执行就像穿越洋葱一样，最早use的中间件，就放在最外层。处理顺序横穿洋葱，从左到右，左边接收一个request，右边输出返回response；一般的中间件都会执行两次，调用next之前为第一次，调用next时把控制传递给下游的下一个中间件。当下游不再有中间件或者没有执行next函数时，就将依次恢复上游中间件的行为，让上游中间件执行next之后的代码； 如下代码：
const Koa = require('koa') const app = new Koa() app.use((ctx, next) =&gt; { console.log(1) next() console.log(3) }) app.use((ctx) =&gt; { console.log(2) }) app.listen(9001) # 执行结果是1=&gt;2=&gt;3 复制代码 中间件实现思路 # 注意其中的compose函数，这个函数是实现中间件洋葱模型的关键 // 场景模拟 // 异步 promise 模拟 const delay = async () =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd2238923996fe0f7915aa4b7486dc9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bf2b49f5ab5d9d7efa276b4a3bc39c7/" rel="bookmark">
			error2001/2019: 无法解析的外部符号_imp_xxxxxxx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理......
当我的项目有很多个依赖项，而且这些依赖项的lib都需要我自己编译；
在编译依赖.lib时，我没有注意其他，只是一通make,当运行我自己的项目时，却遇到了“无法解析的外部符号_imp_xxxxxxxxx”问题；
我的解决方法：
1.在编译.lib时，将所有的.lib库统一编译平台，x86/x64_release/debug，并将项目也和lib统一；
2.统一字符集，都将其修改为“使用多字节字符集”，当然你也可以选择其他，重要的是要统一；
3.运行库要统一（MT）,也可以选择其他；
重要的是，以上三种都要一样，包括.lib和项目；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/777fab818a2a56ad0cd99f0829c4887b/" rel="bookmark">
			Hash值生成java算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java加密算法hash值生成，了解到的三种方式
1.MD：信息摘要算法 java代码Utils：
public static String MD5Encode(String origin){ try{ MessageDigest md = MessageDigest.getInstance("MD5"); // return Hex.encodeHexString(md.digest(origin.getBytes(DE_CHARSET))); return Base64.encodeBase64String(md.digest(origin.getBytes(DE_CHARSET))); }catch(NoSuchAlgorithmException ex){ ex.printStackTrace(); } return null; } 2.SHA：安全散列算法 java代码Utils:
import java.math.BigInteger; import java.security.MessageDigest; public class SHAUtils { private static final String KEY_SHA = "SHA"; public static String encodeSHA(String content){ byte[] inputData = content.getBytes(); try { MessageDigest messageDigest = MessageDigest.getInstance(KEY_SHA); messageDigest.update(inputData); BigInteger sha = new BigInteger(messageDigest.digest()); return sha.toString(32); } catch (Exception e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/777fab818a2a56ad0cd99f0829c4887b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cb81675926bdc8065948e03621b7141/" rel="bookmark">
			基于STM32CubeIDE的LittleVGL开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LVGL版本号release-v8.1
LVGL版本号release-v8.1
开发环境STM32CubeIDE
仿真环境Code::Block
开发工具包包含lv_demos、lv_drivers、lvgl
本文包含基于STM32CubeIDE的LittleVGL的开发环境搭建的所需资源下载连接、开发环境搭建步骤。
本文仅包含环境搭建，不包括应用开发。
如有问题，欢迎讨论。
基于STM32CubeIDE的LittleVGL的开发环境搭建
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f809c76a781e730e49300a4c678bd865/" rel="bookmark">
			vscode报错：无法将“node.exe”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.检查环境变量
用户环境变量已配置：
系统环境变量已配置node安装目录：
2.如果以上环境变量都正确，关闭所有vscode，重新打开一个vscode，执行yarn即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eea0db490259c2f35b794c120571c941/" rel="bookmark">
			【高阶系列二】数据清洗和准备——字符串操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串处理是数据清洗中常见的操作。在python中有两种方式进行字符串操作，一种是内置的字符串方法，一种是正则表达式工具——re模块。
目录
一、Python内置的字符串方法
二、正则表达式（Regular Expression）
2.1 普通字符
2.2 元字符（特殊字符）
2.2.1 单个字符匹配
2.2.2 预定义字符集
2.2.3 字符次数匹配——量词
2.2.4 边界匹配
2.2.5 逻辑与分组
2.2.6 特殊构造
2.2.7 贪婪模式与非贪婪模式
三、python正则表达式工具-re模块
3.1 Re模块对象属性
3.1.1 re模块对象
3.1.2 模式对象的方法和属性
3.1.3 匹配对象的方法和属性
3.1.4 实例
3.2 re模块的函数
四、向量化字符串函数
4.1 应用背景
4.2 pd.Series.str
4.3 Series.str函数
4.3.1 大小写转换
4.3.2 字符串填充
4.3.3. 字符串编码
4.3.4 字符串查找
4.3.5 解决判断问题
4.3.6 字符串修剪
4.3.7 分割字符串
4.3.8 字符串替换
4.3.9 统计字符函数
一、Python内置的字符串方法 方法说明示例string.count(sub)返回子串sub在字符串string中的出现次数，其中，string\sub均为字符串str string='a,bo,guido'
print(type(string),string.count('o'))
[out]: &lt;class 'str'&gt; 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eea0db490259c2f35b794c120571c941/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cd511f5aa46d563dd332267f7f91804/" rel="bookmark">
			如何在PD虚拟机中开启系统的嵌套虚拟化功能？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PD虚拟机是一款可以在Mac电脑中设置Windows系统的应用软件。在ParallelsDesktop虚拟机中如何开启系统的嵌套虚拟化功能？下面我们分享一下具体的操作步骤。
1、打开Mac电脑中ParallelsDesktop虚拟机，
2、选择虚拟系统的“设置”选项，
3、在弹出的窗口中，点击“硬件”标签；
4、进入硬件的界面后，点击左边列表里的“CPU与内存”；
5、然后点击“高级设置”，再勾选上“启用nested虚拟化”，
6、最后，在弹出的提示窗口中，点击“是”按钮即可完成。
以上就是小编带来的PD虚拟机教程：如何在PD虚拟机中开启系统的嵌套虚拟化功能，还有哪些关于PD虚拟机的操作问题，欢迎来交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50e6814311ffd4f56288c84ae8a42fd7/" rel="bookmark">
			大数据培训如何优化HiveSQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive作为大数据平台举足轻重的框架，以其稳定性和简单易用性也成为当前构建企业级数据仓库时使用最多的框架之一。
但是如果我们只局限于会使用Hive，而不考虑性能问题，就难搭建出一个完美的数仓，所以Hive性能调优是我们大数据从业者必须掌握的技能。本文将给大家讲解Hive性能调优的一些方法及技巧。
Hive性能调优的方式
为什么都说性能优化这项工作是比较难的，因为一项技术的优化，必然是一项综合性的工作，它是多门技术的结合。我们如果只局限于一种技术，那么肯定做不好优化的。
下面将从多个完全不同的角度来介绍Hive优化的多样性，我们先来一起感受下。
1. SQL语句优化
SQL语句优化涉及到的内容太多，因篇幅有限，不能一一介绍到，所以就拿几个典型举例，让大家学到这种思想，以后遇到类似调优问题可以往这几个方面多思考下。
1. union all
insert into table stu partition(tp)
select s_age,max(s_birth) stat,'max' tp
from stu_ori
group by s_age
union all
insert into table stu partition(tp)
select s_age,min(s_birth) stat,'min' tp
from stu_ori
group by s_age;
我们简单分析上面的SQl语句，就是将每个年龄的最大和最小的生日获取出来放到同一张表中，union all 前后的两个语句都是对同一张表按照s_age进行分组，然后分别取最大值和最小值。对同一张表相同的字段进行两次分组，这造成了极大浪费，我们能不能改造下呢，当然是可以的，为大家介绍一个语法：from ... insert into ... ，这个语法将from前置，作用就是使用一张表，可以进行多次插入操作：
--开启动态分区
set hive.exec.dynamic.partition=true;
set hive.exec.dynamic.partition.mode=nonstrict;
from stu_ori
insert into table stu partition(tp)
select s_age,max(s_birth) stat,'max' tp
group by s_age
insert into table stu partition(tp)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50e6814311ffd4f56288c84ae8a42fd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51fa51c23909cefa15401349f6b5eda8/" rel="bookmark">
			vue 一键点击下载对应图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能会遇到 图片的预览大图和下载功能，此代码为下载图片的功能
//name 为传入的想下载的图片的名称 handleClick (name) { const image = new Image() image.setAttribute('crossOrigin', 'anonymous') image.onload = function () { const canvas = document.createElement('canvas') canvas.width = image.width canvas.height = image.height const context = canvas.getContext('2d') context.drawImage(image, 0, 0, image.width, image.height) const url = canvas.toDataURL('image/png') // 得到图片的base64编码数据 const a = document.createElement('a') // 生成一个a元素 const event = new MouseEvent('click') // 创建一个单击事件 a.download = name || '下载' // 设置图片名称 a.href = url // 将生成的URL设置为a.href属性 a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51fa51c23909cefa15401349f6b5eda8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fc654d9ce457e05913cad8412cbafc8/" rel="bookmark">
			vue 文件里面的.native有波浪线报警问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你同时安装了Vetur插件和ESlint插件，建议禁用Vetur插件后重试一下，听说Vetur插件和ESlint插件同时开启，ESlint插件不会生效哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89f32ab91ad9966e245a1338de005dd7/" rel="bookmark">
			IO流、字节流和字符流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 一、IO流1.1 概念1.2 分类1.3 IO流的父类 二、字节流2.1 概念2.2 OutputStream2.2.1 常用方法2.2.2 FileOutputStream类2.2.2.1 构造方法2.2.2.2 输出字符串到文件2.2.2.3 追加输入字符串2.2.2.4 写出换行 2.3 InputStream2.3.1 常用方法2.3.2 FileInputStrean2.3.2.1 构造方法2.3.2.2 读取文件所有内容并输出至控制台2.3.2.3 文件复制 三、字符流3.1 概念3.2 Writer3.2.1常用方法3.2.2 FileWriter3.2.2.1 构造方法3.2.2.2 读取文档输出控制台并复制 3.3 Reader3.3.1 常用方法3.3.2 FileReader3.3.2.1 构造方法3.3.2.2 读取文本文档内容并输出至控制台 一、IO流 1.1 概念 把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为输入input 和输出output ，即流向内存是输入流，流出内存的输出流。
Java中I/O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出数据。
1.2 分类 根据数据的流向分为：输入流和输出流。
输入流 ：把数据从其他设备上读取到内存中的流。输出流 ：把数据从内存 中写出到其他设备上的流。 格局数据的类型分为：字节流和字符流。
字节流 ：以字节为单位，读写数据的流。字符流 ：以字符为单位，读写数据的流。 1.3 IO流的父类 名称输入流输出流字节流字节输入流InputStream字节输出流OutputStream字符流字符输入流Reader字符输出流Writer 这些类都是抽象类，在实际的开发过程中使用的是相应的子类。
二、字节流 2.1 概念 一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。
2.2 OutputStream java.io.OutputStream 抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。
2.2.1 常用方法 方法名说明public abstract void write(int b)将指定的字节输出流。public void write(byte[] b)将 b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89f32ab91ad9966e245a1338de005dd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d826ad5594ce17b4ee6cf0d6d6af56d/" rel="bookmark">
			ag-gride-vue滚动条调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ::v-deep .ag-layout-normal { overflow-y: overlay; } ::v-deep .ag-theme-alpine-dark:hover .ag-body-horizontal-scroll-viewport { margin-right: -8px; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa706d5a1ba539f0c398ab46b9c4a1c2/" rel="bookmark">
			nohup命令--linux后台运行程序并实时查看输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在启动linux服务器的weblogic时，一般是在bin 目录下面执行nohup ./startWeblogic&amp;
那么它与普通的./startWeblogic有什么区别呢？
先解释nohup这个命令
以下是官方的解释：
nohup 命令
用途：不挂断地运行命令。
语法：nohup Command [ Arg … ] [　&amp; ]
描述：nohup 命令运行由 Command 参数和任何相关的 Arg 参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示”and”的符号）到命令的尾部。
无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。如果标准错误是一个终端，那么把指定的命令写给标准错误的所有输出作为标准输出重定向到相同的文件描述符。
退出状态：该命令返回下列出口值：
126 可以查找但不能调用 Command 参数指定的命令。
127 nohup 命令发生错误或不能查找由 Command 参数指定的命令。
否则，nohup 命令的退出状态是 Command 参数指定命令的退出状态。
nohup命令及其输出文件
nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( n ohang up)。
该命令的一般形式为：nohup command &amp;
使用nohup命令提交作业
如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：
nohup command &gt; myout.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa706d5a1ba539f0c398ab46b9c4a1c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab7bcf76d2606dc8ddd187a5fedd5808/" rel="bookmark">
			css定位&amp;锚点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.定位的作用:控制元素在浏览器中的位置
2.生活中的案例
- 把大象放进冰箱需要几步:打开、放进去、关闭
- 把志强吊在投影仪上听课:绑起来、吊上去、嘲笑他
3.定位需要的条件
- 大象:需要移动位置的对象
- 冰箱:参照物
- 方向:前端方向
4.定位的属性:position 定位、位置
5.定位的属性值
- static 默认值 静态定位
- relative 相对定位
- absolute 绝对定位
- fixed 固定定位
- sticky 粘性定位
相对定位属性的使用
1.属性:position
2.属性值:relative
3.相对定位属性的特点
- 相对定位的参照物是元素初始位置
- 不会脱离文档流,初始布局不会被破坏
4.之前学习的移动元素方法
- margin外边距:需要和父级包含框相接触
- 定位没有方向上的限制
5.作用:为了给绝对定位提供参照物的(工具人)
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div{ width: 200px; height: 200px; background: greenyellow; margin: 0 auto; position: relative; top: 100px; left: 100px } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;文本内容&lt;/div&gt; 文本 &lt;/body&gt; &lt;/html&gt; 效果图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab7bcf76d2606dc8ddd187a5fedd5808/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af9c5597c2538c56ec54a46152ed95e6/" rel="bookmark">
			方法中创建线程池，方法结束后线程池会被垃圾回收吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般的线程池写法是 放在成员变量级别的, 不会是局部变量
在最近的一次job改造中发现一个问题, 前人在方法里创建了线程池, 然后执行业务逻辑
public static void main(String[] args) throws Exception { new xxx().runJob(); System.out.println("end..." + 1); new xxx().runJob(); System.out.println("end..." + 2); } public void runJob(){ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 5, 10L,TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(2000)); // 是否允许核心线程超时 关闭 // threadPoolExecutor.allowCoreThreadTimeOut(true); for (int taskNum = 0; taskNum &lt; 5; taskNum++) { // 提交5个任务 到线程池 threadPoolExecutor.execute(() -&gt; { // 任务的内容是, 5秒内, 每秒打印一次序号 for (int i = 0; i &lt; 5; i++) { try { Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af9c5597c2538c56ec54a46152ed95e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/052bf60ded54b116a9aea455a2eb22c7/" rel="bookmark">
			js-cookie 失效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一般情况，可能不会出现这个失效问题，如果你遇到了这种问题，我的建议是检查一下，开发者工具里 =&gt; Application =&gt; Cookies。 注意：是Cookies哦，不是Local Storage 也不是Session Storage ，不要看错啦！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24332bad552359a9bed23366c0b093c5/" rel="bookmark">
			关于a-modal提示弹窗的经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我负责的是一个支付弹窗页面，类似百度网盘的会员购买界面。我以UI图为参考去除了弹窗右下角的确认和取消按钮。方法在开发文档中有显示：footer=“null”,footer为脚尾文件展示，赋值为空则什么也不显示。
&lt;a-modal v-model="visible" :footer="null"&gt; 由于存在不同套餐的选择情况，所以我是用对div进行分隔，在对弹窗背景颜色进行填充时，我通过网页F12观察得知弹窗默认样式ant-modal-content，可以通过增加div结构来进行样式覆盖，不过此处太麻烦了，所以我选择通过deep方法改变封装过的弹窗默认样式。
::v-deep .ant-modal-content{ background-color: #F5F6FA; height: 410px; } 该支付弹窗拥有点击支付套餐选项改变样式的功能，此处添加了动态样式
:class。设置了原本change样式和点击后呈现的changes样式，isActive初始值为1，当点击到item.id的套餐选项时，会进行判断isAcitive的值是否为点击选项的id值，如果是则进行样式变换。通过点击事件onclick实现。
&lt;div style="cursor: pointer" @click="onClick(item)" :class="isActive == item.id?'changes':'change'"&gt; &lt;div style="font-size: 16px;color: #333333;font-weight: 500"&gt;{{ item.day }}&lt;/div&gt; &lt;div style="color: #C79745;font-size: 24px;font-weight: 600"&gt;{{ item.pay }}&lt;/div&gt; &lt;div style="text-decoration:line-through;color: #999999"&gt;{{ item.pays }}&lt;/div&gt; &lt;/div&gt; data() { return { isActive: 1, }; }, .change { width: 150px; height: 100px; border: 1px; border-radius: 10px; background-color: #FFFFFF; text-align: center; } .changes { width: 150px; height: 100px; border: 1px solid #C79745; border-radius: 10px; background-color: #FFEED0; text-align: center; } 实现复选框点击事件改变文本框内文字和按钮颜色功能：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24332bad552359a9bed23366c0b093c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/648ef9a11a99cb688207197756a330a4/" rel="bookmark">
			echarts图表y轴数据设置等间距分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如图所示，y轴数据分为5等分。
使用的echarts属性为yAxis.min、yAxis.max、yAxis.splitNumber、yAxis.interval。
计算出当前数据的最大值以及最小值，然后用（最大值-最小值）/ 分割段数 计算出y轴的分割间隔。
如果y轴最小值为固定值0，则可直接设置min:0;，因为数据中如果最小值不为0，则minVal不为0，y轴的0刻度线的文本显示的就不是0。如下图，最小值为309：
/** * flowData为数据数组对象 */ // 获取坐标轴刻度最大值 const maxVal = Number(Math.max(...flowData)); // 获取坐标轴刻度最小值 const minVal = Number(Math.min(...flowData)); // 计算坐标轴分割间隔 let interval= (maxVal - minVal) / 5; const options = { yAxis: [ { type: "value", position: "left", min: minVal, // 坐标轴刻度最小值。 max: maxVal, // 坐标轴刻度最大值。 splitNumber: 5, // 坐标轴的分割段数，是一个预估值，实际显示会根据数据稍作调整。 interval: interval, // 强制设置坐标轴分割间隔。 nameTextStyle: { color: "#666", fontSize: 12, lineHeight: 40, }, axisLabel: { color: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/648ef9a11a99cb688207197756a330a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f753e10e96b7d64b71ec3e91ab15a35/" rel="bookmark">
			VSCode 中文乱码设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode中文乱码怎么解决?vscode是一款跨平台源代码编辑器，能够在桌面上运行，并且能够用途windows、macOS以及Linux。但是有不少小伙伴们在使用vscode时，输入输出的却是中文代码，也不知道如何解决，那么今天小编就来告诉大家vscode中文乱码怎么解决，一起来看看吧。
vscode中文乱码怎么解决
1、打开文件出现乱码
方法一、①先“打开文件”，然后点击“首选项”，接着点击“设置”;
②接着在搜索栏中输入Files:Auto Guess Encoding ，将其勾选即可。
方法二、
搜索插件GBKtoUTF8，并将其安装。
方法三、
这是最简单的方法，点击右下角utf8，将其换成GBK.
2、终端输出出现乱码
方法一、
在终端输入 chcp 查看编码 936代表GBK,65001代表utf8,然后输入chcp 65001即可切换。
方法二、
1、依次点击“文件”–“首选项”–“设置”–“用户选项”–“功能”–“终端”–“settings.json”;
2、然后在其中加入以下代码，并点击保存：
"terminal.integrated.fontFamily": "Lucida Console",
"[cpp]": {
"files.encoding": "gbk"
},
"[c]": {
"files.encoding": "gbk"
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea76dc965f9bff4bf96db2f271ce3a27/" rel="bookmark">
			Windows10安装WSL2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、检查 Windows CPU 虚拟化（http://t.csdn.cn/mC1IG）
2、启用适用于 Linux 的 Windows 子系统（http://t.csdn.cn/PyIla）
3、更新 WSL2 的 Linux 内核更新包
wsl下载链接：https://pan.baidu.com/s/1cbmRoJSLssf0iIPDUDvsdw?pwd=1234
下载后直接安装。
4、安装 Linux 分发版
1.打开 Microsoft Store，搜索 Ubuntu 并下载
2.点击启动
END
听说这个启动有可能报错 “0x800706ba” 或 “参考的对象类型不支持尝试的操作” 。
但是我没有，所以我就不负责解决了，CSDN有相关文章。
汪苏泷2就安好啦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdd3236fc7fcd1d2bbfce90b39d4874c/" rel="bookmark">
			mac端addr2line的NDK位置和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人mac上在android NDK里的位置如下，可以写到环境变量里
arm32:
export PATH=${PATH}:/Users/admin/Library/Android/sdk/ndk/21.3.6528147/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin
arm64:
export PATH=${PATH}:/Users/admin/Library/Android/sdk/ndk/21.3.6528147/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin
使用方法：
arm-linux-androideabi-addr2line -C -f -e lib*.so 0003deb4
aarch64-linux-android-addr2line -C -f -e lib*.so 0003deb4
其中，0003deb4为堆栈信息中pc的值，可以定位到具体哪一行崩溃
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec2dcd2753e559a1467c8d4c17c1031d/" rel="bookmark">
			oracle集群概念详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集群术语须知 服务硬件：指提供计算服务的硬件，比如 PC 机、PC 服务器。服务实体：服务实体通常指服务软体和服务硬体。节点（NODE）：运行 Heartbeat 进程的一个独立主机称为节点，节点是 HA 的核心组成部分，每个节点上运行着操作系统和Heartbeat 软件服务。资源（RESOURCE）：资源是一个节点可以控制的实体，当节点发生故障时，这些资源能够被其他节点接管。如： 磁盘分区、文件系统、IP 地址、应用程序服务、共享存储。事件（EVENT）：事件也就是集群中可能发生的事情，例如节点系统故障、网络连通故障、网卡故障和应用程序故障等。这些事件都会导致节点的资源发生转移，HA 的测试也是基于这些事件进行的。 什么是集群 集群（cluster）就是一组计算机，它们作为一个整体向用户提供一组网络资源，这些单个的计算机系统就是集群的节点（node）。集群提供了以下关键的特性。
可扩展性。集群的性能不限于单一的服务实体，新的服务实体可以动态的加入到集群，从而增强集群的性能。高可用性。集群通过服务实体冗余使客户端免于轻易遭遇到“out of service”警告。当一台节点服务器发生故障的时候，这台服务器上所运行的应用程序将在另一节点服务器上被自动接管。消除单点故障对于增强数据可用性、可达性和可靠性是非常重要的。负载均衡。负载均衡能把任务比较均匀的分布到集群环境下的计算和网络资源，以便提高数据吞吐量。错误恢复。如果集群中的某一台服务器由于故障或者维护需要而无法使用，资源和应用程序将转移到可用的集群节点上。这种由于某个节点中的资源不能工作，另一个可用节点中的资源能够透明的接管并继续完成任务的过程叫做错误恢复。 分布式与集群的联系与区别如下：
分布式是指将不同的业务分布在不同的地方。而集群指的是将几台服务器集中在一起，实现同一业务。分布式的每一个节点，都可以做集群，而集群并不一定就是分布式的。而分布式，从狭义上理解，也与集群差不多，但是它的组织比较松散，不像集群，有一定组织性，一台服务器宕了，其他的服务器可以顶上来。分布式的每一个节点，都完成不同的业务，一个节点宕了，这个业务就不可访问了。 集群主要分成三大类：
HA：高可用集群（High Availability Cluster）。LBC：负载均衡集群/负载均衡系统（Load Balance Cluster）HPC：科学计算集群（High Performance Computing Cluster）/高性能计算（High Performance Computing）集群。 为什么搭建数据库集群 随着经济的高速发展，企业规模的迅猛扩张，企业用户的数量、数据量的爆炸式增长，对数据库提出了严峻的考验。对于所有的数据库而言，除了记录正确的处理结果之外，还面临着以下几方面的挑战。
如何提高处理速度，实现数据库的均衡负载。如何保证数据库的可用性、数据安全性、以及如何实现数据集群可扩性。怎么综合解决这些问题成为众多企业关注的焦点。 在数据库上，组建集群也是同样的道理，主要有以下几个原因：
伴随着企业的成长，业务量提高，数据库的访问量和数据量快速增长，其处理能力和计算速度也相应增大，使得单一的设备根本无法承担。在以上情况下，若扔掉现有设备，做大量的硬件升级，势必造成现有资源的浪费，而且下一次业务量提升时，又将面临再一次硬件升级的高额投入。于是，人们希望通过几个中小型服务器组建集群，实现数据库的负载均衡及持续扩展；在需要更高数据库处理速度时，只要简单的增加数据库服务器就可以得到扩展。数据库作为信息系统的核心，起着非常重要的作用，单一设备根本无法保证系统的下持续运行，若发生系统故障，将严重影响系统的正常运行，甚至带来巨大的经济损失。于是，人们希望通过组建数据库集群，实现数据库的高可用，当某节点发生故障时，系统会自动检测并转移故障节点的应用，保证数据库的持续工作。企业的数据库保存着企业的重要信息，一些核心数据甚至关系着企业的命脉，单一设备根本无法保证数据库的安全性，一旦发生丢失，很难再找回来。于是，人们希望通过组建数据库集群，实现数据集的冗余，通过备份数据来保证安全性。 数据库集群的分类 数据库集群技术是将多台服务器联合起来组成集群来实现综合性能优于单个大型服务器的技术，这种技术不但能满足应用的需要，而且大幅度的节约了投资成本。数据库集群技术分属两类体系：基于数据库引擎的集群技术和基于数据库网关（中间件）的集群技术。在数据库集群产品方面，其中主要包括基于数据库引擎的集群技术的 Oracle RAC、Microsoft MSCS、IBM DB2UDB、Sybase ASE，以及基于数据库网关（中间件）的集群技术的 ICX-UDS 等产品。
一般来讲，数据库集群软件侧重的方向和试图解决的问题划分为三大类：
负载均衡集群（LOAD BALANCE CLUSTER，LBC）侧重于数据库的横向扩展，提升数据库的性能。高可用性集群（HIGH AVAILABILITY CLUSTER，HAC）侧重保证数据库应用持续不断。大部分的数据库集群侧重与此。高安全性集群（HIGH SECURITY CLUSTER，HSC）侧重于容灾。 只有 ORACLE RAC 能实现以上三方面
可扩展的分布式数据库架构 ORACLE RAC 其架构的最大特点是共享存储架构（SHARED-STORAGE），整个 RAC 集群是建立在一个共享的存储设备之上的，节点之间采用高速网络互联。OracleRAC 提供了非常好的高可用特性，比如负载均衡和应用透明切块（TAF），其最大的优势在于对应用完全透明，应用无需修改便可切换到RAC 集群。但是RAC 的可扩展能力有限，首先因为整个集群都依赖于底层的共享存储，所以共享存储的 I/O 能力和可用性决定了整个集群的可以提供的能力，对于 I/O 密集型的应用，这样的机制决定后续扩容只能是 Scale up（向上扩展）类型，对于硬件成本、开发人员的要求、维护成本都相对比较高。Oracle显然也意识到了这个问题，在 Oracle 的 MAA（Maximum Availability Architecture）架构中，采用 ASM 来整合多个存储设备的能力，使得 RAC 底层的共享存储设备具备线性扩展的能力，整个集群不再依赖于大型存储的处理能力和可用性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec2dcd2753e559a1467c8d4c17c1031d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc305e9077001de4edb2081003cab6a1/" rel="bookmark">
			SpringBoot配置属性之Security
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring security是springboot支持的权限控制系统。 security.basic.authorize-mode 要使用权限控制模式. security.basic.enabled 是否开启基本的鉴权，默认为true security.basic.path 需要鉴权的path，多个的话以逗号分隔，默认为[/**] security.basic.realm HTTP basic realm 的名字，默认为Spring security.enable-csrf 是否开启cross-site request forgery校验，默认为false. security.filter-order Security filter chain的order，默认为0 security.headers.cache 是否开启http头部的cache控制，默认为false. security.headers.content-type 是否开启X-Content-Type-Options头部，默认为false. security.headers.frame 是否开启X-Frame-Options头部，默认为false. security.headers.hsts 指定HTTP Strict Transport Security (HSTS)模式(none, domain, all). security.headers.xss 是否开启cross-site scripting (XSS) 保护，默认为false. security.ignored 指定不鉴权的路径，多个的话以逗号分隔. security.oauth2.client.access-token-uri 指定获取access token的URI. security.oauth2.client.access-token-validity-seconds 指定access token失效时长. security.oauth2.client.additional-information.[key] 设定要添加的额外信息. security.oauth2.client.authentication-scheme 指定传输不记名令牌(bearer token)的方式(form, header, none,query)，默认为header security.oauth2.client.authorities 指定授予客户端的权限. security.oauth2.client.authorized-grant-types 指定客户端允许的grant types. security.oauth2.client.auto-approve-scopes 对客户端自动授权的scope. security.oauth2.client.client-authentication-scheme 传输authentication credentials的方式(form, header, none, query)，默认为header方式 security.oauth2.client.client-id 指定OAuth2 client ID.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc305e9077001de4edb2081003cab6a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86aef0806a4baf9b8d6378f9b7715cb0/" rel="bookmark">
			如何判断BIOS设置是否开启CPU虚拟化功能？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开“任务管理器“，进入任务管理器快捷方式【 Ctrl+Shift+Esc】或者【Ctrl+Alt+Delete】
找到“性能”选项卡，看CPU的虚拟化是“已启用” 还是 “已禁用”。参见下图：
若看到“虚拟化：已启用”，说明开启CPU虚拟化功能。
若看到“虚拟化：已禁用”，说明未开启CPU虚拟化功能，需要进入BIOS设置，以联想的笔记本为例，进入BIOS按键是F2，进入后按左右键选择configuration，找到 Intel Virtual Technology（Intel虚拟化技术），确认为enable。
END
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8610076ae85b4c906750eb5f6cbbd7c9/" rel="bookmark">
			word中选中所有拼音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Ctrl + f 查找 查找内容 填 ^$ 点击 高级搜索 只选中 区分全/半角 在以下范围中查找 选中 主文档 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76230d3d015397bf7e6ffab1856afda6/" rel="bookmark">
			vue实现input禁止粘贴
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求: 阻止element组件中的复制粘贴功能
实现思路: 组件是由外层
和内层的组成的, 根据浏览器的事件传递机制(先捕获,后冒泡): 粘贴的时候会先执行绑定在外层div上的paste事件捕获方法, 然后再到内层的input, 因此可以在组件上捕获监听paste事件, 并阻止向下传播即可
&lt;el-input v-model="list.content" type="textarea" :disabled="true" @paste.native.capture.prevent="handleFalse" @copy.native.capture.prevent="handleFalse" @cut.native.capture.prevent="handleFalse" :rows="60" autosize &gt;&lt;/el-input&gt; methods: { handleFalse() { // 终止 return false; } } 事件修饰符说明:
native: 表明这个是dom的原生事件,如果不加native, vue会认为paste是一个自定义事件,必须要在组件内手动触发, 那么在粘贴的时候自然就不会触发了
capture: 表明这个方法在捕获阶段执行,默认为冒泡执行,参考addEventListener方法中的useCapture参数
prevent: 相当于event.preventDefault阻止默认行为, 同时也会阻止事件的向下传递和向上冒泡
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/732c3fab07634825fc0137ce22fbeede/" rel="bookmark">
			MFC 使用控制台打印程序信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MFC编程中，代码的调试一直不太直观。搞一个 MessageBox 来打印信息查看程序是否执行或执行是否有误，又或者是在程序中设断点都有不太方便的地方，特别是在需要获得多个信息的情况下更是不便。此外，MessageBox 在涉及到打印非 CString 格式的信息时还要用 CString 的 Format 函数进行格式转换，又给调试带来进一步的麻烦。综上，在MFC程序的调试阶段加入像WIN32控制台程序那样的控制台来打印程序信息显得直观又方便易用。下面，是在MFC程序中添加控制台程序的方法：
在对话框程序的初始化函数OnInitDialog()中(如果不是对话框程序，或者希望在子对话框中加入，只需将代码添加到相应的入口位置即可)加入如下代码：
::AllocConsole();//打开控件台资源 FILE *fp; freopen_s(&amp;fp,"CONOUT$", "w+t", stdout);//申请写，这个是针对VS2013版本的代码，在VS较为早期的版本比如VS2008中，可将freopen_s改为freopen，并将参数改为对应形式即可 到此，程序在运行时就会打开一个控制台窗口等待输入，只要在程序中加入 printf(“,”) 则可在控制台中打印出信息。
最后，要记得在程序关闭的地方调用如下函数关闭掉控制台程序，不然会导致程序无法正常关闭的悲剧。
本人是在对话框程序的 WM_CLOSE 消息响应函数中添加的：
FreeConsole();//释放控制台资源 注意：生成的exe程序打开时也会自动打开控制台，发行程序时要记得把打开和关闭控制台的代码都注释掉
当然，MFC本身也集成了相应的宏"TRACE"来实现这个功能。示例如下：
TRACE("x = %d and y = %x and z = %f\n", 1, 2, 3); 优点就是可以直接打印信息，缺点则是打印出来的东西在"输出窗口"中，感觉总没有控制台那么好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5e1a0210557804ad7b81b403fe6dd6c/" rel="bookmark">
			线程池ThreadPoolExecutor详解（整理详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是线程池？
（首先要理解什么是线程）
线程池，thread pool，是一种线程使用模式，线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。
通俗来说，就是为了优化线程的内存开销。 2.为什么使用线程池？
为了减少创建和销毁线程的次数，让每个线程都可以多次的使用，可以根据系统情况调整线程的数量，防止消耗过多内存。在实际使用中，服务器在创建和销毁线程上花费的时间和消耗的系统资源都相当大，使用线程池就可以优化。
线程池主要用来解决线程生命周期开销问题和资源不足问题。通过对多个任务重复使用线程，线程创建的开销就被分摊到了多个任务上了，而且由于在请求到达时线程已经存在，所以消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使用应用程序响应更快。另外，通过适当的调整线程中的线程数目可以防止出现资源不足的情况。
通俗来说，就是为了优化线程的内存开销。
3.线程池的核心参数
public ThreadPoolExecutor(int corePoolSize,//核心线程数 int maximumPoolSize,//最大线程数 long keepAliveTime,//线程空闲时间 TimeUnit unit,//时间单位 BlockingQueue&lt;Runnable&gt; workQueue,//任务队列 ThreadFactory threadFactory,//线程工厂 RejectedExecutionHandler handler//拒绝策略) { ... } 4.线程池的执行顺序
线程池按以下行为执行任务
当线程数小于核心线程数时，创建线程。当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。当线程数大于等于核心线程数，且任务队列已满，若线程数小于最大线程数，创建线程。若线程数等于最大线程数，则执行拒绝策略 5.线程池的参数详解
corePoolSize 核心线程数，默认为1。
设置规则：
CPU密集型(CPU密集型也叫计算密集型，指的是运算较多，cpu占用高，读/写I/O(硬盘/内存)较少)：corePoolSize = CPU核数 + 1
IO密集型（与cpu密集型相反，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，此时CPU Loading并不高。）：corePoolSize = CPU核数 * 2
maximumPoolSize 最大线程数，默认为Integer.MAX_VALUE
一般设置为和核心线程数一样
keepAliveTime 线程空闲时间，默认为60s，一般设置为默认60s
unit 时间单位，默认为秒
workQueue 队列，当线程数目超过核心线程数时用于保存任务的队列。（BlockingQueue workQueue）此队列仅保存实现Runnable接口的任务。（因为线程池的底层BlockingQueue的泛型为Runnable）
无界队列
队列大小无限制，常用的为无界的LinkedBlockingQueue，使用该队列作为阻塞队列时要尤其当心，当任务耗时较长时可能会导致大量新任务在队列中堆积最终导致OOM。阅读代码发现，Executors.newFixedThreadPool 采用就是 LinkedBlockingQueue，而博主踩到的就是这个坑，当QPS很高，发送数据很大，大量的任务被添加到这个无界LinkedBlockingQueue 中，导致cpu和内存飙升服务器挂掉。
当然这种队列，maximumPoolSize 的值也就无效了。当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。
有界队列
当使用有限的 maximumPoolSizes 时，有界队列有助于防止资源耗尽，但是可能较难调整和控制。常用的有两类，一类是遵循FIFO原则的队列如ArrayBlockingQueue，另一类是优先级队列如PriorityBlockingQueue。PriorityBlockingQueue中的优先级由任务的Comparator决定。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5e1a0210557804ad7b81b403fe6dd6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de7e4033a9ed4e4ac2fb449597e2b81b/" rel="bookmark">
			5分钟 在Mac下Docker部署redis集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在自定目录新建文件 redis.conf ，如 /Users/xx/apps/redis/redis.conf将redis.conf的内容设置为： bind 0.0.0.0 daemonize no requirepass 123456 masterauth 123456 cluster-enabled yes cluster-node-timeout 3000 打开终端，输入命令启动容器： docker run -d --name redis-node1 -v /Users/xx/apps/redis/redis.conf:/etc/redis/redis.conf -p 6379:6379 -p 16379:16379 redis --cluster-enabled yes --port 6379 docker run -d --name redis-node2 -v /Users/xx/apps/redis/redis.conf:/etc/redis/redis.conf -p 6380:6380 -p 16380:16380 redis --cluster-enabled yes --port 6380 docker run -d --name redis-node3 -v /Users/xx/apps/redis/redis.conf:/etc/redis/redis.conf -p 6381:6381 -p 16381:16381 redis --cluster-enabled yes --port 6381 ps: 16379、16380、16381端口用于接收心跳数据等操作
输入命令查看容器启动状况 docker ps -a # 如果出错使用以下命令查看日志 docker logs &lt;容器id&gt; 结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de7e4033a9ed4e4ac2fb449597e2b81b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b46f4abc3f6d7582344bed4c56797699/" rel="bookmark">
			vue3 beforeRouteEnter内调用setup里的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在setup方法里return要调用的方法，在beforeRouteEnter里就可以直接调用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7f68b8cb2a1216e6103dc1c98c867dc/" rel="bookmark">
			从零到一，教你搭建「CLIP 以文搜图」搜索服务（二）：5 分钟实现原型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇文章中，我们了解了关于搜索技术、以文搜图，以及 CLIP 模型的基础知识。本篇我们将花上 5 分钟时间，对这些基础知识进行一次动手实践，快速构建一个「以文搜图」的搜索服务原型。
Notebook 链接👇
https://github.com/towhee-io/examples/blob/main/image/text_image_search/1_build_text_image_search_engine.ipynb
这里我们选取 “搜萌宠” 这个小例子：面对成千上万的萌宠，帮助用户在海量的图片中快速找到心仪的那只猫咪或修勾~
图片来源：https://www.vetopia.com.hk 话不多说，先看 5 分钟出活儿的成品效果：
让我们来看看做这样一个原型都需要些什么：
一个宠物的小型图片库。
一个能将宠物图片的语义特征编码成向量的数据处理流水线。
一个能将查询文本的语义特征编码成向量的数据处理流水线。
一个可以支撑向量近邻搜索的向量数据库。
一段能将上述所有内容串起来的 python 脚本程序。
接下来，我们会陆续完成这张图的关键组件，开始干活~
安装基础工具包 我们用到了以下工具：
Towhee 用于构建模型推理流水线的框架，对于新手非常友好。
Faiss 高效的向量近邻搜索库。
Gradio 轻量级的机器学习 Demo 构建工具。
创建一个 conda 环境
conda create -n lovely_pet_retrieval python=3.9 conda activate lovely_pet_retrieval 安装依赖
pip install towhee gradio conda install -c pytorch faiss-cpu 准备图片库的数据 我们选取 ImageNet 数据集的子集作为本文所使用的 “小型宠物图片库”。首先，下载数据集并解压：
curl -L -O https://github.com/towhee-io/examples/releases/download/data/pet_small.zip unzip -q -o pet_small.zip 数据集的组织如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7f68b8cb2a1216e6103dc1c98c867dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/badff4e5e9cb1bdd277f3d8383f5815b/" rel="bookmark">
			javaweb——Response下载文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HttpServletResponse web服务器接收到客户端的http请求，针对这个请求分别创建一个代表请求的HttpServletResponse对象，一个代表响应的HttpServletResponse对象；
如果要获取客户端请求过来的参数：找HttpServletRequest如果要客户端响应一些信息：找HttpServletResponse 1、简单分类 负责向浏览器发送数据的方法 public ServletOutputStream getOutputStream() throws IOException; public PrintWriter getWriter() throws IOException; 负责向浏览器**发送响应头（encoding…）**的方法 void setCharacterEncoding(String charset); void setContentLength(int len); void setContentLengthLong(long length); void setContentType(String type); void setDateHeader(String name, long date); void addDateHeader(String name, long date); void setHeader(String name, String value); void addHeader(String name, String value); void setIntHeader(String name, int value); void addIntHeader(String name, int value); 响应的状态码 /** * Status code (100) indicating the client can continue. */ public static final int SC_CONTINUE = 100; /** * Status code (101) indicating the server is switching protocols according * to Upgrade header.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/badff4e5e9cb1bdd277f3d8383f5815b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14bf412ed2a4c3b90e617652ed05207c/" rel="bookmark">
			Jaccard 相似度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Jaccard相似系数： Jaccard相似系数（Jaccard similarity coefficient）用于比较有限样本集之间的相似性与差异性。Jaccard系数值越大，样本相似度越高。 主要应用场景： 卡德方法完善了余弦相似性只考虑用户评分而忽略了其他信息量的弊端，特别适合于应用到稀疏度过高的数据 比较文本相似度，用于文本查重与去重；（就是将字符串S, T分别进行分词，用交集中的词语数和并集中的词语数求比） 计算对象间距离，用于数据聚类等。 举例讲： A 用户(香蕉、苹果、鸭梨) B 用户(苹果、橘子、桃子) A∩B=苹果 1 A∪B=香蕉、苹果、鸭梨、橘子、桃子 5 则相似度（Jaccard系数）为1/5=0.2 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4500b5516c1248c17b8cd1f1d02bdf7/" rel="bookmark">
			【Python实现】解析Drugbank文件中的XML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 样例一：xml直接提取2 样例二：xml转json格式3 提取drug-target信息4 参考文献 1 样例一：xml直接提取 在做Drugbank数据处理时，发现的一个能够解决我问题的开源代码：项目地址以及Test文件，都在：
https://github.com/Deshan-Zhou/deal_DrugBank 但是直接上手处理xml格式的文件，对于xml数据的组织形式不熟悉的同志来讲很头疼，并不能够随心所欲的提取自己想提取的各种关联信息。在样例二中我提供一种能够方便提取数据的方法。
from xml.sax.handler import ContentHandler from xml.sax import parse import pandas as pd """ 简写： dbid : DrugBank id dbname : DrugBank name chid : ChEMBL id ptid : protein id """ class ExtractData(ContentHandler): def __init__(self): #各个简写的映射关系 self.dbid_chid = {} self.dbid_dbname = {} self.dbid_dbid = {} self.dbid_ptid = {} #当前的药物id和遍历区域的限定 self.curr_id = "" self.limit = 0 #可以自动获取遍历到的元素里面的内容，如&lt;ele&gt;content.....&lt;/ele&gt; def characters(self,content): if self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4500b5516c1248c17b8cd1f1d02bdf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd222a062b32a2a9953268474d59051e/" rel="bookmark">
			VS设置导出目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开属性页面
1、配置属性-&gt;常规-&gt;输出目录
这里修改的是exe的生成目录
2、配置属性-&gt;常规-&gt;目标文件名
这里修改的是exe的名字
3、配置属性-&gt;调试-&gt;命令
这里修改的是运行时vs去哪里找exe
4、配置属性-&gt;调试-&gt;工作目录
如果你有很多dll感觉太乱，需要放在子目录也许可以试试这个
5、配置属性-&gt;链接器-&gt;常规-&gt;输出文件
这里修改的是exe的生成目录，需要加上exe的名字如a.exe
6、配置属性-&gt;链接器-&gt;调试-&gt;生成程序数据库文件
这里是pdb文件，没啥用可以改掉，这样生成目录清爽一些
7、配置属性-&gt;链接器-&gt;高级-&gt;导入库
这里是lib、exp文件，没啥用可以改掉，这样生成目录清爽一些
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c92ce73f4d9e7eab1c1c1a2c61645c7/" rel="bookmark">
			JavaScript中字符串和Base64的互相转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
JavaScript中提供了两个函数，用来解析Base64，分别时Btoa和Atob
一、Btoa() 将字符串或者二进制转换成Base64
二、Atob() 将Base64转换成原本的编码
总结 注意Atob()中编码的书写格式不然会报错
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea86a1cc58db0bd07cde7834eb1c8b28/" rel="bookmark">
			即刻开启零信任网络之旅，绎云推出永久免费的轻量级零信任网络产品
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		绎云推出永久免费的轻量级零信任网络产品——信域安全云网Lite（信域Lite），帮助企业在碎片化的物理网络之上构建一张点对点虚拟网络，用实名制零信任网络重新整合企业分布在各地的网络资源，让远程互联更灵活，管理运维更高效，业务协同更可信，为企业节省网络和安全投入，降低运维成本。
官网链接：https://www.trustmatrix.com/#/product.html
微信中看了信域免费版的文章，回答了我的疑问，亲自去体验一把：
1、登录官网 信域企业注册平台 去注册了帐号：
2、注册完， 登录成功后，可以看到界面，有免费的组件，提供了下载链接；
简单了解了一下这个产品的功能和一些约束，不得不说确实挺好：
3、下载镜像包开始… 文件不小，但是速度还可以哈👍
4、怎么安装？？？去网站上找了找，发现文档中心里有介绍入门的步骤：
5、亲自用VMVare虚出来3台机器，准备安装上：
1）新建虚拟机：
2）填写名称，选择：兼容性，操作系统系列，操作系统版本；*
3）选择存储：
4）自定义设置：
很重要一点：创建虚拟机的时候，驱动器要选择： 勾选镜像：
![在这里插入图片描述](https://img-blog.csdnimg.cn/09ff5e23027143b5a756139f4a8fdd62.png
吐槽一下：机器的配置不低…：
5）完成配置：
6、启动虚拟机，然后开始安装镜像：
7、安装完镜像：
等待镜像安装… …：
几分钟后，安装完成，点击红色OK按钮，或Enter键：
安装完镜像，重启虚拟机，输入exit，点击enter键：
8、安装完镜像，开始同步证书License：
虚拟机重启完，登录：默认用户名：admin，默认密码：b4a5928c（网站文档中有标注写明）
登录成功后，先得同步License，执行4，点击enter键：
录入帐号密码（帐号密码是什么？？看截图）：
等待执行成功：
同步证书成功后，会收到邮件：
成功后，可以访问TMC的页面：
9、访问信域管理控制平台：
浏览器输入 https://虚拟机物理IP:16000
输入管理员：sysadmin 和 密码，登录：
首次登录成功后，强制修改密码，密码强度：大写字母+小写字母+数字+常用特殊符号+长度10位以上：
配置邮件设置：管理员不清楚的应该联系自己公司的人力部门，或者配置上自己的个人邮箱都是可以的：
用新密码再次登录 信域管理控制平台：
10、如何使用信域管理控制平台，请去注册平台查看具体的步骤吧：
原文链接：https://blog.csdn.net/xilangyuyun/article/details/125679293
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d700acbab4e45e48e2107175dca3e15/" rel="bookmark">
			VMware 虚拟机安装 OpenWrt 作旁路由 单臂路由 img 镜像转 vmdk 旁路由无法上网 没网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重要注意事项 由于布线原因笔记本只能采用无线的方式连接路由器，在Windows10的环境下使用无线网卡桥接，结果软路由无法上网，翻阅了各种帖子最终发现跟系统底层的协议栈有关系，随即放弃使用有线网卡，不能上网等乱七八糟的问题瞬间解决，因此务必提醒各位，千万不要使用无线网卡桥接！！！
参考文章如下，讲的很详细，可以事先阅读避免踩坑。
1、 已解决关于vmware搭openwrt旁路由 无线网卡设备无法上网
2、【终极指南】关于N1做旁路由添加 iptables 自定义防火墙规则的见解
1. 安装VMware 请自行下载安装 VMware 16.2 及以上版本
2. img 镜像转 vmdk 格式 下载的 vmdk 格式的系统，请忽略此步下载的 img 格式的系统，请自行下载 StarWind V2V Image Converter 工具将其转换为 vmdk 格式，下载链接如下https://www.starwindsoftware.com/tmplink/starwindconverter.exe 3. 创建 OpenWrt 虚拟机 创建虚拟机
使用自定义模式
使用兼容模式
稍后安装操作系统
选择Linux操作系统，内核版本根据镜像的内核来决定
虚拟机命名并选择存储位置
处理器配置
内存配置 建议2G起步
网络配置 旁路由务必选择桥接模式
I/O设置
磁盘设置
选择现有磁盘创建系统，即前面生成的 vmdk 文件
保持现有格式不变
自定义硬件 删除无用硬件设备
4. 配置 OpenWrt 软路由 启动虚拟机
查看本机网络信息，确定软路由的 IP 地址及网关设置
修改软路由的 IP 地址及网关
vi /etc/config/network
按下 i或者insert键进入编辑模式按下 esc退出编辑模式输入:wq然后回车(保存并退出编辑)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d700acbab4e45e48e2107175dca3e15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1950c0e3004c1730d5c4c354a9f0a0dc/" rel="bookmark">
			echarts社区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一个：
http://analysis.datains.cn/finance-admin/index.html#/chartLib/all
第二个
https://www.makeapie.cn/echarts_component/polar
第三个
http://ppchart.com/#/
第四个
https://www.isqqw.com/#/homepage
第五个
http://192.144.199.210/forum-2-1.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e1601e75aeb48a40b747d5484da46ed/" rel="bookmark">
			groupby详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、groupby详解 上周五同组同事有一个关于sql的bug,经leader看完后大体定位在group by语句用法错误。然后leader把我叫上一起，询问我们关于group by的用法。而我当时脑子非常空，其实感觉group by在脑子就只有一种去重的大致概念。真正用的时候其实大概率还是靠度娘，所以久久答不上来，所以特来重新学习下group by语句。 group_by的意思是根据by对数据按照哪个字段进行分组，或者是哪几个字段进行分组。
二、groupby语法 select 字段 from 表名 where 条件 group by 字段
或者
select 字段 from 表名 group by 字段 having 过滤条件
注意：对于过滤条件，可以先用where，再用group by或者是先用group by，再用having（唯一的差别是WHERE过滤行，HAVING过滤组）HAVING支持所有WHERE操作符。
三. 案例 1 、创建表格并插入数据
说明：在navicat上创建表格并插入数据，以便下面进行简单字段分组以及多个字段分组，同时还结合聚合函数进行运算。
创建student表
CREATE TABLE `student` ( `id` bigint(20) NOT NULL COMMENT '主键', `name` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '姓名', `grade` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '年级', `salary` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '薪水', PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic; 在student表中插入数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e1601e75aeb48a40b747d5484da46ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07f3d5fe24ceeb5f5f846539afb8bd1e/" rel="bookmark">
			【踩坑系列】 SpringBoot ，SpringSecurity，activiti 项目无法正常跳转到登录界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【踩坑系列】 SpringBoot ，SpringSecurity，activiti 项目无法正常跳转到登录界面 前言 一直强制跳转到springSecurity 的默认的登录界面，无法正常跳转到自己项目的登录界面以及自己的LoginController 没有执行。
接手的其他项目，项目中登录一直用的Shiro,pom 文件中也没有搜到有SpringSecurity的依赖，定位这个问题的bug 花费了挺长时间，在
才找到有引入SpringSecurity 的jar 包
问题原因 1.项目中有用Activiti
项目中引入SpringSecurity 的依赖 所以SpringBoot中的Application 的启动类中 SecurityAutoConfiguration 有两个
org.activiti.spring.boot.SecurityAutoConfiguration.class, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class 解决方案 @EnableScheduling @EnableTransactionManagement @ConfigurationPropertiesScan @SpringBootApplication(exclude = {org.activiti.spring.boot.SecurityAutoConfiguration.class, org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class}) public class Application extends SpringBootServletInitializer { public static void main(String[] args) { SpringApplication.run(Application.class, args); } @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { this.setRegisterErrorPageFilter(false); // 错误页面有容器来处理，而不是SpringBoot return builder.sources(Application.class); } } 最后 可以正常跳转到自己的登录界面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e244e8b374e40797e044fa067468fea5/" rel="bookmark">
			VS中使用类图查看和编辑项目中的类结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： 前言：安装类设计器配置类设计器到工具栏中在项目中添加类图 前言： VS堪称宇宙第一IDE，那么灵活使用它将是一个非常好地帮手！在许多项目构造时，我们不免要产生许多类和编辑查看他们，所以如果只是一味地去看代码，可能有审美疲劳（大神真的直接看直接理解emo）！所以我们就要好好利用VS给我们提供的类设计器啦，方便快速地去编写和管理项目中的类！
类图比较类似统一建模语言(UML)，大家可以百度下！
安装类设计器 首先打开你的VS项目程序页面！
接上面一步后，会跳出Visual Studio Installer窗口的正在修改窗口，如下图（由于之前我已经安装过，所以没显示下载安装，但是so easy啦）！
安装成功后，就可以利用类设计器来方便地去生成项目中对应的类图，管理好我们编写的类！ 配置类设计器到工具栏中 我们还不能直接使用它，还需要做一些配置，将类图设置编辑的功能菜单项添加到工具栏中，下面是我们没配置好的工具栏菜单！
勾选后可以看到VS项目工具栏中新增了如下菜单项（是编辑类设计器生成的类图的功能菜单），但是由于我们还没添加好类图文件，所以对应菜单项还是虚空状态 ：
在项目中添加类图 为了方便说明，这里不列举建造类的过程，但是你应该有个项目程序有两个类以上（最好有父类和子类）！
添加类图文件 将项目拉到类设计器界面（类图界面）
关于类图的编辑和基于类图添加字段，方法等等以后有空才更新了！请各位朋友稍后下！
最后，文中若有不足，敬请批评指正！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efaae0a3da084b3521b66f9e57128379/" rel="bookmark">
			Helm-chart学习-简单介绍与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
为什么需要Helm？直接kubectl有什么问题吗？
Helm介绍
Helm基本使用
Helm模板设置 流程控制
Chart模板：命名模板
写一个通用的Chart
使用Harbor作为Chart仓库
为什么需要Helm？直接kubectl有什么问题吗？ 常规K8s部署应用方式：将需要的资源编写YAML文件，然后apply -f进行部署，当然也有使用图形界面操作的，这里不做讨论。 例如部署一个常规web程序，一般我们需要部署deployment、service、ingress资源。 Deployment.yaml
apiVersion: apps/v1 kind: Deployment metadata: name: web namespace: default spec: replicas: 3 selector: matchLabels: app: web template: metadata: labels: app: web spec: containers: - name: web image: nginx:1.19 ports: - containerPort: 80 Service.yaml
apiVersion: v1 kind: Service metadata: labels: app: web name: web spec: ports: - port: 80 protocol: TCP targetPort: 8080 selector: app: web Ingress.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efaae0a3da084b3521b66f9e57128379/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/139/">«</a>
	<span class="pagination__item pagination__item--current">140/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/141/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>