<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb40f0556772c97df993ce23d5a5e88a/" rel="bookmark">
			图片仅供测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片仅供测试！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93a3e9381e18c9cf574cd7cfc7882a7e/" rel="bookmark">
			itoa随手记（itoa是什么，itoa怎么用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 虽然是非常常见的函数，但我没见过，在这里记录一下。
一、itoa是什么？
itoa函数，全称int to array，是将整形转换成字符串类型的函数。是C非标准库的函数（写题目也不用管这个）
二、使用 char* itoa(int value,char*string,int radix);
value: 要转换的整数，可以不是int类型但是整数必须在int的范围里 string: 转换后的字符串 radix: 转换进制数，范围是2~36
#include &lt;stdio.h&gt; int main() { int number1 = 12; int number2 = -123456; char string[16] = {0}; itoa(number1,string,8); printf("数字：%d 转换为：%s\n",number1,string); itoa(number2,string,10); printf("数字：%d 转换为：%s\n",number2,string); system("pause"); return 0; } 总结 用于int类型转字符串
填入数字的范围在int之内，可以是负数，进制转化在2到36之间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49477aaec7ca5e075a2dc26cf81b65d6/" rel="bookmark">
			C语言中的分支语句和循环语句（if语句、switch语句、while循环、for循环、do...while循环、goto语句）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言是结构化的程序语言，有循环结构、选择结构、循环结构’
一、什么是语句？
1. 表达式语句 2. 函数调用语句 3. 控制语句 4. 复合语句 5. 空语句 本文主讲 控制语句 ，其 用于控制程序的执行流程，以实现程序的各种结构方式，它们由特定的语句定义符组成， C 语 言有九种控制语句。 可分成以下三类： 1. 条件判断语句也叫分支语句： if语句 、 switch语句 ； 2. 循环执行语句： do while语句、while语句、for语句 ； 3. 转向语句： break语句、goto语句、continue语句、return语句 。 二、分支语句（选择结构） 2.1 if语句
2.2.1语法
if（表达式） //表达式为真则执行 语句； if（表达式） //表达式为真则执行 语句1； else 语句2； 多分支：
if(表达式1) //表达式为真则执行 语句1； else if（表达式2） //表达式为真则执行 语句2； else 语句3； 2.1.2真假判断：
#define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h&gt; int main() { int a = 10; if (a = 3) //对a进行赋值3，非0为真 { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49477aaec7ca5e075a2dc26cf81b65d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38830fca328e3d030787043f8df3f9e9/" rel="bookmark">
			聊聊java8中的@sun.misc.Contended与伪共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“持续创作，加速成长！这是我参与「掘金日新计划 · 6 月更文挑战」的第30天，点击查看活动详情”
@[toc] 在前面学习ConcurrentHashMap的size方法的过程中，对于CounterCell这个类，有个特殊的注解 @sun.misc.Contended。那么今天就来聊聊这个注解的具体作用和其底层的基本原理。
&lt;pre class="prettyprint hljs cs"&gt;/** * A padded cell for distributing counts. Adapted from LongAdder * and Striped64\. See their internal docs for explanation. */ @sun.misc.Contended static final class CounterCell { volatile long value; CounterCell(long x) { value = x; } }&lt;/pre&gt; 经过查阅资料之后，不难发现，@sun.misc.Contended注解是被设计用来解决伪共享问题的。那么什么是为伪共享呢？
1.伪共享 在了解伪共享之前，需要了解一下CPU的缓存机制。
1.1 CPU的缓存机制
学过计算机的人都知道，CPU是计算机的大脑，所有的程序，最终都要变成CPU指令在CPU中去执行。CPU的计算速度是非常快的，但是，我们知道，程序必须存储在存储介质中，程序启动之后被加载到内存中才能执行。但是内存的读取速度和CPU的计算速度之间存在非常大的差异。那么为了解决这个计算速度之间的差异，就在CPU上增加了缓存来解决这个问题。通常情况下，CPU是三级缓存结构，如下图：
越靠近CPU的缓存，其容量就越小，但是其速度就越快。所以实际上L1的容量是最小的，这取决于CPU的具型号。
如上图所示，我们笔记本使用的I7CPU的三级缓存，L1为256k，L2为1M,L3为8M。 当CPU在执行计算的时候，先去L1查找数据，然后再去L2、L3,如果都没有数据则需要到主存中去加载。走得越远运算耗费的时间就越长。所以，对于一些高CPU的计算，尽量确保数据都能在L1中，降低加载次数。 Martin Thompson 提供了一些从CPU到缓存加载需要的大值时间：
从CPUCPU周期大致时间主存60-80nsQPI总线20nsL3 cache40-45cycles15nsL2 cache10 cycles3nsL1 cache3-4cycle1ns寄存器1cycle 1.2 缓存行和伪共享
我们了解了缓存cache之后，缓存是以行为单位存在在cache中的，通常而言，一个缓存行大概是64byte。对于java类而言，一个javalong的对象长度为8字节，因此一个缓存行就是8个long的长度。因此，在你访问一个long数组的时候，当数组中有一个值被加载到缓存中的时候，它会额外加载另外7个值，以至于遍历数组的速度可以非常快。因此对于连续存储在内存块的数据结构，都是可以非常快速的遍历的。 对于链表，由于数据不连续，因此很难享受到这个优势。也就是说，CPU处理内存的宽度是64byte。但是我们程序中的基本的变量都会小于这个宽度，因此这会带来另外一个问题，这就是伪共享。 伪共享的意思就是说，当线程1在使用变量x的时候，CPU会将X相连的部分共64字节全部都加载到core的L1中。如果此时线程2需要使用的y，但是y在此时已经做为x相邻的64字节的一部分被加载到了L1中。由于L1是按核心各自独立的，因此这个时候就会对这个缓存行产生了竞争。这就是伪共享。 实际上CPU的处理可能比这个描述复杂，但是对于这种竞争的情况，一般在MESI协议的CPU上，是会互相影响的。 在MESI协议中，如果两个不同的处理器都需要操作相同的缓存行，那么就会导致RFO请求。 我们来看看Disruptor的示例图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38830fca328e3d030787043f8df3f9e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2df88191cd1be1d0250522cde1ef085a/" rel="bookmark">
			输入输出大全（普通输入输出和快读快写）C/C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、普通读写操作
1、cin
2、scanf
3、gets/getline
4、printf
二、快读快写
1、整形快读快写
2、浮点型的快读快写
3、字符串快读快写
三、O2优化
总结
前言 我最早接触的刷题平台是力扣，这导致我第一次在PTA平台上写题的时候在数据的输入和输出上感到非常折磨。这篇文章是我对各种输入输出的总结，准备开始刷题的同学看这篇文章能帮你节约不少的时间。
缓存区 ： 书上的定义是，缓冲区是一块物理内存中的存储区,当数据进行转移时用来临时存放数据。在这里的作用我就把他理解成，在输入和输出时数据时，这些数据都要在缓存区走一遍再去完成他们的功能。
一、普通读写操作 在不考虑读写运行速度的情况下，基本的读入函数就能完成我们所有的读入功能。下面主要介绍不同的读入函数，
1、cin 作为操作起来最方便的读入函数，cin不需要记住任何的多余符号，新手只要知道他在空格和换行符会自动停止读入就行，且不会清空缓存区，对刚刚刷题的小白非常的友好。但我个人是非常不建议用的，速度慢是其次，主要是他在读入一些比较特殊的词时会有些不方便（这个题目写多了肯定会遇到的），最基础的操作相比来说的话我更推荐scanf。
2、scanf 我是非常建议把scanf当成不需要考虑读入效率时的默认输入方式的。一般的scanf使用方法我就不多说了，这里介绍几种在刷题时曾经困扰过我的几种输入。
题目要求读入n个整形（n不确定），存放在arr数组里，输入时每个整形之间会以空格分开，具体样子如下。
当时我不了解scanf遇到空格会结束的特性，这个输入没有完成，其实这种类型的输入通过一句话就可以解决。
while(~scanf("%d",&amp;arr[i++]));//i就是个从零开始的变量 这里用到了scanf的返回值特性，scanf其实是有返回值的（可能就我不知道吧），一次scanf读入几个字符他就会返回几，碰到空格或者TAB等会返回0，而碰到输入结束标志会返回EOF（即-1），所以这里用的是~符号，让-1的时候得到0退出while循环，就是要让他在检测接收到数据和空格时都继续接收下一个，而接收到输入结束标志时退出while即不继续输入。
大部分不确定输入个数的输入通过这个都能解决，但有一个例子不可以：要求将n（n不确定）个字符串放到二维数组arr里，具体如下。
我们先直接看解决代码
while(~scanf("%d",&amp;arr[i++]) &amp;&amp; getchar() == ' ');//i就是个从零开始的变量 这里我先解释上面的那一串字符为什么不能用之前的方法解决，在最开始我也不明白为什么这样的字符串输入进来会有问题，后面我看了录进去的值之后我发现其实不管是让我输入字符串还是让我输入整形，我的输入都是有问题的，只不过在字符串输入的时候更容易发现错误。对于第一个输入整形的题目我们写一下就会发现当我们运行完时，如果我们输入3个数，n的值会变成4而不是3，这是因为scanf在读入的时候在把空格，换行等读入到缓存区的时候会结束此次读入，但是这时候缓存区里的空格，换行等不会消失，这就导致我读完最后一个数时其实缓存区里还有\n而不是结束标志，这时候如果下一位是文章结束标志scanf会将\n转换成空格存到我的数组里，当然这时候n++于是导致n比我们想要的值还多一。那为什么加了getchar就好了呢，这我们就要知道getchar的处理字符方式，当缓存区有字符时，getchar会从缓存区读取并清空一个字符，而这里就是用到了getchar的这个特性，不仅可以清空scanf之后缓存区残留的符号还能，让循环在正确的时候退出。
3、gets/getline 这两个分别是c/c++的输入函数，这里要注意的是gets在c++里是不能用的，在这里讲一下这两个函数和scanf有什么区别，前面我们已经说过了scanf遇到空格和回车会停止，但是这里的gets只有遇到回车才会停止，并且会自动把\n转化成\0(gets只会能把数据读到char*里)。还有一点与scanf不同的是scanf会把空格换行等留在缓存区里，只能通过getchar来清除，但gets不会在缓存区里留东西。getline就是c++版的gets。那什么时候会用到这个呢？当我想输入一段字符串但字符串里面包含空格时，我就只能用gets去实现这个功能。
4、printf 所有的输出我都是建议printf的，虽然cout非常的方便，但是学会printf可以满足所有不需要效率时的输出操作。下面主要讲两个我之前不知道的操作。
固定小数位数的输出，这里举个例子1：比如我要输出一个小数后两位的浮点数。
double a =2.127; printf("%.2lf\n",a);//控制double类型到两位小数 这里有一点要注意，最后一位显示出来的小数是会自动四舍五入的。
例子2：在整形前面自动补0直到达到指定位数，多用于有补0格式要求的整形输出。
int i=2; printf("%02d",i);//不够两位在左边补零，补空格也行 二、快读快写 在有些题目里读写要求的数据量特别大时甚至会要求我们不能使用语言本身提供的函数，而是要求我们对一些不方便但是效率高的函数操作来达到输入输出的功能，这就是快读快写。
快读快写的本质就是用更快的读入函数去实现读写操作，读入操作时间 cin &gt; scanf &gt; getchar &gt; fread.这就衍生出了以下两种快读（getchar版本和fread版本）。以下按照整型的输入来解释。
inline int read1()//这里加inline是为了解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题 { int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt;'9') { if (ch == '-') f = -1; ch = getchar(); } while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = x * 10 + ch - '0', ch = getchar(); return x * f; } 上面根据getchar读入字符的功能去实现读入一个整形，但是这样的函数没法像scanf一样放在while里读入，这就导致如果不告诉你数据个数你就没法很好的读入，于是改进后函数为下面这样，输入检测到\n会让while退出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2df88191cd1be1d0250522cde1ef085a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f346a4237086e4fbdeb1bdf923b9b871/" rel="bookmark">
			服务治理-Nacos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nacos下载： mac下第一个 windows下的二个
下载地址：https://github.com/alibaba/nacos/releaseshttps://github.com/alibaba/nacos/releases 进入安装路径的bin目录，通过cmd命令行输入startup.cmd -m standalone即可启动
访问控制台现实的nacos管理页面，完成登录：用户名和密码：nacos
那么之前我们是用的Eureka进行的服务注册，现在使用Nacos进行相同的功能使用。
修改提供者和消费者中的依赖和配置文件。
① 在pom文件中引入nacos-discovery依赖，==注释掉eureka的依赖== &lt;!--nacos注册中心客户端依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; ② 在application.yml中添加nacos地址，==注释掉eureka相关配置== spring: cloud: nacos: discovery: server-addr: localhost:8848 # 连接nacos注册中心 然后重启一下微服务，既然我们不使用Eureka了，那么Eureka的服务就不需要再启动了。
然后就可以进行访问测试了。 服务分级存储 这里的分级存储实际上就是增加的分类的类别，我们目前讨论的就只有微服务的区别，提供者和消费者，这里的分级存储又引入了服务集群的概念，一个服务可以有多个集群，这里就以地方作为分类类别，同一个服务可以在北京有一个服务集群，也可以在上海有一个服务集群。
服务调用尽可能选择本地集群的服务，跨集群（区域）调用延迟较高 。
① 将部分微服务配置到北京集群
spring: cloud: nacos: discovery: server-addr: localhost:8848 cluster-name: BJ # 服务所在集群名称 ② 新建1个user微服务配置到上海集群
-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH ③ 启动三个服务，并访问注册中心观察
④ 修改order-service的负载均衡策略
Ribbon默认的策略并不能实现根据同集群优先来实现负载均衡，需要切换成Nacos中的一个NacosRule来实现。
user-service: # 给某个微服务配置负载均衡规则，这里是user-service服务 ribbon: NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则 ⑤ 访问测试
多访问几次消费者，就会发现，提供者中，会优先查询相同集群下的微服务，而不会跨域查询另一个集群下的微服务，除非本集群中所有的提供者都失效了，才会去访问非同一集群下的提供者
权重配置 nacos支持权重配置来控制不同实例的访问频率，权重越大则访问频率越高。0 &lt;= 权重值 &lt;= 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f346a4237086e4fbdeb1bdf923b9b871/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76ca34c732bb1fde45ea428d02658115/" rel="bookmark">
			MySQL 中 Sum(1)与Count(1)的区别和联系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL中count和sum使用 count
COUNT()函数里面的参数是列名的的时候,那么会计算有值项的次数。（NULL 不计入， 但是''值计入）COUNT(*)可以计算出行数，包括null ，COUNT（1）也可以计算出行数，1在这里代表一行COUNT(条件表达式)，不管记录是否满足条件表达式，只要非NULL就加1 ，所以一般都count(id=1 or null) sum
sum()参数是列名的时候，计算列名的值的相加，不是统计有值项的总数sum(id=2) 当参数是表达式的时候，统计满足条件的行数 注：
上面id指列名，=后面的代表值 本文参考：MySQL中sum和count用法总结，如需转载请注明出处，
MySQL中count和sum使用 - lin_zone - 博客园
mysql sum(1)_简单说一下MySQL sum(1) count(1) 区别和联系 简单说一下MySQL sum(1) count(1) 区别和联系 - 豆豆2018 - 博客园
有人说sum(1) 相当于 count(1) ，其实还是有一点点差别;
1. 首先说一下使用过程中注意的点
sum(1) count(1) 使用过程中都有可能返回值为NULL,并不是统计不到就返回值为0
以下数据表实例
&lt;1&gt; 对于sum(1),如果带 where 条件查不到数据，则返回Null
1
SELECT sum(1) FROM tickets WHERE `order` &gt; 10000
&lt;2&gt; 对于 count(1) ,如果带 where 且 group by 操作， where条件下无数据，也会返回NUll 1
SELECT count(1) FROM tickets WHERE `order` &gt; 10000 GROUP BY priority
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76ca34c732bb1fde45ea428d02658115/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9977170963e884d6cce82c6162f2b0a/" rel="bookmark">
			Markdown For Typora
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Markdown For Typora Overview Markdown is created by Daring Fireball; the original guideline is here. Its syntax, however, varies between different parsers or editors. Typora is using GitHub Flavored Markdown.
文章目录 Markdown For TyporaOverviewBlock ElementsParagraph and line breaksHeadersBlockquotesListsTask List(Fenced) Code BlocksMath BlocksTablesFootnotesHorizontal RulesYAML Front MatterTable of Contents (TOC) Span ElementsLinksInternal LinksReference Links URLsImagesEmphasisStrongCodeStrikethroughUnderlinesEmoji :smile:Inline MathSubscriptSuperscriptHighlight HTMLEmbed ContentsVideoOther HTML Support Block Elements Paragraph and line breaks A paragraph is simply one or more consecutive lines of text.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9977170963e884d6cce82c6162f2b0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e4452ac59012060ee58333edeee234c/" rel="bookmark">
			Python数据分析12——Pyecharts使用文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 - pyecharts - A Python Echarts Plotting Library built with love.https://pyecharts.org/#/zh-cn/intro
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a49b3a906f34964d0633df0941eeecb/" rel="bookmark">
			输入百分制分数，给出相应的等级(C语言，switch语句)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入百分制分数，给出相应的等级：当分数大于等于90分时为A，80-89为B，70-79为C，60-69为D，60以下为E
例如：当输入的分数为100时，可以将其看成90分，因为100和90分对应的等级都为A，对输入的成绩使用除法（除以10），便可求出其高位数字，通过高位数字便可判断输出的成绩处于哪个等级。使用switch语句对：取出的高位数字进行选择判断，如果高位数为9则是A，如果是8则是B.....以此类推，分别出现C,D,E等。
程序代码如下：
#include &lt;stdio.h&gt; #define _CRT_SECURE_NONINGS 1 int main() { float score;//定义分数的变量 int s; printf("请输入您的成绩：\n"); scanf_s("%f", &amp;score);//接收用户的输入 if (score == 100) { score = 90; } s = score / 10; switch (s) { case 9: printf("等级：A\n"); break; case 8: printf("等级：B\n"); break; case 7: printf("等级C\n"); break; case 6: printf("等级：D\n"); break; default: printf("等级：E\n"); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88ff1aa0aa08506f45f5b5527984bb1b/" rel="bookmark">
			Linux 系统挂载大硬盘（＞2TB）及默认登录目录修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常安装系统按照引导方式+磁盘分区表方式有两种，即legacy+mbr或uefi+gpt，其中mbr和gpt一个重要的区别就是用mbr的分区表，最大可支持容量只有2t，超过2t及以上的部分就没法使用了。因此，如果买了2t以上的硬盘就要考虑使用gpt的分区表方式。
具体的，在硬盘接入主板并供电后，在Ubuntu系统中使用
sudo fdisk -l | grep /dev/sd 查找新加入的硬盘，例如为/dev/sdb，使用parted 切换到 sdb这块硬盘上
sudo parted /dev/sdb 输入 print 这时候还没有进行分区，会出现 unrecogonised disk label，建立gpt分区表(mbr 是 mklabel msdos)
mklabel gpt 再输入 print 就会看到 hdd硬盘存储空间为4001GB(以4TB 硬盘为例)，然后对sdb这块硬盘进行分区，这时候可以直接用0KB这种方式，也可以用百分比设置的方式进行，建议使用后者
mkpart primary 0KB 4001GB 或者 mkpart primary 0% 100% 接下来会提示Yes/No?回答y；提示Ignore/Cancel?回答i
然后再次输入print查看hdd硬盘的分区情况，最后输入quit退出parted工具即可完成硬盘分区。我这里只创建了一个分区，读者可以按照自己的需求创建多个分区，当然如果想要删除创建的分区，使用 rm 命令即可，例如rm 1, 具体可以参考博文。
分区以后对硬盘进行格式化处理，格式化成ext4，
sudo mkfs -t ext4 /dev/sdb1 或者 sudo mkfs.ext4 -F /dev/sdb1 接下来需要将硬盘挂载到系统的文件目录上，对于ubuntu系统用户来说，一般用户目录为/home/用户名，参考ubuntu的命名方法，这里在/ 目录下创建/home2目录，让新硬盘可以挂载，
sudo mkdir /home2 sudo mount /dev/sdb1 /home2 # 复杂一点的写法 sudo mount -t ext4 -o rw /dev/sdb1 /home2 # 卸载硬盘的挂载 sudo umount /dev/sdb1 具体的mount命令可以参考Linux mount命令 | 菜鸟教程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88ff1aa0aa08506f45f5b5527984bb1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/439136c06a2a660120087fc0f238e713/" rel="bookmark">
			js模糊匹配（like）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //js 模糊匹配(也就是sql中的like) //其实就是类似contain()方法，找到str2里面是否包含有str1，不存在返回-1，存在返回0 function like(str1,str2){ var result = str2.indexOf(str1); if(result&lt;0){ return false; }else{ return true; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9893bd17839e75ea0d711e8737d95189/" rel="bookmark">
			VSCode中值得推荐的常用的33个高效前端插件「效率篇」（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VSCode 是我们前端开发的一个强大的IDE，所以选择趁手好用的插件是提高开发效率，然后剩下的时间用来摸鱼是很有必要滴。
效率篇（33） Auto Rename Tag Auto Rename Tag : 自动重命名成对的 HTML/XML 标记，与 Visual Studio IDE 相同。
插件名：Auto Rename Tag官方地址：Auto Rename Tag - Visual Studio Marketplace特征： 当您重命名一个 HTML/XML 标签时，会自动重命名配对的 HTML/XML 标签用法：当您重命名一个 HTML/XML 的开始或结束标签时，会自动重命名配对的 HTML/XML 标签。 Auto Close Tag Auto Close Tag : 自动添加 HTML/XML 关闭标记，与 Visual Studio IDE 或 Sublime Text 一样。
插件名：Auto Close Tag官方地址：Auto Close Tag - Visual Studio Marketplace特征： 键入开始标签的右括号时自动添加结束标签插入结束标签后，光标在开始和结束标签之间设置不自动关闭的标签列表自动关闭自闭合标签支持 Sublime Text 3 的自动关闭标签使用键盘快捷键或命令面板手动添加关闭标签 用法：输入开始标签的右括号后，将自动插入结束标签 也可以安装 Auto Complete Tag 插件，它已经结合了自动关闭标签和自动重命名标签插件的功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9893bd17839e75ea0d711e8737d95189/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/364bf12d5257cd9ed2e44e6ec12e0b9a/" rel="bookmark">
			Flink部署——命令行界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 作业生命周期管理（Job Lifecycle Management）提交作业作业监控创建一个保存点设置保存点终止作业正常停止作业以创建最终保存点非优雅的停止作业 从保存点启动作业 CLI Actions高级命令行界面REST API选择部署目标提交 PyFlink 作业 Flink 提供了一个命令行界面 （CLI） bin/flink 来运行打包为 JAR 文件的程序并控制其执行。CLI 是任何 Flink 设置的一部分，可在本地单节点设置和分布式设置中使用。它连接到在conf/flink-conf.yaml中指定的正在运行的JobManager。
作业生命周期管理（Job Lifecycle Management） 本节中列出的命令工作的先决条件是运行 Flink 部署，如 Kubernetes、YARN 或任何其他可用的选项。您可以随意在本地启动 Flink 集群，在您自己的机器上尝试这些命令。
提交作业 提交作业意味着将作业的 JAR 和相关依赖项上传到 Flink 集群并启动作业执行。对于此示例，我们选择一个长时间运行的作业，如 examples/streaming/StateMachineExample.jar。您可以随意从 examples/文件夹中选择任何其他JAR存档或部署自己的作业。
$ ./bin/flink run \ --detached \ ./examples/streaming/StateMachineExample.jar 使用 --detached 提交作业将使该命令在提交完成后返回。输出包含（除其他内容外）新提交的作业的 ID。
Usage with built-in data generator: StateMachineExample [--error-rate &lt;probability-of-invalid-transition&gt;] [--sleep &lt;sleep-per-record-in-ms&gt;] Usage with Kafka: StateMachineExample --kafka-topic &lt;topic&gt; [--brokers &lt;brokers&gt;] Options for both the above setups: [--backend &lt;file|rocks&gt;] [--checkpoint-dir &lt;filepath&gt;] [--async-checkpoints &lt;true|false&gt;] [--incremental-checkpoints &lt;true|false&gt;] [--output &lt;filepath&gt; OR null for stdout] Using standalone source with error rate 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/364bf12d5257cd9ed2e44e6ec12e0b9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/472172964e13af06054a339578b9f1d0/" rel="bookmark">
			windows安装paddlepaddle遇到的问题及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次尝试学习paddlepaddle先根据githup上官方的安装方式进行安装
我装的是cpu版本，安装过程中遇到了以下错误：
错误一、
运行 python3 -m pip install paddlepaddle -i https://mirror.baidu.com/pypi/simple 报错信息如下：“error: Microsoft Visual C++ 14.0 or greater is required.“
解决方案：
参考网上方案Microsoft Visual C++ 14.0 or greater is required. Get it with "Microsoft C++ Build Tools"的解决办法 - 知乎 直接安装Microsoft C++ Build Tools，而不需要安装Visual Studio。
错误二、
运行 pip install "paddleocr&gt;=2.0.1" 命令后报错如下
“LINK : fatal error LNK1158: cannot run ‘rc.exe’”
解决方案：
参考LINK : fatal error LNK1158: cannot run 'rc.exe'_YapingXin的博客-CSDN博客
将rc.exe 、rcdll.dll复制一份到D:\Apps\x86\Microsoft\Visual_Studio\v14.0\VC\bin
错误三、
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/472172964e13af06054a339578b9f1d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3c35fc9bcb5fbe6fb51a915963a0c75/" rel="bookmark">
			VScode 函数与后面括号之间加空格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode的设置文件
在vscode的：文件 》首选项 》设置 》打开设置
代码如下：
{ // vscode默认启用了根据文件类型自动设置tabsize的选项 "editor.detectIndentation": false, // 重新设定tabsize "editor.tabSize": 2, // #每次保存的时候自动格式化 "editor.formatOnSave": true, // #每次保存的时候将代码按eslint格式进行修复 "eslint.autoFixOnSave": true, // 添加 vue 支持 "eslint.validate": [ "javascript", "javascriptreact", { "language": "vue", "autoFix": true } ], // #让prettier使用eslint的代码格式进行校验 "prettier.eslintIntegration": true, // #去掉代码结尾的分号 "prettier.semi": false, // #使用带引号替代双引号 "prettier.singleQuote": true, // #让函数(名)和后面的括号之间加个空格 "javascript.format.insertSpaceBeforeFunctionParenthesis": true, // #这个按用户自身习惯选择 "vetur.format.defaultFormatter.html": "js-beautify-html", // #让vue中的js按编辑器自带的ts格式进行格式化 "vetur.format.defaultFormatter.js": "vscode-typescript", "vetur.format.defaultFormatterOptions": { "js-beautify-html": { "wrap_attributes": "force-aligned" // #vue组件中html代码格式化样式 } }, // 格式化stylus, 需安装Manta's Stylus Supremacy插件 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3c35fc9bcb5fbe6fb51a915963a0c75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdab80b0970b5b104bf6c371d16381de/" rel="bookmark">
			利用labelme将json标签批量转换为png【图像分割数据集】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输出结果为：out_file文件下Image和GT两个文件夹，其中Image保存原图，GT保存mask，如下图。rename函数作用是将文件名字从XX_image1.jpg修改为image0001.jpg。
import json import os import os.path as osp import warnings import cv2 from labelme import utils import numpy as np import PIL.Image import PIL.ImageDraw def json2png(json_file, out_file): warnings.warn("This script is aimed to demonstrate how to convert the\n" "JSON file to a single image dataset, and not to handle\n" "multiple JSON files to generate a real-use dataset.") # freedom list_path = os.listdir(json_file) print('freedom =', json_file) for i in range(0, len(list_path)): print(i) path = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdab80b0970b5b104bf6c371d16381de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e7d61b5cc8551affec7320d611ec18a/" rel="bookmark">
			‘java-version‘ 不是内部或外部命令，也不是可运行的程序或批处理文件。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装好jdk和jre，并且配置好环境变量后，按下win+R键，出现“运行”窗口。在“打开（O）：”后面的输入栏输入“cmd”，然后点击确认。
点击确定后出现下面的小黑框：
在“C:\Users\86188&gt;”（你的电脑上不一定是这个路径，不管是什么，直接在后面输入就可以）后面输入“java-version”,然后按下回车键，查看当前自己电脑上的java版本：
按下回车键后，没有显示java版本，而是提示：'java-version' 不是内部或外部命令，也不是可运行的程序或批处理文件。
这是因为我们的命令输错了，java和横杠之间还要加一个空格。
验证：输入“java -version”,按下回车键，结果显示如下：
可以看到此时输出了java的版本“1.8.0_333” .
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eeae1293879cbf458e67fcd3d1d192d/" rel="bookmark">
			Ubuntu 20.04 安装Xcelium2009无法正常运行cdnshelp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		讲故事总得有个头啊
对于IC界的搬砖工，执着于对新鲜事物的追求，当EETOP上惊现Xcelium2009时，欣喜若狂，以迅雷不及掩耳之势完成XCELIUM的安装。
在命令行运行了一个简单的仿真，输出hello
随后启动simvision，点击help菜单中的cadence help library，呵呵。。。，不能正常打开，于是乎，直接运行帮助命令cdnsshelp
{install dir}/XCELIUM2009/bin/cdnshelp 由于Cadence各工具均有帮助命令，这里采用绝对路径启动。
意想不到的事情出现了，该命令不能正常启动，显示如下问题：
2022/06/26 03:02:41 WARNING This OS does not appear to be a Cadence supported Linux configuration. 2022/06/26 03:02:41 For more info, please run CheckSysConf in &lt;cdsRoot/tools.lnx86/bin/checkSysConf &lt;productId&gt; CadenceHelpv03.12 Build ID: 080320-91529 Copyright (c) 2006-2022 Cadence Design Systems, Inc. All rights reserved Launching gui.../opt/Cadence/XCELIUM2009/tools.lnx86/cdnshelp/bin/cdnshelp.exe /opt/Cadence/XCELIUM2009/doc/xmlreg/library.lbr Cadence Help logging started at /home/user/.config/cadence/cdnshelp.log file. 发现该命令运行异常，查看/cat /home/user/.config/cadence/cdnshelp.log，显示：
2022/06/26 03:02:41 WARNING This OS does not appear to be a Cadence supported Linux configuration.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eeae1293879cbf458e67fcd3d1d192d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e96438707af1fc8db740f9dcb8590400/" rel="bookmark">
			Unable to find the ncurses libraries or the required header files
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入内核目录，编译内核，执行make menuconfig时，提示如下：
*** Unable to find the ncurses libraries or the *** required header files. *** 'make menuconfig' requires the ncurses libraries. *** *** Install ncurses (ncurses-devel) and try again. *** scripts/kconfig/Makefile:202: recipe for target 'scripts/kconfig/dochecklxdialog' failed make[1]: *** [scripts/kconfig/dochecklxdialog] Error 1 Makefile:520: recipe for target 'menuconfig' failed make: *** [menuconfig] Error 2 但是我肯定是装了ncurses的，使用dpkg --get-selections |grep ncurse查看：
可以确认，ncurses确实安装了。
但是配置内核的时候，就是提示没装，后来，看了供应商给的内核编译命令，在执行make menuconfig之前还有两条命令：
unset LDFLAGS unset PKG_CONFIG_PATH 我照做之后，顺利的就可以进入到配置内核的界面了。
虽然这个问题解决了，但是由于它困扰了我很久，所以我决定看看为什么这两个环境变量会导致找不到ncurses，于是我exit退出命令行，然后重新进命令行，这次没用unset命令，并且打印了这两个环境变量的值：
echo $LDFLAGS -Wl,-O1 -Wl,--hash-style=gnu -Wl,--as-needed echo $PKG_CONFIG_PATH /opt/ros/kinetic/lib/pkgconfig:/opt/ros/kinetic/lib/x86_64-linux-gnu/pkgconfig:/opt/fsl-imx-xwayland/4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e96438707af1fc8db740f9dcb8590400/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98c3b0ff86a7e139a618cd2516bf8383/" rel="bookmark">
			西南交通大学高级语言程序设计(SCAI000812)第2次实验报告-学生成绩管理系统（链表版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景描述：
因为苦于网上到处都找不到答案，仅有的链表版还要收费，我就自己写了一个低配版链表，将就着用，想的是帮助明年以及后年的学弟学妹们。
题目描述：
实验目的：
掌握程序设计的基本算法和简单数据结构基础，能够综合运用基本控制语句、算法和数据结构，以及自顶向下、逐步求精的模块化设计方法，能够设计具有一定规模的系统级C语言程序，提高系统编程能力；针对计算相关的复杂工程问题，能够使用恰当的算法和数据结构，完成计算、统计、排序、检索、匹配等相关的软件系统的构造、测试与实现。 实验要求：
掌握常用的程序调试和测试方法。采用自顶向下、逐步求精的模块化设计思想设计一个简单的成绩管理系统。报告要求解释说明采用了什么数据结构和算法，为什么选择这种数据结构或算法(系统设计描述)，系统实现过程中遇到了哪些问题，这些问题是如何解决的，还有什么问题尚未解决，今后打算从哪几个方面进行改进，本设计的亮点和难点在哪里，实验结果如何，有哪些收获和学习体会(大作业反思)；编写程序完成以下实验(大作业)内容并完成实验报告。 实验内容：
某班有最多不超过30人（具体人数由实际输入决定）参加期末考试，最多不超过6门（具体门数由实际输入决定）。学生成绩管理系统是一个非常实用的程序，如果能够提前学习字符文件读写操作，把用户输入的数据存盘为字符文件，下次运行时读出，就更有用了。即编程实现如下菜单驱动的学生成绩管理系统：
（1）录入学生的学号、姓名和各科考试成绩；
（2）计算每门课程的总分和平均分；
（3）计算每个学生的总分和平均分；
（4）按每个学生的总分由高到低排出名次表；
（5）按每个学生的总分由低到高排出名次表；
（6）按学号由小到大排出成绩表；
（7）按姓名的字典顺序排出成绩表；
（8）按学号查询学生排名及其考试成绩；
（9）按姓名查询学生排名及其考试成绩；
（10）按优秀（90~100）、良好（80~89）、中等（70~79）、及格（60~69）、不及格（0~59）5个类别，对每门课程分别统计每个类别的人数以及所占的百分比；
（11）输出每个学生的学号、姓名、各科考试成绩，以及每门课程的总分和平均分；
（12）将每个学生的记录信息写入文件(可选实现)； （13）从文件中读出每个学生的记录信息并显示(可选实现)。
要求程序在输入课程门数以及所有课程名称后，先显示如下菜单，并提示用户输入选项：
代码实现：
初始化部分是当时我自己定义的（方便函数调试）
有需求的话自己改一下
另外须知，本程序可能有些地方会与题目要求略微不符（能力不够），请大家见谅。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef struct Student{ //定义学生结构体（链表模式） char name[15]; int sum; int number; int Math; int Chinese; int Physic; int English; int Biology; int Chemical; struct Student *next; }student; //测试用 student S[6] = {{"NULL",0,0,0,0,0,0,0,0}, {"b",0,102,99,99,99,99,99,99}, {"c",0,103,98,98,98,98,98,98}, {"d",0,104,97,97,97,97,97,97}, {"e",0,105,96,96,96,96,96,96}, {"f",0,106,95,95,95,95,95,95}}; //初始化，方便调试，并且头节点不存放数据 void sum(student *head) { //对每个学生的成绩求总分 student *p1 = head; //总分是在链表里面 while(p1-&gt;next !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98c3b0ff86a7e139a618cd2516bf8383/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb5f6fa05f37482b9a959edc3b74573b/" rel="bookmark">
			matlab中sum函数的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 向量的相加2 矩阵加法3 参数设定4 参考文献 在做方法模型的时候，不可避免的要读matlab代码。特别是做矩阵分解方法，所以积累一点matlab常见函数的用法，提高阅读代码的速度是非常有必要的。 现在介绍matlab中常用的sum函数：sum函数有两种用法 1 向量的相加 b=sum(a); a表示行向量，b表示行向量求和的值。
例子如下：
&gt;&gt;a=[1 2 3 4 5]; &gt;&gt;b=sum(a); b= 15 2 矩阵加法 生成一个矩阵以及使用sum函数对矩阵进行操作。在MATLAB默认的情况下，sum函数对矩阵的每一列的元素进行求和，结果是一个横向量。
调用格式：b=sum(a); a表示矩阵，b表示矩阵每列求和得到的行向量。
例子如下：
生成一个矩阵以及使用sum函数对矩阵进行操作。在MATLAB默认的情况下，sum函数对矩阵的每一列的元素进行求和，结果是一个横向量。
调用格式：b=sum(a); a表示矩阵，b表示矩阵每列求和得到的行向量。
例子如下：
&gt;&gt;a=[1 2 3 4 5 6 7 8 9]; &gt;&gt;sum(a)= [12 15 18]; 3 参数设定 设定sum函数的参数列表的参数dim，对矩阵每一列或者每一列求和或每一行求和，得到行向量或者列向量。
调用格式：b=sum(a,dim); a表示矩阵；dim等于1或者2，1表示每一列进行求和，2表示每一行进行求和；b表示求得的行向量。
例子如下：
&gt;&gt;a=[1 2 3 4 5 6 7 8 9]; &gt;&gt;sum(a,1)=[12 15 18]; &gt;&gt;sum(a,2)=[ 6 15 24]; 4 参考文献 [1]MATLAB 函数sum的用法简介
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4c065613e89cfb0216c32ee3e8a234f/" rel="bookmark">
			梯度消失问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是梯度消失
梯度消失产生的原因
梯度消失解决方法
什么是梯度消失 梯度消失问题( vanishing gradient)是在早期的BP网络中比较常见的问题。这种问题的发生会让训练很难进行下去，看到的现象就是训练不再收敛——Loss过早地不再下降,而精确度也过早地不再提高。
梯度消失产生的原因 我们还是来看一个具体的例子:
就是两个节点首尾相接组成的神经网络(应该说连“线”都算不上)，这其中位于网络前部的w1的更新就需要计算损失函数对w,的偏导数，在这个函数里，根据链式法则我们能够得到,前面的这个神经元的w,的导数是这样一个表达式:
其中我们发现第一项关于中z_2的偏导数和第三项关于z_1的偏导数其实就是Sigmoid函数的斜率，Sigmoid函数的图像如图
Sigmoid函数比较致命的缺点就是在自变量处于小于-5或者大于5的部分，他的斜率几乎处于水平了，即导数几乎为零，这就像一个陷阱，万一我们上面所说的第一项关于中z_2的偏导数和第三项关于z_1的偏导数正好处于陷阱时，会使整个导数的值也是接近0的状态，这样误差在向前传递的过程中会导致网络前端的w几乎没什么变化，因为单数实在是太小了，多个网络层的的导数连乘，从而越来越小，而且网络层级越多，越往前的隐藏层这种情况就越糟糕———w变化就越慢,也就是说，这一层没能学到什么东西。这就是我们所说的梯度消失问题，也叫作梯度弥散问题。
既然我们弄清楚了，导致梯度消失问题的原因是因为在对参数求偏导时，根据链式法则得到的连乘式中多个几乎为0的导数值连乘导致，那么我们就可以提出相应的解决办法。
导数小导致每次更新时的值过小，那么相反，导数大就应该会使更新的数值比较大，更新速度比较快。所以无非就是要消除这种链式发着中发生的每一项绝对值小于1的情况呗。
让我们再来看一下例子中的两个导数值：
第二项其实就是sigmoid函数求导，即
所以在这里我们的想法就是让连乘大于等于1。
梯度消失解决方法 我们可以尝试一下如下方法
方法1：将w初始化大一些
假设我们把w初始化成10，在 Sigmoid函数为0的地方，导数的绝对值是4,当 lwl=10的时候=2.5。这个值确实够大了，但是大就一定好么，未必。
同样是链式法则的连乘关系，原来是因为导数太小导致网络前端的w变化太慢，这么一改之后反过来了，网络前端的变化率太高了，一次的变化量非常大。就拿刚刚这个例子来说，如果有10层，10个2.5相乘就是9536左右。俗话说“过犹不及”，这就算是一个很小的n也能一下子从地下挪到天上去，这种现象叫做梯度爆炸( gradient explording)，也叫作梯度膨胀。
综上可知，这种方法似乎并不理想，那让我们看下一个方法。
方法二：选取合适的激活函数
既然sigmoid函数本身就有缺陷，那么我们就从根上解决问题，直接换激活函数！那是否有合适的激活函数呢？还真有，那就是ReLU激活函数，ReLU激活函数的图像如下
这个函数的形式为y=max(x,0)，这个函数在原点左侧部分斜率为0，在右侧则是一条斜率为1的直线。函数在x大于0的部分是呈现出线性特点的，在小于0的时候则是一条直线，这个锋利的弯折提供了良好的非线性特点。尤其注意它在第一象限的这条直线，它的导数恒为.1，这是它的“激活”状态;x小于0的部分导数恒为0，这是它的“非激活”状态。所以它的优点有两个应该是显而易见的。
其一，在第一象限中不会有明显的梯度消失问题，因为导数恒为1，而w在初始化的时候也是有大有小，连乘的时候不会轻易出现很小或者很大的数值，这就是一个非常好的特性了。
其二，由于导数为1，所以求解它的导数要比求解Sigmoid函数的导数代价要小一些，这里说的代价主要是时间代价。前面咱们说了求导数要在函数的这个点上用Loss(w+A)-Loss(x)的古社击求这个计算的次数可就比直接拿一个1出来麻烦多了，尤其是在损失函数里的w很多的时候，一次计算所消耗的计算资源就太多了，速度会变慢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2ade342aca05f0f698bd0cdb36fbd3d/" rel="bookmark">
			Servlet（IDEA创建Maven工程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Servlet简介 Servlet是sun公司开发动态web的一门技术Sun公司在这些API中提供一个接口，叫做：Servlet，如果你想开发一个Servlet程序，其实只需要完成两个步骤： 编写一个类，实现Servlet接口把开发好的Java类部署到Web服务器中 总结一句话：把实现了Servlet接口的Java程序叫做Servlet HelloServlet 创建一个普通干净的Maven项目、删掉里面的src目录，以后学习就在这项目里面建立Model；这个空的工程就是Maven的主工程。我们把需要的Maven依赖导入，以后就不用重复导入外层是个普通的Maven项目，第二步我们在创建好的Maven项目上new一个webapp项目 可以看到，刚开始创建的普通项目中多了一个子模块，并且在导入Maven的一些东西
关于Maven父子工程的理解 在我们刚开始创建的普通Maven项目的基础上创建子项目，也就是我们的web项目
在父项目中会有modules
而子项目就会有parent
父项目中的jar包，子项目可以直接使用
将web.xml里的配置改成我们所需要的 代码如下
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0" metadata-complete="true"&gt; &lt;/web-app&gt; 然后我们在子项目的main文件夹下创建java和resources，并且把资源标记一下。
修改资源文件夹的颜色在这里
Maven环境优化 修改web.xml为最新的将Maven的结构搭建完整 编写一个Servlet程序 编写一个普通类 2.实现Servlet接口，这里我们直接继承HttpServlet
package com.godairo.servlet; import javax.servlet.ServletException; import javax.servlet.ServletOutputStream; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; public class HelloServlet extends HttpServlet { //由于get或者post只是请求实现的不同方式，可以相互调用，因为业务逻辑都一样； @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //ServletOutputStream outputStream = resp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2ade342aca05f0f698bd0cdb36fbd3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8856329d9bfcee6ebb60e1fb98f664a0/" rel="bookmark">
			npm下载node-sass 报错Cannot download https://github.com/sass/node-sass/releases/download/v3.4.2/win32...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm install node-sass
Cannot download https://github.com/sass/node-sass/releases/download/v3.4.2/win32-x64-46_binding.nodeHint: If github.com is not accessible in your locationtry setting a proxy via HTTP_PROXY, e.g.export HTTP_PROXY=http://example.com:1234or configure npm proxy vianpm config set proxy http://example.com:8080'
很简单的一条命令，但是结果却不尽如人意，简单看了下别人介绍，原因是走外国网络，安装失败。
网上有说翻墙的、有说用淘宝镜像的，然而有些地方网络限制还是失败。
后来找到一种方法，下载node-sass文件的方式，很顺利。
1. 执行命令 node -p "[process.platform, process.arch, process.versions.modules].join('-')"，复制输出内容。例如：win32-x64-64
2. 进入安装包页面https://github.com/sass/node-sass/releases，搜索复制内容，下载win32-x64-64_binding.node文件，放入nodejs安装目录：C:/Program Files/nodejs/node_modules/npm/win32-x64-64_binding.node
3. 修改~/.npmrc增加：sass_binary_path=C:/Program Files/nodejs/node_modules/npm/win32-x64-64_binding.node，路径即为第二步的路径。
4. npm i --save node-sass就可以顺利安装了。
作者：hapy_c124
链接：https://www.jianshu.com/p/d390136298da
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7bf2a816a2cf156194b7a8a263330ac/" rel="bookmark">
			Git拉取指定文件或者文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行项目开发的时候，有时候会有这样的需求那就是：
我们只希望从Git仓库里取指定的文件或者文件夹出来。在SVN里面，这非常容易实现，因为SVN基于文件方式存储，而Git却是基于元数据方式分布式存储文件信息的，它会在每一次Clone的时候将所有信息都取回到本地，即相当于在你的机器上生成一个克隆版的版本库。因此在Git1.7.0以前，这无法实现，但是幸运的是在Git1.7.0以后加入了Sparse Checkout模式，这使得Check Out指定文件或者文件夹成为可能。
仓库只有一个的情况下，只想拉取某个目录文件；其他文件没用到的会很浪费时间；
关键：git的sparse checkout模式
理论 github.io
“Sparse checkout” 允许稀疏地填充工作目录。它使用 skip-worktree 位（参见git-update-index(1)）告诉 Git 工作目录上的文件是否值得查看。
“git read-tree”和其他基于合并的命令（“git merge”、“git checkout”……）可以帮助维护跳过工作树位图和工作目录更新。$GIT_DIR/info/sparse-checkout用于定义跳过工作树参考位图。当“git read-tree”需要更新工作目录时，它会根据这个文件重新设置索引中的skip-worktree位，它使用与.gitignore文件相同的语法。如果条目与此文件中的模式匹配，则会在该条目上设置 skip-worktree。否则 skip-worktree 将被取消设置。
然后它将新的跳过工作树值与前一个值进行比较。如果 skip-worktree 从 unset 变为 set，它将添加相应的文件。如果它从设置变为未设置，则该文件将被删除。
虽然$GIT_DIR/info/sparse-checkout通常用于指定哪些文件在其中。您还可以使用否定模式指定哪些文件不在其中。例如，要删除“不需要的”文件：
* !不需要的 另一个棘手的事情是当您不再需要sparse checkout完全重新填充工作目录。您不能只禁用“sparse_checkout”，因为 skip-worktree 仍在索引中，并且您的工作目录仍然很少填充。您应该使用$GIT_DIR/info/sparse-checkout文件内容重新填充工作目录，如下所示：
* 然后您可以禁用Sparse_checkout。默认禁用“git read-tree”和类似命令中的Sparse checkout支持。您需要打开core.sparseCheckout以获得Sparse checkout支持
大致步骤 1，本地新建文件夹或者执行命令
mkdir project &amp;&amp; cd project 2，目录初始化
git init 3，设置远程仓库地址(将本地仓库关联到远程仓库)
git remote add -f origin &lt;origin_url&gt; 4，设置sparse checkout模式(稀疏检出)，允许克隆子目录
git config core.sparsecheckout true	//config：参数是用来配置git环境的 # 上面的代码会帮助我们创建一个空的本地仓库，同时将远程Git Server URL加入到Git Config文件中。 5，设置指定拉取的目录（ *是通配符，!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7bf2a816a2cf156194b7a8a263330ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f287a37b31b07924c38dac6b550eb59/" rel="bookmark">
			数学建模——非线性规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基本概念
凸规划
判别定理
二次规划模型
非线性规划的求解
无约束极值问题
有约束极值问题
基于求解器的解法
基于问题的求解
其他
非线性规划：描述目标函数或约束条件条件的数学表达式中，至少有一个是非线性函数。
基本概念 记是n维欧式空间中的一个点（n维向量），，，是定义在上的实值函数。若f,g,h函数中至少有一个是x的非线性函数，则称如下为非线性规划模型的一般形式：
全局最优解：若，并且都有，则称为全局最优解。
局部最优解：x的邻域内（也包含于可行域），x所对应的函数值是最小的，则x为局部最优解。
无约束非线性规划问题可以具体表示为：
凸规划 凸规划是一类特殊的非线性规划问题，可以求得全局最优解。
凸集：
凸函数：
定义在凸集上的有限个凸函数的非负线性组合仍为凸函数
判别定理 半正定矩阵的行列式非负。
黑塞矩阵：
对于非线性规划模型的一般形式，若f(x)为凸函数，g(x)为凸函数，h(x)为线性函数，则称该非线性规划问题为凸规划。凸规划局部最优解即为全局最优解，最优解的集合形成一个凸集。当目标函数为严格凸函数时，其最优解必定唯一。
例子
f(x)和g2(x)的黑塞矩阵的行列式：
其他约束条件为线性函数，所以是一个凸规划问题
clc,clear prob = optimproblem; x = optimvar('x',2,'LowerBound',0); prob.Objective = sum(x.^2)-4*x(1)+4; con = [-x(1)+x(2)-2 &lt;= 0 x(1)^2-x(2)+1 &lt;= 0]; prob.Constraints.con = con; x0.x = rand(2,1)%非线性规划必须赋初值，x0名字随便取 [s,f,flag,o] = solve(prob,x0); s.x ans =
0.5536
1.3064
二次规划模型 目标函数是关于决策向量的二次函数，约束条件是线性的，则该模型称为二次规划模型，一般形式：
其中：
当H正定时，目标函数最小化时，模型为凸二次规划，凸二次规划局部最优解就是全局最优解。如果不是凸规划，则建议使用fmincon函数。
例子
目标函数是最小化，但是H为负定矩阵，所以不是凸规划。
clc,clear x = optimvar('x',2,'LowerBound',0); h = [-1,-0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f287a37b31b07924c38dac6b550eb59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c98095d51147430c721f3ac7fa404554/" rel="bookmark">
			java上传超大文件解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：因自己负责的项目(jetty内嵌启动的SpringMvc)中需要实现文件上传，而自己对java文件上传这一块未接触过，且对 Http 协议较模糊，故这次采用渐进的方式来学习文件上传的原理与实践。该博客重在实践。
一. Http协议原理简介 HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。
简单来说，就是一个基于应用层的通信规范：双方要进行通信，大家都要遵守一个规范，这个规范就是HTTP协议。
1.特点：
(1)支持客户/服务器模式。
(2)简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
(3)灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
(4)无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
(5)无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
注意：其中(4)(5)是面试中常用的面试题。虽然HTTP协议（应用层）是无连接，无状态的，但其所依赖的TCP协议（传输层）却是常连接、有状态的，而TCP协议（传输层）又依赖于IP协议（网络层）。
2.HTTP消息的结构
(1)Request 消息分为3部分，第一部分叫请求行， 第二部分叫http header消息头, 第三部分是body正文，header和body之间有个空行， 结构如下图
(2)Response消息的结构， 和Request消息的结构基本一样。 同样也分为三部分，第一部分叫request line状态行， 第二部分叫request header消息体，第三部分是body正文， header和body之间也有个空行， 结构如下图
下面是使用Fiddler捕捉请求baidu的Request消息机构和Response消息机构：
因为没有输入任何表单信息，故request的消息正文为空，大家可以找一个登录的页面试试看。
先到这里，HTTP协议的知识网上很丰富，在这里就不再熬述了。
二. 文件上传的三种实现
1. Jsp/servlet 实现文件上传
这是最常见也是最简单的方式
(1)实现文件上传的Jsp页面 (2)负责接文件的FileUploadServlet
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.log4j.Logger;
// @WebServlet(name = "FileLoadServlet", urlPatterns = {"/fileload"})
public class FileLoadServlet extends HttpServlet {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c98095d51147430c721f3ac7fa404554/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6692fc8fb62f8b51e1a82c6706b92dd/" rel="bookmark">
			Vue打包项目报错 Uncaught SyntaxError: Unexpected token ‘＜‘ 的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 好不容易工作进入到了打包环节，却又开始报错，报错文件是一个JS文件：
JS文件打开以后是这样的
问题：应该是文件引入的问题，开始找解决方法
在网上找了一些浏览量很高的方法，试过的如下：
1、 添加externals的配置
2、 把assets文件夹下的内容放到public下
3、将引入Router的模式改为“hash”
试过了之后都无效，非常的头疼（也有可能是我设置的方式也存在问题）
最终找到了一篇文章解决，使用一行配置搞定，在vue.config.js文件中加入：
//使用路径 Uncaught SyntaxError: Unexpected token ‘＜‘ 的解决方法 publicPath: process.env.NODE_ENV === "production" ? "./" : "/", 原文章地址在这里：原文章链接
2022-6-23号更新：
最近的使用中，还发现出现一种可能：引入的cdn地址已经不再使用，需要使用新的cdn地址：
新地址为：【vue.config.js文件中】
//开发环境中 js: [ '//fastly.jsdelivr.net/ajax/libs/vue/2.6.14/vue.min.js', '//fastly.jsdelivr.net/ajax/libs/vue-router/3.5.1/vue-router.min.js', '//fastly.jsdelivr.net/ajax/libs/vuex/3.1.1/vuex.min.js', '//fastly.jsdelivr.net/ajax/libs/axios/0.21.1/axios.min.js' ] //生产环境中 js: [ '//cdn.bootcdn.net/ajax/libs/vue-router/3.5.1/vue-router.min.js', '//cdn.bootcdn.net/ajax/libs/vuex/3.1.1/vuex.min.js', '//cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js' ] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c5005ffd1fc515aef9cd85e09530da2/" rel="bookmark">
			Java内存模型之重排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：
在单线程环境下不能改变程序运行的结果；
存在数据依赖关系的不允许重排序
如果看过LZ上篇博客的就会知道，其实这两点可以归结于一点：无法通过happens-before原则推导出来的，JMM允许任意的排序。
as-if-serial语义 as-if-serial语义的意思是，所有的操作均可以为了优化而被重排序，但是你必须要保证重排序后执行的结果不能被改变，编译器、runtime、处理器都必须遵守as-if-serial语义。注意as-if-serial只保证单线程环境，多线程环境下无效。
下面我们用一个简单的示例来说明：
int a = 1 ; //A int b = 2 ; //B int c = a + b; //C A、B、C三个操作存在如下关系：A、B不存在数据依赖关系，A和C、B和C存在数据依赖关系，因此在进行重排序的时候，A、B可以随意排序，但是必须位于C的前面，执行顺序可以是A –&gt; B –&gt; C或者B –&gt; A –&gt; C。但是无论是何种执行顺序最终的结果C总是等于3。
as-if-serail语义把单线程程序保护起来了，它可以保证在重排序的前提下程序的最终结果始终都是一致的。
其实对于上段代码，他们存在这样的happen-before关系：
A happens-before B
B happens-before C
A happens-before C
1、2是程序顺序次序规则，3是传递性。但是，不是说通过重排序，B可能会排在A之前执行么，为何还会存在存在A happens-beforeB呢？这里再次申明A happens-before B不是A一定会在B之前执行，而是A的对B可见，但是相对于这个程序A的执行结果不需要对B可见，且他们重排序后不会影响结果，所以JMM不会认为这种重排序非法。
我们需要明白这点：在不改变程序执行结果的前提下，尽可能提高程序的运行效率。
下面我们在看一段有意思的代码：
public class RecordExample1 { public static void main(String[] args){ int a = 1; int b = 2; try { a = 3; //A b = 1 / 0; //B } catch (Exception e) { } finally { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c5005ffd1fc515aef9cd85e09530da2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7434b389aadc0d3c8f6715c86681590d/" rel="bookmark">
			java中的静态方法是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 静态方法是使用公共内存空间的，就是说所有对象都可以直接引用，不需要创建对象再使用该方法。
然后在含有main方法的类中使用这个类时，对与以上非静态和静态方法的引用方式是不同的，如下：
public class mainClass{ int sum; public static void main(String args[]){ sum=Test.a(1,2); //直接用 类.方法或者属性就可以使用该方法或属性。 System.out.print(sum); Test t=new Test(); sum=t.b(1,2); //因为b不是静态方法,只能只能用Test类创建一个t对象，然后调用该对象的方法。 System.out.print(sum); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d8fcc0e450f1d31421b7d8a97a177ef/" rel="bookmark">
			python-opencv图像处理-腐蚀和膨胀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		17.python-opencv图像处理-腐蚀和膨胀 第一章 python-opencv-图片导入和显示
第二章 python-opencv图像简单处理
第三章 python-opencv图像mask掩膜处理
第四章 python-opencv图像马赛克
第五章 python-opencv人脸马赛克
第六章 python-opencv人脸检测
第七章 python-opencv图像张贴
第八章 python-opencv轮廓绘制
第九章 python-opencv边缘检测
第十章 python-opencvpython-opencv边缘检测与人脸检测应用
第十一章 python-opencv直方图绘制与直方图均衡
第十二章 python-opencv图像傅里叶变换
第十三章 python-opencv图像的高通滤波和低通滤波
第十四章 python-opencv视频中的人脸检测
第十五章 python-opencv视频人脸检测和保存
第十六章 python-opencv使用摄像头实时人脸检测
文章目录 17.python-opencv图像处理-腐蚀和膨胀前言完整代码部分代码说明腐蚀腐蚀原理：腐蚀代码腐蚀代码定义参数说明 膨胀膨胀原理膨胀代码膨胀代码定义参数说明 结果展示腐蚀结果膨胀结果 前言 本篇博客主要介绍如何使用python-opencv对图像进行腐蚀和膨胀图像处理。
完整代码 import numpy as np import cv2 if __name__ == '__main__': # 加载图片，并将图片转化为灰度图像 img = cv2.imread('./tong.jpg',flags=cv2.COLOR_BGR2GRAY) # 设置腐蚀和膨胀核 kernel = np.ones(shape=[3,3],dtype=np.uint8) # 通过shape=[3,3]可以改变处理效果 # 腐蚀，由多变少，边界容易被腐蚀,去除噪声 img1 = cv2.erode(img,kernel=kernel) # 膨胀，图像变粗 img2 = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d8fcc0e450f1d31421b7d8a97a177ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42c6a7f66fbb04d0f6006dad989a86d2/" rel="bookmark">
			批量修改指定字符文件名 bat脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@echo off set /p str1= 请输入要替换的文件(文件夹)名字符串（可替换空格）： set /p str2= 请输入替换后的文件(文件夹)名字符串（若删除直接回车）： echo. echo 正在操作中，请稍候…… for /f "delims=" %%a in ('dir /s /b ^|sort /+65535') do ( if "%%~nxa" neq "%~nx0" ( set "file=%%a" set "name=%%~na" set "extension=%%~xa" call set "name=%%name:%str1%=%str2%%%" setlocal enabledelayedexpansion ren "!file!" "!name!!extension!" 2&gt;nul endlocal ) ) exit 直接在要修改的文件下创建.bat文件，将上面代码放到文件中即可，双击执行。
转载：https://blog.csdn.net/weixin_43042683/article/details/108453639
实测 可行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84690c7c6fc9470db7bd648e883fa963/" rel="bookmark">
			2022面试，Java面试项目推荐，15个项目吃透两个offer拿到手软
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目名称：JeeSite 项目所用技术栈：Spring、Spring MVC、MyBatis、Apache Shiro、Bootstrap UI等
项目简介：JeeSite 是一个 Java EE 企业级快速开发平台，基于经典技术组合（Spring Boot、Spring MVC、Apache Shiro、MyBatis、Beetl、Bootstrap、AdminLTE）采用经典开发模式，让初学者能够更快的入门并投入到团队开发中去。在线代码生成功能，包括核心模块如：组织机构、角色用户、菜单及按钮授权、数据权限、系统参数、内容管理、工作流等。采用松耦合设计；界面无刷新，一键换肤；众多账号安全设置，密码策略；在线定时任务配置；支持集群，支持SAAS；支持多数据源；支持微服务。
由于平台限制，这里不能直接放源码链接，所以文中这15个项目源码和开发文档都给你们整理好了，转发本文+关注+私信【308】即可获取
项目名称：XMall商城 项目所用技术栈：SSM、Elasticsearch、Redis、MySQL、ActiveMQ、Shiro、Dubbo、Zookeeper、Vue.js 等
项目简介：XMall是一个基于SOA架构的分布式电商购物商城，并且前后端分离。包括如下几大模块：
后台管理系统：管理商品、订单、类目、商品规格属性、用户、权限、系统统计、系统日志以及前台内容等功能前台系统：用户可以在前台系统中进行注册、登录、浏览商品、首页、下单等操作会员系统：用户可以在该系统中查询已下的订单、管理订单、我的优惠券等信息订单系统：提供下单、查询订单、修改订单状态、定时处理订单搜索系统：提供商品的搜索功能单点登录系统：为多个系统之间提供用户登录凭证以及查询登录用户的信息 是初学者练手的不错的项目。
项目名称：Cloud-Platform 项目所用技术栈：Spring Boot、Spring Cloud全家桶、Vue.js等
项目简介：Cloud-Platform是国内首个基于Spring Cloud的微服务开发平台，具有统一授权、认证后台管理系统，其中包含具备用户管理、资源权限管理、网关API 管理等多个模块，支持多业务系统并行开发，可以作为后端服务的开发脚手架。代码简洁，架构清晰，适合学习和直接项目中使用。
项目名称：Piggy Metrics 项目所用技术栈：Spring Boot、Spring Cloud、Docker等
项目简介：Piggy Metrics是一个基于Spring Boot, Spring Cloud和Docker等技术实现的微服务脚手架，项目包含了：API网关、服务发现、负载均衡、熔断机制、配置中心、监控服务、认证服务等几大微服务项目基本模块，对学习和练手微服务项目是不错的选择。
项目名称：mall 项目所用技术栈：Spring Boot、Spring Security、MyBatis、Elasticsearch、RabbitMq、Redis、MongoDb、Docker 、Vue.js等
项目简介：mall项目是一套电商系统，包括前台商城系统及后台管理系统，基于SpringBoot+MyBatis实现，采用Docker容器化部署。前台商城系统包含首页门户、商品推荐、商品搜索、商品展示、购物车、订单流程、会员中心、客户服务、帮助中心等模块。后台管理系统包含商品管理、订单管理、会员管理、促销管理、运营管理、内容管理、统计报表、财务管理、权限管理、设置等模块。
项目名称： JeeSite 项目介绍：
这是个典型的SSM后台管理项目（不是有很多小伙伴让推荐SSM项目练手嘛），基于经典技术组合（Spring MVC、Shiro、MyBatis、Bootstrap UI等）开发，适合学习练手。
而且它作为一个典型的后台管理系统，要素基本都有，包括：组织机构、角色用户、权限授权、数据权限、内容管理、工作流等。
尤其要提的就是最后的工作流模块，它可以实现提工单、审核/审批等流程，这个在后台管理类项目里是必备的模块。
项目名称：platform-wechat-mall 项目介绍：
该项目是一个开源的微信小程序商城，虽说其项目技术栈不算特别新，后端用的也是SSM框架，但是它作为一个商城项目，要素模块基本都包含了，比如：系统后台管理、商品后台管理、移动端商城的API接口、手机移动端商城、微信小程序商城等等。
而且主要功能也非常丰富，包括：会员管理、商城配置、商品管理、推广管理、订单和系统管理等等。
秒杀类项目 项目名称：spring-boot-seckill
项目介绍：
秒杀类开源项目其实很难得，毕竟涉及高并发的一些问题嘛，这些在面试时都是能让面试官眼前一亮的东西。
这个项目与其说是一个开源项目，倒不如说是一些具体秒杀问题里面的案例集合。
秒杀系统基本设计思想无非也就是：限流、缓存、异步、分摊、主备，其实某一程度上来说就是开源+节流的思想。
所以通过它应该能学到一些比CRUD高级一些的技术，诸如：线程池、锁、分布式锁、消息队列（kafka）、缓存（redis） 等等。
支付类项目 项目名称：roncoo-pay
项目介绍：
支付系统嘛，集成了主流支付方式、支付平台等，除此之外它还有些额外的管理功能，比如对账、结算、交易订单的管理等等，所以也有后台管理的。
该项目的技术栈也是后端的主流技术，包括：Spring Boot、Shiro、MyBatis、Redis等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84690c7c6fc9470db7bd648e883fa963/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75ae1532ce25a8e0fd98b8a30c4e7fd9/" rel="bookmark">
			Centos8安装进入设置安装源失败问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题一 一． 安装CentOS，在本机安装双系统，如果不是双系统的跳过此步。
用UltraISO刻录CentOS镜像到U盘，在菜单中选择“启动-&gt;写入硬盘映像”，再选择USB-HDD+即可。在磁盘管理中分出一块空闲的区域用于安装CentOS，至少要60G。启动的时候，选择u盘启动，在安装菜单上按”e”键，编辑安装命令，删除label=…，改为Linux dd，按ctrl+x执行命令，查看U盘所在的盘符，一般为/dev/sda4。重启计算机，编辑安装菜单，将引导改为hd:/dev/ sda4（每个计算机可能不同，设定成实际的盘符），按ctrl+x执行安装引导。选择安装工作站，对于开发系统用工作站版本，如果是服务器使用带图像的服务器版本。 问题二：安装镜像无法从本地源安装； 设置阿里源
https://mirrors.aliyun.com/centos-vault/8.4.2105/BaseOS/x86_64/os/
安装成功后换源 先把/etc/yum.repos.d/ 下的文件备份
然后执行：
wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo
wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo
yum install clear
yum makecache
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9965abbff63af4f5dc53b7e63edd02b8/" rel="bookmark">
			js实现页面元素的拖拽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平时在我们页面上，经常会悬浮着一些功能按钮，如帮助，联系客服等，按钮的显示比较简单，用定位悬浮在自己需要的位置上就行，比如下面的页面上我们展示一个帮助的按钮，用户点击后可以展示一些帮助的信息：
代码：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;style type="text/css"&gt; .help-btn { width: 50px; height: 50px; border-radius: 50%; background: blue; color: #fff; position: fixed; display: flex; align-items: center; justify-content: center; cursor: pointer; right: 0; bottom: 150px; } &lt;/style&gt; &lt;title&gt;js实现拖拽&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="help-btn" id="help-btn"&gt;帮助&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 但是这样定位一般是固定在这个位置，如果这时候刚好【帮助按钮】挡住了这个位置原本有的其他操作按钮，那么我们就需要能够把【帮助按钮】拖开，不影响原本页面上的操作。
一般实现拖动的思路是：在【帮助按钮】上鼠标按下时，记录下当前的坐标，以及原本相对于父元素的位置，然后监听【帮助按钮】的鼠标移动事件【onmousemove】，然后取现在的坐标，计算出两轴上移动的距离，用原本的位置减去移动的位置得到现在的位置，再重新设置给【帮助按钮】即可。最后在【帮助按钮】鼠标抬起事件【onmouseup】上注销对鼠标移动的监听即可。
代码：
&lt;script type="text/javascript"&gt; let btnEle = document.getElementById("help-btn"); //帮助按钮鼠标按下时 btnEle.onmousedown = (e) =&gt; { let defaultX = e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9965abbff63af4f5dc53b7e63edd02b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/209d2befded6b016dbb99680eb8f44da/" rel="bookmark">
			Unity的Ping类使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.目的 1.1 准备ping网络，查看是否能够ping通，ping通代表网络链接正常 2.参考 2.1 Unity 之 Ping类简析&amp;尝试使用_陈言必行的博客-CSDN博客
3.注意 3.1 发现不怎么好用， 明明能够ping通，却显示ping不通里面没有变量显示 是否ping的通，ping_zhuJi.time=-1 ms ，实际上电脑可以ping通， 代码如下
ping_zhuJi.time主要以这个和0比较判断是否链接上 using System.Collections; using System.Collections.Generic; using UnityEngine; /// &lt;summary&gt; /// 【Function:ping网络】【Time:2022 06 20】【Author:XZY】 /// &lt;/summary&gt; public class PingNet : MonoBehaviour { /// &lt;summary&gt;主机的ip，目的为了ping它是否通&lt;/summary&gt; [HideInInspector] //public string ip_zhuJi = "192.168.1.111"; public string ip_zhuJi = ""; /// &lt;summary&gt;Ping对象：主机的&lt;/summary&gt; Ping ping_zhuJi=null; /// &lt;summary&gt;Ping对象：后台的&lt;/summary&gt; Ping ping_server; /// &lt;summary&gt;协程：检测是否长时间没有ping通，如果是代表ping不通&lt;/summary&gt; private Coroutine coroutine_isPingSuccess=null; /// &lt;summary&gt;ping一次的时间&lt;/summary&gt; private float waitForSeconds_IE_isPingSuccess = 5; /// &lt;summary&gt;ping失败的次数,与协程waitForSeconds_IE_isPingSuccess有关系&lt;/summary&gt; private int numPingFail = 0; /// &lt;summary&gt;ping失败多少次为失败&lt;/summary&gt; private int totalPingFail = 3; public static PingNet instance = null; //public int NumPingFail { get =&gt; numPingFail; set =&gt; numPingFail = value; } private void Awake() { if (instance == null) { instance = this; } } private void Start() { //coroutine_isPingSuccess = StartCoroutine(IE_isPingSuccess()); //StartCoroutine(IE_GetIp_zhuJi()); //StartCoroutine(IE_StartPing()); } //IEnumerator IE_GetIp_zhuJi() //{ // yield return new WaitForSeconds(5); // string _ip = SmartPlayerAndroidMono.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/209d2befded6b016dbb99680eb8f44da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e5323e9d09255008c36f37b520dec1a/" rel="bookmark">
			Topaz DeNoise AI for Mac(AI智能图像降噪工具)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Topaz DeNoise AI for Mac是最好用的AI智能图像降噪工具，DeNoise AI通过消除噪点的同时恢复原始图像细节，帮助您获得100％的最佳质量。
Topaz DeNoise AI for Mac(AI智能图像降噪工具)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9893192ad83213d9dc34d623afc06b09/" rel="bookmark">
			02.分布式日志采集ELK&#43;Kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课程标题:&lt;基于ELK+Kafka构建分布式日志采集系统&gt;
1.传统日志采集存在哪些缺点
2.elk+kafka日志采集的原理
3.基于docker compose 安装elk+kafka环境
4.基于AOP+并发队列实现日志的采集
20点25分准时开始
分布式日志采集产生背景 在传统项目中，如果在生产环境中，有多台不同的服务器集群，如果生产环境需要通过日志定位项目的Bug的话，需要在每台节点上使用传统的命令方式查询，这样效率非常低下。
因此我们需要集中化的管理日志，ELK则应运而生。
传统方式服务器搜索日志命令：tail -200f 日志文件名称
ELK+Kafka组成 Elk E= ElasticSeach（存储日志信息）
l Logstash(搬运工)
K Kibana连接到我们ElasticSeach图形化界面查询日志
Elk+kafka实现分布式日志采集
为什么需要将日志存储在ElasticSeach 而不是MySQL中呢
ElasticSeach 底层使用到倒排索引存储数据 ，在 搜索日志效率比mysql要高的。
elk+kafka原理 \1. springboot项目会基于aop的方式拦截系统中日志
请求与响应日志信息—前置或者环绕通知；
\2. 将该日志投递到我们kafka中 注意该过程一定要是异步的形式，如果是同步形式会影响到整体
接口的响应速度。
\3. Logstash 数据源—kafka 订阅kafka的主题 获取日志消息内容
\4. Logstash 在将日志消息内容输出到es中存放
5.开发者使用Kibana连接到ElasticSeach 查询存储日志内容。
为什么ELK需要结合Kafka 如果只整合elk 不结合kafka这样的话 每个服务器节点上都会安装Logstash做读写日志IO操作，可能性能不是很好，而且比较冗余。
ELK+Kafka环境构建 docker compose构建ELK+Kafka环境 整个环境采用 docker compose 来实现构建
注意：环境 cpu 多核 内存 4GB以上
kafka环境的安装：
1.使用docker compose 安装 kafka
对docker compose 不熟悉可以查看：http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9893192ad83213d9dc34d623afc06b09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d047e4ccfdb43262cfc5b65a2ed565c/" rel="bookmark">
			断点 调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		断点调试:
断点调试是指自己在程序的某一行设置一个断点 ，调试时，程序运行到这一行就会停住 ，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。
断点调试可以帮我们观察程序的运行过程
浏览器中按F12–&gt; sources --&gt;找到需要调试的文件–&gt;在程序的某行设置断点
Watch:监视，通过watch可以监视变量的值的变化，非常的常用。
F11:程序单步执行,让程序一行一行的执行，这个时候，观察watch中变量的值的变化。
for 循环
&lt;script&gt; // for 循环的执行过程 for (var i=1;i&lt;=100;i++) { console .1og('你好吗' )； ｝ // 1.首先执行里面的计数器变量var i = 1 ，但是这句话在for 里面只执行一次 index // 2.去i &lt;= 100 来判断是否满足条件，如果满足条件就去执行循环体，不满足条件退出循环 // 3.最后去执行i++ ，i++是单独写的代码递增第一轮结束 // 4.接着去执行i &lt;= 100 如果满足条件 就去执行循环体 不满足条件退出循环 第二轮 &lt;/ script&gt; &lt;script&gt; //for循环可以执行相同的代码 for (var i=1;i&lt;=10;i++){ console .1og(以你的心诠释我的爱); } //我们可以让用户控制输出的次数 var num = prompt( 请您输入次数）； for (var i=1;i&lt;=num;i++){ console. log(以你的心诠释我的爱'); } &lt;/ script&gt; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d047e4ccfdb43262cfc5b65a2ed565c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/458ce26ee6729d9898bf9d3be2ab6a28/" rel="bookmark">
			常用测试用例设计方法之正交实验法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正交试验法 正交试验设计法，是从大量的试验点中挑选出适量的、有代表性的点，应用依据迦罗瓦理论导出的“正交表”，合理安排试验的一种科学的试验设计方法。
因子/因素：所有影响试验指标的条件。
水平/状态：而影响试验因子的，叫做因子的状态。
正交表的构成 行数(Runs)：正交表中的行的个数，即试验的次数。
因素数(Factors)：正交表中列的个数。
水平数(Levels)：任何单个因素能够取得的值的最大个数。正交表中的包含的值为从0到数“水平数-1”或从1到“水平数”。
正交表的表示形式 L行数(水平数因素数)：
正交表的特点 完成试验要求所需的实验次数少
数据点的分布具有整齐可比性
数据点的分布具有均衡分散性
常见的正交表 各列水平均为2的常用正交表有：L4（23）、L8（27）、L12（211）、L16（215）、L20（219）、L32（231）。
各列水平数均为3的常用正交表有：L9（34）、L27（313）。
各列水平数均为4的常用正交表有：L16（45）。
各列水平数均为5的常用正交表有：L25（56）。
设计测试用例步骤 有哪些因素（变量）；
每个因素有哪几个水平（变量的取值）；
选择一个合适的正交表；
把变量的值映射到表中；
把每一行的各因素水平的组合作为一个测试用例。
正交试验法 假设一个WEB站点，对该系统进行兼容性测试。该站点有大量的服务器和操作系统，并且有许多具有各种插件的浏览器浏览。
WEB浏览器：Chrome48、IE9.0、firefox35；
插件：无、RealPlayer、MediaPlayer；
应用服务器：IIS、Apache、NetscapeEnterprise；
操作系统：Windows2008、Windows7、Linux。
PPT打印功能 测试PPT的打印功能：
喜欢软件测试的小伙伴们，如果我的博客对你有帮助、如果你喜欢我的博客内容，请 “点赞” “评论” “收藏” 一键三连哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5195ef6817ffc4bb9ec8f58df777735c/" rel="bookmark">
			UnityWebRequest如何发送Json数据格式的Post请求，为什么使用UnityWebRequest.Post会报错？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🔍 方法一 ：new UnityWebRequest🔍 方法二 ：UnityWebRequest.Post❓ UnityWebRequest.Post 会使后端报出数据读取格式错误？❗ 正确的做法 在前后端的交互中，我们很经常将 Json 格式的数据装入请求体，向后端发送 Post 请求。 Unity 提供了 UnityWebRequest 这个和网络有关的类，我们可以借助它实现数据的请求和响应的接收。想了解详情可参考 Unity 官方文档中相关的 API 介绍：UnityWebRequest
那么下面就来为大家演示一下如何利用 UnityWebRequest 发送 Json 数据格式的 Post 请求。后端的部分我是用基于 Java 的 SpringBoot 框架搭建的程序，对应的接口用了 @RequestBody 注解来接收前端传来的 Json 请求参数。这里就不具体演示后端怎么写了，本篇博客还是把重点放在 Unity 前端的实现方法上，总的来说有两种实现方式，但不论是哪一种，思路都是一样的，只是代码的实现上有些不同。
🔍 方法一 ：new UnityWebRequest 如果在百度上搜，可能大部分会搜到这种实现方式，我先附上代码，然后再具体解释：
private void Start() { string url="xxx"; string json="一个Json格式的数据，这里大家替换成自己想要测试的Json数据"; StartCoroutine(I_RequestByJsonBodyPost(url,json)); } private static IEnumerator I_RequestByJsonBodyPost(string url, string json) { UnityWebRequest www = new UnityWebRequest(url, UnityWebRequest.kHttpVerbPOST); DownloadHandler downloadHandler = new DownloadHandlerBuffer(); www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5195ef6817ffc4bb9ec8f58df777735c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9159d8146f27bba8ef80082d7388e196/" rel="bookmark">
			Hive on Spark环境搭建（解决Hive3.1.2和Spark3.0.x版本冲突）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建数仓必要环境的注意事项 使用Hive做元数据存储和HQL解析，Spark做实际计算。（Hive on Spark）
Hive 使用3.1.2版本，Spark 使用3.0.3版本 。
由于Hive 3.1.2 和 Spark 3.0.3不兼容，需要修改Hive中关于Spark的源码和依赖引用。
重新编译Hive 下载Hive 3.1.2源码 ，上传并解压
apache-hive-3.1.2-src.tar.gz
下载Linux版IDEA，安装到带有桌面的Linux上。（使用root操作IDEA，bin/idea.sh打开idea）
用idea打开apache-hive-3.1.2-src，首先修改pom.xml
修改pom.xml，将spark.version改为3.0.3，scala.version改为2.12.15，scala.binary.version改为2.12 和 SPARK_SCALA_VERSION改为2.12
（修改前配置一下IDEA的maven使用的settings的位置）
在shell命令行中，进入hive src目录，执行mvn命令进行install，安装依赖
/opt/module/maven-3.8.5/bin/mvn clean -DskipTests -Pdist -Dmaven.javadoc.skip=true install 编译报错SparkCounter.java存在问题，打开idea，找到该java文件，并对源码进行分析。
根据编译报错，及官网API，发现
org.apache.spark.Accumulator 已不存在
org.apache.spark.AccumulatorParam 已不存在
这两个类由 AccumulatorV2代替
对累加器使用及获取进行修改
import java.io.Serializable; import org.apache.spark.api.java.JavaSparkContext; // org.apache.spark.Accumulator已被删除，由以下类代替 import org.apache.spark.util.LongAccumulator; // org.apache.spark.AccumulatorParam已被删除，一并删除它的实现类 public class SparkCounter implements Serializable { private String name; private String displayName; private LongAccumulator accumulator; private long accumValue; public SparkCounter() {} private SparkCounter(String name, String displayName, long value) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9159d8146f27bba8ef80082d7388e196/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac05befa0de2f3edf3cff06a5c78302c/" rel="bookmark">
			机器人抓取系列——路径规划（RRT原理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面所述的点云分割＋姿态估计能完成机器人抓取工作，但是如果抓取环境特比复杂，固定的抓取路径中有很多障碍物，那么就需要一种路径规划方法来规划出一条无碰撞的路线。
目前应用在机械臂上的路径规划算法主要分为人工势场法以及RRT（随机生成树）的方法，这里我用的是RRT的方法，因此主要介绍RRT方法的原理
RRT RRT算法不仅可以在二维平面上适用，也适用于三维空间。今天主要记录一下二维的RRT算法原理，三维的RRT算法原理类似，只是增加一个维度即可。
RRT是一种通用的方法，不管什么机器人类型、不管自由度是多少、不管约束有多复杂都能用。而且它的原理很简单，这是它在机器人领域流行的主要原因之一。不过它的缺点也很明显，它得到的路径一般质量都不是很好，例如可能包含棱角，不够光滑，通常也远离最优路径。
那么下面就先介绍一下RRT的原理，然后再说一下路径不够光滑，以及远离最优距离是怎么解决的。
与其他方法相比较，RRT有什么优势呢？
其中一个很重要的优势就是快。RRT 的思想是快速扩张一群像树一样的路径以探索（填充）空间的大部分区域，伺机找到可行的路径。之所以选择“树”是因为它能够探索空间。在搜索轨迹的时候我们不知道出路应该在哪里，如果不在“确定”的搜索方向上，我们怎么找也找不到（找到的概率是0）。这时“随机”的好 处就体现出来了，虽然不知道出路在哪里，但是通过随机的反复试探还是能碰对的，而且碰对的概率随着试探次数的增多越来越大，就像买彩票一样，买的数量越多中奖的概率越大（RRT名字中“随机”的意思）。可是随机试探也讲究策略，如果我们从树中随机取一个点，然后向着随机的方向生长，那么结果是什么样的呢？见上图。可以看到，同样是随机树，但是这棵树并没很好地探索空间，它一直在起点（红点）附近打转。这可不好，我们希望树尽量经济地、均匀地探索空间，不要过度探索一个地方，更不能漏掉大部分地方。这样的一棵树怎么构造呢？
RRT的基本步骤是：
1、初始化整个空间，定义起始点，终点，采样点数，点与点之间的步长等信息
2、在空间中随机生成一个点Xrand
3、在已知树的点的集合中找到距离这个随机点最近的点Xnear
4、在Xnear到Xrand的直线方向上从Xnear以步长 t 截取点Xnew
5、判读Xnear和Xnew之间有没有障碍物，若存在障碍物则舍弃掉该点
6、将Xnew加入到树的集合中
7、循环2-6，循环截至的条件：有一个new点在终点的设定邻域内
虽然这种方法能够找到有效的路径，但是同样也有一些问题
1、路径不够平滑
2、不是最优路径
RRT* RRT*算法是相对于RRT算法的一个改进，相对于RRT来说，RRT *多了两个步骤：
1、重新为Xnew选择父节点
2、重布线随机树的过程
首先介绍RRT*重新选择父节点的过程
重新选择父节点过程 这里贴一张图，图中9节点是新产生的节点Xnew，6节点是产生9节点的父节点，，图中节点和节点之间的数值代表的是两点之间的欧氏距离。
在重新找父节点的过程中，以9节点 Xnew为圆心，以事先规定好的半径，找到在这个圆的范围内 Xnew 的近邻，也就是4，5，8节点（6节点是9的父节点）。
原来的路径0-4-6-9的代价为10+5+1=16
备选的三个节点 4，5，8和Xnew9节点组成的路径0 - 1 - 5 - 9，0 - 4 - 9和0 - 1 - 5 - 8 - 9代价分别为3 + 5 + 3 = 11，10 + 4 = 14和3 + 5 + 1 + 3 = 12，因此如果5节点作为9节点的新父节点，则路径代价相对是最小的，因此我们把9节点的父节点由原来的节点6变为节点5，则重新生成的随机树如图 b)所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac05befa0de2f3edf3cff06a5c78302c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cbf20e024c7aeff84b5fe0acdb59ea2/" rel="bookmark">
			spring源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.spring架构 由架构可以看出，spring核心是BeanFactory，可以比做现实生活中工厂。
我们看看一个工厂的大致工作流程：
工厂加工一个产品需要有图纸，图纸存放于档案库。有了图纸，需要车间流水线，这个流水线能加工产品，就需要人、加工机器、水电气等等加工环境。环境准备工作好了，就可以按照图纸加工产品了。 再来看看spring生产Bean的大致过程：
现实中的零件图纸，在spring中称作BeanDefinition（Bean定义信息），spring要得到Bean定义信息，需要将资源Resource（xml、注解）解析出来得到Bean定义信息，并保存起来。工厂需要加工环境，spring也是一样，需要一些环境，比如加载java的Properties。有了BeanDefinition，就可以创建Bean，在创建Bean的过程中，spring定义后置处理器在一些步骤进行干预，最后完成Bean创建。这里也被称作Bean生命周期过程。 2.Spring容器刷新 测试方法
/** * 注解版Spring的用法 */ public class AnnotationMainTest { public static void main(String[] args) { //	new ClassPathXmlApplicationContext() ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class); } } 进入构造方法
/** * Create a new AnnotationConfigApplicationContext, deriving bean definitions * from the given component classes and automatically refreshing the context. * @param componentClasses one or more component classes &amp;mdash; for example, * {@link Configuration @Configuration} classes */ public AnnotationConfigApplicationContext(Class&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cbf20e024c7aeff84b5fe0acdb59ea2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29d86bdcea3d80d25e068b5a2866f84f/" rel="bookmark">
			JS中的原型链(超清晰理解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是原型链 原型链，所有的原型构成了一个链条，这个链条我们称之为原型链（prototype chain)。
原型链的案例 如果我们执行下面这段代码,因为没有定义address这个属性，程序结果理所当然的是undefined。
let obj = { name : 'harry', age:18 } console.log(obj.address); //undefined 这个时候经历了什么呢？JS引擎线从Obj.address里寻找，发现没有找到，然后接着去找obj.__ proto __ 里面寻找，发现还是没找到，所以结果为undefined。我们可以给obj.__ proto __ 赋值
let obj = { name : 'harry', age:18 } obj.__proto__ = { address:'上海' } console.log(obj.address); //上海 或者这样
obj.__proto__ = { //这里一定要开辟一个空间，不能直接写obj.__proto__.__proto__ = {} } obj.__proto__.__proto__= { address:'上海' } console.log(obj.address); //上海 接着套娃
let obj = { name : 'harry', age:18 } obj.__proto__ = { } obj.__proto__.__proto__= { } obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29d86bdcea3d80d25e068b5a2866f84f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bacaba813603d3356022e1ab4f118d9a/" rel="bookmark">
			python学习-6-面向对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类与实例 创建类的格式: class Student(object): # class 类名(继承) pass init()方法就是java中的构造器类中的self相当于java中的this,java不用显示声明,python中需要在参数列表中声明 第一个参数一定是self 访问限制 私有属性用双下划线__开头,只有内部可访问 (private) 访问需要类提供get方法,这和java一样
_ 修改就需要set方法实际上,并不是私有的,只是python解释器给属性改了一个名,变为._类名__属性名 python中双下划线开头与结尾的,都是特殊变量,一般不能用发现个好玩的,即使类中没有的属性,也是可以xx.xx = xx进行设置的,然后就可以使用了 继承 继承会引发多态 子类是父类,父类不是子类调用方只管调用,不管细节,无需知道子类型,从而尽可能满足开闭原则 java是静态语言,它在进行编译的时候就要来检查传入对象的类型是否合法Python是动态语言,不需要保证类型完全,只需要它有本方法中需要的方法和属性就ok了 鸭子类型,无需严格继承,只要 看起来像鸭子,走起来也像鸭子 就ok 对象信息 type(obj) 类型,指向函数 type(obj)if type(xxx) == type(已知类型)if type(xxx) == types.FunctionType 判断是否是函数… instance(obj,已知类型) 判断类型是否相等 返回True or False可用于继承判断是否是其中一种 instance(obj,(xxx,xxx)) dir(obj) 将所有方法 属性 字符串列表返回len(obj) 获取对象的长度 自动调用__len__()方法可以被复写 hasattr(obj,“xxx”) 是否拥有某种属性 注意是字符串 getattr(obj,“xxx”,404) 最后一个参数是默认值,防止不存在报错 方法和属性都是一样的,都用这个 setattr(obj,“xxx”,xx)结合上面的鸭子类型,可以使用对象信息来判断是否像鸭子 if hasattr(obj,“xxx”): … 实例属性与类属性 实例可以任意绑定属性 类没有定义name属性,但我可以 实例.name=xxx,然后用 slots 作为动态语言,python可以给实例绑定方法与属性而给类动态的绑定,则可以对每个实例都适用,具体操作和实例的绑定一样为了限制绑定,需要__slots__ 其作为一个变量,可以定义 允许绑定的 属性名称其他属性是不能够绑定的对继承的子类无效 @property 一般的属性都是不对外暴露的,所以需要getter方法,setter方法 这样使用起来就很麻烦 所以实际上可以使用 @property 来让get方法变成属性,然后使用 @属性.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bacaba813603d3356022e1ab4f118d9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2833ed231256fdc337bd4df8cd9c06d6/" rel="bookmark">
			【极客时间-网络编程实战】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 极客时间-网络编程 盛延敏 文件
实战思维导图
开篇词│学好网络编程，需要掌握哪些核心问题? 学习高性能网络编程，掌握两个核心要点就可以了：第一就是理解网络协议，并在这个基础上和操作系统内核配合，感知各种网络 I/O 事件；第二就是学会使用线程处理并发。
基础篇:一起来认识网络编程 01 追古溯源︰TCP/IP和Linux是如何改变世界的? 02网络编程模型:理解“客户端–服务器”的基本概念 03套接字和地址:电话和电话号码 04 TCP三次握手:怎么使用套接字格式建立连接? 05使用套接字进行读写:开始交流吧 06嗨，别忘了UDP这个小兄弟 07本地套接字:如何入门本地套接字? 08 工欲善其事必先利其器:学会使用各种工具 09基础篇总结与答疑 提高篇:一起来解决异常问题 10TIME_WAIT︰隐藏在细节下的魔鬼 11优雅地关闭还是粗暴地关闭? 12连接无效:使用Keep-Alive还是应用心跳来检测? 13小数据包应对之策:理解TCP协议中的动态数据传输 14 What ? UDP也可以是“已连接”? 15怎么老是出现“地址已经被使用”? 16如何理解TCP的“流”? 17TCP并不总是“可靠”的? 18防人之心不可无:检查数据的有效性 19提高篇总结与答疑 性能篇:学会优雅地提高程序性能 20鼎鼎大名的select:看我如何同时感知多个I/O事件 21poll:另一种I/O多路复用 22非阻塞I/O:提升性能的加速器 23 Linux利器:epoll的前世今生 24C10K问题:高并发模型设计 25使用阻塞I/O和进程模型:用最传统的方式 26使用阻塞I/O和线程模型:换—种轻量的方式 27 I/O多路复用遇上线程:使用poll单线程处理所有I/O事件 28 I/O多路复用进阶:子线程使用poll处理连接I/O事件 29 渐入佳境:使用epoll和多线程模型 30真正的大杀器:异步I/O探索 31性能篇总结与答疑 实战篇:让我们一起来造个轮子 32自己动手写高性能HTTP服务器(一)︰设计和思路 33 自己动手写高性能HTTP服务器(二):I/O处理模型和多线程模型实现 34自己动手写高性能HTTP服务器（三):TCP字节流处理和HTTP协议实现 35实战篇总结与答疑 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b334a21007fbe97c090e1932d3420e7/" rel="bookmark">
			yum提示Another app is currently holding the yum lock； waiting for it to exit...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用yum安装计划任务功能，结果提示：
# yum -y install vixie-cron Loaded plugins: fastestmirror, refresh-packagekit, security Existing lock /var/run/yum.pid: another copy is running as pid 25960. Another app is currently holding the yum lock; waiting for it to exit... 可能是系统自动升级正在运行，yum在锁定状态中。
已经有一个yum进程在运行了，使用kill干掉它：
# kill -s 9 25960 # ps aux|grep yum root 6744 0.0 0.0 103260 900 pts/1 S+ 14:59 0:00 grep yum root 25960 0.0 0.0 0 0 ? Z Sep19 0:01 [yumBackend.py] &lt;defunct&gt; 很遗憾，kill对付不了它，那怎么办呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b334a21007fbe97c090e1932d3420e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed38cbc5dfc838a7ec718740c4fb70a1/" rel="bookmark">
			python-opencv边缘检测与人脸检测应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		10.python-opencv边缘检测与人脸检测应用 第一章 python-opencv-图片导入和显示
第二章 python-opencv图像简单处理
第三章 python-opencv图像mask掩膜处理
第四章 python-opencv图像马赛克
第五章 python-opencv人脸马赛克
第六章 python-opencv人脸检测
第七章 python-opencv图像张贴
第八章 python-opencv轮廓绘制
第九章 python-opencv边缘检测
文章目录 10.python-opencv边缘检测与人脸检测应用前言一、完整代码二、部分代码说明图片处理部分轮廓检测部分人脸检测及处理部分 结果展示 前言 本章主要介绍如何在人脸区域张贴图像，主要思路为：首先检测到人脸区域，对于要张贴的图像进行轮廓检测，检测到轮廓后在人脸区域绘制轮廓，并将洛阔中的图像张贴到人脸区域。
一、完整代码 import cv2 import numpy as np if __name__ == '__main__': # 加载图片 img = cv2.imread('./tong.jpg') img2 = cv2.imread('./dog.png') # 加载人脸检测器 face_detector = cv2.CascadeClassifier('./haarcascade_frontalface_alt.xml') # 见图片转化为灰度图片 img_gray = cv2.cvtColor(img, code = cv2.COLOR_BGR2GRAY) img2_gray = cv2.cvtColor(img2, code = cv2.COLOR_BGR2GRAY) # 图像二值化，binary二进制图片（黑白图），其中，threshold为阀值，阀值以下变为0，阀值以上变为255 threshold, binary = cv2.threshold(img2_gray, 180, 255, cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed38cbc5dfc838a7ec718740c4fb70a1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/142/">«</a>
	<span class="pagination__item pagination__item--current">143/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/144/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>