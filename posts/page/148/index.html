<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cceb17bbf619540d5205009813b8df9a/" rel="bookmark">
			STM32简介（系统结构、引脚定义……）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、STM32简介二、STM32F103xxx1.STM32F1系列片上资源/外设2.命名规则3.系统结构4.引脚定义5.启动配置6.STM32最小系统电路 总结 前言 提示：这里可以添加本文要记录的大概内容：
介绍STM32的片上资源/外设、命名规则、系统结构、引脚定义、启动配置、最小系统电路等基础内容。
STM32：ST指ST公司、M指Microcontroller（微控制器）
一、STM32简介 1）STM32是ST公司基于ARM Cortex-M内核开发的32位微控制器。
2）STM32常用在嵌入式领域。
（1）智能车：循迹小车，读取光电传感器或者摄像头的数据，驱动电机前进和转弯。
（2）无人机：读取陀螺仪加速度计的姿态数据，根据控制算法控制电机速度，保证飞机稳定飞行。
（3）机器人：驱动舵机，控制其关节，让机器人运动。
（4）无线通信：给STM32连接一些2.4G无线模块或者蓝牙、WIFI模块，则具备无线通信能力。
（5）物联网：借助无线通信模块，再通过STM32驱动继电器来控制220v电路的通断。
（6）工业控制：PLC主控。
（7）娱乐电子产品：流水灯之类……
（8）……
3）STM32功能强大、性能优异、片上资源丰富、功耗低、是一款经典的嵌入式微控制器。
此处用STM32F103C8T6。
二、STM32F103xxx 1.STM32F1系列片上资源/外设 NVIC：管理中断，如配置中断优先级等。
SysTick：给操作系统提供定时服务。
RCC：使能外设时钟。
AFIO：复用功能端口重定义，及中断端口配置。
CAN：多应用于汽车领域
RTC：在STM32内部完成年月日、时分秒的计时功能，可接外部备用电池，掉电也可使用。
CRC：判断数据的正确性。
PWR：电源可睡眠，使功耗降低。
GPIO、EXTI、TIM、USART、I2C、SPI、ADC、DMA等都会在专题内逐一介绍。
……
如果操作片上不存在的外设资源，是无法工作的。
2.命名规则 示例：STM32 F103 C 8 T 6
![103含义](https://img-blog.csdnimg.cn/50531279eb4e498a957f244072ef64bf.png
![8含义](https://img-blog.csdnimg.cn/6cdd6a922fdd479cb3a640efc89ec5aa.png
可见STM32F103C8T6的具体参数为：增强型、48脚、64K字节的闪存存储器、LQFP封装、在-40~85℃间可正常工作。
3.系统结构 将此结构分成四个部分：
**（1）**区域1位Cortex-M3内核，内核引出三条总线；分别是ICode指令总线、DCode数据总线、System系统总线。其中ICode和DCode主要用以连接Flash闪存，Flash中存储的内容为我们所编写的程序。ICode指令总线就是用以加载指令程序的，DCode数据总线是用来加载数据的，比如常量和调试参数等。System系统总线连接其他东西上，如SRAM（用于存储程序运行时的变量数据）、FSMC等。
**（2）**AHB（先进高性能总线）系统总线用于挂在主要外设，挂载的一般是最基本的或者是性能比较高的外设，如复位和时钟控制（RCC）、SDIO、两个桥接（APB1和APB2）等。APB（先进外设总线），用于连接一般的外设；因为AHB与APB在总线协议、总线速度、数据传送格式之间的差异，故中间需要加两个桥接，完后数据的转换和缓存。APB2（一般与AHB同频）的性能比APB1高一些，故连接一些外设中稍微重要的部分，如GPIO、外设的一号（USART1、TIM1、ADC1……）；APB1则连接DAC、外设的其它号（USART2、TIM2……）。前文所述的就为区域3，主要介绍的就是外设种类和分布。
**（3）**区域4为DMA（直接内存访问），可理解为内核CPU小秘书，若是有一些大量搬运数据的工作，为了减少CPU的工作量，给其它工作腾出时间，就将此工作交给DMA来做。
DMA主要用来做如数据搬运一样简单且反复要做的事情，其通过DMA总线连接到总线矩阵上，可以拥有和CPU一样的控制权，用于访问其它外设；当需要DMA搬运数据时，外设就会通过请求线发送DMA请求，然后DMA就会获得总线控制权，访问并转运数据，整个过程不需要CPU的参与，省下CPU的时间来干其它事。
4.引脚定义 在拿到新的芯片时，需要着重的看一下其引脚定义，这样才能大致了解该如何使用该芯片。
砖红色：与电源相关的引脚；有FT则表示其可忍受5V电压，如果没有FT，需要5V的电平就需要加装电平转换电路。
蓝色：与最小系统相关的引脚
绿色：I/O口、功能口相关引脚
主功能就是上电后默认的功能，一般和引脚名称相同；若不同，引脚的实际功能是主功能而不是引脚名称的功能。默认复用功能，是IO口同时连接的外设功能引脚，在配置IO时可以选择是通用IO口还是复用功能。重定义功能，其作用是如果有两个功能同时复用在一个IO上，而且确实需要这两个功能，就可以把其中一个复用功能重映射到其他端口上（前提是，重定义功能的表里有对应的端口）。
**1）**VBAT：备用电池供电引脚，其可接一个3V的电池，当系统电源断电时，备用电池可以给内部的RTC时钟和备份寄存器提供电源。
**2）**2号引脚是IO口或者侵入检测或RTC，IO口可根据程序输出或读取高低电平，是最基本也是最常用功能；侵入检测可以用来做安全保障的功能；RTC可用来输出RTC校准时钟、RTC闹钟脉冲或秒脉冲。
**3）**3、4号引脚是IO口或者接32.768KHz的RTC晶振。
**4）**5、6号引脚接系统主晶振，一般是8MHz。芯片内有锁相环电路，可以对8MHz的频率进行倍频，最终产生72MHz频率，作为系统的主时钟。
**5）**7号NRST为系统复位引脚，N表示它是低电平复位。
**6）**8、9号引脚是内部模拟部分的电源，如ADC、RC振荡器等。VSS为负极，接GND，VDD是正极，接3.3V。
**7）**10~19号引脚都为IO口，PA0兼具Wake-up功能，用于唤醒处于待机模式的STM32.
20号引脚为IO口或者BOOT1引脚，BOOT引脚是用来配置启动模式的。
**8）**23、24号的VSS_1（负极）和VDD_1（正极）是系统的主电源口。后面的VSS_2和VDD_2、VSS_3和VDD_3都是系统的主电源口，STM32内部采用分区供电的模式，把VSS都接GND，VDD都接3.3V即可。
**9）**25~33都为IO口。
**10）**34号加37号40号，都是IO口或者调试端口；默认的主功能是调试端口，调试端口就是用来调试程序和下载程序的，次STM32支持SWD和JTAG两种调试方式。SWD需要两根线，分别是SWDIO和SWCLK；JTAG需要5根线，分别是JTMS、JTCK、JTDI、JTDO、NJTRST。此处介绍用STLINK下载调试程序，在SWD调试方式时，PA15、PB3、PB4可以切换回普通的IO使用，但是要在程序中进行配置，不配置的话默认是不会为IO口的。
**11）**41-43及45~46都是IO口，44号BOOT0做启动配置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cceb17bbf619540d5205009813b8df9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4ad32f75037a2b3f65eadf33099c9f5/" rel="bookmark">
			C语言数据结构学习（clion版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		栈的应用（就近匹配，逆波兰表达式） 先放一张clion设置截图，用于分割不同作用的文件，以及怎么定义路径和引用。
需要在main.c同级的CMakeLists.txt中定义source_file和header_file。
在CMakeLists.txt加入设置：
include_directories("source_file") include_directories("header_file") 在source_file中对header_file中的文件进行实现，在头文件那里，可以通过相对路径引入，也可以通过CMakeLists.txt文件，设置。
这样就让clion中的C语言工程和visual studio中的一样了。注意，clion中，尽量不要用中文定义文件夹，容易出现路径寻找不到的问题。
括号匹配 #include &lt;stdio.h&gt; #include "stackFinishByArray.h" int isLeft(char ch){ return ch=='('; } int isRight(char ch){ return ch==')'; } void printError(char *str,char *errMsg,const char *pos){ printf("错误的信息：%s\n",errMsg); printf("%s\n",str); //计算打印空格的数量 long long num = pos-str; //char型指针地址（占一个字节）相减 for (int i = 0; i &lt; num; ++i) { printf(" "); } printf("|\n"); } void test01() { char *str = "5+5*(6)+*/3*1-(1+3("; char *p =str; //定义一个指针指向字符串的头地址 seqStack myStack = init_Stack(); while (*p!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4ad32f75037a2b3f65eadf33099c9f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2dc92da0e4da962cae8c54ee705683d/" rel="bookmark">
			BCompare--使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BCompare简介：文件夹，文件的对比与合并
比较文件夹：
打开软件，选择“文件夹比较”
点击之后
选择文件夹
输入文件夹路径，并点击按钮进入（或直接拖入文件夹）
结果：
右侧也是这样进行，结果：
内容不同的会在中间显示，也可以点击中间箭头进行合并，最后关闭BCompare时选择保存
**对于文章出现的任何问题请大家批评指出，一定及时修改
**可联系我：3113964587@qq.com
**本文原创，如需转载请标注出处！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffc811f57b98ff0aaef9c990185d487f/" rel="bookmark">
			strcmp函数详解看这一篇就够了-C语言（函数实现、使用用法举例、作用、与strncmp的区别）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先要明确strcmp的功能是：用来比较两个字符串
目录
函数介绍
ACSII表
与strncmp的区别
函数实现：
用法示例：
结果展示：
函数介绍 函数原型：int strcmp(const char* str1, const char* str2)
头 文 件：#include &lt;string.h&gt;
返 回 值：str1 = str2 则返回0，
str1 &gt; str2 则返回大于0的值，
str1 &lt; str2 则返回小于0的值
说明：
判断两个字符串大小
1）ACSII码 2）长度
注：区分大小写比较的，如果希望不区分大小写进行字符串比较，可以使用stricmp函数
strcmp()函数首先将str1字符串的第一个字符的ACSII值减去str2第一个字符的ACSII值(自左向右逐个字符相比，直到出现不同的字符或遇'\0'为止)
若差值为零则继续比较下去；若差值不为零，则返回差值。
特别注意：strcmp可用于比较两个字符串常量或比较数组和字符串常量，不能比较数字等其他形式的参数。
ACSII表 与strncmp的区别 1、先比较一下两个函数传参的不同：
int My_strncmp(const char* str1, const char* str2, int num)
int My_strcmp(const char* str1, const char* str2)
strcmp与strncmp都是用来比较字符串的，区别在于能否比较指定长度字符串，故要多传一个长度参数，这也使得strncmp比strcmp更加精细。
函数实现： //以null结尾的字符串 const修饰防止字符串被修改，进行保护 int My_strcmp(const char* str1, const char* str2) { assert(NULL !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffc811f57b98ff0aaef9c990185d487f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/917db1388dcfb3acf47d42986d82e6eb/" rel="bookmark">
			getchar函数详解看这一篇就够了-C语言（函数功能、使用、返回值）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先要明确getchar的功能是：从计算机终端（一般是键盘）输入一个字符，其值就是输入得到的字符。
目录
getchar函数简介
getchar函数执行过程详解（配图）
getchar用法示例
解释一下：while ((ch=getchar()) != 'EOF')
getchar函数简介 函数原型：int getchar(void); 返回类型为int,参数为void
头 文 件：#include&lt;stdio.h&gt;
返 回 值： 1、getchar返回的是字符的ASCII码值（整数）。
2、getchar在读取结束或者失败的时候，会返回EOF。
(EOF意思是end of file,本质上是-1）
读取方式：只能输入字符型,输入时遇到回车键才从缓冲区依次提取字符。
结束输入的方式：以Enter结束输入（空格不结束），接受空格符。
舍弃回车符的方法：以Enter结束输入时，接受空格，会舍弃最后的回车符。
getchar函数执行过程详解（配图） 程序执行到getchar()函数时，自动从输入缓冲区中去找字符，如果输入缓冲区中没有字符的话，那么就等待用户输入字符，此时用户使用键盘输入的字符，被输入到输入缓冲区中，键盘输入字符的时候首先进入输入缓冲区,然后getchar()函数获得的字符是从输入缓冲区中提取的且每次只能提取一个字符。
​
getchar用法示例 #include&lt;stdio.h&gt; int main() { char ch = getchar();//输入字符 putchar(ch); return 0; } 它的简单意思就是从键盘读入一个字符，然后输出到屏幕。理所当然，我们输入A，输出就是A，输入B，输出就是B。
那么我们如果输出的是ABC呢？答案是A。
解释如下：当我们从键盘输入字符‘A’，‘B’, 'C'，并按下回车后，我们的输入被放入了输入缓冲区，这个时候getchar()会从缓冲区中读取我们刚才的输入，一次只读一个字符，所以字符A就被拿出来了，赋值给了ch，然后putchar()又将ch放在了标准输出，也就是这里的屏幕，所以我们看见了最终的显示结果A。同时字符‘A’也被缓冲区释放了，而字符‘B’,'C'仍然被留在了缓冲区。而这样是很不安全的，有可能下次使用的时候，我们的缓冲区会读到一些垃圾，但是当程序结束的时候，它会自动刷新。
解释一下：while ((ch=getchar()) != 'EOF') #include&lt;stdio.h&gt; int main() { char ch ; while ((ch=getchar()) != 'EOF') { putchar(ch); } return 0; } getchar先读取一个字符放到ch里面去，如果这个字符不等于EOF，就进入循环，打印这个字符。当getchar读到文件末尾或者结束时，它会返回一个EOF，此时结束循环。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/917db1388dcfb3acf47d42986d82e6eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b45c4cd29d24329aaf0f89b2274828ed/" rel="bookmark">
			二叉树的基本操作-C语言实现-数据结构作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
(1)二叉树的创建；
(2)二叉树的先序、中序和后序遍历输出；
(3)输出二叉树的叶子节点和度为2的节点的数量；
(4)输出二叉树的深度；
(5)将二叉树所有节点的左右子树互换(左子树变右子树，右子树变左子树)；
(6)参考书上，二叉树按层次输出(一行输出一层)；
(7)删除二叉树(释放二叉树所有节点空间)；
完整代码
运行结果展示
编写一个带菜单的实验演示系统（参考前面实验的菜单系统）。要求演示以下功能（界面、函数及相关数据结构等根据需要自行设计和定义）：
(1)二叉树的创建；
(2)二叉树的先序、中序和后序遍历输出；
(3)输出二叉树的叶子节点和度为2的节点的数量；
(4)输出二叉树的深度；
(5)将二叉树所有节点的左右子树互换(左子树变右子树，右子树变左子树)；
(6)参考书上，二叉树按层次输出(一行输出一层)；
(7)删除二叉树(释放二叉树所有节点空间)；
(1)二叉树的创建； BiTree CreatePreTree()//建立二叉树 { char c; scanf("%c", &amp;c); if (c == '#') //表示空子树 return NULL; else { BiTree T = (BiTree)malloc(sizeof(BiTreeNode)); T-&gt;data = c; T-&gt;leftChild = CreatePreTree(); T-&gt;rightChild = CreatePreTree(); return T; } } (2)二叉树的先序、中序和后序遍历输出； void PreOrder(BiTreeNode* root, void visit(DataType item)) { //前序遍历二叉树root，访问操作为visit if (root != NULL) { visit(root-&gt;data); PreOrder(root-&gt;leftChild, visit); PreOrder(root-&gt;rightChild, visit); } } void InOrder(BiTreeNode* root, void visit(DataType item)) { //中序遍历二叉树root，访问操作为visit if (root !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b45c4cd29d24329aaf0f89b2274828ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/071eb38fd6ebee787a9f91b0cd93d246/" rel="bookmark">
			Hololens2 &#43; VS2019负载安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.如图，VS2019已经安装完成，VS Installer可以添加工作负荷和组件。
2.点击VS Installer，进行Hololens所需要的工作负荷及组件，点击修改。
3.具体安装工作负荷如图所示，选择完成后，点击修改进行安装。
4.工作负荷及组件修改过程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71d8a74b2f90d460fe014cab495b3204/" rel="bookmark">
			电脑微信语音通话听不到对方声音或无法播放消息语音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近面试时发现电脑版微信在语音通话时听不到对方的声音（对方可以听到自己的声音），试了重装微信、更新驱动等等操作发现都不行，上网搜了一下发现原来是音量合成器中微信通道的声音没开，打开就好了。
如果你此时也面临着微信语音通话听不到对方的声音或者对方发来的语音消息点开没有声音，那么请尝试以下步骤解决：
1、右键声音图标，选择打开音量合成器
2、在音量合成器中，打开微信的声音，完成！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33fadef1cc32ac9c520860cdb469d052/" rel="bookmark">
			Nginx 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Nginx WEB入门简介
Nginx [engine x]是Igor Sysoev编写的一个HTTP和反向代理服务器，另外它也可以作为邮件代理服务器。 它已经在众多流量很大的俄罗斯网站上使用了很长时间，这些网站包括Yandex、Mail.Ru、VKontakte，以及Rambler。
据Netcraft统计，在2012年8月份，世界上最繁忙的网站中有11.48%使用Nginx作为其服务器或者代理服务器。目前互联网主流公司360、百度、新浪、腾讯、阿里等都在使用nginx作为自己的web服务器。
Nginx由内核和模块组成，其中，内核的设计非常微小和简洁，完成的工作也非常简单，仅仅通过查找配置文件将客户端请求映射到一个location block（location是Nginx配置中的一个指令，用于URL匹配），而在这个location中所配置的每个指令将会启动不同的模块去完成相应的工作。
Nginx相对于Apache优点：
1)高并发响应性能非常好，官方Nginx处理静态文件并发5w/s
2)反向代理性能非常好。（可用于负载均衡）
3)内存和cpu占用率低。（为Apache的1/5-1/10）
4)功能较Apache少（常用功能均有）
5)对php可使用cgi方式和fastcgi方式。
2、 Nginx WEB安装配置
安装编译工具及库文件
yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel
首先需要安装pcre库
然后再安装Nginx，安装pcre支持rewrite库
#源码安装pcre
2.1、下载 PCRE 安装包，下载地址： http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz
cd /usr/src/
wget http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz
2.2、解压安装包:
tar zxvf pcre-8.35.tar.gz
2.3、进入安装包目录
cd pcre-8.35
2.4、编译安装
./configure
make &amp;&amp; make install
2.5、查看pcre版本
pcre-config --version
3、安装 Nginx
#下载Nginx源码包
cd /usr/src ;
wget -c http://nginx.org/download/nginx-1.4.2.tar.gz
#解压Nginx源码包
tar -xzf nginx-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33fadef1cc32ac9c520860cdb469d052/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71b321d42b03d44aeb78e14dbbacfcad/" rel="bookmark">
			唐老师讲运算放大器(第三讲)——运放相关参数及选型指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 九、 输入电压范围 轨到轨：意思是输出或者输入电压的范围和供电范围的临界程度，若很接近，则轨到轨，否则不是轨到轨(例如十中的LM324)，又分为输入轨到轨(输入电压范围很接近电源电压范围)和输出轨到轨(输出电压范围很接近电源电压范围)
十、 输出电压范围 十一、 短路电流 十二、 输入阻抗(越大越好) 常用运放 运放选型 TI放大器的命名规范 TI精密放大器家族 精密运放的选型指南 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7498ea6f47f1ab6ce75fa72dd5bdcbf5/" rel="bookmark">
			WebStorm项目上传gitee的方法步骤-idea同样适用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebStorm项目上传gitee的方法步骤-idea同样适用 主要流程：1下载git并配置-&gt;2、再webStorm中下载gitee插件–&gt;3、在WebStorm 添加gitee账户信息—&gt;上传项目并查看 一、git的下载与环境变量的配置 1.1下载git。git的下载地址[Git - Downloading Package (git-scm.com)](https://git-scm.com/download/win)选择自己的系统对应的版本进行下载，此次演示是基于win10系统进行安装配置 1.2win10下载64-bit git for windows Prortable 绿色解压版 注意图片中的下载路径，此路径后面还有用
1.3 解压git之后进行配置环境变量 请参考下图：我的电脑右键属性，选择高级系统设置，点击环境变量，选择系统变量path目录，编辑点击新建此时填写刚才解压的中的cmd目录路径，最后点击确定。系统环境变量配置完成。
### 1.4 git账户本地设置，在git目录中找到git-bash并运行。输入一下两行代码
$git config --global user.name"username" // "username"是注册gitee时候的账户名
$git config --global user.email“username@email.com" //"username@email.com "是注册gitee用的邮箱
说明一下这里的 “username” 和 “username@email.com" 最好与自己的给gitee账号对应。在项目上传gitee时候可以显示出上传的用户信息便于项目管理。这里用户名和邮箱后期也可以更改。想了解的读者可以留言
执行命令后输入：
$ git config --global --list 检查是否配置成功
返回自己的账户信息代表配置成功
二 WebStorm 中下载gitee插件 验证插件是否下载成功，在sittings中可以看到gitee插件，这时候既可以配置在webstorm中添加自己的账户信息了，如下图所示
在webstorm 中上传自己的项目 提交成功显示提示信息。
在gitee上查看项目是否上传 在gitee中我的中，可以看到自动建立了giteeproj仓库，点击查看可以到上传的项目目录库
此时代表上传成功
项目的更新上传步揍 每次对项目的更新需要上传到gitee中，不必按照以上繁琐的步揍，接下来介绍简单的方法，对项目进行了更新，比如在index中添加了p标签，或者什么功能，就可以按照一下步骤进行gitee提交。
在gitee中查看，刚才更新的信息，可以看到添加的代码描述
WebStorm项目上传gitee的方法步揍到此结束！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dda7b57c976c60be80d7a2a8c8e60cb/" rel="bookmark">
			线性代数感悟之4 通过增广矩阵查看解的情况上篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在看 liuyubobobo 的 线性代数 课，感觉很妙，有些感悟记录一下~~~
通过增广矩阵查看解的情况：
------------------------------------------------------------------------------------------------------------------------------
主元(首元)定义：非零行的第一个元素。
什么是阶梯形矩阵？
感性定义：可以画个阶梯，阶梯下面都是0
理性定义：
有全零行的话，一定是在矩阵的最下方
主元的位置，随着行号的递增，向右偏。
阶梯下方的元素都是0
如果在阶梯型矩阵的条件下，继续满足一个条件：
4. 主元为1，且主元所在列其他元素为0。
那么 这样的矩阵称之为，rref(行最简形式)，
以下两个矩阵，都满足RREF的定义：
分析：
1 首先它是一个阶梯形矩阵
2 主元为1，且主元所在列其他元素为0。
以下矩阵不是行最简形式：
分析：
第一个是阶梯型矩阵，但是不满足：主元为1，且主元所在列其他元素为0。
第二个和第三个，不是阶梯型矩阵。
----------------------------------------------
接下来将增广矩阵变化成行最简形式，再来判断解的的结构。
首先给出定义：
系数矩阵：这个矩阵只包括原方程组的系数，没有等式右侧的那个常数。（及虚线左边的矩阵）
下图中的A就表示 “系数矩阵”，而未知数的个数就是看，系数矩阵有几列。
这里还有个，行最简形式的非零行，就是整个矩阵的非零行。’
​由于对比的是系数矩阵和整个矩阵，而系数矩阵是被包含在整个矩阵之内的。
所以非零行的个数，只可能是系数矩阵的个数小于等于整个矩阵的个数（不可能大于）。 那么先看非零行是否一致，不一致的话（不相等），那绝对小于。此时无解。 如果一致，再看是有唯一解还是无数解。
小结： 1 最重要的就是系数矩阵的非零行个数 2 先对比非零行是否一致，不一致，无解（一致就在往下看） 3 再看未知数个数，判断有几个解 3.1 如果 未知数个数=A非零行，那此时，A就是一个单位矩阵了！所以一定是唯一解
3.2 如果 A非零行&lt;未知数个数 此时无数解
3.3 不存在 A非零行&gt;未知数个数 的情况：画一下，就知道了，如果非零行大于列数（及未知数个数），那就不满足阶梯矩阵了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30a73ad1b04617960f4a4be4f0df5cb6/" rel="bookmark">
			（四）flink初体验-2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实时报表与table api Apache Flink提供了一个表API作为一个统一的关系型API用于批处理和流处理，也就是说，查询在无边界的实时流或有边界的批处理数据集上以相同的语义执行，并产生相同的结果。Flink中的表API通常用于简化数据分析、数据管道和ETL应用程序的定义。
你要建什么? 在本教程中，您将学习如何构建一个实时仪表板，以按帐户跟踪金融交易。该管道将从Kafka读取数据，并通过Grafana将结果写入MySQL可视化。
前提 本演练假设您熟悉Java或Scala，但即使您来自不同的编程语言，也应该能够理解。本文还假设您熟悉基本的关系概念，如SELECT和GROUP BY子句。
开发环境 Java 11MavenDocker 所需的配置文件可以在flink-playgrounds存储库中找到。下载后，在IDE中打开项目flink-playground/table-walkthrough，并导航到文件SpendReport。
EnvironmentSettings settings = EnvironmentSettings.inStreamingMode(); TableEnvironment tEnv = TableEnvironment.create(settings); tEnv.executeSql("CREATE TABLE transactions (\n" + " account_id BIGINT,\n" + " amount BIGINT,\n" + " transaction_time TIMESTAMP(3),\n" + " WATERMARK FOR transaction_time AS transaction_time - INTERVAL '5' SECOND\n" + ") WITH (\n" + " 'connector' = 'kafka',\n" + " 'topic' = 'transactions',\n" + " 'properties.bootstrap.servers' = 'kafka:9092',\n" + " 'format' = 'csv'\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30a73ad1b04617960f4a4be4f0df5cb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/980c36677e6ea0436ad7eb6a3e81b117/" rel="bookmark">
			不清晰的照片怎么变清晰？分享三个一键变清晰的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信大家都遇到过老旧照片放大后发现变得模糊不清的情况，但毕竟这是我们自己拍的照片，也无法在网上寻找下载原图，那有什么办法能修复这种模糊不清晰的照片呢？ 相信很多朋友会说用PS，但是PS需要一定的基本功，而且操作起来也很麻烦。 其实，除了PS，修复这种模糊不清晰的照片还有很多方法。 今天给大家分享几个方法，让你知道如何让不清晰的照片清晰起来！
1、在线处理：PhotoKi 如果怕麻烦，可以直接使用这款图片在线修复，注册后直接使用即可，而且它的修复效果也是不错的，通过填充模糊照片的细节来制作，让照片更清晰，增强照片的画质。质量高，操作非常简单。接下来，我将演示下如何修复不清晰图片的清晰度。
以下是具体的操作步骤：
第一步：在浏览器搜索“PhotoKi”网站，找到官网后进入首页，然后点击“开始编辑”按钮上传图片。
第二步：成功上传图片后，软件就会自动对图片进行修复，修复完成后，我们点击“保存”按钮就可以将照片保存到本地。
2、手机处理：Styler 这是一款集图片特效和修复功能于一体的手机修复软件。 可以给图片添加各种特效，让照片中的人像看起来更年轻，一键变漫画等，还可以修复照片的清晰度。一键降噪，在照片模糊部分填充细节，提升画质，还原照片清晰度！
以下是软件的具体操作步骤：
第一步：打开软件,在首页找到“+”图标，单击一下并上传要进行修复的照片，然后自定义裁剪一下图片大小，再点击“√”保存设置
第二步：成功上传图片后，在软件下方找到“老照片修复”功能，然后点击“下一步”按钮软件就可以自动修复照片，我们还可以滑动中间的滑动杆查看修复前后的对比，最后点击“保存到相册”按钮即可把修复后的照片保存到相册。
3、电脑处理：牛学长图片修复工具 这款工具可以帮助我们快速完成照片修复，有着批量操作的功能，无需自己一张一张的上传修复，可以批量上传，一键开始批量修复。牛学长图片修复工具基于领先的智能AI修复技术，一键提高模糊照片清晰度，老照片重铸高清、图片无损放大和黑白照片上色等图片修复！对不同场景的图片修复需求，牛学长AI智能都能匹配最佳修复方案，一键修复照片清晰度，在不损失质量的情况下提供最佳效果！
操作步骤也很简单，只需要以下几步：
第一步：打开软件，点击“添加文件”按钮将需要照片添加到软件中，也可以直接将照片拖入到软件中进行添加，可批量添加多张照片进行批量操作。
第二步：如下图所示在右边进行设置，选择AI模型，每个AI模型都有说明比较适合那种类型的图片，可根据图片类型选择适合的AI模型，然后点击“预览效果”等待结果就可以。
修复完成后我们可以在线预览，照片清晰度高度还原。最后点击“导出”按钮即可导出效果图片。
以上就是给大家分享高清修复模糊照片的方法啦！是不是很简单，只需一键即可修复模糊照片，不损失质量的情况下提供最佳效果。感兴趣的小伙伴们不妨去试试！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfae3905b7ddc7547e1c38b7b322d73d/" rel="bookmark">
			通讯录管理系统—优化版 (C语言 期末大作业 课程设计)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 通讯录管理系统 --- 优化版一、设计要求二、总体设计1.系统具体功能2.数据结构设计3.函数功能4.磁盘文件 三、详细设计主界面管理员模块用户模块 四、程序测试1.查看文件2.主界面测试3.管理员界面测试4.用户界面测试5.退出测试 五、系统使用说明使用说明： 通讯录管理系统 — 优化版 一、设计要求 设计一个完整的通讯录管理系统。信息至少包含编号、姓名、年龄、电话、籍贯、单位等。
功能要求如下：
1.管理员功能
（1）建立通讯录信息；（通讯录信息利用文件存储）
（2）能够提供添加、删除和修改通讯录信息的功能；
（3）能够按表格方式输出通讯录信息；
（4）按籍贯或单位统计通讯录人员信息。
2.普通用户功能
（1）按姓名或单位查询；
（2）实现电话的模糊查询（即输入电话的前几位即可查询）；
（3）根据您输入单位自动生成某单位的内部通讯录（按照年龄从大到小保存在一个新的文件中）；
（4）输出某单位的内部通讯录信息。
二、总体设计 1.系统具体功能 本通讯录管理系统具有两个用户状态下的模式，可以通过用户账号进行登录，也可通过管理员账号进行登录；具体如下图所示。
2.数据结构设计 定义一个结构体类型list，包括姓名、年龄、编号、电话、籍贯、单位，共6个结构体成员;使用define定义结构体的长度LEN。
#define LEN sizeof(struct list) //宏定义结构体长度 struct list { char name[30]; //名字 char age[30]; //年龄 int number; //编号 自动生成 char handset[30]; //电话 char address[30]; //籍贯 char unit[30];//单位 }; 3.函数功能 函数名功能说明void admin管理员界面void user用户界面void exit退出void admin_est建立通讯录void est_add添加通讯录void est_delet删除通讯录void est_renew修改通讯录void admin_print_all输出通讯录全部信息void admin_tongji统计通讯录信息void user_jqcx精确查找void user_mhcx模糊查找void user_save保存通讯录到文件sort_computer按计算机成绩排序void user_paixu按姓名字母排序void user_print输出单位通讯录 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfae3905b7ddc7547e1c38b7b322d73d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f935e3f556335bb0347961e8585f75a6/" rel="bookmark">
			CentOS 开启端口（最有效的方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.连接CentOS服务器 查看已经开放的端口：
`firewall-cmd --list-ports` 1 2.查看防火墙的状态： 输入命令
`firewall-cmd --state` 1 3.开启防火墙： 如果上一步处于关闭状态，输入命令开启防火墙：
`systemctl start firewalld.service` 1 4.开启端口 输入命令，开启8000端口：
`firewall-cmd --zone=public --add-port=8000/tcp --permanent &amp;&amp; firewall-cmd --reload` 1 关闭8000端口：
`firewall-cmd --zone=public --remove-port=8000/tcp --permanent` 1 让我们来解释一下上一个命令：
--zone=public:表示作用域为公共的；--add-port=8080/tcp：添加tcp协议的端口8080；--permanent：永久生效；(如果没有此参数，则只能维持当前服务生命周期内，重新启动后失效；) 5.输入命令重新输入配置： `firewall-cmd --reload` 1 1.连接CentOS服务器 查看已经开放的端口：
`firewall-cmd --list-ports` 1 2.查看防火墙的状态： 输入命令
`firewall-cmd --state` 1 3.开启防火墙： 如果上一步处于关闭状态，输入命令开启防火墙：
`systemctl start firewalld.service` 1 4.开启端口 输入命令，开启8000端口：
`firewall-cmd --zone=public --add-port=8000/tcp --permanent &amp;&amp; firewall-cmd --reload` 1 关闭8000端口：
`firewall-cmd --zone=public --remove-port=8000/tcp --permanent` 1 让我们来解释一下上一个命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f935e3f556335bb0347961e8585f75a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b0336a88d4bd9986a18c174d85bacd8/" rel="bookmark">
			JSP的常用标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 JSP的常用标签JSP静态包含JSP动态包含JSP转发 JSP的常用标签 JSP静态包含 &lt;%@ include file=“”%&gt; 就是静态包含
file 属性指定你要包含的 jsp 页面的路径
地址中第一个斜杠 / 表示为 http://ip:port/工程路径/ 映射到代码的 web 目录 静态包含的特点：
1、静态包含不会翻译被包含的 JSP 页面。
2、静态包含其实是把被包含的 JSP 页面的代码拷贝到包含的位置执行输出。
演示
运行结果
JSP动态包含 &lt;jsp:include page=“”&gt;&lt;/jsp:include&gt; 这是动态包含
page 属性是指定你要包含的 jsp 页面的路径
动态包含也可以像静态包含一样，把被包含的内容执行输出到包含位置。
动态包含的特点：
1、动态包含会把包含的 JSP 页面也翻译成为java代码
3、动态包含，还可以传递参数通过&lt;jsp:param name=“” value=“”/&gt;标签
a.jsp
b.jsp
输出页面
JSP转发 &lt;jsp:forward page=“”&gt;&lt;/jsp:forward&gt;是请求转发标签，它的功能就是请求转发。
page属性设置请求转发的路径
可以传递参数，通过&lt;jsp:param name="name"value=“value”/&gt;标签
a.jsp
b.jsp
输出页面（转发后a.jsp的内容不会显示）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40b020628b8428ee57f5411827817f97/" rel="bookmark">
			GraphViz‘s executables not found的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、报错 import pydotplus 运行报错: GraphViz’s executables not found
二、解决方法 1.更新brew（mac终端）
arch -x86_64 brew upgrade 2.安装graphviz
brew install graphviz jupyter里运行代码，成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/642239e8cec864430e9ec201f7efb506/" rel="bookmark">
			阿里测试大师手把手教你基于JMeter开发一个自动化测试平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、基础能力
二、开源精神
三、开发环境搭建
四、配置开发环境（后端部分）
五、配置开发环境（前端部分）
前言 现今的测试行业不停的发展，今天测试人员会代码，已经从一个高阶能力变成了一项基本技能。市场要求测试工程师，或多或少都会一些代码。但是光说不练可不行，如果只是单纯的理论知识很难打动人，但如果你实际开发过一个测试平台，那就不一样了。GitHub 打开看一看，胜过了千言万语。 所以，想要工资要的好，测试平台搞一搞
但开发一个好的测试平台绝非易事，一个好的工具平台，涉及到前后端开发、架构设计、数据库设计、框架选型等综合技能。
一、基础能力 首先我们来看一下，想要基于 JMeter 开发一个测试平台，你需要积累的技术栈。当然这里大家不需要争论开发语言和框架，这是一种可行的方案，不是唯一性方案。
我们将能力拆分成 6 个方面来看，分别是测试相关、JMeter 相关前端开发、后端开发、中间件和运行时环境。
测试相关：
这本身就是我们出发的本源，想要做好测试平台，那肯定需要对测试有深入的理解。那么这里我们又可以再细分一下，需要具备能力的三个方向，功能测试，性能测试和接口测试。
这三种是目前最主要的测试场景，在动手开发测试平台之前，我们自然是要对这几方面的测试知识有深入理解。
c 相关
JMeter 是目前使用最广泛的测试引擎，而且还是一个开源的项目，这也是我们为什么将 JMeter 选做了测试平台开发的核心。
既然 JMeter 作为 C 位出现，那自然是要对其本身进行学习和研究，这里建议对这三方面来学习，首先是常用组件的功能和使用，也就是先要熟悉 JMeter 。其次是学习核心类库，这样可以深入理解 JMeter 的内在逻辑。最后要再学习一下 JMeter 的插件体系，便于对其进行功能扩展。
前端开发：
前端和后端主要是针对于开发的角度，很简单，想要做出一个测试平台，那么一定是需要有一个可以让用户去使用的界面的，那么这里就需要使用到前端的技术 。Vue.js 是现在最炙手可热的前端技术框架了，而且还是咱们中国人主导的开源技术，无数大公司都选择 Vue.js ，找工作时会用 Vue.js 帮助极大，那有什么理由不选择它呢？ElementUI 也类似，是由饿了吗开源的前端组件库。
NPM 是 NodeJS 包管理工具，因为前端项目都会使用到，所以这里应该要对其有一些基本的理解，不需要深入去学习 NodeJS，可以用 NPM 就差不多了。
后端开发：
后端的选择上我相信大家会有自己的意见，所以这里我给出的建议是我自己熟悉的 SpringBoot+Maven，这个组合虽然说不是那么是新潮时髦，但是绝对的值得信赖。而且还要说的是虽然这几年 Java 的热度似乎没有 Python 之类的那么高，但是在真正招聘市场中，Java 依然是第一大的开发语言。而作为 Java 的开发者不搞一搞 SpringBoot，不会用用 Maven，那还能算 Java 程序员吗？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/642239e8cec864430e9ec201f7efb506/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14aa3d4ff8c7035f7ad6ca8da00d5c04/" rel="bookmark">
			八大排序（二）-----堆排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本思想 1):将带排序的序列构造成一个大顶堆，根据大顶堆的性质，当前堆的根节点（堆顶）就是序列中最大的元素
2):将堆顶元素和最后一个元素交换，然后将剩下的节点重新构造成一个大顶堆；
3):重复步骤2，如此反复，从第一次构建大顶堆开始，每一次构建，我们都能获得一个序列的最大值，然后把它放到大顶堆的尾部。最后，就得到一个有序的序列了
构造堆
在构造有序堆时，我们开始只需要扫描一半的元素（n/2-1 ~ 0）即可，为什么
因为(n/2-1)~0的节点才有子节点，如图1，n=8,(n/2-1) = 3 即3 2 1 0这个四个节点才有子节点
（图1：初始状态）
所以代码4~6行for循环的作用就是将3 2 1 0这四个节点从下到上，从右到左的与它自己的子节点比较并调整最终形成大顶堆，过程如下：
第一次for循环将节点3和它的子节点7 8的元素进行比较，最大者作为父节点（即元素60作为父节点）
【红色表示交换后的状态】
第二次for循环将节点2和它的子节点5 6的元素进行比较，最大者为父节点（元素80作为父节点）
第三次for循环将节点1和它的子节点3 4的元素进行比较，最大者为父节点（元素70作为父节点）
第四次for循环将节点0和它的子节点1 2的元素进行比较，最大者为父节点（元素80作为父节点）
（注意这里，元素20和元素80交换后,20所在的节点还有子节点，所以还要再和它的子节点5 6的元素进行比较，这就是28行代码i = j的原因）
至此有序堆已经构造好了！如下图：
调整堆
下面进行while循环
（1）堆顶元素80和尾40交换后–&gt;调整堆
（2）堆顶元素70和尾30交换后–&gt;调整堆
（3）堆顶元素60尾元素20交换后–&gt;调整堆
（4）其他依次类推，最终已排好序的元素如下：
代码实现
public class 堆排序 { public static void main(String[] args) { int[] arr = {1,9,7,5,3,8}; for(int p = arr.length-1;p&gt;=0;p--) { adjestHeap(arr, p,arr.length); } // 堆顶元素和堆底元素互换，维护大顶堆 for(int i = arr.length-1;i&gt;0;i--) { int temp = arr[i]; arr[i] = arr[0]; arr[0] = temp; // 维护大顶堆 adjestHeap(arr, 0,i);	} System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14aa3d4ff8c7035f7ad6ca8da00d5c04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0a3ee4ea6fa58ebd170ba5fc1419f6b/" rel="bookmark">
			【C语言】输出一个菱形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//打印菱形 #include&lt;stdio.h&gt; int main() { int i = 0;//i控制第几行 int j = 0;//j控制每一行空格的循环次数 int k = 0;//k控制每一行*的循环次数 for (i = 1; i &lt;= 4; i++)//将图形分为两部分，前四行(第一部分) { for (j = 1; j &lt;= 4 - i; j++)//打印第i行的空格数 { printf(" "); } for (k = 1; k &lt;= 2 * i - 1; k++)//紧接着打印第i行的*数，注意要带乘号* { printf("*"); } printf("\n");//第i行完成，要换行\n,进入下一行的循环 } for (i = 1; i &lt;= 3; i++)//后三行(第二部分)，和前四行同样的道理 { for (j = 1; j &lt;= i; j++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0a3ee4ea6fa58ebd170ba5fc1419f6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6694aef71d6981e54937fdefb4b1aaa6/" rel="bookmark">
			旅行商问题（回溯算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 回溯问题适合于解由向量的形式来构成的，这个向量空间中使用搜索的方法进行搜索，搜索使用宽度优先的方法。货郎问题又名旅行商问题，但其实更多教科书中更通用的叫法叫旅行商问题，下面来对旅行商问题使用回溯算法证明。
文章目录 一、问题描述二、数学建模三、实例1、传统经典做法2、回溯算法 四、总结 一、问题描述 有n个城市，已知任两个城市之间的距离，求一条每个城市恰好经过一次的回路，使得总长度最小 。
分析：
有n个城市，城市与城市之前有距离的，任意两个城市之间的距离是已知的，现在需要找一条回路，经过每一个城市1次，使得总长度最小，就相当于这个货郎在路途，或者旅行商的行路，遍历所有的城市去各个城市走一趟，但是城市不能重复，所以怎么走下来才能够使得总长度达到最小。
其实相当于把这些城市做一个排列，第一个城市指向k1所指向的城市，由城市k1走向城市k2，一直往下走，走到kn以后再回到k1形成一个闭环
二、数学建模 数学表达式中的C k1到C k2，这两个城市的距离用d来表示，走到最后一个城市再倒回来(从C kn到C k1)，这个距离达到最小，就是我们要做的事情。
这个问题是有选择的，一定程度上讲，TSP也是优化问题，只要是涉及到有选择，选择的不同导致结果的不同，结果的不同要想法设法找出最好的选择，不管是调度问题、背包的装法问题还是这个城市排列的问题，现代的智能优化算法不再使用精确的解，而是找到一个近似最精确的解就可以了。
三、实例 1、传统经典做法 从第1个城市走到第2个城市，从第2个城市走到第4个城市，从第4个城市到第3个城市然后再回来。
C={1,2,3,4}
d(1,2)=5, d(1,3)=9,
d(1,4)=4, d(2,3)=13,
d(2,4)=2, d(3,4)=7
解：&lt; 1,2,4,3 &gt; ,
长度= 5 + 2 + 7 + 9 = 23
这是其中一个解，最后的解得到的是城市的排列向量，上面原始的数据每两个城市之间的距离都是给出的。
2、回溯算法 假定每个城市都有连接，回溯算法的实现也是一种搜索，首先对于第一个城市出发，第1个城市和2，3，4城市相连，这个时候做选择，选择任何一条路径往下走，走到第2个城市，又有两种选择：到第4个城市，或者到第3个城市。每走到一个城市就选相当于前面已经走过的城市就不用再选择了，就从剩下的城市中去选。
一开始选定任何一个出发点出发，接下来又n-1个城市可以去选择，当你走到任何一个点之后，接下来又有n-2个城市可以去选择，……一直到最后只有1种选择，就是唯一的选择：回去。所以总的路径有(n-1)!种，每到叶结点的路径就是城市间的路径。
表示为树，称之为排列树，有(n-1)!片树叶
其实我们要找的就是在所有的排列树叶结点中去找最小的那个，所以搜索空间是相当大的。
四、总结 解：向量搜索空间：树，可能是n叉树、子集树、排列树等等，树的结点对应于部分向量，可行解在叶结点搜索方法：深度优先, 宽度优先, …
跳越式遍历搜索树，找到解 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de683291b12a894a0ef19547ae4f9393/" rel="bookmark">
			idea ssh 连接 (2020.3版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.步骤如下:
2.设置服务器信息
3.点击idea工具栏中
4.选择刚才新建的实例sit，即可连接。
5.注意:若控制台出现乱码，则需要修改字符集 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2307e881c69f504e56547bee21d6dbc/" rel="bookmark">
			笔记--Nvidia Jetson利用Anaconda安装MMDeploy及API测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1--安装Anaconda
2--创建conda环境及安装pytorch
3--配置环境依赖
4--安装mmdeploy
5--实例测试
6--参考
前言 建议结合官方文档阅读。
1--安装Anaconda ①下载Anaconda
cd ~/mmdeploy_test # 进入一个新的文件夹 # 下载anaconda包 wget "https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge-pypy3-Linux-aarch64.sh" bash Miniforge-pypy3-Linux-aarch64.sh # 执行安装 source ~/.bashrc # 更新Path ②设置国内源
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/peterjc123/ conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/peterjc123/ conda config --set show_channel_urls yes ③测试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2307e881c69f504e56547bee21d6dbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e7ba39dcdbaf51226024eddea8f05f0/" rel="bookmark">
			SpringBoot 内置 Tomcat 线程数优化配置，你学会了吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击关注公众号，实用技术文章及时了解
前言 本文解析springboot内置tomcat调优并发线程数的一些参数，并结合源码进行分析
参数 线程池核心线程数 server.tomcat.min-spare-threads：该参数为tomcat处理业务的核心线程数大小，默认值为10
线程池最大线程数 server.tomcat.max-threads：该参数为tomcat处理业务的最大线程数大小，默认值为200，当对并发量有一点值时可以调大该参数
请求最大连接数 server.tomcat.max-connections：该参数为请求的最大连接数，默认值为10000，注意这个参数并不是设置在线程池上的，而是在tomcat的Acceptor类（专门处理连接的线程类）来控制的，结合源码我们可以看到
protected void countUpOrAwaitConnection() throws InterruptedException { if (maxConnections==-1) return; LimitLatch latch = connectionLimitLatch; if (latch!=null) latch.countUpOrAwait(); } 可以看到当最大连接数满了之后会进行等待
accept-count server.tomcat.accept-count：这个参数实际上和tomcat没有太大关系，默认值为100
我们先看下文档的定义
/** * Allows the server developer to specify the acceptCount (backlog) that * should be used for server sockets. By default, this value * is 100. */ private int acceptCount = 100; 这个参数是服务端创建ServerSocket时操作系统控制同时连接的最大数量的，服务端接收连接是通过accept()来的，accept()是非常快的，所以accept-count的不需要太大，正常保持默认值100即可了，acceptCount这个参数和线程池无关，会被映射为backlog参数，是socket的参数，在源码的使用是在NioEndpoint类的initServerSocket方法，在tomcat中的名字是backlog在springboot内置tomcat中名字没有使用backlog而是使用acceptCount
serverSock.socket().bind(addr,getAcceptCount())
protected void initServerSocket() throws Exception { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e7ba39dcdbaf51226024eddea8f05f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fbcb1392a59d99be2230ea686c29143/" rel="bookmark">
			【MATLAB】MATLAB三维曲面绘制【详细教程】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日需要用Matlab绘制一些三维曲面图，并对其进行标注。于是这些天花了些功夫重新梳理了一遍关于Matlab三维曲面作图的一些注意事项，在此记录备案，便于以后使用查找。
任务要求：已知函数形式，绘制三维曲面 此次以下函数为例，介绍Matlab三维曲面的绘制方式
z = 1 − x 2 + ( y − 1 ) 2 z = 1-\sqrt{x^{2}+(y-1)^{2}} z=1−x2+(y−1)2 ​
成品效果图如下：&lt;/li&gt;&lt;/ul&gt; 绘图讲解： 1. 绘制三维图像 [X,Y] = meshgrid(x,y);：将x和y网格化，得到网格化的后的变量X和Y 所谓的网格化即将原本的一维的坐标轴x和y组合，成为一个二维的平面X和Y。可能有些人会觉得不太好理解，我也不太能用语言描述清楚。不过在工作区点开X和Y查看其内部的具体值之后即可理解。
Fig = mesh(X,Y,Z);：以X，Y和Z为数据绘制三维曲面，并将此曲面赋值给Fig 在最开始的时候我都是用mesh(X,Y,Z)而不用其返回值，后来发现使用返回值调整参数更加容易（这个具体后续细说）
在掌握这两段代码后，能够绘制一个最基本的三维曲面，代码如下：
clear;clc; %清除前置数据 %数据预处理
x = linspace(0,1,50); %设置x轴的范围
y = x; %设置y轴范围
[X,Y] = meshgrid(x,y); %将其x，y轴网格化
Z = 1-sqrt((X).2+(Y-1).2); %直接计算
%绘制曲面
Fig = mesh(X,Y,Z); %绘制三维曲面图
由此我们能得到一个非常简陋的三维曲面，而这样的曲面距离我们的要求还有一段距离。
2. 坐标轴的设置 上图最明显的感觉就是太空了，因此我们需要为其加上坐标轴：
xlabel('x');：设置x轴的变量为xylabel('$y$','interpreter','latex');：将y轴的变量设置为LaTeX格式的y（这里的代码和LaTeX公式代码完全一致）zlabel('$z$','interpreter','latex','FontSize',18);：除上述功能外，设置z轴变量的字体大小为18pttitle('$z = 1-\sqrt{x^{2}+(y-1)^{2}}$','interpreter','latex','FontWeight','bold');：命名标题且加粗 坐标轴的设置还有很多功能，比如说替换字体这种，可以通过帮助文档（在命令行输入help text查看）
注：这里help的是text，这样才有足够详细的可选项说明
我们通过以下代码设置坐标轴的格式：（这里的L(i)同上述Fig可以去掉）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fbcb1392a59d99be2230ea686c29143/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/287871ea41a054661e504f9778bd73e1/" rel="bookmark">
			关于Element Plus图标组件局部引用问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用官方给出的可能看不到效果，以UploadFilled图标组件为例子，可以试试这种方法
// 引用（看自己下载的使@element-plus/icons还是@element-plus/icons-vue,我这里是icons） import { UploadFilled } from "@element-plus/icons" // 注册 components: { [UploadFilled.name]: UploadFilled } // 使用 方法一：&lt;upload-filled /&gt; 方法二：&lt;UploadFilled /&gt; 方法三：&lt;upload-filled class="upload-filled-icon" /&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73e3f50ce5bc022302123ab2d2403eaa/" rel="bookmark">
			一.c#基础 [Unity_Learn_RPG_1]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.C#、unity C# 基础 1.面向对象 1).面向过程和面向对象 a.面向过程 就是把一个需求/问题，分成一步步的逻辑，很像数学里的解答。
关心的是解决问题的步骤。
b.面向对象 把需求分为一个个对象。
关心的是对象在做什么。以及对象之间的交互。
2).类和对象 a.先有类还是现有对象 设计角度：现有对象，再有类。根据需求，我们从中分析，提取出一有相同行为的"类”。
编码角度：肯定是先有类了，不然new 什么呢？
b.类与类 类是抽象的。是抽象的"类别"。类与类行为不同。
什么是行为？我的理解其实就是代码，如果一个类的代码改变了，那么它的逻辑也改变，逻辑改变体现在对象的实际执行上，也就是对象的行为也会因为逻辑的改变而改变。
那么不同类的代码肯定是不一样的，所以行为也不一样。
c.对象与对象 对象和对象数据不同。
不同类的对象就不说了。同类型的对象呢？
d.区分是对象不同还是类不同 比如人这个类。
游戏的捏脸功能就是如此，修改一些不同的属性数据即可。比如有的人腿长，有的人腿短，只是数据不同。
但是如果需求要人能飞，能射出蛛丝，“一般"来说我们就得新建一个类了。给它加上 飞行/喷射蛛丝 的行为。
所以，对象和对象的不同，只是数据上，比如腿的长短。而类就得是 行为/功能 上的不同。
类与类行为不同；对象与对象数据不同。 2.主要思想 分而治之
将一个大的需求分解为许多类，每个类处理一个独立的模块。
拆分好处：独立模块便于分工，每个模块便于复用，可扩展性强。
封装变化
变化的地方独立封装，避免影响其他模块。
高内聚
类中各个方法都在完成一项任务(单一职责的类)。
复杂的实现封装在内部，对外提供简单的调用。
低耦合
类与类的关联性依赖度要低(每个类独立)。
让一个模块的改变，尽少影响其他模块。
1).分而治之和封装变化 分而治之其实就是模块化。
封装变化：
比如我们可以攻击，但是攻击可以分为用手，用武器，等。那么我们就应该用一个专门的武器类来封装这些。
难点在于，什么时候该用类来封装。老师的说法是，变化。
就比如攻击，当攻击方式多样化的时候，就应该封装了。
2).高内聚和低耦合 也很简单。老师也列了一个例子。
[例如：硬件高度集成化，又要可插拔]
最高的内聚莫过于类中仅包含1个方法，将会导致高内聚高耦合。
最低的耦合莫过于类中包含所有方法，将会导致低耦合低内聚。
高内聚高耦合
说的是，如果类都是最简单的一个方法那种，是高内聚了，但是实现一个功能，往往不可能这么简单，那么就得调用多个类，导致高耦合。
低耦合低内聚
极端的一个类囊括所有功能。低耦合的确，但是各种功能都在一个类，导致了低内聚。
2.继承 复习一些基础知识
1).栈和堆 深入理解堆栈、堆在内存中的实现
什么是堆？什么是栈？他们之间有什么区别和联系？
推荐看这篇知乎回答。
管理方式：栈由编译器自动管理，无需人为控制。而堆释放工作由程序员控制，容易产生内存泄漏（memory leak）。
空间大小：在32位系统下，堆内存可以达到4G的空间（虚拟内存的大小，有面试官问过），从这个角度来看堆内存大小可以很大。但对于栈来说，一般都是有一定的空间大小的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73e3f50ce5bc022302123ab2d2403eaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e79db9d80905878af98f00edb31bc12/" rel="bookmark">
			【1&#43;X】正交实验法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想看更多内容请移步专栏 转载：【1+X】软件测试技术 - 正交实验法 - 蓝桥云课 (lanqiao.cn)
正交实验法 知识点 正交实验法介绍正交实验法案例 简介 判定表法和因果图法均是考虑有多个输入条件，并且不同的输入条件的组合会得出不同的动作的情况，但他们不适合输入条件过多的情况。比如某学校有一个查询历年学生档案的程序，有 5 个查询条件，如下图所示。可以通过程序界面上查询条件中的其中一项或多项进行查询，然后把查询结果罗列出来。那么测试人员该如何对该查询功能点进行测试呢？
暂且不考虑每个文本框输入内容的限制，只考虑他们“填”或“不填”的组合条件查询的话，可以设计出 25=32 条测试用例，根据组合的原理，设计用例如下表所示。
序号姓名专业年级班级户籍地1不填不填不填不填不填2不填不填不填不填填3不填不填不填填不填4不填不填不填填填5不填不填填不填不填6不填不填填不填填7不填不填填填不填8不填不填填填填9不填填不填不填不填10不填填不填不填填11不填填不填填不填12不填填不填填填13不填填填不填不填14不填填填不填填15不填填填填不填16不填填填填填17填不填不填不填不填18填不填不填不填填19填不填填填不填20填不填不填填填21填不填填不填不填22填不填填不填填23填不填填填不填24填不填填填填25填填不填不填不填26填填不填不填填27填填不填填不填28填填不填填填29填填填不填不填30填填填不填填31填填填填不填32填填填填填 仅仅组合“填”或“不填”的组合测试，就有 32 条测试用例，测试用例太多了，投入和回报不相符。那如果随机取部分用例进行测试呢？测试时又没有把握，那些没有被测试到的组合该怎么办呢？那么作为测试人员，该怎么解决这种问题呢？这个时候就要使用到正交实验法，正交实验法设计测试用例是考虑用最少的用例来覆盖大量组合的情况。接下来一起来看一下什么是正交实验法。
正交实验法介绍 正交实验法是套用正交表来设计测试用例的方法。
那什么是正交表呢？古希腊是一个多民族的国家，国王在检阅臣民时要求每个方队中每行有一个民族代表，每列也要有一个民族的代表。数学家在设计方阵时，以每一个拉丁字母表示一个民族，所以设计的方阵称为拉丁方，正交表由此演化而来。正交表是通过运用数学理论在拉丁方和正交拉丁方的基础上，从大量的（实验）数据中挑选合适的、有代表性的条件组合构造而成的规格化表格。
正交实验法是一种基于正交表的、高效率、快速、经济的实验设计方法，它研究的“多因素多水平”的情况，然后套用正交表来随机地产生用例（用例之间没有主次之分），是一种提高测试覆盖率的简单易用的方法。
因素（Factor）：在一项实验中，凡是被考查的变量就称为因素。
水平（Level）：在实验范围内，因素被考查的值称为水平。
前文有提到，正交实验法是套用正交表来随机地产生用例的一种方法。一些测试新人容易陷入“研究如何得出正交表”的错误思维，在此提醒一下，正交表格是无数科学家的智慧凝聚而成，读者无需去深究正交表是如何得出的，我们在设计测试用例的时候直接去套用对应的表格即可。
查询正交表的方式有 2 种：
为方便读者使用，本书在附录 1 中列出了一些常用的正交表格。可通过附录查询适合的正交表。通过链接查询：http://support.sas.com/techsup/technote/ts723_Designs.txt 正交表的表现形式可描述如下：
L 行数（水平数因素数）
行数（Runs）：正交表中行的个数，也就是实验的次数，也指测试用例的个数。
因素数（Factors）：指正交表中列的个数。
水平数（Levels）：任何单个因素能够取得的值的最大个数。
如何选择正交表是一个关键问题。首先考虑因素的个数，其次考虑因素水平的个数，最后考虑正交表的行数，且选择符合条件的行数最少的一个正交表进行套用。笔者会通过案例详细讲解它的套用方法。
读者可能会有疑问，正交实验法是根据正交性从全面实验中挑选出部分有代表性的点进行实验，它的选择原理是什么呢？为什么这个表格可以代表所有的实验可能呢？主要是因为选择出来的这些有代表性的点具备了“均匀分散、齐整可比”的特点。
** 整齐可比性:** 在同一张正交表中，每个因素的每个水平出现的次数是完全相同的。由于在实验中每个因素的每个水平与其他因素的每个水平参与实验的几率是完全相同的，这就保证在各个水平中最大程度的排除了其他因素水平的干扰。因而，能最有效地进行比较和做出展望，容易找到好的实验条件。
均衡分散性: 在同一张正交表中，任意两列（两个因素）的水平搭配（横向形成的数字对）是完全相同的。这样就保证了实验条件均衡地分散在因素水平的完全组合之中，因而具有很强的代表性，容易得到好的实验条件。
以上特点充分体现了正交表的两大优越性，通俗地说，每个因素的每个水平与另一个因素的每个个水平都能够出现一次组合，这就是正交性。使用正交实验法设计测试用例的步骤如下：
确定有哪些因素？确定每个因素有几个水平？选择合适的正交表。把变量的值映射到表中。加上认为可疑且没有在表中出现的组合。把每一行的各因素水平的组合作为一个测试用例 正交实验法案例 案例 1-学生信息查询 如本节开篇所示的程序“历年学生信息查询”界面，利用正交实验法对其设计测试用例。
【解析】：
确定表中的因素数。
共有 5 个因素：姓名、专业、年级、班级、户籍地。故因素数=5。
确定每个因素的水平数。
通过分析，以上 5 个因素的水平数均为“填”和“不填”。故水平数=2。
选择合适的正交表。
通过第 1 步和第 2 步的分析，正交表应该是 25，但经过查询附录 1，表格中接近的只有 L4（23）和 L8（27），那么我们只能选择 L8（27），因为如果选择列数少的表格会缺失部分因素的取值。但如果表格中列数数多于实际因素数，则把表格中多余的列简单粗暴地直接删除就可以了。L8（27）正交表如下表所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e79db9d80905878af98f00edb31bc12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b036eb27b2d5ab8db81c3016a881a2e4/" rel="bookmark">
			李宏毅机器学习笔记【未完】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		李宏毅2021/2022春机器学习课程
【《2021机器学习-李宏毅》学习笔记】
一、机器学习 1.机器学习基本概念 找一个函数。
深度学习：使用类神经网络的函数。
可以有各式各样的输入：向量，矩阵（如图像），序列（如语音，文本）；也可以有各式各样的输出：数值（regression），类别（classification），文本图像…
函数类别 Regression（回归）：输出是一个数值（scalar）
Classification（分类）：给定选项/类别（classes），输出正确的
Structured Learning：创造一些结构（image，document）
如何找一个函数（训练） 1.Function with unknown parameters.
model：
y = b + w x 1 y = b + wx_1 y=b+wx1​
x：feature；w：weight；b：bias
2.Define loss from training data.
Loss是未知参数的函数，L(b, w)，How good a set of value is.
例如，MAE，MSE；error surface（误差曲面）
3.Optimization 找到一组w和b让loss最小
w ∗ , b ∗ = a r g m i n w , b L w^*,b^* = arg\underset{w,b}{\mathrm{\ min}}\ L w∗,b∗=argw,b min​ L
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b036eb27b2d5ab8db81c3016a881a2e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6e46de6b4394fa7322070fa1eb23c2c/" rel="bookmark">
			想学习C语言的第不知道多少天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://bbs.csdn.net/skill/c
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ae5e513f91cccea86c92066c5c2da70/" rel="bookmark">
			《我要进大厂》- Spring框架 夺命连环22问，你能坚持到第几问？（Spring高频问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		??博客首页：热 ??
??文章目的：Spring框架高频 面试题分享??
文章出处：Spring常见问题总结
??博主在学习阶段，如若发现问题，请告知，非常感谢??
??同时也非常感谢各位小伙伴们的支持??
??每日一语：脚踏实地，勇往直前，你走过的路，每一步都算数！??
??感谢： 我只是站在巨人们的肩膀上整理本篇文章，感谢走在前路的大佬们！??
??最后，祝大家每天进步亿点点！ 欢迎大家点赞??收藏评论??支持博主??！??
上篇文章-《我要进大厂》- 计算机网络夺命连环23问，你能坚持到第几问？（TCP 三次握手、四次挥手）
文章目录 一、什么是 Spring 框架?二、列举一些重要的 Spring 模块？三、Spring,Spring MVC,Spring Boot 之间什么关系?四、Spring IOC &amp; AOP 4.1 谈谈自己对于 Spring IoC 的了解4.2 谈谈自己对于 AOP 的了解4.3 Spring AOP 和 AspectJ AOP 有什么区别？ 五、Spring Bean 5.1 什么是 Spring Bean？5.2 将一个类声明为 Bean 的注解有哪些?5.3 @Component 和 @Bean 的区别是什么？5.4 注入 Bean 的注解有哪些？5.5 @Autowired 和 @Resource 的区别是什么？5.6 Bean 的作用域有哪些?5.7 单例 Bean 的线程安全问题了解吗？5.8 Bean 的生命周期了解么? 六、Spring MVC 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ae5e513f91cccea86c92066c5c2da70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a3003246bb20083c95fa70aa31a52e7/" rel="bookmark">
			Typora中将多张图片并排/分行显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		居中并排
&lt;center class="half"&gt; &lt;img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnfolw5kxj30u00u0qe5.jpg" width="300"/&gt; &lt;img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnfolw5kxj30u00u0qe5.jpg" width="300"/&gt; &lt;/center&gt; 左对齐并排
&lt;figure class="third"&gt; &lt;img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnfolw5kxj30u00u0qe5.jpg" width="200"/&gt; &lt;img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnfolw5kxj30u00u0qe5.jpg" width="200"/&gt; &lt;img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggnfolw5kxj30u00u0qe5.jpg" width="200"/&gt; &lt;/figure&gt; &lt;center class="half"&gt; &lt;img src="E:\2020\....jpg" width = "50%" alt="***" align=left /&gt; &lt;img src="E:\2020\... .jpg" width = "50%" alt="***" align=right /&gt; &lt;center&gt; 修改图片大小
&lt;img src="E:\2020\... .jpg" width = "50%" height = "70%" alt="图片名称" align=left /&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35c00c08c2982fcd05e40fa3ca98448d/" rel="bookmark">
			WebStorm代码上传的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.创建本地仓库 2.在git上创建一个仓库 3.绑定上传地址 4.然后正常上传就可以了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eab138a3f444c7b9cc9a8961f9e7b832/" rel="bookmark">
			python编写程序实现：有一栋9层高的宿舍，每层各有24间房间，请随机生成n间宿舍存放在列表dorm_list中给网络系使用，其中n由用户输入，寝室编码为x0y，x为楼层，y为宿舍编号。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import random floor = 9 room = 24 n = int(input("请输入您需要的房间数：")) b = "{x}0{y}" dorm_list = [] for i in range(n): x = random.randint(1, floor) y = random.randint(1, room) if i &lt;= n: dorm_list.append(b.format(x=x, y=y)) print("网络系可以使用的房间在dorm_list内有：") for j in dorm_list: print(j, end=" ") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef720a116132500c217af99be0bfbf36/" rel="bookmark">
			动态规划（中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		确定dp数组（dp table）以及下标的含义确定递推公式dp数组如何初始化确定遍历顺序举例推导dp数组 以上内容参考及总结参考（leetcode 和 代码随想录）：随想录—参考链接
3.打家劫舍（中） 198. 打家劫舍 题目描述： 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2： 输入：[2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 class Solution: def rob(self, nums: List[int]) -&gt; int: pre , cur = 0 , 0 for num in nums: pre , cur = cur , max(pre+num,cur) return cur 213.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef720a116132500c217af99be0bfbf36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c82018e4c0b232f4c5fd6b67a3ccf3ff/" rel="bookmark">
			毫米波雷达传感技术方案，爱希ISEE人体感应器，智能感应人体存在控制应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		雷达感应器是基于多普勒雷达技术的自动感应控制产品，当有人进入感应范围时，雷达传感器探测到人体，自动接通负载，人不离开感应范围，将持续接通；人离开后，延时自动关闭负载。
人到灯亮，人离灯熄，亲切方便，安全节能，更显示出人性化关怀。毫米波雷达感应器，人体存在感知，灯光控制，节能环保，安全防护，适用于各种环境，支持第三方对接。
雷达传感器从原理上即具有明显的误触发低（可通过算法过滤），感应区域大（天线可配置），精准有效触发（特征点可复用）的优势。
可穿透雨雪雾，玻璃亚克力等材质，不受恶劣环境如温度，空气等环境影响也能够做出高颜值的外观。
人体存在雷达传感器，真正解决了目前行业的痛点，做到了静止存在人体监测。让我们隔着三四米盖着被子睡觉也可以被感知。
雷达人体感应器性能稳定，真正做到了既节能又环保，可以说是声控产品的替代产品。它是通过感应人体的存在、能自动快速开启各种灯具、防盗报警器、自动门等各种设备。
特别适用于酒店宾馆、公寓、办公室、商场、过道、走廊等。人体呼吸存在传感器，利用毫米波雷达技术，针对不同环境特点（空间大小，环境复杂程度）精选合适的ISM雷达频段。
通过人体进入环境后的距离，相位，呼吸，心跳等电磁波反馈信号数据进行特征提取，深度算法比对处理，进而分析环境中是否有人体存在。
不仅可以感知动态人体，还可以精准感知静态体征，在挂高3米的场景下，可以有效侦测到40平方米环境内人体的呼吸，超过100平方米的大动作。
人体存在感应器触发的时候不需要人发出任何声音，而是检测人体存在（呼吸存在、静止微动等）控制灯具的开启，当人离开后，经过一定时间的延时，自动熄灭。
因为不同于声光控灯，不需要声音和开关控制，从而避免了声控噪音的侵扰，同时因为它是感应人体控制开关，所以避免了无效电能的损耗，达到节能效果。
人体存在雷达传感器，可通过APP或者拨码可调整设备的灵敏度，延时，距离，从而大大提高了产品对环境的适应能力，做到与应用场景深度无缝衔接。
采用了极具优势的深度算法，相较于市场上友商的雷达传感器，能够做到有效过滤中央空调，窗帘，风扇，强电以及密集布景等安装环境的误触发。
雷达人体存在传感器在接口方面，提供了包含干接点，强电，PLC，485多样化接口，通讯方式也可支持涂鸦/私有云/LORA/NB等多种主流通讯方式。
当室内有人，且在选定的空间范围（如办公室、客厅）内间歇地活动时，该装置能保证正常供电，使用电设备正常、连续、稳定的工作。
人体感应器探测人体接近距离远近可调；探测区域呈扇形，覆盖空间范围大；环境温度适应性能高；非接触探测；抗射频干扰能力强。
与其他传感技术不同，毫米波具有非接触性和非干涉性，全天时全天候检测，可以穿过塑料、干墙和衣服等材料，使传感器可以隐藏在面板背后，广泛应用于第三卫生间、母婴室、智能家居、智慧消防、智慧酒店、智慧办公等应用场景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/210e4a5dd4018d941a3f4a57b80e42df/" rel="bookmark">
			仅使用Dveaver（无需借助其他工具）一分钟导完/同步完几十万条数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、不同连接源，不同数据表结构数据同步 1、在当前连接上执行sql语句查询出要导出的记录
2、鼠标右击，选择【导出结果集】
3、在【数据转化】页选择我们该次的导出方式-&gt;【数据库表】；
4、在这里选中我们要转移到的目标表；
5、依次选择我们的查询结果将要导入的相应字段；
6、一直点击下一步，知道出现【开始】按钮，即可开始进行数据同步；
7、完成后刷新即可看到我们同步好的数据；
二、倘若是“不同连接上”的“相同表结构”进行数据同步的话那就更简单了 1、右击表名称，选择【导入数据】；
2、选择表-&gt;数据库表；
3、点击选择【源端】里对应的数据库表；
4、一直点击下一步即可完成数据同步；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dbbcc3e369bd336345f2f09b47fd80d/" rel="bookmark">
			安卓手机远程控制DIY智能家居设备(ESP8266)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、准备材料:
手机（安卓手机，如果没有请忽略整篇文章）。电脑（windows， 如果没有请忽略整篇文章，此文章不适合大神阅读）。DIY智能设备（ESP8266基本上是绕不过去的，如果没有那就买一套，最多也就几十块钱，如果没有也不想买请忽略本文的绝大部分内容）网络服务器（可以在阿里、腾讯、华为等平台租赁服务器，最低配置的就可以了！花费几十到几千，可以找促销活动的时候买，我在腾讯140米买了3年的一个最低配置的服务器，目前对我来说完全足够使用了！）。服务器域名（自己玩的话可以忽略,反正到目前为止我的服务器还是没有域名，一直用服务器IP直接登录和连接）。 二、准备软件:
python3 用于服务器端程序的开发。ArduinoIDE 用于ESP8266WIFI模块的程序开发。www.wxbit.com 在网页上开发安卓手机app。 三、通信协议：
MQTT协议，非常适用于DIY智能家居的控制。其他协议，标准的非标准的自定义的都可以。 四、开发流程：
先使用www.wxbit.com 开发手机APP，平台上有标准的MQTT通信组件！可以在手机上先模拟控制智能家居设备，这个成本最小、上手最快！。(部分高级功能需要会员才能使用，对于初级玩家来说免费的部分就已经足够了) ESP8266程序开发，程序代码基于C/C++ 也很简单，网上例子一大把！先让模块跟服务器之间可以正常通信！剩下的再慢慢熟悉。服务先使用免费的服务器做开发测试。 服务器端程序开发，自己玩推荐使用Python开发。程序代码简单上手快！服务器端可以进行个性化定制。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87748f08ddee2f0823abc59feec9bdc5/" rel="bookmark">
			M1芯片Mac安装lightgbm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、报错内容 在Jupyter notebook中导入lightgbm时报错：
Referenced from: /opt/homebrew/anaconda3/envs/biligame/lib/python3.7/site-packages/lightgbm/lib_lightgbm.so Reason: tried: '/usr/local/opt/libomp/lib/libomp.dylib' (no such file), '/usr/local/lib/libomp.dylib' (no such file), '/usr/lib/libomp.dylib' (no such file) 二、尝试失败 1.一些解决方法 找了很多文章，尝试了无数次，无果。。。最详细的是这一篇：
[python] [lightgbm] Mac下安装lightgbm 其他参考：
M1芯片mac安装xgboost和lightgbm
MAC m1安装lightgbm时报错
三步在MacOS Anaconda安装ligthGBM
python3——解决MAC在import lightgbm时报错image not found
Mac环境下安装LightGBM的闯关记
MacBook Pro中安装LightGBM的超详细步骤
2.我的问题 我每次执行到这一步就会失败
git clone --recursive https://github.com/Microsoft/LightGBM 所以我放弃了
尝试在jupyter里重新用pip安装：
安装没问题√
pip install lightgbm 导入没问题√
import lightgbm as lgb 可是，运行模型会提示内核挂掉 。。。。
三、解决办法 功夫不负有心人，在我准备放弃之时，居然找到了解决方法！
超简单的，为什么我一开始没想到！
1.在jupyter里运行： conda install lightgbm 运行结果很长，看上去很曲折，但是成功了！
The following packages will be downloaded: package | build ---------------------------|----------------- _anaconda_depends-2021.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87748f08ddee2f0823abc59feec9bdc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cab457013d9a0032eaa113211fbc6ff0/" rel="bookmark">
			使用matplotlib绘制饼图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据消费类别，如外卖、零食、衣服、娱乐等，使用matplotlib绘制本月的消费支出饼图。
以代码插入方式提交源代码。并以图像文件提交运行截图
python代码：
import matplotlib.pyplot as plt from pylab import * mpl.rcParams['font.sans-serif'] = ['SimHei'] # 显示中文字体 name = ["外卖", "零食", "衣服", "娱乐", "其他"] # 饼状图标签 data = [84, 79, 46, 62, 1] lt = [] for i in range(len(data)): result = data[i] / sum(data) # print(result) lt.append(result) # print(lt) print(lt) plt.axes(aspect=1) plt.pie(x=lt, autopct='%1.2f%%') # x表示饼状图的数据，autopct后面的值1.2表示保留2位小数，1.1表示保留一位小数 plt.legend(name, loc="best") # 绘制图的图例为name，位置为最佳 plt.title("本月的消费支出饼图") # 饼图的名称 plt.show() 运行截图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b04b2393aefd2ff0fd96d1b5daf628e1/" rel="bookmark">
			使用endnote在毕业论文中插入文献
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		endnote下载地址 文献管理软件 EndNote X9.3.3 中科大批量授权版(中文一键直装)
GBT7714格式下载地址 Chinese Standard GBT7714 (numeric)
第一步：下载endnote，中科大批量授权版可以直接安装不需要破解。全部按默认选项安装，安装完成后，word或wps的工具栏会有 endnote选项
第二步：下载需要的格式文件。毕业论文一般使用GBT7714格式，在endnote官网即可下载 Chinese Standard GBT7714 (numeric)。下载完成后，将格式文件放到Endnote安装目录下Styles文件夹中。
第三步：从知网下载论文索引信息。
第四步：打开endnote，点击 file-&gt;new ，添加新的数据库。
第五步：点击 file-&gt; import file -&gt; file。在弹出的对话框中，Import file选择第三步下载到的txt文件，Import Option选择 Endnote Import.其他选项默认，点击 import 完成导入。
第六步：此步可选。如果有pdf格式的论文文件，可以选中endnote中对应的论文后，点击右面的附件符号，上传pdf文件，这样就可以在endnote中看论文了。
第七步：打开wps，将endnote设置为第二步中下载的格式。
第八步：在需要插入文献的位置点击 Insert Citation。
在弹出的对话框上搜索想要插入的文献。选中后点击 Insert
成功插入效果如下
第九步：调整首行缩进。endnote默认的序号和文献之间的空间过大。毕业论文中一般需要将它调节为只空一格。首先，打开endnote。点击edit-&gt;output styles-&gt;edit GBT7714(即需要调整的格式)。在弹出的对话框中，选择Bibliography节点下的layout。在右侧，仅保留[Bibliography Number]，然后在后面加一个空格。endnote会将输入的空格显示为图中的.
第十步：调整多行参考文献的缩进。打开wps，点击edit&amp;manage
在对话框中选择 Tools -&gt; configure Bibliography 。
修改 hanging的值。由默认的1.270改为0.635即可。
调整完缩进后效果如图
参考网站
Endnote 使用简易教程（科研狗必备）
在endnote中添加Chinese Standard GBT7714格式
Endnote插入参考文献的对齐方式和缩进空格修改
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5df44f7916932cb628b5c4ed9bedd006/" rel="bookmark">
			SQL入门之第二一讲——IF函数的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IF函数主要有：IF函数嵌套和IF+聚合函数 两类，主要是用来根据条件返回不同值。
基本语法为;
IF(条件表达式,值1,值2) 如果条件表达式为True，返回值1，为False,返回值2.返回值可以是任何值，比如：数值，文本，日期，空值，NULL，数学表达式，函数等。 1、IF函数 实例1：在学生表中，将1995年以后出生的学生划分为2班，将1995年(包括1995)之前的学生划分为1班，最后显示Sname,Sage,所在班级这三列。
select Sname as '学生姓名', Sage as '学生年龄', IF(YEAR(Sage)&lt;=1995,'1班','2班') as '所在班级' from students ORDER BY Sage; 2、IF函数嵌套 当分类大于两种或者以上时，就可以使用IF函数嵌套。 实例2：在学生表中，将学生编号小于等于3的学生，分为1班，学生编号在4-6的学生，分为2班，学生编号大于等于7的学生，分为3班，最后显示Sid,Sname,所在班级这三列。
select Sid as '学生编号', Sname as '学生姓名', IF( Sid &lt;= 3,'1班', IF(Sid &gt;= 7,'3班','2班') ) as '所在班级' from students order by Sid 3、IF + 聚合函数 IF 还经常与聚合函数一起结合使用 实例3：将学生表和教师结合使用，计算班主任所带的学生数量，大于等于5人以上的显示：5人以上，人数小于5人的显示：5人以下。
select t.Tname as '老师姓名', count(*) as '人数', IF( count(*) &gt;= 5,'5人以上','5人以下' ) as '分类' from teachers as t join students as s using(Tid) GROUP BY t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5df44f7916932cb628b5c4ed9bedd006/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/439672dddbaf0abfa41fd8168345d10d/" rel="bookmark">
			linux c语言 线程sleep有关测试总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.线程中不使用sleep，不会造成线程切换问题。
2.线程中使用sleep，会使cpu的占有率降低。让其他线程或进程，运行得更有效。
3.使用sleep(0)和不使用sleep，效果差别不大，都不会使cpu睡眠。usleep(0)和usleep(1)效果相同，都会使cpu睡眠。
4.信号量和互斥锁阻塞时候都不会占用cpu。
5.nanosleep没有令cpu睡眠时间比usleep(1)更短。
6.如果需要cpu快速运行，又能获得睡眠，可以使用循环一定次数后，用usleep(1)睡眠一次。
参考：
信号量和互斥锁阻塞时，cpu占用率测试_工程师-CSDN博客
Linux c语言sleep多线程while循环实验_工程师-CSDN博客
linux c语言sleep不占用cpu的验证_工程师-CSDN博客
linux c语言sleep的时间实验_工程师-CSDN博客
linux C 多线程_工程师-CSDN博客
互斥锁机制，互斥锁与读写锁区别_CET4_的博客-CSDN博客_读写锁和互斥锁的区别
Linux内核锁机制——信号量、互斥锁、自旋锁、原子操作详解 - 百度文库 (baidu.com)
posix多线程有感--自旋锁-taohorse-ChinaUnix博客
pthread_spin自旋锁_gdut17的博客-CSDN博客_pthread_spin_init
linux多线程：自旋锁_老王不让用的博客-CSDN博客_pthread_spin_init
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cc56bf162886d3c1438bcaddabd155a/" rel="bookmark">
			详解 —— HTTP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 HTTP协议格式和抓取
1.1 HTTP抓取
1.2 格式总结
2 请求的格式
2.1 请求行
2.2 请求头
2.3 空行
2.4 请求正文 3 响应的格式
3.1 首行
3.2 响应头
3.3 空行
3.4 响应正文 4 HTTP请求
4.1 认识URL
URL encode/decode 4.2 HTTP方法
5 HTTPS
5.1 SSL/TLS
HTTP是基于TCP处于应用层的一种协议，与传输层协议不同，它关注的不是像TCP那样的可靠传输，而是站在应用的角度，对传输的信息来具体的使用。HTTP广泛应用于手机APP和浏览器之中。 1 HTTP协议格式和抓取 我们之前已经讨论过了关于TCP和UDP这两种协议了，而上述的两种协议是属于“二进制协议”，通常需要理解到二进制的bit位（例如TCP中的六位标志位，若代表ACK的那一位为1，则代表这一条为ACK）。
HTTP属于文本格式的协议，因此不需要去理解具体的二进制位，而只需要理解文本格式即可，也更方便用肉眼去观察。
1.1 HTTP抓取 而想要获取一些具体的HTTP交互过程中的信息，就需要一些抓包工具了。我们可以将这些抓包工具看做是一个代理 ，请求和响应都需要路过代理，这时候在代理上就很容易获取到请求和响应的详细信息了，我当前使用的是Fiddler。
Fiddler左侧是一个列表，显示了当前抓到的所有HTTP/HTTPS的数据报。
当选中左侧列表中的某个条目，双击的时候，右侧就会显示这个条目的详细信息。 其中上面的那部分是HTTP请求，下面的是HTTP响应。
但是我们会发现上述两个信息框里大半都是乱码信息，我们就需要选择Row这一选项来观察这些信息的本体，其它选项相当于Fiddler对数据进行了一些加工。以下就是请求原来的样子：
针对响应也是一样，但不一样的是响应是经过压缩的，所以还需要要经过解压缩之后才能看到本体
1.2 格式总结 2 请求的格式 HTTP的请求分成四个部分：1、请求行；2、请求报头；3、空行；4、请求正文
2.1 请求行 请求行包括三部分，每一部分之间用空格隔开，它们分别是：
HTTP方法：大概，描述了这个请求想要干什么，例如get意思就是想从服务器获取到什么
URL：描述了要访问的网络上的资源具体是在哪
版本号：表示当前使用的HTTP的版本是什么，目前常用的版本是1.1
2.2 请求头 这一部分一般有很多行，每一行都是一个键值对，键和值之间通过 ：空格 来分割。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cc56bf162886d3c1438bcaddabd155a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd4fe438e6563ea74474ecd9782fecbc/" rel="bookmark">
			【保姆级讲解】C语言---预编译处理精华
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预编译处理 1.1预编译处理概述 预编译处理也称为编译预处理，是在程序正式编译之前需要进行的前期编译处理阶段。主要作用是向编译器传递信息。以井号（“#”）开头的命令都是编译预处理命令，并且编译预处理命令后面没有分号（“;”）。
预处理:头文件 #include &lt;stdio.h&gt; 预处理阶段进行的(完成替换) 后面没有;
预处理阶段相关命令:GNU套件中的gcc编译器 参数-E 生成文件后缀为xxx.i
未包含头文件的预处理与源文件的比较:
编译预处理命令格式:gcc -E 1.c -o 1.i
包含头文件的预处理与源文件的比较:
进行替换:
预处理==替换
1.2常用预编译处理命令 文件包含命令（#include） #include预编译命令主要用于插入（包含）头文件。使用“#include &lt;头文件名称&gt;”或“#include “头文件名称””的格式来插入（包含）一个具体的头文件。尖括号（&lt;&gt;）和双引号（””）表示头文件的查找路径不同：
&lt;&gt;：在系统指定目录（软件安装目录）下查找需要插入的头文件。 Linux中寻找的为/usr/include/文件夹;
“”：在整个工程目录下查找插入的头文件，如果找不到，再到系统指定目录（软件安装目录）下查找。 情况1:
#include “stdio.h”
如果你的工程目录下有stdio.h则发生替换需要采用工程下stdio.h不再使用标准库下的stdio.h
如果您的工程目录下没有stdio.h则查找标准库下的头文件;
以上编译器首先查找当前工程目录下stdio.h；找到出现错误---没有printf函数;
情况2:
自己编写字符串函数头文件为string.h，即可抛出标准库string.h----头文件格式一定是””；
情况3:
当前目录下没有stdio.h文件,采用#include ”stdio.h”形式,归根到底还是查找标准库中的&lt;stdio.h&gt;;这样做的结果是:编译预处理时间耗时变长;(查找是需要时间的);
以后#include “”与&lt;&gt;要合理;
宏定义（#define） 宏定义概述 宏定义就是替换的意思，主要是把表达式、常量等内容，利用一个自定义的标识符号进行替换。
替换意思：位置不变 只替换内容
原:Abcdef:将cd替换为12 结果:Ab12ef
宏应用 无参宏 无参宏是指这个宏定义不需要参数的输入，仅仅是用于替换。使用“#define A B”的格式来进行无参宏定义。
替换一个数据类型 -- #define 别名 数据类型 #include &lt;stdio.h&gt;
//a）替换一个数据类型 -- #define 别名 数据类型 #define DATA_INT int //宏定义为大写标识
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd4fe438e6563ea74474ecd9782fecbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06cb365fa14adfaaa4acf438c3bdc937/" rel="bookmark">
			C语言操作符—左移右移操作符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、移位操作符十进制转二进制 1.2 &lt;&lt; 左移操作符1.2.1 &gt;&gt; 左移操作符 —— 正数1.2.2 &gt;&gt; 左移操作符 —— 负数 1.3 &gt;&gt; 右移操作符`注意：移位操作符的操作数只能是整数` 1、移位操作符 移位操作符移动的是二进制位
只支持整数不支持浮点数
十进制转二进制 123
十进制的 123
从右往左 下标
3 x 100 = 3
2 x 101 = 20
1 x 102 = 100
3 x 100+2 x 101+1 x 102 = 123
第一位为符号位负数为1整数为0 7
00000000 00000000 00000000 00000111 -原码
00000000 00000000 00000000 00000111 - 反码
00000000 00000000 00000000 00000111 - 补码
-7 10000000 00000000 00000000 00000111 -原码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06cb365fa14adfaaa4acf438c3bdc937/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb8f61a4fceb3adf69e2893fd225ab15/" rel="bookmark">
			Java——I/O(输入/输出)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、File类 File类中的java.io包是唯一代表磁盘文件本身的对象，能够创建、删除或重命名文件，判断硬盘上某个文件是否存在，查询文件最后修改时间等。
File类的常用的构造方法
1.1 创建File对象
所有的构造方法都需要传入文件的路径。如上图，如果程序只处理一个目录或文件，并且知道该目录或文件的路径，使用第一个构造方法较方便。如果程序处理的是一个公共目录中的若干子目录或文件，那么使用第二个或者第三个构造方法会更方便。
【案例】，
需要注意的是在创建File文件时传入的路径使用了" \\ " ，这是因为在windows中目录符号为反斜线" \ "，但反斜线在java中是特殊字符，表示转义符，所以使用反斜线时，前面应该再添加一个反斜线，即为" \\ "，除此之外，目录符号还可以用正斜线" / "表示，如：src/Hello.java
import java.io.File; public class test{ public static void main (String[] args){ File f = new File("E:\\Java base\\第七章IO\\a.txt"); //使用绝对路径构造File对象 File f1=new File("src\\Hello.java"); //使用相对路径构造File对象 System.out.println(f); System.out.println(f1); } } 【运行结果】
1.2 File类的常用方法
File类提供了一系列方法，用于操作其内部封装的路径指向的文件或目录。例如，判断文件或目录是否存在，文件的创建于删除文件等，如下图：
【案例】
import java.io.File; import java.io.IOException; public class test{ public static void main (String[] args)throws IOException{ File f = new File("E:\\Java base\\第七章IO\\b.txt"); //使用绝对路径构造File对象 if(f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb8f61a4fceb3adf69e2893fd225ab15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44bcb17cc210419eef936b3b7de3f095/" rel="bookmark">
			Spring Cloud OpenFeign源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 概述 在Spring Cloud微服务体系中，服务于服务之间的调用，是避免不了的， 我们可以通过Http请求的方式进行调用，当然这样并不是一个很好的选择， OpenFeign是一个http请求调用的轻量级框架，可以以Java接口注解的方式调用Http请求， 而不用像Java中通过封装HTTP请求报文的方式直接调用。 同时OpenFeign的使用也比较简单，一般我们通过两个注解进行配置即可， `@FeignClient`和`@EnableFeignClients`. 2 注解的属性含义 @EnableFeignClients @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Documented @Import(FeignClientsRegistrar.class) public @interface EnableFeignClients { //属性的别名，可类比：@ComponentScan注解 String[] value() default {}; //扫描包下带注释的组件 String[] basePackages() default {}; //basePackages() 的类型安全的替代方法，用于指定要扫描带注释的组件的软件包，指定类别的包装将被扫描。 Class&lt;?&gt;[] basePackageClasses() default {}; //适用于所有自定义@Configuration,可以包含组成客户端的部分的@Bean Class&lt;?&gt;[] defaultConfiguration() default {}; //用@FeignClient注释的类的列表，如果不为空，则禁用类路径*扫描。 Class&lt;?&gt;[] clients() default {}; } @FeignClient @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface FeignClient { //指定FeignClient的名称，如果项目使用了Ribbon，name属性会作为微服务的名称，用于服务发现 @AliasFor("name") String value() default ""; /** * The service id with optional protocol prefix.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44bcb17cc210419eef936b3b7de3f095/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5267413d447c3761fe199032352adb6/" rel="bookmark">
			springcloud feign本地微服务之间的相互调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、随着项目微服务数量越来越多，本地调试的时候很容易把请求打到别人的机器上或者云上环境，所以用自定义注解的方式实现微服务本地之间调用，使用起来也非常简单，只需要在启动类上加一个注解即可。
1.编写自定义注解
import org.springframework.context.annotation.Import; import java.lang.annotation.*; @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE}) @Documented @Import(FeignClientsServiceNameAppendBeanPostProcessor.class) public @interface EnableLocalHostFeign { String[] serverNameAndUrl() default {}; } 2：加一个规则配置类，在bean交给spring管理之前更改url
import lombok.SneakyThrows; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.BeansException; import org.springframework.beans.factory.config.BeanPostProcessor; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; import org.springframework.core.annotation.AnnotationUtils; import org.springframework.scheduling.annotation.Async; import org.springframework.util.ReflectionUtils; import java.lang.reflect.Field; import java.util.Objects; import java.util.concurrent.atomic.AtomicInteger; import java.util.regex.Pattern; @Slf4j public class FeignClientsServiceNameAppendBeanPostProcessor implements BeanPostProcessor, ApplicationContextAware { private ApplicationContext applicationContext; private AtomicInteger atomicInteger = new AtomicInteger(); private static final Pattern pattern = Pattern .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5267413d447c3761fe199032352adb6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/147/">«</a>
	<span class="pagination__item pagination__item--current">148/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/149/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>