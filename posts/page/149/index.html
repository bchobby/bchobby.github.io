<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb3c9db42c7a473489c1b9e3515614a0/" rel="bookmark">
			HikariDataSource 配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#数据源类型 spring.datasource.type=com.zaxxer.hikari.HikariDataSource #连接池名称，默认HikariPool-1 spring.datasource.hikari.pool-name=KevinHikariPool #最大连接数，小于等于0会被重置为默认值10；大于零小于1会被重置为minimum-idle的值 spring.datasource.hikari.maximum-pool-size=12 #连接超时时间:毫秒，小于250毫秒，否则被重置为默认值30秒 spring.datasource.hikari.connection-timeout=60000 #最小空闲连接，默认值10，小于0或大于maximum-pool-size，都会重置为maximum-pool-size spring.datasource.hikari.minimum-idle=10 #空闲连接超时时间，默认值600000（10分钟），大于等于max-lifetime且max-lifetime&gt;0，会被重置为0；不等于0且小于10秒，会被重置为10秒。 # 只有空闲连接数大于最大连接数且空闲时间超过该值，才会被释放 spring.datasource.hikari.idle-timeout=500000 #连接最大存活时间.不等于0且小于30秒，会被重置为默认值30分钟.设置应该比mysql设置的超时时间短 spring.datasource.hikari.max-lifetime=540000 #连接测试查询 spring.datasource.hikari.connection-test-query=SELECT 1 idleTimeout 默认是600000毫秒，即10分钟。如果idleTimeout+1秒&gt;maxLifetime 且 maxLifetime&gt;0，则会被重置为0；如果idleTimeout!=0且小于10秒，则会被重置为10秒。如果idleTimeout=0则表示空闲的连接在连接池中永远不被移除。
只有当minimumIdle小于maximumPoolSize时，这个参数才生效，当空闲连接数超过minimumIdle，而且空闲时间超过idleTimeout，则会被移除。
minimumIdle 控制连接池空闲连接的最小数量，当连接池空闲连接少于minimumIdle，而且总共连接数不大于maximumPoolSize时，HikariCP会尽力补充新的连接。为了性能考虑，不建议设置此值，而是让HikariCP把连接池当做固定大小的处理，默认minimumIdle与maximumPoolSize一样。
当minIdle&lt;0或者minIdle&gt;maxPoolSize,则被重置为maxPoolSize，该值默认为10。
完整配置项如下：
name描述构造器默认值默认配置validate之后的值validate重置autoCommit自动提交从池中返回的连接TRUETRUE–connectionTimeout等待来自池的连接的最大毫秒数SECONDS.toMillis(30) = 3000030000如果小于250毫秒，则被重置回30秒idleTimeout连接允许在池中闲置的最长时间MINUTES.toMillis(10) = 600000600000如果idleTimeout+1秒&gt;maxLifetime 且 maxLifetime&gt;0，则会被重置为0（代表永远不会退出）；如果idleTimeout!=0且小于10秒，则会被重置为10秒maxLifetime池中连接最长生命周期MINUTES.toMillis(30) = 18000001800000如果不等于0且小于30秒则会被重置回30分钟connectionTestQuery如果您的驱动程序支持JDBC4，我们强烈建议您不要设置此属性nullnull–minimumIdle池中维护的最小空闲连接数-110minIdle&lt;0或者minIdle&gt;maxPoolSize,则被重置为maxPoolSizemaximumPoolSize池中最大连接数，包括闲置和使用中的连接-110如果maxPoolSize小于1，则会被重置。当minIdle&lt;=0被重置为DEFAULT_POOL_SIZE则为10;如果minIdle&gt;0则重置为minIdle的值metricRegistry该属性允许您指定一个 Codahale / Dropwizard MetricRegistry 的实例，供池使用以记录各种指标nullnull–healthCheckRegistry该属性允许您指定池使用的Codahale / Dropwizard HealthCheckRegistry的实例来报告当前健康信息nullnull–poolName连接池的用户定义名称，主要出现在日志记录和JMX管理控制台中以识别池和池配置nullHikariPool-1–initializationFailTimeout如果池无法成功初始化连接，则此属性控制池是否将 fail fast11–isolateInternalQueries是否在其自己的事务中隔离内部池查询，例如连接活动测试FALSEFALSE–allowPoolSuspension控制池是否可以通过JMX暂停和恢复FALSEFALSE–readOnly从池中获取的连接是否默认处于只读模式FALSEFALSE–registerMbeans是否注册JMX管理Bean（MBeans）FALSEFALSE–catalog为支持 catalog 概念的数据库设置默认 catalogdriver defaultnull–connectionInitSql该属性设置一个SQL语句，在将每个新连接创建后，将其添加到池中之前执行该语句。nullnull–driverClassNameHikariCP将尝试通过仅基于jdbcUrl的DriverManager解析驱动程序，但对于一些较旧的驱动程序，还必须指定driverClassNamenullnull–transactionIsolation控制从池返回的连接的默认事务隔离级别nullnull–validationTimeout连接将被测试活动的最大时间量SECONDS.toMillis(5)
= 50005000如果小于250毫秒，则会被重置回5秒leakDetectionThreshold记录消息之前连接可能离开池的时间量，表示可能的连接泄漏00如果大于0且不是单元测试，则进一步判断：(leakDetectionThreshold &lt; SECONDS.toMillis(2) or (leakDetectionThreshold &gt; maxLifetime &amp;&amp; maxLifetime &gt; 0)，会被重置为0 . 即如果要生效则必须&gt;0，而且不能小于2秒，而且当maxLifetime &gt; 0时不能大于maxLifetimedataSource这个属性允许你直接设置数据源的实例被池包装，而不是让HikariCP通过反射来构造它nullnull–schema该属性为支持模式概念的数据库设置默认模式driver defaultnull–threadFactory此属性允许您设置将用于创建池使用的所有线程的java.util.concurrent.ThreadFactory的实例。nullnull– scheduledExecutor
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb3c9db42c7a473489c1b9e3515614a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b188866f1ebc7301ceac706618559c58/" rel="bookmark">
			dockerfile优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
优化前示例
优化方法1：不需要输出的指令丢入/dev/null （需要确定命令执行的是正确的）
优化方法2：减少RUN构建
优化方法3：多阶段构建（使用FROM命令生成多个镜像，将指定的镜像做为其他镜像的基础镜像环境来构建）
优化方法4: 使用更为轻量级的linux 发行版本
优化后的效果：
优化前示例 mkdir /nginx FROM centos:7 RUN yum install -y gcc pcre pcre-devel devel zlib-devel make ADD nginx-1.15.9.tar.gz /mnt WORKDIR /mnt/nginx-1.15.9 #关闭debug日志 RUN sed -i 's/CFLAGS="$CFLAGS -g"/#CFLAGS="$CFLAGS -g"/g' auto/cc/gcc RUN ./configure --prefix=/usr/local/nginx RUN make RUN make install EXPOSE 80 VOLUME ["/usr/local/nginx/html"] 优化方法1：不需要输出的指令丢入/dev/null （需要确定命令执行的是正确的） 减少不必要的缓存（丢到黑洞）删除不必要的缓存文件/磁盘文件
FROM centos:7 RUN yum install -y gcc pcre pcre-devel devel zlib-devel make &amp;&gt; /dev/null &amp;&amp; yum clean all ADD nginx-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b188866f1ebc7301ceac706618559c58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60f5ad192689e6ad807e86eb0e2b6e53/" rel="bookmark">
			dockerfile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我在dockerfile里面想安装torchvision
WORKDIR vision-0.8.1 WORKDIR相当于cd，进入文件夹执行
RUN python3 setup.py install --user 想要安装时，报错
Traceback (most recent call last): File "setup.py", line 12, in &lt;module&gt; import torch File "/usr/local/lib/python3.6/site-packages/torch/__init__.py", line 189, in &lt;module&gt; _load_global_deps() File "/usr/local/lib/python3.6/site-packages/torch/__init__.py", line 142, in _load_global_deps ctypes.CDLL(lib_path, mode=ctypes.RTLD_GLOBAL) File "/usr/local/lib/python3.6/ctypes/__init__.py", line 348, in __init__ self._handle = _dlopen(self._name, mode) OSError: libmpi_cxx.so.20: cannot open shared object file: No such file or directory The command '/bin/sh -c python3 setup.py install --user' returned a non-zero code: 1 从这个错误来看是缺少libopenblas，但我在dockerfile前面步骤装过了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60f5ad192689e6ad807e86eb0e2b6e53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54bded08f5cd1701806316d05e70ccfe/" rel="bookmark">
			HiveSQL正则表达式的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近工作中数据处理方面用到很多不是特别容易处理的数据，用正则表达式的话会让语句显得特别精简，也可以用各种字符串截取函数嵌套处理（必须要有一定规律），总结一下经常用到的几个。
1.正则的通配符简介 1）正则表达式的符号及意义 ^ 表示开头
$ 表示结尾
. 表示任意字符
* 表示任意多个
/ 做为转意，即通常在"/"后面的字符不按原来意义解释，如/b/匹配字符"b"，当b前面加了反斜杆后//b/，转意为匹配一个单词的边界。
-或- 对正则表达式功能字符的还原，如"*"匹配它前面元字符0次或多次，/a*/将匹配a,aa,aaa，加了"/"后，/a/*/将只匹配"a*"。
^匹配一个输入或一行的开头，/^a/匹配"an A"，而不匹配"An a"$匹配一个输入或一行的结尾，/a$/匹配"An a"，而不匹配"an A"*匹配前面元字符0次或多次，/ba*/将匹配b,ba,baa,baaa+匹配前面元字符1次或多次，/ba+/将匹配ba,baa,baaa?匹配前面元字符0次或1次，/ba?/将匹配b,ba(x)匹配x保存x在名为$1...$9的变量中x|y匹配x或y{n}精确匹配n次{n,}匹配n次以上{n,m}匹配n-m次[xyz]字符集(character set)，匹配这个集合中的任一一个字符(或元字符)[^xyz]不匹配这个集合中的任何一个字符[/b]匹配一个退格符/b匹配一个单词的边界/B匹配一个单词的非边界/cX这儿，X是一个控制符，//cM/匹配Ctrl-M/d匹配一个字数字符，//d/ = /[0-9]//D匹配一个非字数字符，//D/ = /[^0-9]//n匹配一个换行符/r匹配一个回车符/s匹配一个空白字符，包括/n,/r,/f,/t,/v等/S匹配一个非空白字符，等于/[^/n/f/r/t/v]//t匹配一个制表符/v匹配一个重直制表符/w匹配一个可以组成单词的字符(alphanumeric，这是我的意译，含数字)，包括下划线，如[/w]匹配"$5.98"中的5，等于[a-zA-Z0-9]/W匹配一个不可以组成单词的字符，如[/W]匹配"$5.98"中的$，等于[^a-zA-Z0-9]。 '( )' 标记一个子表达式的开始和结束位置。
'[]' 标记一个中括号表达式。
/num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。
2）字符簇： [[:alpha:]] 任何字母。
[[:digit:]] 任何数字。
[[:alnum:]] 任何字母和数字。
[[:space:]] 任何白字符。
[[:upper:]] 任何大写字母。
[[:lower:]] 任何小写字母。
[[:punct:]] 任何标点符号。
[[:xdigit:]] 任何16进制的数字，相当于[0-9a-fA-F]
[[:&lt;:]],[[:&gt;:]] 标记表示word边界。它们分别与word的开始和结束匹配。word是一系列字字符，其前面和后面均没有字字符。字字符是alnum类中的字母数字字符或下划线(_)
3）各种操作符的运算优先级： / 转义符
(), (?:), (?=), [] 圆括号和方括号
*, +, ?, {n}, {n,}, {n,m} 限定符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54bded08f5cd1701806316d05e70ccfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d584c286b9f75e18ce48b9d2c028f03f/" rel="bookmark">
			软考高级系统分析师知识点整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统分析师知识点整理 信息化战略体系
企业战略规划：企业如何达到目标信息系统战略规划：信息系统如何支撑这些目标信息技术战略规划（IT战略规划）：需要哪些信息技术支撑信息系统信息资源规划：信息化建设具体项目的实施。（功能建模、数据建模、ER模型） 企业战略与信息化战略集成方法
业务与IT整合（BITA）：重心是找业务与现有IT系统之间的不一致，并给出转变计划企业IT架构（EITA）：帮助IT企业建立IT的原则规范、模式和标准 信息系统战略规划方法
第一阶段，以数据处理为核心，围绕职能部门需求 企业系统规划法（BSP）关键成功因素法（CSF）战略集合转化法（SST）第二阶段，以企业内部管理信息系统（MIS）为核心，围绕企业整体需求 战略数据规划法（SDP）信息工程法（IE）战略栅格法（SG）第三阶段，综合考虑企业内外环境，以集成为核心，围绕企业战略需求 价值链分析法（VCA）战略一致性模型（SAM） 信息系统开发方法
结构化法 将系统的生命周期划分为系统规划、系统分析、系统设计、系统实施和系统维护等阶段开发目标清晰化；开发工作阶段化；开发文档规范化；设计方法结构化精髓是自顶向下、逐步分解（求精）和模块化设计适合数据处理领域的问题，不适用于规模较大、比较复杂的系统开发，局限性体现在开发周期长，难以适应需求变化，很少考虑数据结构。原型法 根据用户初步需求，利用系统开发工具，快速建立一个系统模型展示给用户，在此基础上与用户交流，最终实现用户需求。适用于需求不明确的开发包括抛弃型原型和演化型原型面向对象方法 系统的描述及信息模型的表示与客观实体相对应，符合人们的思维习惯更好的复用性当前大型信息系统的开发，通常把结构化开发方法和面向对象开发方法结合起来（去找描述的例子，准备论文）面向服务的方法 三个抽象级别：操作、服务、业务流程底层的操作代表单个逻辑单元的事务，类似于对象的方法，第二层的服务代表操作的逻辑分组，最高层的业务流程是为了实现特定业务目标而执行的一组长期运行的动作或活动。接口的定义与实现解耦粗粒度、松散耦合和基于标准的服务 商业智能（BI）
现代化的业务操作会产生大量数据，怎样从业务数据中提取有用的信息，然后根据这些信息采取明智的行动，就是商业智能的功能。
BI系统主要包括：
数据预处理：整合原始数据的第一步，包括ETL三大过程，分别是抽取（extraction）、转换（transformation）和加载（load）。建立数据仓库： 处理海量数据的基础数据分析：体现系统智能的关键，包括两大技术： OALP：进行数据汇总、切片、切块、下钻、上卷和旋转等数据分析功能数据挖掘：目标是挖掘数据背后隐藏的知识，通过关联分析、聚类和分类等方法建立分析模型，预测企业未来发展趋势和将要面临的问题。数据展现：保障系统分析结果的可视化 数据仓库
面向主题：数据按主题组织集成：消除源数据的不一致，提供整个企业的一致性全局信息相对稳定：主要进行查询，少量的修改和删除反映历史变化：记录企业过去某一时刻到当前各个阶段的信息，可对发展里成和未来趋势做定量分析和预测 数据挖掘
关联分析：挖掘出隐藏在数据间的相关关系序列模式分析：侧重点是分析数据间的前后关系（因果关系）分类分析：为每一个机理赋予一个标记在按标记分类（监督学习）聚类分析：分类分析法的逆过程。（非监督学习） 供应链管理（SCM）
理念：强强联合，打通信息孤岛，严格的数据交换标准整合和优化“三流”： 信息流：核心，需求信息流，如：客户订单、生产计划、采购合同等；供应信息流，如：入库单、完工记录等。资金流物流 企业应用集成
表示集成（界面集成）：把各应用系统的界面集成起来，统一入口，产生整体的感觉数据集成：应用集成和业务流程集成的基础，吧不同来源、格式、特点性质的数据在逻辑上或物理上有机地集中，为企业提供全面的数据共享，ETL、数据仓库、联邦数据库都可以视为数据集成。控制集成（功能集成、应用集成）：业务逻辑层级集成，可以借用过程、方法调用或面向消息的中间件等技术业务流程集成（过程集成）：对各种业务信息的交换进行定义、授权和管理，一遍改进操作、减少成本、提高响应速度。消息集成：适用于数据量小但要求频繁、立即、异步的数据交互场合。共享数据库：实时性强，可以频繁交互，数据的交互属于同步方式文件传输：适用于数据量大、交换频度小、即时性要求低的情况。 项目可行性分析
经济可行性：项目的底线，主要评估项目的建设成本、运行成本和项目建成后可能的经济收益。技术可行性：也称为技术风险分析，研究的对象是信息系统需要事先的功能和性能，以及技术能力约束，法律可行性（社会可行性）：需要从政策、法律、道德、制度等社会因素来论证信息系统建设的现实性。用户使用可行性（执行可行性）：从信息系统用户的角度来评估系统的可行性，包括企业的行政管理和工作制度、使用人员的素质和培训要求等。 成本效益分析
固定成本：不受业务量变动的影响而保持固定不变的成本，如房屋租金、固定资产折旧费、员工培训费等变动成本：随业务量的变动而成正比例变动的成本，如直接材料费、产品包装费、外包费用、开发奖金等。混合成本：混合了固定成本和变动成本性质的成本，如水电费、电话费等，通常有一个基数，超过这个基数就会碎业务量的增大而增大。直接成本：直接投入在项目上间接成本：分摊到项目上沉没成本：已经支出的成本，对于未来的决策而言，无论项目是否继续，成本都已花掉，收不回来了。 信息系统生命周期
系统规划：初步调查、分析系统目标，产物： 系统设计任务书系统分析：业务流程分析、数据与数据流程分析、软件需求分析、网络需求分析，产物： 系统需求规格说明书软件需求规格说明书系统测试计划系统设计：软件架构设计、概要设计、详细设计、网络设计，产物： 架构设计文档概要设计说明书详细设计说明书详细测试计划系统实施：软件编码、软件单元/集成/系统测试、综合布线，产物： 源码单元测试、集成测试报告操作手册系统验收：确认测试、试运行，产物： 确认测试报告项目验收报告 软件开发模型
瀑布模型：结构化方法，适用于需求很明确的情况，软件开发的各项活动严格按照线性方式进行，每个阶段都有文档产出。演化模型 针对事先不能完整定义需求的软件开发。用户可以给出待开发系统的核心需求，并且当看到核心需求实现后，能够有效地提出反馈，以支持系统的最终设计和实现第一次迭代(需求-&gt;设计-&gt;实现-&gt;测试-&gt;集成) -&gt; 反馈 -&gt; 第二次迭代(需求-&gt;设计-&gt;实现-&gt;测试-&gt;集成) -&gt; 反馈-&gt; ……重复执行的多个“瀑布模型”。增量模型 各个阶段并不交付一个可运行的完整产品，而是交付满足客户需求的一个子集的可运行产品，然后不断增加新的模块。第一个增量往往是实现基本需求的核心产品。螺旋模型： 以原型为基础，配合瀑布模型，同时用到迭代思想考虑了风险特别适合于大型复杂的系统快速原型模型 针对需求不明确的情况关键在于尽可能快速地建造出软件原型，一旦确定了客户的真正需求，所建造的原型将被丢弃无完整的需求说明，只有一些基本要求喷泉模型 面向对象具有更多的增量和迭代性质项目的整个生存期中还可以嵌入子生存期，就像水喷上去又可以落下来，可以落在中间，也可以落在最底部V模型 强调测试贯穿始终，尽早测试包含了底层测试（单元测试）和高层测试（系统测试）自上而下逐步求精，每个阶段分工明确，便于整体项目的把控 敏捷方法
思想：给开发人员减负，加强沟通，适用于小项目
自适应方法水晶方法：探索用最少纪律约束而仍能成功的方法特性驱动开发（FDD）：开发人员分成两类：首席程序员和“类”程序员，首席程序员经验丰富，是项目的协调者、设计者和指导者，“类”程序员主要做源码的编写SCRUM：明确定义了可重复的方法过程只限于在明确定义了的可重复环境中极限编程（XP） 4大价值观
沟通简单反馈勇气 5大原则
快速反馈简单性假设逐步修改提倡更改优质工作 12大最佳实践
计划游戏；2. 结对编程；3. 小型发布；4. 案例代码所有制； 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d584c286b9f75e18ce48b9d2c028f03f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f3adca4277d8e1737bbcb68feb9fd81/" rel="bookmark">
			如何用栈实现队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		队列遵循先进先出（FIFO）原则，栈遵循后进先出（LIFO）原则。如果用栈来实现队列则需要用俩个栈来模拟队列进而实现队列的先进先出（FIFO）原则。步骤如下:
（1）创建俩个栈一个进行入栈操作Stack&lt;E&gt; in，一个进行出栈操作Stack&lt;E&gt; out
（2）队列的特点为先进先出所以要求栈in进，栈out出
（3）入队时要保证栈out为空，所以先判断栈out是否为空，若不为空则将栈out中的元素全部存入栈in中 in.push(out.pop())
（4）出队时要保证栈in为空，所以先判断栈in是否为空，若不为空则将栈in中的元素全部存入栈out中 out.push(in.pop())
代码实现：
import java.util.Stack; public class Test01 { public static void main(String[] args) { MyQueue&lt;String&gt; queue=new MyQueue(); queue.offer("A1"); queue.offer("A2"); queue.offer("A3"); queue.offer("A4"); System.out.println(queue.poll()+"出队"); } } //栈模拟队列 class MyQueue&lt;E&gt;{ private Stack&lt;E&gt; in =new Stack&lt;E&gt;(); private Stack&lt;E&gt; out =new Stack&lt;E&gt;(); //入队 public void offer(E e) { while(!out.isEmpty()) { in.push(out.pop()); } in.push(e); } public boolean isEmpty() { return in.size()==0&amp;&amp;out.size()==0; } //出队 public E poll() { while(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f3adca4277d8e1737bbcb68feb9fd81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b88b75debdbe4ffe6a6a2dc3b4ca0c25/" rel="bookmark">
			linux systemctl命令添加开机启动脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux systemctl命令添加开机启动脚本
我想开机自动运行 sudo chmod 777 /dev/ttyTHS1命令来启动串口
systemctl命令添加开机启动可以直接写命令，也可以写脚本,我这里主要写个脚本
//首先使用sudo 命令创建一个.sh文件 $ vim openttyTHS1.sh 下面是写在.sh文件中的脚本命令,#!/bin/bash 是写.sh脚本必须添加的，否则会报错
一定要在linux下创建.sh文件！！！！
#!/bin/bash sudo chmod 777 /dev/ttyTHS1 然后赋予脚本执行权限
$ chmod +x openttyTHS1.sh 接下来要到**/etc/systemd/system/** 创建systemctl文件，后缀为.service
//首先使用sudo 命令创建一个.service文件 $ vim openttyTHS1.service [Unit] Description=JetBot start service After=multi-user.target [Service] Type=oneshot User=root ExecStart=/usr/bin/openttyTHS1.sh WorkingDirectory=/home/jetbot [Install] WantedBy=multi-user.target ~ 一定要注意User=root否则会报sudo以后没有密码之类的错误
然后命令
sudo systemctl enable openttyTHS1 sudo systemctl start openttyTHS1 这样就完成开机启动了，可以重启试试 如果需要查看已有的服务，可以使用:
sudo systemctl list-units
如果有些服务文件，虽然已经在服务文件的目录下，但是它不是热生效的，即不是说咱们把它放进去就能被识别、注册、启动的。它没有被 systemctl 的 start 或 enable 命令登记到Systemd，如果你需要的话，得自己做这个操作。
如果想查看没被激活的服务文件怎么办呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b88b75debdbe4ffe6a6a2dc3b4ca0c25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bfae88e9214a275ee011ec7af783194/" rel="bookmark">
			Keil界面优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.解决模糊(修改DPI) 未处理前，十分模糊
按以下操作：
找到keil-&gt;右键属性-&gt;兼容性-&gt;高DPI缩放替代打钩
操作完成后的keil界面：
2.黑色背景: 找到global.prop文件: 先将原文件保存,防止以后想换回:原文件: # properties for all file types indent.automatic=1 virtual.space=0 view.whitespace=0 view.endofline=0 code.page=936 caretline.visible=1 highlight.matchingbraces=1 print.syntax.coloring=1 use.tab.color=1 create.backup.files=0 auto.load.ext.modfiles=0 save.prj.before.dbg=0 save.files.before.dbg=0 function.scanner.project=1 function.scanner.files=1 function.scanner.modules=1 # properties for c/cpp files syntax.colouring.cpp=1 use.tab.cpp=0 tabsize.cpp=2 line.margin.visible.cpp=1 fold.cpp=1 monospaced.font.cpp=1 # properties for asm files syntax.colouring.asm=1 use.tab.asm=0 tabsize.asm=4 line.margin.visible.asm=1 monospaced.font.asm=1 # properties for other files use.tabs=0 tabsize=4 line.margin.visible.txt=0 monospaced.font.txt=1 # setting for code completion and syntax check cc.autolist=1 cc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bfae88e9214a275ee011ec7af783194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52f39466bda821c4e2d7b455416da259/" rel="bookmark">
			select和poll的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础的网络编程模型中，套接字通常都是阻塞的，比如服务端listen阻塞等待客户端来连接，建立连接后，recv阻塞等待接收数据。而如果在等待接收数据的过程中，又有新的客户端连接，这时服务端无能为力，因为服务端还在阻塞等待接收上一个客户端的数据。有一种做法是将套接字设置为非阻塞的，调用即返回，不管套接字是否准备好（是否有数据可读/写），但这就需要不断轮询调用函数（因为服务端也不知道什么时候会来数据）如果客户端一直没有响应，服务端的轮询就会占用大量的CPU资源，效率低下。而另一种方法是采用IO复用：
这样的进程需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个或多个I/O条件就绪 （也就是说输入已准备好被读取，或者描述符已能承接更多的输出），它就通知进程。这个能力称为I/O复用。 在Linux中IO复用有select、poll和epoll，epoll较前两种区别较大，下一篇总结。
它们都有这样的能力：同时监听多个文件描述符。
需要指出的是，I/O复用虽然能同时监听多个文件描述符，但它本身是阻塞的。并且当多个文件描述符同时就绪时，如果不采取额外的措施，程序就只能按顺序依次处理其中的每一个文件描述符，这使得服务器程序看起来像是串行工作的。如果要实现并发，只能使用多进程或多线程等编程手段。
select
先来看一下函数原型：
#include &lt;sys/select.h&gt; int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); 从后往前：timeout参数用来指定超时时间，和其他函数中设置超时时间的含义一样，select本身是阻塞的，如果设置了超时时间，不管监听的文件描述符是否就绪都会返回。再往前三个fd_set *类型的参数，分别指向可读、可写和异常等事件对应的文件描述符集合，我们在调用select时，通过这三个参数分类传入需要被监听的文件描述符集合。nfds是所有被select监听的文件描述符中的最大值加1，注意不是描述符个数加1，而是描述符最大值加1。
更详细的，timeout是一个结构体，包含秒数和微秒数：
struct timeval { long tv_sec;//秒数 long tv_usec;//微秒数 }; 有些系统会修改该值，把值修改成剩余的时间。比如，超时设置是5秒，在文件描述符可用之前逝去了3秒，那么在调用返回时，tv_sec的值就变为了2。有一些系统则不改变该值，因此，为了方便移植，我们在每次调用select时最好重新设置该值。更进一步，我们还可以用select的定时，来替代sleep()，只需要将前几个参数都设置为零和空，并设置超时时间：
struct timeval tv; tv.tv_sec = 0; tv.tv_usec = 500; select(0, NULL, NULL, NULL, &amp;tv); 例：
#include &lt;sys/select.h&gt; #include &lt;stdio.h&gt; int main() { struct timeval tv; tv.tv_sec = 5; tv.tv_usec = 0; select(0, NULL, NULL, NULL, &amp;tv); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52f39466bda821c4e2d7b455416da259/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e81c87853bc55a44b4861937132dc288/" rel="bookmark">
			asn1c中使用双重指针来实现asn中的sequence和set
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按照asn.1的定义，sequence和set是一系列数据的集合。在实际使用中，可能就是某一个结构体的集合。
sequence和set分为各个元素相同以及每个元素不相同。在asn1c中，当每个元素相同时，定义为SEQUENCE_OF，当每个元素有不相同时，定义为SEQUENCE，
在asn1c中，将sequence通过动态数组来实现。当添加元素时，会判断当前是否需要扩展内存，如果需要扩展，就扩展之前一倍的内存。
数据结构描述 sequence of的结构体定义：
#define	A_SEQUENCE_OF(type)	A_SET_OF(type) #define A_SET_OF(type) \ struct { \ type **array; \ int count; /* Meaningful size */ \ int size; /* Allocated size */ \ void (*free)(type *); \ } 可以看到，sequence of相当于set of，set of中的type是通过宏的参数设置进来的，实际使用时应该将type参数设置为数据结构的类型。结构体中有一个双重指针array，这个双重指针是本篇文章要重点介绍的对象。通过下一小节【想数组中添加元素】可以更好的理解这里为什么是一个双重指针。
向数组中添加元素 #define	ASN_SEQUENCE_ADD(headptr, ptr) asn_sequence_add((headptr), (ptr)) /* * Add another element into the set. */ int asn_set_add(void *asn_set_of_x, void *ptr) { asn_anonymous_set_ *as = _A_SET_FROM_VOID(asn_set_of_x); if(as == 0 || ptr == 0) { errno = EINVAL;	/* Invalid arguments */ return -1; } /* * Make sure there's enough space to insert an element.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e81c87853bc55a44b4861937132dc288/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/706b6222e2113b23a1f580e419ad101d/" rel="bookmark">
			Hive MetaStore 启动配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.MetaStore介绍 Hive可以启动一个叫做MetaStore的服务，该服务在Hive的客户端启动，用户通过客户端连接到MetaStore，然后和一个数据库（例如：Mysql）进行通信。该数据库是用于存储Hive的元数据信息。
2.MetaStore配置 需要修改hive-site.xml配置文件，配置端口
&lt;property&gt; &lt;name&gt;hive.metastore.port&lt;/name&gt; &lt;value&gt;9083&lt;/value&gt; &lt;description&gt;Hive metastore listener port&lt;/description&gt; &lt;/property&gt; 3.MetaStore启停 hive --service metastore -p 9083 &amp; 使用netstat或者ps查看metastore服务是否起来
netstat -anp|grep 9083 ps -ef | grep metastore 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4282abba063e51207955e20648adb18/" rel="bookmark">
			vim里tab的替换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 自动展开tab为4个空格 在vimrc里添加以下两行：
:set tabstop=4 :set expandtab 或者用缩写格式：
:set ts=4 :set et 2. 编辑文件，替换现有的tab为空格 命令模式下执行：
:set ts=4 :set expandtab :%retab! 3. 编辑文件，替换空格为tab 命令模式下执行：
:set ts=4 :set noexpandtab :%retab! 说明： !是用于处理非空白字符之后的TAB，即所有的TAB，若不加!，则只处理行首的TAB
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a28faf3597f49f3a5bedfd52d86baed/" rel="bookmark">
			Floyd算法（matlab实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Floyd算法 Folyd算法主要是解决每对顶点之间的最短路径
从直观上进行分析，从任意顶点 V i V_i Vi​到任意顶点 V j V_j Vj​的最短路径有两种情况。
从 V i V_i Vi​直接到 V j V_j Vj​的距离就是最短路径。从 V i V_i Vi​经过若干个顶点到 V j V_j Vj​的距离是最短路径。 function [dist,mypath]=myfloyd(a,sb,db); %输入：a——邻接矩阵；元素a(i,j)——顶点i到j之间的直达距离，可以是有向的。 %sb——起点的标号；db——终点的标号； %输出：dist——最短路的距离；mypath——最短路的路径 n=size(a,1);path=zeros(n); for k=1:n for i=1:n for j=1:n if a(i,j)&gt;a(i,k)+a(k,j) a(i,j)=a(i,k)+a(k,j); path(i,j)=k; end end end end dist=a(sb,db); parent=path(sb,:);%从起点sb到终点db的最短路上各顶点的前驱顶点 parent(parent==0)=sb;%path中的分量为0，表示该顶点的前驱是起点 mypath=db;t=db; while t~=sb p=parent(t);mypath=[p,mypath]; t=p; end 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9b3f82616180b71875d7be8a2b7f0ad/" rel="bookmark">
			MATLAB实例：PCA（主成成分分析）详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现一篇非常实用的pca matlab程序学习文章，包括对matlab自带的pca函数的解释说明，转载链接放到文末。另外整理了涉及到的一些其他内容一并放入文中
1. 主成成分分析 对于数学原理，可参见：CodingLabs - PCA的数学原理
本文不再赘述 2. MATLAB解释
详细信息请看：Principal component analysis of raw data - mathworks
[coeff,score,latent,tsquared,explained,mu] = pca(X)
coeff = pca(X) returns the principal component coefficients, also known as loadings, for the n-by-p data matrix X. Rows of X correspond to observations and columns correspond to variables.
The coefficient matrix is p-by-p.
Each column of coeff contains coefficients for one principal component, and the columns are in descending order of component variance.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9b3f82616180b71875d7be8a2b7f0ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3daeb7cdd45763f60565f30dfa1fa32c/" rel="bookmark">
			linux 增加静态路由命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux 临时修改路由： 方法一：
添加路由
route add -net 192.168.2.0/24 gw 192.168.1.1 或 route add -host 192.168.2.8 dev 192.168.1.1 删除路由
route del -net 192.168.0.0/24 gw 192.168.0.1 add 增加路由
del 删除路由
-net 设置到某个网段的路由
-host 设置到某台主机的路由
gw 出口网关 IP地址
dev 出口网关 物理设备名
增加默认路由
route add default gw 192.168.3.1 查看路由表
route -n 方法二：
添加路由
ip route add 192.168.0.0/24 via 192.168.0.1 或 ip route add 192.168.1.1 dev 192.168.0.1 删除路由
ip route del 192.168.0.0/24 via 192.168.0.1 add 增加路由
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3daeb7cdd45763f60565f30dfa1fa32c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d7d024a7657412beebda0fab8d994b2/" rel="bookmark">
			论文阅读笔记之AGE:由图信号引发的一系列问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导航栏
什么是图信号——&gt;什么是节点——&gt;什么是节点维度——&gt;什么是shape——&gt;list、Array、Series——&gt;降维——&gt;方差公式中为什么除数是(n-1)
一、什么是图信号 问题来源：https://blog.csdn.net/qq_44015059/article/details/114977767）
图信号（Graph signal） 图信号x:V➡R是一个定义于图顶点集的映射。我们也可以将其表示为一个向量 x ∈ R n x∈R^{n} x∈Rn ，其中 x i x_i xi​表示第i个顶点的信号值。
邻接矩阵、度矩阵、拉普拉斯矩阵这三种矩阵表述根据不同的需要，可以十分有力的表达图的结构。但表达的也仅仅是图的结构，就好比是设计好了一栋连接错综复杂的大楼，每一个节点还等着我们去赋值。给定任意一个无向图的邻接矩阵A，假定节点数为N，则任意的长度为N的信号都可以作为这个无向图的图信号，其各个位置的值代表对应节点的值。
关于图信号的原文链接：
（1）https://zhuanlan.zhihu.com/p/415756783
（2）https://blog.csdn.net/m0_38002423/article/details/90758200
二、什么是节点 问题来源：https://blog.csdn.net/m0_38002423/article/details/90758200
如下图，图中圆圆的点就是节点。
参考链接：
（1）https://blog.csdn.net/weixin_41929524/article/details/121736848
（2）https://blog.csdn.net/weixin_41929524/article/details/121198344
三、什么是节点维度 问题来源：https://blog.csdn.net/m0_38002423/article/details/90758200
1. 对于数组和Series来说 对于数组和Series来说，维度就是功能shape返回的结果，shape中返回了几个数字，就是几维。索引以外的数据，不分行列的叫一维（此时shape返回唯一的维度上的数据个数），有行列之分叫二维（shape返回行x列），也称为表。一张表最多二维，复数的表构成了更高的维度。当一个数组中存在2张3行4列的表时，shape返回的是(更高维，行，列)。当数组中存在2组2张3行4列的表时，数据就是4维，shape返回(2,2,3,4)。
数组中的每一张表，都可以是一个特征矩阵或一个DataFrame，这些结构永远只有一张表，所以一定有行列，其中行是样本，列是特征。针对每一张表，维度指的是样本的数量或特征的数量，一般无特别说明，指的都是特征的数量。除了索引之外，一个特征是一维，两个特征是二维，n个特征是n维。
2. 对于图像来说 对图像来说，维度就是图像中特征向量的数量。特征向量可以理解为是坐标轴，一个特征向量定义一条直线，是一维，两个相互垂直的特征向量定义一个平面，即一个直角坐标系，就是二维，三个相互垂直的特征向量定义一个空间，即一个立体直角坐标系，就是三维。三个以上的特征向量相互垂直，定义人眼无法看见，也无法想象的高维空间。
3. 降维算法中的“降维” 降维算法中的”降维“，指的是降低特征矩阵中特征的数量。上周的课中我们说过，降维的目的是为了让算法运算更快，效果更好，但其实还有另一种需求：数据可视化。从上面的图我们其实可以看得出，图像和特征矩阵的维度是可以相互对应的，即一个特征对应一个特征向量，对应一条坐标轴。所以，三维及以下的特征矩阵，是可以被可视化的，这可以帮助我们很快地理解数据的分布，而三维以上特征矩阵的则不能被可视化，数据的性质也就比较难理解。
4.总结 （1）对于数组和Series来说，维度就是功能shape返回的结果，shape中返回了几个数字，就是几维。
（2）针对每一张表，维度指的是样本的数量或特征的数量，一般无特别说明，指的都是特征的数
量。
（3）对图像来说，维度就是图像中特征向量的数量。特征向量可以理解为是坐标轴。
参考链接：
（1）https://zhuanlan.zhihu.com/p/59357783
（2）https://blog.csdn.net/weixin_44376037/article/details/122245411
四、什么是shape 问题来源：https://zhuanlan.zhihu.com/p/59357783
1.Python里对于shape()的理解 学习相关代码的时候，很容易出现shape()这样形式的东西，用来告知输出数据的形式，由于shape（）里出现的数字数量不同，还经常有shape（？，64，512）这样的数据存在，因此上网查了一些信息，作出比较通俗易懂的解释：
import numpy as np a = np.array([[[1,2,3],[4,5,6]]]) print(a.shape) (1, 2, 3) 表示该数组有1个，是2行3列的数组。每一个shape里的数字对应数组中的一对中括号，第一个数字1表示最外层的中括号。以此类推，数字2表示第二层中括号，数字3表示最里层的中括号。如果定义array时去掉了最外层的括号那么输出的shape为(2, 3)。
2.区分一维数组和二维数组 有几层中括号就为几维数组，即shape后的结果中就有几个数。
因此在上文中，有三对中括号，是3维数组，shape（）中有3个数。
a = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d7d024a7657412beebda0fab8d994b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f98b71ffc7fb3df9f42ae9570289487/" rel="bookmark">
			本科论文常见答辩问题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 专业性问题你系统的整体设计是怎么样？用了什么技术？这些技术应用的好处是什么？框架，SSM，SSH这些有什么优势。前端，前端用了什么；你数据库整体的设计是怎么样的，某个表，某个字段作用是什么？MySQL，为什么用MySQL；有几个表；三范式；主键这些基础。数据库链接方式，数据库设计中的ER图、范式等。你系统核心功能怎么实现？业务，功能模块，老师对某个模块需要详细了解，问你是怎么做的，其实就是你的代码实现逻辑；功能怎么实现的。流程图，讲一下有角色的功能区别。一些软件工程，数据库的基础知识，比如时序图，ER图，范式之类的。前后端交互用什么；ajax等等软件测试Java基础，三大特性，有接口吗，类是什么，封装了什么。 一般性问题：（读懂论文基本可以自己回答）1、为什么选择这个课题（或题目）？2、研究这个课题的意义和目的是什么？3、全文的基本框架、基本结构是如何安排的？4、论文和系统有哪些不足之处？5、你的工作未来有什么应用前景? 后端技术方案SSH框架SSM框架SpringbootSpringSpringMVCmybatisJSP前端MD5密码加密MySQLHikari 连接池数据库连接池概述：HikariCP概述HikariCP特点 Log4JMVC设计模式MVC如何在你的程序中运用实现MVC优缺点: B/S架构 前端技术方案CSSJavaScriptJqueryVUEBootStrap 前后端交互ajax 需求分析问题需求分析的主要内容流程图用例图活动图 mysql数据库问题E-R图的目的和作用主键与外键数据库事务数据库三范式第一范式第二范式第三范式（3NF）总结几个重要的概念: 功能性问题分页功能如何实现页面传值的方法Session是什么定向与转发1.请求转发（forward）:2.重定向（Redirect）: Java的三大特性：封装、继承、多态封装 继承多态接口类 测试测试什么？白盒测试和黑盒测试 答辩过程中，老师问的问题一般都和你的设计有关，下面总结了一下常见的提问的问题给大家：
框架，SSM，SSH这些有什么优势。
前端，前端用了什么；无非就是CSS、HTML这些
MySQL，为什么用MySQL；有几个表；三范式；主键这些基础。数据库链接方式，数据库设计中的ER图、范式等。
前后端交互用什么；ajax等等
测试过吗，怎么测试的。
流程图，讲一下有角色的功能区别。
Java基础，三大特性，有接口吗，类是什么，封装了什么。
一般都是框架和业务各问一个，如果你解释的不清楚，老师可能会追问。
专业性问题 你系统的整体设计是怎么样？用了什么技术？这些技术应用的好处是什么？框架，SSM，SSH这些有什么优势。前端，前端用了什么； 参考下面技术整理
你数据库整体的设计是怎么样的，某个表，某个字段作用是什么？MySQL，为什么用MySQL；有几个表；三范式；主键这些基础。数据库链接方式，数据库设计中的ER图、范式等。 你系统核心功能怎么实现？业务，功能模块，老师对某个模块需要详细了解，问你是怎么做的，其实就是你的代码实现逻辑；功能怎么实现的。流程图，讲一下有角色的功能区别。 （比如说购物系统，核心功能就在于整个购物的流程，这个就是系统的核心，老师也一般会对这些地方进行发问），当然也会随机问你某个模块怎么实现，所以自己必须要对自己的系统业务功能，实现的逻辑，数据库表十分熟悉。
一些软件工程，数据库的基础知识，比如时序图，ER图，范式之类的。 前后端交互用什么；ajax等等 软件测试 Java基础，三大特性，有接口吗，类是什么，封装了什么。 一般性问题：（读懂论文基本可以自己回答） 1、为什么选择这个课题（或题目）？ 首先从主观入手，可从当前该课题对应的社会大致情况来简要分析，其次可以结合自己的经历来分析（xxx时对该课题有了更深的社会认识，发现了一些问题等），最后，可以说是与指导老师进行深入沟通交流后选择该课题。
2、研究这个课题的意义和目的是什么？ 这一问题一般在开题中就有提及，正文中也有相关小节说明，只需要对其加以总结提炼即可，需要注意的是，一定要逻辑清楚，条理分明，不可想到哪儿说到哪儿，东拼西凑会给考核老师留下不好的印象。
说明这个课题的历史和现状，即前人做过哪些研究，自己有什么新的看法…
对应开题的文献综述部分。
例如：在xx这个问题上前人的经验十分丰富，我的工作是通过收集前人答辩数据，总结规律，对xx进行xx，创新性地实现了xx的丰富性，
从而使得xxx大大提高，对xxxx的提高有着极强的推动作用。
3、全文的基本框架、基本结构是如何安排的？ 该问题的回答并非是让您将论文大纲讲述一遍，而是对整个文章的一个综合说明，比如：全文按照“总–分–总”的结构展开论述，开头从总体上论述XXXX的特点等大背景，之后“提出XXXXX问题”,再根据问题提出XXXXX对策，最后是总结陈述，各部分相互间存在逻辑联系，相互配合，成为整体的有机组成部分（该结构是最为常见的结构，您需要依照自身文章实际情况做具体分析）
eg:
本课题对xxx进行了社会、市场背景的了解，通过对前人的文献调查和总结规划了本系统的需求，针对需求进行需求分析设计了UML图、流程图等规划系统模板，根据分析结果进行了系统设计，包括数据库设计、详细功能设计、架构设计等，最后根据设计实现系统并进行了测试。
4、论文和系统有哪些不足之处？ 提出一些不足之处，再提出日后完善的展望即可。
第一，XXXXX;第二，XXXXX.（可以说“由于对计算机专业知识学习欠缺，在研究过程中XXX部分还有待进一步深入研究”等）
5、你的工作未来有什么应用前景? 我本次的成果可以在xx领域提高过程的效率，简化操作流程，替代传统方法。尽管目前成本较高，但它在等许多方面已经展现出了巨大的商业化潜力!
后端技术方案 SSH框架 SSH是struts+spring+hibernate的一个集成框架，是一种Web应用程序开源框架。从职责上分为四层:表示层、业务逻辑层、数据持久层和域模块层，可复用性好、维护方便的Web应用程序。其中使用Struts作为系统的整体基础架构，负责MVC的分离，在Struts框架的模型部分，控制业务跳转，利用Hibernate框架对持久层提供支持，Spring来 管理struts和hibernate。
SSM框架 SSM（Spring+SpringMVC+MyBatis）框架集由Spring、MyBatis两个开源框架整合而成（SpringMVC是Spring中的部分内容）。常作为数据源较简单的web项目的框架。
Springboot Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是 Spring Boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f98b71ffc7fb3df9f42ae9570289487/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc131c19af3113b5ad423f04107769ad/" rel="bookmark">
			《操作系统导论》知识总结 第四章 抽象：进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程的非正式定义非常简单：进程就是运行中的程序。
关键问题：如何提供有许多 CPU 的假象？
操作系统通过虚拟化（virtualizing）CPU 来提供这种假象。通过让一个进程只运行一个时间片，然后切换到其他进程，操作系统提供了存在多个虚拟 CPU 的假象。这就是时分共享（time sharing）CPU 技术，允许用户如愿运行多个并发进程。潜在的开销就是性能损失，因为如果 CPU 必须共享，每个进程的运行就会慢一点。
抽象：进程 操作系统为正在运行的程序提供的抽象，就是所谓的进程（process）。
为了理解构成进程的是什么，我们必须理解它的机器状态（machine state）：程序在运行时可以读取或更新的内容。
内存：指令存在内存中。正在运行的程序读取和写入的数据也在内存中。寄存器：程序计数器告诉我们程序当前正在执行哪个指令；栈指针和帧指针用于管理函数参数栈、局部变量和返回地址。 进程 API API，全称Application Programming Interface，即应用程序编程接口。
API就是操作系统给应用程序的调用接口，应用程序通过调用操作系统的 API而使操作系统去执行应用程序的命令（动作）。（资料来源于网络）
这里先介绍一下操作系统的所有接口必须包含哪些内容。
创建（create）：操作系统必须包含一些创建新进程的方法。在 shell 中键入命令或双击应用程序图标时，会调用操作系统来创建新进程，运行指定的程序。销毁（destroy）：由于存在创建进程的接口，因此系统还提供了一个强制销毁进程的接口。当然，很多进程会在运行完成后自行退出。但是，如果它们不退出，用户可能希望终止它们，因此停止失控进程的接口非常有用。等待（wait）：有时等待进程停止运行是有用的，因此经常提供某种等待接口。其他控制（miscellaneous control）：除了杀死或等待进程外，有时还可能有其他控制。例如，大多数操作系统提供某种方法来暂停进程（停止运行一段时间），然后恢复（继续运行）。状态（statu）：通常也有一些接口可以获得有关进程的状态信息，例如运行了多长时间，或者处于什么状态。 进程创建：更多细节 操作系统运行程序必须做的第一件事是将代码和所有静态数据（例如初始化变量）从磁盘加载（load）到内存中，加载到进程的地址空间中。在早期的（或简单的）操作系统中，加载过程尽早（eagerly）完成，即在运行程序之前全部完成。现代操作系统惰性（lazily）执行该过程，即仅在程序执行期间需要加载的代码或数据片段，才会加载。
为栈分配空间：将代码和静态数据加载到内存后，必须为程序的运行时栈（run-time stack 或 stack）分配一些内存。C 程序使用栈存放局部变量、函数参数和返回地址。操作系统也可能会用参数初始化栈。具体来说，它会将参数填入 main()函数，即 argc 和 argv 数组。为堆分配空间：操作系统也可能为程序的堆（heap）分配一些内存。程序通过调用 malloc()来请求这样的空间，并通过调用 free()来明确地释放它。数据结构（如链表、散列表、树和其他有趣的数据结构）需要堆。I/O 初始化：操作系统还将执行一些其他初始化任务，特别是与输入/输出（I/O）相关的任务。例如，在 UNIX 系统中，默认情况下每个进程都有 3 个打开的文件描述符（file descriptor），用于标准输入、输出和错误。这些描述符让程序轻松读取来自终端的输入以及打印输出到屏幕。运行程序入口：通过将代码和静态数据加载到内存中，通过创建和初始化栈以及执行与 I/O 设置相关的其他工作，完成准备后，接下来就是启动程序，在入口处运行，即 main()。 进程状态 进程可以处于以下 3 种状态之一。
运行（running）：在运行状态下，进程正在处理器上运行。这意味着它正在执行指令。就绪（ready）：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统选择不在此时运行。阻塞（blocked）：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。一个常见的例子是，当进程向磁盘发起 I/O 请求时，它会被阻塞，因此其他进程可以使用处理器
可以根据操作系统的载量，让进程在就绪状态和运行状态之间转换。从就绪到运行意味着该进程已经被调度（scheduled）。从运行转移到就绪意味着该进程已经取消调度（descheduled）。一旦进程被阻塞（例如，通过发起 I/O 操作），OS 将保持进程的这种状态，直到发生某种事件（例如，I/O 完成）。此时，进程再次转入就绪状态（也可能立即再次运行，如果操作系统这样决定）。
总结：一个进程阻塞或停止时，就会去调度另一个就绪的进程，从而让 cpu 一直保持在满负荷状态。 书中23页有两个例子很好解释了这些状态转换，这里不详细说了。
数据结构 为了跟踪每个进程的状态，操作系统可能会为所有就绪的进程保留某种进程列表（process list），以及跟踪当前正在运行的进程的一些附加信息。操作系统还必须以某种方式跟踪被阻塞的进程。当 I/O 事件完成时，操作系统应确保唤醒正确的进程，让它准备好再次运行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc131c19af3113b5ad423f04107769ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/377f1b948ee573381b59a3471951fbaa/" rel="bookmark">
			CSP第十二次认证 行车路线 拆点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这道题的关键是如何解决连续小路的情况，因为题目保证答案不超过1e6,说明小路的连续长度不超过1000，给了我们提示，可以将点拆分为两个属性，一个是点的序号，另一个则是最后一段连续小路的长度，所以我们的dist数组dist[i][j]可以表示，从第1个点开始到第i个点，最后一段连续小路的长度为j的疲劳值，这样的话我们就可以同时记录两个我们所需要的值。
ps：dijkstra算法中需要的st判重数组也要拆成两个。
每次更新dist数组需要考虑大路小路两种情况（如下图的两种更新方式），有点类似于动态规划里边的集合的划分，
ps:为了区分两种路我们引入了t数组存储type
最后一条小路的长度不超过1000，同一个点，由于第二维j的不同所以每个点拆成1001个点，我们拆了点之后n相当于500*1001，n是1e5的数据量，m是1e5，所以朴素版的dijkstra和SPFA都会超时，这里我们选择堆优化版的dijkstra。
拆点在CSP目前已经考了三次了，本题是第三次）
拆点：
第一次CCF考试第四题：3200. 无线网络 - AcWing题库
第七次CCF考试第四题：3230. 游戏 - AcWing题库
第十二次CCF考试第四题：AcWing 3255. 行车路线
代码如下：
#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int N = 510, M = 1e5 + 10; int dist[N][1010], h[N], ne[2*M], e[2*M], idx, n, m, t[2*M],w[2*M]; bool st[N][1010]; void add(int type, int a, int b, int c) { t[idx] = type;w[idx]=c; e[idx] = b; ne[idx] = h[a]; h[a] = idx++; } struct Node { int dis,p,v; bool operator&lt;(const Node &amp;w)const { return dis&gt;w.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/377f1b948ee573381b59a3471951fbaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebcfa917fde79629f58f999dce481d6d/" rel="bookmark">
			vue 抽离出公共的js文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录结构：
api&gt;&gt;indiex.ts如下
export * from './common' export * from './site-survey' export * from './engine-progress' export * from './project' 其余内部文件里面ts为：
import { getApi, postApi } from '@/composables/useApi' export const getDetail = async ({ id, node }) =&gt; { const res = await getApi('/api/customer/project/detail', { id, currentNode: node }) return res.data } export const projectSubmit = async (data) =&gt; { const res = await postApi('/api/customer/project/submit', data) return res.data } export const getMessageCount = async (data) =&gt; { const res = await postApi('/api/message/getMessageCount', data) return res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebcfa917fde79629f58f999dce481d6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3fbfeb59fd07633c46b95297d3345da/" rel="bookmark">
			nohup 命令之 nohup: ignoring input and appending output to ‘nohup.out’
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我在linux中使用nohup 命令的时候，出现了这个错误：
nohup: ignoring input and appending output to ‘nohup.out’ 忽略输入输出，将信息化信息记录到nohup.out文件中。 补充：nohup 命令 nohup 英文全称 no hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。
nohup 命令，在默认情况下（非重定向时），会输出一个名叫 nohup.out 的文件到当前目录下，如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。
1、用途：LINUX命令用法，不挂断地运行命令。
2、语法：nohup Command [ Arg ... ] [&amp;]
3、描述：nohup 命令运行由 Command 参数和任何相关的 Arg 参数指定的命令，忽略所有挂断信号。
4、在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp;到命令的尾部。
使用格式： nohup Command [ Arg … ] [　&amp; ] 举例： 比如，我们输入这个nohup命令：
nohup /root/runoob.sh &amp; 如果在终端看到下面所示的输出说明的话，就说明该nohup命令运行成功了：
appending output to nohup.out 那么现在当我们打开 root 目录的时候，我们就可以看到生成了一个 nohup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3fbfeb59fd07633c46b95297d3345da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3373e65dbe8a43a5e792447d53c5d64/" rel="bookmark">
			Python 并发编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 为什么需要引入并发编程呢？
二. 怎么样选择多线程，多进程和多协程？
1. CPU 密集型与 I/O 密集型
2. 多线程，多进程和多协程的对比
三. python 的全局解释器锁（GIL）
1. python 速度慢的两大原因
2. GIL 是什么？
3. 为什么会有GIL 这个东西？
4. 怎么样规避GIL 带来的限制？
四. 使用多线程加速python spider
1. python 创建线程的方法；
2. 改写spider程序，变成多线程爬取；
五. 生产消费者spider
1. 多组件的Pipeline 技术架构
2. 生产者消费者的爬虫架构
3. 生产者消费者爬虫
六. python 线程安全问题以及解决方案
1. 线程安全的概念
2. python 可以使用 Lock 类来解决线程安全问题
七. python 线程池 ThreadPoolExecutor
1. 线程池的原理
2. 使用线程池的好处
3. ThreadPoolExecutor 的使用，使用线程池改造爬虫程序
八. 在web 服务中使用线程池加速
1. web 服务的架构以及特点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3373e65dbe8a43a5e792447d53c5d64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f58cf1ac2c6ae3be94851aa4f399a3e5/" rel="bookmark">
			彻底关闭Win10自动更新（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：如何彻底关闭win10自动更新 win10彻底关闭自动更新方法【步骤】-太平洋IT百科
win10的自动更新可谓是非常顽固，很多用户在网上试了各种关闭win10自动更新的方法，刚开始看着好像是关闭更新了，可没过多久系统就又开始自动更新了。今天就来教大家如何彻底关闭win10自动更新，该方法亲测有效。
我是1月8号装的win10系统，现在已经3月9号了，系统安安静静，没有任何自动更新的迹象
win10彻底关闭自动更新方法步骤：
由于win10自动更新非常顽固，所以我们要从多个地方下手才能永久关闭其自动更新，别怕麻烦，跟着下面的步骤一步步操作。
一、禁用Windows Update服务
1、同时按下键盘 Win + R，打开运行对话框，然后输入命令 services.msc ，点击下方的“确定”打开服务。
2、找到 Windows Update 这一项，并双击打开。
3、双击打开它，点击“停止”，把启动类型选为“禁用”，最后点击应用。
4、接下再切换到“恢复”选项，将默认的“重新启动服务”改为“无操作”，然后点击“应用”“确定”。
二、在组策略里关闭Win10自动更新相关服务
1、同时按下Win + R 组合快捷键打开运行命令操作框，然后输入“gpedit.msc”，点击确定。
2、在组策略编辑器中，依次展开 计算机配置 -&gt; 管理模板 -&gt; Windows组件 -&gt; Windows更新
3、然后在右侧“配置自动更新”设置中，将其设置为“已禁用”并点击下方的“应用”然后“确定”。
4、之后还需要再找到“删除使用所有Windows更新功能的访问权限”，选择已启用，完成设置后，点击“应用”“确定”。
三、禁用任务计划里边的Win10自动更新
1、同时按下 Win + R 组合快捷键打开““运行”窗口，然后输入“taskschd.msc”，并点击下方的“确定”打开任务计划程序。
2、在任务计划程序的设置界面，依次展开 任务计划程序库 -&gt; Microsoft -&gt; Windows -&gt; WindowsUpdate，把里面的项目都设置为 [ 禁用 ] 就可以了。(我这里边只有一个任务，你的电脑里可能会有2个或者更多，全部禁用就行了)
四、在注册表中关闭Win10自动更新
1、同时按下 Win + R 组合快捷键，打开运行对话框，然后输入命名 regedit，然后点击下方的「 确定 」打开注册表。
2、在注册表设置中，找到并定位到 [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\UsoSvc]。然后在右侧找到“Start”键。
2、点击修改，把start值改成16进制，值改为“4”，然后点击「 确定 」保存数据
3、继续在右侧找到“FailureActions”键，右键点击修改该键的二进制数据，将“0010”、“0018”行的左起第5个数值由原来的“01”改为“00”，完成后，点击下方的“确定”即可
至此彻底关闭win10自动更新的操作步骤就全部完成了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f58cf1ac2c6ae3be94851aa4f399a3e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dade19ef9f4edf429785f6e66575f1f/" rel="bookmark">
			理解图像卷积操作的意义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字信号处理中卷积 卷积一词最开始出现在信号与线性系统中，信号与线性系统中讨论的就是信号经过一个线性系统以后发生的变化。由于现实情况中常常是一个信号前一时刻的输出影响着这一时刻的输出，所在一般利用系统的单位响应与系统的输入求卷积，以求得系统的输出信号（当然要求这个系统是线性时不变的）。
卷积的定义：
卷积是两个变量在某范围内相乘后求和的结果。如果卷积的变量是序列x(n)和h(n)，则卷积的结果：
数字图像处理中卷积 数字图像是一个二维的离散信号，对数字图像做卷积操作其实就是利用卷积核（卷积模板）在图像上滑动，将图像点上的像素灰度值与对应的卷积核上的数值相乘，然后将所有相乘后的值相加作为卷积核中间像素对应的图像上像素的灰度值，并最终滑动完所有图像的过程。
这张图可以清晰的表征出整个卷积过程中一次相乘后相加的结果：该图片选用3*3的卷积核，卷积核内共有九个数值，所以图片右上角公式中一共有九行，而每一行都是图像像素值与卷积核上数值相乘，最终结果-8代替了原图像中对应位置处的1。这样沿着图片一步长为1滑动，每一个滑动后都一次相乘再相加的工作，我们就可以得到最终的输出结果。除此之外，卷积核的选择有一些规则：
1）卷积核的大小一般是奇数，这样的话它是按照中间的像素点中心对称的，所以卷积核一般都是3x3，5x5或者7x7。有中心了，也有了半径的称呼，例如5x5大小的核的半径就是2。
2）卷积核所有的元素之和一般要等于1，这是为了原始图像的能量（亮度）守恒。其实也有卷积核元素相加不为1的情况，下面就会说到。
3）如果滤波器矩阵所有元素之和大于1，那么滤波后的图像就会比原图像更亮，反之，如果小于1，那么得到的图像就会变暗。如果和为0，图像不会变黑，但也会非常暗。
4）对于滤波后的结构，可能会出现负数或者大于255的数值。对这种情况，我们将他们直接截断到0和255之间即可。对于负数，也可以取绝对值。
边界补充问题 上面的图片说明了图像的卷积操作，但是他也反映出一个问题，如上图，原始图片尺寸为77，卷积核的大小为33，当卷积核沿着图片滑动后只能滑动出一个55的图片出来，这就造成了卷积后的图片和卷积前的图片尺寸不一致，这显然不是我们想要的结果，所以为了避免这种情况，需要先对原始图片做边界填充处理。在上面的情况中，我们需要先把原始图像填充为99的尺寸。
常用的区域填充方法包括：
为了画图方便，这里就不用55的尺寸了，用33定义原始图像的尺寸，补充为9*9的尺寸，图片上的颜色只为方便观看，并没有任何其他含义。
原始图像：
补零填充 边界复制填充 镜像填充 块填充 以上四种边界补充方法通过看名字和图片就能理解了，不在多做解释。
不同卷积核下卷积意义 我们经常能看到的，平滑，模糊，去燥，锐化，边缘提取等等工作，其实都可以通过卷积操作来完成，下面我们一一举例说明一下：
一个没有任何作用的卷积核： 卷积核：
将原像素中间像素值乘1，其余全部乘0，显然像素值不会发生任何变化。
平滑均值滤波： 选择卷积核：
该卷积核的作用在于取九个值的平均值代替中间像素值，所以起到的平滑的效果：
高斯平滑： 卷积核：
高斯平滑水平和垂直方向呈现高斯分布，更突出了中心点在像素平滑后的权重，相比于均值滤波而言，有着更好的平滑效果。
图像锐化： 卷积核：
该卷积利用的其实是图像中的边缘信息有着比周围像素更高的对比度，而经过卷积之后进一步增强了这种对比度，从而使图像显得棱角分明、画面清晰，起到锐化图像的效果。
除了上述卷积核，边缘锐化还可以选择：
梯度Prewitt： 水平梯度卷积核：
垂直梯度卷积核：
梯度Prewitt卷积核与Soble卷积核的选定是类似的，都是对水平边缘或垂直边缘有比较好的检测效果。
Soble边缘检测： Soble与上述卷积核不同之处在于，Soble更强调了和边缘相邻的像素点对边缘的影响。
水平梯度：
垂直梯度：
以上的水平边缘与垂直边缘检测问题可以参考：Soble算子水平和垂直方向导数问题 http://blog.csdn.net/chaipp0607/article/details/54348624
梯度Laplacian： 卷积核：
Laplacian也是一种锐化方法，同时也可以做边缘检测，而且边缘检测的应用中并不局限于水平方向或垂直方向，这是Laplacian与soble的区别。下面这张图可以很好的表征出二者的区别：来源于OpenCV官方文档 http://docs.opencv.org/master/d5/d0f/tutorial_py_gradients.html
OpenCV实现 可以利用OpenCV提供的filter2D函数完成对图像进行卷积操作，其函数接口为：
CV_EXPORTS_W void filter2D( InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor=Point(-1,-1), double delta=0, int borderType=BORDER_DEFAULT ); 第一个参数: 输入图像
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dade19ef9f4edf429785f6e66575f1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc43840c59d9ed5a24987ceee54c26b5/" rel="bookmark">
			解决 Cannot download node-sass 切换淘宝源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 执行以下语句
npm config set sass_binary_site=https://npm.taobao.org/mirrors/node-sass 重新执行 npm install
或切换为dart-sass
//先安装dart-sass npm install node-sass@npm:dart-sass //安装成功后再安装sass和sass-loader npm install sass sass-loader 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f17c5df1f58f7a169dde71964db484b/" rel="bookmark">
			Code Composer Studio(CCS)主题配色自定义教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1概要 文章以黑色主题为例，列出了比较直观的一些设置项，仅适用CCS11及以上。颜色值供参考，请根据个人喜好更改。效果如图：
2开始 设置提示，先点Apply再点Apply And Close，否则有些设置项参数可能不保存。
2.1先设置主题 2.2字体设置 这里推荐一个对中文比较友好的字体：YaHei Consolas Hybrid。(链接: https://pan.baidu.com/s/1uWz2yPdsRjX7YTf6N908wQ?pwd=jr44 提取码: jr44)
Git变动颜色一般只需改图中那两个位置即可：
Ignored Resource (Foreground) ，灰色(120,120,120)；
Uncommitted Change (Foreground)，浅蓝色(114,157,186)。
2.3文本编辑器相关设置 这里自定义3项，编辑器背景色，当前行背景色和选中区域背景色。如果没有显示行号的在这里可以勾上。
当前行高亮颜色深灰色RGB(48,48,48)，选中区域背景色深绿色RGB(0,102,0)，背景色为深灰色RGB(24,24,24)。
2.4代码颜色自定义 class，struct，Union，红色RGB(213,89,89)；
Function declarations， 天蓝色RGB(191,216,255)，用于C；
Function，深海蓝RGB(113,173,200)，用于C；
Keywords，玫瑰红RGB(191,0,96)；
Method declarations，青草绿RGB(0,189,0)，用于C++；
Methods，纯白色RGB(255,255,255)，用于C++；
Numbers，枫芽紫RGB(191,128,255)；
Strings，蛋黄橙RGB(255,198,0)；
Typedefs，浅海蓝RGB(0,208,208)；
2.5注释颜色自定义 /*Multi-line comment*/ 多行注释，枯草绿RGB(81,81,40)；
//Single-line comment，单行注释，死草灰RGB(82,83,66)；
3 END 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b98c90a3e2ad1b905c835c2508d51886/" rel="bookmark">
			找到代码的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 找到代码的两种方法 (1)在elements中找 (2)用vue调试工具 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f64ca2592644796faf584e788c5c175c/" rel="bookmark">
			Windos 安装子系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 参考文章 https://blog.csdn.net/moshowgame/article/details/109039727
WIN10的所有非精简版的系统，都已经内置Linux内核，可以直接打开一个PC应用一样使用Ubuntu子系统。这是非常Cool的体验，并且经历了一段时间的完善和摸索，现在应用起来都非常成熟。
本教程包含
启用linux功能和从微软商店安装Ubuntu配置和启用SSH连接，使用xshell远程连接安装xfce4图形界面和RDP远程桌面连接 不过，网上说只有专业和企业版可以使用，其实我家庭版也是ok的，只要Microsoft Store商店可以打开。Ghost版的似乎大部分都不行，有待大家验证）。
整理 by zhengkai.blog.csdn.net
更新于 2020年10月13日：
新增关于修改阿里云软件源中focal代号的解释 https://developer.aliyun.com/mirror/ubuntu优化连接SSH部分的描述补充清华大学的软件源（阿里云的focal源无法安装xfce4，切换到清华的源则可以） 准备工作：打开Linux子系统功能 1.打开控制面板 ，选择 程序和功能 ，选择 开启或关闭windows功能。
2.在Windows功能中找到 适用于Linux的Windows子系统 ，选择并保存。
3.等待安装完毕，重启电脑。
安装步骤：从Microsoft Store一键安装 安装步骤非常简单，只要能够正常打开 Microsoft Store ，也就是微软的Win10 UWP商店， 就可以搜索到 Ubuntu 进行下载，一般使用最新的LTS长期支持版本，例如当前是 Ubuntu 20.04 LTS 。
打开Ubuntu应用 安装完成后，可以从Win10商店，或者开始菜单中选择，使用Ubuntu就像打开一个应用一样简单，无需各种虚拟机！
Ubuntu子系统的安装位置 Administrator换成你自己的用户名
C:\Users\Administrator\AppData\Local\Packages\C:\Users\Administrator\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc\by zhengkai.blog.csdn.netC:\Users\Administrator\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc\LocalState\rootfs 初始化Ubuntu配置：账号和密码 首次进入系统需要根据提示设置 用户名 和 密码 。
而且必须注意的是，用户名和密码均不建议使用大写，输入密码的时候屏幕也不会显示，请谨慎输入。
设置好 Username &amp; Password 后，即进入Ubuntu系统的Terminal终端界面，此时的Ubuntu子系统是没有图形界面的。
更换软件源-&gt;阿里云/清华：为了更快的安装软件速度 备份原数据源文件。
sudo cp /etc/apt/sources.list /etc/apt/sources_init.list使用vim，编辑数据源文件，清空并重新写入阿里源。
sudo vim /etc/apt/sources.list *. 附加： 这里需要顺便温习一下VIM编辑器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f64ca2592644796faf584e788c5c175c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ccc0d39867c8df839ba20160ee480f1/" rel="bookmark">
			计算机专业答辩技巧小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备 PPT 按照论文的答辩要求，大部分学校都要求大家准备好PPT，一般PPT不宜太长，图片需要多，而文字需要少一点，答辩时切勿一个字一个字的照读PPT。
PPT需要写些什么：
毕设项目名字，你的名字，导师名字毕设的介绍，你的毕设是什么，拿来干什么的技术选型，有什么技术，为什么用这个，有什么优势毕设的功能，有什么功能，能解决什么 【也可以直接进行系统演示不进行下面的不足和优化】
5. 不足以及优化
最后：【结束语】 比如说这篇论文是我自己通过查阅XXX，竭尽所能运用自己大学四年的知识独立完成的，在设计上可能存在不足，期间非常感谢XXX老师一直的支持，请各位老师指正，我一定会好好提升。
毕设项目 如果答辩需要运行项目做展示，检查自己的投影/共享屏幕功能是否正常，如果课室没有网络，断网状态下项目是否能运行起来。
在自己的电脑上操作要运行的功能模块，如果毕设项目还存在某个模块的bug，尽量在前端注释隐藏，或者尽量避免运行该模块。
答辩稿 提前写好答辩的大纲，第一步需要讲什么，第二步需要讲什么。
需要讲什么：参考PPT的流程，在稿件上提示自己要讲除了PPT以外的内容。（也可以打印出ppt直接在ppt正背面写稿）
论文 一般答辩的时候，需要递交论文给指导老师，然后再答辩。
老师可能根据论文问问题，所以对论文也要有“比较全面的熟悉”
流程 提交答辩申请、答辩评分表等材料以及论文给指导老师。
要按时答辩，千万不要迟到，如果有特殊情况，要请假。
穿着得体，要有礼貌，不一定是西服什么的，但是要得体，比如穿个睡衣拖鞋什么的肯定不行，这些可能不加分，但是没有可能就减分。
首先是全世界统一的开场白，介绍自己、论文题目、指导老师，一定要介绍自己的指导老师哦。
根据PPT，自信的演讲。
演讲的时候声音一定要让老师们听得到，自信发言，这样能让老师感觉你有底气。
记得控制好时间。
沉着冷静，边听边记
精神集中，认真思考
既要自信，又要虚心
实事求是，绝不勉强
听准听清，听懂听明
提问 一般有3~5个问题
回答问题，一定不要和老师杠，理智冷静谦虚的解释/回答老师的问题，少说可能，应该；有老师提出的意见老师说什么就是什么，专心听着，虚心接受。有不会的问题，不要随便蒙，实在不行就“问就道歉”。
一定要配合老师，老师问你什么你就答什么，前往不要天马行空。
回答问题要注意的几点：
（1）正确、准确。正面回答问题，不转换论题，更不要答非所问。
（2）重点突出。抓住主题、要领，抓住关键词语，言简意赅。
（3）清晰明白。开门见山，直接入题，不绕圈子。
（4）有答有辩。有坚持真理、修正错误的勇气。既敢于阐发自己独到的新观点、真知灼见，维护自己正确观点，反驳错误观点，又敢于承认自己的不足，修正失误。
（5）辩才技巧。讲普通话，用词准确，讲究逻辑，吐词清楚，声音洪亮，抑扬顿挫，助以手势说明问题；力求深刻生动；对答如流，说服力、感染力强，给教师和听众留下良好的印象。
答辩过程中，老师问的问题一般都和你的设计有关，特别是设计中的一些关键技术，比如：数据库链接方式，数据库设计中的ER图、范式等。一般不会太难，都是一些学过的知识。
对自己设计的评价不要绝对化。比如填补什么空白、国内领先、很好、没有什么问题、最优之类的字眼。回答问题时要谦虚、诚恳，态度端正。
听取答辩小组成员的提问，精神要高度集中，同时，将提问的问题——记在本上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/425ededdd5dd41af8bf8723ab0188980/" rel="bookmark">
			计算机专业毕业设计答辩稿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实例一 尊敬的各位老师：
您们好！
我叫xxx，来自 xx班，学号 xx，我论文的题目是 《**********》。
本篇论文是在xx老师的指导下完成的。在这期间，*老师对我的论文进行了详细的修改和指正，并给予我许多宝贵的建议。在此，我非常感谢她一直以来的精心指导，同时也对各位评审能在百忙之中抽出宝贵的时间，参与论文的审阅和答辩表示不胜感激。下面我就把论文的基本思路向各位答辩老师作如下简要陈述：
一、选题缘由
选择本课题作为我论文的写作题材的原因如下：******
二、资料收集准备工作
选定题目后，为了完成论文，我进行了资料收集，拟定提纲，论文初稿、修改、定稿等一系列程序。在毕业论文的准备和写作过程中，我阅读了大量的***方面的相关书籍和学术期刊论文，这得益于我们学校图书馆丰富的参考书籍和中国学术期刊网中的专业论文。
三、论文的结构和内容
本文共分成*部分：
第一部分主要阐述了******
第二部分主要******
第三部分主要阐述了******
第四部分是******
第******
本篇论文已经完成，还有许多的地方需要更全面的改进，但总的来说，在撰写的过程中，我真实地学到了许多东西，也积累了不少经验，更进一步丰富了自己的知识。但由于个人能力不足，加之时间和精力有限，在许多内容表述、论证上存在着不当之处，与老师的期望还有差距，许多问题还有待进行一步思考和探究，借此答辩机会，希望各位老师能够提出宝贵的意见，指出我的错误和不足之处，我将虚心接受，从而进一步深入学习，使该论文得到完善和提高。
我的答辩自述完毕，谢谢各位老师！
实例二 一、 开场i白
各位老师，上午好！我叫……，是……级……班的学生，我的论文题目是……。论文是在……导师的悉心指点下完成的，在这里我向我的导师表示深深的谢意，向各位老师不辞辛苦参加我的论文答辩表示衷心的感谢，并对四年来我有机会聆听教诲的各位老师表示由衷的敬意。下面我将本论文设计的目的和主要内容向各位老师作一汇报，恳请各位老师批评指导。
二、 内容
首先，我想谈谈这个毕业论文设计的目的及意义。……
其次，我想谈谈这篇论文的结构和主要内容。
本文分成……个部分.
第一部分是……。这部分主要论述……
第二部分是……。这部分分析……
第三部分是……
三、 结束语
最后，我想谈谈这篇论文和系统存在的不足。
这篇论文的写作以及修改的过程，也是我越来越认识到自己知识与经验缺乏的过程。虽然，我尽可能地收集材料，竭尽所能运用自己所学的知识进行论文写作，但论文还是存在许多不足之处，有待改进。请各位评委老师多批评指正，让我在今后的学习中学到更多。
谢谢！
实例三 各位老师，下午好！ 我叫***，是xxxx的学生，我的论文题目是--------------------，论文是在**导师的悉心指点下完成的，在这里我向我的导师表示深深的谢意，向各位老师不辞辛苦参加我的论文答辩表示衷心的感谢，并对三年来我有机会聆听教诲的各位老师表示由衷的敬意。下面我将本论文设计的目的和主要内容向各位老师作一汇报，恳请各位老师批评指导。
首先，我想谈谈这个毕业论文设计的目的及意义。
作为计算机应用的一部分,图书销售管理系统对图书销售进行管理,具有着手工管理所无法比拟的优点,极大地提高图书销售管理效率及在同行业中的竞争力.因此，图书销售管理系统有着广泛的市场前景和实际的应用价值.
其次，我想谈谈这篇论文的结构和主要内容。
本文分成五个部分.
第一部分是综述.这部分主要论述本系统开发的目的和意义，与业务相关的管理原理，以及与系统相关MIS系统开发原理与方法。
第二部分是系统分析.这部分分析用户需求,进行调查研究和分析,目的是根据用户的需求和资源条件,以现状为基础,确定新系统的逻辑模型,即从抽象的信息管理角度出发,为使用户满意,系统应对哪些信息做怎样一些存储、变换与传递，具备哪些功能，从而明确系统应该做些什么。
第三部分是系统设计.通过系统总体设计及详细设计对系统分析的结果进行整合,目的是要得到一个令用户满意的良好的实现方案。
第四部分是系统实现.根据系统设计的内容，讨论了该系统对人员与平台的要求,以及数据库表结构的建立与数据输入,并进行应用程序设计与测试.
第五部分是系统运行.这部分描述了系统操作使用的方法,进行一些系统测试，并评价了该系统.
最后，我想谈谈这篇论文和系统存在的不足。
这篇论文的写作以及系统开发的过程，也是我越来越认识到自己知识与经验缺乏的过程。虽然，我尽可能地收集材料，竭尽所能运用自己所学的知识进行论文写作和系统开发，但论文还是存在许多不足之处,系统功能并不完备，有待改进.请各位评委老师多批评指正，让我在今后的学习中学到更多。
谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7268fc8e8b74b53aed8617a9d7121fd/" rel="bookmark">
			$nextTick 用法与原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 $nextTick 用法与原理：
在Vue 中更新DOM 是异步的， nextTick的主要应用的场景及原因。
1、在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中
在 Vue生命周期函数中 created钩子函数中： DOM 并没有进行任何渲染， 而此时进行DOM 操作无异于是徒劳的， 所以此处一定将DOM 操作的js 代码放进Vue.nextTick 回调函数中， 与之对应的就是mounted()。
钩子函数， 因为该钩子函数执行时所有的DOM 挂载和渲染都已经完成， 此时在该钩子函数中进行任何操作都不会有问题。
2、在数据变化后要执行某个回调函数，而这个操作需要使用随数据改变而改变的DOM结构的时候， 这个操作都应该放进Vue.nextTick () 回调函数中。
3、Vue的官方文档中详细解释：
vue 执行dom 更新是异步的， 只要是观察到数据变化， vue 将会开启一个队列， 并缓冲在同一事件循环中发生的所有数据改变。 如果同一个watcher 被多次触发，只会被推如到队列中一次。 在这种缓冲时去除重复数据对于避免不必要的计算， 和DOM 操作非常重要。 然后下一个事件循环 “tick”中， vue 刷新队列执行实际（去重）工作。 在Vue 内部尝试对异步队列使用原生的promise.then 和 MessageChange，如果执行环境不支持， 会采用setTime（（）=&gt; {} , 0）代替。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/601d1dbd45a2314bd3e92fec3609ddf7/" rel="bookmark">
			Spring基础入门详解与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【1】基础概念 Spring是轻量级的开源的JavaEE框架，它是一个全面的、企业应用开发一站式的解决方案，贯穿表现层、业务层、持久层，可以和其他的框架无缝整合。
这里Spring框架其实我们指的是spring-framework，此外其projects还有SpringBoot、SpringData等。
Spring官网地址：https://spring.io/
Spring版本下载地址：https://repo.spring.io/ui/native/release/org/springframework/spring/
文档目录地址：https://docs.spring.io/spring-framework/docs/current/reference/html/
如下所示，目前稳定可用的是5.3.15版本(General Availability,正式发布的版本，官方推荐使用此版本。)
① Spring特征 轻量
Spring 是非侵入性的， 基于 Spring 开发的应用中的对象可以不依赖于 Spring 的 API。其完整框架大小jar只有1M多，且其所需要的处理开销很小。
控制反转(依赖注入)
Spring通过一种称作控制反转的IOC技术促进了低耦合。当应用了IOC，一个对象依赖的其他对象会通过被动的方式传递进来，而不是这个对象自己创建或查找需要的对象。
面向切片(AOP-aspect oriented programming)
Spring支持面向切片编程，把应用业务逻辑和系统服务分离开来。典型应用比如系统日志采集。
容器
Spring 是一个容器, 因为它包含并且管理应用对象的生命周期。Spring 提供了两种类型的 IOC 容器实现：BeanFactory-IOC 容器的基本实现 和 ApplicationContext-提供了更多的高级特性，是 BeanFactory 的子接口。
BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身。ApplicationContext 面向使用 Spring 框架的开发者，几乎所有的应用场合都直接使用 ApplicationContext 而非底层的 BeanFactory。
框架
Spring 实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用 XML 和 Java 注解组合这些对象，Spring也提供了很多基础功能(事务管理、持久化框集成等)，将应用逻辑的开发留给程序员。
主要包说明如下表
包说明org.springframework.corespring和核心包负责IOC基本实现org.springframework.beans顾名思义，bean的管理org.springframework.aopSpringAOP面向切面编程实现org.springframework.context提供在基础IOC功能上的扩展服务，比如邮件服务、任务调度、JNDI定位等org.springframework.context.supportspring context的扩展支持，用于MVC方面org.springframework.webweb应用开发时需要的核心类org.springframework.web.mvcspringMVC应用开发时的核心类org.springframework.transaction为JDBC、JPA等提供的一套事务管理org.springframework.test对junit等测试框架的封装org.springframework.expressionSpringEL表达式语言org.springframework.jdbc对JDBC的简单封装org.springframework.jms为简化JSM简单实用做的封装org.springframework.orm整合第三方ORM实现比如hibernate、jpaorg.springframework.oxmSpring对object/xml的支持，可以让对象与xml相互转换org.springframework.web.portletSpringMVC 的增强org.springframework.web.servlet对servlet3.0的支持org.springframework.instrumentSpring对服务器的代理接口org.springframework.instrument.tomcatSpring对Tomcat的集成org.org.springframework.asmSpring3.0开始提供自己独立的asm包 ② Spring功能模块 ① Core Container核心容器 Spring 的核心容器是其他模块建立的基础，由 Beans 模块、Core 核心模块、Context 上下文模块和 SpEL 表达式语言模块组成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/601d1dbd45a2314bd3e92fec3609ddf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20604095edfd9ebbcac3559c99244a62/" rel="bookmark">
			如何拿到浏览器请求的所有url
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要先把所有的请求给拿到。例如下面这样
然后进入console里面，输入a = 然后粘贴刚才复制的部分，如果不让粘贴，按照浏览器要求的allow pasting 进行粘贴。
然后粘贴成功之后，执行
b = a.log.entries.map(e=&gt;e.request.url) 就可以拿到所有请求的url了。
也可以根据自己的需要做一些url的处理。
参考: https://gist.github.com/cvan/03ffa0c71317cb6b0b95a41ab189b097
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/662fb7def56448c8a77a57cbe081e385/" rel="bookmark">
			Linux-ubuntu20.04 docker的镜像加速配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux-ubuntu20.04 docker的镜像加速配置 建立demon.json 配置docker国内镜像加速 #1、 建立deamon.json 配置docker国内镜像加速地址 $ sudo vim /etc/docker/daemon.json #添加镜像的内容如下： { "registry-mirrors": [ "https://docker.mirrors.ustc.edu.cn", "https://hub-mirror.c.163.com/", "https://reg-mirror.qiniu.com", "https://registry.docker-cn.com"] } #2、添加完成之后重启docker服务 sudo systemctl reload docker sudo systemctl restart docker #注意：如果重启docker服务时遇到 docker.service is not active,cannot reload问题需要重启ubuntu系统 #3、查看docker 相关信息 sudo docker info #使用命令之后在最后几行出现一下信息代表配置成功 Registry Mirrors: https://docker.mirrors.ustc.edu.cn/ https://hub-mirror.c.163.com/ https://reg-mirror.qiniu.com/ https://registry.docker-cn.com/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/606e38867355e1de46222a49fc2d3995/" rel="bookmark">
			vivado错误记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Cannot set property ‘PACKAGE_PIN’, because the property does not exist for objects of type ‘pin’ 可能的问题：
输入输出端口类型与相应IP不对应，如ddr4中的 c0_ddr4_dq为inout类型 [Synth 8-685] variable ‘nvme_regs_douta’ should not be used in output port connection 可能的原因：
输出采用reg变量 vivado：mixed level sensitive and edge triggered event controls are not supported for synthesis 在always块的敏感列表中既有边沿触发又有电平触发，如下面代码： always @(posedge clk or rst_n) begin ... end // 修改为 always @(posedge clk or negedge rst_n) begin ... end 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/327db6fba7df8acb64de07f12c7fadcb/" rel="bookmark">
			显示完整columns
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先把它转换成列表，然后输出，即可
import os import pandas as pd import numpy as np import xlwings as xw Un = 230 data = pd.read_csv('5%Pn interharmonic.csv') pd.set_option('display.max_columns',None) pd.set_option('max_colwidth',100) pd.set_option('display.max_rows',None) pd.set_option('display.width', 1000) # 设置字符显示宽度 pd.set_option('display.max_rows', None) # 设置显示最大 print(list(data.columns)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc30ee22123b770c6d7d8580a6c0162d/" rel="bookmark">
			Windows下不用敲一行命令使用webstorm将代码上传至Gitlab已经存在的库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Git这个神器对于程序员来说并不陌生了。用git当代码其实比较简单，使用一行命令
git clone http://xx.xx.xx.xx.git 就可以完成了。但是上传代码就比这复杂多了。鄙人也是踩了很多次坑，可能之前成功后没做记录，隔段时间再做就忘了。三天不练手生，这句话还是有点道理的。所以，这里留下一些笔记，供自己也供大家参考。
首先我对于web开发习惯用webstorm。别跟我提vscode。后者除了ts的支持稍微比webstorm好点，其余完败。毕竟前者是收费的。言归正传。用webstorm上传代码到github其实比较简单，因为默认集成了github的插件。上传到gitee也简单，可以从插件市场下载gitee的插件。但是上传代码到gitlab就不怎么简单了。
注意，上传代码到git的前提就是要先安装git.下载完后，一路无脑点击安装就行。默认安装在C盘,建议不要修改路径，因为webstorm会默认匹配这个git.exe的执行文件路径。当然不嫌麻烦也可以自己手动修改。
我的webstorm安装了中文插件，ws的版本的2022.1。后面的操作以此版本进行讲解。
解决方式 一、纯命令行方式 PS:注意，windows下使用命令行模式最好在powershell下面运行，而不是普通的win+R，不然可能会出现一堆的莫名其妙的问题。webstorm的terminal就打开的是windows的powershell。
回到正题。
网上搜索得到的结果，清一色地类似:
先cd到需要上传的文件夹的根目录，然后分别键入
git init git remote add origin https://xx/xx/xx/xx.git git add . git commit -m "Initial commit" git push -u origin master 这些操作还算标准，但是你自己去操作的话就会出现很多问题。具体什么问题，我就不详解了，你可以自己试试。下面我就来说说webstorm自带的git管理上传。
二、使用Webstorm上传 这里，我先建了一个gitTest的项目，用于演示
然后我在gitlab那边新建了一个GitLabUploadTest的空仓库。并且为了模拟那些喜欢加README文件的手痒党，我也默认加了readme(为什么我会提到这个文件。因为有些时候建库的不是我们自己，而且我们的权限也没有master的权限。但是建库的人就喜欢多这一步，给你生成一个README。这样一来，他们不写代码，苦了我们自己，上传的时候如果我们存在的项目有README了，那就绝对冲突，导致上传失败，淦)。
然后我们回到webstorm,找到VCS-&gt;创建Git仓库
默认的话就是指向当前项目，然后选择确定
这个时候，项目的文件名字会变颜色
并且VCS那个选项会变成Git
我们点击这个Git选项，选择管理远程
然后会弹出下面的窗口
点击+号
会要求我们输入URL,此时我们回到浏览器，找到我们新建的gitlab仓库首页，选择clone
拷贝http的那个以git结尾的链接，粘到前面的URL输入框里面。
然后，点击确定。
需要注意的时，如果这是第一次添加这个域下的gitla时，还会弹出一个你登录该gitlab的账号密码输入框。校验成功后，就将该项目绑在远程的gitlab上面了。
为了防止冲突，我们先将项目里面的READMEy移到另外一个地方。
然后右键项目名字，选到Git-&gt;添加
然后文件又会变颜色(绿色)
接着再右键，选择Git-&gt;提取,来获得远程有哪些分支。这一步的操作就是防止，我们没有master分支的权限，导致提交失败。一般来讲，建库的人给我们分配的只有develop分支的上传权限，因此我们要先看一下远程上有哪些分支，然后同步到本地，并切换到有权限的分支，然后上传。
因为我们这个项目只有一个master分支，所以拉下来的只有这个分支，然后点击右下角的master图标
找到origin/master，并选择签出,此时就等同于完全与远程建立好了链接，并且代码库也准备好了同步。
这时我们再把之前备份的README覆盖现有的README,文件名会变颜色。
然后我们邮件Git-&gt;提交
然后键入提交备注
点击提交,成功的话，左下角会提示
接着，再次邮件，选到推送
然后点击推送
然后就会显示
此时再去gitlab页面刷新一下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e443462f9abbb795a79ba4168d139ef/" rel="bookmark">
			前端分页代码实现简要思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		list : null, //table当前所要展示的数据 total : 0, //返回过来的消息总条数 pageIndex : 1, //当前所在页数 pageSize : 10, //一页要展示10条数据 tableData : [], //一次性后端返回过来的数据 //当点击页面跳转时调用这个方法 pageChange:(pageIndex) { var _this = this; if (_this.tableData) { if (pageIndex) { _this.pageIndex = pageIndex; } _this.list = _this.tableData.slice( (_this.pageIndex - 1) * _this.pageSize, _this.pageIndex * _this.pageSize ); console.log(_this.list); } else {} }, getTableData(){ _this.$http.post('/api/getAllTableData',params) .then(res =&gt;{ // 请求接口成功之后,获取列表所有数据 _this.tableData = billArr.result; _this.total = res.data.result.length; _this.list = _this.tableData.slice( (_this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e443462f9abbb795a79ba4168d139ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fb12b93806a9be48f5913db8bfaccee/" rel="bookmark">
			HAL 库使用printf函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include "main.h"
#include "adc.h"
#include "usart.h"
#include "gpio.h"
/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "stdio.h"
#ifdef __GNUC__
#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
#else
#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
#endif
PUTCHAR_PROTOTYPE
{
HAL_UART_Transmit(&amp;huart3,(uint8_t *)&amp;ch,1,0xFFFF);//??????
return ch;
}
/* USER CODE END Includes */
/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
/* USER CODE END PTD */
/* Private define ------------------------------------------------------------*/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fb12b93806a9be48f5913db8bfaccee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fd02e6a3a9105dcaf751ef562fe9930/" rel="bookmark">
			React学习（状态数据更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标： 提示：两个小时学会React状态数据更新
例如：
两个小时学会React状态数据更新 学习内容： 提示：学会React状态数据更新
（6）状态数据更新 React特性是单向数据流，也就是所谓的单向数据绑定，数据的更新包含数据模块更新以及视图更新两部分
直接修改变量数据，变量数据更新，但是视图不会同步更新，这就是单向数据流推荐：更新变量数据，通过this.setState({key: value, key2: value, ...})的形式进行更新，既能更新变量数据，同时也会推送更新视图界面不推荐：直接更新变量数据，最后通过调用this.setState({})刷新视图界面注意：setState({})是一个异步函数 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script src="../../js/react17.0.2.development.js"&gt;&lt;/script&gt; &lt;script src="../../js/react-dom17.0.2.development.js"&gt;&lt;/script&gt; &lt;script src="../../js/babel.min.js"&gt;&lt;/script&gt; &lt;script type="text/babel"&gt; // 使用React的组件化 class Home extends React.Component { state = { pageTitle: "系统首页", flag: true } changeLanguage1() { //直接修改数据， 不会同步视图界面 if (this.flag){ this.state.pageTitle = "系统首页" this.flag = false console.log("111") } else { this.state.pageTitle = "SYSTEM HOME" this.flag = true console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fd02e6a3a9105dcaf751ef562fe9930/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26800a552b5668deb1f037050d998713/" rel="bookmark">
			Python屏蔽InsecureRequestWarning报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用Python3 requests发送HTTPS请求，在关闭SSL认证（verify=False）的情况下：
import requests response = requests.get(url='http://127.0.0.1:12345/test', verify=False) 会出现如下错误：
InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings
解决：
#python3 import urllib3 urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) #python2 from requests.packages.urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(InsecureRequestWarning) PS：如下所示，disable_warnings()代表屏蔽全部warning类型。
def disable_warnings(category=exceptions.HTTPWarning): """ Helper for quickly disabling all urllib3 warnings. """ warnings.simplefilter("ignore", category) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5de5ee448a1422d3faa1babad5e58261/" rel="bookmark">
			jmeter——生成多样的接口自动化html报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jmeter——生成多样的接口自动化html报告 一、实现目的二、实现效果1、jmter自带的HTML报告2、jmeter+ant报告优化3、批量执行jmeter工具4、jmeter+allure生成测试报告 三、实现方案1、jmeter自带的HTML报告2、jmeter+ant优化测试报告3、使用jmeter脚本批量执行工具生成4、jmeter+allure生成测试报告 四、遗留问题 一、实现目的 对于接口自动化来说有很多工具和框架来实现，比较常遇到的实现工具非jmeter莫属啦；
简单的界面、轻巧的安装配置、完善的功能、学习成本低这就导致了jmeter是很多人的首选；
特别是代码基础薄弱的同学，更加适合借助此工具实现接口自动化，而且做接口、性能测试也是极为方便；
对于自动化来说有一个是必不可少的，测试报告，可以对外提供的测试报告，本文就聊一聊jmeter实现接口自动化测试报告的
提供方案，当前提供四种方案来实现，各有优缺建议选择适合项目要求的的方案实现。
二、实现效果 接下来我们聊一下四种方案分别可以实现的html报告效果
1、jmter自带的HTML报告 2、jmeter+ant报告优化 3、批量执行jmeter工具 4、jmeter+allure生成测试报告 三、实现方案 1、jmeter自带的HTML报告 接口自动化HTML
（1）实现方式是通过ant来调用biud文件来实现的
首先是ant安装和环境变量配置：https://blog.csdn.net/tangsl666/article/details/79431037
【注意】：首先查一下本地的JDK版本，1.8以上的建议下载ant1.10，1.8以下的建议下载ant1.9
（2）把apache-jmeter-5.3\extras目录下的ant-jmeter-1.1.1.jar复制到apache-ant-1.9.16\lib目录下
（3）创建一个build.xml文件修改build内容，修改为如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project name="ant-jmeter-test" default="run" basedir="."&gt; &lt;tstamp&gt; &lt;format property="time" pattern="yyyyMMddhhmm" /&gt; &lt;/tstamp&gt; &lt;property name="basedirectory" value="F:\20220425\apache-jmeter-5.3\extras" /&gt; &lt;!-- 需要改成自己本地的 Jmeter 目录--&gt; &lt;property name="jmeter.home" value="F:\20220425\apache-jmeter-5.3" /&gt; &lt;!-- jmeter生成jtl格式的结果报告的路径--&gt; &lt;property name="jmeter.result.jtl.dir" value="F:\20220425\jmeterAnt\jtl" /&gt; &lt;!-- jmeter生成html格式的结果报告的路径--&gt; &lt;property name="jmeter.result.html.dir" value="F:\20220425\jmeterAnt\html" /&gt; &lt;!-- Name of test (without .jmx) --&gt; &lt;property name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5de5ee448a1422d3faa1babad5e58261/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dcf5209325571f0bdc2fe8b88a14760/" rel="bookmark">
			SpringMVC(未完)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、SpringMVC简介
1、什么是MVC
2、什么是SpringMVC
3、SpringMVC的特点
二、准备
三、@RequestMapping注解
1、@RequestMapping注解的功能
2、@RequestMapping注解的位置
3、@RequestMapping注解的value属性
4、@RequestMapping注解的method属性
5、@RequestMapping注解的params属性（了解）
6、@RequestMapping注解的headers属性（了解）
7、SpringMVC支持ant风格的路径
8、SpringMVC支持路径中的占位符（重点）
9、get/post的区别！！！！！！！！！！！！！！！！！！！！！！！！
10、一些注意点
四、SpringMVC获取请求参数
1、通过ServletAPI获取
2、通过控制器方法的形参获取请求参数
3、@RequestParam
4、@RequestHeader
5、@CookieValue
6、通过POJO获取请求参数
7、解决获取请求参数的乱码问题
五、域对象共享数据
1、概述
2、使用ServletAPI向request域对象共享数据
3、使用ModelAndView向request域对象共享数据
4、使用Model向request域对象共享数据
5、使用map向request域对象共享数据
6、使用ModelMap向request域对象共享数据
7、Model、ModelMap、Map的关系
8、向session域共享数据
9、向application域共享数据
六、SpringMVC的视图
1、ThymeleafView
2、转发视图
3、重定向视图
4、视图控制器view-controller-在springMVC.xml文件中配置
5、请求转发和重定向的区别
七、RESTful p50/53的源码还没看
1、RESTful简介
2、RESTful的实现
3、DELETE 用来删除资源：
八、HttpMessageConverter
1、@RequestBody-这是注解，标识形参
2、RequestEntity-这是类型
3、@ResponseBody-注解，标识方法
4、SpringMVC处理json
5、注解驱动的作用
6、SpringMVC处理ajax
7、@RestController注解
8、ResponseEntity
九、文件上传和下载
1、文件下载
2、文件上传
十、拦截器
1、拦截器的配置
2、拦截器的三个抽象方法
3、多个拦截器的执行顺序
十一、异常处理器
十二、注解配置SpringMVC
1、创建初始化类，代替web.xml
一、SpringMVC简介 1、什么是MVC M:模型层（model）包括service，dao，pojo
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dcf5209325571f0bdc2fe8b88a14760/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c337b0b842dfd47e73ab479da18df970/" rel="bookmark">
			如何把插件提交到WordPress？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近写了一个开源了一个小的插件:Auto Generate Navigation,提交到WordPress碰到了许多坑，这里就简单记录一下。
如需了解更多，请访问: https://www.emperinter.info/2022/05/10/how-to-submit-plug-ins-to-wordpress/
插件编写 主题代码编写 这里就说几个我踩过的坑
CSS和JS的引用方式 wp_register_style('plugin_stylesheet_css', plugins_url('autoc.css', __FILE__)); wp_enqueue_style('plugin_stylesheet_css'); wp_register_script('plugin_stylesheet_js', plugins_url('autoc.min.js', __FILE__)); wp_enqueue_script('plugin_stylesheet_js'); 层级目录如下图:
插件名称的确定,文件名最好就是xxx-xxx-xxx格式，均为小写。我这里是auto-generate-navigation。
函数的命名一定要特别，以防止和其它插件函数名称冲突。
readme.txt的编写,其中尤其是版本那一块需要特别注意。
=== 插件名称 === Contributors: WordPress.org 的用户名 Tags: 插件的标签，比如 spam Donate link: 捐款链接地址 Requires at least: 最低 WordPress 版本 Tested up to: 最高测试的 WordPress 的版本 Requires PHP: 所需 php 版本 Stable tag: 稳定版标签，如 1.0 License: 开源协议 License URI: 协议地址 这里是短描述，会展示在列表中 == Description == 这里是长描述，会展示在独立的页面中 == Installation == 具体的安装说明 == Frequently Asked Questions == 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c337b0b842dfd47e73ab479da18df970/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54dec76041454c7e65412b03b1496f42/" rel="bookmark">
			怎样改变conda创建虚拟环境的python版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时创建了新的虚拟环境之后才发现，有些包并不支持现有的python版本这就很麻烦。常用的改变这一窘境的方法就是重新建一个虚拟环境，但是之前花了很多时间装了那么多包，这不就浪费了嘛。最好的一种做法就是在当前环境下降低版本，代码如下：
conda install python=版本号 这就是替换几个包的问题，换起来很快。其实换完之后会发现，之前安装的包也都没有了。很尴尬，但是也比重新删除安装简单。
conda 创建虚拟环境和对虚拟环境的管理等操作可以参考博文【Conda管理】Conda管理虚拟环境常用的操作整理的很详细。
参考文献 [1]ubuntu系统anaconda降级python3.7为python3.6
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d70e69d8d69857af09614de808fbb5c5/" rel="bookmark">
			（数字ic）CDC设计实例 - ICG ：integrate Clock Gating Cell
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CDC设计实例 - ICG ：integrate Clock Gating Cell 1、Latch原理2、ICG消除毛刺原理1）en信号中的毛刺出现在clk低电平期间，如下图所示2）en信号出现在clk高电平期间，如下图所示 3、SoC系统中时钟切换应用场景 1、Latch原理 锁存器（latch）：所谓锁存器，就是输出端的状态不会随输入端的状态变化而变化，仅在有锁存信号时输入的状态才被保存到输出，直到下一个锁存信号到来时才改变。
2、ICG消除毛刺原理 Clock gating cell 可以由与门或者或门构成，但是使用这两者会产生Glitch，因此目前都采用ICG（Integrated clock gating cell)，其结构如下
ICG由一个latch（低电平有效）和一个与门（gating cell，也可以是或门）组成。ICG 可以过滤掉en信号中的毛刺信号，其原理如下：
对于毛刺信号Glitch，大概可以分为两种情况：
1）en信号中的毛刺出现在clk低电平期间，如下图所示 由上图可以发现，en信号在clk低电平期间产生了毛刺，并且该latch是低电平有效，所以会采集到该毛刺信号，如信号enl中所示，但是由于该ICG的gating cell采用的是与门，此时cl
为低电平，即使enl有毛刺信号，也不能通过与门，因此该毛刺信号被过滤。
2）en信号出现在clk高电平期间，如下图所示 由于ICG中的latch是低电平有效，所以在clk高电平期间，latch采集不到en中的毛刺信号，因此该毛刺信号被过滤掉了。
综合以上，可以发现，无论en中的毛刺信号出现在clk低电平或者是高电平期间，ICG可以有效过滤掉en信号中的毛刺，得到好的clk波形！具体的ICG电路及其波形图如下所示
3、SoC系统中时钟切换应用场景 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d0e9f5bd7820a1d9505cf18da4e873d/" rel="bookmark">
			【翻译】比较4个NodeJS Serverless App的框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【原作者】Gedalyah Reback
【原文链接】Comparing Frameworks for Node.js Serverless Apps
【推荐阅读】12 Best Nodejs Frameworks for App Development in 2022
Express.js- Express for EveryoneKoa.js- Next Generation Node.js FrameworkMeteor.js- One Application, One LanguageSocket.io- Chat Apps Made Easy with Socket.ioNest.js- A Nestling of CodeSails.js- Modernized Data-Oriented MVC Framework Total.js- A Complete FrameworkHapi.js- Secure than EverFeather.js- F for FlexibleLoopback.js- Better ConnectivityAdonis.js-The Dependable FrameworkDerby.js-The Racer 正文:
多年来，云部署变得更加复杂。这是他们的责任，但这不一定是错误的——现在你可以做的比过去多得多。随着时间的推移，每一项新服务都变得越来越容易，这种能力的蓬勃发展确实归功于它自己。AWS、谷歌和 Azure 开始提供减轻本地计算基础设施负担的产品。很快，用户和提供商就被需求和新云服务的激增所淹没。
AWS 于 2002 年推出，然后开始提供用自己的基础设施替换本地基础设施。在谷歌和微软推出自己的产品后，Docker 于 2013 年首次亮相，以组织（“容器化”）越来越多的开发人员开始使用的服务。Kubernetes 很快就出现了，从那时起，就有大量的工具试图理解 Kubernetes 本身。显然，这对于新手来说会感到困惑，但对于刚开始使用云计算的新手和老手来说，这足以说明这是需要组织的大量基础架构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d0e9f5bd7820a1d9505cf18da4e873d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f6f63feca4ac354de5a90564e35b178/" rel="bookmark">
			【Pytorch基础】torch.nn.MSELoss损失函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MSE: Mean Squared Error（均方误差）
含义：均方误差，是预测值与真实值之差的平方和的平均值，即：
M S E = 1 N ∑ i = 1 n ( x i − y i ) 2 \begin{aligned} MSE =\cfrac {1}{N}\sum_{i=1}^n(x_i-y_i)^2 \end{aligned} MSE=N1​i=1∑n​(xi​−yi​)2​
但是，在具体的应用中跟定义稍有不同。主要差别是参数的设置，在torch.nn.MSELoss中有一个reduction参数。reduction是维度要不要缩减以及如何缩减主要有三个选项：
‘none’:no reduction will be applied.‘mean’: the sum of the output will be divided by the number of elements in the output.‘sum’: the output will be summed. 如果不设置reduction参数，默认是’mean’。
下面看个例子：
import torch import torch.nn as nn a = torch.tensor([[1, 2], [3, 4]], dtype=torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f6f63feca4ac354de5a90564e35b178/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3d42742b103e427a9915e8e7f6d1f0c/" rel="bookmark">
			SpringBoot用户鉴权以及统一获取用户信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
背景
解决方案
方法一：手动调用方法进行解析
方法二：拦截器+方法参数解析器
步骤
WebMvcConfigurer配置权限拦截器和方法参数解析器
自定义HandlerInterceptor进行权限校验，token解析
自定义@CurrentUser注解，并加入到controller接口中
自定义HandlerMethodArgumentResolver，将request中的User传给@CurrentUser
背景 前端调用后端Controller方法时，进入Controller方法后，经常需要获取当前登录用户的信息，便于一些后续的用户操作(比如保存时需要自动填入当前登录用户的用户名)。
通常的做法是，前端将token信息放入请求头中，后端拿到请求头中的token后，再将token解析成用户信息。
解决方案 token解析工具类方法
校验token有效性：boolean isValid = tokenUtils.isValid(token);
解析token为User：User user = tokenUtils.getUserInfoByToken(token);
方法一：手动调用方法进行解析 直接在需要使用用户信息的地方调用token解析方法获取User对象。
方法二：拦截器+方法参数解析器 WebMvcConfigurer + HandlerInterceptor + HandlerMethodArgumentResolver
步骤 自定义WebMvcConfigurer配置权限拦截器HandlerInterceptor 及方法参数解析器HandlerMethodArgumentResolver。自定义权限拦截器AuthInterceptor拦截所有请求，校验token有效性，并将token解析为User，放到request中。自定义参数注解@CurrentUser，将注解添加到controller的方法参数中。自定义方法参数解析器CurrentUserMethodArgumentResolver，取出request中的User对象，并将User对象赋值给@CurrentUser注解的参数user。 WebMvcConfigurer配置权限拦截器和方法参数解析器 Spring内部的一种配置方法，通过用java代码代替xml配置Bean，可以通过实现WebMvcConfigurer接口自定义一些MVC相关的Handler，Interceptor等。
@Configuration public class SecurityAutoConfiguration implements WebMvcConfigurer{ @Override public void addInterceptors(InterceptorRegistry registry) { // addInterceptor：添加一个实现HandlerInterceptor了接口的拦截器实例 // addPathPatterns：用于设置拦截器的过滤路径规则 registry.addInterceptor(getAuthInterceptor()).addPathPatterns("/**"); } @Bean public AuthInterceptor getAuthInterceptor() { // 声明AuthInterceptor拦截器Bean，需实现HandlerInterceptor接口 return new AuthInterceptor(); } @Bean public CurrentUserMethodArgumentResolver currentUserMethodArgumentResolver() { // 声明自定义方法参数解析器 return new CurrentUserMethodArgumentResolver(); } @Override public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) { // 添加CurrentUserMethodArgumentResolver参数解析器 argumentResolvers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3d42742b103e427a9915e8e7f6d1f0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/061f48be6daef1c089006e48ad8bd715/" rel="bookmark">
			基于卷积神经网络的高光谱分类 CNN&#43;高光谱&#43;印度松数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于卷积神经网络的高光谱分类 一、研究现状 只考虑到高光谱图像的光谱特征，即：
1、提取特征(小波变换、Gabor纹理分析、形态学剖面)
2、利用分类方法分类(支持向量机、决策树、随机森林、神经网络)
缺点：这些特征提取方法需要依据先验知识手动设置，且通过设定参数提取的特征信息通常只能
​ 用于区分特定的对象，缺乏灵活性，并且分类性能无法进一步提升。
本文提出：卷积神经网络的高光谱分类
​ 优点：能同时提取图像中的1）光谱信息；2）空间信息；3）能够自动的学习和优化网络中的参数，
​ 而不需要过多的人工调整
二、高光谱图像 ​ 高光谱与RGB三通道图像的最大不同是，其具有上百个通道（就是一个三维的数据立方体）假如一个N X N X B 的图像，RGB图像的B维度有三个通道，高光谱图像的B维度有上百个通道(他的光谱维度)
​ 高光谱的三维：二维几何空间及一维光谱信息
​ 光谱维度展开不仅可以获得图像上每个点的光谱数据，还可以获得任一个谱段的影像信息
三、降维 PCA(主成分分析) ​ 主成分分析（Principal Component Analysis，简称为 PCA）PCA 变换又称为霍特林变换（hotelling transform）和K-L （karhunen-loeve）变换。
是一种用于多变量数据信息提取的降维算法(提取数据的主要特征分量)，离散 K-L 变换是理论基础，PCA 也被称为特征脸方法。其主要思想是通过计算不同维度图像训练样本与各维训练样本均值的差值之间的相关性，评估各维空间特征表征整体空间特征的能力，再将所有图像样本最大特征值对应的特征向量投影到较低维度空间，最终实现降维。
算法具体描述如下：
1、 数据预处理。假设有 M 维图像数据，I1, I2, … … I𝑀，作为训练样本，每个图像由 m 行和 n 列像素组成。假设多维信息各维度数据不相关，将所有图像转换为图像向量Γ1, Γ2, … … Γ𝑀，并且每个图像向量的维度为m × n。
2、计算特征空间。
3、 投影与相似性检验。
四、CNN ​组成：一般包括全连接层、卷积层、&lt;激活函数层&gt;、池化层（有平均池化、最大池化两种）有了这些层使得卷积神经网络有了可以拟合各种函数的能力。
作用：通过卷积运算，将图像进行降维，使其可以进行训练
卷积操作示意(通过3x3的卷积核进行特征提取)
1）卷积层 通过卷积核(kernel)和原始图像上等同大小的区域进行卷积运算，通过计算得到特征图（与图像等同大小的尺寸的像素点进行对应相乘，再将相乘结果相加得到特征图上的特征值）
卷积核的参数不同提取到的特征不同，一个卷积层可以有多个卷积核，低层的卷积层提取到的是边框、颜色等简单特征；中层提取到低层特征的集合；高层提取到图像的全局特征
2）池化层（最大池化Max-Pooling） 池化有：最大池化，均值池化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/061f48be6daef1c089006e48ad8bd715/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/148/">«</a>
	<span class="pagination__item pagination__item--current">149/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/150/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>