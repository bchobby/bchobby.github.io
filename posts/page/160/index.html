<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bad6c75e25441e77a91cdf17731964ad/" rel="bookmark">
			Qt5学习笔记之bin文件合成工具二：bin文件的读取和写入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 概述实现步骤1.调整界面并布局。2.显示文件路径和偏移量3.bin文件读取4.将读取的bin文件写入到新的文件。5.测试运行效果：6.解决00结束符问题 GitHub下载 概述 上一小节主要是练习下本地文件的打开和另存为，现在我们开始正式bin文件合成工具的开发。
先学习《Qt学习之路2.pdf》第36节 二进制文件读写。
本篇文章的目标：
1.重新设计界面
2.实现不同bin文件的选取
3.合成bin文件涉及的内容略多：将选好的3个bin文件根据偏移量合成为1个bin文件，空出的内容填充为FF。在本篇文章，我们先实现一个bin文件的读取和另存写入。
实现步骤 1.调整界面并布局。 工具是为了自己开发方便，不求做成一个通用工具去发布给大家使用（这个可能比较耗精力，作为初学者我还是先简单实现即可）。我的实际应用中合成主要分为3端，IAP、APP、最后的参数页。界面设计如下，其中路径和偏移量的显示框我们都是用LineEdit组件，避免出现换行问题：
2.显示文件路径和偏移量 IAP、APP、Para三个按钮实现功能相同，选取本地bin文件，将路径和默认偏移量填写到界面的对应位置即可。在上一小节已经测试过通过文件框选取本地文件。
QString path = QFileDialog::getOpenFileName(this, tr("Open File"),//控件的objectName ".", //对话框显示时默认打开的目录，"." 代表程序运行目录 tr("Bin Files(*.bin)")); //对话框的后缀名过滤器，将txt文件改为bin文件。 qDebug("path = %s",qPrintable(path)); 这里我们只需将过滤器修改为*.bin即可。将path打印出来，即为选中文件的绝对路径：
将path直接填充到路径显示框中即可。程序中没有使用path，而是使用一个QString变量获取文件信息，最后进行填充：
QString buf; QFileInfo info(file); buf = QString(info.absolutePath()); buf.append("/"); buf.append(info.baseName()); //直接获得文件名 buf.append(".bin"); qDebug("%s",qPrintable(buf)); //与上面的path变量相同，可直接使用path变量 qDebug() &lt;&lt; info.filePath(); ui-&gt;iappathEdit-&gt;setText(buf); ui-&gt;iapoffsizeEdit-&gt;setText(tr("0x00000000")); //默认偏移量 3.bin文件读取 要主要分为两步：根据路径显示框来获取文件、读取bin文件到程序中。
QFile readfile(ui-&gt;iappathEdit-&gt;text()); //要读取的bin文件 QFileInfo read_file_info(readfile); //要读取的bin文件的信息 if (!readfile.open(QIODevice::ReadOnly)) { //只读方式打开bin文件 QMessageBox::warning(this, tr("Read File"), tr("Cannot open file:\n%1"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bad6c75e25441e77a91cdf17731964ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/167c63e995a80d94ca4fc3e1e66e7ddf/" rel="bookmark">
			java培训：判断元素是不是在集合里的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何快速判断一个元素是不是在一个集合里？这个题目是我最近面试的时候常问的一个问题，这个问题不同人都有很多不同的回答。
今天想介绍一个很少有人会提及到的方案，那就是借助布隆过滤器。
什么叫布隆过滤器
布隆过滤器（Bloom Filter）是一个叫做 Bloom 的老哥于1970年提出的。
实际上可以把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。
它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。
实现原理
先来一张图
布隆过滤器算法主要思想就是利用 n 个哈希函数进行 hash 过后，得到不同的哈希值，根据 hash 映射到数组（这个数组的长度可能会很长很长）的不同的索引位置上，然后将相应的索引位上的值设置为1。
判断该元素是否出现在集合中，就是利用k个不同的哈希函数计算哈希值，java培训看哈希值对应相应索引位置上面的值是否是1，如果有1个不是1，说明该元素不存在在集合中。
但是也有可能判断元素在集合中，但是元素不在，这个元素所有索引位置上面的1都是别的元素设置的，这就导致一定的误判几率（这就是为什么上面是活可能在一个集合中的根本原因，因为会存在一定的 hash 冲突）。
注意：误判率越低，相应的性能就会越低。
作用
布隆过滤器是可以用于判断一个元素是不是（可能）在一个集合里，并且相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。
注意上面的一个词：可能。这里先预留一个悬念，下文会详细分析到。
使用场景
判断给定数据是否存在防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。 具体实现
看完了布隆过滤器的算法思想，那就开始具体的实现的讲解。
我先来举个例子，假设有旺财和小强两个字符串，他们分别经过三次的 hash 算法，然后根据 hash 的结果将对应的数组（假设数组长度为 16）的索引位置的值置为1，先来看下旺财这个词组:
旺财经过三次 hash 过后，值分别为2,4,6 那么根据可以得到索引值分别为 2、4、6，于是就将该数组的索引（2、4、6）位置的值置为1，其余当做是0，现在假设需要查找旺财 ，同样经过这个三个hash 然后发现得到的索引 2、4、6对应的位置的值都为1，那么可以判断旺财可能是存在的。
接着有将小强插入到布隆过滤器中，实际的过程和上面的一样，假设得到的下标是 1、3、5
抛开旺财的存在，小强此时是这样子在布隆过滤器中的，结合旺财和小强实际的数组是这样子的：
现在有来一个数据：9527，现在要求是判断 9527 是否存在，假设9527 经过三次 hash 过后得到的下标分别为：5、6、7。结果发现下标为 7 的位置的值为0，那么可以肯定的判断出，9527 一定不存在。
接着又来了一个 国产007，经过三次 hash 过后得到的下标分别为：2、3、5，结果发现 2、3、5下标对应的值全是1，于是可以大致判断出 国产007可能存在。但是实际上经过我们刚刚的演示，国产007 根本就不存在，之所以 2、3、5 索引位置的值为1 ，那是因为其他的数据设置的。
说到这里，不知道大家有没有明白布隆过滤器的作用。
代码的实现
作为 java 程序员，我们真的是很幸福了，我们使用到很多的框架和工具，基本都被封装好了，布隆过滤器，我们就使用 google 封装好的工具类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/167c63e995a80d94ca4fc3e1e66e7ddf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/513eb98da6097f7485a40a254884744c/" rel="bookmark">
			eharts 实现展示时间区间图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eharts 实现展示时间区间图 效果图如下：其中每一条都是时间区间
话不多说，代码如下所示：
import * as echarts from 'echarts'; var chartDom = document.getElementById('main'); var myChart = echarts.init(chartDom); var option; // 初始化echart //var chart = echarts.init(document.getElementById('chart-box')); // 各状态的颜色 var colors = ['red', 'orange']; // 状态 var state = ['正常', '繁忙']; // echart配置 var option = { color: colors, tooltip: { formatter: function (params) { return params.value[1].substr(11) + '~' + params.value[2].substr(11); } }, legend: { data: state, bottom: '1%', selectedMode: false, // 图例设为不可点击 textStyle: { color: '#000' } }, grid: { left: '3%', right: '3%', top: '1%', bottom: '10%', containLabel: true }, xAxis: { type: 'time', //设置横坐标标签格式 axisLabel: { formatter: function (value) { var date = new Date(value); return getzf(date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/513eb98da6097f7485a40a254884744c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef42e8fde7a4bdc8bd1a65f8666095e5/" rel="bookmark">
			Jenkins使用k8s的pod运行slave节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jenkins使用k8s的pod运行slave节点 一、安装插件二、创建证书秘钥三、Jenkins中添加凭证四、在Jenkins上添加kubernetes集群五、测试kubernetes Jenkins支持以Pod形式运行Slave节点，实现规模可伸缩的Jenkins Cluster，需要安装插件“kubernetes” 通过jenkins/inbound-agent镜像创建的pod连接至Jenkins的master节点，需要在master节点上开启代理50000端口 一、安装插件 系统管理-&gt;管理插件-&gt;可选插件,搜索kubernetes plugin，安装完成后重启Jenkins！！！
二、创建证书秘钥 在master节点上生成对应的证书
#1、查看kubernetes的config文件 cat ~/.kube/config #2、根据配置文件生成证书.替换引号内部的信息为config内相关value echo "certificate-authority-data" | base64 -d &gt; ca.crt echo "client-certificate-data" | base64 -d &gt; client.crt echo "client-key-data" | base64 -d &gt; client.key #3、生成jenkins使用的cert.pfx，此处需要设置一个4位数以上的密码 openssl pkcs12 -export -out cert.pfx -inkey client.key -in client.crt -certfile ca.crt ls ca.crt cert.pfx client.key client.crt 三、Jenkins中添加凭证 把生成的cert.pfx证书上传至Jenkins，系统管理–凭证管理–Jenkins–全局凭据
四、在Jenkins上添加kubernetes集群 系统管理–系统配置–Cloud
填写k8s集群api-server的url，kubernetes服务证书为刚刚生成的ca.crt，凭据为刚刚添加的，填写Jenkins地址，点击连接测试验证 Jenkins开启系统代理：系统管理–全局安全配置，设置代理端口为50000
ss -anptu | grep 50000 tcp LISTEN 0 50 *:50000 *:* users:(("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef42e8fde7a4bdc8bd1a65f8666095e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e0055c8dd4f22f785e5049161272fd7/" rel="bookmark">
			实测：nn.CrossEntropyLoss()多维输出 &#43; 权重分配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pytorch版本：1.10.0
part1：多维输出部分 问题描述：
我有长度为14万的频域序列数据若干，要对每条序列进行异常检测。我将每个长序列划分为多个短序列，每个短序列长度为1000，即140000 = 140×1000，Model输出是140个值，即将序列检测问题转换为时间序列分类问题。
因此，我的模型输出（输入给loss函数）为16×140×2，对140个短序列作二分类，loss使用nn.CrossEntropyLoss()，多维输出。
官方文档定义为：
为简单起见，我的测试代码如下所示：
输入input维度：[1,2,3]
标签label维度：[1,3]
输出output维度：1个值，是3维的平均值（在weight默认，reduction默认为'mean'时），即 0.7711 = - [ -1.2158 - 0.3249 - 0.7726] / 3
part2：权重分配部分 主要是用来解决类别不平衡问题。在我的实际问题中，正反类数量为3:137，严重不平衡。
因此我设置权重：
在这里解释一下如何设置权重。
结论是：为数量少的类别设置更大的权重。
原因：对于二分类问题，模型会犯2种错误，即①将正类预测为反类②将反类预测为正类
在我的Dataset中，正类极少，因此学习到的Model会更倾向于预测为反类，因此我要惩罚第①种错误，避免都预测为反类。
2022.3.7 更新： 上面对于权重分配方面，是我一厢情愿了，真实测试发现，pytorch并不是这样理解权重分配的。
nn.CrossEntropyLoss()里面的权重，作用是平衡正反类样本的数量。
因此，可以理解权重是将该样本（也就是该类样本）的数量增加m倍。
Pytorch中nn.CrossEntropyLoss()加权计算方式如下： 注：以下内容请对应nn.CrossEntropyLoss(）pytorch的官方文档阅读。
若batch_size&gt;1，那么nn.CrossEntropyLoss()输出结果已经平均掉batch_size = N了
程序验证：
a = torch.tensor([[-0.4514,0.7823,0.5210],[-0.0082,-0.3569,-0.2626]],requires_grad=True) a = a.unsqueeze(0) tar = torch.tensor([[0,1,1]]) # a = torch.randn(1,2,3,requires_grad=True) # tar =torch.randint(0,2,(1,3)) # print(a,'\n',tar) fn1 = nn.CrossEntropyLoss(reduction='mean') fn2 = nn.CrossEntropyLoss(reduction='sum') # 加权后 fn3 = nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e0055c8dd4f22f785e5049161272fd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/776f3b09bdb1449bbe25e4690717f81b/" rel="bookmark">
			226.翻转二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		226.翻转二叉树
题目地址：力扣
翻转一棵二叉树。
思路：
我们之前介绍的都是各种方式遍历二叉树，这次要翻转了，感觉还是有点懵逼。
这得怎么翻转呢？
如果要从整个树来看，翻转还真的挺复杂，整个树以中间分割线进行翻转，如图：
可以发现想要翻转它，其实就把每一个节点的左右孩子交换一下就可以了。
关键在于遍历顺序，前中后序应该选哪一种遍历顺序？ （一些同学这道题都过了，但是不知道自己用的是什么顺序）
遍历的过程中去翻转每一个节点的左右孩子就可以达到整体翻转的效果。
**注意只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果**
**这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不行，因为中序遍历会把某些节点的左右孩子翻转了两次！**
那么层序遍历可以不可以呢？**依然可以的！只要把每一个节点的左右孩子翻转一下的遍历方式都是可以的！**
递归法：
1. 确定递归函数的参数和返回值
参数就是要传入节点的指针，不需要其他参数了，通常此时定下来主要参数，如果在写递归的逻辑中发现还需要其他参数的时候，随时补充。
返回值的话其实也不需要，但是题目中给出的要返回root节点的指针，可以直接使用题目定义好的函数，所以就函数的返回类型为`TreeNode`。
```
TreeNode invertTree(TreeNode root)
```
2. 确定终止条件
当前节点为空的时候，就返回
```
if (root == NULL) return root;
```
3. 确定单层递归的逻辑
因为是先前序遍历，所以先进行交换左右孩子节点，然后反转左子树，反转右子树。
```
swap(root);
invertTree(root.left);
invertTree(root.right);
```
基于这递归三步法，代码基本写完，Java代码如下：
```JAVA
class Solution {
public TreeNode invertTree(TreeNode root) {
if (root == NULL){return root;}
swap(root); // 中
invertTree(root.left); // 左
invertTree(root.right); // 右
return root;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/776f3b09bdb1449bbe25e4690717f81b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/042333de9539854ff6eaa041a2164c13/" rel="bookmark">
			2.git的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.git 文章目录 2.git1. 冲突的修改2. 获取git的url地址3. git查看branch4. git建立新的分支5.git删除本地文件并提交记录6.恢复误删的文件7.解决冲突8. 版本回退9. 撤销commit 1. 冲突的修改 pull时错误
保留本地修改，支持pull git stash #将改动隐藏 git pull #新代码覆盖本地代码 git stash pop #将刚隐藏的改动恢复 不保留本地修改 git reset --hard #直接覆盖掉 git pull 2. 获取git的url地址 git remote -v 3. git查看branch git branch 4. git建立新的分支 git clone下来一个需要的分支
从当前的分支拉copy开发分支,路径就是lz/copy
$ git checkout -b git checkout -b lz/copy Switched to a new branch 'lz/copy' 把新建的分支push到远端 $ git push origin lz/copy #会让输入sudo用户名和密码，并打印出迁出的分支 拉取分支、 $ git pull There is no tracking information for the current branch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/042333de9539854ff6eaa041a2164c13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/654a3016f961da8102207ba1590d6059/" rel="bookmark">
			python:一些做过的作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入输出
1、利用input函数输入自己的名字，并打印出来
2、利用input函数输入自己的年龄，打印出自己的年龄+2的结果
3、利用input函数分别输入自己的名字和年龄，并打印出如下字符串：“哇塞，xx今年yy岁了！”
变量、数据类型和表达式
1、分别创建三个变量并进行赋值作为三门功课的成绩，计算总分和平均分，并打印
2、编写程序实现一个三位数字的反序输出
3、从键盘输入求的半径，计算求的表面积和体积并进行打印
字符串
1、现有字符串： str1 = 'www.hufe.edu.cn'，根据题目要求，将截取后的新字符串赋值给str2并输出
（1）截取字符串的第一位到第三位的字符
（2）截取字符串最后三位的字符
（3）截取字符串的全部字符
（4）截取字符串的第七个字符到结尾
（5）截取字符串的第三个字符
（6）输出字符串的长度
（7）将字符串中所有的"."换成"-"并输出
（8）删除字符"."，拆分成四个字符串并输出
2、按照一定格式输出（最好能够用常用方法和format方法两种实现）：
（1）打印123456的二进制、八进制和十六进制
（2）打印Python，要求格式：空白填充+左对齐+固定宽度20
（3）打印70305084.0 要求格式: 千分位+空白填充+右对齐+固定宽度18+浮点精度.2+浮点数声明f
3、已知字符串 a = “aAsar3ide4bgs7Dlsf9eAF”,要求如下:
（1）找出字符串中最先出现i字母的位置
（2）计算a字母出现的次数
（3）将a字符串的大写改为小写，小写改为大写。
（4）将a字符串的数字取出，并输出成一个新的字符串
（5）去除a字符串中的字母a，并输出
（6）将a字符串反转并输出
4、编写程序，自动生成宿舍的组合名，从键盘上分别输入宿舍人员的姓名，取其中的一个字连在一起，输出组合名
5、编写程序，实现人民币和美元转换，其中：‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬人民币和美元间汇率固定为：1美元 = 6.78人民币。‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬程序可以接受人
民币或美元输入，转换为美元或人民币输出。人民币采用RMB表示，美元USD表示，符号和数值之间没有空格‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬，
结果小数点后保留两位。‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬
1.1 x=input("请输入你的名字") y=eval(input("请输入你的年龄")) print("哇塞，{}明年{}岁了！".format(x,y+1)) 1.2 strs = 'www.hufe.edu.cn' str1=strs[0:3] str2=strs[-3:] str3=strs[6:] str4=len(strs) str5=strs.replace(".","-") str6=strs.count("w") print(str1) print(str2) print(str3) print(str4) print(str5) print(str6) 1.3 a="aAsar3ide4bgs7Dlsf9eAF" s=[] e=a.index('i') print(e) y=a.count("a") print(y) for i in a: if ord(i)&gt;=65 and ord(i)&lt;=90:#大写 i=ord(i)+32 print(chr(i),end="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/654a3016f961da8102207ba1590d6059/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bdc02871845f1aecf3dbb08a61108ff/" rel="bookmark">
			python接口自动化之带Header信息的请求封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# coding=utf-8 import requests from Logs.Log import Logger import json from Public.GetToken import Token log=Logger('请求日志执行结果').getlog() class WebRequests(): #传入get请求必要的参数 def get(self, url, params=None, headers=None, files=None,cookies=None): '''封装get方法，return返回响应信息''' try: #设置headers信息 headers = {'Content-Type': 'application/json;charset=UTF-8'} r = requests.get(url, params=params, headers=headers, files=files, cookies=cookies) log.info("请求的内容：%s" % params) status_code = r.status_code # 获取响应状态码 log.info("获取返回的状态码:%d" % status_code) response_json = r.json() # 获取json格式类型的数据 log.info("响应内容：%s" % response_json) return r # 返回响应的数据 log.info('接口请求成功') except BaseException as e: log.error("请求失败！", exc_info=1) #传入post请求必要的参数 def post(self, url, data=None, headers=None, files=None,cookies=None): '''封装post方法，return返回响应数据''' try: # 设置headers数据 里面token数据来源于Token类中的GetLoginToken()函数提取的数值 headers = {'Content-Type': 'application/json;charset=UTF-8','sid':Token().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bdc02871845f1aecf3dbb08a61108ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de37de6ad62e6b6c379a71afa1be1e55/" rel="bookmark">
			python：２４点游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		24点游戏是指随机选取4张扑克牌（不包括大小王），然后通过四则运算来构造表达式，如果表达式的值恰好等于24就赢一次。编写代码测试随机给定的4个数是否符合24点游戏。
用户输入4个1-13之间的整数，程序自动搜索+-*/全部可能计算出24的组合及数目。如果得不到结果，则提示失败。
废话不多说，直接上代码
中缀运算符改后缀运输符
有点乱
def get_c(num): if num == 0: return '+' elif num == 1: return '-' elif num == 2: return '*' else: return '/' print("请输入4个数字") g24 = [] for i in range(4): g24.append(input("")) a = b = c = '+' flag = False stack1 = [] stack2 = [] for i in range(0, 4): for j in range(0, 4): for q in range(0, 4): a = get_c(i) b = get_c(j) c = get_c(q) res = g24[0] + a + g24[1] + b + g24[2] + c + g24[3] #将中缀表达式转化为后缀表达式 n = len(res) for w in range(0, n): if res[w].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de37de6ad62e6b6c379a71afa1be1e55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7980122646122eb6a4efd3e887529c2/" rel="bookmark">
			解决方法： No space in execution regions with .ANY selector matching
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文禁止转载！！！！
Error: L6406E: No space in execution regions with .ANY selector matching dunder.o(i.__mathlib_dbl_underflow).
单片机资源受限，出现这种错误，一般可以从以下几个方面进行优化：
第一，增加堆栈空间的大小，修改对应的汇编文件：
第二，修改编译器中的优化等级为O3
第三，去除掉冗余的不需要的库文件，不要编译到工程中，只保留自己需要的外设
如果以上三步还是不行，那么需要进一步的裁减代码
第四步，裁减工程目录中的不需要的代码。具体的裁减方式可以查看map文件，双击工程就可以打开map文件。
在map文件映射中，会包含所有的函数列表。
仔细查看里面的函数列表，如果发现函数没有被调用，那么就删除掉这个函数的定义和声明
必要的情况下，可以删减ARM官方库中的文件。
删除项目中没有使用到的宏定义，变量类型声明，尽量减少全局变量，减少大的局部变量的使用
第五、去除掉printf
因为printf会占用大量的内存空间，使用到这个printf会暂用内存，所以去除掉调试语句。
这一点经常被忽略，但是确实非常重要的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa58037354075879da9dafbd9fcf8e59/" rel="bookmark">
			win10下torch和trt无法一起加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 self._handle = _dlopen(self._name, mode)
OSError: [WinError 127] 找不到指定的程序。
import torch import tensorrt as trt 就这两行代码然后就报错了
OSError: [WinError 127] 找不到指定的程序。 这里推测 我有两个cuda版本，trt依赖的是cuda11.5，torch依赖是cuda11.3
先加载torch导致trt找不到依赖的库。
解决方案，先加载trt，再加载torch。
import tensorrt as trt import torch if __name__ == "__main__": print(torch.__version__) print(trt.__version__) print("hello world") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b043dfe7d197d9a96dc14e116817299b/" rel="bookmark">
			spring实验2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验二SpringAOP的使用 实验目的：
了解AOP的概念和作用理解AOP中的切面以及通知熟悉Spring中两种动态代理方式的区别掌握基于代理类的AOP实现 实验类型：
验证性
实验学时：
2学时
实验内容：
实验任务1：创建项目，导入相关依赖
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 实验任务2：创建目标接口和实现类
public interface UserDao { public void addUser(); public void deleteUser(); } public interface ScoreDao { public void addScore(); public void deleteScore(); } public interface StudentDao { public void addStudent(); public void deleteStudent(); } @Repository("scoreDao") public class ScoreDapImpl implements ScoreDao { public void addScore() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b043dfe7d197d9a96dc14e116817299b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3453609ef7cfdefd8c405bf75afa347/" rel="bookmark">
			C&#43;&#43;代码笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		猜数字游戏 系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。
错解：
#include&lt;iostream&gt; #include&lt;cstdlib&gt; using namespace std; int main() { int num = rand() %100+1;//生成0-100的随机数 int a=0; cout &lt;&lt; "请输入猜测的数字: "&lt;&lt;endl; cin &gt;&gt; a; if(a&gt;num) { cout&lt;&lt;"数字大了"&lt;&lt;endl; } else if(a&lt;num) { cout&lt;&lt;"数字小了"&lt;&lt;endl; } else(a=num) { cout&lt;&lt;"恭喜你，猜对了"&lt;&lt;endl; } system("pause"); return 0; } 分析：1；while循环
2：随机数种子
3：循环跳出的条件
if嵌套的循环语句中，最后一个else没有（），切记
正解：
#include&lt;iostream&gt; #include&lt;cstdlib&gt; #include&lt;ctime&gt; //随机数种子的头文件 using namespace std; int main() { srand(time(NULL));//防止每次生成的随机数都一样 int num = rand() %100+1;//生成随机数种子 int a=0; //	cout&lt;&lt; num&lt;&lt;endl; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3453609ef7cfdefd8c405bf75afa347/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca8d05cc11c08ac95349fc476b4cdbad/" rel="bookmark">
			从.yml配置文件中读取属性值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从.yml配置文件中读取属性值 实现YamlPropertySourceFactory类关联的对象类 参考文章 springboot使用@PropertySource的默认factory是读取.properties文件属性。
如果要读取yml或者yaml格式的文件属性值，需要自定义一个YamlPropertySourceFactory
实现YamlPropertySourceFactory类 package com.example.demo.config; import lombok.AllArgsConstructor; import org.springframework.beans.factory.config.YamlPropertiesFactoryBean; import org.springframework.boot.env.YamlPropertySourceLoader; import org.springframework.core.env.PropertiesPropertySource; import org.springframework.core.env.PropertySource; import org.springframework.core.io.support.DefaultPropertySourceFactory; import org.springframework.core.io.support.EncodedResource; import org.springframework.core.io.support.PropertySourceFactory; import java.io.FileNotFoundException; import java.io.IOException; import java.util.Properties; public class YamlPropertySourceFactory extends DefaultPropertySourceFactory { @Override public PropertySource&lt;?&gt; createPropertySource(String name, EncodedResource resource) throws IOException { // 指定配置路径中的文件名 String filename = resource.getResource().getFilename() == null ? "" : resource.getResource().getFilename(); // 资源为空，则会抛出异常 resource.getInputStream(); // 配置文件为 properties 文件，调用原逻辑 if (resource == null || filename.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca8d05cc11c08ac95349fc476b4cdbad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ef9e50552309e50323be7cf0fdd036f/" rel="bookmark">
			c&#43;&#43;字母三角形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输出一个稍微复杂的三角形，输入一个大写字母(A-z)或者一个数字( 1-9 ) 。
比如输入是F的时候，输出:
输入是3的时候，输出：
示例代码：
#include&lt;iostream&gt; using namespace std; int main() { char c; cin &gt;&gt; c; if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') { for (int i = 1; i &lt;= c - 'A' + 1; i++)	//行数 { for (int j = 1; j &lt;= c - 'A' + 1 - i; j++)	//每行的空格数为最后一行是第几行减去当前行数 { cout &lt;&lt; " "; } for (int j = 1; j &lt;= i; j++)	//递增的部分，第一行1个， 第二行2个 { cout &lt;&lt; char('A' + j - 1); } for (int j = i - 1; j &gt;= 1; j--)	//递减的部分 { cout &lt;&lt; char('A' + j - 1); } cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ef9e50552309e50323be7cf0fdd036f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d109ba413bfe895a113d8d3554f2ca6d/" rel="bookmark">
			HTML表格（HTML 表格的使用，收藏这一篇就够了）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML 表格 文章目录 HTML 表格 1. 表格的定义2. 表格的标签3. 单元格边框(border)4. 合并单元格 4.1 合并行单元格(colspan)4.2 合并列单元格(rowspan) 5. 表格格式设置 5.1 单元格的对齐（align）（居中，左对齐，右对齐）5.2. 背景色&amp;图片（bgcolor &amp; background） 5.2.1 单元格背景色&amp;图片5.2.2 表格背景色&amp;图片 5.3 单元格的边距（cellpadding）5.4 单元格间的距离(cellspacing)5.5 显示部分边框（frame &amp; rules） 1. 表格的定义 &lt;table&gt; 标签定义 HTML 表格。简单的 HTML 表格由 table 元素以及一个或多个 &lt;tr&gt;、&lt;th&gt; 或 &lt;td&gt; 元素组成表格结构；其中： &lt;tr&gt; 元素定义表格行，&lt;th&gt; 元素定义表头，&lt;td&gt; 元素定义表格单元。
为了让表格更美观，我们会用到：border，colspan，rowspan，align，bgcolor 等来美化表格，具体在本文都有讲解；
2. 表格的标签 在HTML定义表格的时候，有以下标签供我们使用
NO
表格标签
用处
1
&lt;table&gt;
定义表格，生成的表格在一对&lt;table&gt;&lt;/table&gt;中；
2
&lt;caption&gt;
定义表格标题，当表格需要标题时，使用&lt;caption&gt;表格标题&lt;/caption&gt;
3
&lt;thead&gt;
定义表格的页眉
4
&lt;tbody&gt;
定义表格的主体
5
&lt;tfoot&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d109ba413bfe895a113d8d3554f2ca6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edf1d0edf5c92df2d04714d9e8cfa61c/" rel="bookmark">
			百度地图 获取当前位置 添加标记物等基础使用 JavaScript API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标：实现一个能自动定位我当前位置的地图，并且地图上能显示我想要标记物，以及能搜索地图对应的位置。这地图只能在IE浏览器上有效果，其他浏览器不支持。
先上效果图：
接下来说说怎么实现：
1.首先先去百度地图开放平台注册个账号：百度开发平台
然后点击控制台
填写开发者资料并认证。
2.接着去创建AK，也就是授权码，这个很关键，必须要去申请创建，要不然项目中没法调用百度地图的API。
这里应用名称随便写，应用类型选择服务端，启用服务按我图中勾选为主。
设置白名单IP：设置0.0.0.0/0就行
点完提交就能获取到AK了，记得保存下来，后面会用到。
3.在对应页面中，引入百度api的js
&lt;script type="text/javascript" src="//api.map.baidu.com/api?v=2.0&amp;ak=你的AK"&gt;&lt;/script&gt; 4.写上你想承载这地图dom元素
&lt;div id="r-result"&gt;地点搜索:&lt;input type="text" id="suggestId" size="20" placeholder="请输入地点信息..." style="width:250px;margin-top: 10px;margin-left:10px;padding: 0 20px;line-height: 36px;" /&gt;&lt;/div&gt; &lt;div id="searchResultPanel" style="border:1px solid #C0C0C0;width:150px;height:auto; display:none;"&gt;&lt;/div&gt; &lt;div id="l-map" style="width:700px; height:680px;margin-top: 10px;"&gt;&lt;/div&gt; 5.实现获取当前位置的Js代码：这里如果获取成功，会执行locationSuccess的回调方法。如果获取失败了，会执行locationError回调方法。
function getNowLocation() { if (navigator.geolocation) { navigator.geolocation.getCurrentPosition(locationSuccess, locationError, { // 指示浏览器获取高精度的位置，默认为false enableHighAccuracy: true, // 指定获取地理位置的超时时间，默认不限时，单位为毫秒 timeout: 5000, // 最长有效期，在重复获取地理位置时，此参数指定多久再次获取位置。 maximumAge: 3000 }); }else{ alert("浏览器不支持Html5来获取地理位置信息"); } } locationSuccess回调方法实现：也就是获取当前位置的经度和纬度（H5浏览器自带的定位功能），然后根据经度和纬度获取当前的位置（调用百度api方法）
function locationSuccess(position) { let lat = position.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edf1d0edf5c92df2d04714d9e8cfa61c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ea7d5ec3008ac66e470a0615f532f76/" rel="bookmark">
			outputStream转inputStream
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你在Java程序中处理IO流的话，很快就会碰到如下的场景，你向一个类中的OutputStream写数据，同时需要从另一个类的InputStream中读取这些数据，在一些流式的场景更多，例如我们在一个HTTP的请求中，客户端请求的资源需要较长时间的处理，为了避免端测的长时间等待，我们可以处理好一部分数据就先返回一部分数据，减少不必要的等待，这个时候我们就需要考虑到这两种流的互转。这边主要介绍3中转换的方法
方法一：使用byte array缓存转换 代码示例如下
ByteArrayOutputStream baos = new ByteArrayOutputStream(); ByteArrayInputStream swapStream = new ByteArrayInputStream(baos.toByteArray()); 这种方式最为简单，但是要求执行baos.toByteArray()这个方法之前，需要的数据已经完全写入，即无法做到边写边读，另外其需要足够的内存来一次性的容纳这些数据。
方法二：使用Pipes 代码示例如下
PipedInputStream in = new PipedInputStream(); PipedOutputStream out = new PipedOutputStream(in); new Thread( new Runnable(){ public void run(){ class1.putDataOnOutputStream(out); } } ).start(); class2.processDataFromInputStream(in); 顾名思义，pipe即为管道，这种方法支持流式的方式，一端写一端读，向PipedOutputStream写入的数据可以从PipedInputStream读出，很好的解决了方法一中的短处，是个人较为推荐的一种方式。
注意 PipedInputStream中存储数据的数组大小默认为1024，且使用过程中不可扩充，当一次性写入的数据超过这个数，则会有个AssertionError抛出。当然，我们可以在初始化PipedInputStream的时候进行设置。上述代码仅为pipe的一种使用的方式，其也可以初始化如下 PipedOutputStream out = new PipedOutputStream(); PipedInputStream in = new PipedInputStream(out); 两种方式等价。
方法三：使用Circular Buffers 作为PipedInputStream和PipedOutputStream的一种替代方式，CircularBuffer有着更为简单的数据结构和使用方法，但是其并不是JDK自带的类需要额外引入
&lt;!-- https://mvnrepository.com/artifact/org.ostermiller/utils --&gt; &lt;dependency&gt; &lt;groupId&gt;org.ostermiller&lt;/groupId&gt; &lt;artifactId&gt;utils&lt;/artifactId&gt; &lt;version&gt;1.07.00&lt;/version&gt; &lt;/dependency&gt; 其使用代码示例如下
CircularByteBuffer cbb = new CircularByteBuffer(); new Thread( new Runnable(){ public void run(){ class1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ea7d5ec3008ac66e470a0615f532f76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e55982b56520268f229fca7b0f85a4e/" rel="bookmark">
			orm框架 MyBatis-Plus（Spring boot &#43; Gradle）安装与入门【2022年】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 写此文的原因在于，由于软件版本迭代的太快了，网上的许多教程已经不合适了，同时有许多命令并不太懂其含义。
如果觉得本篇章对您有所帮助，希望能给我一个赞，稍稍鼓励一下，非常感谢。
官方教程 传送门
我的版本信息 java 17.0.1（后面修改成8了，如果有差异会在文章中注明）gradle 7.4mysql 8.0mybatis plusv 3.5.1 官方版本更新日志 安装教程 首先创建一个Spring boot（Gradle）项目，具体教程与此入门教程传送门一致
安装相关依赖
Spring Boot
Maven：
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; Gradle:
打开build.gradle compile group: 'com.baomidou', name: 'mybatis-plus-boot-starter', version: '3.5.1' 由于新版取消了compile的用法，所以，无法运行或者是出现报错的可以更改为如下 implementation group: 'com.baomidou', name: 'mybatis-plus-boot-starter', version: '3.5.1' 版本号version可以根据官方的进行具体的修改
其他配置
dependencies { //SpringBoot 基础配置 implementation 'org.springframework.boot:spring-boot-starter-web' testImplementation 'org.springframework.boot:spring-boot-starter-test' //Mybatis-plus(简称MP)依赖 implementation group: 'com.baomidou', name: 'mybatis-plus-boot-starter', version: '3.5.1' //lombok java库依赖 compileOnly 'org.projectlombok:lombok' annotationProcessor 'org.projectlombok:lombok' //devtool 用于配置热部署的，可以删去 developmentOnly 'org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e55982b56520268f229fca7b0f85a4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b041bfd44e7e315ad7b448ad7c602fc/" rel="bookmark">
			source insight打开时闪退的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完美解决source insight4启动时闪退的方法：
ource Insight 4.0打开一会就闪退 解决方法
补充一句：闪退其实是因为软件开了自动更新导致的，先用兼容模式运行source insight4，进软件后按照上述博客中的步骤关闭自动更新，然后关闭source insight4后可以在桌面快捷方式的属性里面把兼容模式去掉，然后就可以正常使用source insight4了。
以下是闲话，可看可不看，哈哈~
csdn上所有的方法都试过了，都快要放弃source insight转用vscode了，最后在Source Insight崩溃的2种解决方法这篇文章的评论区里面看到了一个方法，然后试了下，果然就好了。
上述文章中的评论区里面的网友给的方法是以兼容模式运行source insight4：
桌面快捷方式上面右键-属性-兼容性-选择以兼容性运行这个程序。
在兼容性-&gt;兼容模式中，将以兼容模式运行这个程序打钩，然后点击确定，然后回到桌面，双击source insight的快捷方式打开。
上述方法是可以解决一启动就闪退的问题，但是还是会出现在使用过程中突然闪退的情况。于是继续csdn，竟然发现很多网友在这段时间都遇到了这种问题。最终也发现了真正解决问题的办法：
ource Insight 4.0打开一会就闪退 解决方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/572748c7e6d58f38719e8ff5c1255237/" rel="bookmark">
			ES索引迁移 可跨服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用ElasticSearch的HTTP接口
使用Python对HTTP进行封装
迁移时将所需迁移的Field进行替换即可
import json import requests url = "http://127.0.0.1:9200/索引名/_search?size=索引个数&amp;from=0" # 此处填写你的ElasticSearch的URL data = { "query": { "match_all": { } } } # 使用match_all对原始索引数据进行下载 HEADERS = {'Content-Type': 'application/json;charset=UTF-8'} res = requests.get(url=url, data=json.dumps(data), headers=HEADERS) res_js = res.json() # print(res_js) print(len(res_js['hits']['hits'])) n = 0 for i in range(0, len(res_js['hits']['hits'])): query = { # 可根据自己实际需要添加索引的FIE老师 'Field1': res_js['hits']['hits'][i]['_source']['Field1'], 'Field2': res_js['hits']['hits'][i]['_source']['Field2'], 'Field3': res_js['hits']['hits'][i]['_source']['Field3'], 'Field4': res_js['hits']['hits'][i]['_source']['Field4'], 'Field5': res_js['hits']['hits'][i]['_source']['Field5'], 'Field6': res_js['hits']['hits'][i]['_source']['Field6'], 'Field7': res_js['hits']['hits'][i]['_source']['Field7'] } url = 'http://新的URL:9200/新的索引的名/新的Type/' + str(res_js['hits']['hits'][i]['_source']['id']) es = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/572748c7e6d58f38719e8ff5c1255237/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cec2ecf4e990c36cd2afe1c14da02dd9/" rel="bookmark">
			import org.apache.hadoop.conf.Configuration无法import；The import org.apache cannot be resolved
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查找网上许多方法都没用，最后自己从包处解决
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IOUtils;
出现上述都无法import的情况
报错显示：The import org.apache cannot be resolved
分析得出无法找到对应的包，而看报错先看第一个报错
org.apache.hadoop.conf.Configuration这个的包是
hadoop-common-2.7.3.jar
解决方法如下：：
右键项目——》点击属性Properties
在Libraries找到这个包,
双击这个包，找到这个包的真正路劲，选中（一开始我是这个包后面的路劲错了，所以没找到这个包）
大家在自己电脑要找到属于它的真正位置，当然如果你不是因为这个原因，那就爱莫能助了
说一下我上面这个包的路劲是在：
按道理，大家找到自己hadoop的安装包，然后在其share\hadoop\common\下即可找到
若是·找不到再整个电脑找一下，实在找不到再去网上找这个jar包下载放进去即可
点击Apply-》OK
可以看到正常import了
谢谢阅读，有用的话可以点个赞嘛
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95045be979207f40beffc857da4ebd6e/" rel="bookmark">
			STM32定时器学习-PWM输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本定时器 最基础功能定时，两个基础定时器TM6和TM7,基本定时器时钟源只来自内部时钟。
如果我们想要一个1s的定时，那么我们应该怎么设置定时器呢？
首先了解定时器的基本初始化结构体
typedef struct { uint16_t Prescaler; // 预分频器 uint16_t CounterMode; // 计数模式 uint32_t Period; // 定时器周期 uint16_t ClockDivision; // 时钟分频 uint8_t RepetitionCounter; // 重复计算器 } TIM_Base_InitTypeDef; 首先考虑计数模式（CounterMode），定时器有五种计数模式，向上计数、向下计数、三种中心对齐模式，本实验的基本定时器只能是向上计数，从0开始计数，并且无需初始化。定时器预分频器设置（Prescaler），设置它来取得每次计数的时间。例如每次计数的时间为100us，我们称之为时钟源周期，因为输入时钟为84MHZ，所以设置预分频器为（8400-1）定时器周期（Period） 刚刚我们知道了时钟源时间，一个时钟源时间我们刚刚设定为100us，如果我们有10000个这样的时间我们就有了1s定时。而系统是从0开始计数的所以我们设定时需要减一（10000-1）。ClockDivision：时钟分频，设置定时器时钟 CK_INT 频率与数字滤波器采样时钟频率分频比， 基本定时器没有此功能，不用设置。RepetitionCounter：重复计数器，属于高级控制寄存器专用寄存器位，利用它可以非常容易控制输出 PWM 的个数。 这里不用设置。 基本定时器只需要设定两个成员就行。
我们来看初始化基本定时器函数
static void TIM_Mode_Config(void) { // 开启 TIMx_CLK,x[6,7] __TIM6_CLK_ENABLE(); TIM_TimeBaseStructure.Instance = TIM6; /* 累计 TIM_Period 个后产生一个更新或者中断*/ //当定时器从 0 计数到 4999，即为 5000 次，为一个定时周期 TIM_TimeBaseStructure.Init.Period = 5000-1; //定时器时钟源 TIMxCLK = 2 * PCLK1 // PCLK1 = HCLK / 4 // =&gt; TIMxCLK=HCLK/2=SystemCoreClock/2=84MHz // 设定定时器频率为=TIMxCLK/(TIM_Prescaler+1)=10000Hz TIM_TimeBaseStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95045be979207f40beffc857da4ebd6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c7351eb33bab2d264fbfff9f7ce4e19/" rel="bookmark">
			RuntimeError: Error compiling objects for extension 和nvcc fatal : Unsupported gpu architecture ‘c
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下最近跑TinaFace代码在原来服务器跑没有问题，新服务器跑遇到的错误
首先，按照官网步骤安装相关包：
本人环境：
显卡驱动版本： NVIDIA-SMI 460.73.01 Driver Version: 460.106.00 CUDA Version: 11.2
CUDA版本：nvcc -V： Cuda compilation tools, release 11.1, V11.1.74
pytorch 1.8.1 torchvision 0.9.1 mmcv-full 1.4.6 mmdet 2.22.0 cudatoolkit 11.1.1 ps：如果没有安装上mmcv或者mmdet，不要怀疑，肯定是你的版本有问题。这个问题博主也遇到了。
检查上面版本，通常来讲，没有任何问题。
cudatoolkit严格按照cuda版本安装的，mmdet也是根据cuda版本和pytorch版本安装的。
不出意外的话出意外了，最后一步执行命令 pip install -v -e . 编辑vedadet报错：
Installing collected packages: vedadet Running setup.py develop for vedadet Running command /mnt/data/cbm/software/anaconda3/envs/lw/bin/python -c 'import io, os, sys, setuptools, tokenize; sys.argv[0] = '"'"'/mnt/data1/lw/vedadet-main/setup.py'"'"'; __file__='"'"'/mnt/data1/lw/vedadet-main/setup.py'"'"';f = getattr(tokenize, '"'"'open'"'"', open)(__file__) if os.path.exists(__file__) else io.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c7351eb33bab2d264fbfff9f7ce4e19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f76fc4fe6ff4a6bca5df265245d5f4e/" rel="bookmark">
			最最详细的黑马前端HTML5&#43;CSS3笔记，给大家整理好了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于黑马前端视频学习的CSS3笔记，每一天的知识点都放在一起，方便学习查阅 ==CSS第一天== 一、css简介二、css语法规范三、css代码风格四、css选择器的作用五、css基础选择器 1、标签选择器：2、类选择器3、多类名选择器4、id选择器：5、id选择器和类选择器的区别6、通配符选择器7、选择器总结 六、css字体属性: 1、字体大小：2、字体粗细：3、字体样式：4、字体的综合写法5、字体总结： 七、css文本属性： 1、文本颜色：2、文本对齐：3、修饰文本：4、文本缩进5、行间距： 八、css样式表： 1、行内样式表（行内式）2、内部样式表（嵌入式）3、外部样式表（链接式） 九、Chrome调试工具： ==CSS第二天== 一、emmet语法 1、简介2、快速生成HTML结构语法3、快速生成CSS样式语法4、快速格式化代码 二、css的复合选择器 1、什么是复合选择器？2、后代选择器 (重要）3、子选择器 (重要）4、并集选择器 (重要）5、伪类选择器6、链接伪类选择器7、:focus 伪类选择器复合选择器总结 三、css的显示模式 1、什么是元素的显示模式2、元素显示模式的分类 2.1、块元素2.2、行内元素2.3、行内块元素2.4、元素显示模式总结 3、元素显示模式的转换4、单行文字垂直居中的代码 四、css的背景 1、背景颜色2、背景图片3、背景平铺4、背景图片位置5、背景图片固定6、背景样式合写7、背景色半透明8、背景总结 ==CSS第三天== 一、css三大特性 1、层叠性2、继承性3、优先级 3.1、权重叠加（重点） 二、盒子模型 1、网页布局的本质 1.1、网页布局过程1.2、网页布局三大核心 2、盒子模型（Box Model）组成3、边框（border） 3.1、边框的使用3.2、表格的细线边框3.3、边框会影响盒子实际大小 4、内边距（padding） 4.1、内边距的使用方式4.2、内边距会影响盒子实际大小 5、外边距（margin） 5.1、外边距的使用方式5.2、外边距典型应用5.3、外边距合并5.4、清除内外边距 三、PS 基本操作 ==CSS第四天== 一、其他样式 1、圆角边框2、盒子阴影3、文字阴影 二、浮动 1、传统网页布局的三种方式2、标准流（普通流/文档流）3、为什么需要浮动？4、什么是浮动？5、浮动特性6、浮动元素经常和标准流父级搭配使用 三、常见网页布局 浮动布局注意点 四、清除浮动 1、为什么需要清除浮动？2、清除浮动本质3、清除浮动样式4、清除浮动的多种方式 4.1、额外标签法4.2、父级添加 overflow 属性4.3、父级添加after伪元素4.4、父级添加双伪元素 总结 五、PS 切图 1、图层切图2、切片切图3、PS插件切图 ==CSS第五天== 1. PS 切图 1.1. 常见的图片格式1.2. 图层切图1.3. 切片切图1.4. 插件切图 1.4.1. 介绍1.4.2. 安装 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f76fc4fe6ff4a6bca5df265245d5f4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f31d2e988fb7f780c73388856ac1442e/" rel="bookmark">
			如何让图片变得更清晰（汇总中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 近日在写论文的时候发现部分图片清晰度较差，为了保持图形的美观，可以使用以下方法：
https://bigjpg.com/对图片进行无损放大，增加清晰度 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f606279cb4daa764db70ec57165d4f24/" rel="bookmark">
			linux安装node(含npm命令) 并配置淘宝镜像源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装NPM 方法一 使用apt安装 npm版本号可能不是最新的
apt install npm 方法二 下载安装包离线安装 1. 下载压缩包 wget https://nodejs.org/dist/v16.14.0/node-v16.14.0-linux-x64.tar.xz # node14 https://nodejs.org/dist/v14.15.4/node-v14.15.4-linux-x64.tar.xz # 推荐将压缩包放置到/usr/local/node文件夹中安装 mv node-v16.14.0-linux-x64.tar.xz /usr/local/node 2. 解压 tar -xf node-v16.14.0-linux-x64.tar.xz 3. 设置环境变量 vim ~/.bashrc 添加【export PATH="&lt;解压后的位置&gt;/node-v16.14.0-linux-x64/bin:$PATH"】
# 例如 export PATH="/usr/local/node/node-v16.14.0-linux-x64/bin:$PATH" 4. 验证是否安装成功 node -v npm -v 若输出版本号则表示安装成功
配置淘宝镜像源 如果直接使用官方的开源库，国内下载不稳定速度慢，淘宝镜像源相对稳定
切换源 npm config set registry https://registry.npm.taobao.org # 显示当前源 npm config get registry 安装 npm install -g cnpm --registry=https://registry.npm.taobao.org 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21944c070e671301116494c313b1af3a/" rel="bookmark">
			[转]Python实现多功能音乐播放器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 就是用Python做一个简易的音乐播放器，废话不多说，咱们直接开干
当然，今天做这个肯定不是最简单的，最简单的音乐播放器，9行代码足以
import time import pygame file = r'歌曲路径' pygame.mixer.init() print('正在播放',file) track = pygame.mixer.music.load(file) pygame.mixer.music.play() time.sleep(130) pygame.mixer.music.stop() 开始今天的代码之前，准备工作 知识点和所需模块 1.python基础知识
2.requests库
3.time
4.pygame
5.tkinter
6.线程
环境 windowspycharm 2021.2python 3.8 完整代码，运行即可，记得👍👍👍（直接明示了） # 导入 import os import time import tkinter import tkinter.filedialog import threading import pygame # pip root = tkinter.Tk() root.title('音乐播放器') root.geometry('460x600+500+100') root.resizable(False,False) # 不能拉伸 folder ='' res = [] num = 0 now_music = '' def buttonChooseClick(): """ 添加文件夹 :return: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21944c070e671301116494c313b1af3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1230ad32d90ba6dbac30f1cc64738af4/" rel="bookmark">
			【深度学习】神经网络基础：反向传播算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：Simona Ivanova
AI/ML 专家
就职于 Science 杂志
导读
反向传播（Backpropagation，简称 BP）是目前用来训练人工神经网络（Artificial Neural Network，简称 ANN）算法最常用、最有效的方法。
反向传播最早出现于 20 世纪 70 年代，但直到 Geoffrey Hinton（杰佛里·辛顿）在1986 年发表了论文《Learning Representations by Back-Propagating Errors》后才得到各界重视。
杰佛里·辛顿：反向传播算法的发明人之一
Geoffrey Hinton（杰弗里•辛顿）
杰佛里·辛顿是一位英国出生的加拿大计算机学家和心理学家，在类神经网络领域贡献颇多，是反向传播算法的发明人之一，也是深度学习的积极推动者，被称为神经网络和深度学习之父。
此外，辛顿还是伦敦大学盖茨比计算神经科学中心创始人，目前担任加拿大多伦多大学计算机科学系教授。他的主要研究方向是人工神经网络在机器学习、记忆、感知和符号处理等领域的应用。目前，辛顿正在探索如何将神经网络运用到无监督学习算法中。
不过，在辛顿众多科研成果中，反向传播是最为著名的，也是目前大部分有监督学习神经网络算法的基础，建立在梯度下降法之上。其主要工作原理为：
ANN 算法在实际运行过程中一般分为输入层、隐藏层和输出层三类，当算法输出结果与目标结果出现误差时，算法会对误差值进行计算，然后通过反向传播将误差值反馈到隐藏层，通过修改相关参数进行调整，并不断重复此步骤，直到得出与预期相符的结果。
通过反向传播可以让 ANN 算法推导更接近目标的结果，不过，在了解反向传播如何应用于 ANN 算法之前，需要先弄清 ANN 的工作原理。
ANN 的工作原理
ANN 是一种基于人脑神经网络的数学模型或者计算模型，由大量节点（可以理解为生物神经元）相互连接而成。
生物神经元
数学模型中的单个节点
每个节点代表一种特定的输出函数，称为激励函数（activation function）；两个节点间的连接就代表一个加权值，也叫权重值。在 ANN 算法运行过程中，每个连接会对应一个权重 w 和偏移量 b（又称为 ANN 参数）。输出值则跟节点、权重值和偏移量有关。
单个神经元模型图
（其中a1～an 为输入向量的各个分量；w1～wn 为权重值；b为偏移量；σ 为激励函数，例如 tanh、Sigmoid、ReLU 等）
一个完整 ANN 一般包含一个输入层、多个隐藏层和一个输出层。其中隐藏层主要由神经元组成，承担最主要的运算工作，在实际运行过程中，每一层的神经元都会做出决策，并将决策传导至下一个隐藏层的神经元，直至输出最终结果。
因此，隐藏层层数越多，ANN 就越复杂，结果也就越准确。举例来讲，假如现在要通过一个 ANN 确定输入的动物「是猫」或者「不是猫」，输入这个动物，每个隐藏层内的神经元都对其会进行一次判定，得出结果，并将结果向下传导，直到最后一层神经元输出结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1230ad32d90ba6dbac30f1cc64738af4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/290f2684d075e9ffc8f020a2df8aacac/" rel="bookmark">
			ESXI 7.0 安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vm ESXI安装教程
下载ESXI7.0的iso镜像
下载地址：
链接：https://pan.baidu.com/s/1ecZq6qUyqMeaBUOz1W84gQ 提取码：h42c 安装教程：
vm新建虚拟机，选择典型安装
下一步选择稍后安装操作系统
点击下一步，选择Vm ESX（x）
选择6.0版本
因为用的是老版本VM，新版本的vm会有7.0的选项，这里安装的也是ESXI7.0
继续点击下一步
路径和名称随便设置，继续下一步
这里建议把配置调高点
然后我们点击完成即可
点击CD/DVD 选择ESXI7.0的iso文件
开启虚拟机进行下一步安装
开启虚拟机后等待上方黄色进度条跑满
进入系统加载安装文件
加载VMkernel文件，等待灰色进度条跑满
加载文件完成按enter（回车）建进行安装ESXI7.0 系统出现End User License Agreement（EULA界面）也就是最终用户许可协议，按【F11】键接受Accept and Continue接受许可协议。 系统提示选择安装VMware ESXi 使用的存储，ESXi支持U盘以及SD卡安装。
黄色字体就是刚刚在vm设置的硬盘
提示选择键盘类型，选择US Default默认美国标准，按【Enter】键继续。
系统提示配置root用户的密码，根据实际情况输入，按【Enter】键继续。
按【F11】键开始安装。
开始安装ESXi 7.0
安装的时间取决于服务器的性能，等待一段时间后即可完成VMware ESXi 7.0的安装，按【Enter】键重启服务器 服务器重启完成后，进入VMware ESXi 7.0正式界面
在浏览器进入web页面账户root，密码在上方设置的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86a94f7c2da1b49284fb0f02512fe6a/" rel="bookmark">
			stm32 单个定时器多路捕获测量频率与占空比（排坑）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单个定时器的多个通道可以捕获不同的方波信号
1.初始化配置
TIM_ICInitStructure.TIM_Channel = TIM_Channel_2; //通道选择
TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising; //上升沿触发
TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //管脚与寄存器对应关系
TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; //输入预分频。意思是控制在多少个输入周期做一次捕获，如果
//输入的信号频率没有变，测得的周期也不会变。比如选择4分频，则每四个输入周期才做一次捕获，这样在输入信号变化不频繁的情况下，
TIM_ICInitStructure.TIM_Channel = TIM_Channel_2; TIM_ICInitStructure.TIM_Channel = TIM_Channel_3; 一定要分开写，切记不可TIM_ICInitStructure.TIM_Channel = TIM_Channel_2|TIM_Channel_3; 会出问题
2.原理
先配置上升沿触发
TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;
位置一
清零CNT计数器TIM_SetCounter(TIM2,0);
并且设置下降沿触发
位置二
下降沿触发进入，捕获此时CNT　IIM2_CH2ReadValue1 = TIM_GetCounter(TIM2); 并且设置上升沿触发
位置三
上升沿触发进入，捕获此时CNT　IIM2_CH2ReadValue2 = TIM_GetCounter(TIM2); 此时利用IIM2_CH2ReadValue1，IIM2_CH2ReadValue2 计算频率占空比
循环进入位置一
两个通道需要交替进行捕获，否则由于一个TIM只有一个CNT计数器，第一个上升沿清零会混乱
这就需要另一个定时器计时分配捕获时间
if(capture_time&gt;=100)//100ms
{
if(TIM_CaptureNumber==2)
TIM_CaptureNumber=3;／／通道三捕获
else if(TIM_CaptureNumber==3)
TIM_CaptureNumber=2;
capture_time=0;／／通道二捕获
} 下面以TIM2的CH2、CH3通道演示 初始化代码 __IO uint16_t IIM2_CH2ReadValue1 = 0, IIM2_CH2ReadValue2 = 0, IIM2_CH3ReadValue1 = 0, IIM2_CH3ReadValue2 = 0; __IO uint16_t IIM2_CH2CaptureNumber = 0,IIM2_CH3CaptureNumber=0; __IO uint32_t IIM2_CH2Freq = 0,IIM2_CH3Freq=0; u8 TIM_CaptureNumber=2; //__IO uint32_t Capture = 0; //__IO uint32_t TIM2Freq = 0; float TIM2_Duty2; float TIM2_Duty3; void pwm2_capture_init(void) { TIM_ICInitTypeDef TIM_ICInitStructure; GPIO_InitTypeDef GPIO_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; /* Enable the TIM2 global Interrupt */ NVIC_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a86a94f7c2da1b49284fb0f02512fe6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bd0ab21d754a99e62032cd4c74ec297/" rel="bookmark">
			GITHUB无法打开与下载失败解决方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学SNICAR模式，去GITHUB下源码，学校网速感人加上IP限制，折腾近一个小时才完成，网上文章太多，自己总结一下。
下载单个文件 通常下载提供都是整个项目下载，但对于过大项目，下载其中几个就够了，网上的方法花里胡哨，其实有很简单的方法。
点进我们要单个下载的项目，比如这里我想先下nicarAD_v3.m 和 snicarAD_v3_drv.m 源文件研究一下。
我们点进相应文件，看到右上角的raw，右键，点击将链接另存为即可。
GITHUB无法打开与下载失败 由于DMS解析的IP无法访问造成，我们需要根据所在的地区，github.com解析的ip地址是多少，然后配置到hosts文件。
然而IP地址经常更换，为此，有程序员做出GITHUB520项目，给出了全部的IP地址，按照描述操作即可。
关于window下如何修改hosts文件：
打开CMD，以管理身份运行，输入notepad，打开记事本。
随后，文件→打开→C:\Windows\System32\drivers\etc\→选择所有文件→打开hosts。
在hosts最后加上项目作者给的IP地址就好啦，如下图：
记得激活生效，刷新一下DMS，然后关闭浏览器，重新进去就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb1106d50b1f7b5af899dc74d872e6a2/" rel="bookmark">
			NameNode和Secondary NameNode工作机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 工作机制 第一阶段：NameNode启动 第一次启动NameNode格式化后，创建Fsimage文件和Edits日志；如果不是第一次启动，直接加载Fsimage和Edits文件到内存客户端对元数据进行增删改的请求NameNode记录操作日志，更新滚动日志NameNode在内存中对数据进行增删改 第二阶段：Secondary NameNode工作 Secondary NameNode询问NameNode是否需要checkpoint，直接带回NameNode的询问结果Secondary NameNode请求执行checkpointNameNode滚动正在写的Edits日志将滚动前的Edits日志和Fsimage文件都由到Secondary NameNodeSecondary NameNode加载Edits日志和镜像文件到内存，执行合并生成新的镜像文件fsimage.chkpoint拷贝fsimage.chkpoint到NameNodeNameNode将fsimage.chkpoint重新命名成fsimage 工作机制详解：
Fsimage：NameNode内存中元数据序列化后形成的文件Edits：记录客户端更新元数据信息的每一步操作（可通过Edits运算出元数据） NameNode启动时，先滚动Edits并生成一个空的edits.inprogress，然后加载Edits和Fsimage到内存中，此时NameNode内存就持有最新的元数据信息。Client开始对NameNode发送元数据的增删改的请求，这些请求的操作首先会被记录到edits.inprogress中（查询元数据的操作不会被记录），如果此时NameNode挂掉，重启后会从Edits中读取元数据的信息，然后NameNode会在内存中执行元数据的增删改的操作。
由于Edits中记录的操作会越来越多，Edits文件会越来越大，导致NameNode在启动加载Edits时会很慢，所以需要对Edits和Fsimage进行合并（所谓合并，就是将Edits和Fsimage加载到内存中，照着Edits中的操作一步步执行，最终形成新的Fsimage）。Secondary NameNode的作用就是帮助NameNode进行Edits和Fsimage的合并工作。
Secondary NameNode首先会询问NameNode是否需要checkpoint（触发Checkpoint需要满足两个条件中的任意一个：定时时间和Edits中数据写满了），直接带回检查结果。Secondary NameNode执行Checkpoint操作，首先会让NameNode滚动Edits并生成一个空的edits.inprogress，滚动的目的是给Edits打个标记，以后所有新的操作都写入edits.inprogress，其它未合并的Edits和Fsimage会拷贝到Secondary NameNode的本地，然后将拷贝的Edits和Fsimage加载到内存中进行合并，生成fsimage.chkpoint，然后将fsimage.chkpoint拷贝给NameNode，NameNode将fsimage.chkpoint重命名为Fsimage后替换掉原来的Fsimage。NameNode在启动时就只需要加载之前未合并的Edits和Fsimage即可有，因为合并过的Edits中的元数据信息已经被记录在Fsimage中。
2 Fsimage和Edits概念 NameNode被格式化之后，将在/opt/module/hadoop-2.x.x/data/tmp/dfs/name/current目录中产生如下文件
fsimage_000000000000000
fsimage_000000000000000.md5
seen_txid
VERSION
Fsimage文件：HDFS文件系统元数据的一个永久性的检查点，其中包含HDFS文件系统的所有目录和idnode的序列化信息Edtis日志：存储HDFS文件系统的所有更新操作的路径，文件系统客户端执行的所有写操作首先会被记录到Edits文件中seen_txid文件保存的是一个数字，就是最后一个edits_的数据每次NameNode启动的时候都会将Fsimage文件读入内存，加载Edits里面的更新操作，保证内存中的元数据信息是最新的、同步的，可以看成NameNode启动的时候就将Fsimage和Edits文件进行了合并 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/790f0600fd3ef6d02f746c7abfa5c16c/" rel="bookmark">
			刷到 LeetCode 这个评论，被笑到了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是吴师兄。
今天早上我在 LeetCode 第 141 号问题 环形链表 的评论区中发现了一个称得上是天秀的解法，简直太骚气了，忍不住分享给大家。
首先给没有见过这道题目的小伙伴补充一下前置知识， 环形链表这道题目讲的是给你一个链表的头节点 head ，判断链表中是否有环。
所谓链表有环，直观上来看就是这个样子：
严谨一些的说明指的是如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。
一般正经解法是使用快慢指针的思路，即在开头设置两个指针，一个跑的快，一个跑的慢，如果两个指针再次重新相遇，那么就说明有环。
这个思路挺好理解的，在一个环形操场上，跑的快的人总是能和跑的慢的人再次相遇。
但是这个评论区的小伙伴面向测试用例编程，给出了如下的代码：
public class Solution { public boolean hasCycle(ListNode head) { int count = 8029; while( head != null &amp;&amp; count &gt; 0){ head = head.next; count--; } if( head == null ) return false; return true; } } 上述代码的含义是从链表的头节点，沿着链表不断地向后移动，移动 8029 次后，如果此时指向的是空，说明链表是一条直线不存在环，反之存在环。
很合理的思路！
如果一个链表的长度小于 8029，当它没有环时，不需要移动 8029 次就会来到尾部指向 null；当它存在环时，那么会在这个环中绕圈圈，最终移动 8029 次后指向一个存在值的节点。
提交一下代码，报错！
点击查看全部，发现最后一个测试用例链表的长度扩充到了 10000 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/790f0600fd3ef6d02f746c7abfa5c16c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ade687cd9884227de0d034523f20541/" rel="bookmark">
			Spring事务回滚和异常类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、异常的一些基本知识 异常的架构
异常的继承结构：Throwable为基类，Error和Exception继承Throwable。Error和RuntimeException及其子类成为未检查异常（unchecked），其它异常成为已检查异常（checked）。
Error异常 Error表示程序在运行期间出现了十分严重、不可恢复的错误，在这种情况下应用程序只能中止运行，例如JAVA 虚拟机出现错误。Error是一种unchecked Exception，编译器不会检查Error是否被处理，在程序中不用捕获Error类型的异常。一般情况下，在程序中也不应该抛出Error类型的异常。
RuntimeException异常 Exception异常包括RuntimeException异常和其他非RuntimeException的异常。
RuntimeException 是一种Unchecked Exception，即表示编译器不会检查程序是否对RuntimeException作了处理，在程序中不必捕获RuntimException类型的异常，也不必在方法体声明抛出　RuntimeException类。RuntimeException发生的时候，表示程序中出现了编程错误，所以应该找出错误修改程序，而不是去捕获RuntimeException。
Checked Exception异常 Checked Exception异常，这也是在编程中使用最多的Exception，所有继承自Exception并且不是RuntimeException的异常都是checked Exception，上图中的IOException和ClassNotFoundException。JAVA 语言规定必须对checked Exception作处理，编译器会对此作检查，要么在方法体中声明抛出checked Exception，要么使用catch语句捕获checked Exception进行处理，不然不能通过编译。
**
2、spring事务以及配置 spring事务的默认配置 Spring的事务管理默认是针对unchecked exception回滚，也就是默认对Error异常和RuntimeException异常以及其子类进行事务回滚，且必须抛出异常，若使用try-catch对其异常捕获则不会进行回滚！（Error异常和RuntimeException异常抛出时不需要方法调用throws或try-catch语句）；
checked异常,checked异常必须由try-catch语句包含或者由方法throws抛出，且事务默认对checked异常不进行回滚。
spring事务回滚异常的修改
a、注解方式。 @javax.transaction.Transactional 和 @org.springframework.transaction.annotation.Transactional 相似，均可使用。
rollbackFor定义的是需要回滚的异常，noRollbackFor定义的是不需要回滚的异常。（默认情况下对Error和RuntimeException及其子类进行回滚）
@Transactional(rollbackFor=MyException.class,noRollbackFor=OtherException.class)
public void updateUser(User user){
dao.update(user);
} b、配置方式。 定义时声明类的全限定名
注：若rollbackFor和noRollbackFor配置的类相同，则出现对应异常会进行回滚
c、若需要自行捕获异常进行处理，则使用 TransactionAspectSupport.currentTransactionStatus().setRollbackOnly() 语句进行手动回滚。
@Transactional(rollbackFor=MyException.class,noRollbackFor=RuntimeException.class) public void updateUser(User user){ try{ dao.update(user); }catch(MyException e){ //------//其他操作 TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();//捕获异常后进行回滚 } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f9d5d8e2fe1b3b2731641cde0d38c9e/" rel="bookmark">
			Spring AOP来自定义注解实现审计或日志记录（完整代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境准备 JDK 1.8，Springboot 2.1.3.RELEASE，spring-boot-starter-aop.2.1.4.RELEASE.jar，aspectjrt.1.9.2.jar，aspectjweaver.1.9.2.jar，pom依赖如下：
&lt;!-- 添加aspectj --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt; &lt;/dependency&gt; 项目结构 自定义审计注解 package com.cjia.common.annotation; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(value = RetentionPolicy.RUNTIME) @Target(value = { ElementType.METHOD }) public @interface Audit { /** * 模块代码 */ int moudleCode() default -1; /** * 扩展信息，用户返回操作类型及参数 */ Class&lt;?&gt; extension(); } 定义切面类 package com.cjia.common.aspect; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f9d5d8e2fe1b3b2731641cde0d38c9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99346932525cb3d93d4b7b8f37551af6/" rel="bookmark">
			【特征选择】基于粒子群算法实现二进制特征选择问题附matlab代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 简介 摘要：特征选择是数据挖掘和机器学习等领域的重要研究方向。客观条件的限制，特征选择比较复杂且很难找到最关键的特征集合，导致分类精确度不高、分类器制作困难。开展分组特征选择算法的研究具有较高的理论意义和实用价值。　本文分析研究了支持向量机、Relief算法、SVM-RFE算法、粒子群算法和离散型粒子群算法，在此基础上对离散型粒子群算法进行了改进，对比实验表明，改进后的算法能够更好地找到特征之间的组结构，同时每个组中特征之间也有很强的相关性。提出基于特征子集相关性的分组特征选择算法，该算法首先运用线性支持向量机获取到数据属性的特征系数，据之建立用于特征分组的评价模型，然后对每个组内的特征距离进行优化，使得组内的距离尽可能小，进而找到特征之间的组结构，最后从每个组结构中挑选出代表特征组成特征子集。结果表明，本算法的分类精确度明显高于典型的特征选择算法。提出了基于特征子集差异性的分组特征选择算法，该算法首先利用特征权重系数构建分组矩阵，找到最优分组结构，然后对组间距离进行优化，使得每个组中的特征与其他各组中特征的距离和最大。在标准数据集上对本算法和基于特征子集相关性的分组特征选择算法进行对比测试，实验结果表明，本算法在特征选择和分类上的性能上更优。
BPSO 算法是 Kennedy 于 1997 年在连续性 PSO算法基础上提出的，用于解决离散的优化问题[26]。BPSO算法通过模拟鸟类飞行觅食过程，种群中每个粒子相当于解空间中的一个解，粒子具有速度和位置两个属性，位置向量表示该粒子对应的解，速度向量则是为了调整粒子下一次飞行，从而进行位置更新搜索新的解集。粒子飞行过程中根据自己的历史飞行经验和种群中其他粒子的飞行经验调整自身的飞行方向和速度。其中，每个粒子历史飞行过程中的最优位置称为个体最优解 pbest ，整个种群在历史飞行过程中所经过的最好位置为 gbest ，称为全局最优解[26]，粒子之间通过 pbest、gbest 共享信息，从而在进化过程中影响种群的搜索行为。
2 部分代码 %-------------------------------------------------------------------------%% Binary Particle Swarm Optimization (BPSO) source codes demo version %clc, clear, close % Benchmark data set contains 351 instances and 34 features (binary class)load ionosphere.mat; % Matlab also provides this dataset (load Ionosphere.mat)% Call features &amp; labelsfeat=f; label=l; %---Input------------------------------------------------------------------% feat: feature vector (instances x features)% label: labelling% N: Number of particles% T: Maximum number of iterations% c1: Cognitive factor% c2: Social factor% Vmax: Maximum velocity% Wmax: Maximum bound on inertia weight% Wmin: Minimum bound on inertia weight% *Note: k-value of KNN &amp; k-fold setting can be modified in jFitnessFunction.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99346932525cb3d93d4b7b8f37551af6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40f67cc249031237415fe5682f8ba9a8/" rel="bookmark">
			C语言编写通讯录系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天交了一个用C写的通讯录系统，自以为还行，但老师无视我的设计🙀🙀，只给我89（主要是90多的一大堆，代码还都比我垃圾） （大一初学C）
下面是我的代码🐵🐵🐵
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;windows.h&gt; typedef struct person { char name[20]; //姓名 char sex[10]; //性别 char num[20]; //手机号 char QQ[20]; //QQ号 char email[20]; //邮箱 char address[50]; //地址 char relation[20]; //分组 char remarks[20]; //备注 } PER; int menu(); //菜单 void add_person(PER arr[],int *nPtr); //添加l联系人函数 void InputPerson(PER arr[],int i); //添加一个联系人 void OutPerson(PER arr[],int i); //输出一个联系人 int print_person(PER arr[],int n); //输出联系人 int FindByName(PER arr[],int n,char *str); //按姓名查找位置 int FindByNum(PER arr[],int n,char *str); //按电话号查找位置 void delete_person(PER arr[],int *nPtr); //删除联系人 void modify_person(PER arr[],int n); //修改联系人 void search_person_name(PER arr[],int n); //按名字查找联系人 void search_person_num(PER arr[],int n); //按号码查找联系人 void search_person_relation();//按分组查找联系人 void save_file(PER arr[],int n); //将数据保存到磁盘 void load_file(PER arr[],int *nPtr); //添加顺序文件加载到数组per void load_file_Name(PER arr[],int *nPtr); //姓名顺序文件加载到数组Name_per void load_file_Num(PER arr[],int *nPtr); //号码顺序文件加载到数组Num_per void sort_person_name(); //按姓名显示 void sort_person_num(); //按号码显示 void show_person(PER arr[],int n); //显示所有联系人 int main() { system("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40f67cc249031237415fe5682f8ba9a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80172aa2a1723322934cfd92d46e8f8a/" rel="bookmark">
			HTTP协议-报文解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 HTTP（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式。
HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息的组成：
开始行（对于请求消息，开始行就是请求行；对于响应消息，开始行就是状态行）消息报头（可选）空行（只有CRLF的行）消息正文（可选）组成。 一、请求报文 http请求由四部分组成：
请求行消息报头/请求头空行请求正文 1.1 请求行 Method Request-URI HTTP/Version CRLF
(1) Method HTTP请求方法
请求方法描述GET请求获取Request-URI所标识的资源POST在Request-URI所标识的资源后附加新的数据HEAD请求获取由Request-URI所标识的资源的响应消息报头PUT请求服务器存储一个资源，并用Request-URI作为其标识DELETE请求服务器删除Request-URI所标识的资源TRACE请求服务器回送收到的请求信息，主要用于测试或诊断CONNECTHTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器OPTIONS请求查询服务器的性能，或者查询与资源相关的选项和需求 (2) Request-URI URI完整地指定了要访问的网络资源，通常只要给出相对于服务器的根目录的相对目录即可，因此总是以“/”开头
(3) HTTP/Version 协议/版本
1.2 请求头 Accept、Accept-Charset、Accept-Encoding、Accept-Language、Authorization、Host、User-Agent等。
1.3 请求正文 请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。
二、响应报文 http响应由四部分组成：
状态行消息报头/响应头空行响应正文 2.1 状态行 HTTP/Version Status-Code Reason-Phrase CRLF
(1) HTTP/Version 协议/版本
(2) Status-Code Reason-Phrase HTTP状态码
状态码分类描述1xx指示信息–表示请求已接收，继续处理2xx成功–表示请求已被成功接收、理解、接受3xx重定向–要完成请求必须进行更进一步的操作4xx客户端错误–请求有语法错误或请求无法实现5xx服务器端错误–服务器未能实现合法的请求 状态码列表描述200 OK客户端请求成功400 Bad Request客户端请求有语法错误，不能被服务器所理解401 Unauthorized请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden404 Not Found请求资源不存在，eg：输入了错误的URL500 Internal Server Error服务器发生不可预期的错误503 Server Unavailable服务器当前不能处理客户端的请求，一段时间后可能恢复正常 2.2 响应头 Location、Server、WWW-Authenticate等
2.3 响应正文 响应头和响应正文之间是一个空行，这个行非常重要，它表示响应头已经结束，接下来的是响应正文。
三、消息报头 包括普通报头、请求报头、响应报头、实体报头。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80172aa2a1723322934cfd92d46e8f8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8f67b4c021f16ebfd8fbbfe4e727b48/" rel="bookmark">
			vue 实时获取当前年月日时间星期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在data中定义一个变量，存储时间
data(){ return { nowTime:'' } }, 2.给定一个div
&lt;div&gt;{{nowTime}}&lt;/div&gt; 3.js部分 调用nowTimes
//显示当前时间（年月日时分秒） timeFormate(timeStamp) { let year = new Date(timeStamp).getFullYear(); let month =new Date(timeStamp).getMonth() + 1 &lt; 10? "0" + (new Date(timeStamp).getMonth() + 1): new Date(timeStamp).getMonth() + 1; let date =new Date(timeStamp).getDate() &lt; 10? "0" + new Date(timeStamp).getDate(): new Date(timeStamp).getDate(); let hh =new Date(timeStamp).getHours() &lt; 10? "0" + new Date(timeStamp).getHours(): new Date(timeStamp).getHours(); let mm =new Date(timeStamp).getMinutes() &lt; 10? "0" + new Date(timeStamp).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8f67b4c021f16ebfd8fbbfe4e727b48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/175faecf14051dc75e98856bfb6e9cc0/" rel="bookmark">
			配备Apple T2 安全芯片的 Mac 机型及T2芯片mac电脑U盘装系统教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		T2 芯片为 Mac 提供了一系列功能，例如加密储存和安全启动功能、增强的图像信号处理功能，以及适用于触控 ID 数据的安全保护功能。哪些电脑配备了 T2 安全芯片呢，T2芯片mac电脑又如何重装系统呢？跟随小编一起来看看吧！
配备 Apple T2 安全芯片的电脑
下列 Mac 配备 Apple T2 安全芯片：
iMac（视网膜 5K 显示屏，27 英寸，2020 年）
iMac Pro
Mac Pro（2019 年）
Mac Pro（机架式机型，2019 年）
Mac mini（2018 年）
MacBook Air（视网膜显示屏，13 英寸，2020 年）
MacBook Air（视网膜显示屏，13 英寸，2019 年）
MacBook Air（视网膜显示屏，13 英寸，2018 年）
MacBook Pro（13 英寸，2020 年，两个雷雳 3 端口）
MacBook Pro（13 英寸，2020 年，四个雷雳 3 端口）
MacBook Pro（16 英寸，2019 年）
MacBook Pro（13 英寸，2019 年，两个雷雳 3 端口）
MacBook Pro（15 英寸，2019 年）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/175faecf14051dc75e98856bfb6e9cc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41279c937e7f18c9a7c6829d8dd0981f/" rel="bookmark">
			Jmeter监控服务器性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要讲的是jmeter通过插件去监控服务器的性能参数,来帮助我们分析系统性能.
也可以通过prometheus去监控:docker+jmeter+prometheus+grafana入门实战,需要的可以自行去查看哦!
1.下载需要的Jmeter插件 jmeter监控服务器的性能参数,如CPU、内存、IO等,都是需要去下载插件的.
JMeterPlugins-Extras-1.4.0.zip和JMeterPlugins-Standard-1.4.0.zip可以在此链接中下载:https://jmeter-plugins.org/downloads/old
ServerAgent-2.2.3可以在下面链接中自取
链接：https://pan.baidu.com/s/1lC_HlGfOgPNvIbRjK9Kltg
提取码：6s7z
2.配置jmeter 把两个插件解压,拿到里面的.jar文件放在你的jmeter的安装目录的\lib\ext下
重启你的jmeter,如果能看到图片中的内容说明配置成功了
3.将监控服务器的ServerAgent拷贝到需监测的服务器 这里我是用工具(MobaXterm)直接把文件拖上自己的云服务的,下面讲弄上云服务后的操作:
# 进入ServerAgent目录中 cd ServerAgent-2.2.3/ # 给startAgent.sh设置权限 chmod 777 startAgent.sh # 执行./startAgent.sh文件 ./startAgent.sh 注意:
1.如果你的4444端口被占用了这里就不会成功哦,你需要关闭占用的4444端口
2.因为我用的是阿里云,所以需要在阿里云后台配置安全组,把4444端口开放出来,不然无法实现监听,其他云服务同理
4.安装的组件介绍 jp@gc - Bytes Throughput Over Time:不同时间吞吐量展示（图表）
聚合报告里，Throughput是按请求个数来展示的，比如说1.9/sec，就是每s发送1.9个请求；而这里的展示是按字节Bytes来展示的图表jp@gc - Composite Graph： 混合图表
在它的Graphs里面可以设置多少个图表一起展示，它可以同时展示多个图表jp@gc - Hits per Second：每秒点击量jp@gc - PerfMon Metrics Collector：服务器性能监测控件，包括CPU，Memory，Network，I/O等等jp@gc - Reponse Latencies Over Time：记录客户端发送请求完成后，服务器端返回请求之前这段时间jp@gc - Reponse Times Distribution： 显示测试的响应时间分布，X轴显示由时间间隔分组的响应时间，Y轴包含每个区间的样本数jp@gc - Transactions per Second： 每秒事务数，服务器每秒处理的事务数jp@gc - Reponse Times vs Threads：展示事务响应时间与虚拟用户数之前的对应关系 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41279c937e7f18c9a7c6829d8dd0981f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54955e2c45fc5587751295a790192651/" rel="bookmark">
			vue Syntax Error Error PostCSS plugin postcss-pxtorem requires PostCSS 8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue Syntax Error: Error: PostCSS plugin postcss-pxtorem requires PostCSS 8. Migration guide for end-users: 关于脚手架生成项目,配置自适应postcss-pxtorem配置报错
首先你在.postcssrc.js文件正常配置(详细配置)
module.exports = { plugins: { // 兼容浏览器，添加前缀 autoprefixer: { overrideBrowserslist: [ "Android 4.1", "iOS 7.1", "Chrome &gt; 31", "ff &gt; 31", "ie &gt;= 8", "last 10 versions", // 所有主流浏览器最近10版本用 ], grid: true, }, "postcss-pxtorem": { rootValue: 37.5, //结果为：设计稿元素尺寸/16，比如元素宽320px,最终页面会换算成 20rem propList: ["*"], //是一个存储哪些将被转换的属性列表，这里设置为['*']全部，假设需要仅对边框进行设置，可以写['*', '!border*'] unitPrecision: 5, //保留rem小数点多少位 //selectorBlackList: ['.radius'], //则是一个对css选择器进行过滤的数组，比如你设置为['fs']，那例如fs-xl类名，里面有关px的样式将不被转换，这里也支持正则写法。 replace: true, //这个真不知到干嘛用的。有知道的告诉我一下 mediaQuery: false, //媒体查询( @media screen 之类的)中不生效 minPixelValue: 12, //px小于12的不会被转换 }, }, }; 也可以这样(简单一点)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54955e2c45fc5587751295a790192651/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef903ba0389d75d6a0587fbc2ff979ee/" rel="bookmark">
			如何修改vant中DropdownMenu组件选中后的样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们想要实现如下效果：选中下拉选项中的某一项后想让选中项的字体变色。
vant组件中只有选择过程中效果：
但选中之后字体又变成黑色呢。如何设置成想要的颜色呢？
我们发现这里有个title-class,标题额外类名。
同时我们可以通过审查元素发现vant中选中后多了下面的.van-dropdown-item__option–active类：
所以我们这里有一个很好的实现思路：
将title-class设置为van-dropdown-item__option–active。同时用一个变量控制是否为van-dropdown-item__option–active or “”(空的)。使用常用的三目运算就可以实现。
注：若有多个分组，如有区域、美食类型等等，我们可以分别给每项绑定不同的变量来控制是否使用van-dropdown-item__option–active类。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f477a694c483549aadbf87155feddce4/" rel="bookmark">
			Python grid布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 使⽤ grid 布局的时候,我们使⽤ grid 函数,在⾥⾯指 定两个参数,⽤ row 表示⾏，⽤ column 表示列，注意的是 row 和 column 的编号都从 0 开始。
2. grid 函数还有个 sticky 参数,它可以⽤ N,S,W,E 表示 上,下,左,右 , 它决定了这个组件是从哪个⽅向开始的。
3. grid 布局直接⽤后⾯的⾏和列的数字来指定了它位于哪个位置,⽽不必使⽤其他参数。
4. grid 函数也⽀持诸如 ipadx,ipady,padx,pady ,它们的意思和 pack 函数是⼀样的,默认边距是 0。
5. 它还⽀持参数⽐如 rowspan ,表示跨越的⾏数, columnspan 表示跨越的列数
测试代码如下：
from tkinterimport *
window = Tk()
window.title(“grid 布局测试”)
Label(window, text=“Name:”).grid(row=0, sticky=W)
Entry(window).grid(row=0, column=1, sticky=E)
Label(window, text=“Password:”).grid(row=1, sticky=W)
Entry(window).grid(row=1, column=1, sticky=E)
Button(window, text=“Login”).grid(row=2, column=1, sticky=E)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f477a694c483549aadbf87155feddce4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d363a9e252b0c68146dd67815d9115cb/" rel="bookmark">
			IDEA开发工具的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载完成之后，开始安装。
安装路径不能有中文和空格。
这里是免费试用
建立项目：
建立模块：
关联JDK，一般自带，如果没有自带，就要手动选择。
然后为模块命名。
然后建包
一般是用域名，并且是倒着写，最好用英文小写。
然后在包里面建一个类
直接输入 main 回车就会自动补全
直接输入 System 回车，又可以自动补全。
编译，直接右键运行
总结：
IDEA字体、主题、背景色设置
背景色：
护眼的颜色 豆沙绿
IDEA常用快捷键
删除类文件
修改类文件名
修改模块
选第三个 模块名和磁盘名一起改。
导入模块
关联导入：缺点是一旦关联的模块删除，就无法打开。
在黑点的地方导入，不能直接选择主目录
以下方法导入模块不会丢失
此模块就放在工程下面
然后回到需要导入的模块
直接ctrl+C 拷贝
然后回到模块，Ctrl+V粘贴
删除模块
此方法只是在界面删除，不是真正的删除，文件还是没有删除。
彻底删除，直接到工程目录下，直接删除。
这样也可以真正的删除，然后重新启动IDEA
打开工程
工程，可以直接关闭IDEA，或者右键关闭。
本文通过B站“黑马程序员”所发布的JAVA视频学习记录的笔记，不作为任何商业行为，仅作为知识分享。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b8dc1871d61f2c5f9469b0b574097b/" rel="bookmark">
			Silane-PEG-NHS，SIL-PEG-NHS，可以用来修饰蛋白质、多肽以及其他活性基团，NHS-PEG-Silane
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 英文名称：Silane-PEG-NHS
中文名称：硅烷-聚乙二醇-活性酯
分子量：1k，2k，3.4k，5k，10k，20k（可按需定制）
质量控制：95%+
存储条件：-20°C，避光，避湿
用 途：仅供科研实验使用，不用于诊治
外观: 固体或粘性液体，取决于分子量
注意事项：取用一定要干燥，避免频繁的溶解和冻干
溶解性：溶于大部分有机溶剂，如：DCM、DMF、DMSO、THF等等。在水中有很好的溶解性
取用：现配现用，将包装从冰箱中取出，置于干燥器中缓慢升至室温，打开瓶盖，取用。取用后充入惰性气体，封口膜封口，拧紧瓶盖装入自封袋，及时放入冰箱。
供应商：西安凯新生物科技有限公司
结构式：
Silane-PEG-NHS是硅烷偶联剂（PEG衍生物）的一种，他可以和无机材料(玻璃、金属、SiO2)等发生偶联反应。通过使用硅烷偶联剂，可在无机物质和有机物质的界面之间架起“分子桥”，把两种性质悬殊的材料连接在一起提高复合材料的性能和增加粘接强度的作用。硅烷偶联剂的这一特性早应用于玻璃纤维增强塑料（玻璃钢）上，作玻璃纤维的表面处理剂，使玻璃钢的机械性能、电学性能和抗老化性能得到很大的提高。活性酯（NHS）PH7-8.5与伯胺基团反应形成稳定的酰胺键。通过PEG连接的硅烷偶联剂具有很好的水溶性。
硅烷PEG活性酯（SILANE -PEG-NHS）可以用来修饰蛋白质、多肽以及其他活性基团材料或者小分子。活性酯(-NHS)能与氨基（-NH2）反应的PEG衍生物，在PH7-8.5与伯胺基团反应形成稳定的酰胺键。聚乙二醇(-PEG-)可以增加溶解度和稳定性。减少多肽和蛋白质的***原性，它也能抑制带电分子在修饰表面的非特异性结合。
技术指标：
纯度（PEG）：95%以上
取代率（NHS）：95%以上
取代率（SILANE）：95%以上
分散系数（PDI）：小于等于1.05
分析：COA、GPC、NMR、MALDI-TOF
其他相关产品：
AC-PEG-Silane,MW 1k
AC-PEG-Silane,MW 2k
AC-PEG-Silane,MW 3.4k
AC-PEG-Silane,MW 5k
AC-PEG-Silane,MW 10k
mPEG-Silane,MW 5k
mPEG-Silane,MW 2k
mPEG-Silane,MW 1k
mPEG-Silane,MW 30k
mPEG-Silane,MW 20k
MAL-PEG-Silane,MW 1k
MAL-PEG-Silane,MW 2k
MAL-PEG-Silane,MW 3.4k
MAL-PEG-Silane,MW 5k
MAL-PEG-Silane,MW 10k
以上信息由西安凯新生物科技有限公司为您提供，如需了解详细信息请联系！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49e1d3901b427b4ee4d25a66e692acdc/" rel="bookmark">
			DruidDatasource取消失败后无限重试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 DruidDatasource默认是无限自动重试，可能导致程序卡死。
处理方式如下：
DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setUrl(jdbcUrl); druidDataSource.setUsername(username); druidDataSource.setPassword(password); // 失败后重连的次数 druidDataSource.setConnectionErrorRetryAttempts(3); // 请求失败之后中断 druidDataSource.setBreakAfterAcquireFailure(true); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f20ff7f034eff42bc12493bae20b0330/" rel="bookmark">
			移动端布局(一)dp、dip、PPI、dpr、图片模糊
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注: 此篇文章引用多篇文章，在文章的结尾处有注明文章的来源
高清屏 即高清屏,把更多的像素压缩至一块屏幕里，从而达到更高分辨率显示的细腻程度，使人眼无法分辨出单个的像素。
物理像素(dp) 物理像素，设备的硬件像素，生产出来就已经设定好了的真实像素，不能被改变。是计算机屏幕渲染画面(图像)的最小单位，整个图像是由像素单位组成的，这个单位的形状通常都是会发光的正方形方格，
在相同尺寸屏幕中，像素点越多，像素点就越小就越清晰(因为你在该屏幕内容纳更多的像素，像素点自然会缩小)，像素点越少，像素点就越大，图像就不清晰，因为你都能看到像素点的锯齿状。
分辨率指的就是水平垂直方向上像素点的数量，比如1920*1080表示屏幕水平方向上有1920个像素点，垂直方向上有1080个像素点。
css像素 网页中，用于控制元素样式的像素，它也属于独立像素，浏览器在显示页面时，需要将css像素转为物理像素在呈现。
设备独立像素(dip) 也叫虚拟像素、逻辑像素，是我们程序软件里使用的像素，它是相对于物理像素来计算的，表示一个物理像素由多少个逻辑像素来表示，也就是说可以人为的定义让1个独立像素等于多少个物理像素。
注：在我们的浏览器中css像素就是独立像素
为什么要有设备独立像素呢?
在早期普通屏中，只有物理像素，没有独立像素，在不缩放的情况下，1个css像素就是1个物理像素，比如iphone3手机屏幕是320 * 480px的分辨率，那么width等于320px的元素是占满整个屏幕的。从iphone4开始苹果公司推出了高清屏，分辨率变成640 * 960px，也就是普通屏一个像素点有高清屏两个像素点那么大，因为相同尺寸的屏幕要放满640 * 960px的像素，只能是将像素点面积缩小1倍，如果还按照1物理像素就是1个css像素来渲染图像，那么width等于320px的元素只会占据屏幕宽度的一半，如何让iphone4和iphone3显示相同呢? 在开发中为了让不同设备上有一样的显示效果，就引入了独立像素，让网页中css像素成为独立像素，在iphone3中不变1个css像素就是1个物理像素，但是 在iphone4上，在不缩放的前提下，1个css像素等于2个物理像素，这样iphone4中width等于320px的元素等于640个物理像素，正好占满iphone4的宽度， font-size: 20px; 的字体在 iphone3 和 iphone4 上的尺寸也相同，只不过在 iphone4 上的字体更清楚。
还有一个因素会引起css中px的变化，那就是用户缩放。例如当用户把页面放大一倍，css像素不会变，但是css中1px所代表的物理像素也会增加一倍，反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。
该段文字引用于https://blog.csdn.net/weixin_30301449/article/details/96200494
设备像素比(DevicePixelRatio): DPR = (设备像素dp / 独立像素dip)*scale(表示缩放大小为百分之几)，物理像素和独立像素的比例，表示由一个物理像素由多少个css像素来表示。
在iphone4上dpr是2，但不是所有设备都是2，不同设备的dpr都是不同的。
下列展示了不通过设备物理像素和逻辑像素的关系。
像素密度(PPI): 表示每英寸面积内像素的数量(疏密程度),PPI是一个定值，是一个固定参数，PPI的值越高，表示在一定尺寸的屏幕上像素数量越多。
PPI的计算公式: 屏幕边的物理像素除以物理尺寸
图片模糊 同一张图片，在普通屏显示正常，但在高清屏出现模糊。原因是一个物理像素的点分成了四个像素的点进行显示。
1个位图像素是栅格图像(如：png, jpg, gif等)最小的数据单元。每一个位图像素都包含着一些自身的显示信息(如：显示位置，颜色值，透明度等)。理论上，1个位图像素对应于1个物理像素，图片才能得到完美清晰的展示。
1个位图像素对应于4个物理像素，由于单个位图像素不可以再进一步分割，所以只能就近取色，导致图片看起来比较模糊。
当1个位图像素占据少于1个物理像素(压缩图像)，图片就会锐化。
假设我有一张图片，图片素材尺寸为200 * 200的位图像素，我们设置css:width为200px,height为200px；在ipnone3上图片渲染为200px * 200px的位图像素是清晰的，但是在高清屏iphone4上图片渲染为400px * 400px，由于位图像素不能分裂，哪多出来的200像素怎么生成，于是只能使用线性插值算法，颜色近似选取(选择相似的颜色填充像素块)，于是图片就模糊了。
位图: 由多个像素点组成的点阵图像。
缩小图像(压缩图片):
称为下采样（subsampled）或降采样（downsampled）的主要目的是两个：
使得图像符合显示区域的大小；
生成对应图像的缩略图；
下采样的原理：
对于一幅图像尺寸为MN，对其进行s倍的下采样，即得到（M/s）（N/s）尺寸的分辨率图像，当然，s应该是M和N的公约数才可以，如果考虑是矩阵形式的图像，就是把原始图像s*s窗口内的图像变成一个像素，这个像素点就是窗口内所有像素的均值 Pk = (∑ Xi)/ S^2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f20ff7f034eff42bc12493bae20b0330/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/159/">«</a>
	<span class="pagination__item pagination__item--current">160/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/161/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>