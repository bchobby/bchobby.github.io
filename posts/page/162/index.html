<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/887a628a81e0d7c571a0e69a496ac7af/" rel="bookmark">
			阿里云木马检查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器挖矿木马[kthreaddi]处理记录 – 编程笔记
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96d6924fb9420420091a877c8455e0da/" rel="bookmark">
			PCL-PEG-MAL，聚己内酯-聚乙二醇-马来酰亚胺，Poly(ε-caprolactone)-PEG-Maleimide
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 英文名称：PCL-PEG-MAL
Poly(ε-caprolactone)-PEG-Maleimide
中文名称：聚己内酯-聚乙二醇-马来酰亚胺
分子量：1k，2k，3.4k，5k，10k，20k（可按需定制）
质量控制：95%+
存储条件：-20°C，避光，避湿
用 途：仅供科研实验使用，不用于诊治
外观: 固体或粘性液体，取决于分子量
注意事项：取用一定要干燥，避免频繁的溶解和冻干
溶解性：溶于大部分有机溶剂，如：DCM、DMF、DMSO、THF等等。在水中有很好的溶解性
取用：现配现用，将包装从冰箱中取出，置于干燥器中缓慢升至室温，打开瓶盖，取用。取用后充入惰性气体，封口膜封口，拧紧瓶盖装入自封袋，及时放入冰箱。
结构式：
PCL-PEG-MAL是一种功能性两亲嵌段共聚物，用于制备靶向胶束或纳米粒子。马来酰亚胺可与硫醇、巯基、巯基或巯基结合形成二硫键。
聚己内酯PEG马来酰亚胺（Biotin-PEG-MAL）可以用来修饰蛋白质、多肽以及其他活性基团材料或者小分子。马来酰亚胺(-MAL)马来酰亚胺和巯基在PH6.5-7.5很容易形成稳定的硫醚键。聚乙二醇可以增加溶解度和稳定性,减少多肽和蛋白质的***原性，它也能抑制带电分子在修饰表面的非特异性结合。
技术指标：
纯度（PEG）：95%以上
取代率（MAL）：90%以上
取代率（PCL）：90%以上
分散系数（PDI）：小于等于1.05
分析：COA、GPC、NMR、MALDI-TOF
其他相关产品：
mPEG-PCL, PEG MW:1000&amp;PCL MW:1000
mPEG-PCL, PEG MW:1000&amp;PCL MW:2000
mPEG-PCL, PEG MW:1000&amp;PCL MW:5000
mPEG-PCL, PEG MW:1000&amp;PCL MW:10000
mPEG-PLGA, PEG MW:1000&amp;PCL MW:1000
mPEG-PLGA, PEG MW:1000&amp;PCL MW:2000
mPEG-PLGA, PEG MW:1000&amp;PCL MW:5000
mPEG-PLGA, PEG MW:1000&amp;PCL MW:10000
PCL(1000)-PEG(1000)-PCL(1000)
PCL(2000)-PEG(1000)-PCL(2000)
PCL(5000)-PEG(1000)-PCL(5000)
以上信息由西安凯新生物科技有限公司为您提供，如需了解详细信息请联系！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0a15973a9001d7fc65c44d8d873e0c4/" rel="bookmark">
			拦不住灰犀牛，芯片短缺即将扭转，小型公司风险骤增！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信群消息，有人到处在各个群里推销芯片。舆论层面，芯片缺货似乎仍在继续，囤货似乎仍然是主流。为什么已经有人开始到处推销芯片了？因为他们已经预感到芯片供需拐点即将到来。
我们先来看看需求侧。
首先，疫情带来的电子产品需求已经结束。随着国外在奥密克戎变种之下，选择躺平，人员流动趋于自由。同时，电子产品该买已经买了，需求也已经得到了满足。在此条件下，芯片需求下降已经是趋势。
其次，由于疫情导致的经济下滑，人们的消费能力变弱。除了中国之外，世界绝大多数国家的经济增长为负值。人们手里的钱是变少而不是更多，同样导致芯片需求下降。
我们再来看看供给侧。
台积电是最早预感到芯片短缺的情况的公司。因此，台积电是最早开始筹备扩厂的公司。按照建厂到产能到位时间至少为18~24个月为例。预计今年年中新建产能就能到位。其他各大芯片厂，如中芯国际，格罗方德等公司，也纷纷扩张产能。产能扩张的时间窗口越来越近。
芯片短缺的原因，不仅在于需求侧，更在于供应链断链。疫情导致的港口拥堵，物流不畅，以及贸易战引发的恐慌，导致所有厂家选择囤货以及疯狂下单，这才是这次芯片短缺的罪魁祸首。一旦新的产能到位，由于囤货厂家担心手里的货物砸到手里，就会会选择降低库存。库存释放，产能扩张，两者共同作用之下，将会导致芯片供应迅速由短缺变为过剩。
我们再来看芯片股。以英特尔，英伟达为例，均已经从最高点连续下跌2个月，目前仍在下跌中。可以看出，资本已经意识到芯片股高峰已过，正在选择抽身。
如果芯片供应短缺现象扭转之后，最先受伤的必然是囤货最多的厂家。
当正常状况下，所有的厂家追求的是0库存。而现在，厂家囤货甚至高达一个月甚至一年的需求量。如此高的库存下，如果芯片转为供应过剩，必然损失惨重。
我们可以再设想，当芯片供应过剩情况下，小型公司以及创业公司的风险可能骤增。为何? 大厂的芯片可以足额供应，并且更有品质保证，更有足够的利润可以降价。作为客户，你会选择创业公司的芯片还是大厂的芯片？
而如果系统厂商如果由于市场萎缩，导致产品利润下降，那么他们是否有能力再养的起庞大的芯片团队？芯片人才的工资如今已是天价。
从某位投资经理处得到消息，目前很多资金对于投资芯片公司已经趋于保守。
有人在我列出成本后，打消了自研芯片的念头
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17862c040e9144fad31018e03f76deb7/" rel="bookmark">
			序列化和反序列化详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		凡事都要问为什么，在讲解序列化概念和原理前，我们先来了解一下为什么需要序列化。
为什么要序列化？ 如果光看定义我想你很难一下子理解序列化的意义，那么我们可以从另一个角度来感受一下什么是序列化。
都玩过游戏么？玩过的同学应该知道游戏里有一个叫『存档』的功能，每次不想玩的时候可以把当前进度存档，下次有时间想玩的时候，直接载入存档就可以接着玩了，这样的好处是之前的游戏进度不会丢失，要是每次打开都重新玩估计大家也没什么耐心了。
如果把面向对象的思想带到游戏的世界，那在我们眼中不管是游戏角色还是游戏中的怪兽、装备等等都可以看成是一个个对象：
角色对象（包含性别、等级、经验值、血量、伤害值、护甲值等属性）
怪兽对象（包含类型、血量、等级等等属性）
装备对象（包含类型、伤害值、附加值等等属性）
在玩游戏的过程中创建一个游戏角色就好像是创建了一个角色对象，拿到一套装备就好像创建了一个装备对象，路上遇到的怪兽等等也都是对象了。
我们再用计算机的思维去思考，创建的这些对象都是保存在内存中的，大家都知道内存的数据是短暂保留的，断电之后是会消失的，但是游戏经过手动存档之后就算你关机几天了，再次进入游戏读取存档，你会发现之前在游戏中创建的角色和装备都还在呢，这就很奇怪了，明明内存的数据断电就消失了，这是为什么？
稍加思考就知道，我们在存档的过程中就是将内存中的数据存储到电脑的硬盘中，硬盘的数据在关机断电后是不会丢失的（别杠，硬盘损坏数据丢失先不考虑）。这个过程就是对象的持久化，也就是我们今天要讲的对象序列化。对象的序列化逆过程就叫做反序列化，反序列化也很好理解就是将硬盘中的信息读取出来形成对象。
什么是序列化？ 前面引入游戏的例子是为了让大家生动地理解什么是序列化和反序列化。简单总结一下就是：
序列化是指将对象实例的状态存到存储媒体的过程
反序列化是指将存储在存储媒体中的对象状态装换成对象的过程
用更为抽象的概念来讲：
序列化：把对象转化为可传输的字节序列过程
反序列化：把字节序列还原为对象的过程
序列化的机制 序列化最终的目的是为了对象可以跨平台存储和进行网络传输，而我们进行跨平台存储和网络传输的方式就是 IO，而 IO 支持的数据格式就是字节数组。
那现在的问题就是如何把对象转换成字节数组？这个很好办，一般的编程语言都有这个能力，可以很容易将对象转成字节数组。
仔细一想，我们单方面的把对象转成字节数组还不行，因为没有规则的字节数组我们是没办法把对象的本来面目还原回来的，简单说就是将对象转成字节数组容易但是将字节数组还原成对象就难了，所以我们必须在把对象转成字节数组的时候就制定一种规则（序列化），那么我们从 IO 流里面读出数据的时候再以这种规则把对象还原回来（反序列化）。
还是拿上面游戏那个例子，我们将正在玩的游戏存档到硬盘，序列化就是将一个个角色对象和装备对象存储到硬盘，然后留下一张原来对象的结构图纸，反序列化就是将硬盘里一个个对象读出来照着图纸逐个还原恢复。
常见序列化的方式 序列化只是定义了拆解对象的具体规则，那这种规则肯定也是多种多样的，比如现在常见的序列化方式有：JDK 原生、JSON、ProtoBuf、Hessian、Kryo等。
（1）JDK 原生
作为一个成熟的编程语言，JDK自带了序列化方法。只需要类实现了Serializable接口，就可以通过ObjectOutputStream类将对象变成byte[]字节数组。
JDK 序列化会把对象类的描述信息和所有的属性以及继承的元数据都序列化为字节流，所以会导致生成的字节流相对比较大。
另外，这种序列化方式是 JDK 自带的，因此不支持跨语言。
简单总结一下：JDK 原生的序列化方式生成的字节流比较大，也不支持跨语言，因此在实际项目和框架中用的都比较少。
（2）ProtoBuf
谷歌推出的，是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于通信协议、数据存储等。序列化后体积小，一般用于对传输性能有较高要求的系统。
（4）Hessian
Hessian 是一个轻量级的二进制 web service 协议，主要用于传输二进制数据。
在传输数据前 Hessian 支持将对象序列化成二进制流，相对于 JDK 原生序列化，Hessian序列化之后体积更小，性能更优。
（5）Kryo
Kryo 是一个 Java 序列化框架，号称 Java 最快的序列化框架。Kryo 在序列化速度上很有优势，底层依赖于字节码生成机制。
由于只能限定在 JVM 语言上，所以 Kryo 不支持跨语言使用。
（6）JSON
上面讲的几种序列化方式都是直接将对象变成二进制，也就是byte[]字节数组，这些方式都可以叫二进制方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17862c040e9144fad31018e03f76deb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e66e9151dc52da5f403a3cd11db246b/" rel="bookmark">
			node-sass修改源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 node-sass修改源 yarn config set sass_binary_site https://mirrors.huaweicloud.com/node-sass/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20e361a2121bf0e57496204d3e116c3b/" rel="bookmark">
			Nacos客户端启动出现9848端口错误分析（非版本升级问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 很多人Nacos客户端启动时，会报错如下，提示9848端口连接超时。
我自己也搜了搜，很多文章都说是版本问题，把客户端升级2.0就好了，但是我发现很多人升级之后还是会报这个错，网上找了半天都是让升级版本，好吧，网上没答案，只能自己分析了。
二、分析源码 找到报错的地方 GrpcClient.serverCheck() 方法，然后打断点，重新启动，等执行完下面这一行，发现居然又不报错了，然后竟然启动成功了！
responseFuture.get(3000L, TimeUnit.MILLISECONDS);
反复试了几次，只要打断点就不报错，不打断点就报错。
仔细研究了下，requestBlockingStub.request 是非阻塞请求，请求后直接进入
responseFuture.get(3000L, TimeUnit.MILLISECONDS) 方法里，这方法是判断上面的请求响应是否回来，大家可以看下里面的逻辑，大体上就是3秒超时时间之内，会循环判断响应是否返回，如果超时没有返回就抛出异常了。
这就是为什么打了断点之后，就不报错了，打了断点无形中增加了超时时间，在判断超时方法之前，响应已经返回了，自然不会报错了。
三、是否启动成功 大多数人，启动时报错之后，项目仍然启动成功了，nocas服务列表也已经有了，但是看到报错心里还是有点疑惑，真的就没问题吗？我们再分析一下，找找源头，报错的方法serverCheck，是从哪里开始调用的
一步一步追，找到本类的 connectToServer 方法
继续找调用 connectToServer 方法的地方，定位到了RpcClient.class里的 start 方法
发现，里面调用 connectToServer 时，返回null（就是前面报错后返回null），会重试三次，一般第二次就会连接成功了，会打印出 Success to connect to server on start up
所以大家启动报错后要看下，报错日志下面是否有成功日志，有成功日志就表示正常，没有问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/431c30de31cce09c0af391846091d671/" rel="bookmark">
			前端培训：Vue3添加公共方法与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在vue3中是不会直接暴露vue对象给你使用了。前端培训所以不能想vue2那样直接在原型上挂载，那么该如何实现公共方法的挂载呢？下面以$axios方法为例，介绍vue3添加公共方法的三种方式。
第一种：使用 app.config.globalProperties 添加 import { createApp } from 'vue'
import axios from 'axios'
const app = createApp({
created() {
console.log(this.$axios)
}
})
app.config.globalProperties.$axios = axios
app.mount('#root')
在setup中访问（setup中没有this）
&lt;script setup&gt;
import {getCurrentInstance} from 'vue'
const { proxy } = getCurrentInstance();//获取公用方法proxy.$axios，或者use中方法
const {$axios}=proxy
console.log($axios)
&lt;/script&gt;
第二种：使用 app.mixin 添加 import { createApp} from 'vue'
import axios from 'axios'
const app = createApp({
created() {
console.log(this.$axios)
}
})
app.mixin({
methods: {
$axios: axios
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/431c30de31cce09c0af391846091d671/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac3a9a886f5e8425c84a19f0f2eb853f/" rel="bookmark">
			SpringBoot 后台权限框架搭建（一）—后台框架搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot 后台权限框架搭建（一）—后台框架搭建
SpringBoot后台权限管理系统（二)—前端工程搭建
SpringBoot后台权限管理系统（三)—权限模块
SpringBoot后台权限管理系统（四)—部署
项目简介 项目名称定义为mountain（山）, 主要实现后端权限管理系统，包括用户管理、 角色管理、部门管理、菜单管理等。项目采用前后端分离模式开发， 后端使用springboot+shiro+mybatis+MySQL等；前端选用Element UI框架， 直接基于vue-element-admin的基础上扩展开发。 项目源码下载地址
工程目录说明 集成jar包 集成 Springboot、Shiro、Mybatis、Druid等jar包 在pom.xml 文件中引用相对应的jar包 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.site&lt;/groupId&gt; &lt;artifactId&gt;mountain&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;mountain&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac3a9a886f5e8425c84a19f0f2eb853f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a802f7bb6e6e71f5907ff890ecd7c2b2/" rel="bookmark">
			程序设计天梯赛L3-3 (并查集模板，今天已经神志不清了)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目
题意: 给定n个人，每人有num个感兴趣的课程xi,1&lt;=i&lt;=num。所有有共同感兴趣课程的人为一个group。要求求出group的数量，并且按非升序输出他们的大小。n = 1000,num = 1000.
思路: 我寻思这不是并查集裸题，然后发现他这个课程的值域并不是从1到n.(它也确实不应该是从1到n)那我就不能通过fa[i] == i判断是不是一个真group主人还是课程没有出现。但是可以通过一种比较笨的方法，对于1到n每个人我们都去find一下他的父亲是谁，即可统计出对应group的大小。
另，维护并查集时需判断一下某个课程是否为第一次出现。
时间复杂度: O(n * m * α( n*m ))
代码:
#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;complex&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;unordered_map&gt; #include&lt;list&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;stack&gt; #define OldTomato ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr) #define fir(i,a,b) for(int i=a;i&lt;=b;++i) #define mem(a,x) memset(a,x,sizeof(a)) #define p_ priority_queue // round() 四舍五入 ceil() 向上取整 floor() 向下取整 // lower_bound(a.begin(),a.end(),tmp,greater&lt;ll&gt;()) 第一个小于等于的 // #define int long long //QAQ using namespace std; typedef complex&lt;double&gt; CP; typedef pair&lt;int,int&gt; PII; typedef long long ll; // typedef __int128 it; const double pi = acos(-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a802f7bb6e6e71f5907ff890ecd7c2b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f73546fce900cc2fafa5b215409f16/" rel="bookmark">
			ORA-01843:无效的月份解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题出现的根本原因：数据库安装时的语言与你要插入的数据的语言不一致
使用如下命令查看：
SELECT * FROM v$parameter WHERE name = 'nls_date_language';
修改语言：ALTER SESSION SET NLS_DATE_LANGUAGE='AMERICAN';
数据库的语言是简体中文(所以日期也是中文日期)，但是插入的日期是英文日期，所以提示月份无效。
解决方式：
new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(DateFormat.getDateTimeInstance().format(new Date())) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/311dee6a0b64afd048770a4e691e89b5/" rel="bookmark">
			IP地址的分类和规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每日分享：
你拼命奔跑的样子，终究会在风中留下痕迹！
文章目录 一、IP地址的格式二、私有IP地址三、IP地址分类：四、子网掩码五、IP地址的规划 一、IP地址的格式 1)、主机唯一的标识，保证主机间正常通信
2)、一种网络编码，用来确定网络中一个节点
3)、IP地址由32位二进制(32bit)组成:
例：11010010.01001001.10001100.00000110化为十进制为:210.73.140.6。
IP地址分为两部分:网络部分(NETWORK)、主机部分(HOST)。
IP地址分为A、B、C、D、E五类，每一类有不同的划分规则:
二、私有IP地址 1、满足企业用户在内部网络中使用的需求，且私有地址不能在lnternet上使用。
2、私有地址包括3组：A、B、C三类(属于有类地址)
A类:10.0.0.0~10.255.255.255
B类: 172.16.0.0~172.31.255.255
C类:192.168.0.0~192.168.255.255
三、IP地址分类： 1、有类地址:标准的IP地址(A、B、C三类)属于有类地址，例如A类地址掩码8位、B类地址掩码16位、C类地址掩码24位，都属于有类地址——(A/8 B/16 C/24)。
无类地址:为了灵活地使用IP地址，需要根据需求对IP地址进行子网划分，使划分后的IP地址不再具备有类地址的特征，这些地址称为无类地址——(可变子网)。
2、C类地址划分：IP地址进过一次自额昂划分后，被分为三个部分——网络位、子网位和主机位。
子网数=2^n，其中n为子网部分位数；
有效主机数=2^N-2(2为网络号、广播号）,其中N为主机部分位数。
四、子网掩码 1、用32个二进制位来确定IP的网络地址，对应IP地址的网络部分用1表示，对应IP地址的主机部分用0表示。
IP地址和子网掩码作逻辑“与”运算得到网络地址，0和任何数相与都等于0，1和任何数相与都等于任何数本身。
2、A、B、C三类地址的默认子网掩码：
A类:255.0.0.0
B类:255.255.0.0
C类:255.255.255.0
4、子网划分的原因:
1)满足不同网络对IP地址的需求
2)实现网络的层次性
3)节省IP地址
5、子网划分的软硬规则:
·“软”规则
辅助性规则，其目的是方便网络管理员的统一管理，如给某大厦的10层分配地址是192.168.10.0/24 IP段,12层分配192.168.12.0/24。
“硬”规则
如何根据实际情况制定出合理的划分方法，如查看网络设计，包括每个部门拥有的主机数、需要iP地址设备数量及哪些设备需要配置的互联地址；
确定需要的子网数；
确定每个子网需要的IP地址数和使用的掩码。
五、IP地址的规划 1、IP地址规划原则
要遵循4个原则：唯一性、可扩展性、连续性、实意性。
2、IP地址规划注意事项
1)配置互联地址时，子网掩码为30；
2)配置Loopback地址时，子网掩码为32；
3)对各业务网关进行统一设定
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c022af99e5d102cf06bc95d1c6bd9ad7/" rel="bookmark">
			TypeError:this.getOptions is not a function
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： vue开发项目时，提示需要安装less-loader，使用npm install安装后报错如下： 直接npm install安装的是最新版本的，less-loader版本过高和webpack版本不一致导致
解决方案： 降低less-loader版本，或者也可以升级webpack版本，但是容易引发一系列其他问题，建议只降低less-loader的版本
npm install less-loader@6.0.0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61db9b20966376f6f1ac74b96efd3363/" rel="bookmark">
			MacPro安装运行Win10虚拟机 (Parallels Desktop)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Parallels Desktop for Mac安装运行Win10 Parallels Desktop 安装Win10镜像下载：PD安装Win10虚拟机网络问题解决： 先上图：
最近研究学习Mac，因为嵌入式开发大部分软件都是Windows的，又懒得装双系统，所以直接用虚拟机。。
经过对比，Mac上虚拟机还是PD比较丝滑，有种上真机的赶脚，速度快，各种资源使用共享方便。。。就是收费。。。而免费的Virtual Box 运行Win10实测太卡顿，没法用。。。
Parallels Desktop 安装 下载Parallels Desktop 安装包后，打开点击安装：
安装过程如果报错：“无法打开“Parallels Desktop”,因为Apple无法检查其是否包含恶意软件。”
则 终端输入 sudo spctl --master-disable
执行后重新打开dmg 继续安装即可
安装过程和正常软件一样即可，
同时安装下Tools
安装完成后打开
Win10镜像下载： 镜像下载有很多方式：
msdn：https://msdn.itellyou.cn/ 下载纯净版，微软官方：https://www.microsoft.com/zh-cn/software-download/windows10ISO 微软官方也提供构建好的PD虚拟机下载：https://developer.microsoft.com/zh-cn/windows/downloads/virtual-machines/
用msdn下载最新Win10：
或者在微软官方Link：
下载好后，即可准备安装win10了
PD安装Win10 配置好偏好设置各权限后，打开PD ，点击安装Windows：
选择下载好的win10 ISO，点击继续：
选择系统类型：
点击继续输入或跳过许可证，
随即和正常流程一样，开始安装Windows，
安装完成：
快捷方式已自动显示：
虚拟机网络问题解决： 启动win10后，如果发现提示：虚拟机网络配置失败：
通过修改 /Library/Preferences/Parallels/network.desktop.xml
将 &lt;UseKextless&gt;-1&lt;/UseKextless&gt; 改为： &lt;UseKextless&gt;0&lt;/UseKextless&gt;，因为该文件被锁定，需要copy到桌面修改保存后，再替代到源目录！
之后重新启动PD和虚拟机即可使用网络：
网络方式选择与主机共享即可：
附虚拟机磁盘占用大小：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97426f67c72e983947c4abab8f02b85a/" rel="bookmark">
			C&#43;&#43;性能优化（十二）——自旋锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、互斥锁 1、互斥锁简介 互斥锁属于sleep-waiting类型锁。Linux Kernel 2.6.x稳定版开始，Linux的互斥锁都是futex (Fast Usermode Mutex)锁。
Futex是一个在Linux上实现锁定和构建高级抽象锁如信号量和POSIX互斥的基本工具。
Futex由Hubertus Franke（IBM Thomas J. Watson 研究中心），Matthew Kirkwood，Ingo Molnar（Red Hat）和 Rusty Russell（IBM Linux 技术中心）等人创建。
Futex是由用户空间的一个对齐的整型变量和附在其上的内核空间等待队列构成。多进程或多线程绝大多数情况下对位于用户空间的futex的整型变量进行操作(汇编语言调用CPU提供的原子操作指令来增加或减少)，而其它情况下则需要通过代价较大的系统调用来对位于内核空间的等待队列进行操作(如唤醒等待的进程/线程或将当前进程/线程放入等待队列)。除了多个线程同时竞争锁的少数情况外，基于futex的lock操作是不需要进行代价昂贵的系统调用操作的。
Futex核心思想是通过将大多数情况下非同时竞争lock的操作放到在用户空间执行，而不是代价昂贵的内核系统调用方式来执行，从而提高了效率。
互斥锁禁止多个线程同时进入受保护的代码临界区（critical section）。在任意时刻，只有一个线程被允许进入代码保护区。互斥锁实际上是count=1情况下的semaphore。
2、互斥锁特点 互斥锁缺点：
（1）等待互斥锁会消耗时间，等待延迟会损害系统的可伸缩性。
（2）优先级倒置。低优先级的线程可以获得互斥锁，因此会阻碍需要同一互斥锁的高优先级线程。
（3）锁护送（lock convoying）。如果持有互斥锁的线程分配的时间片结束，线程被取消调度，则等待同一互斥锁的其它线程需要等待更长时间。
3、互斥锁API #include &lt;pthread.h&gt; int pthread_mutex_destroy(pthread_mutex_t *mutex); int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_trylock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex, const struct timespec *restrict abs_timeout); 二、自旋锁 1、自旋锁简介 自旋锁（spin lock）属于busy-waiting类型锁。在多处理器环境中，自旋锁最多只能被一个可执行线程持有。如果一个可执行线程试图获得一个被其它线程持有的自旋锁，那么线程就会一直进行忙等待，自旋（空转），等待自旋锁重新可用。如果自旋锁未被争用，请求锁的执行线程便立刻得到自旋锁，继续执行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97426f67c72e983947c4abab8f02b85a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84dec533c006cdb7c4ab059234f47b8f/" rel="bookmark">
			elementui日期选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 日期选择器只能选择明天及以后 &lt;el-date-picker	:picker-options="pickerOptions"&gt; data () { return { pickerOptions: { disabledDate (time) { return time.getTime() &lt; Date.now() } } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96696e6a11d3292141a91a96ac4c8df0/" rel="bookmark">
			pyspark中dataframe 转化问题（panda、list等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 dataframe是pyspark中常见的数据类型，一般从load的sql中读取。有时候输入数据源并非sql，这时如何处理呢？
具体转化示例 list转化为dataframe 先将list转化为 dataframe
import pandas as pd data_list = [['wer', 1], ['asd', 2]] panda_df = pd.DataFrame(data_list, columns=['col_name1', 'col_name2']) # 此处要注意panda和pandas是两个不同的包 # pandas中的dataframe和spark中的dataframe不一样 再将pandas中的dataframe转化成spark中的dataframe
from pyspark.sql import SparkSession spark = SparkSession.builder.enableHiveSupport().getOrCreate() spark_df = spark.createDataFrame(panda_df) 其他 更多spark中dataframe 操作可参见 pyspark中where及=的使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28e2fb9fe574b9a6eee9b17a7604d636/" rel="bookmark">
			在win10中安装vim并配置vimplus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录 一、vim 仓库下载 vim 32 位 或者 64 位安装包]二、git 仓库下载 git三、将 .vimplus 克隆至用户文件夹四、安装 vimplus五、移动个别文件以适配 vimplus 的设置六、安装插件七、扩展安装八、完成 如果你也想在 windows 下使用 vim, 这篇文章可能会给你提供一点帮助。用熟悉了 vim ，在 windows 下总会怀念 它，今天试着安装了下，特此记录，欢迎参考~
一、vim 仓库下载 vim 32 位 或者 64 位安装包] 安装入口
ps：下述安装包的下载完成后出现黄色感叹号时，并且你选择“不信任该文件”时，文件的扩展名会变成一串bala…，我直接将其改成了 exe 😃
下载下来后双击运行，一路 next， 将其安装至非系统盘
将安装后的位置添加至环境变量中的 path 中，便于在cmd 或者 powershell 中命令行式的使用 vim
我的是这样的：
二、git 仓库下载 git 安装入口
同理将 git 安装好的路径添加至环境变量中的 path 变量中便于在命令行下使用 git 命令
三、将 .vimplus 克隆至用户文件夹 vimplus 仓库
刚进入cmd 时的位置即为用户文件夹：
"进入 cmd，不要变更位置，执行以下` git clone `命令(将 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28e2fb9fe574b9a6eee9b17a7604d636/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9d6c2be3261c578085e6550deda78dc/" rel="bookmark">
			DCDC 原理简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 降压变换器原理 BUCK
当开关闭合时，加在电感两端的电压为（Vi-Vo），此时电感由电压（Vi-Vo）励磁，电感增加的磁通为：（Vi-Vo）*Ton。
当开关断开时，由于输出电流的连续，二极管VD变为导通，电感削磁，电感减少的磁通为：（Vo）*Toff。
当开关闭合与开关断开的状态达到平衡时，由伏秒平衡 （Vi-Vo）*Ton=（Vo）*Toff，由于占空比D&lt;1，所以Vi&gt;Vo，实现降压功能。
2. 升压变换器原理 Boost
当开关闭合时，输入电压加在电感上，此时电感由电压（Vi）励磁，电感增加的磁通为：（Vi）*Ton。
当开关断开时，由于输出电流的连续，二极管VD变为导通，电感削磁，电感减少的磁通为：（Vo- Vi）*Toff。
当开关闭合与开关断开的状态达到平衡时，由伏秒平衡（Vi）*Ton=（Vo- Vi）*Toff，由于占空比D&lt;1，所以Vi&lt;Vo，实现升压功能。
3. 升降压变换器 boost-buck
当开关闭合时，此时电感由电压（Vi）励磁，电感增加的磁通为：（Vi）*Ton；
当开关断开时，电感削磁，电感减少的磁通为：（Vo）*Toff。
当开关闭合与开关断开的状态达到平衡时，增加的磁通等于减少的磁通，（Vi）*Ton=（Vo）*Toff，根据Ton比Toff值不同，可能Vi&lt; Vo，也可能Vi&gt;Vo。
综上，可通过DCDC外部电感和二极管的接法来判断DCDC的类型：
1&gt;若二极管负向接SW，正向接地，且电感接SW和负载之间。则为降压DCDC。
2&gt;若电感接电源和SW之间，二极管正向接SW，负向接负载。则为升压DCDC。
3&gt;若电感接SW和地之间，二极管负向接SW，正向接负载。则为升降压DCDC。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41476ef0c882938f0d3e3d7d2b714842/" rel="bookmark">
			k8s在pod内无法ping通servicename和ClusterIP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要使用 ipvs 替换iptables，操作是在所有节点上
1：开启内核支持
1
2
3
4
5
6
7
cat &gt;&gt; /etc/sysctl.conf &lt;&lt; EOF
net.ipv4.ip_forward = 1
net.bridge.bridge-nf-call-iptables = 1
net.bridge.bridge-nf-call-ip6tables = 1
EOF
sysctl -p
2：开启ipvs支持
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
yum -y install ipvsadm ipset
# 临时生效
modprobe -- ip_vs
modprobe -- ip_vs_rr
modprobe -- ip_vs_wrr
modprobe -- ip_vs_sh
modprobe -- nf_conntrack_ipv4
# 永久生效
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41476ef0c882938f0d3e3d7d2b714842/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3664300675846d5dab2bc03fbaa700ea/" rel="bookmark">
			ffmpeg 下载网上m3u8的视频文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、关于 FFmpeg FFmpeg 是一个音视频领域使用最广泛的跨平台开源库。由C语言编写，但广泛的为 C/C++、C#、Java、Python 等主流编程语言所调用。它集合了几乎所有的编码解码库与流协议，几乎能完美处理音视频开发领域的所有需求。
二、Mac 平台安装 FFmpeg 方式一：源码安装 FFmpeg
通过编译源码安装 FFmpeg 的优点是可以把我们想要的东西都塞到FFmpeg中，不想要的就删掉，也就是根据自己的需要对FFmpeg进行裁剪。首先我们编希望达到的目标：
（1）编译出 ffmpeg、ffplay、ffprobe 三个命令行程序；
（2）只产生动态库，不产生静态库；
（3）将 fdk-aac、x264、x265集成到 FFmpeg 中（fdk-aac 会在后续 AAC 编解码时用到，x264、x265会在视频模块中用到）；
1.1、安装依赖项：
a、安装 yasm
#下载 yasm 1.2.0 $ curl http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz &gt;yasm.tar.gz # 解压 $ tar xzvf yasm.tar.gz # 进入目录 yasm-1.2.0 $ cd yasm-1.2.0 # 执行配置 $ ./configure # 编译 $ make # 安装 $ sudo make install b、安装 sdl2（如果不需要安装 ffplay 可以忽略这一步）：
$ brew install sdl2 c、安装 fdk-aac
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3664300675846d5dab2bc03fbaa700ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e98cdc0473ef5221573c5c0d9aba7b9a/" rel="bookmark">
			2022微信支付v3 - Native
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Native支付介绍 参考文档：https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_7_0.shtml
Native支付是指商户系统按微信支付协议生成支付二维码，用户再用微信“扫一扫”完成支付的模式。
应用场景 Native支付适用于PC网站、实体店单品或订单、媒体广告支付等场景
用户扫描商户展示在各种场景的二维码进行支付，具体操作流程如下：
接入前准备 参考文档：https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_7_1.shtml#top
选择接入模式 直连模式服务商模式 参数申请 注意：appid 和 mchid 是必须的。
配置API key API v3密钥主要用于平台证书解密、回调信息解密，具体使用方式可参见接口规则文档中证书和回调报文解密章节。
注意：这里我们设置的是 API v3密钥，不是 API v2密钥。
下载并配置商户证书 在【证书工具】-“生成证书”环节，已完成申请证书流程，点击“查看证书文件夹”，查看已生成的证书文件。
恭喜，到此一切准备就绪！
关于API v3 为了在保证支付安全的前提下，带给商户简单、一致且易用的开发体验，我们推出了全新的微信支付API v3。
相较于之前的微信支付API，主要区别是：
遵循统一的REST的设计风格使用JSON作为数据交互的格式，不再使用XML使用基于非对称密钥的SHA256-RSA的数字签名算法，不再使用MD5或HMAC-SHA256不再要求携带HTTPS客户端证书（仅需携带证书序列号）使用AES-256-GCM，对回调中的关键信息进行加密保护 数据格式 所有的API请求必须使用HTTPS。
微信支付API v3使用 JSON 作为消息体的数据交换格式，图片上传API除外。请求须设置HTTP头部：
Content-Type: application/json Accept: application/json 错误信息 微信支付API v3使用HTTP状态码来表示请求处理的结果。
处理成功的请求，如果有应答的消息体将返回200，若没有应答的消息体将返回204。已经被成功接受待处理的请求，将返回202。请求处理失败时，如缺少必要的入参、支付时余额不足，将会返回4xx范围内的错误码。请求处理时发生了微信支付侧的服务系统错误，将返回500/501/503的状态码。这种情况比较少见。 微信支付v3 实战 环境：
SpringBoot 2.3.2.RELEASEweixin-java-pay 4.2.0lombok 1.18.22hutool-all 5.7.21 准备 需要提前准备以下的材料
添加依赖 参考地址：https://gitee.com/binary/weixin-java-tools
&lt;!--weixin pay --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.binarywang&lt;/groupId&gt; &lt;artifactId&gt;weixin-java-pay&lt;/artifactId&gt; &lt;version&gt;4.2.0&lt;/version&gt; &lt;/dependency&gt; 其他
&lt;!-- https://mvnrepository.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e98cdc0473ef5221573c5c0d9aba7b9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e81f60168aa3ac150824e6adfe939e55/" rel="bookmark">
			Relion三维重构失败可能的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用relion时，有可能会出现initial model 正常但是三维精修后一塌糊涂的情况，这时候如果你在三维精修时设置了对称性，那么这篇文章可能会解决你的问题。
一开始我发现自行编写.star来导入颗粒会引起这种情况，但后来发现这个现象可能更普遍些
以relion tutorial中使用的beta-galactosidase数据集为例
这是初始模型，一切正常
三维精修（D2对称）后，结构完全错误
如果你尝试不限制对称性（C1），能重构出正常的结构，那么可以继续看下去
当时这个问题困扰了我很久，于是请教了relion的开发者
问题在于，使用带有对称性限制三维精修时，要事先校准initial model的三维角度，使用以下命令（这个结构是D2对称，要根据实际改动）：
relion_align_symmetry --i InitialModel/job015/run_it150_class001.mrc \--o InitialModel/job015/run_it150_class001_alignD2.mrc --sym D2 之后问题就解决了，这是正常精修结构，很漂亮
另外，回答我问题的biochem-fan （Takanori Nakane）是个很了不起的人，他作为第一作者在nature发表的'Single-particle cryo-EM at atomic resolution'是领域内里程碑作品，被nature评为2020年度十大发现，感兴趣的人可以多了解一下他，可以从他身上学习到很多东西
我的提问连接：
https://github.com/3dem/relion/issues/839
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdcd8a3b68e4a7dc3e2e264d7463abc7/" rel="bookmark">
			前端Mockjs数据模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装mockjs(本案例完整代码在最下方) 通过指令npm install mockjs安装mock ,
之后在src文件夹下创建一个mock文件夹,再在mock文件夹下创建一个index.js文件
之后接着在main.js文件中引入mock
之后就可以在mock文件下的index.js文件中模拟数据了
1.首先我们需要在mock下的index.js文件中引入mock
import Mock from "mockjs"; 2.接着在此处我们模拟了一个 新闻列表数据 ,该数据是一个数组,数组长度为75,每个数组元素均为对象,
不太了解mock数据的可以到mockjs官网去查看
const { newsList } = Mock.mock({ "newsList|75": [{ id: "@increment",//表示自增 title: "@ctitle()",//表示中文标题 content: "@cparagraph(5,10)",//表示中文段落5-10句 img_url: "@image('50*50','#FF83FA','#FCFCFC','png','mono')",//表示图片 add_time: "@date(yyyy-MM-dd hh:mm:ss)",//表示日期 }, ], }); 3.我们继续在该文件中定义一个接口
var getQuery = (url, name) =&gt; { console.log(url, name); const index = url.indexOf("?"); if (index !== -1) { const queryStrArr = url.substr(index + 1).split("&amp;"); for (var i = 0; i &lt; queryStrArr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdcd8a3b68e4a7dc3e2e264d7463abc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef77fb572d0e7da2c2e7c2a6cc51eb6c/" rel="bookmark">
			shell脚本中变量替换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shell脚本中变量替换 如果变量字符前面使用感叹号，可以实现对变量的间接引用，而不是返回变量本身的值，但只能实现一层间接引用
[root@mao_aliyunserver ~]# god=mao [root@mao_aliyunserver ~]# people=god [root@mao_aliyunserver ~]# echo ${people} god [root@mao_aliyunserver ~]# echo ${!people} mao 变量替换可以测试变量是否存在及是否为空，并根据不同的语法格式进行不同的操作
# ${变量名:-默认值} -&gt; 如果变量未定义或为空，则返回默认值，否则返回变量值 [root@mao_aliyunserver ~]# echo ${a} [root@mao_aliyunserver ~]# echo ${a:-mao} mao [root@mao_aliyunserver ~]# echo ${a} # ${变量名:=默认值} -&gt; 如果变量未定义或为空，则返回默认值，并且会把默认值赋给变量，否则返回变量值 [root@mao_aliyunserver ~]# echo ${b} [root@mao_aliyunserver ~]# echo ${b:=mao} mao [root@mao_aliyunserver ~]# echo ${b} mao # ${变量名:?错误信息} -&gt; 如果变量未定义或为空，则通过标准错误返回错误信息，否则返回变量值 [root@mao_aliyunserver ~]# echo ${c} [root@mao_aliyunserver ~]# echo ${c:?变量值c为空或没有赋值} -bash: c: 变量值c为空或没有赋值 [root@mao_aliyunserver ~]# echo ${c} # ${变量名:+默认值} -&gt; 如果变量未定义或为空，则返回空，否则返回默认值 [root@mao_aliyunserver ~]# echo ${d} [root@mao_aliyunserver ~]# echo ${d:+mao} [root@mao_aliyunserver ~]# echo ${d} [root@mao_aliyunserver ~]# d=pipi [root@mao_aliyunserver ~]# echo ${d:+mao} mao 变量替换还可以完成字符串切割及掐头去尾功能，详细情况见之前的一篇博客
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef77fb572d0e7da2c2e7c2a6cc51eb6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f93eeb6c2772cbce0ee16f6197ad3730/" rel="bookmark">
			【CryoEM】FSC, Fourier Shell Correlation简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fourier Shell Correlation Fourier Shell Correlation (FSC) 是冷冻电镜单颗粒分析获得的生物大分子三维结构的可靠性度量指标。FSC由下式（归一化互相关）表示为空间频率的函数。
这里 F 1 ( k ) F_1(k) F1​(k)、 F 2 ( k ) F_2(k) F2​(k)是任意两组独立的TEM图像重建的两种结构的三维傅里叶变换。 F 2 ( k ) ∗ F_2(k)^* F2​(k)∗是复共轭， ∑ K , △ k F ( k ) ∑_{K,△k}F(k) ∑K,△k​F(k)表示在k附近的一个小范围( △ k △k △k)里求和 F ( k ) F(k) F(k)。
FSC(k) 对每个空间频率k取值在 +1~-1之间，接近1时说明两个重构结构的一致性较好，说明得到的结构具有较高的可靠性。如果FSC在高频时不随空间频率k单调减小，则认为FSC函数可靠性较低。
下面的例子显示了FSC和小鼠脱氧蛋白的空间分辨率。首先，将一组用于单颗粒分析的TEM图像随机分成两组，对每组进行图像处理分析，得到两个独立的三维结构，利用得到的两个三维结构计算FSC。
在单颗粒分析中通常将获得的结构的空间分辨率定义为FSC=0.143时的空间频率的倒数。（0.143是根据随机噪声相关性的统计讨论和参考x射线晶体学定义的分辨率采用的）在6.5 nm-1的空间频率下，脱铁蛋白的分辨率为0.153 nm，而FSC的值为0.143。
图1(a)显示了840张低温透射电镜图像中提取的120,295个颗粒重建的脱铁蛋白的三维密度图。图1(b)是这个3D密度图计算出的FSC。低频下FSC的值接近于+1，并随频率的增加而单调向0衰减。这证实了FSC函数的高可靠性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5ea50c9fa035b2095c7b2e9adeb922c/" rel="bookmark">
			CPP头文件引用混乱问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近写一个C++项目，因为头文件循环引用增加了很多工作量。
感觉这个问题更偏向于工程性，也就是怎么设计代码结构，让各个文件是又层次的而不是混乱的互相引用。
比如说：
A_class.h定义了一些基础类，然后A_transform.h引用A_class.h并定义将这个基础类与protobuf进行互相转化的工具函数，然后A_control.cpp引用前面两个头文件就可以实现逻辑清晰的代码结构。
B_class.h定义了基础类和转换函数，然后被B_control.cpp引用，这样也可以。
但是我之前写的代码结构是A_class.h定义了类但是引用了A_transform.h，A_transform.h定义了转换函数但是又引用了A_class.h，这样互相引用就出错了。
常见的解决方案有：
当使用类型时只需要引用或者指针类型时，通过前向声明来解决就可。因为它们的存储空间可以在编译期间确定。
或者调整代码结构使得他们层次清晰，比如把基础类放在一块，把转换函数放在一块，让基础类不依赖于转换函数所在的头文件，这样就不会有交叉引用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f213a20134e18dfaa5047d85d4d464b/" rel="bookmark">
			前所未有的 Milvus 源码架构解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✏️ 编者按：
Deep Dive 是由 Milvus 社区发起的代码解析系列直播，针对开源数据库 Milvus 整体架构开放式解读，与社区交流与分享 Milvus 最核心的设计理念。通过本期分享，你可以了解到云原生数据库背后的设计理念，理解 Milvus 相关组件与依赖，了解 Milvus 多种应用场景。
讲师简介：
栾小凡，Zilliz 合伙人、工程总监，LF AI &amp; Data 基金会技术咨询委员成员。他先后任职于 Oracle 美国总部、软件定义存储创业公司 Hedvig 、阿里云数据库团队，曾负责阿里云开源 HBase 和自研 NoSQL 数据库 Lindorm 的研发工作。栾小凡拥有康奈尔大学计算机工程硕士学位。
视频版讲解请戳 👇
本期分享分为四个部分：
我们为什么需要 Milvus ？为什么它被称为下一代人工智能基础设施？
Milvus 2.0 的设计理念
Milvus 2.0 的概览与模块划分
Milvus 代码阅读注意事项
我们为什么需要 Milvus？ 非结构化数据处理流程 Milvus 为解决非结构化数据的检索问题而生：海量的非结构化数据一般会存储在分布式文件系统或对象存储上，之后通过深度学习网络完成推理，将这些非结构数据转化成 embedding 向量，并在向量空间内完成近似性检索，从而发现数据背后的一些特征。
整个数据处理流程如下图所示。比如，有很多原始的食物图片，通过卷积神经网络做训练和推理，为每一幅照片得出一组向量，再把这些向量按照空间中的近似维度做排序，最后得到这样的结果：最上面一排是一些长得像薯条的东西，中间都是一些长得像拉面的东西，底下都是长得像寿司的东西。也就是说，图片这种非结构化数据，经过深度学习处理之后，转化成了embedding 向量，并通过在向量空间的近似度比对来表征其相似性，这在很大程度上能跟人类理解的近似度是高度一致的。
向量与标量 传统的标量数据和 Milvus 面向的向量数据之间，到底有哪些不同呢？
从基本操作上来讲，对于标量数据，针对数值类数据一般会做加减乘除的操作；对字符串类型的数据一般会做一些 term 的匹配， 或者一些类似 like 的近似匹配，抑或一些前缀匹配。
而针对向量数据而言，很少进行这种 100% 的完全匹配，更多是看近似度，也就是高维空间下的距离。较常见的距离表示有余弦距离、欧式距离等。空间中向量之间的距离，很大程度上能表示非结构化数据之间的相似度。
除了对数据的操作会有很大不同以外，数据的组织方式也会有很大不同。如，传统数据很容易比较大小，无论是数值类，还是字符串，都可以通过二叉树或者 skip list 的方式排列组合，然后做二分查找。对于向量数据来讲，则更加复杂，因为它维度较高，很难像传统的数值类数据一样通过排序的方式做加速，往往需要一些特殊的索引结构和存储方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f213a20134e18dfaa5047d85d4d464b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80786bfffa5583b2f1c46c730b4c0bcb/" rel="bookmark">
			C语言——辗转相除法求最大公约数和最小公倍数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我觉得没什么说的，直接上流程图好了，图是百度得，懒得再画一遍了。
程序实现：
int main() { int m = 0; int n = 0; int temp = 0; printf("请输入正整数m和n的值:&gt;"); scanf("%d %d", &amp;m, &amp;n); int sum = m * n; if (m &lt; n) { temp = m; m = n; n = temp; } while (1) { if (m % n == 0) { break; } m = n; n = m % n; } printf("\n最大公约数为：%d\n", n); printf("\n最小公倍数为：%d\n", sum/n); return 0; } 运行结果： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72df34d943aea6504dedceaa13463df2/" rel="bookmark">
			ios返回只显示部分数据，轻触或滑动页面出现完整数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题场景： ios从详情页放回当前列表页后，只显示下半部分列表，上半部分不展示，需要用手稍微滑动下页面才能完全展示当前页面，见下图：
原因分析： 从当前页面顶部进入详情返回后未出现该问题；
从当前页面滑到底部进入详情返回后必现该问题。
1.尝试在离开路由前beforeRouterLeave，通过设置document.documentElement.scrollTop和document.body.scrollTop均为0，只第一次成功，估计有缓存，导致问题还是出现；
2.上一步怕是有缓存，尝试在详情页返回该页面前，也使用与上同样的方法，不奏效：
解决方案： 查资料发现PC端和H5端滑动窗体滚动元素不一致导致的兼容性问题：
PC端：document.body.scrollTop一直是0，滚动元素是document.documentElement；
H5：document.documentElement.scrollTop一直是0，滚动元素是document.body；
为了解决上述兼容性问题，出现了scrollingElement：
PC端：document.scrollingElement就是document.documentElement；
H5端：document.scrollingElement就是document.body。
解决方法：updated声明周期设置document.scrollingElement.scrollTop为0；
updated() { document.scrollingElement.scrollTop = 0; } 以上~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c3c996e9b9bda66b56ae489949b4c52/" rel="bookmark">
			mPEG2000-COOH，一种羧酸（-COOH）功能化PEG，Methoxy-PEG2000-acid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MPEG-COOH是一种羧酸（-COOH）功能化聚乙二醇衍生物，可用于修饰蛋白质、肽、颗粒和其他具有游离酸基团的材料。羧酸基容易与胺基反应，形成稳定的酰胺键。它们还可以与羟基发生反应，形成不稳定的酯键，在酸性或碱性条件下可以断裂。聚乙二醇化可以增加肽和蛋白质的溶解性和稳定性，并降低其免疫原性。它还可以抑制带电分子与修饰表面的非特异性结合。酸功能化聚乙二醇在医疗器械改性、生物分子聚乙二醇化和粒子表面功能化等领域有着广泛的应用。
英文名称：Methoxy-PEG-acid
mPEG-COOH
中文名称：甲氧基-聚乙二醇-羧基
分子量：1k，2k，3.4k，5k，10k，20k（可按需定制）
质量控制：95%+
存储条件：-20°C，避光，避湿
用 途：仅供科研实验使用，不用于诊治
外观: 固体或粘性液体，取决于分子量
注意事项：取用一定要干燥，避免频繁的溶解和冻干
溶解性：溶于大部分有机溶剂，如：DCM、DMF、DMSO、THF等等。在水中有很好的溶解性
取用：现配现用，将包装从冰箱中取出，置于干燥器中缓慢升至室温，打开瓶盖，取用。取用后充入惰性气体，封口膜封口，拧紧瓶盖装入自封袋，及时放入冰箱。
结构式：
技术指标：
纯度（PEG）：95%以上
取代率（COOH）：95%以上
分散系数（PDI）：小于等于1.05
分析：COA、GPC、NMR、MALDI-TOF
其他相关产品：
H2N-PEG2-COOH 791028-27-8
H2N-PEG3-COOH 784105-33-5
H2N-PEG4-COOH 663921-15-1
H2N-PEG6-COOH 905954-28-1
HS-PEG4-COOH 749247-06-1
HS-PEG8-COOH 866889-02-3
HS-PEG12-COOH 1032347-93-5
H2N-PEG8-COOH 756526-04-2
HO-PEG6-COOH 1347750-85-9
HO-PEG8-COOH 937188-60-8
以上信息由西安凯新生物科技有限公司为您提供，如需了解详细信息请联系！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56189b8712c18bdca584e5462d8b6c93/" rel="bookmark">
			长链接和短链接的区别？为什么要使用短链接？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		短链接在营销推广中的应用越来越广泛，而且整体看来短链接在营销推广中的效果也是更好。那营销推广为什们要使用短链接了，我们就需要了解长链接和短链接的区别。 长链接和短链接的区别 ？
长链接和短链接区别从字面上就很好理解，就是比较长的链接地址和比较短的长链接地址。但长链接和短链接区别却不仅如此，两者之间的区别应该是在于最终的推广效果上。
这里要说的短链接其实是指通过短链接工具生成的短链接(如： 缩链)，这些短链接对应的内容还是原本长链接的内容。长链接和短链接都可以被使用在推广中，但是推广中长链接和短链接区别是很大的。
为什么要使用短链接？
页面美观
首先在美观度上，过长的链接显然是不够美观的，而通过短链接工具生成的短链接就显得更加的整齐美观了。尤其是在一些社群推广中，如果使用长链接会让用户觉得不够正规，而使用短链接(如： 缩链)就显得更加的正规了。
打开速度
在打开速度上，长链接显然是更具优势的。访问短链接，增加了短链接到长链接的跳转，所以访问速度相较会更慢。但是这个跳转是服务器的请求速度，其实在用户访问端而言，几乎是没有什么感知的。因此即使是使用短链接，打开速度也是很快的。
推广限制
在推广中，长链接受到的限制更多。例如在论坛、贴吧中发帖，如果使用长链接基本没有存活的可能性，都会被删除，而使用短链接会被系统识别为文本，因此避开删帖。还有最常用的QQ群推广，如果在群里发长链接，很容易被群主踢掉。而且最重要的是，在社群推广中使用短链接(如： 缩链)，还减少了长链接被屏蔽访问的风险。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bab28c57353221056958339cbb81027e/" rel="bookmark">
			【整合springboot和oracle报错】不支持的字符集 (在类路径中添加 orai18n.jar): ZHS16GBK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022-02-17 16:46:55.047 ERROR 8964 --- [p-nio-86-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.jdbc.UncategorizedSQLException: Error attempting to get column 'ID' from result set. Cause: java.sql.SQLException: 不支持的字符集 (在类路径中添加 orai18n.jar): ZHS16GBK ; uncategorized SQLException; SQL state [99999]; error code [17056]; 不支持的字符集 (在类路径中添加 orai18n.jar): ZHS16GBK; nested exception is java.sql.SQLException: 不支持的字符集 (在类路径中添加 orai18n.jar): ZHS16GBK] with root cause java.sql.SQLException: 不支持的字符集 (在类路径中添加 orai18n.jar): ZHS16GBK at oracle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bab28c57353221056958339cbb81027e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec6fde3b58ed2e6facebd68e2b9654fd/" rel="bookmark">
			拜托，面试请不要再问我Spring Cloud底层原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加VX：ruyuan0220，回复：CSDN，领取更多精品学习资料！
目录 业务场景介绍
Spring Cloud核心组件：Eureka
Spring Cloud核心组件：Feign
Spring Cloud核心组件：Ribbon
Spring Cloud核心组件：Hystrix
Spring Cloud核心组件：Zuul
总结
概述
毫无疑问，Spring Cloud是目前微服务架构领域的翘楚，无数的书籍博客都在讲解这个技术。不过大多数讲解还停留在对Spring Cloud功能使用的层面，其底层的很多原理，很多人可能并不知晓。因此本文将通过大量的手绘图，给大家谈谈Spring Cloud微服务架构的底层原理。
实际上，Spring Cloud是一个全家桶式的技术栈，包含了很多组件。本文先从其最核心的几个组件入手，来剖析一下其底层的工作原理。也就是Eureka、Ribbon、Feign、Hystrix、Zuul这几个组件。
一、业务场景介绍 先来给大家说一个业务场景，假设咱们现在开发一个电商网站，要实现支付订单的功能，流程如下：
创建一个订单之后，如果用户立刻支付了这个订单，我们需要将订单状态更新为“已支付”
扣减相应的商品库存
通知仓储中心，进行发货
给用户的这次购物增加相应的积分
针对上述流程，我们需要有订单服务、库存服务、仓储服务、积分服务。整个流程的大体思路如下：
用户针对一个订单完成支付之后，就会去找订单服务，更新订单状态
订单服务调用库存服务，完成相应功能
订单服务调用仓储服务，完成相应功能
订单服务调用积分服务，完成相应功能
至此，整个支付订单的业务流程结束，下图这张图，清晰表明了各服务间的调用过程：
好！有了业务场景之后，咱们就一起来看看Spring Cloud微服务架构中，这几个组件如何相互协作，各自发挥的作用以及其背后的原理。
二、Spring Cloud核心组件：Eureka 咱们来考虑第一个问题：订单服务想要调用库存服务、仓储服务，或者是积分服务，怎么调用？
订单服务压根儿就不知道人家库存服务在哪台机器上啊！他就算想要发起一个请求，都不知道发送给谁，有心无力！
这时候，就轮到Spring Cloud Eureka出场了。Eureka是微服务架构中的注册中心，专门负责服务的注册与发现。
咱们来看看下面的这张图，结合图来仔细剖析一下整个流程： 如上图所示，库存服务、仓储服务、积分服务中都有一个Eureka Client组件，这个组件专门负责将这个服务的信息注册到Eureka Server中。说白了，就是告诉Eureka Server，自己在哪台机器上，监听着哪个端口。而Eureka Server是一个注册中心，里面有一个注册表，保存了各服务所在的机器和端口号
订单服务里也有一个Eureka Client组件，这个Eureka Client组件会找Eureka Server问一下：库存服务在哪台机器啊？监听着哪个端口啊？仓储服务呢？积分服务呢？然后就可以把这些相关信息从Eureka Server的注册表中拉取到自己本地缓存起来。
这时如果订单服务想要调用库存服务，不就可以找自己本地的Eureka Client问一下库存服务在哪台机器？监听哪个端口吗？收到响应后，紧接着就可以发送一个请求过去，调用库存服务扣减库存的那个接口！同理，如果订单服务要调用仓储服务、积分服务，也是如法炮制。
总结一下：
Eureka Client：负责将这个服务的信息注册到Eureka Server中
Eureka Server：注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号
三、Spring Cloud核心组件：Feign 现在订单服务确实知道库存服务、积分服务、仓库服务在哪里了，同时也监听着哪些端口号了。但是新问题又来了：难道订单服务要自己写一大堆代码，跟其他服务建立网络连接，然后构造一个复杂的请求，接着发送请求过去，最后对返回的响应结果再写一大堆代码来处理吗？
这是上述流程翻译的代码片段，咱们一起来看看，体会一下这种绝望而无助的感受！！！
友情提示，前方高能：
看完上面那一大段代码，有没有感到后背发凉、一身冷汗？实际上你进行服务间调用时，如果每次都手写代码，代码量比上面那段要多至少几倍，所以这个事儿压根儿就不是地球人能干的。
既然如此，那怎么办呢？别急，Feign早已为我们提供好了优雅的解决方案。来看看如果用Feign的话，你的订单服务调用库存服务的代码会变成啥样？
看完上面的代码什么感觉？是不是感觉整个世界都干净了，又找到了活下去的勇气！没有底层的建立连接、构造请求、解析响应的代码，直接就是用注解定义一个 FeignClient接口，然后调用那个接口就可以了。人家Feign Client会在底层根据你的注解，跟你指定的服务建立连接、构造请求、发起靕求、获取响应、解析响应，等等。这一系列脏活累活，人家Feign全给你干了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec6fde3b58ed2e6facebd68e2b9654fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98bfb4937606d12df5108b0f9e5d2dcf/" rel="bookmark">
			java实现调用方法解压和压缩给定的文件夹方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.最近接到任务，需要将压缩包解压到指定路径，还有将指定路径的文件夹压缩成一个压缩包，在网上找了一些资料，自己有完善了一下，发布出来记录一下；
引入的jar包；
&lt;!--rar压缩--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-compress&lt;/artifactId&gt; &lt;version&gt;1.9&lt;/version&gt; &lt;/dependency&gt; 压缩和解压方法代码：
package com.aspirecn.audit.file.biz.utils; import org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry; import org.apache.commons.compress.archivers.sevenz.SevenZFile; import org.apache.commons.lang3.StringUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.util.DigestUtils; import sun.misc.BASE64Decoder; import sun.misc.BASE64Encoder; import java.io.*; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.URL; import java.nio.channels.FileChannel; import java.nio.charset.Charset; import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.*; import java.util.zip.ZipEntry; import java.util.zip.ZipFile; import java.util.zip.ZipOutputStream; /** * TODO * * @author wangyanhui * @date 2018-07-09 13:52 * */ public class FileUtil { //private static final Logger logger = LogUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98bfb4937606d12df5108b0f9e5d2dcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fa86fb450536d5e9d13cc03f60db98d/" rel="bookmark">
			Mybatis中使用的10种设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Mybatis至少遇到了以下的设计模式的使用： 1、Builder模式，例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder； 2、工厂模式，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory； 3、单例模式，例如ErrorContext和LogFactory； 4、代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果； 5、组合模式，例如SqlNode和各个子类ChooseSqlNode等； 6、模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler； 7、适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现； 8、装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现； 9、迭代器模式，例如迭代器模式PropertyTokenizer； 10、 MyBatis拦截器使用了责任链模式 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/481c87335a67f6845f9719f150be23fd/" rel="bookmark">
			VSCODE波形曲线提示找不到头文件（头文件存在还报错）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VSCODE波形曲线提示找不到头文件（头文件存在还报错） 文章目录 VSCODE波形曲线提示找不到头文件（头文件存在还报错）之前在网上看到一个方法如下，但并没有解决 ，如果你也是这样，`请直接跳过这个方法往下看`我自己实测有用的方法1.打开这个网址[LLVM下载地址](https://releases.llvm.org/download.html)2.搜索windows找到windows版本的，然后下载3.安装4.上述安装完成后，在vscode 中将C/C++ Clang Command Adapter插件卸载掉，重启，重新安装，再重启，就好了 2022/2/17最新： 之前在网上看到一个方法如下，但并没有解决 ，如果你也是这样，请直接跳过这个方法往下看 工程文件夹下会有一个.vscode文件夹，找到c_cpp_properties.json文件，复制以下代码进去
"includePath": [ "${workspaceFolder}/**" ], 如下图所示：
我自己实测有用的方法 如果你安装了C/C++ Clang Command Adapter这个插件，那大概率是它没有配置好的原因
先卸载这个插件，重启VSCODE, 再看看你还会不会报错,如果还会，那么这个方法不适合你，看看别的帖子吧。
如果没有报错了，那么下面教你怎么完全配置好这个插件
1.打开这个网址LLVM下载地址 2.搜索windows找到windows版本的，然后下载 下载可能会很慢，如果你下载不动或者很慢，可以直接在我上传的资源下载下载链接，设置的0积分免费的
3.安装 安装过程中会问你添不添加环境变量，默认是不添加，手动选一下添加就行，就只需要注意这一点，其它傻瓜安装就行。
如果忘了点，可以重装或者手动添加环境变量，找到bin文件添加进去，这个我就不详细说了，常规操作。
4.上述安装完成后，在vscode 中将C/C++ Clang Command Adapter插件卸载掉，重启，重新安装，再重启，就好了 2022/2/17最新： 确定是C/C++ Clang Command Adapter的锅，好像是和C/C++冲突，辣鸡插件，不安也罢
把C/C++ Clang Command Adapter卸载后再也没有这个问题了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf0dd1dc390d68e71215ccccb575c74e/" rel="bookmark">
			详解二叉树经典基础算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树是我们平时学习当中一种常见的数据结构。在面试和学习当中我们难免会遇到一些跟二叉树有关的算法题。今天我为大家带来了几题经典的二叉树基础算法题，我们一起来看看吧！
目录
1.检查两棵树是否相同
①题目描述
②思路分析
③题解代码
2.另一颗树的子树
①题目描述
②思路分析
③题解代码
3.二叉树最大的深度
①题目描述
②思路分析
③题解代码
4.平衡二叉树
①题目描述
②思路分析
③题解代码
5.对称二叉树
①题目描述
②思路分析
③题解代码
6.最近公共祖先
①题目描述
②思路分析
③题解代码
7.根据前序和中序构建二叉树
①题目描述
②思路分析
③题解代码
1.检查两棵树是否相同 ①题目描述 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。(来源：力扣（LeetCode）)
示例：
②思路分析 根据题目描述，我们在检验两颗二叉树是否相同时，可以先检验结构是否相同。那么基本可以分成一下几种情况：
一.两棵树的根节点有一颗为空，一颗不为空：false
二.两棵树都为空：true
三.两棵树都不为空：
1.值相同 ：检查子树
2.值不同：false
③题解代码 public boolean isSameTree(TreeNode p, TreeNode q) { if(p != null &amp;&amp; q == null) { return false; } else if(p == null &amp;&amp; q !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf0dd1dc390d68e71215ccccb575c74e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce9b6c2f1fd54710d7990ad3661ed8cc/" rel="bookmark">
			Java面试题及答案整理与下载（2021最新版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java面试题及答案整理 一、Java 基础# 1. JDK 和 JRE 有什么区别？# JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。 具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。
2. == 和 equals 的区别是什么？# == 解读
对于基本类型和引用类型 == 的作用效果是不同的，如下所示：
基本类型：比较的是值是否相同；引用类型：比较的是引用是否相同； 代码示例：
Copy
String x = "string"; String y = "string"; String z = new String("string"); System.out.println(x==y); // true System.out.println(x==z); // false System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce9b6c2f1fd54710d7990ad3661ed8cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51bd06ab80f7649e094936aa5edf6192/" rel="bookmark">
			(亲测)java.lang.ClassNotFoundException: javax.servlet.jsp.jstl.core.LoopTag
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 加入一下依赖
jstl-1.2.jar
standard-1.1.2.jar
&lt;dependency&gt; &lt;!--注意groupId不是javax.servlet.jsp.jstl--&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db624a3604b8cd91feb74660f3341f85/" rel="bookmark">
			使用umi脚手架来初始化React项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用umi脚手架来初始化React项目：使用umi脚手架来初始化React项目 - 简书 一、开发环境 首先，请安装 NodeJS。NodeJS 是一个 JS 执行环境，umi 基于 JS 编写，并且需要在你的开发机上运行，所以依赖于它。
安装完成后，执行下面的命令确认是否安装成功。
node -v npm -v 在 umi 中我们采用了一些 NodeJS 的新特性，请确保你的 NodeJS 版本大于等于 8.5.0。
在国内，你可以安装cnpm获得更快速、更安全的包管理体验。使用如下命令安装：
npm install -g cnpm --registry=https://registry.npm.taobao.org 然后你可以通过如下的命令确认是否成功：
cnpm -v 通过 cnpm 你可以很方便的安装和管理一些第三方的包。比如 umi 就将通过它来安装到你的项目。
二、安装 umi 依赖 首先，新建一个空的文件夹，用来存放本课程后续所有的代码。
mkdir antd-course cd antd-course 然后，调用 cnpm init 来初始化 package.json，它是 NodeJS 约定的用来存放项目的信息和配置等信息的文件。
cnpm init -y 上面命令中，参数 -y 表示对 npm 要求提供的信息，都自动按下回车键，表示接受默认值。
接着，安装 umi 的依赖。
cnpm install umi --save-dev 安装完成之后你会发现 package.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db624a3604b8cd91feb74660f3341f85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3a772f4368a5906b555829411bba335/" rel="bookmark">
			ruoyi-vue版本sqlserver的初始化数据库脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用navicate把我本地正常启动的库重新生成的脚本
/* Navicat Premium Data Transfer Source Server : mssqlserver Source Server Type : SQL Server Source Server Version : 11003000 Source Host : 127.0.0.1:1433 Source Catalog : sales Source Schema : dbo Target Server Type : SQL Server Target Server Version : 11003000 File Encoding : 65001 Date: 15/02/2022 16:11:47 */ -- ---------------------------- -- Table structure for gen_table -- ---------------------------- IF EXISTS (SELECT * FROM sys.all_objects WHERE object_id = Object_id(N'[dbo].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3a772f4368a5906b555829411bba335/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de8b15773d9af07e160f287fc99adead/" rel="bookmark">
			Java常见面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Java基础
谈谈对面向对象的理解？
访问修饰符的作用范围
String和StringBuilder、StringBuffer的区别？ 重载（Overload）和重写（Override）的区别？
throw和throws的区别？
接口与抽象类的区别？
Java中final关键字？
wait() 和 sleep() 方法的区别？
Thread 调用 start() 方法和调用 run() 方法的区别
synchronized 和 Lock 的区别
JVM常见问题
谈谈对JVM的理解？
什么情况下回发生栈内存溢出？
JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代？
你知道哪几种垃圾收集器，各自的优缺点？
CMS收集器和G1收集器的区别？
谈谈双亲委派机制？
强引用、软引用、弱引用、虚引用的区别？
spring常见问题
谈谈你对Spring的理解？
BeanFactory和ApplicationContext有什么区别？
谈谈spring中bean的生命周期？
SpringMVC常见问题
谈谈你对springmvc的理解？
SpringBoot常见问题
谈谈你对SpringBoot的理解？
说说SpringBoot的优点？
介绍一下 @SpringBootApplication 注解？
Spring Boot 的四大核心？
Spring Boot 自动配置原理是什么？
Spring Boot起步依赖？
Java基础 谈谈对面向对象的理解？ 面向对象是一种编程思想，它注重的是结果而非过程，不需要所有事情都亲力亲为。面向对象是对一类事物共有的特点和行为的概括，是抽象的、不存在的。
面向对象有三大特征：封装、继承和多态
封装：将属性私有化，对外提供getter、setter方法，隐藏对象的属性和实现细节，对内部数据提供不同级别的保护。
继承：所有类都默认继承顶级父类Object，使用extends实现继承关系，子类拥有父类的所有非私有方法及属性，在Java中都是单继承，如果父类中的方法不能满足子类的需求，子类可以重写父类方法进行功能扩展。
多态：多态的前提是要有继承关系，并重写了父类中的方法，父类型指向子类型对象。遵循编译时看左运行时看右原则。
访问修饰符的作用范围 String和StringBuilder、StringBuffer的区别？ String的值是常量，一旦被创建就无法修改，当对多个字符串拼接时，每次拼接得到的字符串都是一个新的对象，会占用大量内存。
StringBuilder是非线程安全的，它的append()方法对字符串进行操作时不会浪费内存。在单线程情况下推荐使用，效率较高。
StringBuffer是线程安全的，但是效率较低。
重载（Overload）和重写（Override）的区别？ 重载：
方法名相同，参数列表不同(参数类型、参数个数、参数顺序)目的，让方法在接收不同参数时实现不同功能 重写：
方法名和参数列表相同返回值和抛出异常范围要小于等于父类访问修饰符范围大于等于父类有private和final修饰的方法不能被重写 throw和throws的区别？ throw出现在方法中，用于方法执行时抛出一个指定的异常对象，而throws出现在参数列表和方法体之间，用于通知开发人员当前方法运行时，可能抛出的异常。一个throw一次只能携带一个异常对象，throws后面可以携带多个异常类型当方法中存在throw命令时，在调用时可以不考虑异常捕捉问题，当方法被throws修饰时，调用方法时必须考虑异常捕捉问题 接口与抽象类的区别？ 接口：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de8b15773d9af07e160f287fc99adead/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/648e79d7ff90d6e3e3fe83c6b5e4de80/" rel="bookmark">
			用户态和内核态的概念区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户态和内核态的概念区别 究竟什么是用户态，什么是内核态，这两个基本概念以前一直理解得不是很清楚，根本原因个人觉得是在于因为大部分时候我们在写程序时关注的重点和着眼的角度放在了实现的功能和代码的逻辑性上，先看一个例子：
void testfork(){ if(0 = = fork()){ printf(“create new process success!\n”); } printf(“testfork ok\n”); } 这段代码很简单，从功能的角度来看，就是实际执行了一个fork()，生成一个新的进程，从逻辑的角度看，就是判断了如果fork()返回的是则打印相关语句，然后函数最后再打印一句表示执行完整个testfork()函数。代码的执行逻辑和功能上看就是如此简单，一共四行代码，从上到下一句一句执行而已，完全看不出来哪里有体现出用户态和进程态的概念。
如果说前面两种是静态观察的角度看的话，我们还可以从动态的角度来看这段代码，即它被转换成CPU执行的指令后加载执行的过程，这时这段程序就是一个动态执行的指令序列。而究竟加载了哪些代码，如何加载就是和操作系统密切相关了。
2）特权级
熟悉Unix/Linux系统的人都知道，fork的工作实际上是以系统调用的方式完成相应功能的，具体的工作是由sys_fork负责实施。其实无论是不是Unix或者Linux，对于任何操作系统来说，创建一个新的进程都是属于核心功能，因为它要做很多底层细致地工作，消耗系统的物理资源，比如分配物理内存，从父进程拷贝相关信息，拷贝设置页目录页表等等，这些显然不能随便让哪个程序就能去做，于是就自然引出特权级别的概念，显然，最关键性的权力必须由高特权级的程序来执行，这样才可以做到集中管理，减少有限资源的访问和使用冲突。
特权级显然是非常有效的管理和控制程序执行的手段，因此在硬件上对特权级做了很多支持，就Intel x86架构的CPU来说一共有0~3四个特权级，级最高，3级最低，硬件上在执行每条指令时都会对指令所具有的特权级做相应的检查，相关的概念有 CPL、DPL和RPL，这里不再过多阐述。硬件已经提供了一套特权级使用的相关机制，软件自然就是好好利用的问题，这属于操作系统要做的事情，对于 Unix/Linux来说，只使用了级特权级和3级特权级。也就是说在Unix/Linux系统中，一条工作在级特权级的指令具有了CPU能提供的最高权力，而一条工作在3级特权级的指令具有CPU提供的最低或者说最基本权力。
3）用户态和内核态
现在我们从特权级的调度来理解用户态和内核态就比较好理解了，当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，当程序运行在级特权级上时，就可以称之为运行在内核态。
虽然用户态下和内核态下工作的程序有很多差别，但最重要的差别就在于特权级的不同，即权力的不同。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序，比如上面例子中的testfork()就不能直接调用 sys_fork()，因为前者是工作在用户态，属于用户态程序，而sys_fork()是工作在内核态，属于内核态程序。
当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态，比如testfork()最初运行在用户态进程下，当它调用fork()最终触发 sys_fork()的执行时，就切换到了内核态。
2. 用户态和内核态的转换
1）用户态切换到内核态的3种方式
a. 系统调用
这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。
b. 异常 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
c. 外围设备的中断
当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。
2）具体的切换操作
从触发方式上看，可以认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本上也是一致的，关于它们的具体区别这里不再赘述。关于中断处理机制的细节和步骤这里也不做过多分析，涉及到由用户态切换到内核态的步骤主要包括：
[1] 从当前进程的描述符中提取其内核栈的ss0及esp0信息。
[2] 使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个
过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一
条指令。
[3] 将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始
执行中断处理程序，这时就转到了内核态的程序执行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64bdd65698a56ed223b1a4666f12c879/" rel="bookmark">
			【数据结构】（一）数据结构入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数据结构入门1 数据结构基础知识2 算法复杂度 数据结构入门 数 据 结 构 + 算 法 = 程 序 数据结构+算法=程序 数据结构+算法=程序
1 数据结构基础知识 数据
指所有能输入到计算机中的描述客观事物的符号，包括文本、声音、图像、符号等。
数据元素
数据元素是数据的基本单位，也称节点或记录，如下图所示。
数据项
数据项表示有独立含义的数据最小单位，也称域。若干个数据项构成一个数据元素，数据项是不可分割的最小单位，如上图所示的“86”。
数据对象
数据对象是指相同特性的数据元素的集合，是数据的一个子集。
数据结构
数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。
数据结构是带“结构”的数据元素的集合，“结构”是指数据元素之间存在的关系。数据结构研究的问题是将带有关系的数据存储在计算机中，并进行相关操作。
逻辑结构是数据元素之间的关系，存储结构是数据元素及其关系在计算机中的存储方式。例如，小明和小勇是表兄弟，这是他们之间的逻辑关系；他们在教室里面的位置是他们的存储结构。
逻辑结构：数据元素间抽象化的相互关系，与数据的存储无关，独立于计算机，它是从具体问题中抽象出来的数学模型。
（1）集合——数据元素间除“同属于一个集合”外，无其他关系。
集合中的元素是离散、无序的，就像鸡圈中的小鸡一样，可以随意走动，它们之间没有什么关系，唯一的亲密关系就是在同一个鸡圈里，如下图所示。
（2）线性结构——一个对一个，如线性表、栈、队列、数组、广义表。
线性结构就像穿珠子，是一条线，不会分叉，如图1-3所示。有唯一的开始和唯一的结束，除了第一个元素外，每个元素都有唯一的直接前驱（前面那个）；除了最后一个元素外，每个元素都有唯一的直接后继（后面那个）。
（3）树形结构——一个对多个，如树。
树形结构就像一棵倒立的树，树根可以发出多个分支，每个每支也可以继续发出分支，树枝和树枝之间是不相交的，如图
（4）图形结构——多个对多个，如图、网。
图形结构就像我们经常见到的地图，任何一个节点都可能和其他节点有关系，就像一张错综复杂的网，如图
存储结构：数据元素及其关系在计算机中的存储方式。
（1）顺序存储
顺序存储是指逻辑上相邻的元素在计算机内的存储位置也是相邻的。例如，张小明是哥哥，张小波是弟弟，他们的逻辑关系是兄弟，如果他们住的房子是前后院，也是相邻的，就可以说他们是顺序存储，如图
顺序存储采用一段连续的存储空间，将逻辑上相邻的元素存储在连续的空间内，中间不允许有空。顺序存储可以快速定位第几个元素的地址，但是插入和删除时需要移动大量元素，如图
（2）链式存储
链式存储是指逻辑上相邻的元素在计算机内的存储位置不一定是相邻的。例如，哥哥张小明因为工作调动去了北京，弟弟仍然在郑州，他们的位置是不相邻的，但是哥哥有弟弟家的地址，很容易可以找到弟弟，就可以说他们是链式存储，如图
链式存储就像一个铁链子，一环扣一环才能连在一起。每个节点除了数据域，还有一个指针域，记录下一个元素的存储地址，如图
（3）散列存储
散列存储，又称哈希（Hash）存储，由节点的关键码值决定节点的存储地址。用散列函数确定数据元素的存储位置与关键码之间的对应关系，如图
（4）索引存储
索引存储是指除建立存储节点信息外，还建立附加的索引表来标识节点的地址。索引表由若干索引项组成。如果每个节点在索引表中都有一个索引项，则该索引表称为稠密索引。若一组节点在索引表中只对应于一个索引项，则该索引表称为稀疏索引。索引项的一般形式是关键字、地址，如图
抽象数据类型
抽象数据类型（Abstract Data Type, ADT）是将数据对象、数据对象之间的关系和数据对象的基本操作封装在一起的一种表达方式，它和工程中的应用是一致的。在工程项目中，开始编程之前，首先列出程序需要完成的功能任务，先不用管具体怎么实现，实现细节在项目后期完成，一开始只是抽象出有哪些基本操作。把这些操作项封装为抽象数据类型，等待后面具体实现这些操作。而其他对象如果想调用这些操作，只需要按照规定好的参数接口调用，并不需要知道具体是怎么实现的，从而实现了数据封装和信息隐藏。在C++中可以用类的声明表示抽象数据类型，用类的实现来实现抽象数据类型的具体操作。
抽象数据类型可以用以下的三元组来表示。
ADT抽象数据类型名{ 数据对象：&lt;数据对象的定义&gt; 数据关系：&lt;数据关系的定义&gt; 基本操作：&lt;基本操作的定义&gt; } ADT抽象数据类型名 抽象数据类型的主要作用是数据封装和信息隐藏，让实现与使用相分离。数据及其相关操作的结合称为数据封装。对象可以对其他对象隐藏某些操作细节，从而使这些操作不会受到其他对象的影响，这就是信息隐藏。抽象数据类型独立于运算的具体实现，使用户程序只能通过抽象数据类型定义的某些操作来访问其中的数据，实现了信息隐藏。
2 算法复杂度 我们对好的算法的评判标准主要是高效性、低存储性。
高效性：指算法运行效率高，即算法运行所消耗的时间短。我们用算法基本运算的执行次数来衡量算法的效率。因此将算法基本运算的执行次数作为时间复杂度的度量标准。
低存储性：指算法所需要的存储空间低。算法占用的空间大小称为空间复杂度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64bdd65698a56ed223b1a4666f12c879/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50d11b14343803dea355291386f1faa7/" rel="bookmark">
			asp.net core docker部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天尝试了asp.net core 在docker部署，采用的系统：win10+docker+ubuntu wsl2
拉去asp.net core示例代码 cd D:\gitcode\dotnet git clone https://github.com/dotnet/dotnet-docker 编译镜像，并运行 这里先把docker启动，使用wsl2，
cd D:\gitcode\dotnet\dotnet-docker\samples\aspnetapp # 编译镜像 docker build -t aspnetapp . # 运行容器 docker run -it --rm -p 5000:80 --name aspnetcore_sample aspnetapp build命令参数:
将镜像命名为aspnetapp在当前文件夹（末尾的句号）中查找Dockerfile 运行容器命令参数：
-it：分配伪 TTY，即使未附加也使其保持打开状态。 （与 --interactive --tty 的效果相同。）-rm：容器在退出时自动删除-p 将本地计算机上的端口 5000 映射到容器中的端口 80。–name 将容器命名为 aspnetcore_sample。指定 aspnetapp 映像。 效果 这里发现一个问题：每次刷新 cgroup memory usage都会增加。代码待研究。
后期研究复杂应用asp.net core webapi+nginx+mysql+redis在docker的部署。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d05d26917d8b7c985c962d75dbc1b1b8/" rel="bookmark">
			shell脚本中命名管道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 shell脚本中命名管道 管道是进程间通信的一种方式，使用|符号就是创建了一个匿名管道，但匿名管道只能实现父进程与子进程之间的通信。要实现任意两个进程之间的通信，需要使用命名管道，命名管道也叫FIFO文件
命名管道特征 FIFO文件创建后在文件系统中可以直接看到写入FIFO文件中的数据一旦被读取后，就不可以重复读取进程往FIFO文件中写数据时，如果没有其他进程读取数据，则写数据的进程会被阻塞，直到有其他进程读取数据进程从FIFO文件中读数据时，如果FIFO文件中没有数据，则读数据的进程会被阻塞，直到FIFO文件中被写入数据FIFO文件中的数据写在内存中，并不写入磁盘，读写效率更高 创建命名管道(FIFO文件) 使用mkfifo命令或mknod命令创建FIFO文件
[root@mao_aliyunserver bin]# ll total 4 -rw-r--r-- 1 root root 604 Feb 11 20:39 test.sh [root@mao_aliyunserver bin]# mkfifo fifo_file.txt [root@mao_aliyunserver bin]# ll total 4 prw-r--r-- 1 root root 0 Feb 11 22:06 fifo_file.txt -rw-r--r-- 1 root root 604 Feb 11 20:39 test.sh 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23a270b0192a327e8761f2b97e391bac/" rel="bookmark">
			Mongodb 一口气安装执行脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要参考：MongoDB 4.4.4分片集群配置全流程_richie696的专栏-CSDN博客_mongodb 分片集群配置
前面虽然参考了很多文档，但真正配置起来，踩坑真是无数
这边将conf配置文件和安装脚本分享一下，减少其他人继续踩坑
链接：https://pan.baidu.com/s/1akpNNfiiceyTXP7BVA_qfw 提取码：va0c
在第一台服务器上生成一个key文件后，然后拷贝到各台服务器目录中去使用
openssl rand -base64 756 &gt; /opt/mongodb/sharding-sync-key.file chmod 600 /opt/mongodb/sharding-sync-key.file #-----------------------------------------&lt;1&gt;在三台服务器上初始化配置-----------------------------------------# #!/bin/bash MONGO_DAT_HOME=/opt/mongodb MONGO_APP_HOME=/opt/mongodb-4.4.4 #强制杀掉启动的进程 ps aux | grep /opt/mongodb | awk '{print $2}' | xargs kill -9 #删除mongodb数据 sudo rm -r $MONGO_DAT_HOME/config sudo rm -r $MONGO_DAT_HOME/data sudo rm -r $MONGO_DAT_HOME/logs #创建目录 sudo mkdir -p $MONGO_APP_HOME sudo mkdir -p $MONGO_DAT_HOME/conf sudo mkdir -p $MONGO_DAT_HOME/config sudo mkdir -p $MONGO_DAT_HOME/data/27017 sudo mkdir -p $MONGO_DAT_HOME/data/27018 sudo mkdir -p $MONGO_DAT_HOME/data/27019 sudo mkdir -p $MONGO_DAT_HOME/logs #调整各个文件和目录的文件权限 chmod 755 $MONGO_APP_HOME/bin/* chmod 755 $MONGO_DAT_HOME/conf/* chmod 600 $MONGO_DAT_HOME/sharding-sync-key.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23a270b0192a327e8761f2b97e391bac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a28415ba0058f6284205cb14c615962/" rel="bookmark">
			解决LINUX下SSH连接超时自动断开的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行下列脚本
# 切换SSH目录 cd /etc/ssh # 查看sshd_config中关于客户端活动状态的配置 grep ClientAlive sshd_config #默认配置如下 #ClientAliveInterval 0 #ClientAliveCountMax 3 #修改文件内容 find -name 'sshd_config' | xargs perl -pi -e 's|#ClientAliveInterval 0|ClientAliveInterval 60|g' find -name 'sshd_config' | xargs perl -pi -e 's|#ClientAliveCountMax 3|ClientAliveCountMax 3|g' # 查看sshd_config中关于客户端活动状态的配置 grep ClientAlive sshd_config #重启ssh service sshd restart 参考：SSH登录Linux长时间不操作就会自动断开问题 - 何敏杰博客
解决LINUX(CENTOS)下SSH连接超时自动断开的问题_weixin_33727510的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aca0e1b598171c2f77fbf189b53a5256/" rel="bookmark">
			unity webgl获取页面Token信息，及加载StreamingAssets下.txt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接收JS端传回的token信息，如：
jwt~eyJhbGciOiJIUzI1NiIsIlR5cGUiOiJKd3QiLCJ0eXAiOiJKV1QifQ.eyJwYXNzd29yZCI6IjEyMzQ1NiIsImV4cCI6MTY0MjEzODIyNCwidXNlcm5hbWUiOiIxMTkwMjA1MTY5In0.ucdrtqfwOpaEzQkMHOWY7S_nvSTgOroRPa2T9y3H4q0
或者UserInf信息，如：
userinfo~{"id":111,"mobile":"18400000000","password":null,"photo":null,"qq":null,"sex":0,"sn":"100100100","username":"刘X","clazzId":null,"clazzNo":"2021122801","roleId":1,"createDate":"2021-12-29T09:21:58","updateDate":null,"creator":null,"updater":null}
在打包出来的web文件内找到index，做如下修改
&lt;script&gt; var gameInstance = UnityLoader.instantiate("gameContainer", "Build/TestDiaoYong2.json", {onProgress: UnityProgress}); if(!window.localStorage) { alert("浏览器不支持localstorage"); } else { //写入localStorage var storage=window.localStorage; }	&lt;/script&gt; 在打包出来的web文件内找到UnityProgress文件（路径：TemplateData/UnityProgress），做如下修改
if (progress == 1) { gameInstance.logo.style.display = gameInstance.progress.style.display = "none"; getLocalStorage(); } } function getLocalStorage(){ //读取localStorage,并调用函数传递信息到C# JSCommand('jwt~' + storage.getItem('jwt')); JSCommand('userinfo~' + storage.getItem('userinfo')); } //JS向C#传递信息 function JSCommand(str) { console.log("JSCommand--" + str); //三个参数：第一个参数是脚本所在物体名，第二个是脚本函数名，第三个是发送信息 gameInstance.SendMessage('MainScript', 'JSFunction', str); } 接下来在场景中创建对象（名字：MainScript（根据js的填写进行修改）） ，添加脚本（名字：MainSceneManager（可任意起）），脚本内方法如下：
（对服务返回数据进行处理时需要导入Dll文件到Unity工程中
dll链接：链接：https://pan.baidu.com/s/1TdyJYOnicoDYxmvv5Md46A 提取码：o0gx ）
using System.Collections; using UnityEngine; using UnityEngine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aca0e1b598171c2f77fbf189b53a5256/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/876cc1bc7a774a8a4807938e01eb87f9/" rel="bookmark">
			latex图片排版技巧总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 两图并排两图竖直排放，共享标题两图水平排放，共享标题两图竖直排放，独立标题两图水平排放，独立标题两图水平排放，统一大标题，独立子标题 四图并排四图水平摆放，统一大标题，两两独立子标题四图栅格摆放，统一大标题，两两独立子标题四图栅格摆放，统一大标题，独立子标题 总结方法一：使用宏包subfig(不推荐)方法二：使用宏包subfigure(推荐) 两图并排 两图竖直排放，共享标题 \begin{figure}[htbp] \centering \includegraphics[width=0.2\textwidth]{number_1.jpg} \\ \includegraphics[width=0.2\textwidth]{number_2.jpg} \caption{两图竖直摆放，共享标题} \label{fig:ver_2figs_1cap} \end{figure} 两图水平排放，共享标题 \begin{figure} \begin{minipage}[t]{0.5\linewidth} \centering \includegraphics[width=2.2in]{number_1.jpg} \end{minipage} \begin{minipage}[t]{0.5\linewidth} \centering \includegraphics[width=2.2in]{number_2.jpg} \end{minipage} \caption{两图水平摆放，共享标题} \label{fig:hor_2figs_1cap} \end{figure} 两图竖直排放，独立标题 \begin{figure} \centering \begin{minipage}[t]{0.5\linewidth} \centering \includegraphics[width=2.2in]{number_1.jpg} \caption{标题一} \label{fig:ver_2figs_2cap_1} \end{minipage} \\ \begin{minipage}[t]{0.5\linewidth} \centering \includegraphics[width=2.2in]{number_2.jpg} \caption{标题二} \label{fig:ver_2figs_2cap_2} \end{minipage} \end{figure} 两图水平排放，独立标题 \begin{figure} \begin{minipage}[t]{0.5\linewidth} \centering \includegraphics[width=2.2in]{number_1.jpg} \caption{标题一} \label{fig:hor_2figs_2cap_1} \end{minipage} \begin{minipage}[t]{0.5\linewidth} \centering \includegraphics[width=2.2in]{number_2.jpg} \caption{标题二} \label{fig:hor_2figs_2cap_2} \end{minipage} \end{figure} 两图水平排放，统一大标题，独立子标题 \begin{figure} \centering \subfigure[子标题一]{ \begin{minipage}[b]{0.2\textwidth} \includegraphics[width=1\textwidth]{number_1.jpg} \end{minipage} \label{fig:hor_2figs_1cap_2subcap_1} } \subfigure[子标题二]{ \begin{minipage}[b]{0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/876cc1bc7a774a8a4807938e01eb87f9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/161/">«</a>
	<span class="pagination__item pagination__item--current">162/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/163/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>