<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc160b075d560fa170b191428df0c2a9/" rel="bookmark">
			关于DBSCAN聚类算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本概念 DBSCAN（Density-Based Spatial Clustering of Application with Noiso）:具有噪声的基于密度的聚类方法。从名字中就可以看出来，簇划分是根据样本密度来决定的。在了解算法具体过程之前，需要先了解一下相关的基本概念：
ϵ-邻域：样本x以ϵ为半径的范围内包含的所有样本的集合
核心对象：样本x的ϵ-领域内样本数大于阈值MinPts，则x为核心对象
直接密度可达：若某点p在点q的ϵ-邻域内，且q是核心点，则p由q直接密度可达。
密度相连：若从某核心点p出发，点q和点k都是密度可达的 ,则称点q和点k是密度相连的。
DBSCAN的基本思想：由密度可达导出的最大密度相连的集合作为一个簇。
算法流程 (1)将所有的样本标记为未访问状态
(2)随机选择一个未访问对象P，将其标记为已访问
(3)如果p为核心对象，创建一个新簇C，将q添加到C中
(4)对于C中的每一个样本q，如果q为核心对象，遍历其ϵ-邻域内的所有样本x：
a.如果x未被访问，则标记为已访问，将x添加到C中
b.如果x已被访问但是不属于任何一个簇，将x添加到C中
c.对C中的每个元素重复步骤a、b
(5)重复(2)到(4),直到没有未被访问的样本
(6)输出所有簇划分
DBSCAN类重要参数 DBSCAN类的重要参数也分为两类，一类是DBSCAN算法本身的参数，一类是最近邻度量的参数，下面我们对这些参数做一个总结。
1）eps： DBSCAN算法参数，即我们的ϵϵ-邻域的距离阈值，和样本距离超过ϵϵ的样本点不在ϵϵ-邻域内。默认值是0.5.一般需要通过在多组值里面选择一个合适的阈值。eps过大，则更多的点会落在核心对象的ϵϵ-邻域，此时我们的类别数可能会减少， 本来不应该是一类的样本也会被划为一类。反之则类别数可能会增大，本来是一类的样本却被划分开。
2）min_samples： DBSCAN算法参数，即样本点要成为核心对象所需要的ϵϵ-邻域的样本数阈值。默认值是5. 一般需要通过在多组值里面选择一个合适的阈值。通常和eps一起调参。在eps一定的情况下，min_samples过大，则核心对象会过少，此时簇内部分本来是一类的样本可能会被标为噪音点，类别数也会变多。反之min_samples过小的话，则会产生大量的核心对象，可能会导致类别数过少。
3）metric：最近邻距离度量参数。可以使用的距离度量较多，一般来说DBSCAN使用默认的欧式距离（即p=2的闵可夫斯基距离）就可以满足我们的需求。可以使用的距离度量参数有：
a) 欧式距离 “euclidean”:
b) 曼哈顿距离 “manhattan”：
c) 切比雪夫距离“chebyshev”: d) 闵可夫斯基距离 “minkowski”: e) 带权重闵可夫斯基距离 “wminkowski”:
f) 标准化欧式距离 “seuclidean”: 即对于各特征维度做了归一化以后的欧式距离。此时各样本特征维度的均值为0，方差为1.
g) 马氏距离“mahalanobis”：
其中，S的-1次方为样本协方差矩阵的逆矩阵。当样本分布独立时， S为单位矩阵，此时马氏距离等同于欧式距离。
4）algorithm：最近邻搜索算法参数，算法一共有三种，第一种是蛮力实现，第二种是KD树实现，第三种是球树实现。这三种方法在K近邻法(KNN)原理小结中都有讲述，如果不熟悉可以去复习下。对于这个参数，一共有4种可选输入，‘brute’对应第一种蛮力实现，‘kd_tree’对应第二种KD树实现，‘ball_tree’对应第三种的球树实现， ‘auto’则会在上面三种算法中做权衡，选择一个拟合最好的最优算法。需要注意的是，如果输入样本特征是稀疏的时候，无论我们选择哪种算法，最后scikit-learn都会去用蛮力实现‘brute’。个人的经验，一般情况使用默认的 ‘auto’就够了。 如果数据量很大或者特征也很多，用"auto"建树时间可能会很长，效率不高，建议选择KD树实现‘kd_tree’，此时如果发现‘kd_tree’速度比较慢或者已经知道样本分布不是很均匀时，可以尝试用‘ball_tree’。而如果输入样本是稀疏的，无论你选择哪个算法最后实际运行的都是‘brute’。
5）leaf_size：最近邻搜索算法参数，为使用KD树或者球树时， 停止建子树的叶子节点数量的阈值。这个值越小，则生成的KD树或者球树就越大，层数越深，建树时间越长，反之，则生成的KD树或者球树会小，层数较浅，建树时间较短。默认是30. 因为这个值一般只影响算法的运行速度和使用内存大小，因此一般情况下可以不管它。
6） p: 最近邻距离度量参数。只用于闵可夫斯基距离和带权重闵可夫斯基距离中p值的选择，p=1为曼哈顿距离， p=2为欧式距离。如果使用默认的欧式距离不需要管这个参数。
以上就是DBSCAN类的主要参数介绍，其实需要调参的就是两个参数eps和min_samples，这两个值的组合对最终的聚类效果有很大的影响。
可直接使用sklearn库进行调用：
from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc160b075d560fa170b191428df0c2a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7c4de521763eadd1fb950b910b47681/" rel="bookmark">
			Spring依赖注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring ioc容器初始化好bean的实例对象之后，会对该对象中的属性进行初始化，初始化的过程依然是由容器自动来完成，这个被称为是依赖注入（dependency injection缩写是DI）。spring里面常用的注入方式有两种，setter方法注入，构造方法注入。
还有一种方式是实现特定接口注入。由于这种方式采用侵入式编程，污染代码，所以已经不用了。
基于XML配置文件的依赖注入
setter方法注入
容器通过调用setter方法将对象注入，这种方式比较简单，所以使用的概率比较高。
示例：
创建一个UserDao接口和其实现类：
public interface UserDao { void addUser(); } 实现类：
public class UserDaoImpl implements UserDao { @Override public void addUser() { System.out.println("添加学生数据"); } } 创建UserService接口和其实现类：
public interface UserService { void addUser(); } 实现类，里面添加UserDao的变量，并创建setter和getter方法：
public class UserServiceImpl implements UserService { private UserDao userDao; @Override public void addUser() { //以前如果需要使用UserDao对象的时候，需要在这里创建对象 //userDao = new UserDaoImpl(); //使用spring之后，由spring为我们创建对象 userDao.addUser(); } public UserDao getUserDao() { return userDao; } public void setUserDao(UserDao userDao) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7c4de521763eadd1fb950b910b47681/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f147d75731e2f49df535bf45ae7060a5/" rel="bookmark">
			LeetCode简单题之寻找数组的中心下标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 给你一个整数数组 nums ，请计算数组的 中心下标 。
数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。
如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。
如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。
示例 1：
输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
示例 2：
输入：nums = [1, 2, 3]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f147d75731e2f49df535bf45ae7060a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba01c51763b77d6b0dc4efa738021e70/" rel="bookmark">
			linux内核的ip头校验和测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试程序：
#include "stdio.h" #include "stdlib.h" typedef __signed__ char __s8; typedef unsigned char __u8; typedef __signed__ short __s16; typedef unsigned short __u16; typedef __signed__ int __s32; typedef unsigned int __u32; typedef __signed__ long __s64; typedef unsigned long __u64; typedef __s8 s8; typedef __u8 u8; typedef __s16 s16; typedef __u16 u16; typedef __s32 s32; typedef __u32 u32; typedef __s64 s64; typedef __u64 u64; #ifdef __CHECKER__ #define __bitwise__ __attribute__((bitwise)) #else #define __bitwise__ #endif #define __bitwise __bitwise__ typedef __u16 __bitwise __le16; typedef __u16 __bitwise __be16; typedef __u32 __bitwise __le32; typedef __u32 __bitwise __be32; typedef __u64 __bitwise __le64; typedef __u64 __bitwise __be64; typedef __u16 __bitwise __sum16; typedef __u32 __bitwise __wsum; struct iphdr { __u8 ihl:4, version:4; __u8 tos; __be16 tot_len; __be16 id; __be16 frag_off; __u8 ttl; __u8 protocol; unsigned short check; __be32 saddr; __be32 daddr; }; static inline unsigned short ip_fast_csum(const void *iph, unsigned int ihl) { unsigned int sum; asm("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba01c51763b77d6b0dc4efa738021e70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0c70dd3d0c22203bd8cf8bd24e86108/" rel="bookmark">
			Android S 12 行为变更：所有应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 12 平台包含一些行为变更，这些变更可能会影响您的应用。以下行为变更将影响在 Android 12 上运行的所有应用，无论采用哪种 targetSdkVersion 都不例外。您应该测试您的应用，然后根据需要进行修改，以适当地支持这些变更。
此外，请务必查看仅影响以 Android 12 为目标平台的应用的行为变更列表。
用户体验 拉伸滚动效果 在搭载 Android 12 及更高版本的设备上，滚动事件的视觉行为发生了变化。
在 Android 11 及更低版本中，滚动事件会使视觉元素发光。在 Android 12 及更高版本中，发生拖动事件时，视觉元素会拉伸和反弹；发生快速滑动事件时，它们会快速滑动和反弹。
如需了解详情，请参阅动画演示滚动手势指南。
应用启动画面 如果您之前在 Android 11 或更低版本中实现了自定义启动画面，则需要将您的应用迁移到 SplashScreen API，以确保它从 Android 12 开始正确显示。如果不迁移您的应用，则可能会导致应用启动体验变差或出乎预期。
如需了解相关说明，请参阅将现有的启动画面实现迁移到 Android 12。
此外，从 Android 12 开始，在所有应用的冷启动和温启动期间，系统始终会应用新的 Android 系统默认启动画面。 默认情况下，此系统默认启动画面由应用的启动器图标元素和主题的 windowBackground（如果是单色）构成。
如需了解详情，请参阅启动画面开发者指南。
网络 intent 解析 从 Android 12（API 级别 31）开始，仅当您的应用获准处理某个通用网络 intent 中包含的特定网域时，该网络 intent 才会解析为应用中的 activity。如果您的应用未获准处理相应的网域，则该网络 intent 会解析为用户的默认浏览器应用。
应用可通过执行以下某项操作来获准处理相应的网域：
使用 Android App Links 验证网域。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0c70dd3d0c22203bd8cf8bd24e86108/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10f0ebb51438baf1dc10c9b0d81e57d5/" rel="bookmark">
			No matching distribution found for panda（cmd中安装panda时报错）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错界面：
解决办法：
当直接使用pip install panda报该错误的时候，我们可以通过换源来解决：
pip install panda -i https://pypi.tuna.tsinghua.edu.cn/simple/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7078e8ad19d256ebb6237de0af0a5436/" rel="bookmark">
			undefined: There is no template at js/tmpl/login.ejs undefined/ Rabbitmq页面突然打不开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题：Rabbitmq页面突然打不开 正在使用中，“上网”查资料，再用rabbitmq就突然不能用了😭
2.解决：关闭“梯子” 中途查资料，打开“梯子”，导致不能用rabbitmq
3.解决过程 我在docker中部署rabbitmq
3.1 刷新页面 —此时没用 3.2 重启rabbitmq —此时没用 1 docker 启动与停止
systemctl start docker # docker 启动 systemctl stop docker # docker 停止 systemctl restart docker # docker 重启 启动安装好的容器名/服务名
docker start 容器名 停止正在运行的容器
docker stop 容器名 3.3 电脑浏览器页面打不来，手机却可以 手机可以证明，服务器部署的rabbitmq没问题。由此，推出异常“梯子”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6d22cf5abbe278e8fc25a87cff788ba/" rel="bookmark">
			防火墙的基本概念和分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		防火墙的概念 “防火墙”一词起源于建筑领域，用来隔离火灾，阻止火势从一个区域蔓延到另一个区域。引入到通信领域，防火墙这一具体设备通常用于两个网络之间有针对性的、逻辑意义上的隔离。当然，这种隔离是高明的，隔离的是“火”的蔓延，而又保证“人”的穿墙而过。这里的“火”是指网络中的各种攻击，而“人”是指正常的通信报文。
用通信语言来定义，防火墙主要用于保护一个网络区域免受来自另一个网络区域的网络攻击和网络入侵行为。因其隔离、防守的属性，灵活应用于网络边界、子网隔离等位置，具体如企业网络出口、大型网络内部子网隔离、数据中心边界等等。
从实现的方式来看，防火墙可以分为硬件防火墙和软件防火墙。硬件防火墙是通过硬件与软件的结合来达到隔离内外部网络的目的，而软件防火墙则是通过纯软件的方式来实现。
防火墙的作用 防火墙能够隔离风险区域和安全区域，但不会妨碍人们对风险区域的访问。从总体上看，防火墙应该具有以下基本功能：
（2）限制未授权用户进入内部网络，过滤掉不安全的服务和非法用户。
（3）防止入侵者接近内部网络的防御设施，对网络攻击进行检测和报警。
（4）限制内部用户访问特殊站点。
（5）记录通过防火墙的信息内容和活动。
防火墙的技术特点 而一个好的防火墙系统应该具备以下特性：
（1）所有在内部网络和外部网络之间传输的数据都必须经过防火墙。
（2）只有被授权的合法数据即安全策略允许的数据才允许通过防火墙。
（3）防火墙本身具有预防入侵的功能，不受各种攻击的影响。
（4）人机交互界面良好，用户配置方便、易管理。
防火墙的分类 （1）网络层防火墙
网络层防火墙可视为一种 IP 封包过滤器，运作在底层的TCP/IP协议堆栈上。我们可以以枚举的方式，只允许符合特定规则的封包通过，其余的一概禁止穿越防火墙（病毒除外，防火墙不能防止病毒侵入）。这些规则通常可以经由管理员定义或修改，不过某些防火墙设备可能只能套用内置的规则。我们也能以另一种较宽松的角度来制定防火墙规则，只要封包不符合任何一项“否定规则”就予以放行。
（2）应用层防火墙
应用层防火墙是在 TCP/IP 堆栈的“应用层”上运作，您使用浏览器时所产生的数据流或是使用 FTP 时的数据流都是属于这一层。应用层防火墙可以拦截进出某应用程序的所有封包，并且封锁其=他的封包（通常是直接将封包丢弃）。理论上，这一类的防火墙可以完全阻绝外部的数据流进到受保护的机器里。防火墙借由监测所有的封包并找出不符规则的内容，可以防范电脑蠕虫或是木马程序的快速蔓延。根据侧重不同，可分为：包过滤型防火墙、应用层网关型防火墙、服务器型防火墙。
（3）数据库防火墙
数据库防火墙是一款基于数据库协议分析与控制技术的数据库安全防护系统。基于主动防御机制，实现数据库的访问行为控制、危险操作阻断、可疑行为审计。数据库防火墙通过SQL协议分析，根据预定义的禁止和许可策略让合法的SQL操作通过，阻断非法违规操作，形成数据库的外围防御圈，实现SQL危险操作的主动预防、实时审计。数据库防火墙面对来自于外部的入侵行为，提供SQL注入禁止和数据库虚拟补丁包功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eef8f2eeeaf824e327beea1c312b27b0/" rel="bookmark">
			Linux源码包安装和RPM包安装区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、区别
1、安装前：概念上不同。
1.1、RPM包是二进制包，源码包就是C语言文件。
2、安装后：安装位置的不同
1.1、RPM包安装位置是安装在多个位置，这不是由安装人决定的，而是由RPM包的作者决定的。
3、其他
3.1、RPM包安装后访问效率较低，源码包访问效率高。所以安装访问量大的服务的时候建议使用源码包安装，Apache就强烈建议使用源码包安装。
3.2、RPM虽然也可以指定位置，但是不建议指定位置安装RPM包，因为安装之后系统找不到命令，就不可以用RPM的命令来启动和关闭了。
二、启动与停止
1、RPM
启动服务： 1、使用绝对路径方式启动：/etc/rc.d/init.d/httpd start (linux标准启动方法)
2、service httpd start (redhat系列专有命令)
停止服务：service httpd stop
2、源码包
2.1、启动服务： /usr/local/apache2/bin/apachectl start
2.2、怎么知道这个启动命令的？
进入源码包目录，在这个目录下有一个INSTALL文件，打开文件可以发现安装和启动方法。
三、源码包安装位置
1、默认安装位置：/usr/local/软件名/
2、启动方法：/usr/local/apache2/bin/apachectl start
3、源码包保存位置：/usr/local/src/
四、安装
1、./configure 软件配置与检查(进入解压缩目录后都会有configure这个命令)
1.1、定义需要的功能选项
1.2、检测系统环境是否符合安装要求
1.3、把定义好的功能选项和检测环境系统信息都写入Makefile文件，用于后续的编辑
说明：a、每个源码包都会有configure命令，就算极个别没有这个命令也会用其他的命令取代
b、执行过./configure之后，会生成Makefile文件，make和make install都是依赖这个文件进行编译安装的，
此处安装假设： ./configure --prefix=/usr/local/apache2/
2、make：编译
2.1、将源码包翻译成机器能识别的语言
2.2、一旦编译出错，可使用make clean，清除之前的编译。
说明：这一步执行时间一般是最长的。
3、make install
3.1、真正进行安装
3.2、一旦这一步报错，那要执行两步：
1、make clean
2、直接删除/usr/local/apache2/这个目录即可。
五、卸载
1、源码包卸载：直接删除安装目录即可，不会残留任何垃圾。
2、RPM包卸载：rpm -e 软件名
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8efc20966122bd1a35c1009683c6238/" rel="bookmark">
			VSCode安装LeetCode插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VSCode安装LeetCode插件 一、LeetCode插件安装 在VScode的Extensions中搜索LeetCode，并点击install安装。
二、登录 输入账号密码登录，可能会报错：
login: (node:22564) Warning: Accessing non-existent property ‘padLevels’ of module exports inside circular dependency
(Use node --trace-warnings ... to show where the warning was created)
pass: - Signing in leetcode.com
[ERROR] invalid password?
解决方法：
点击如下图标，切换为力扣中文版（如果是在中文版注册的账号）。
三、设置默认语言、存储地址 在VSCode的Setting中，可以设置默认的编程语言，和代码的存储位置，如下图所示：
四、其它报错 4.1 无法预览题目 Error loading webview: Error: Could not register service workers: InvalidStateError: Failed to register a ServiceWorker: The document is in an invalid state…
解决方法：重启VSCode。
4.2 提交代码时，报错[ERROR] session expired, please login again [code=-1] 解决方法：在力扣网站个人账号信息处，验证邮箱。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b9f51df5e525c3836e44535fc121fe1/" rel="bookmark">
			SpringSecurity权限记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		server 1、访问过滤器
code模式访问：http://localhost:8000/oauth/authorize?response_type=code&amp;client_id=test_client&amp;scope=read&amp;state=test&amp;redirect_uri=http://baidu.com
AnonymousAuthenticationFilter拦截进入登陆页面
if (SecurityContextHolder.getContext().getAuthentication() == null) {
SecurityContextHolder.getContext().setAuthentication(
createAuthentication((HttpServletRequest) req));
}
2、AbstractSecurityInterceptor spring SPEL比对类方法信息，属性比较
this.accessDecisionManager.decide(authenticated, object, attributes);
（ spel初始化见：ExpressionBasedFilterInvocationSecurityMetadataSource WebExpressionConfigAttribute）
代码例子
@Test public void expressionParserTest() { ExpressionParser parser = new SpelExpressionParser(); Expression exp = parser.parseExpression("permitAll()"); //使用自定义容器 StandardEvaluationContext ctx = new StandardEvaluationContext(); ctx.setRootObject(new SecurityExpressionRoot()); System.out.println(exp.getValue(ctx)); } class SecurityExpressionRoot { public final boolean permitAll() { return true; } public final boolean denyAll() { return false; } } 3、认证
AbstractUserDetailsAuthenticationProvider
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b9f51df5e525c3836e44535fc121fe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41f3b86759d1ad8977eb68fc22b38fc8/" rel="bookmark">
			centos7部署oracle19c-最简单的安装方式-rpm安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle部署 曾经被oracle的部署方式折磨的死去活来，最近突发奇想又想再来一次，结果打开oracle官网，忽然发现竟然可以这样~
竟然有RPM包了，
1. 下载安装包 总共需要上图所示两个包，较大的2.5G的包可按照第一张图片位置下载即可，较小的包下载地址：
http://yum.oracle.com/repo/OracleLinux/OL7/latest/x86_64/getPackage/oracle-database-preinstall-19c-1.0-1.el7.x86_64.rpm
2. 先安装rpm包 按照下面顺序安装，顺序不能乱
yum -y install oracle-database-preinstall-19c-1.0-1.el7.x86_64.rpm yum -y install oracle-database-ee-19c-1.0-1.x86_64.rpm 如果安装过程提示少了一些依赖库，安装下依赖库就行
3. 创建数据库 /etc/init.d/oracledb_ORCLCDB-19c configure 执行上面的命令，等待完成，这一步时间可能会稍微长一点。
4. 最后一步 4.1 oracle设置密码 以上过程会将oracle用户，组都创建好，我们设置个密码，为了可以登录就行
passwd oracle 4.2 环境变量设置 可以再很多地方配置：/etc/profile、/etc/bashrc、/home/oracle/.bashrc等环境变量配置文件配置皆可。在文件末尾加上以下几行
export ORACLE_BASE=/opt/oracle export ORACLE_HOME=/opt/oracle/product/19c/dbhome_1 export ORACLE_SID=ORCLCDB export PATH=$ORACLE_HOME/bin:$PATH:$HOME/.local/bin:$HOME/bin 而后，生效一下配置文件，
source /etc/bashrc 4.3 登录 到此为止，所有配置基本完成
切换oracle用户，可以登录：
sqlplus / as sysdba 5. 创建用户并登录 启动数据库：
SQL&gt; STARTUP; ORACLE instance started. Total System Global Area 406844688 bytes Fixed Size	9135376 bytes Variable Size	276824064 bytes Database Buffers	117440512 bytes Redo Buffers	3444736 bytes Database mounted.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41f3b86759d1ad8977eb68fc22b38fc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f39b0ec3d9c3e7b34f0d2554bab38916/" rel="bookmark">
			为什么Spring中的对象默认要设计成单例的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 :
为什么要设计成单例
单例的bean如何解决线程安全问题
对于第一点，可以理解为为了简化资源消耗，因为每有一个请求打到Controller层十，如果该Controller是原型，那么就会重新实例化一个对象，这样对于高并发的情况下消耗是相当大的，所以设计为单例，所有请求访问的都是同一个对象。
但是这样就会有一个缺点，那就是多线程的情况下如何解决线程安全问题，因为你都是访问的同一个controller对象啊，假如此时多个线程同时访问该controller的同一个方法(假设该方法对实例变量进行了操作)，那不就有线程安全问题了吗？那你说可以在需要的方法上加上悲观锁不就好了，频繁的线程切换会消耗大量cpu时间，在高并发惜时如金的情况下显然不合适，所以可以采用以“空间”换“时间”的做法：
threadlocal
常见的有RequestContextHolder、TransactionSynchronizationManager等都是采用threadlocal，其中RequestContextHolder的作用是获取当前请求的上下文，比如request、session这些，在没有threadlocal的情况下，我们大概要写一个加了悲观锁的静态方法，方法内容是获取当前线程的request对象，然后当前线程作为key，request对象作为value存到一个全局map里面。
有了threadlocal之后，我只需将request对象set入当前线程thread的Threadlocal.threadlocalmap属性中，threadlocal实际上并没啥用，只是起到一个“钩子”的作用，存值的时候负责用set方法把request对象甩到当前线程的threadlocalmap的entry[]数组中，取值的时候负责将threadlocalmap的entry[]数组对应的值从当前线程中“钩”出来（是通过threadlocal来作为key从entry[]中存取值，所以叫钩子）：
除上图中的方法还有其他封装threadlocal的方法，这里就不细谈了。
题外话
部分面试题springbean单例是线程安全的吗, 其实问题本身有歧义, springbean和线程安全没有关系, spring只是提供了一个容器用于管理实例, 单例还是原型区别只是整个过程是否使用同一实例, spring不能也无法预知你代码内容是否造成线程安全问题, 你需要做的是自行注意代码线程安全问题, 所以相对于面视的时候直接抛出这个问题, 还不如待面试者回答完单例或原型的基础概念后, 抛砖引玉地来一句: “既然单例模式全程只使用同一个实例, 那如果我代码中有操作成员变量地代码, 那如何在多个请求打到这个实例上的时候保证线程安全?”, 问题清晰明了, 又能凸显面试官职业水平
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f55fc1b51d56702e785ad369028d3b26/" rel="bookmark">
			服务器安装 Ubuntu 系统完成重启后花屏、紫屏解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器安装 Ubuntu 系统时一切正常，安装完成重启后还没进登录页面就花屏，如下图
很多方法不好使，直接换显示器，好了！！！！！！！！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92c0befac7d9127104a4d055e8b5b9a6/" rel="bookmark">
			记一次 K8s 控制平面排障的血泪经历！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集群以及环境信息的信息：
k8s v1.18.4
3 节点 Master 均为 8 核 16Gi, 50Gi-SSD
差异化配置的 19 节点 Minion
control-plane 组件 (kube-apiserver,etcd,kube-controller-manager, kube-scheduler) 以 static-pod 的模式进行部署
3 个 kube-apiserver 前端有一个 VIP 进行流量的 LoadBalance
腾讯云的 SSD 性能大概是 130MB/s
故障描述 在 2021-9-10 下午“诡异”的事情开始出现：kubectl 偶尔卡住无法正常 CRUDW 标准资源 (Pod, Node 等)，此时已经意识到是部分的 kube-apiserver 无法正常工作，然后尝试分别接入 3 台 kube-apiserver 所在宿主机，发现以下不正常的情况：
现场的信息 k8s control-plane kube-apiserver Pod 信息 $ kubectl get pods -n kube-system kube-apiserver-x.x.x.x -o yaml ... containerStatuses: - containerID: docker://xxxxx .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92c0befac7d9127104a4d055e8b5b9a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d8ad8bb93b3f80e31733bb9f297cb80/" rel="bookmark">
			华为云Centos7搭建hadoop集群三：jdk，hadoop安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为云Centos7搭建hadoop集群三：jdk，hadoop安装
使用hadoop用户，在/opt下面创建module文件夹，并将权限赋值给hadoop用户
–如果使用root用户 直接创建即可
sudo chown hadoop:hadoop module/
第一个用户是属主信息，第二个用户是属组信息
将jdk，hadoop上传到云服务器后，解压到指定文件夹
sudo tar -zxvf /data/jdk-8u212-linux-x64.tar.gz -C /opt/module/
sudo tar -zxvf /data/hadoop-3.1.3.tar.gz -C /opt/module/
配置环境变量，新建环境变量文件配设置hadoop与jdk目录，配置后记得source生效，java与hadoop验证版本
sudo vi /etc/profile.d/my_env.sh 每个节点都配置
source /etc/profile
java -version
hadoop version
另外两个节点创建/opt/module 目录
将jdk与hadoop分发到另外两台节点
安装hadoop，进入hadoop文件夹
我配置的是高可用的namenode，节点选择hadoop01.hadoop02
高可用的resourcemanager，节点选择hadoop01，hadoop02
yarn历史服务器，节点选择hadoop03
因为配置高可用，所以需要先安装zookeeper，节点三台全部安装
先将zookeeper上传解压到/opt/module/并重命名
tar -zxvf /data/apache-zookeeper-3.5.7-bin.tar.gz -C /opt/module/
mv apache-zookeeper-3.5.7-bin/ zookeeper-3.5.7
在zk目录下新建data文件夹
mkdir data
进入zk的conf目录
将zoo_sample.cfg 为 zoo.cfg
修改zoo.cfg配置文件，将dataDir修改为创建的data文件夹，增加zk的server信息
server分别为服务器编号，服务器节点，内部与leader通信端口，选举leader端口，zk对外的连接端口为2181
进入zk的data目录下，新建一个myid文件，配置与server对应的节点编号对应，如hadoop01，就配置1来对应Server.1
将zk从01分到到02，03节点，过程省略，并且要记得修改另外两台节点的myid信息，因为同步的数据myid为1可以使用vi，或者
使用echo 2 &gt; myid ,这里的 &gt; 表示覆盖写入的意思，03节点对应echo 3 &gt; myid
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d8ad8bb93b3f80e31733bb9f297cb80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1e07031dce3f25b005fbdf4715dc88d/" rel="bookmark">
			C&#43;&#43; | boost库入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、boost库简介
二、boost库安装及编译
1.目录结构说明
2.编译静态库
3.构建工具b2 三、boost库的简单使用
一、boost库简介 Boost是一个功能强大 , 构造精良 , 跨越平台 , 代码开源 , 完全免费的 C ++ 程序库。
功能强大 共包含 160 余个库 / 组件 , 涵盖字符串与文本处理、容器、迭代器、算法、图像处理、模板元编程、并发编程等多个领域。
构造精良 由 c ++ 标准委员会成员发起倡议并建立 boost 社区 , C ++11 标准库中三分之二来自 boost , 并且将来还会有更多的库进入 c ++ 标准库 , 因此 boost 是一个 c ++ " 准 " 标准库。
跨越平台 支持现有的所有操作系统。
代码开源，完全免费 Boost的发布采用Boost Software License，这是一个不同于GPL和Apache的非常宽松的许可证（许可证相关知识可查看秒懂开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别），该许可证允许库用户将Boost用于任何用途，既鼓励非商业用途，也鼓励商业用途。用户无须支付任何费用，不受任何限制，即可轻松享有Boost的全部功能。
Boost库的大多数组件不需要编译链接，我们在自己的源码里直接包含头文件即可。（注意：包含头文件的时候需要有boost目录，即#include "boost/logic/tribool.hpp"，而不能是#include "logic/tribool.hpp"）剩下的少量库（如chrono、date_time、program_options、test、thread等）必须编译成静态库或动态库，并在构建时指定链接选项才能使用。
Boost的独特之处：它把C++类的声明和实现放在了一个文件中，而不是分成两个文件，即.h+.cpp，故文件的后缀是.hpp。
二、boost库安装及编译 1.目录结构说明 在boost官网下载boost压缩文件（我用的是boost_1_74_0.zip这个版本），解压后主要目录结构说明如下：
--boost：最重要的目录 , 90 % 以上的 Boost 程序库源码都在这里
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1e07031dce3f25b005fbdf4715dc88d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d64f35a91743f7868541ec7337377dc/" rel="bookmark">
			Go遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 配置 MacOs 修改GO111MODULE环境变量出错 warning: go env -w GO111MODULE=… does not override conflicting OS environment variable 原因是在设置的时候，系统的环境变量GO111MODULE已经有值，而go env是不支持覆盖写入的。但是可以修改系统文件.bash_profile 或者直接操作系统环境变量
所以使用export直接改变系统环境变量
export GO111MODULE=off 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e514875aff7f4e71873306b7bd09dfe4/" rel="bookmark">
			GPS从入门到放弃（九）、伪距与载波相位 （扩展）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感谢 GNSS伪距及载波相位观测模型_Chaoz3的博客-CSDN博客_载波相位观测方程
前言 最小二乘与卡尔曼滤波是目前GNSS定位中主流的二类平差滤波方法，而构建观测模型是此二类方法的关键步骤。本篇从伪距和载波相位观测方程出发，推导了伪距单点定位，RTK相对定位，历元间三差相对定位中的观测模型。主要参考RTKLIB、《GPS测量与数据处理》及《GPS原理与接收机设计》书籍。
一、观测方程 1、伪距、载波相位观测方程
其中，p为伪距观测值(单位m)，r为真实卫地距(单位m)，c为光速(单位m/s)，光速乘的那部分为接收机钟差及卫星钟差(单位s)，I为电离层延迟(单位m)，T为对流层延迟(单位m),φ为载波相位观测值(单位rad)，λ为载波波长(单位m),N为整周模糊度(单位rad)。伪距观测及载波相位观测中都在方程尾引入了测量噪声项，代表了所有未直接体现在方程中的误差总和，为了方便公式书写，后续将其忽略。
2、单差、双差、三差观测方程 单差观测： 伪距观测及载波相位观测在流动站与基准站之间求一次差，可以消除卫星钟差，在短基线情况下（基站流动站之间的距离不超过10km），可以消去电离层和对流层延迟误差，忽略测量噪声项，得到如下观测方程：
双差观测： 单差观测在同系统卫星p与卫星q之间作二次差，可消去接收机钟差，得到双差观测方程：
三差观测： 双差观测在此历元与上一历元之间作三次差，可消去双差整周模糊度参数（常量），得到三差观测方程：
二、观测模型 1、伪距单点定位（SPP）最小二乘观测模型 伪距观测方程中的r为真实的卫地距，由于真实接收机位置未知，真实卫地距是无法计算的，我们只能给定一个大致的接收机位置[x, y, z]（ECEF_xyz坐标系下，后续默认都在此坐标系下），可求得卫星与接收机大致位置之间卫地距ρ：
真实卫地距r:
在真实位置处泰勒展开并取一阶项，可得：
则伪距观测方程可写为：
通过上式我们可以构建最小二乘的几个矩阵：
然后通过最小二乘求解公式完成一次位置的迭代更新：
上式中的P为伪距观测的权值矩阵，一般通过卫星高度角定权模型给出，迭代计算10次以下（RTKLIB）就可收敛得到伪距单点定位结果。
2、载波相位相对定位（RTK）卡尔曼滤波浮点解量测模型 浮点解求解使用伪距及载波相位双差观测，双差观测方程：
上式的r为真实双差卫地距，用下标i表示流动站，j表示基站（基站由于真实坐标已知，认为真实卫地距已知），上标p表示卫星p，q表示卫星q，代入真实卫地距线性化结果并站间作差星间作差可得：
上式代入双差观测方程：
通过上式我们可以构造卡尔曼滤波量测模型，根据状态参数的不同，主要有以下两种构造方式：
（1）以单差模糊度参数作为状态量（RTKLIB）
根据状态量的不同对双差观测方程进行适当的变换：
根据上式，可以构建卡尔曼滤波浮点解求解的量测模型（假设观测到N颗卫星，以第一颗卫星作为双差基准星）：
V(t)为双差观测量的误差，一般是通过伪距误差（事先设定的定值）及载波相位误差（事先设定的定值）通过双差变化得到。
（2）以双差模糊度误差作为状态量
将双差模糊度的误差（整数）分离出来，得到观测方程：
带-上标的N表示为上一历元双差模糊度的最优估计，根据上式，构建卡尔曼滤波浮点解求解的量测方程（假设观测到N颗卫星，以第一颗卫星作为双差基准星）：
然后通过卡尔曼滤波量测更新公式完成卡尔曼滤波浮点解的求解。
3、 历元间三差最小二乘观测模型 三差观测方程：
对于三差卫地距，在历元间作了一次差，我们认为上一历元的位置结果是精确的（即t1历元的双差卫地距是精确已知的），以t2历元的伪距单点定位位置解作为此历元接收机大致位置，代入t2历元双差卫地距的线性化结果，此时的真实三差卫地距写为：
上式中的delta_r(t2)表示t2历元的真实位置与t2历元大致位置间的误差。将上式代入三差观测方程，可得:
移项得：
通过上式我们可以构建出最小二乘的各项矩阵：
只做一次最小二乘迭代，得到此历元位置与此历元大致位置的位置误差，此位置误差再加上此历元大致位置与上一历元精确位置的误差，就得到了t1历元到t2历元的接收机位置变化量。若直接用上一历元的接收机精确位置作为此历元接收机的大致位置，那么三差求得的位置误差就是两历元间的接收机位置变化量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6ad3aa7a3a137a26cd5571102dba797/" rel="bookmark">
			Qt 通过重写QGraphicItem实现绘制、拖动、缩放、旋转矩形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt 通过重写QGraphicItem实现绘制、拖动、缩放、旋转矩形
本例程通过重写了一个类，继承自QGraphicItem，来实现了在qgraphicsScene上绘制、拖动、缩放、旋转矩形。
效果如下：
其实要实现绘制、拖动、缩放矩形都不难，难的是在旋转之后还要支持缩放。
我的思路是：
1.实现绘制矩形：只要定义一个全局变量QRectF m_oldRect，在外面矩形大小传进来，然后在paint函数里面绘制这个矩形就行
2.实现拖动矩形：重写mousePressEvent，mouseMoveEvent，mouseReleaseEvent，记录鼠标按下的起始点和移动时候的点，并用moveBy()函数来移动矩形即可
3.实现缩放：在矩形内部靠近4条边的地方定义4个矩形，当鼠标按下的时候在这4个矩形方框内，则将矩形往4个方向拉伸
4.实现旋转：
我给之前定义的矩形全部配一个QPolygonF，因为我只能通过绘制多边形的方式来画出旋转之后的矩形。
矩形正上方的圆圈我是通过三角函数+直线方程来计算，让其始终绘制在矩形左右两个顶点的中垂线上方。
当鼠标落在圆形内部的时候可以控制矩形旋转。
在矩形旋转之后，再进行拉伸的时候，我是通过的计算鼠标的点离对面的边的距离来重新计算矩形的大小，然后计算对应的QPolygonF的大小。
主要代码如下： mygraphicrectitem.h #ifndef MYGRAPHICRECTITEM_H
#define MYGRAPHICRECTITEM_H
#include #include #include #include #include #include #include #include #include #include enum STATE_FLAG{
DEFAULT_FLAG=0,
MOV_LEFT_LINE,//标记当前为用户按下矩形的左边界区域
MOV_TOP_LINE,//标记当前为用户按下矩形的上边界区域
MOV_RIGHT_LINE,//标记当前为用户按下矩形的右边界区域
MOV_BOTTOM_LINE,//标记当前为用户按下矩形的下边界区域
MOV_RIGHTBOTTOM_RECT,//标记当前为用户按下矩形的右下角
MOV_RECT,//标记当前为鼠标拖动图片移动状态
ROTATE//标记当前为旋转状态
};
class myGraphicRectItem:public QObject,public QGraphicsItem
{
Q_OBJECT
public:
myGraphicRectItem(QGraphicsItem *parent = nullptr);
//myGraphicRectItem(QRectF m_OriginRect = QRectF(0,0,100,100));
QRectF boundingRect() const;
~myGraphicRectItem();
void setRectSize(QRectF mrect,bool bResetRotateCenter = true);
void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6ad3aa7a3a137a26cd5571102dba797/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ea8493875e5092b966ef966a1c7aa42/" rel="bookmark">
			CSS3转换属性（Transform）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变形属性：transform transform翻译成汉语具有"变换"或者"改变"的意思。
通过此属性具有非常强大的功能，比如可以实现元素的位移、拉伸或者旋转等效果
最能体现transform 属性强大实力的是实现元素的3D变换效果
变形属性：transform的所有属性值 transform：none;默认值transform：translate（）；移动 平移 单位是pxtransform：rotate（）；旋转 单位是deg deg度数 transform：scale（）；
缩放 没有单位 默认值是1transform：skew（）；倾斜 单位是degtransform：matrix（）；矩阵 transform：perspective（）；景深 视距 单位是px 确定坐标系 2d场景，在屏幕上水平和垂直的交叉线x轴和y轴
3d场景，在垂直于屏幕的方法，相对于3d多出个z轴
Z轴：靠近屏幕的方向是正向，远离屏幕的方向是反向
属性详细解释 （一）transform：translate（）；移动 平移 单位是px。 注意：
transform ：translate(200px)；平移，默认是X轴移动，可以单位是%，这个%是自己的，不是父元素的。
transform ：translateX(200px)；根据X轴给定的参数，从当前元素位置移动。transform ：translateY(200px)；根据Y轴给定的参数，从当前元素位置移动。transform ：translateZ(200px)；定义 3D 转换，只是用 Z 轴的值。transform ：translate(10px,20px)；定义 2D 平移移动。transform ：translate3d(10px,20px,30px)；定义 3D 平移移动。transform ：translateX(200px) translateY(200px) translateZ(200px)； 部分代码展示：
&lt;style&gt; * { margin: 0; padding: 0; } div { width: 100px; height: 100px; margin: 300px; background-color: red; } div:nth-of-type(1) { transform: translateX(100px); } div:nth-of-type(2) { transform: translateY(200px); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ea8493875e5092b966ef966a1c7aa42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/798e788e5276bcce517c8483ab026791/" rel="bookmark">
			样本不均衡的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、样本不均衡简介 1.1 样本不均衡现象 样本（类别）样本不平衡（class-imbalance）指的是分类任务中不同类别的训练样例数目差别很大的情况，一般地，样本类别比例（Imbalance Ratio）（多数类vs少数类）明显大于1:1（如4：1）就可以归为样本不均衡的问题。现实中，样本不平衡是一种常见的现象，如：金融欺诈交易检测，欺诈交易的订单样本通常是占总交易数量的极少部分，而且对于有些任务而言少数样本更为重要。
1.2 不均衡的根本影响 很多时候我们遇到样本不均衡问题时，很直接的反应就是去“打破”这种不平衡。但是样本不均衡有什么影响？有必要去解决吗？
具体举个例子，在一个欺诈识别的案例中，好坏样本的占比是1000：1，而如果我们直接拿这个比例去学习模型的话，因为扔进去模型学习的样本大部分都是好的，就很容易学出一个把所有样本都预测为好的模型，而且这样预测的概率准确率还是非常高的。而模型最终学习的并不是如何分辨好坏，而是学习到了”好 远比 坏的多“这样的先验信息，凭着这个信息把所有样本都判定为“好”就可以了。这样就背离了模型学习去分辨好坏的初衷了。所以，样本不均衡带来的根本影响是：模型会学习到训练集中样本比例的这种先验性信息，以致于实际预测时就会对多数类别有侧重（可能导致多数类精度更好，而少数类比较差）。
如下图，类别不均衡情况下的分类边界会偏向“侵占”少数类的区域，更重要的一点，这会影响模型学习更本质的特征，影响模型的鲁棒性。
总结一下也就是，我们通过解决样本不均衡，可以减少模型学习样本比例的先验信息，以获得能学习到辨别好坏本质特征的模型。
1.3 判断解决不均衡是否有必要 从分类效果出发，通过上面的例子可知，不均衡对于分类结果的影响不一定是不好的，那什么时候需要解决样本不均衡？
判断任务是否复杂：学习任务的复杂度与样本不平衡的敏感度是成正比的（参见《Survey on deep learning with class imbalance》），对于简单线性可分任务，样本是否均衡影响不大。需要注意的是，学习任务的复杂度是相对意义上的，得从特征强弱、数据噪音情况以及模型容量等方面综合评估。（样本越复杂，样本不平衡敏感度越高）判断训练样本的分布与真实样本分布是否一致且稳定，如果分布是一致的，带着这种正确点的先验对预测结果影响不大。但是，还需要考虑到，如果后面真实样本分布变了，这个样本比例的先验就有副作用了。判断是否出现某一类别样本数目非常稀少的情况，这时模型很有可能学习不好，类别不均衡是需要解决的，如选择一些数据增强的方法，或者尝试如异常检测的单分类模型。 二、样本不均衡解决办法 基本上，在学习任务有些难度的前提下，不均衡解决方法可以归结为：通过某种方法使得不同类别的样本对于模型学习中的Loss（或梯度）贡献是比较均衡的。以消除模型对不同类别的偏向性，学习到更为本质的特征。本文从数据样本、模型算法、目标（损失）函数、评估指标等方面，对个中的解决方法进行探讨。
2.1 样本层面 2.1.1 欠采样、过采样 最直接的处理方式就是样本数量的调整了，常用的可以：
欠采样：减少多数类的数量（如随机欠采样、NearMiss、ENN）。过采样：尽量多地增加少数类的的样本数量（如随机过采样、以及2.1.2数据增强方法），以达到类别间数目均衡。还可结合两者做混合采样（如Smote+ENN） 2.1.2 数据增强 数据增强（Data Augmentation）是在不实质性的增加数据的情况下，从原始数据加工出更多数据的表示，提高原数据的数量及质量，以接近于更多数据量产生的价值，从而提高模型的学习效果（其实也是过采样的方法的一种。如下列举常用的方法：
基于样本变换的数据增强
样本变换数据增强即采用预设的数据变换规则进行已有数据的扩增，包含单样本数据增强和多样本数据增强。单样本增强(主要用于图像)：主要有几何操作、颜色变换、随机擦除、添加噪声等方法产生新的样本，可参见imgaug开源库。
多样本增强：是通过组合及转换多个样本，主要有Smote类（可见imbalanced-learn.org/stable/references/over_sampling.html）、SamplePairing、Mixup等方法在特征空间内构造已知样本的邻域值样本。
基于深度学习的数据增强
生成模型如变分自编码网络(Variational Auto-Encoding network, VAE)和生成对抗网络(Generative Adversarial Network, GAN)，其生成样本的方法也可以用于数据增强。这种基于网络合成的方法相比于传统的数据增强技术虽然过程更加复杂, 但是生成的样本更加多样。
数据样本层面解决不均衡的方法，需要关注的是：随机欠采样可能会导致丢弃含有重要信息的样本。在计算性能足够下，可以考虑数据的分布信息（通常是基于距离的邻域关系）的采样方法，如ENN、NearMiss等。随机过采样或数据增强样本也有可能是强调（或引入）片面噪声，导致过拟合。也可能是引入信息量不大的样本。此时需要考虑的是调整采样方法，或者通过半监督算法(可借鉴Pu-Learning思路)选择增强数据的较优子集，以提高模型的泛化能力。 2.2 损失函数层面 损失函数层面主流的方法也就是常用的代价敏感学习（cost-sensitive），为不同的分类错误给予不同惩罚力度（权重），在调节类别平衡的同时，也不会增加计算复杂度。如下常用方法：
2.2.1 class weight 这最常用也就是scikit模型的’class weight‘方法，class weight可以为不同类别的样本提供不同的权重（少数类有更高的权重），从而模型可以平衡各类别的学习。如下图通过为少数类做更高的权重，以避免决策偏重多数类的现象（类别权重除了设定为balanced，还可以作为一个超参搜索。示例代码请见（github.com/aialgorithm）：
2.2.2 OHEM 和 Focal Loss 上文的大意是，类别的不平衡可以归结为难易样本的不平衡，而难易样本的不平衡可以归结为梯度的不平衡。按照这个思路，OHEM和Focal loss都做了两件事：难样本挖掘以及类别的平衡。
OHEM（Online Hard Example Mining）算法的核心是选择一些hard examples（多样性和高损失的样本）作为训练的样本，针对性地改善模型学习效果。对于数据的类别不平衡问题，OHEM的针对性更强。Focal loss的核心思想是在交叉熵损失函数（CE）的基础上增加了类别的不同权重以及困难（高损失）样本的权重（如下公式），以改善模型学习效果。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/798e788e5276bcce517c8483ab026791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0397a3a80727c563a0b2e6b3cac1bfc2/" rel="bookmark">
			艺术~如何设计一套优秀的API响应体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言参考HTTP状态码优秀的设计进行分段处理个性化Message额外的好处 前言 客户端请求API，通常需要通过返回码来判断API返回的结果是否符合预期，以及该如何处理返回的内容等.
有的API用返回码是int类型，有的是string类型，有的用0表示成功，又有的用1表示成功，还有用“true”表示成功，碰上这种事情，只能说：沟通起来真头疼。
API返回码的设计还是要认真对待，毕竟好的返回码设计可以降低沟通成本以及程序的维护成本。
参考HTTP状态码 以HTTP状态码为例，为了更加清晰的表述和区分状态码的含义，HTTP状态做了分段。
对于后端开发来说，我们通常见到的都是：
2XX状态码，比如200-&gt;请求成功。
5XX状态码，比如502-&gt;服务器异常，通常就是服务没正常运行，或者代码执行出错。
通过状态码即可初步判断问题原因，HTTP状态的设计思路值得借鉴。
优秀的设计 虽说是返回码设计，但是只有code是不行的，还要有对应的message，让人可以看懂，有data统一管理数据。
进行分段处理 参考HTTP状态码的思路，我们对错误码进行分段。
个性化Message 目前有三个问题
在不同的场景下，同样的错误，可能需要给不同用户端（APP 小程序 网页）看到不一样的错误提示。通常我们的Message都是写给工程师看的，但是对于用户来说，返回的信息又必须是准确的，所以用户看到的就必须转译。完整的message如果在服务与服务之间传输调用也是没必要的浪费。 所以可以把转译的消息配置到数据库，并缓存到Redis或者API本机，在请求最后要返回的时候进行转译。可以在请求开始的时候就从不同的用户端传入不同的application_id参数，然后在请求处理结束即将返回的时候，根据application_id+code，去匹配替换message。
额外的好处 有了统一的code，我们就可以通过Nginx或者APM工具统计API请求Code数量及分布信息。
我们可以根据单位时间内99999的数量来做API的异常告警。
我们可以根据Code的返回饼图，帮助我们发现系统、业务流程中的问题，及时的去优化业务。
总之，好的返回码设计，可以帮助我们提高沟通效率，降低代码的维护成本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deb80174f90bcdcc18b8d84045c0f38b/" rel="bookmark">
			java 多线程异步处理List拿到返回结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 public static void test10() throws ExecutionException, InterruptedException { List&lt;TestUser&gt; userList=new ArrayList&lt;&gt;(); for(int i=0;i&lt;1000;i++){ TestUser testUser=new TestUser(); testUser.setUsername("a"+i); testUser.setAge(1); userList.add(testUser); } List&lt;Future&gt; futureList=new ArrayList&lt;&gt;(); for(TestUser testUser:userList){ Future&lt;TestUser&gt; future=ThreadUtil.execAsync(new Callable&lt;TestUser&gt; (){ @Override public TestUser call() throws Exception { Thread.sleep(1000); testUser.setAge(testUser.getAge()+1); return testUser; } }); futureList.add(future); } List&lt;TestUser&gt; testUserList=new ArrayList&lt;&gt;(); for(Future&lt;TestUser&gt; future:futureList){ TestUser testUser=future.get(); testUserList.add(testUser); } for(TestUser testUser:testUserList){ System.out.println(testUser.toString()); } } @Data public class TestUser { private String username; private Integer age; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d65f4ae3a0541de5effcbb9cfd862e2b/" rel="bookmark">
			CSS MASK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近看css大佬chokcoco的文章，发现对于mask（遮罩）这个属性没怎么学习过，就接着大佬的这篇
奇妙的 CSS MASK 文章进行简单学习，并自己实现一下文章中有意思的效果
参考文章：
奇妙的 CSS MASK
CSS mask遮罩
MASK常用属性 在 CSS 中，mask 属性允许使用者通过遮罩或者裁切特定区域的图片的方式来隐藏一个元素的部分或者全部可见区域。
常用属性
mask-image：遮罩图片mask-repeat：是否重复mask-position：遮罩位置mask-size：遮罩尺寸 实例1 mask-image指遮罩使用的图片资源，默认值是none，也就是无遮罩图片。类似于background-image属性
下面使用这两张图片
.main{ width: 100%; height:100%; background: url('../image/11.webp'); mask-image: url('../image/q.png'); mask-repeat: no-repeat; } 效果
如 css mask遮罩 这篇文章中说的，所谓遮罩，就是原始图片只显示遮罩图片非透明的部分。
实例2 mask-image 除了使用背景图同样可以使用渐变，如下：
.main{ width: 100%; height:100%; background: url('../image/11.webp'); mask-image: linear-gradient(90deg, #fff,transparent); } 效果
使用渐变同样需要遵守：所谓遮罩，就是原始图片只显示遮罩图片非透明的部分。
如果不设置透明，比如设置为mask-image: linear-gradient(90deg, #fff,#000); 那么只会显示原图片
实例3 实现切角，线性渐变 .main{ width: 100%; height:100%; background: url('../image/11.webp'); mask: linear-gradient(135deg, transparent 50px, #fff 0) top left; } 实例4 径向渐变 &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d65f4ae3a0541de5effcbb9cfd862e2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b49f49dab392bd53653379a1679d3ce/" rel="bookmark">
			VS简明教程（VS安装、系统建议设置、软件设置、新建工程、发行、编译建议）、VS Code简明教程（安装、汉化、配置python环境、安装插件、新建并运行python程序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装 官网下载安装器，工作负荷选择如下（假如只用C，且只为学习语言），安装位置建议是不要改，改也可以
安装位置参考：
选择安装位置 - Visual Studio (Windows) | Microsoft Docshttps://docs.microsoft.com/zh-cn/visualstudio/install/change-installation-locations?view=vs-2022
备注
某些工具和 SDK 对于安装位置有不同规则。 即使选择另一位置，这些工具和 SDK 也会安装在系统驱动器上。
提示
如果系统驱动器是固态硬盘 (SSD)，建议你将核心产品保留在系统驱动器上。 原因？ 当使用 Visual Studio 进行开发时，将从大量文件进行读取并写入大量文件，这会增加磁盘 I/O 活动。 最好选择最快的驱动器来处理负载。
2.系统建议的一些设置 首先文件管理器里打开“文件扩展名“和”隐藏的项目“
打开”Windows安全中心“，进行如下设置
关闭“文件夹限制访问”
3.初次打开VS 初学者主要使用以上两个选项，进阶学者可能会用第一个。 创建新项目：以下两种创建方法都可以，有的教程建议“空项目”，有的教程“Windows桌面向导”，两种都可以，看个人喜好。
配置新项目，注意项目名称连接处用下划线“_”，还要勾选图中所示
如图所示设置就好
这样就建立了一个新项目
在“视图”里可以设置各种管理器的开/关。 如图所示添加源文件
在“工具”“选项”里可以进行字体、字号等设置 更改颜色主题
运行的时候如图，开始执行（不调试），快捷键Ctrl+F5
如果程序报错，选择“否”，可以看到错误提示
针对“拒绝访问”错误
如果要分享自己的程序，选择“发行”
若要直接在文件管理器打开VS文件，则找".sln"后缀的文件
建议语句规范
变量赋值等号两边要有空格
编写多个源文件的问题：
在一个项目中，编写多个源文件时，只能在一个源文件里使用main函数。
以上就是C语言初学者使用VS的一些建议。
4.VS Code安装 VScode 教程 | 菜鸟教程 (runoob.com)https://www.runoob.com/w3cnote/vscode-tutorial.html
注意两点：
1.安装位置可以改变，与VS略有不同
2.安装时注意勾选选项，如图所示
3.汉化
打开vc code，安装一个插件
4.配置python环境
Python3 环境搭建 | 菜鸟教程 (runoob.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b49f49dab392bd53653379a1679d3ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a08a8bb101285ddda5eaee1ec9bd1758/" rel="bookmark">
			ES6数组中删除指定元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES6数组中删除指定元素 findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。 arr.splice(arr.findIndex(item =&gt; item.id === data.id), 1) arr.splice(arr.findIndex(item =&gt; item.id === id), 1) 1、item 代码参数(可变) 2、 item.id 根据数组里面的唯一值写 比如：id、key 3、 id：是你想要删除的元素的id号 比如：record.id record.key(对象.属性) 或者 id 、key(根据实际定) 4、1是你要删除1个元素的意思 5、splice() 方法用于添加或删除数组中的元素 注意：这种方法会改变原始数组。 6、findIndex() 是找到某元素的下标的位置 1:js中的splice方法
splice(index,len,[item]) 注释：该方法会改变原始数组。
splice有3个参数，它也可以用来替换/删除/添加数组内某一个或者几个值
index:数组开始下标 len: 替换/删除的长度 item:替换的值，删除操作的话 item为空
如：arr = [‘a’,‘b’,‘c’,‘d’]
删除 ---- item不设置
arr.splice(1,1) //[‘a’,‘c’,‘d’] 删除起始下标为1，长度为1的一个值，len设置的1，如果为0，则数组不变
arr.splice(1,2) //[‘a’,‘d’] 删除起始下标为1，长度为2的一个值，len设置的2
替换 ---- item为替换的值
arr.splice(1,1,‘ttt’) //[‘a’,‘ttt’,‘c’,‘d’] 替换起始下标为1，长度为1的一个值为‘ttt’，len设置的1
arr.splice(1,2,‘ttt’) //[‘a’,‘ttt’,‘d’] 替换起始下标为1，长度为2的两个值为‘ttt’，len设置的1
添加 ---- len设置为0，item为添加的值
arr.splice(1,0,‘ttt’) //[‘a’,‘ttt’,‘b’,‘c’,‘d’] 表示在下标为1处添加一项‘ttt’
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20a4c81266c6fa8fa88c22a3702d55dd/" rel="bookmark">
			(tensorflow2.1.0安装教程) 对应Anaconda3(对应python3.7)&#43;cuda10.1&#43;cudnn7.6.5&#43;Pycharm 网盘 链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tensorflow2.1.0 安装工具百度网盘链接 整体安装流程及版本：
Anaconda3(2019)对应python3.7+cuda10.1+cudnn7.6.5+Pycharm
第一步： 首先确保电脑上原先所有的python和conda环境卸载干净
网盘获取：
&lt;1&gt;Anaconda3-5.3.1-Windows-x86_64.exe
链接：https://pan.baidu.com/s/1mMOVgFkCfhF6hYTGdEGJKQ
提取码：2zk8
&lt;2 &gt;cuda_10.1.105_418.96_win10.exe
链接：https://pan.baidu.com/s/1sInaK4c5KC3LX7qCLIWYFQ
提取码：t11g
&lt;3&gt;cudnn7.6.5
链接：https://pan.baidu.com/s/1uwTFfr4JsW5V3JN51sW-Xg
提取码：tytf
&lt;4&gt;pycharm-community-2021.3.1.exe
链接：https://pan.baidu.com/s/17NwHddp_k91GqfeBe99rGg
提取码：qnes
&lt;5&gt;TensorFlow安装，Terminal输入：
pip install tensorflow-gpu==2.1.0 -i https://pypi.douban.com/simple
这篇博客提供与tf2.1.0版本对应的anaconda、cuda、cudnn的安装包。测试成功。具体每一步的详细安装步骤参照另外一篇博客。
https://blog.csdn.net/qq_42005540/article/details/111941929?spm=1001.2014.3001.5501
https://blog.csdn.net/weixin_44170512/article/details/103990592
与之相对应的pytorch安装包：
安装torch1.6.0
链接：https://pan.baidu.com/s/1Q65RMFZVtzHAiGMzL6PCnA
提取码：yo1q
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8482fbf9a4a1f69a9b80bfef1bcabfd6/" rel="bookmark">
			PCM编码译码仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的
1．熟悉PCM（脉冲编码调制）原理。
2．掌握编写PCM（脉冲编码调制）程序的要点。
3．掌握使用Matlab调制仿真的要点。
二、实验内容
1．根据PCM（脉冲编码调制）原理，设计源程序代码。
2．通过Matlab软件仿真给定模拟信号编码后的波形。
3. 对比给的原始信号波形和译码后的波形。
三、实验原理
1.脉冲编码调制
脉冲编码调制在通信系统中是一种对模拟信号数字化的取样技术，将模拟信号变换为数字信号的编码方式。 PCM的实现主要包括三个步骤完成：抽样、量化、编码。分别完成时间上离散、幅度上离散、及量化信号的二进制表示。根据CCITT的建议，为改善小信号量化性能，采用压扩非均匀量化，有两种建议方式，分别为A律和律方式，本设计采用了A律方式。由于A律压缩实现复杂，常使用13折线法编码，采用非均匀量化PCM编码示意图如图1所示
图1 PCM编码示意图
2.抽样：在一系列离散点上，对信号抽取样值称为抽样。其模拟信号的抽样过程如图2所示。
图2 模拟信号的抽样过程图
3.非均匀量化
图3 非均匀13折线压缩特性曲线
图4 非均匀13折线编码原理图
在实际应用中，量化器设计好后，量化电平数M和量化间隔都是确定的。量化噪声Nq 也是确定的。但是，信号的强度会影响信号量噪比，当信号小时，信号量噪比也就越小。因此，均匀量化器对小输入信号很不利，为了克服这个缺点，以改善小信号时的信号量噪比，采用下述的非均匀量化方式。
在非均匀量化中，量化间隔是随信号抽样值的不同而变化的。信号抽样值小时，量化间隔也小；信号抽样值大时，量化间隔也大，非均匀量化的实现方法有两种：一种是北美和日本采用的μ律压扩，一种是欧洲和我国采用的A律压扩，常采用的近似算法是13折线法，该算法的压缩特性图如图3所示。
信号小时，Δ小，信号大时，Δ大。一般语音信号，信号幅度小出现的概率大，信号幅度大出现的概率小。通过非均匀量化，使得平均信噪比增大。
13折线A律PCM的非线性编码方法具体过程如表1所示。
在13折线法中采用的折叠码有8位。其中一位c1 表示量化值的极性正负，后7位分为段落码和段内码两部分。用于表示量化值的绝对值。其中第2~4位（c2~c4）是段落码，5~8位（c5~c8）为段内码，可以表示每一段落内的16种量化电平。段内码代表的16个量化电平是均匀分布的，因此，这7位码总共能表示27=128种量化值。编码方法如下所示：
极性码　段落码　段内码
C1 C2C3C4 C5C6C7C8
（1）将量化区间［a,b］分为4096个小段
（2）正半轴2048个小段，负半轴2048个小段
（3）每个小段用Δ表示
表1 非均匀13折线编码原理
四、程序设计
1. 首先给定一个模拟信号。
2. 根据PCM（脉冲编码调制）原理，对模拟信号进行抽样，得到离散信号， 然后进行非均匀量化编码 ，采用13折线法。
3. 在Matlab当中进行操作时，首先要画出经过PCM调制的模拟信号波形。 4. 将经过PCM调制的信号叠加上一个高斯白噪声信道，然后，根据非均匀量化译码原理，得到译码后的波形，即原始的模拟信号。
五、设计流程
1. 输入一个模拟信号，根据奈奎斯特定理，进行抽样，得到时间上离散的模拟信号。
2. 根据非均匀量化编码（13折线法），设定模拟信号各个段的段落码和段内码。并画出量化编码后的波形。
3. 根据非均匀量化编码（13折线法）的逆向思想，即不同的段落码和段内码分别对应不同的电平值，最终得到译码后的模拟信号，然后画出译码后的模拟信号的波形。
六、源程序代码
%建立原信号
T=0.002; %取时间间隔为0.002
t=-0.1:T:0.1; %时域间隔dt为间隔从-0.1到0.1画图
xt=cos(2*pi*30*t)+sin(2*pi*65*t); %xt方程
%采样：时间连续信号变为时间离散模拟
%信号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8482fbf9a4a1f69a9b80bfef1bcabfd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdd4154a537764e948ef6f4befa0f364/" rel="bookmark">
			2ASK和2FSK调制解调仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验一 2ASK和2FSK调制解调仿真
一、实验目的
1．熟悉2ASK和2FSK调制解调原理。
2．掌握编写2ASK和2FSK调制解调程序的要点。
3．掌握使用Matlab调制解调仿真的要点。
二、实验内容
1．根据2ASK和2FSK调制解调原理，设计源程序代码。
2．通过Matlab软件仿真给定信号的调制波形。
3. 对比给定信号的理论调制波形和仿真解制波形。 三、实验原理
1．2ASK
二进制振幅键控（2ASK）信号码元为：
S(t)=A(t)cos(w0t+θ) 0﹤t≤T
式中w0=2πf0为载波的角频率；A(t)是随基带调制信号变化的时变振幅，即
╱ A 当发送“1”时
A(t)= ╲ 0 当发送“0”时
在式中给出的基带信号码元A(t)的波形是矩形脉冲。
产生2ASK的调制方法，主要有两种。第一种方法采用相乘电路如图1，用基带信号A（t）和载波cosw0t相乘就得到已调信号输出。第二种方法是采用开关电路如图2，开关由输入基带信号A（t）控制，用这种方法可以得到同样的输出波形。
图1 相乘法原理图 图2 开关法原理图
2ASK信号有两种基本的解调方法：非相干解调（包络检波法）和相干解调（同步检测法），相应的接收系统如图 3和图4所示。
图3 包络检波法（非相干解调）
图4 相干解调原理图
抽样判决器的作用是：信号经过抽样判决器，即可确定接收码元是“1”还是“0”。假设抽样判决门限为b，当信号抽样值大于b时，判为“1”码；信号抽样值小于b时，判为“0”码。当本实验为简化设计电路，在调制的输出端没有加带通滤波器，并且假设信道时理想的，所以在解调部分也没有加带通滤波器。
2. 2FSK调制原理
二进制频移键控（2FSK）信号码元的“1”和“0”分别用两个不同频率的正弦波形来传送，而其振幅和初始相位不变。故其表达式为；
式中，假设码元的初始相位分别为Φ1和Φ0；w1 =2πf1和w0 =2πf0为两个不同频率码元的角频率；A为一常数，表明码元的包络是矩形脉冲。
2FSK信号的调制方法主要有两种。第一种是用二进制基带矩形脉冲信号去调制一个调频器，使其能够输出两个不同频率的码元。第二种方法是用一个受基带脉冲控制的开关电路去选择两个独立频率源的振荡作为输出。
.2FSK解调原理
2FSK信号的解调也分为相关和非相关解调两类。 相关接收根据已调信号由两个载波f1、f2调制而成，则先用两个分别对f1、f2带通的滤波器对已调信号进行滤波，然后再分别将滤波后的信号与相应的载波f1、f2相乘进行相干解调，再分别低通滤波、用抽样信号进行抽样判决器即可。
原理图如下：
图5 二进制移频键控相干解调原理方框图
非相关接收经过调制后的2FSK数字信号通过两个频率不同的带通滤波器f1、f2滤出不需要的信号，然后再将这两种经过滤波的信号分别通过包络检波器检波，最后将两种信号同时输入到抽样判决器同时外加抽样脉冲，最后解调出来的信号就是调制前的输入信号。其原理图如下图所示：
图6 二进制移频键控非相干解调原理方框图
四、程序设计
1. 首先给定一组输入信号序列，如m=[1 1 1 0 0 0 1 0 1 1 0 1]。也可以利用rand随机产生一组元素为10的数字序列。
2. 根据2ASK和2FSK调制原理，需要对输入信号序列中的每个元素进行判断，假设判断元素为“1”，则在一个周期内，2ASK图像中对应一个正弦波，2FSK图像中也对应一个正弦波；假设判断元素为“0”，则在一个周期内，2ASK图像中对应零输出，2FSK图像中对应两个正弦波；假设判断元素非上述两者，则在图中均无图像输出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdd4154a537764e948ef6f4befa0f364/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d08cbe4f75564cbe709760776eece1cf/" rel="bookmark">
			【图神经网络】图神经网络(GNN)学习笔记：图信号处理与图傅里叶变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图神经网络GNN学习笔记：图信号处理与图卷积神经网络 第五章：图信号处理与图卷积神经网络1. 矩阵乘法的三种方式2. 图信号与图的拉普拉斯矩阵3. 图傅里叶变换参考资料 第五章：图信号处理与图卷积神经网络 图信号处理（Graph Signal Processing, GSP）是离散信号处理（Discrete Signal Processing, DSP）理论在图信号领域的应用，其通过对傅里叶变换、滤波等信号处理基本概念的迁移，来研究对图信号的压缩、变换、重构等信号处理的基础任务。
图信号处理与图卷积模型密切相关：
有助于了解图卷积模型的定义和演变为图卷积模型的理论研究提供工具 本文，首先给出图信号的基本定义，然后介绍图傅里叶变换，并引出图信号频率的定义；然后介绍图信号上的滤波操作，以及卷积滤波与图卷积模型的关系。同时还介绍了对图信号的频域与空域的理解。
1. 矩阵乘法的三种方式 设两个矩阵 A ∈ R K A\in R^{K} A∈RK， B ∈ R M × P B\in R^{M\times P} B∈RM×P，对于 C = A B C=AB C=AB，有如下3种计算方式：
(1)内积视角：将A视作一个行向量矩阵，将B视作一个列向量矩阵，则
C i j = A i , : B : , j C_{ij}=A_{i,:}B_{:,j} Cij​=Ai,:​B:,j​
(2)行向量视角：将B视作一个行向量矩阵，将A视作系数矩阵，则
C i , : = ∑ m M A i m B m , : C_{i,:}=\sum_{m}^MA_{im}B_{m,:} Ci,:​=m∑M​Aim​Bm,:​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d08cbe4f75564cbe709760776eece1cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6677ef4b77687f833a31226e23bdbcc5/" rel="bookmark">
			在Android 设置中的应用中隐藏指定app
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在文件
alps/packages/apps/Settings/src/com/android/settings/applications/ManageApplications.java
中rebuild方法中增加
//cxq for(ApplicationsState.AppEntry appEntry: entries){ if (DEBUG) Log.d(TAG, "App packageName " + appEntry.info.packageName); if(appEntry.info.packageName.equals("")) { entries.remove(appEntry); break; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ef5d7861970bd4181df0e23f7a0941c/" rel="bookmark">
			修复联网和usb问题 PD虚拟机17 Mac中文版(支持12系统)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Parallels Desktop for Mac是Mac虚拟机软件中的佼佼者，现在全新版本的Parallels Desktop 中文版已经更新，支持最新的Windows 11、macOS Catalina、macOS Big Sur 11和macOS Monterey 12系统，无需重启电脑，可以轻松帮助用户在Mac上运行windows或其他系统，而且安装parallels desktop mac版后，你可以在Mac上运行数千种Windows程序，这里带来最新激活的Parallels Desktop mac中文版，欢迎各位来体验哦！
Parallels Desktop 17 for Mac官方介绍
Parallels Desktop是一款运行在Mac电脑上的极为优秀的虚拟机软件，用户可以在 Mac OS X下非常方便运行Windows、Linux等操作系统及应用，用户不必繁琐重复地重启电脑即可在Win与Mac之间切换甚至同时使用它们。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dda2fa04bf773cfcfe906d111abbcc78/" rel="bookmark">
			java策略模式实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java策略模式 在具体实践中根据业务形态不同做适当调整
1、被动方式
策略维护规则用 switch case 模式 每新加一个实现类 需根据 type 指定具体实现类
优点：所有实现类都必须在context中显示初始化 所有实现类一目了然 比较清晰
缺点：context中暴露了具体的接口实现 弱化了context的能力
简略代码实现
interface Fruit{ String color; int size; } class Apple implements Fruit{ String color; int size; String location; } class Pear implements Fruit{ String color; int size; String season; } class FruitContext{ private Fruit; private init(int fruitType){ switch(fruitType){ case 苹果: new Apple(); break; case 梨子: new Pear; break; ... case 葡萄: //...; break; } } // 对应业务逻辑实现 private String processFruit(int fruitType){ init(fruitType); return Fruit.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dda2fa04bf773cfcfe906d111abbcc78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0242d3f15b4cd8402c25faf14f0c184f/" rel="bookmark">
			【时间序列】最完整的时间序列分析和预测（含实例及代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间序列 在生产和科学研究中，对某一个或者一组变量 进行观察测量，将在一系列时刻所得到的离散数字组成的序列集合，称之为时间序列。
pandas生成时间序列
过滤数据
重采样
插值
滑窗
数据平稳性与差分法
pandas生成时间序列 时间戳（timestamp）
固定周期（period）
时间间隔（interval）
import pandas as pd import numpy as np # TIMES的几种书写方式 #2016 Jul 1; 7/1/2016; 1/7/2016 ;2016-07-01; 2016/07/01 rng = pd.date_range('2016-07-01', periods = 10, freq = '3D')#不传freq则默认是D rng DatetimeIndex(['2016-07-01', '2016-07-04', '2016-07-07', '2016-07-10', '2016-07-13', '2016-07-16', '2016-07-19', '2016-07-22', '2016-07-25', '2016-07-28'], dtype='datetime64[ns]', freq='3D') time=pd.Series(np.random.randn(20),index=pd.date_range('2016-01-01',periods=20)) print(time) 2016-01-01 -1.503070 2016-01-02 1.637771 2016-01-03 -1.527274 2016-01-04 1.202349 2016-01-05 -1.214471 2016-01-06 2.686539 2016-01-07 -0.665813 2016-01-08 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0242d3f15b4cd8402c25faf14f0c184f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bf9e419d1ef8ece73c6b4ca618269bc/" rel="bookmark">
			Python中使用Flask：VsCode调试Flask程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 系列文章目录
Python中使用Flask：VsCode调试Flask程序
Python中使用Flask：Flask Web入门实操
Python中使用Flask：Docker发布Flask API
VsCode中如何调试Flask程序呢？ 首先需要建立调试的配置文件，launch.json
在弹出的界面选择flask
点击调试，报错了，尴尬的很，看了控制台输出的信息Flask app 'app.py‘,我们的程序是app的嘛，系统默认生成的launch.json中配置的也是app.py，只有app.py中配置的是wwxcweb，是不是应该改为wwxcweb呢？试试看！
这里的原理确实有点懵，希望有大佬解释一下
修改app.py为wwxcweb.py，修改后文件目录
修改launch.josn中相关的配置
"env": { "FLASK_APP": "wwxcweb.py", "FLASK_ENV": "development", "FLASK_DEBUG": "0" }, 添加断点，点击debug或者F5，访问页面，可以看到命中断点了
wwxcweb 代码 from setuptools import setup setup( name='wwxcweb', packages=['wwxcweb'], include_package_data=True, install_requires=[ 'flask', ], ) init.py 代码 from flask import Flask app = Flask(__name__) import wwxcweb.fileupload import wwxcweb.returnhtml 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11e82de39310065625636a1bdfc43a55/" rel="bookmark">
			基于 Docker 的 Gitlab 环境迁移遇坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 （1）迁移准备工作1.1 停掉gitlab1.2 拷贝giblab1.3 启动容器 （2）填坑2.1 查看容器状态2.2 重新配置权限 + 重新配置gitlab2.3 解决 gitaly 启动问题2.5 解决 rails 权限问题2.5 解决 grafana 权限问题 因为安全需要，公司的gitlab需要从外网迁移到内网。按道理说公司的gitlab是用的docker部署，直接把原来的docker整个目录复制过来就可以，但是直接复制的会导致gitlab启动不了，中间遇到各种坑，这里记录下可能会帮助到有缘人，O(∩_∩)O哈哈~。
基础环境
操作系统：Ubuntu 18.04
容器环境：Docker version 20.10.12 / docker-compose version
Gitlab环境：Gitlab 13.7.9
（1）迁移准备工作 1.1 停掉gitlab 进入容器所在目录，停掉服务
docker-compose stop 千万可别 docker-compose down 这个将停止运行的容器，并且会删除已停止的容器以及已创建的所有网络。
1.2 拷贝giblab scp -r ./gitlabxx user@192.168.xx.xx:/data/xx/xx 1.3 启动容器 进入拷贝后的目录，启动 gitlab
docker-compose up -d （2）填坑 2.1 查看容器状态 查看容器状态，发现容器内部一直在重启
docker-compose ps docker的 state 状态 一直是 starting ，通过网上搜索问题，判断应该是容器内部出了问题，进入容器
docker-compose exec gitlab bash 其中 gitlab 是 docker-compose 的 services 名字， 进入后通过下面命令查看gitlab的运行状态：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11e82de39310065625636a1bdfc43a55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f2b7f078a45c8510c91a9d85dcf6883/" rel="bookmark">
			关于ES查询文档标记来源问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于ES查询文档标记来源问题 1.目前知了使用的方案 知了目前使用的是ES为Java提供一个查询接口，叫做QueryBuilder
当用户传入查询后，现在我们做了一个这个事情——多字段匹配查询
reBuilder = reBuilder.must(multiMatchQuery(query, "title", "text")); 其中这个query就是用户的输入
官方文档给出的解释是：Finds documents which match any field, but uses the _score from the best field.
实际上这个多字段匹配查询可以这么理解：
比如说用户搜索一个「北京邮电大学」
我在标题和正文里分别对北京邮电大学进行全文检索，然后分别在两个字段里按照命中率(或者说_score)进行排序
然后将这两个排序结果取并集，在两个字段命中率都高的排名考前
最后得到一个没有重复的文档集合，返回给用户
这就造成一个问题，通过这种方法获得的结果是这样的
["0": { "id": 17516, "crop_id": null, "user_id": 23, "create_time": 1631950049000, "edit_time": 1631950049000, "title": "计算机学院2021级培养方案", "text": "&lt;p&gt;计算机学院2021级培养方案，包括：&lt;/p&gt;&lt;p&gt;北京邮电大学专业学位硕士研究生培养方案（2021级）-9.14.pdf&lt;br /&gt;北京邮电大学博士研究 生培养方案（2021级）-9.3.pdf&lt;br /&gt;北京邮电大学学术学位硕士研究生培养方案（2021级）-9.9.pdf&lt;br /&gt;北京邮电大学直博研究生培养方案（2021级）-9.3.pdf&lt;/p&gt;", "attachment": null, "superior": 0, "recognition": null, "opposition": null, "pageview": null, "collection": null, "group_id": "", "label_id": "111,203,129", "user_name": null, "group_name": null, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f2b7f078a45c8510c91a9d85dcf6883/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a375de89054b942fd739d925f828e15/" rel="bookmark">
			账户枚举介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		账户枚举介绍 原理说明
攻击者可以利用kerberos协议的特性来进行账户枚举，如图，如果账号不存在，在第②阶段的时候会返回C_PRINCIPAL_UNKNOWN错误。
危害说明
1、主机可能已被攻陷，成为内网跳板机对域控服务器进行攻击。
2、主机可能已中毒，主机敏感信息存在被泄露的风险。
处置建议
1、推荐使用深信服EDR工具进行分析并查杀：http://edr.sangfor.com.cn/tool/SfabAntiBot.zip
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20f7c55e264a8b7587aacf34399b3709/" rel="bookmark">
			selenium-XPATH以及CSS的便捷使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里是清安，我们见过元素定位，也讲过一篇，元素定位不到的文章，那么本章，我们就来详细说说，元素定位的那些利器。一起看看元素定位的另一些情况。
目录
css 和 xpath 定位各自优缺点？
篇外话
如何定位一组元素？
如何定位父子/兄弟/相邻节点的定位元素？
父-&gt;子
子-&gt;父
如何二次定位元素？
如何去定位页面上动态加载动态变化的元素？
正文
xpath实用的元素定位方法
CSS实用的元素定位方法
总结
css 和 xpath 定位各自优缺点？ xpath ：是 XML 文档中查找结点的语法，换句话就是通过元素的路径来查找这个元素。他分绝对路径和相对路径，xpath 比较强大，所有元素它都能定位到，但是他定位相对比较慢，
css 选择器 ：在性能上更优，运行速度更快，语法上更简洁。
Xpath能通过子元素搜索父元素， Css无法实现，Css只能从父级往下级搜索。
Xpath能按文本搜索元素，Css不能。
Css比Xpath更简单易读，执行速度更快
篇外话 如何定位一组元素？ 以百度为例：
from selenium import webdriver fox = webdriver.Firefox() fox.get('https://baidu.com') s = fox.find_elements_by_class_name('mnav') for i in s: print(i.get_attribute('href')) fox.quit() 看图，我标注了数字，为什么要标注数字，跑了看结果就知道了。
http://news.baidu.com/ https://www.hao123.com/ http://map.baidu.com/ http://tieba.baidu.com/ https://haokan.baidu.com/?sfrom=baidu-top http://image.baidu.com/ https://pan.baidu.com/?from=1026962h None 得出的结果是这样的。为什么会有一个None值呢，看到了我标注的黄色框了吗，元素也是mnav开头的，这里是模糊匹配，所以黄色框中的div也输出了，它又没有href，所以为None。
.get_attribute('href')获取元素的给定属性或属性，它将返回具有相同名称的属性的值，我需要获取href属性对应的值，所以说，输出了一个个链接。
如何定位父子/兄弟/相邻节点的定位元素？ 这里做了解就好
父-&gt;子 串联查找，这一项可以理解为父级元素的基础上直接查找所需的子元素。当元素定位不到的时候可以尝试此方法，不过比较的笨拙，但是实在。
from selenium import webdriver fox = webdriver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20f7c55e264a8b7587aacf34399b3709/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12373895f0b444054801a7eb18812d81/" rel="bookmark">
			Symbolicc&#43;&#43;库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		link:
https://issc.uj.ac.za/symbolic/symbolic.html 使用SymbolicC++3 3.35 gzipped tar ，这个是只包含header file的库，生成静态库的版本SymbolicC++3 3.35 with GNU autoconf有问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0beb703f4d4f7683d5c5bb4dcc73c10d/" rel="bookmark">
			火狐浏览器报错：已拦截跨源请求:同源策略禁止读取位于...的远程资源(CORS 请求不是 http)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 访问本地的json文件时出错，已拦截跨源请求:同源策略禁止读取位于 file:///I:/IDEA_VueStudy/demo/data.json
解决方法：
第一步：地址栏输入：about:config，回车，点击”接受风险并继续”后进入页面 第二步：搜索：security.fileuri.strict_origin_policy,并设置该项为false 最后，重启浏览器，就不会再报跨源错误了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5e865567a70d8264cc9183a7cfd2f61/" rel="bookmark">
			VRRP小实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验内容 实验背景： 作为公司的网络管理员，当前的网络中有两个用户，PC1、PC2模拟为公司用户，R1使用环回口模拟Internet服务器。此时网络中有两个网关，为实现冗余选择使用VRRP协议。实验拓扑如下图所示：
二、实验目的 1.了解网络负载均衡的功能和作用。
2.理解VRRP协议的工作原理。
3.掌握三层交换环境单组VRRP的配置方法，及其优化配置。
三、实验方案设计 本次实验采用一台路由器，两台具备三层路由功能的交换机，两台终端设备（PC），网络中划分了三个VLAN,分别为VLAN 1、VLNA 2、VLAN 3。
1.在SW1上创建VLAN 1、VLNA 2、并且配置如上图拓扑所示IP地址，然后将G0/0/10接口配置为trunk模式，允许vlan 1 通过，将G0/0/1接口配置为access模式，划分vlan 2。
2.在SW2上创建VLAN 1、VLNA 3、并且配置如上图拓扑所示IP地址，然后将G0/0/10接口配置为trunk模式，允许vlan 1 通过，将G0/0/1接口配置为access模式，划分vlan 3。
3.PC1连接SW1的G0/0/2口，并且将SW1的G0/0/2口配置为access模式，划分vlan 1 。
4.PC1连接SW2的G0/0/2口，并且将SW2的G0/0/2口配置为access模式，划分vlan 1 。
5.在SW1上进入vlanif 1,配置VRRP为Master设备端，vrid 为1，虚拟网关地址为10.0.123.254 ，设置vrrp优先级105（默认值为100，越大越优），开启抢占模式（默认开启），设置抢占延迟时间为10秒，开启上行链路追踪功能。
6.在SW2上进入vlanif 1,配置VRRP为Backup设备端，vrid 为1，虚拟网关地址为10.0.123.254 。
7.在路由器AR1上配置接口IP如上图所示，并且配置loopback0来模拟外网网段。然后开启OSPF路由协议，在区域0里，宣告两个接口IP地址和一个loopback0接口地址。
8.SW1也开启OSPF路由协议，在区域0里，宣告vlan 1 和 vlan3 网段。
9.SW2也开启OSPF路由协议，在区域0里，宣告vlan 1 和 vlan2 网段。
10.PC1和PC2的网关地址均为10.0.123.254。
四、实验配置命令 SW1:
# Vlan batch 2 //创建vlan2， # interface Vlanif1 ip address 10.0.123.2 255.255.255.0 vrrp vrid 1 virtual-ip 10.0.123.254 //虚拟网关地址 vrrp vrid 1 priority 105 //修改VRRP优先级，使得SW1变为Master设备 vrrp vrid 1 preempt-mode timer delay 10 //配置抢占延迟时间，使得业务流量不中断 vrrp vrid 1 track interface GigabitEthernet0/0/1 reduced 20 //配置追踪上行链路，快速感知链路故障。 # interface Vlanif2 ip address 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5e865567a70d8264cc9183a7cfd2f61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9df7b0445dfbffcc8ff9fe309e2df6a1/" rel="bookmark">
			在Linux中的vi编辑模式中查找关键字的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux中的vi编辑模式中查找关键字的方法：
1、进入vi中，先按下"ESC"跳转成命令输入模式
2、输入斜杠“/”，这时屏幕会跳转到底部，输入栏出现"/"
3、输入你需要查找的关键字，回车
4、如果要继续查找关键字，输入n
5、向前查找，输入N（大写）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/368678ac8492cc0ecb7c24678c11accc/" rel="bookmark">
			SSM整合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ssm整合(文末配有SSM整合所需依赖)
目录结构
实现pojo实体类
package com.mySSM.pojo; import java.io.Serializable; /** *序列化原因 *当客户端访问了某个能开启会话功能的资源 *服务器就会为其创建一个HttpSession对象 *每个HttpSession会占用一定的内存空间 *当访问数量过多，服务器就会创建大量HttpSession对象 *消耗大量服务器内存，即使客户端关闭浏览器，但是在不超时 *情况下依旧占用服务器内存 *服务器通常将那些暂时不活动的但未超时的HttpSession对象 *转移到数据库或文件系统中保存，当需要的时候再从文件系统 *或数据库中载入内存 */ public class Admin implements Serializable { private Integer id; private String username; private String password; private Double money; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/368678ac8492cc0ecb7c24678c11accc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61880eda4851b5e6b868ba064ea701b7/" rel="bookmark">
			C语言解决PTA1008 数组元素循环右移问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 输入样例:输出样例:核心思想完整源码测试效果 本博文源于胡凡老师的《算法笔记》，解决这道题目的关键就是先取模，后打印，打印的话直接n-m - n-1打印，然后1再打印0,n-m打印，思路特别清晰，代码也很简洁，清晰易懂 输入样例: 6 2 1 2 3 4 5 6 输出样例: 5 6 1 2 3 4 核心思想 先取模避免m大于n，然后就开始n-m - n-1的打印，然后1-n-m打印即可。
完整源码 #include&lt;stdio.h&gt; int main() { int a[110]; int n,m,cnt = 0; scanf("%d%d",&amp;n,&amp;m); m = m%n; for(int i =0;i&lt;n;i++){ scanf("%d",&amp;a[i]); } for(int i = n-m;i&lt;n;i++){ //输出n-m 号 到 n-1号数字 printf("%d",a[i]); cnt ++; if(cnt&lt;n) printf(" "); } for(int i = 0;i&lt;n-m;i++){ printf("%d",a[i]); cnt++; if(cnt&lt;n)printf(" "); } return 0; } 方法2最大公约数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61880eda4851b5e6b868ba064ea701b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/693af2b14a160d63a2606744fd922196/" rel="bookmark">
			程序中变量的存储和显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、存储和显示
存储形式：变量在电脑中的存储形式，数值变量都是以补码的形式进行存储的（正数的原码、反码、补码是相同的；负数的原码，反码，补码是不同的）；
显示形式：将变量的存储数据，经过处理后，显示给人看的，因此用户才能看到正数，负数，字符型数据；
二、字符型变量
字符型变量在内存中存储的是ASCII码值，每个字符都有对应的ASCII码，因此在存储的时候存储的是字符型变量对应的ASCII码；
在显示的时候，按照%c格式显示，则显示的是对应的字符；按照%d格式显示，则显示的是对应的ASCII码，即数值；
三、存储系统是针对机器的，而显示系统是针对人的，因此看到的和存储的是不一样的，注意区分。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88073cb7a6b09ab8821b027e13f60c7c/" rel="bookmark">
			数据库系统原理——概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		穷则独善其身，达则兼济天下
一. 什么是数据库 狭义：存储数据的仓库
广义：可以对数据进行存储和管理的软件以及数据本身统称为数据库
定义：是长期存储在计算机内的、有组织的、可共享的数据集合
数据库是由表、关系、操作组成
二. 为什么需要数据库 几乎所有的应用软件的后台都需要数据库
数据存储数据占用空间小，容易持久保存
数据库的内容是存储在硬盘上，掉电之后任然存在 存储比较安全
软件是加密的，只能通过DBMS打开 容易维护和升级
使用SQL语句方便操作数据 数据库移植比较容易
简化对数据的操作
数据库是第四代语言，是一些命令
为将来学习Oracle做准备
B/S架构里面包含数据库
三. 预备知识 1. 学习数据库必须要学习数据库原理吗？ 是滴，数据库原理是理论知识，数据库软件是对数据库的实现
2. 学习SQL server必须先学一门编程语言吗？ 不需要，但是懂一门编程语言有助于学习SQL server中的TL-SQL
TL-SQL带有流程控制的SQL命令
3. 数据结构和数据库的区别？ 数据库：是在应用软件级别研究数据的存储和操作（外存级别）
数据结构：是在系统软件级别研究数据的存储和操作（内存级别）
4. 什么是连接 5. 有了编程语言为什么还需要数据库 保存数据的容器：数组、集合、文件
其中数组、集合是临时性存储 文件是持久化存储 对内存数据操作是编程语言的强项，但对硬盘数据操作却是编程语言的弱项
对硬盘数据操作却是数据库强项，是数据库研究核心
6. 建议初学者从三个方面学习数据库 数据库是如何存储数据的
字段 记录 表 约束 （主键、外键、唯一键、非空、check、default、触发器） 什么是约束
定义：对一个表中的属性操作的限制叫约束 分类： 主键约束：不允许重复元素，避免了数据冗余 主键定义：可以唯一标识一个事物的一个字段或多个字段的组合 主键表：含有主键字段的表 注：主键通常是整数，不建议使用字符串（除非主键用于集群式(个机器)服务可考虑） 主键的值通常都不允许修改，除非本记录被删除 主键不要定义成id，而要定义成表名id或表名_id 要用代理主键，不要用业务逻辑主键（用一个没有实际意义的编号当主键）	外键约束：通过外键约束从语法上，保证了本事物所关联的其他事物一定是存在的 事物和事物的关系是通过外键来体现的 外键定义：如果一个表中的若干个字段是来自另外若干个表的主键或唯一键，则这若干个字段就是外键 外键表：含有外键字段的表，外键字段来自的那一张表叫主键表 注：外键通常是来自另外表的主键而不是唯一键，因为唯一键可能是null 外键不一定来自另外的表，也可能来自本表的主键 先删除主键表还是外键表？ 答：先删除外键表 如果先删除主键表，会报错，因为这会导致外键表中的数据引用失败 check约束：保证事物属性的取值在合法范围内 default约束：保证事物属性一定会有一个值 唯一(unique)约束：保证了事物属性的取值不允许重复，但允许其中有一列为空 注：SQL server只允许一个unique列为空 Oracle运行多个unique列为空 not null约束：要求用户必须为该属性赋一个值，否则语法出错 如果一个字段不写null也不写not null，则默认值是null，即允许为空 注：null和default区别 同：都允许用户不赋值 不同：null修饰的字段如果用户不赋值则默认是null default修饰的字段如果用户不赋值则默认是default指定的那个值 表和约束的区别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88073cb7a6b09ab8821b027e13f60c7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdce47057bdcdcf194b78af87f673402/" rel="bookmark">
			java 内存管理和面向对象的三大特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内存管理：由JVM管理的
堆：
存储new出来的对象(包括实例变量)
垃圾：没有任何引用所指向的对象
垃圾回收器(GC)不定时到内存堆中清扫垃圾，回收的过程中透明的(看不到的)，不一定一发现垃圾就立刻回收，通过调用System.gc()建议虚拟机尽快调度GC来回收
实例变量的生命周期：
创建对象时存储在堆中，对象被回收时一并被回收
内存泄漏：不再使用的对象没有被及时的回收，严重的泄漏会导致系统的崩溃，建议：不再使用的对象应及时将引用设置为null
栈：
存储正在调用的方法中的局部变量(包括方法的参数)
调用方法时，会为该方法在栈中分配一块对应的栈帧，栈帧中存储局部变量(包括方法的参数)，方法调用结束时，栈帧被自动清除，局部变量一并被清除。
局部变量的生命周期：
调用方法时存储在栈中，方法调用结束时与栈帧一并被清除
方法区：
存储.class字节码文件(包括静态变量、所有方法)方法只有一份，通过this来区分具体的调用对象 面向对象三大特征总结： 封装：
类：封装对象的属性和行为方法：封装的是具体的业务逻辑实现访问控制修饰符：封装的是具体的访问权限 继承：
作用：代码复用
超类：所有派生类所共有的属性和行为
接口：部分派生类所共有的属性和行为
派生/实现类：派生类所特有的属性和行为
单一继承、多接口实现，具有传递性
多态：
行为多态：所有抽象方法都是多态的(通过重写来表现)
对象多态：所有对象都是多态的(通过向上造型为表现)
重写、向上造型、强制类型转换、instanceof判断
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0c69d22816a5dc637d34a030ccb60ee/" rel="bookmark">
			shell编程-流程控制-if-case-for
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流程控制 1. if语句 我们直接来了解多分支吧，但分支和双分支太简单了，它包含在多分支里面
格式：
if [判断条件1] then 条件1成立时，执行的程序 elif [判断条件2] then 条件2成立时，执行的语句 ... else 当所有条件都不成立，执行的语句 fi 来个完整的四则运算脚本吧
#!/bin/bash read -p "请输入数字1：" num1 read -p "请输入数字2：" num2 read -p "请输入你需要的运算符【+ - * / %】：" oper if [ -n "$num1" -a -n "$num2" -a -n "$oper" ] then tt1=$(echo $num1 | sed s/[0-9]//g) tt2=$(echo $num2 | sed s/[0-9]//g) if [ -n "$tt1" -o -n "$tt2" ] then echo "ERR-13：请输入正确的数字!!!" exit 13 else if [ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0c69d22816a5dc637d34a030ccb60ee/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/163/">«</a>
	<span class="pagination__item pagination__item--current">164/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/165/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>