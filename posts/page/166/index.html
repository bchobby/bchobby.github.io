<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2951c831c6b523bdd665036ae55ef64/" rel="bookmark">
			CentOS7配置本地yum源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日遇到了一个问题，客户分配的虚拟机上面安装了centos7.6的系统，但是却是用最小化方式安装的，常用的功能全都没有安装上，与维护部门协商无效，就只能自己动手丰衣足食了。
采用本地源方式来安装所需的功能或组件，整理过程如下：
操作系统：centos7.6，最小化安装。
iso镜像:CentOS-7-x86_64-DVD-1810.iso
（如果你下载不到iso可以联系我，wxlbrxhb@163.com）
1、将iso上传到服务器
2、在根目录下新建一个iso目录用于挂在本地iso镜像
3、使用命令将iso镜像挂在到iso目录
mount -o loop /home/CentOS-7-x86_64-DVD-1810(7.6).iso /iso/
4、备份原yum源配置文件
5、创建本地yum源配置目录
6、创建本地yum源配置文件
7、在CentOS-local.repo中填写如下内容
[CentOS7.6]
name=CentOS7.6-local
#步骤2中挂载镜像创建的目录
baseurl=file:///iso
#启动yum源： 1-启用 0-不启用
enabled=1
#安全检测： 1-开启 0-不开启
gpgcheck=0
#RPM-GPG-KEY-CentOS-7文件的实际路径
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
8、更新yum源配置
yum clean all
yum makecache
9、使用yum list或者yum repolist后如看到以下内容说明配置成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0685f98be0368162d118fe08e34e0a74/" rel="bookmark">
			课程实习stm32主从蓝牙计算器&#43;温度测量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：对于主从蓝牙计算器项目中的代码都是本人经过思考之后自行创作出来的，没有经过任何的网上抄录，由于课程实习的要求不高，所以我就没有对一些出现的bug进行修改（没有删除功能等）。但是基本的加减乘除都可以实现，包括在一次运算完成之后可以直接进行第二次运算，不需要复位。
我的风格就是先上代码：由于代码比较长，包含关系较为复杂（也算是个比较全面的小项目），所以我会在文章结尾以百度网盘链接的形式展示给大家。
硬件方面：板子用的stm32vet6 hc-05蓝牙模块 iic0.96寸oled 。开发板是学校实习发的，上面有许多的外设模块，我们要用的的有4个独立按键和矩阵键盘以及ds18b20温度传感器。由于开发板是学校的资源，老师也重点强调了不可以向外发布（我觉得非常没有这样必要，我觉得在学习的过程中要保持开源和互相沟通的心理，这样做.......） ，所以这里我就不提供原理图了。
软件方面：本次实习有四个任务，我把四个任务的代码全部整合到了一起，就是在刚开始的界面oled会提示你选择进入那个任务，并按照提示不同的按键选择不同的任务。
前两个任务太过简单，就没有讲的必要，就是基础的按键控制灯，只不过第二个任务用的是矩阵键盘。讲的话浪费大家时间也有失我的水准。
直接从第三个任务讲起。第三个任务是，用ds18b20测量温度，温度越高，亮的led灯就越多。是不是也是很简单，作为一个合格的嵌入式软件工程师应该很快就会想出解决的方法。唯一麻烦的就是对于ds18b20的温度读取上，这里我偷了个懒，直接从淘宝上找商家要的代码，然后改个数据引脚就行。但是对于嵌入式学习来说，最核心最重要的就是对于驱动的编写上，ds18b20是单总线协议的芯片，我曾经写过dht11的驱动代码，也是单总线协议，上手ds18b20的驱动相信也不会很难，但是由于实习时间比较紧张，就直接拿现成的用了，但是建议大家在时间充裕的条件下还是好好的研究芯片的时序图，写写驱动代码，还是很好玩的。
第四个任务。第四个任务我个人认为是相对较为难一些的，毕竟几乎用了我一个小下午的时间。
第四个任务是，在A板输入，然后在B板进行显示并且进行运算，采取蓝牙通信的方式。首先我们解决第一个问题蓝牙通信，实习老师发的是hc-05蓝牙模块，我之前用做过蓝牙遥控小车，所以基本上主从模式很快就可以配好，这里推荐给大家一篇博客。
(7条消息) 蓝牙HC-05上电自动互联（最详细教程）_CaT-CSDN博客_hc05自动连接https://blog.csdn.net/exm_further/article/details/91127481这里要说明一下，蓝牙配好之后，通信的方式我们还是用的串口通信。我们可以把蓝牙直接看成导线使用，一次发一个字节。
蓝牙配好之后，接下来就是计算器程序的编写。我们可以这样想，不管是加减乘除运算，计算的格式都是A_B=C的这种形式，‘_’可以是加减乘除。在A板（主机）我们循环扫描矩阵键盘，并设置每个按键对应数字和加减乘除等的对应关系。当按下一个按键时，通过串口发送对应的字符。B板（从机）在接收到字符之后进行判断是数字还是加减乘除等，如果是数字则判断是第一个还是第二个数字，如果是加减乘除则把对应的标志位设置成相对应的数字，如果是等则根据加减乘除的标志位和记录的第一个和第二个数来计算结果。以上的操作在判断完成之后都会实时的显示在oled上。具体的详细信息，我在代码里面都有注释，大家可以好好看看思考一下。
代码链接：https://pan.baidu.com/s/1ssYG3fslDiQvrLFnPoG7Lw 提取码：4s7k
Vincent-NJW
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8be53a66a4251995eca4fbfc7144281/" rel="bookmark">
			uni.scss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/**
* 下方引入的为uView UI的集成样式文件，为scss预处理器，其中包含了一些"u-"开头的自定义变量
* 使用的时候，请将下面的一行复制到您的uniapp项目根目录的uni.scss中即可
* uView自定义的css类名和scss变量，均以"u-"开头，不会造成冲突，请放心使用
*/
@import 'uview-ui/theme.scss';
$IMG_URL: 'http://file.shopro.top'; //css中背景图片变量。js图片变量在env.js
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe6b03080a727ae78faee45a55305752/" rel="bookmark">
			UVM实战 卷I学习笔记11——UVM中的factory机制（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 factory机制的实现创建一个类的实例的方法*根据字符串来创建一个类用factory机制创建实例的接口factory机制的本质 factory机制的实现 创建一个类的实例的方法 前面UVM根据run_test的参数my_driver创建一个my_driver的实例，这是factory机制的一大功能。
一般的面向对象的编程语言要创建一个类的实例有两种方法，一种是在类的可见的作用范围之内直接创建：
class A … endclass class B; A a; function new(); a = new(); endfunction endclass 另外一种是使用参数化的类：
class parameterized_class # (type T) T t; function new(); t = new(); endfunction endclass class A; … endclass class B; parameterized_classs#(A) pa; function new(); pa = new(); endfunction endclass 这样pa实例化时，其内部就创建了一个属于A类型的实例t。但如何通过一个字符串来创建一个类？这里的前提是这个字符串代表一个类的名字。
class A; … endclass class B; string type_string; function new(); type_string = "A"; //how to create an instance of A according to type_string endfunction endclass 没有任何语言会内建一种如上的机制：即通过一个字符串来创建此字符串所代表的类的一个实例。如果要实现这种功能需要自己做，factory机制正是用于实现上述功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe6b03080a727ae78faee45a55305752/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb2e52b6be25c49c070daa88dd28642a/" rel="bookmark">
			matlab绘图学习（二维曲线）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 函数 一、plot函数的基本用法:
二、 plot函数的调用格式
（1）最简单的调用plot(x）
（2）当plot函数的参数x是复数向量时，则分别以该向量元素的实部和虚部为横、纵坐标绘制出一条曲线
（3）plot(x,y)函数参数的变化形式
(4)含多个输入参数的plot函数
( 5）含选项的plot函数
三、fplot函数
1.fplot函数的调用
总结
前言 所有程序均已经经过调试，本篇文章为记录自己学习matlab的过程
plot函数 一、plot函数的基本用法: plot(x,y)
其中，x,y分别存储x坐标和y坐标数据
例子：绘制一条折线：
&gt;&gt; x=[2.5,3.5,4,5]; &gt;&gt; y=[1.5,2,1,1.5]; &gt;&gt; plot(x,y) 二、 plot函数的调用格式 （1）最简单的调用plot(x） &gt;&gt; x=[2.5,3.5,4,5]; &gt;&gt; plot(x) （2）当plot函数的参数x是复数向量时，则分别以该向量元素的实部和虚部为横、纵坐标绘制出一条曲线 复数（实为横，虚为纵）
&gt;&gt; x=[2.5,3.5,4,5]; &gt;&gt; y=[1.5,2,1,1.5]; &gt;&gt; cx=x+y*i; &gt;&gt; plot(cx) 程序也可将cx=x+y*i;换成cx=complex(x,y);有一样的效果
（3）plot(x,y)函数参数的变化形式 当x是向量，y是矩阵时：矩阵的列数等于x的长度，则以向量x为横坐标，以y的行向量为纵坐标绘制曲线，曲线条数等于y的行数。
矩阵的行数等于x的长度，则以向量x为横坐标，以y的列向量为纵坐标绘制曲线，曲线条数等于y的列数。
【绘制sinx，sin(2x),sin(x/2)的函数曲线】
&gt;&gt; x=linspace(0,2*pi,100); &gt;&gt; y=[sin(x);sin(2*x);sin(0.5*x)]; &gt;&gt; plot(x,y) x,y为同型矩阵，以x、y对应列元素为横、纵坐标分别绘制曲线，曲线条数等于矩阵的列数。
&gt;&gt; t=0:0.01:2*pi; &gt;&gt; t1=t'; &gt;&gt; x=[t1,t1,t1]; &gt;&gt; y=[sin(t1),sin(2*t1),sin(0.5*t1)]; &gt;&gt; plot(x,y) (4)含多个输入参数的plot函数 plot(x1,x2,x3```,xn,yn)
每一向量对构成一组数据点的横、纵坐标，绘制一条曲线
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb2e52b6be25c49c070daa88dd28642a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a70152be27a0a237418262f0d0c180c/" rel="bookmark">
			python制作小游戏，逢七拍腿升级版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逢七拍腿首先需要某数到另外某数找到所有7的倍数，我们设b为开始的数，设d为结束的数，设a为不能说的数——也就是7.
a = 7 b = 1 d = 100 然后执行一个for循环寻找b~d所有7的倍数
for c in range(int(b),int(d)+1): if c % a ==0: print("拍！") 通过c%a取余，余数=0就拍腿（也就是整除）
在遇到包含7但是并不是7的倍数的数，这种办法就不管用了。可以把c转换成字符串，看看这个字符串里包不包含7
e = str(int(7)) in str(c) str1 in str2，就是查找字符串2中包不包含字符串1，是则返回True，否则返回False。
在包含7时也要拍腿，修改代码为：
a = 7 b = 1 d = 99 for c in range(int(b),int(d)+1): e = str(int(a)) in str(c) if c % a ==0: print("拍！") else: if e == True: print("拍！") else: print(c) 为了自定义这些参数，可以再修改成以下代码，变成最有趣的版本。
print("欢迎来到逢七拍腿游戏的加强版——\r逢n拍腿！\n") a = float(input("请输入不能说出的数(也不能说这个数的倍数)：")) b = float(input("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a70152be27a0a237418262f0d0c180c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb5b7be17608f01be8d9ad02e7e79d73/" rel="bookmark">
			TCP长连接和短连接-深入浅出（还在总说http长连接吗）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查阅了一些资料，站在前人的肩膀上看世界会很美好。
什么是长连接和短连接 1.官方解释 长连接（long connnection），指在一个连接上可以连续发送多个数据包，在连接保持期间，如果没有数据包发送，需要双方发链路检测包。
短连接（short connnection），是相对于长连接而言的概念，指的是在数据传送过程中，只在需要发送数据时才去建立一个连接，数据发送完成后则断开此连接，即每次连接只完成一项业务的发送。
2.通俗一点 长连接：连接-&gt;传输数据-&gt;保持连接 -&gt; 传输数据-&gt; …-&gt;直到一方关闭连接，客户端关闭连接。长连接指建立SOCKET连接后无论使用与否都要保持连接。
短连接：连接-&gt;传输数据-&gt;关闭连接。下次一次需要传输数据需要再次连接。
下图对比帮助理解（当然，连接和响应的具体流程需要看对应的通信协议）：
3.应用场景 长连接
长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用新建立TCP连接。
例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。
短连接
而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。
所以并发量大，但每个用户无需频繁操作情况下需用短连好。
4.TCP长短连接的优势 TCP短连接 模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作。
从上面的描述看，短连接一般只会在client/server间传递一次读写操作。
短连接优点：管理起来方便，存在的连接都是有效的连接，不需要额外的控制手段。
TCP长连接 接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。下面介绍一下TCP的保活功能。
TCP的保活功能主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。如下示例：Client2关闭，TCP的保活功能使得Client1上仍然保留有一个半开放的连接，仍然在等待Cilent2的数据。
如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：
客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保证定时器复位。客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。客户主机崩溃并已经重新启动。服务器将收到一个对其保证探测的响应，这个响应是一个复位，使得服务器终止这个连接。客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。 在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损。如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。
长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。
HTTP与TCP/IP 关于HTTP和TCP/IP各协议的详细介绍点击【计算机网络-学习总结篇】。
1.HTTP协议与TCP/IP协议的关系 HTTP协议的长连接和短连接，本质上是TCP协议的长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。 IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且接受顺序与发送顺序一致。TCP协议是可靠的、面向连接的。TCP才负责连接，只有负责传输的这一层才需要建立连接！！！！！
在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。
而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码（但要服务器和客户端都设置）：
Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的TCP连接。也就是说在长连接情况下，多个HTTP请求可以复用同一个TCP连接，这就节省了很多TCP连接建立和断开的消耗。
Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。
2.如何理解HTTP协议是无状态的 HTTP协议是无状态的，指的是HTTP协议对事务处理没有记忆能力，服务器不知道客户端是什么状态。即第一次和第二次发起对应的请求之间没有任何联系。
长轮询与短轮询 1.什么是长轮询与短轮询 短轮询相信大家都不难理解，比如你现在要做一个电商中商品详情的页面，这个详情界面中有一个字段是库存量（相信这个大家都不陌生，随便打开淘宝或者京东都能找到这种页面）。而这个库存量需要实时的变化，保持和服务器里实际的库存一致。
这个时候，你会怎么做？
最简单的一种方式，就是你用JS写个死循环，不停的去请求服务器中的库存量是多少，然后刷新到这个页面当中，这其实就是所谓的短轮询。
这种方式有明显的坏处，那就是你很浪费服务器和客户端的资源。客户端还好点，现在PC机配置高了，你不停的请求还不至于把用户的电脑整死，但是服务器就很蛋疼了。如果有1000个人停留在某个商品详情页面，那就是说会有1000个客户端不停的去请求服务器获取库存量，这显然是不合理的。
那怎么办呢？
长轮询这个时候就出现了，其实长轮询和短轮询最大的区别是，短轮询去服务端查询的时候，不管库存量有没有变化，服务器就立即返回结果了。而长轮询则不是，在长轮询中，服务器如果检测到库存量没有变化的话，将会把当前请求挂起一段时间（这个时间也叫作超时时间，一般是几十秒）。在这个时间里，服务器会去检测库存量有没有变化，检测到变化就立即返回，否则就一直等到超时为止。
而对于客户端来说，不管是长轮询还是短轮询，客户端的动作都是一样的，就是不停的去请求，不同的是服务端，短轮询情况下服务端每次请求不管有没有变化都会立即返回结果，而长轮询情况下，如果有变化才会立即返回结果，而没有变化的话，则不会再立即给客户端返回结果，直到超时为止。
这样一来，客户端的请求次数将会大量减少（这也就意味着节省了网络流量，毕竟每次发请求，都会占用客户端的上传流量和服务端的下载流量），而且也解决了服务端一直疲于接受请求的窘境。
但是长轮询也是有坏处的，因为把请求挂起同样会导致资源的浪费，假设还是1000个人停留在某个商品详情页面，那就很有可能服务器这边挂着1000个线程，在不停检测库存量，这依然是有问题的。
因此，从这里可以看出，不管是长轮询还是短轮询，都不太适用于客户端数量太多的情况，因为每个服务器所能承载的TCP连接数是有上限的，这种轮询很容易把连接数顶满。哪怕轮询解决不了获取库存这个问题，但只要大家明白了长短轮询的区别，这就足够了。
2.长短轮询和长短连接的区别 这里简单说一下它们的区别：
第一个区别是决定的方式，一个TCP连接是否为长连接，是通过设置HTTP的Connection Header来决定的，而且是需要两边（服务器端与应用端）都设置才有效。而一种轮询方式是否为长轮询，是根据服务端的处理方式来决定的，与客户端没有关系。第二个区别就是实现的方式，连接的长短是通过协议来规定和实现的。而轮询的长短，是服务器通过编程的方式手动挂起请求来实现的。 参考：
https://cloud.tencent.com/developer/article/1640430
https://www.cnblogs.com/gotodsp/p/6366163.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/854e4c24e80bd6f9698533127436af88/" rel="bookmark">
			map区域合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、合并数据，在 http://geojson.io/#new 上传需要合并的json文件
2、 将右侧数据复制出来，另存为json文件
3、修改该json文件，目前得到数据如下，features数组对象下，每个对象的properties增加alias属性，属性值为合并后名字。保存
4、打开https://mapshaper.org/，选择刚上传的json文件导入，得到如下数据
5、打开网站命令行工具，输入命令 dissolve ‘alias’ -o result.json，回车，然后下载json文件
6、校验，下载完的json数据拷贝出来，放入geojson右侧JSON框内，就可以看到合并后的行政区了。注意修改properties下的属性，合并后，属性名为 alias ，需改为 name，与之前保持一致
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/713f576d4628f2d9edc2def1a0a4fc8b/" rel="bookmark">
			给出一组数从小到大排序算法 用工具给出详细描述，（1）流程图（2） N-S图（3） PDL语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c1b725615a981375828764a340c1dd2/" rel="bookmark">
			解决loaded more than 1 DLL from .libs和No metadata found in lib\site-packages两个错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		### 卸载numpy pip uninstall numpy 解决No metadata found in lib\site-packages
去这个文件夹下找到numpy的两个文件夹 删除
然后重新输入pip install numpy
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8452d4c7fab9728bfa11002ff62c34d9/" rel="bookmark">
			uuid临时游客身份——＞在请求拦截器中带&#43;本地存储（告诉服务器你是谁）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uuid:是通用唯一标识码（Universally Unique
Identifier）的缩写，是一个128比特的数值。客户端在查找一个服务时，只需要在它的服务查找请求中指出与某类服务（或某个特定服务）有关的UUID，如果服务的提供者能将可用的服务与这个UUID相匹配，就返回一个响应。
1.封装产生uuid的模块
import { v4 as uuidv4 } from 'uuid';//创建一个uuid //要生成一个随机字符串，且每次执行都不能发生变化，游客身份持久存储 export const getUUID = () =&gt;{ //先从本地存储获取uuid（看一下本地存储里面是否有） let uuid_token = localStorage.getItem('UUIDTOKEN'); //如果没有就生成游客临时身份，并且本地存储一次 if(!uuid_token){ uuid_token = uuidv4(); localStorage.setItem('UUIDTOKEN',uuid_token) } //切记有返回值 return uuid_token; } 2.将uuid保存在仓库中
3.在请求中带着uuid，请求拦截后添加一个字段
requests.interceptors.request.use((config)=&gt;{ //console.log(store) if(store.state.uuid_token){ //请求头添加一个字段(userTempId):字段名和后台商量好 config.headers.userTempId = store.state.uuid_token } nprogress.start()//进度条开始 return config; }) 4.可以看到所有请求都携带着这个uuid
5.可以看到本地存储中也保存了这个uuid
缓存使用方法
1.localStorage.setItem('TOKEN',token)//存储token到本地缓存中，命名为TOKEN
2.localStorage.getItem('token')//获取本地缓存中的token
3.localStorage.removeItem('TOKEN')//清除缓存TOKEN
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/585aeba2248e548c536d52edd2243e6b/" rel="bookmark">
			Dubbo拓展点加载机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dubbo拓展点加载机制 前言 本篇首先介绍现有Dubbo加载机制的概况，包括Dubbo所做的改进及部分特性。然后介绍加载机制已经存在的一些关键注解，@SPI、@Adaptive、@Activate。然后介绍整个接在机制中最核心的ExtensionLoader的工作流程及实现原理。最后介绍拓展中使用的类动态编译的实现原理。通过本篇的阅读，我们会对Dubbo SPI加载机制有深入的了解，也会对这部分的源码有深入的认识，后续胖友自行阅读源码也会更容易。
加载机制概述 Dubbo良好的拓展性与两个方面是密不可分的，一是整个框架中针对不同场景，恰到好处的使用了各种设计模式，二就是我们要说的加载机制。基于Dubbo SPI的加载机制，让整个框架的接口与具体实现完全解耦，从而给整个框架良好拓展性奠定了基础。
Dubbo默认提供了很多可以直接使用的拓展点。Dubbo几乎所有的功能组件都是基于拓展机制（SPI）实现的，这些核心拓展点后面会详细说。
Dubbo SPI没有直接使用Java SPI,而是在它的思想上又做了-定的改进，形成了一套自己的配置规范和特性。同时，Dubbo SPI又兼容Java SPI。服务在启动的时候，Dubbo 就会查找这些扩展点的所有实现。
Java SPI 在说Dubbo SPI之前，我们先说一下Java SPI。SPI的全称是Service Provider Interface，起初是提供给厂商做插件开发的。关于Java SPI的详细定义和解释，可以参见此处。Java SPI使用了策略模式，一个接口多种实现。我们只声明接口，具体的实现并不在程序中直接确定，而是由程序之外的配置掌控，用于具体实现的装配。具体步骤如下:
定义一个接口及对应的方法。编写该接口的一个实现类。在META-INF/services/目录下，创建一个以接口全路径命名的文件,如com.example.rpc.example.spi.HelloService。文件内容为具体实现类的全路径名，如果有多个，则用分行符分隔。在代码中通过java. util. ServiceLoader来加载具体的实现类。如此一来， HelloService的具体实现就可以由文件com.example.rpc.example.spi.HelloService中配置的实现类来确定了，这里我配置的类为com.example.rpc.example.spi.HelloServiceImpl。 项目结构如下：
Java SPI示例代码如下：
public interface HelloService { void sayHello(); } public class HelloServiceImpl implements HelloService{ @Override public void sayHello() { System.out.printf("hello world!"); } } public static void main(String[] args) { ServiceLoader&lt;HelloService&gt; serviceLoader = ServiceLoader.load(HelloService.class); //获取所有的SPI实现， // 循环调用 sayHello()方法， // 会打印出hello world 此处只有一个实现: HelloServiceImpl for (HelloService helloService : serviceLoader) { //此处会输出hello world helloService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/585aeba2248e548c536d52edd2243e6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/696a9dfc376242d18acb2d6ec1e27003/" rel="bookmark">
			K8S网络介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景介绍：
对于K8S里面容器之间的通讯基本上面可以分为三种类型：
1. POD里面不同容器之间的通讯：
因为同一个Pod里面的不同容器之间是共享同一个POD里面的网络资源，所以POD里容器之间的通讯基本上就是IPC之间的通讯方式，这个比较简单，不做详细介绍。
2.同一个NODE节点上面不同POD里面容器间的通讯：本篇文章主要用来讲解这一类通讯方式。
3.不同NODE上面的不同POD里面容器之间的通讯：这部分在后续章节介绍。
二、基础知识介绍：
网桥（Bridge）：
在 Linux 中，能够起到虚拟交换机作用的网络设备，是一个工作在数据链路层（Data Link）的设备，主要功能是根据 MAC 地址学习来将数据包转发到网桥的不同端口（Port）上。
docker0 的网桥：
Docker 项目会默认在宿主机上创建一个网桥docker0 ，凡是连接在 docker0 网桥上的容器，就可以通过它来进行通信。
Veth Pair 设备:
它被创建出来后，总是以两张虚拟网卡（Veth Peer）的形式成对出现的。并且，从其中一个“网卡”发出的数据包，可以直接出现在与它对应的另一张“网卡”上，哪怕这两个“网卡”在不同的 Network Namespace 里。
这就使得 Veth Pair 常常被用作连接不同 Network Namespace 的“网线”。
三、通讯过程介绍：
容器1的IP1访问容器2的IP2的交互过程如下所示：
1.在容器1中的路由规则里面查找IP2的地址，发现是是外部网络就会直接走容器1里面的eth0网卡（备注：走网卡的话，就是二层网路，需要探测IP2的MAC地址）。
2.eth0通过ARP广播进行探测IP2所对应的MAC地址，又因为Veth Pair的设备连接着2个网卡，所以eth0的发的ARP广播会通过docker0转发。
（备注：一旦一张虚拟网卡被“插”在网桥上，它就会变成该网桥的“从设备”。从设备会被“剥夺”调用网络协议栈处理数据包的资格，从而“降级”成为网桥上的一个端口。而这个端口唯一的作用，就是接收流入的数据包，然后把这些数据包的“生杀大权”（比如转发或者丢弃），全部交给对应的网桥。）
3.容器2里面的veth2也是通过Veth Pair连接在网桥docker0上面，所以这个ARP广播会发送到容器2里面的eth0网卡中。
4.容器2收到这个ARP之后，会返回这个IP2对应的MAC地址给到容器1里面的eth0。
5.后续容器1里面的eth0就可以直接发送消息出去了。
参考文档：
Kubernetes权威指南(第五版)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de88519fd9d60b2f8b8202278130dddb/" rel="bookmark">
			机器学习应用篇（五）——决策树分类实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习应用篇（五）——决策树分类实例 文章目录 机器学习应用篇（五）——决策树分类实例一、数据集二、实现过程1 数据特征分析2 利用决策树模型在二分类上进行训练和预测3 利用决策树模型在多分类（三分类）上进行训练与预测 三、KEYS1 构建过程2 划分选择3 重要参数 一、数据集 小企鹅数据集，提取码：xqee
该数据集一共包含8个变量，其中7个特征变量，1个目标分类变量。共有150个样本，目标变量为 企鹅的类别 其都属于企鹅类的三个亚属，分别是(Adélie, Chinstrap and Gentoo)。包含的三种种企鹅的七个特征，分别是所在岛屿，嘴巴长度，嘴巴深度，脚蹼长度，身体体积，性别以及年龄。
二、实现过程 1 数据特征分析 ## 基础函数库 import numpy as np import pandas as pd ## 绘图函数库 import matplotlib.pyplot as plt import seaborn as sns #%%读入数据 #利用Pandas自带的read_csv函数读取并转化为DataFrame格式 data = pd.read_csv('D:\Python\ML\data\penguins_raw.csv') #我选取了四个简单的特征进行研究 data = data[['Species','Culmen Length (mm)','Culmen Depth (mm)', 'Flipper Length (mm)','Body Mass (g)']] data.info() #查看数据 print(data.head()) #发现数据中存在的NAN，缺失值此处使用-1将缺失值进行填充 data=data.fillna(-1) print(data.tail()) #查看对应标签 print(data['Species'].unique()) #统计每个类别的数量 print(pd.Series(data['Species']).value_counts()) #对特征进行统一描述 print(data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de88519fd9d60b2f8b8202278130dddb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67a0e2e14c6a854a2a96d7d1309cc826/" rel="bookmark">
			multer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Multer介绍二、上传文件不修改名字1.安装express包2.安装multer包3.创建multer对象，设置上传路径4.设置post访问路径5.完整代码6.运行结果7.由于没有设置文件名，把添加.jpg后缀即可查看图片 三、上传文件并修改名字1.设置磁盘存储引擎diskStorage2.完整代码3.运行结果4.由于设置了文件名称与后缀，所以不用重命名即可查看图片 总结 前言 Multer 是一个 node.js 中间件，用于处理 multipart/form-data 类型的表单数据，它主要用于上传文件。Multer 会添加一个 body 对象 以及 file 或 files 对象 到 express 的 request 对象中。 body 对象包含表单的文本域信息，file 或 files 对象包含对象表单上传的文件信息。
一、Multer介绍 Multer 接受一个 options 对象，其中最基本的是 dest 属性，这将告诉 Multer 将上传文件保存在哪。如果你省略 options 对象，这些文件将保存在内存中，永远不会写入磁盘。一般的网页应用，只需要设置 dest 属性，如果你想在上传时进行更多的控制，你可以使用 storage 选项替代 dest。
二、上传文件不修改名字 1.安装express包 npm install express 2.安装multer包 npm install multer 3.创建multer对象，设置上传路径 Multer 接受一个 options 对象，其中最基本的是 dest 属性，这将告诉 Multer 将上传文件保存在哪。如果你省略 options 对象，这些文件将保存在内存中，永远不会写入磁盘。
const multer = require('multer') const upload = multer({ dest: '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67a0e2e14c6a854a2a96d7d1309cc826/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaeb025c33cc4c1b6c87bfc417dfb829/" rel="bookmark">
			视觉SLAM十四讲笔记-- 第三讲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 第三讲课后题1、验证旋转矩阵是正交矩阵。2.*寻找罗德里格斯公式的推导过程并加以理解。3.验证四元数旋转某个点后，结果是一个虚四元数(实部为零)，所以仍然对应到一个三维空间点，见式(3.33)。4．画表总结旋转矩阵、轴角、欧拉角、四元数的转换关系。5．假设有一个大的Eigen矩阵，想把它的左上角3×3的块取出来,然后赋值为 I 3 × 3 \boldsymbol I_{3 × 3} I3×3​ ，请编程实现。6.*一般线性方程 An =b有哪几种做法?你能在 Eigen中实现吗? 第三讲课后题 1、验证旋转矩阵是正交矩阵。 （1）正交矩阵
定义：设A为n阶方阵，如果 A T A = I A^TA=I ATA=I 或者 A A T = I AA^T=I AAT=I，就称A为正交矩阵
性质：
正交矩阵的每一个列向量都是单位向量，且向量之间两两正交。正交矩阵的行列式为1 或者 -1 A − 1 = A T A^{-1}=A^T A−1=AT(充要条件) （2）旋转矩阵
旋转矩阵描述了坐标系之间的旋转变换，由3 × 3 的矩阵描述。
验证思路是利用 正交矩阵的充要条件 （ A − 1 = A T A^{-1}=A^T A−1=AT）来验证。
根据书中的例子设单位正交基（ e 1 , e 2 , e 3 e_1, e_2,e_3 e1​,e2​,e3​）经过一次旋转变成了（ e 1 ′ , e 2 ′ , e 3 ′ e^{'}_1, e^{'}_2,e^{'}_3 e1′​,e2′​,e3′​），因为同一向量 a 在两个坐标系下分别为（ a 1 , a 2 , a 3 a_1, a_2,a_3 a1​,a2​,a3​）,（ a 1 ′ , a 2 ′ , a 3 ′ a^{'}_1, a^{'}_2,a^{'}_3 a1′​,a2′​,a3′​），没有发生变化，根据坐标定义，因此有：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaeb025c33cc4c1b6c87bfc417dfb829/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1099bfabeadef958bd86a7e74da4c00f/" rel="bookmark">
			Sublime Text默认语法设置-解决每次新建标签页都需要选择语法的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Sublime Text是一款方便快捷的代码编辑器，我们一般会重度使用一种语言（比如笔者是SQL），但是每次新建标签页都需要选择语法的操作很麻烦。这里介绍一种配置方式，能够一劳永逸的解决问题。
解决方法 单击 Tools→Developer→New Snippet 弹出一个窗口，把下面这段代码粘贴进去：
import sublime, sublime_plugin class EverythingIsPowerShell(sublime_plugin.EventListener): def on_new(self, view): view.set_syntax_file('Packages/SQL/SQL.sublime-syntax') 文件另存为 DefaultLanguage.py，路径选择：插件文件夹/Packages/User/
这样以后建立的新标签就默认是SQL语法了，如果想使用其他语法只需把上述代码中的两处SQL换成其他语言即可（比如Python）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a04febdb1d7cab6f500a1c4a2a8b8837/" rel="bookmark">
			RPC 远程过程调用（Remote Procedure Call）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 是RPC框架，首先了解什么叫RPC，为什么要RPC，RPC是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。
比如说，一个方法可能是这样定义的：
Employee getEmployeeByName(String fullName)
那么：
首先，要解决通讯的问题，主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。第二，要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么，这样才能完成调用。比如基于Web服务协议栈的RPC，就要提供一个endpoint URI，或者是从UDDI服务上查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。第三，当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如TCP传递到B服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化（Serialize）或编组（marshal），通过寻址和传输将序列化的二进制发送给B服务器。第四，B服务器收到请求后，需要对参数进行反序列化（序列化的逆操作），恢复为内存中的表达方式，然后找到对应的方法（寻址的一部分）进行本地调用，然后得到返回值。第五，返回值还要发送回服务器A上的应用，也要经过序列化的方式发送，服务器A接到后，再反序列化，恢复为内存中的表达方式，交给A服务器上的应用。 同时需要对 RMI(Remote Method Invoke，远程方法调用)中的 stub (桩)和skeleton (骨架)的概念有一点了解。RMI 的代理模式是通过代理对象将方法传递给实际对象的。stub 驻留客户端,承担着代理远程对象实现者的角色。skeleton 类帮助远程对象与 stub 连接进行通信。
服务调用方（client）调用以本地调用方式调用服务；client stub 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；client stub 找到服务地址，并将消息发送到服务端；server stub 收到消息后进行解码；server stub 根据解码结果调用本地的服务；本地服务执行并将结果返回给 server stub；server stub 将返回结果打包成消息并发送至调用方；client stub 接收到消息，并进行解码；服务调用方得到最终结果。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9755b27255b660706a7ad69804ba89c/" rel="bookmark">
			python 读取excel表格某列数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用python包栈为openpyxl
2.多说无益，直接上代码
3.读取两个excel某列数据进行对比取交集
import openpyxl def get_entitydi(): workbook = openpyxl.load_workbook("2021年行业返佣.xlsx") book_sheet = workbook["Sheet1"] row_all = book_sheet.rows data = [] for row in list(row_all)[2:]: coinsh = [] for value in row: coinsh.append(value.value) data.append(coinsh) entity_list = [] for parment in data: entity = parment[7] entity_list.append(entity) return entity_list def get_data(): workbook = openpyxl.load_workbook("有效时间表.xlsx") book_sheet = workbook["Sheet1"] row_all = book_sheet.rows data = [] for row in list(row_all)[1:]: coinsh = [] for value in row: coinsh.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9755b27255b660706a7ad69804ba89c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8ee4b9a02a616945994891bdbb7cd46/" rel="bookmark">
			Maven拉取Nexus中jar包Could not transfer artifact *** from ***报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实习期间的公司用了统一的nexus作为中央仓库，从中央仓库拉取jar包的时候，idea控制台出现了Could not transfer artifact ………省略 的报错，检查maven的setting.xml文件发现配置的账号密码确实是正确的，用同事的电脑自己的账号，发现也没问题，判断问题出现在了本机。查询资料nexus并没有ip过滤之类的，另一个setting文件配置的阿里云镜像，但是mirrorof配置的central中央仓库，应该不会造成冲突。
报错情况如下：
maven的setting文件和仓库位置配置均没有错误的情况下：
发现正在导入里面的vm选项可能会存在一些安全性考虑的设置
需要设置忽略ssl证书检验：
-Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true 顺利完成下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a56d059b9773ab5c922218958f2a5275/" rel="bookmark">
			Hive相关基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive相关基础知识 文章目录 Hive相关基础知识1. Hive简介2. Hive数据模型3. Hive特点4. 使用Hive操作数据5. 参考链接 1. Hive简介 Hive是基于Hadoop的一个数据仓库工具，用来进行数据提取、转化、加载，这是一种可以存储、查询和分析存储在Hadoop中的大规模数据的机制。hive数据仓库工具能将结构化的数据文件映射为一张数据库表，并提供SQL查询功能，能将SQL语句转变成MapReduce任务来执行，通过自己的SQL查询分析需要的内容，这套SQL简称Hive SQL。
2. Hive数据模型 Hive数据库。类似传统数据库的DataBase。内部表。Hive的内部表与数据库中的Table在概念上是类似。外部表。外部表指向已经在HDFS中存在的数据，可以创建Partition。它和内部表在元数据的组织上是相同的，而实际数据的存储则有较大的差异。分区。Partition对应于数据库中的Partition列的密集索引。桶。Buckets是将表的列通过Hash算法进一步分解成不同的文件存储。 3. Hive特点 Hive表的数据默认只能在末尾追加。我们通常可以认为Hive不支持更新操作，这是因为Hive开启更新操作对性能影响极大，因此一般关闭Hive的更新功能。
Hive操作数据的特点： 支持分区存储数据追加数据(append)全表覆盖+新增(overwrite)不支持更新不支持删除 Hive本身特点： 可伸缩（在Hadoop的集群上动态添加设备）可扩展容错输入格式的松散耦合 4. 使用Hive操作数据 使用Scala语言来进行Hive的相关操作。
/* * 需要在resources添加spark相关配置文件 */ object HiveTest { // 设置用户 System.setProperty("HADOOP_USER_NAME", "hdfs") // 设置SparkConf对象 var conf: SparkConf = new SparkConf() conf.setAppName("HiveTest") conf.setMaster("local") // 创建SparkContext对象 val spark: SparkContext = new SparkContext(conf) // 创建SparkSession对象 val sparkSession: SparkSession = SparkSession .builder() .config(conf) .enableHiveSupport() .getOrCreate() def main(args: Array[String]): Unit = { val df01: DataFrame = select() df01.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a56d059b9773ab5c922218958f2a5275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31e2249ced1e93a61ca927a76c13d6df/" rel="bookmark">
			详解一下JQuery中的each（）方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;body&gt;
&lt;div&gt;1&lt;/div&gt;
&lt;div&gt;2&lt;/div&gt;
&lt;div&gt;3&lt;/div&gt;
&lt;script type="text/javascript"&gt;
$(function(){ // 如果要给数组分配不同样式，还要避免隐式迭代 就要用遍历 JQuery遍历 // 定义数组分配颜色
let col =["red","green","blue"];
// 如果要计算总和，设一个变量
let sum =0;
// each函数是遍历 等同for 但是比for强大
// 两个函数 第一个是下标 第二个是元素
$("div").each(function(i,domElm) {
console.log(i);
console.log(domElm);
// elm是DOM元素，要先转换才可以改变样式
$(domElm).css("color",col[i]);
// 计算总和
// 总和是元素中间填写的内容相加 就是 domElm 但这是字符串 所以要先将其改为数值型parseInt
sum=sum+parseInt($(domElm).text());
});
console.log(sum);
});
$(function(){
// 如果定义了一个颜色数组，想要遍历这个颜色的数组，但是each()方法做不到，就用到 $.each ()方法了
let col =["red","green","blue"];
// 与each方法类似，这里先写$.each(括号第一个函数写数组名称，第二个函数写function)
// $.each()可用于遍历任何对象，比如数组，对象，主要用于数据处理
$.each(col,function(i,domElm){
console.log(i);
console.log(domElm);
});
});
&lt;/script&gt;
&lt;/body&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15d77294806592634f1871d0784854ec/" rel="bookmark">
			java第五天循环结构，数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		循环结构：
for结构：应用率高、与次数相关的循环
语法：
// 1 2 3
for(要素1;要素2;要素3){
语句块/循环体----------------反复执行的代码 4
}
执行过程：
1243243243243243243......2
代码演示：
//for循环中的循环变量i，作用域仅在当前for中 for(int i=1;i&lt;=9;i++){ System.out.println(i+"*9="+i*9); } for(int i=1;i&lt;=9;i+=2){ System.out.println(i+"*9="+i*9); } for(int i=9;i&gt;=1;i--){ System.out.println(i+"*9="+i*9); } for(int times=0;times&lt;5;times++){ System.out.println("行动是成功的阶梯"); } System.out.println("继续执行..."); /* 执行过程: times=0 true 输出 times=1 true 输出 times=2 true 输出 times=3 true 输出 times=4 true 输出 times=5 false for循环结束 输出继续执行... */ //for的特殊格式:----------了解 int i=1; for(;i&lt;=9;i++){ System.out.println(i+"*9="+i*9); } for(int i=1;i&lt;=9;){ System.out.println(i+"*9="+i*9); i++; } for(;;){ //没有条件的循环就是一个死循环 System.out.println("我要学习..."); } for(int i=1,j=5;i&lt;=5;i+=2,j-=2){ } /* i=1,j=5 true i=3,j=3 true i=5,j=1 true i=7,j=-1 false */ 三种循环结构的选择规则：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15d77294806592634f1871d0784854ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09d76858456649ba4fc12bee53f17661/" rel="bookmark">
			Python的繁体简体转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 opencc 包实现简繁体转换。
# 安装 # pip install opencc-python-reimplemented # t2s - 繁体转简体（Traditional Chinese to Simplified Chinese） # s2t - 简体转繁体（Simplified Chinese to Traditional Chinese） import opencc print(opencc.OpenCC('s2t').convert('简体转繁体。明天你好！')) # 簡體轉繁體。明天你好！ print(opencc.OpenCC('t2s').convert('簡體轉繁體。明天你好！')) print(opencc.OpenCC('hk2s').convert('簡體轉繁體。明天你好！')) print(opencc.OpenCC('s2hk').convert('簡體轉繁體。明天你好！')) 更多类型详见：配置文件 Lib\site-packages\opencc\config\*.json
例如 t2s.json:
{ "name": "Traditional Chinese to Simplified Chinese", "segmentation": { "type": "mmseg", "dict": { "type": "txt", "file": "TSPhrases.txt" } }, "conversion_chain": [{ "dict": { "type": "group", "dicts": [{ "type": "txt", "file": "TSPhrases.txt" }, { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09d76858456649ba4fc12bee53f17661/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/770d9190c1b86d8083353a85a68d0422/" rel="bookmark">
			金融云原生漫谈（三）｜银行云原生基础设施构建：裸金属VS虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在金融行业数字化转型的驱动下，国有银行、股份制银行和各级商业银行也纷纷步入容器化的进程。
如果以容器云上生产为目标，那么整个容器云平台的设计、建设和优化对于银行来说是一个巨大的挑战。如何更好地利用云原生技术，帮助银行实现敏捷、轻量、快速、高效地进行开发、测试、交付和运维一体化，从而重构业务，推动金融科技的发展，是个长期课题。
本期金融云原生漫谈，将和大家共同探讨银行在进行云原生基础设施构建时，裸金属和虚拟机哪个更适合作为容器云底层计算资源？谁代表了未来？
虽然，金融行业推进云原生建设的各种实践案例比比皆是，然而银行在着手实际建设之初，围绕“如何构建先进的云原生基础设施”的话题，依然众说纷纭，没有特别明确的答案。
以部署容器的底层计算资源为例，理论上来说容器云可以运行在任意基础设施上，既可以选择裸金属部署，也可以选择虚拟机部署。
过去，很多银行会选择虚拟机作为容器云的底层计算资源，然而，虚拟化的过程在为用户带来高灵活性的同时，其性能损耗也给用户带来了焦虑。
现在，随着容器技术的成熟，在裸金属上部署容器所带来的高性能等特点越发明显，让用户又开始面临着裸金属部署还是虚拟机部署的选择题。
在虚拟机上部署容器云平台有什么优劣势？在裸金属上部署容器云平台有什么优劣势？ 本篇文章将带你一探究竟。
在虚拟机上部署容器云平台有什么优劣势？ 首先，选择虚拟机，可以最大化利用现有的基于虚拟化的云计算资源，为用户带来高灵活性的运维体验。从硬件管理层面来看，虚拟机对于底层硬件资源的管理和监控能力也更强。
但相对于裸金属，在虚拟机上部署容器云平台的性能损耗会更高一些。基于容器的云原生的价值之一就是直接和硬件层打交道，减少软件层的损耗以提升性能。然而我们在金融行业的落地实践中发现，使用虚拟机+容器方案，相比物理机直接跑容器中间多了一层Hypervisor，可能会导致很多硬件创新无法及时、高效地提供给应用使用，性能也会损耗大概10%～20%。
在裸金属上部署容器云平台有什么优劣势？ 目前我们在客户实践案例中，渐渐可以看到一个趋势，越来越多的用户会选择裸金属部署容器。那么裸金属服务器有哪些优势呢？
首先在性能层面，由于少了虚拟机这一层的性能损耗，裸金属服务器构建出来的容器平台性能损失更小。应用程序可以直接访问CPU、内存及其他硬件资源，从而大大缩短延迟，并最大限度地提高资源利用率，有助于大幅提升性能。从具体的场景角度来看，例如人工智能的推理场景，借助 CPU 的 AI 优化指令集，AI 推理的性能可能带来几十倍甚至上百倍的性能提升。
在成本层面，由于少了虚拟机部分的建设投入，裸金属服务器构建出来的容器平台成本投入更低。在相同成本的前提下，裸金属配置往往能够提供比虚拟机配置更强大的功能，更适合需要高端硬件和快速扩展的较复杂项目。
在管理层面，由于少了虚拟机这一层的运维管理，裸金属服务器构建出来的容器平台运维管理更为简单。裸金属服务器的好处贯穿于整个开发过程。缺少虚拟化层降低了系统的复杂性，使故障排除起来更容易。由于配置更精简，管理服务自动化和软件部署也更容易。
在安全层面，裸金属服务器是单租户环境，比虚拟机的多租户环境更安全。裸金属服务器管理员全面控制系统配置，在降低网络攻击风险、敏感信息处理方面更具优势。对于关键类应用或性能要求较高的业务（如大数据集群、企业中间件系统），并且要求安全可靠的运行环境，更推荐使用裸金属服务器部署容器。
在工作负载层面，裸金属服务器可以支持灵活创建针对特定工作负载而优化的配置。虚拟机实例通常托管旨在满足一般工作负载需求的配置上。这意味着非常特定的硬件配置很少可供使用。而裸金属服务器配置可高度定制，可加以优化来支持要求苛刻的特定工作负载。
在组织层面，裸金属服务器不会被供应商工具束缚。裸金属服务器上的容器云平台可以支持管理员全面控制底层的硬件基础架构，使组织避免供应商锁定现象，降低迁移解决方案的难度。
当然，裸金属服务器作为底层计算资源相比与虚拟机也有一些缺点，主要是在容器云扩容层面，容器云的节点扩容性不如虚拟机，毕竟裸金属服务器的采购周期较长。
此外在硬件管理层面，应用裸金属部署容器的另一个问题在于如何提高底层硬件资源的管理和监控能力，相对于传统的云计算平台，K8s本身作为一个服务和负载的调配平台，目前对底层资源的管理能力相对较弱。
但是值得一提的是，目前已经出现了一些基础设施层面的优化工具，例如Intel有一些CPU调度相关组件（CPU Management，Resource Management Daemon等），ARM也有很多针对CPU性能优化方面的工具，可以帮助我们实现裸金属的高级部署方式，提升容器在裸金属上部署的硬件管理能力，更高效地利用硬件级别的创新，如计算加速设备、低延迟大带宽网络设备、高性能持久化设备等。
在实际业务中，选择裸金属还是虚拟机，作为容器云的底层计算资源，还要取决于银行的IaaS能力。如果银行的IaaS能力提供祼金属服务，特别是软硬一体化加速的祼金属服务，则优先祼金属服务，可获得高性能的同时，也得到了扩缩容的弹性支持。否则，建议采用虚拟机以提升交付效率、弹性伸缩和降低运维成本。
不过可以肯定的是，无论选择裸金属，还是虚拟机，以容器为代表的云原生技术都将为银行数字化转型增添浓墨重彩的一笔。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da15598306ebe3668f5d9f69a8f69f63/" rel="bookmark">
			做angular框架遇到的一些小东西
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：样式引入不生效，在子组件外层组件引入angular 2的样式封装，view encapsulation ，属性为encapsulation：ViewEncapsulation.None
@component（｛
selector ：“webform”，
templateUrl：“./webform.html”，
styleUrls：【“./webform.component.scss”】，
encapsulation: ViewEncapsulation.None
})
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24bfc0a773beba3be2363656250dcc62/" rel="bookmark">
			字符与字符串转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将一个数值使用 字符串转整形 得到的是需要转换的整数，如
string str =“259”; //str不可以是浮点数，否则报错 Debug.Log ( Convert.ToInt32(str)); //输出259 但当将一个 字符 转换为整形时，会根据“ASCII码对照表”进行转换，如
char str =‘1’; Debug.Log ( Convert.ToInt32(str)); //49 如果字符不想根据ASCII码对照表进行转换，可将字符转换为字符串即可，如
char str =‘1’; Debug.Log ( Convert.ToInt32(str.ToString ())); // 1 在进制转换时候可用到：
//Changed8To2( 7,num1,num2,num4); private void Changed8To2(int _num,int _num1,int _num2,int _num4) { string _binary = Convert.ToString(_num, 2); //十进制转为二进制 Debug.Log(_binary.Length ); if (_binary.Length == 3) { Debug.Log(_binary[0]); // 1 Debug.Log(Convert.ToInt32(_binary[0])); // 49 Debug.Log(Convert.ToInt32(_binary[0].ToString ())); // 1 _num1 = Convert.ToInt32(_binary[2].ToString ()); _num2 = Convert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24bfc0a773beba3be2363656250dcc62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9df9ee1abd87365b69f8a4c00af85ad6/" rel="bookmark">
			Matlab在一张图上绘制多条拟合曲线，曲线颜色自定，显示指定图例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		clear all;clc; x1 = [2,1,2.3,2.2,1.2,2.4]; x2 = [6,7.6,8.6,7.8,6.6,8]; y1 = [10,11.2,13.2,13,12.4,12.7]; y2 = [6.5,6.7,7.8,6.6,8,9]; cftool 调用打开cftool工具箱
（有cftool的代码好像不能设置断点，直接用ctrl+R把后面的代码先注释掉，不然在cftool工具箱里会不显示x1,x2,y1,y2这些数据？）
在X data里面选择要拟合数据的横坐标值，在Y data里面选择要拟合数据的纵坐标值，在右边选择拟合方式。
在文件-Generate Code-导出生成此拟合曲线的函数文件。
function [fitresult, gof,h] = createFit(x1, y1) %% Fit: 'untitled fit 1'. [xData, yData] = prepareCurveData( x1, y1 ); % Set up fittype and options. ft = 'pchipinterp'; %选择拟合方式 % Fit model to data. [fitresult, gof] = fit( xData, yData, ft, 'Normalize', 'on' ); % Plot fit with data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9df9ee1abd87365b69f8a4c00af85ad6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5e4e9d7a1f8108e1e01ca2c112382fb/" rel="bookmark">
			芯旺微车规级功夫KF32A150，SPI调试经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近项目用到KF32A150,在调试SPI的时候遇到了些问题
1.首先第一个经验就是不要过度信任官方给的DEMO很有可能是有错的，或者没有经过严格测试的。
2.调试的时候发现，不能连续发超过两个字节的SPI数据，或者出现数据错误，原因在于他们的SPI在波特率设置为10US的时候，发送一个直接竟然要30us多，要在发送完成一个字节后加上一个30US的延时。
开始加了等待发送完成后再发另外一个不起作用，只有加延时，作为一个车规级的芯片，SPI的速率还赶不上一般的普通单片机，国产芯片任重道远啊！用起来太心累了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7a8574bd53e1cf1b13ee547ca8dce29/" rel="bookmark">
			C语言 用户输入运算数和四则运算符，输出计算结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用C语言中简单的语句可以实现四则运算：
1、if语句
#include&lt;stdio.h&gt; int main() { double num_left,num_right; char operate; printf("请输入四则运算:\n"); scanf("%lf%c%lf",num_left,operate,num_right); if(operate=="+") { printf("结果是%f\n",num_left+num_right); } else if(operate=="-") { printf("结果是%f\n",num_left-num_right); } else if(operate=="*") { printf("结果是%f\n",num_left*num_right); } else if(operate=="/") { printf("结果是%f\n",num_left/num_right); } return 0; } 2、switch...case...
#include&lt;stdio.h&gt; int main() { double num_left,num_right; char operate; printf("请输入四则运算:\n"); scanf("%lf%c%lf",num_left,operate,num_right); switch(operate) case '+': printf("结果是%f\n",num_left+num_right); break; case '-': printf("结果是%f\n",num_left-num_right); break; case '*': printf("结果是%f\n",num_left*num_right); break; case '/': printf("结果是%f\n",num_left/num_right); break; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c6d4e7cd4a952ffd94711f08cf1a034/" rel="bookmark">
			c&#43;&#43;小游戏——推箱子（低级版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景描述：
有一个同学做大作业做不完了，让我帮他看看，但是代码没加注释，又全部混在一坨，于是我看了半个小时过后无果，当即狠下心自己写一个。于是花费了两个小时，就有了这篇文章。（第一次写小游戏，贼好玩）
复制代码必看：
1.地图可以自己设置，看define就知道地图构成了
2.地图的规格是7 * 7，不要越界（我自己也没试过）
3.游戏通关判定只有两个箱子和两个终点（不要整多了，不然自己改通关判断）
4.游戏一共是3关，想多一点自己改一下结束条件，自己写几个地图
5.由于是clion上面写的，有可能存在字符编码问题（我自己也没有解决），建议大家也用clion，教程CSDN一搜一大把
6.头文件是万能头，没有的自己改
7.好像没啥补充的了。。。想起了再补充吧
下面是代码：
#include "bits/stdc++.h" using namespace std; #define a 0	// #define b 1	//■ #define c 2	//木 #define d 3	//囗 #define e 5	//困 #define f 6	//人 #define g 9	//囚 int my_map[3][7][7] = { //地图初始化 1,1,1,1,1,1,1, 1,3,0,0,3,0,1, 1,1,0,0,0,1,1, 1,0,0,6,0,0,1, 1,1,2,0,2,0,1, 1,1,0,0,0,0,1, 1,1,1,1,1,1,1, 1,1,1,1,1,1,1, 1,3,2,0,3,0,1, 1,0,0,0,2,1,1, 1,1,0,6,0,0,1, 1,1,0,0,0,0,1, 1,1,0,0,0,1,1, 1,1,1,1,1,1,1, 1,1,1,1,1,1,1, 1,3,2,0,3,0,1, 1,1,0,0,2,1,1, 1,0,0,6,0,0,1, 1,1,0,0,0,0,1, 1,1,0,0,1,1,1, 1,1,1,1,1,1,1 }; int x = 3,y = 3; //初始位置 void drawing_map(int part) { //绘制地图 for(int i = 0;i &lt; 7;i++) { for(int j = 0;j &lt; 7;j++) { if(my_map[part][i][j] == 0) { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c6d4e7cd4a952ffd94711f08cf1a034/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d19194fb94af8a148aff56d0f6e02cea/" rel="bookmark">
			SLAM十四讲 安装 Eigen3 &#43; Palingo 第3讲实验踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录 1、安装eigen32、安装Pangolin2.1 下载源代码：2.2 安装依赖2.3 编译安装 SLAM十四讲源码中，使用了多个第三方的库，由于第三方库都是有相应的版权，因此需要逐个的去相应的官网下载源码安装
1、安装eigen3 eigen3这个比较特殊，可以直接用命令安装
sudo apt-get install libeigen3-dev 2、安装Pangolin 由于github主站比较慢，因此推荐使用镜像站：https://hub.fastgit.org/gaoxiang12/slambook2/
2.1 下载源代码： git clone https://hub.fastgit.org/stevenlovegrove/Pangolin.git 2.2 安装依赖 下载完之后，需要安装一些依赖，比如cmake，g++，libglew等
sudo apt-get install g++ sudo apt-get install cmake sudo apt-get install libglew-dev sudo apt-get install libboost-dev libboost-thread-dev libboost-filesystem-dev 2.3 编译安装 进入源码目录
cd Pangolin mkdir build cd build cmake .. make -j2 sudo make install 安装完毕，这个时候执行第3讲的代码会报这个错：
error while loading shared libraries: libpango_windowing.so: cannot open shared object file: No such file or directory 说是少了“libpango_windowing.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d19194fb94af8a148aff56d0f6e02cea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/205ad4f70173bdfaf5c4640407592e29/" rel="bookmark">
			Spring Boot配置FastJson报错‘Content-Type‘ cannot contain wildcard type ‘*‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		升级到最新版本的fastjson以后报的错，查了一下资料，发现
fastjson从1.1.41升级到1.2.28之后，请求报错：
json java.lang.IllegalArgumentException: ‘Content-Type’ cannot contain wildcard type ‘*’
原因是在1.1.41中，FastJsonHttpMessageConverter初始化时，设置了MediaType。
public FastJsonHttpMessageConverter(){ super(new MediaType("application", "json", UTF8), new MediaType("application", "*+json", UTF8)); } 而在1.2.28中，设置的MediaType为‘/’，即：
public FastJsonHttpMessageConverter() { super(MediaType.ALL); // */* } 后续在org.springframework.http.converter.AbstractHttpMessageConverter.write过程中，又要判断Content-Type不能含有通配符，这应该是一种保护机制,并强制用户自己配置MediaType。
解决方案如下：
在FastJson配置类中手动设置Content-Type
@Configuration public class FastJsonConfiguration extends WebMvcConfigurationSupport { @Bean FastJsonHttpMessageConverter fastJsonHttpMessageConverter(){ FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter(); return converter; } @Override protected void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { // 调用父类的配置 super.configureMessageConverters(converters); //升级最新版本需加============================================================= List&lt;MediaType&gt; supportedMediaTypes = new ArrayList&lt;&gt;(); supportedMediaTypes.add(MediaType.APPLICATION_JSON); supportedMediaTypes.add(MediaType.APPLICATION_JSON_UTF8); supportedMediaTypes.add(MediaType.APPLICATION_ATOM_XML); supportedMediaTypes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/205ad4f70173bdfaf5c4640407592e29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fee021b5d9afabef2751931dccc0ef6/" rel="bookmark">
			shell脚本查看k8s日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 占位符的方式指定参数 getopts问题1.执行 shell 脚本` \r `问题2.命令中的grep 查看日志：kubectl logs -f podName --tail 100
比如我们如果想查指定的pod，指定行数，指定的内容，
每次都需要输入kubectl logs -f xxx --tail yyy | grep zzz
为了方便，可自定义脚本，输入sh .sh xxx yyy zzz即可，并且xxx支持RE;
kubectl命令手册
grep，awk基本使用
占位符的方式 #!/bin/bash # kubectl get pods #notification x="kubectl logs -f" y="--tail" g="|grep" name=`kubectl get pods | grep ^$1 | awk '{print $1}'` x="eval $x $name $y $2 $g $3" ${x} # sh log.sh podName 20 content # 最终：kubectl logs -f podName --tail 20 | grep content 指定参数 getopts #!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fee021b5d9afabef2751931dccc0ef6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30f21c11564bc2e3f30a0d597ece4bc4/" rel="bookmark">
			第三天运算符和if..else学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运算符：运算的符号
算术：+，-，*，/，%，++，--
%:取模/取余，余数为0即为整除
++/--：自增1/自减1，可在变量前也可在变量后
单独使用时，在前在后都一样
被使用时，在前在后不一样
a++的值为a--------(a--的值为a)++a的值为a+1------(--a的值为a-1)//%的演示 System.out.println(8%2); //0，商4余0----整除 System.out.println(5%2); //1，商2余1 System.out.println(2%8); //2，商0余2 //++单独使用: int a=5,b=5; a++; //相当于a=a+1 ++b; //相当于b=b+1 System.out.println(a); //6 System.out.println(b); //6 //++被使用: int a=5,b=5; int c = a++; //1)保存a++的值5 2)a自增1变为6 3)将第1步保存的值5赋值给c--底层运算过程 //---粗暴记法:a++的值为5，c就是5 int d = ++b; //1)保存++b的值6 2)b自增1变为6 3)将第1步保存的值6赋值给d--底层运算过程 //---粗暴记法:++b的值为6，d就是6 System.out.println(a); //6 System.out.println(b); //6 System.out.println(c); //5 c是先赋值再自增 System.out.println(d); //6 //--单独使用: int a=5,b=5; a--; //相当于a=a-1 --b; //相当于b=b-1 System.out.println(a); //4 System.out.println(b); //4 //--被使用: int a=5,b=5; int c = a--; //a--的值为5，所以c的值为5 int d = --b; //--b的值为4，所以d的值为4 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30f21c11564bc2e3f30a0d597ece4bc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d8965bdc4d91f228d4baa38f54839c1/" rel="bookmark">
			sql语句练习题（mysql版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，学习完sql的基本语法之后，是需要一定量的练习才能更好的掌握sql语句的书写。因此，这里整理了几十道sql语句的练习题用于巩固sql语句的书写；当然这里只考虑能得到查询结果，不考虑sql语句的性能优化之类的问题。有需要的小伙伴们可以练习一下，一定会有收获的。本文所有的题目都是整理自互联网。
1.创建表 -- 1.学生表 create table students ( s_id varchar(20), s_name varchar(20) not null default '', s_birth varchar(20) not null default '', s_sex varchar(10) not null default '', primary key(s_id) ); -- 2.课程表 create table courses ( c_id varchar(20), c_name varchar(20) not null default '', t_id varchar(20) not null, primary key(c_id) ); -- 教师表 create table teachers ( t_id varchar(20), t_name varchar(20) not null default '', primary key(t_id) ); -- 成绩表 create table scores ( s_id varchar(20), c_id varchar(20), s_score int(3), primary key(s_id, c_id) ); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d8965bdc4d91f228d4baa38f54839c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/738d750c163e69104c8811ff74620289/" rel="bookmark">
			YOLO v5算法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、YOLO v5网络结构 2、输入端 3、Backone网络 4、Neck网络 5、Head网络 1、YOLO v5网络结构
图 1 YOLO v5网络结构图
由上图可知，YOLO v5主要由输入端、Backone、Neck以及Prediction四部分组成。其中：
(1) Backbone：在不同图像细粒度上聚合并形成图像特征的卷积神经网络。
(2) Neck：一系列混合和组合图像特征的网络层，并将图像特征传递到预测层。
(3) Head： 对图像特征进行预测，生成边界框和并预测类别。
下面介绍YOLO v5各部分网络包括的基础组件：
CBL：由Conv+BN+Leaky_relu激活函数组成
Res unit：借鉴ResNet网络中的残差结构，用来构建深层网络
CSP1_X：借鉴CSPNet网络结构，该模块由CBL模块、Res unint模块以及卷积层、Concate组成
CSP2_X：借鉴CSPNet网络结构，该模块由卷积层和X个Res unint模块Concate组成而成
Focus：首先将多个slice结果Concat起来，然后将其送入CBL模块中
SPP：采用1×1、5×5、9×9和13×13的最大池化方式，进行多尺度特征融合
2、输入端详解
YOLO v5使用Mosaic数据增强操作提升模型的训练速度和网络的精度；并提出了一种自适应锚框计算与自适应图片缩放方法
2.1 Mosaic数据增强
Mosaic数据增强利用四张图片，并且按照随机缩放、随机裁剪和随机排布的方式对四张图片进行拼接，每一张图片都有其对应的框，将四张图片拼接之后就获得一张新的图片，同时也获得这张图片对应的框，然后我们将这样一张新的图片传入到神经网络当中去学习，相当于一下子传入四张图片进行学习了。该方法极大地丰富了检测物体的背景，且在标准化BN计算的时候一下子计算四张图片的数据，所以本身对batch size不是很依赖。
2.2 自适应锚框计算
在yolo系列算法中，针对不同的数据集，都需要设定特定长宽的锚点框。在网络训练阶段，模型在初始阶段，模型在初始锚点框的基础上输出对应的预测框，计算其与GT框之间的差距，并执行反向更新操作，从而更新整个网络的参数，因此设定初始锚点框是比较关键的一环。
在yolo V3和yolo V4中，训练不同的数据集，都是通过单独的程序运行来获得初始锚点框。
而在yoloV5中将此功能嵌入到代码中，每次训练，根据数据集的名称自适应的计算出最佳的锚点框，用户可以根据自己的需求将功能关闭或者打开，指令为：
2.3 自适应图片缩放
在目标检测算法中，不同的图片长宽都不相同，因此常用的方式是将原始图片统一缩放到一个标准尺寸，再送入检测网络中。而原始的缩放方法存在着一些问题，由于在实际的使用中的很多图片的长宽比不同，因此缩放填充之后，两端的黑边大小都不相同，然而如果填充的过多，则会存在大量的信息冗余，从而影响整个算法的推理速度。为了进一步提升YOLO v5的推理速度，该算法提出一种方法能够自适应的添加最少的黑边到缩放之后的图片中。具体的实现步骤如下所述：
(1) 根据原始图片大小以及输入到网络的图片大小计算缩放比例
(2) 根据原始图片大小与缩放比例计算缩放后的图片大小
(3) 计算黑边填充数值
其中，416表示YOLO v5网络所要求的图片宽度，312表示缩放后图片的宽度。首先执行相减操作来获得需要填充的黑边长度104；然后对该数值执行取余操作，即104%32=8，使用32是因为整个YOLOv5网络执行了5次下采样操作。最后对该数值除以2，即将填充的区域分散到两边。这样将416*416大小的图片缩小到416*320大小，因而极大的提升了算法的推理速度。
3、Backone 网络
3.1 Focus结构
Focus对图片进行切片操作，具体操作是在一张图片中每隔一个像素拿到一个值，类似于邻近下采样，这样就拿到了四张图片，四张图片互补，长的差不多，但是没有信息丢失，这样一来，将W、H信息就集中到了通道空间，输入通道扩充了4倍，即拼接起来的图片相对于原先的RGB三通道模式变成了12个通道，最后将得到的新图片再经过卷积操作，最终得到了没有信息丢失情况下的二倍下采样特征图。如下图所示，原始输入图片大小为608*608*3，经过Slice与Concat操作之后输出一个304*304*12的特征映射；接着经过一个通道个数为32的Conv层，输出一个304*304*32大小的特征映射。
3.2 CSP结构
CSPNet主要是将feature map拆成两个部分，一部分进行卷积操作，另一部分和上一部分卷积操作的结果进行concate。
在分类问题中，使用CSPNet可以降低计算量，但是准确率提升很小；
在目标检测问题中，使用CSPNet作为Backbone带来的提升比较大，可以有效增强CNN的学习能力，同时也降低了计算量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/738d750c163e69104c8811ff74620289/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae4e1585c98f86fdf3e300ecc09d90d9/" rel="bookmark">
			UnicodeDecodeError: ‘utf-8‘ codec can‘t decode byte 0xb1 in position 0: invalid start byte的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在读取一个从国家统计局下载的csv表格的时候遇到如上报错：
一看就知道是字符编码问题，但是到底要编码成哪种格式才是正确的呢？ 掌柜搜了一下相关问题的解决方案，发现高赞给的答案是下面这个：
于是掌柜尝试过后发现并不能完全解决问题。。。😅在Province这一列还是出现的乱码。。。然后掌柜突然反应过来，Province这一列都是中文，一般中文编码都是用的gbk，所以应该是encoding = ‘gbk’ 才对吧。带着这样的想法填入后，再次运行，成功加载出全国各省近5年的GDP数据！
总结：
所以编码问题还是要看具体数据类型来处理。大多数encoding='utf-8’即可解决，但是如果表格包含中文，建议encoding='gbk’处理。
参考资料：
UnicodeDecodeError: ‘utf8’ codec can’t decode byte 0xa5 in position 0: invalid start byte
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87c87ec8f5d91aa1243e5a20f6b33c6d/" rel="bookmark">
			RocketMQ 应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、异步解耦 场景描述
作为淘宝/天猫主站最核心的交易系统，每笔交易订单数据的产生会引起几百个下游业务系统的关注，包括物流、购物车、积分、阿里妈妈、流计算分析等等，整体业务系统庞大而且复杂，架构设计稍有不合理，将直接影响主站业务的连续性；
高可用松耦合架构设计
通过上、下游业务系统的松耦合设计，即便下游子系统（如物流、积分等）出现不可用甚至宕机，都不会影响到核心交易系统的正常运转；
灵活适应业务的快速增长
商场如战场，通过 MQ 的异步化设计，可以灵活高效的适应因业务快速发展而带来的变化，如新增业务系统；
2、削峰填谷 场景描述
诸如秒杀、抢红包、企业开门红等大型活动时皆会带来较高的流量脉冲，或因没做相应的保护而导致系统超负荷甚至崩溃，或因限制太过导致请求大量失败而影响用户体验，削峰填谷是解决该问题的最佳方式；
超高流量脉冲处理能力
MQ 超高性能的消息处理能力可以承接流量脉冲而不被击垮，在确保系统可用性同时，因快速有效的请求响应而提升用户的体验；
海量消息堆积能力
确保下游业务在安全水位内平滑稳定的运行，避免超高流量的冲击；
合理的成本控制
通过削弱填谷可控制下游业务系统的集群规模，从而降低投入成本；
3、顺序消息 场景描述
细数日常中需要保证顺序的应用场景非常多，比如证券交易过程时间优先原则，交易系统中的订单创建、支付、退款等流程，航班中的旅客登机消息处理等等。与FIFO原理类似，MQ提供的顺序消息即保证消息的先进先出；
严格保序
与部分开源产品不同，无论是服务上下线、扩缩容，网络不稳定等情况下，MQ 始终保证消息的有序；
高性能&amp;可扩展
支持全局顺序与分区顺序，分别满足不同的业务需求，如证券交易系统中相同股别采用全局顺序，交易系统的不同订单之间采用分区顺序；分区顺序在严格保序的同时，通过分区动态扩展能力提高整体的并发与扩展能力；
4、分布式事务消息 场景描述
阿里巴巴的交易系统、支付红包等场景需要确保数据的最终一致性，大量引入 MQ 的分布式事务，既可以实现系统之间的解耦，又可以保证最终的数据一致性；
传统事务
多个系统或者应用组件之间的业务处理会耦合到一个大事务中，响应时间长，业务链路长从而影响系统的整体性能和可用性，甚至引起系统崩溃；
分布式事务
将核心链路业务与可异步化处理的分支链路进行拆分，将大事务拆分成小事务，减少系统间的交互，既高效又可靠；MQ 的可靠传输与多副本技术在确保消息不丢，At-Least-Once 特性确保数据的最终一致性；
5、大数据分析 场景描述
数据在"流动"中产生价值，传统数据分析大多是基于批量计算模型，而无法做到实时的数据分析，利用阿里云消息队列（MQ）与流式计算引擎相结合，可以很方便的实现将业务数据进行实时分析。
应用与分析解耦
构建应用系统和分析系统的桥梁，并将它们之间的关联解耦，同时由于数据产生非常快且数据量大，需要非常高的可扩展性；
大数据分析
可对接 Storm/Spark 实时流计算引擎，亦可对接 Hadoop/ODPS 等离线数据仓库系统；
6、分布式模缓存同步 场景描述
天猫双11大促，各个分会场琳琅满目的商品需要实时感知价格变化，大量并发访问数据库导致会场页面响应时间长，集中式缓存因为带宽瓶颈限制商品变更的访问流量，通过 MQ 构建分布式缓存，实时通知商品数据的变化；
实时数据更新
通过消息实时推送的方式，让数据实时得以更新；
降低页面响应时间
大量并发访问商品数据库，减少页面响应时间；
满足大规模访问需求
大促众多分会场，多缓存的架构设计，满足对商品变更的大量访问需求；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dee4c2e8c5555d4589ade0c35c34dfd/" rel="bookmark">
			Petalinux与kernel版本不匹配问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8cf26004a3fec2f2811894d1d8cebe5/" rel="bookmark">
			PTA 7-4 奇偶分家
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给定N个正整数，请统计奇数和偶数各有多少个？
输入格式： 输入第一行给出一个正整N（≤1000）；第2行给出N个非负整数，以空格分隔。
输出格式： 在一行中先后输出奇数的个数、偶数的个数。中间以1个空格分隔。
输入样例： 9 88 74 101 26 15 0 34 22 77 结尾无空行
输出样例： 3 6 结尾无空行
#include&lt;stdio.h&gt; main() { int N, odd=0, i, t; scanf("%d",&amp;N); for(i = 0; i &lt; N; i++) { scanf("%d",&amp;t); if(t&amp;1)odd++; } printf("%d %d\n", odd, N-odd); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cde96bd3b736782a4bd2c9a905bf4a0d/" rel="bookmark">
			idea启动项目报错Error:(5, 52) java: 程序包org.springframework.scheduling.annotation不存在
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好好的一个项目别人idea都能够启动，我来运行就是不行。项目是没有问题的，clean install也是没有问题的。
下面是解决方案
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5445cab0c2cd7326ceb1cc7bbb9fc4a3/" rel="bookmark">
			前端学习笔记-CSS扩展语言（LESS SCSS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS扩展语言 LESS安装变量嵌套规则混合运算继承less避免编译 SCSS数据类型运算1. 数字运算符2. 关系运算符3. 相等运算符4. 布尔运算符5. 颜色值运算6. 运算优先级 嵌套语法其他语法rules与指令控制指令 LESS 安装 1.Node.js
npm install -g less
lessc styles.less styles.css
2.浏览器环境中引用
&lt;link rel=“stylesheet/less” type=“text/css” href=“styles.less” /&gt;
&lt;script src="//cdnjs.cloudflare.com/ajax/libs/less.js/3.11.1/less.min.js" &gt;&lt;/script&gt;
变量 赋值：@变量名参数：@{变量名} 变量延迟加载，当变量作为赋值参数时，会先解析完作用域中所有变量，然后将该变量赋值给对应的变量。
嵌套规则 &amp; ，指向父级对象嵌套使用 混合 混合即将一系列属性从一个规则集引入到另一个规则集的方式
普通混合
不常输出的混合
带参数的混合
带参数并且有默认值的混合
带多个参数的混合
命名参数
匹配模式
匹配函数名(@_,匹配参数1…匹配参数n){样式1}匹配函数名(匹配参数,匹配参数1…匹配参数n){样式2}调用：匹配函数名(匹配参数，实参1…实参n);//编译完后，合并样式1、样式2 arguments变量
运算 +-*/ 需加上（） 继承 可将某一样式设置封装在类里，通过调用该类，进行继承。
变量名:extend(类名 all) 若带all，表示继承该类所有的状态
性能比混合高，但灵活度比混合低，因为不能带参数进行声明
less避免编译 ~"(样式计算)"，样式计算交由浏览器进行计算，less不做编译
SCSS 数据类型 SassScript支持7种主要的数据类型
数字字符串颜色布尔型空值数组（list）maps，相当于JavaScript的Object 对于其他css属性值，如Unicode字符集、或!important声明，将视为无引号字符串进行处理
判断数据类型方式：type-of($value)
运算 1. 数字运算符 op1 + op2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5445cab0c2cd7326ceb1cc7bbb9fc4a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d70887443d0659449d18df19c24ad26/" rel="bookmark">
			matlab-错误 428: 您的许可证需要进行电子邮件验证。有关说明，请在您的收件箱中查看 MathWorks 发送的电子邮件。如需其他帮助。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很久没打开matlab，一打开重新登录的时候就出现了这个问题，但问题是收件箱里一直收不到邮件。。。
解决办法，先登录
matlab许可证中心
登录成功之后再打开matlab，应该就不会报错了。
参考：谁知道激活时出现错误428怎么解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3f05e251ac83dc0380b651bbfee94d5/" rel="bookmark">
			SQL注入之联合查询、报错注入和sqlmap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 SQL注入的方法方法一：联合查询方法二：报错注入extractvalue() 函数updatexml()函数 方法三：Sqlmap SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。 SQL注入的方法 方法一：联合查询 ?id=1' order by 3 --+ //查询列数 ?id=-1' union select 1,2,3 --+ //查看输出列 ?id=-1' union select 1,(select user()),3 --+ //查询用户名 ?id=-1' union select 1,(select database()),3 --+ //查询数据库名 ?id=-1' union select 1,(select table_name from information_schema.tables where table_schema="数据库名" limit 0,1),3--+ //单独爆出表名 ?id=-1' union select 1,(select group_concat(table_name) from information_schema.tables where table_schema="数据库名"),3--+ //爆出全部表名 ?id=-1' union select 1,(select group_concat(column_name) from information_schema.columns where table_name="表名" and table_schema="数据库名"),3--+ //查询列名，需要限定表名和库名 ?id=-1' union select 1,(select concat(username,0x3a,password)from 表名 limit 0,1),3 --+ //查询username和password （limit函数） ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3f05e251ac83dc0380b651bbfee94d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59b5bdbbeb5ebee310432fb46638eeca/" rel="bookmark">
			百度网盘安装，双击一闪而过没有反应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决的办法以及结果截图
文档：百度网盘无法安装解决过程（有道笔记链接）.note
链接：http://note.youdao.com/noteshare?id=b24da9fe8ea07edc4f9437e95679e789&amp;sub=C02095DF3C0C46C6AEF37A05B2EC1274
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bb6b37781d819d46ac79cd3c3a02911/" rel="bookmark">
			第二天基础变量及八种基本数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变量：存数的
声明：-------------相当于在银行开帐户
int a; //声明一个整型的变量，名为a int b,c,d; //声明三个整型的变量，名为b,c,d //int a; //编译错误，变量不能同名 初始化：第一次赋值---------相当于给帐户存钱
int a = 250; //声明整型变量a并赋值为250 int b; //声明整型变量b b = 250; //给变量b赋值为250 b = 360; //修改变量b的值为360 int c=5,d=10; //声明两个整型变量c和d，并分别赋值为5和10 使用：---------使用的是帐户里面的钱
对变量的使用就是对它所存的那个数的使用
int a = 5; int b = a+10; //取出a的值5，加10后，再赋值给变量b System.out.println(b); //输出变量b的值15 System.out.println("b"); //输出b，双引号中的原样输出 a = a+10; //在a本身基础之上增10 int c = 5000; //帐户余额 c = c-1000; //取款1000 变量在用之前必须声明并初始化
//System.out.println(m); //编译错误，变量m未声明 int m; //System.out.println(m); //编译错误，变量m未初始化 命名：
只能包含字母、数字、_和$符，并且不能以数字开头严格区分大小写不能使用关键字允许中文命名，但不建议，建议"英文的见名知意"、"小驼峰命名法"int a_2$,_4c,$_; //int a*b; //编译错误，不能包含*号等特殊符号 //int 1a; //编译错误，不能以数字开头 int aa = 5; //System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bb6b37781d819d46ac79cd3c3a02911/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2183daa2be501ee85a78dc6b0481e3ed/" rel="bookmark">
			使用axios发送请求（不带参数和带参数）和使用mockjs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用axios获取后端数据并使用（不带参数）
1.对axios进行封装 network/request.js
import axios from 'axios' import nprogress from 'nprogress'//引入进度条 import "nprogress/nprogress.css" const requests = axios.create({ baseURL:'/api', timeout:5000 }); //请求拦截 requests.interceptors.request.use((config)=&gt;{ nprogress.start()//进度条开始 return config; }) //响应拦截 requests.interceptors.response.use((res)=&gt;{ nprogress.done()//进度条结束 return res.data; },(err)=&gt;{ }); export default requests; 对api进行统一管理 network/index.js
//对API进行统一管理 import requests from './request'; import mockrequest from './mockrequest' //下面是三级联动导航栏接口 export const getCategoryList = () =&gt; requests({url:'/product/getBaseCategoryList',method:'get'}); //获取首页轮播图的接口 export const swiper = () =&gt; mockrequest({url:'/swiper',method:'get'}); 2.在要获取的数据页面通过dispatch访问仓库里面actions（actions里面可以处理异步，向服务器发送请求）
mounted() { this.$store.dispatch("getSwiperList"); //通过dispatch访问仓库store中actions里面的东西,即发送请求 } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2183daa2be501ee85a78dc6b0481e3ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a660ab4439869e234f2311a55e434f0d/" rel="bookmark">
			docker-compose的docker容器绑定host
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker容器是默认绑定docker0，然后动态分配IP的，但是这种默认方式存在几个问题：
问题1：docker容器的docker0网段IP在各服务器在路由上不是能够互相通信的，那么会导致在各服务器上的容器内的应用不能互相通信。
问题2：docker容器的docker0网段IP在各服务的IP网段是相同的，那么会导致各服务器上的容器分配的IP重复
最好的方案是什么呢？还是绑定主机的host，哪来的那么多破事！
将原来的docker-compose.yml文件中的
ports:
- "8080:8080"
替换成
network_mode: "host"
即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66f5f809c5b944a39ab9c26dd73bac06/" rel="bookmark">
			安装指定版本的tensorflow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装指定版本的tensorflow
pip install tensorflow-gpu==1.10.0 -i https://pypi.tuna.tsinghua.edu.cn/simple
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/165/">«</a>
	<span class="pagination__item pagination__item--current">166/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/167/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>