<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1905e55517fb31e6531a2554e3ab497c/" rel="bookmark">
			【云计算学习教程】统一身份认证（IDS）是什么？云端如何应用统一身份认证？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前去井冈山游玩，里面的每个景点都要单独排队购票，很烦琐。现在已改为通票，上山时只需购买一张通票，就可以直接进入任何景点游玩，在每个景点门口出示一下通票即可，一路畅通无阻，既方便又省时。
什么人可以进去、进去后可访问什么资源，以及事后承担什么责任，这是人类社会每天都在发生的事情，如景区参观、厂区上班等。
云端包含很多应用系统，而且租户的家目录还要漫游，统一身份认证就相当于景区的通票，登录云端时只需一次验证，之后就可以进入任何有权进入的应用系统。
统一身份认证与单点登录是同一个概念。如果没有统一身份认证，那么你进入任何一个应用系统都要求输入账号和密码，这样一方面难以记住众多的账号和密码，另一方面使用云端资源很烦琐。
对于云端应用系统的访问控制，通常分为三个层面：
认证：解决能否进入的问题。授权：解决进入后能做什么的问题。记账：解决做了事情后就要承担相应责任的问题，可能还要付费。 这就是通常所说的 3A 安全机制（Authentication，Authorization，Accountability）。基于 3A 安全机制的访问控制在现代操作系统中被普遍采用，例如 Linux 操作系统访问控制步骤如下：
1）用户输入账号和密码企图登录系统，此时操作系统会进行认证（Authentication），即核对输入的账号和密码与保存在系统里的账号和密码是否相符。如果相符，则允许登录。
2）登录后的用户并不能为所欲为，其每一步操作都必须被授权（Authorization），比如允许进入什么目录、哪些文件允许读、哪些文件允许写、哪些文件允许删除等，都处于操作系统严密的监视之下。
3）用户的全部操作都被作为日志记录下来（Accountability），方便以后落实责任、事后监督，并作为付费的依据。
Windows 操作系统也采用相同的方法。
作为云端的统一身份认证系统，必须实现以下四个功能：
1）统一用户管理（Identification） 租户的账号、密码等信息集中存储，统一管理。
2）身份鉴别（Authentication） 当租户企图登录某个应用系统时，验证他的票据或者身份是否合法。
3）权限控制（Authorization） 规定允许登录系统的租户具备哪些操作权限。
4）操作日志登记（Accountability） 记录租户的操作行为，以便事后责任追溯。
有了统一身份认证，租户登录云端并访问应用系统的过程如图 1 所示。
图 1 租户登录云端并访问应用系统的过程
租户甲首次登录云端的应用系统 5（第 1 步），但被告知要先去统一认证中心获取票据（第 2 步），拿到票据之后返回并访问应用系统 5（第 3 步），然后凭票据直接访问应用系统 3（第 4 步）、应用系统 2（第 5 步）、应用系统 1（第 6 步）。
租户在访问每个应用系统时，应用系统都会查验他的票据，只有票据合法才被允许进入。应用系统在查验票据时都会与统一认证中心确认，不过这一切都是自动的，租户自己感觉不到，但当租户企图访问没有被授权的应用系统时，就会被告知“没有权限”。
不管租户最先访问哪个应用系统，只要租户没有票据或者出示的票据已经过期，都会引导其先去统一认证中心获取票据。但需要注意的是，对租户来说，获取票据的动作只是在屏幕上输入账号和密码，账号和密码的验证、票据的发放等操作都在云端后台自动完成，此后该租户再访问其他应用系统时，就不会在屏幕上显示输入账号和密码的登录画面，因为云端后台自动帮他出示了合法的票据。
SOA（面向服务的架构）是什么？ SOA 是面向服务的架构，即企业的 IT 系统是由服务组成的，也即企业的各个应用系统是由许多标准的服务件“组装”起来的，组成应用系统中的各个服务之间是一种非常松耦合的关系。
服务基于简单的“问/答”模型——我问你问题，你给我答案，那么对于“我”来说，“你”就是“服务”。但是答案反馈有同步和异步之分，同步就是我问你问题并在线等待你答复，而异步就是我问完你问题就去忙其他事情了，你有了答案之后再通知我。
在软件行业，基于这种服务的编程思想最早表现为函数，即把经常用到的代码块定义成一个函数并取一个函数名，再用函数名替换程序中原先的代码块（称为函数调用）。
比如通过三条边计算三角形的面积，这个任务包含复杂的数学公式，涉及很多条指令，我们可以把它定义为函数 sane（x，y，z），然后在程序需要计算三角形面积时直接调用这个函数即可。比如 sane（10，20，25），就会返回边长为 10、20、25 的三角形的面积。
后来人们觉得函数还不够灵活，就提出了模块，模块比函数功能更强，程序就是由模块组装起来的。当然，编写具体的模块时会继续采用函数。模块本质上就是一组类库（一个类库文件包含若干定义好了的功能较为强大的函数），允许软件开发人员调用类库中的函数。
一些好的面向特定应用领域的模块以开源或者商业模式对外发布，世界各地的其他开发人员可以直接利用这些模块来开发自己的应用程序，从而减少大量重复性的代码编写工作，这样的模块人们习惯称之为框架。例如，利用 Python 语言开发网站的框架 Django，它就是一组类库，编程人员必须掌握需要用到的每个类库函数的定义，才能快速开发网站。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1905e55517fb31e6531a2554e3ab497c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e397f4649c0fa8ab23d1bf8396f923f5/" rel="bookmark">
			linux c语言sleep的时间实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.不使用sleep,循环10000次
/* 1.c */ #include &lt;sys/time.h&gt; #include &lt;stdio.h&gt; void main(void) { struct timeval start, end; int i; float time_use=0; gettimeofday(&amp;start, NULL); for(i=0; i&lt;10000; i++) { ; } gettimeofday(&amp;end, NULL); time_use=(end.tv_sec-start.tv_sec)*1000000+(end.tv_usec-start.tv_usec);//微秒 printf("time_use is %.10f\n",time_use); } 运行结果：
time_use is 51.0000000000 2.使用sleep(0)，循环10000次
/* 0.c */ #include &lt;sys/time.h&gt; #include &lt;stdio.h&gt; void main(void) { struct timeval start, end; int i; float time_use=0; gettimeofday(&amp;start, NULL); for(i=0; i&lt;10000; i++) { sleep(0); } gettimeofday(&amp;end, NULL); time_use=(end.tv_sec-start.tv_sec)*1000000+(end.tv_usec-start.tv_usec);//微秒 printf("time_use is %.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e397f4649c0fa8ab23d1bf8396f923f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/952d87e6ed3379290f029fff395264b7/" rel="bookmark">
			STM32MP157实验（三）——按键扫描和中断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 按键扫描设计需求基础知识硬件设计STM32CubeIDE设计MX设置代码设计 实验结果 按键中断设计需求基础知识硬件设计STM32CubeIDE设计MX设置代码设计 总结 按键扫描 设计需求 通过按键扫描的方式实现，按下KEY_USER1（KEY1）按键，点亮LED_GREEN,再次按下熄灭LED_GREEN;按下KEY_USER2(KEY2)按键，点亮LED_YELLOW，再次按下熄灭LED_YELLOW.
基础知识 前面LED灯是控制GPIO输出，而按键则是读取GPIO电平，从而获知按键是否按下。
按键检测一般有两种：按键扫描（类似于轮询）和按键中断（中断检测）。
按键扫描：是间隔很短时间反复查询GPIO状态，从而的值是否有按键动作，这种方式简单，但是比较耗费资源。按键中断则是通过按键产生中断信号，从而实现按键的检测，这种方式需要使用到中断机制，需要对MCU有一定的了解。后面的按键中断实验将会详细介绍
按键一般占用一个GPIO口，通过检测该GPIO的电平变化得知按键操作，我们查看按键原理图如下
通过原理图我们可以分析出，当按键没有按下的时候，3.3V的VDD通过电阻直接连在我们的GPIO口上（PG2），那么我们的MCU读取到的PG2GPIO口的电平就是高电平。当我们的按键按下，左边电路导通，那么我们的GPIO口的电平就是低电平，MCU读取到的电平就是低电平。
我们常用的按键都是机械触点式按键，机械式按键在按下或释放过程中，由于机械弹性作用的影响，会伴随着机械抖动，如下所示：
抖动的时长与机械开关特性相关，一般为5ms-10ms。在这个抖动过程中，会产生多次高低电平，所以为了确定电平的稳定性，我们需要截取稳定的电平断，所以我们需要进行按键的消抖。按键消抖可以硬件上处理，即在硬件旁并联电容，吸收抖动的电平。也可以软件处理，即通过延时，避开抖动。
硬件设计 开发板上有4个按键，其中两个是复位按键和唤醒按键，这次实验不会介绍，后面介绍。另外两个按键就是我们的上面的KEY1和KEY2.KEY1接在了MCU的PG3脚，并且并联了一个C34电容用于硬件的消抖，还并联了一个TVS二极管防静电。同理，KEY2接在了PG2上。
STM32CubeIDE设计 MX设置 注意这里的红绿两个灯也需要配置，就像第一个实验那样
代码设计 driver_led.h
#ifndef DRIVER_LED_H_ #define DRIVER_LED_H_ #include "main.h" #include "stm32mp1xx_hal.h" #define LED_GREEN_ON() HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_RESET) #define LED_GREEN_OFF()	HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_SET) #define LED_YELLOW_ON() HAL_GPIO_WritePin(LED_YELLOW_GPIO_Port, LED_YELLOW_Pin, GPIO_PIN_RESET) #define LED_YELLOW_OFF() HAL_GPIO_WritePin(LED_YELLOW_GPIO_Port, LED_YELLOW_Pin, GPIO_PIN_SET) extern void DemoLedInit(void); extern void LedBlinking(void); #endif /* DRIVER_LED_H_ */ driver_key.h
#ifndef DRIVER_KEY_H_ #define DRIVER_KEY_H_ #include "driver_led.h" #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/952d87e6ed3379290f029fff395264b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/456b806c82bcfe6ef5bbc64ec78c5657/" rel="bookmark">
			koajsAdmin已经开源了，element-ui &#43; koa &#43; mongodb 全栈搭建后台管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		koajsAdmin介绍 koajsAdmin是一款后台管理框架，全栈用node进行开发。前端用的element-ui + vite进行构建，后端用的koa + mongodb进行构建。运行guiplan低代码开发工具即可快速建站，可视化配置数据库，可视化配置接口，可视化搭建后台界面。 文章目录 koajsAdmin介绍前言一、前端使用步骤1.下载框架2. 安装前端插件3. 启动前端服务4. 停止服务 二、后端步骤1. 安装后端插件2.启动后端服务3.数据库连接配置 注册与登录1.注册2. 登录 前言 随着时代的进步各种框架也层出不穷，各种技术也在不断更新。我们也需要不断学习。 在之前的版本中还在用express + iview搭建前后端。而随着技术的更新升级，我们也不得不更换更好的框架，最新的技术。webpack也换成了vite。与时俱进所以软件也是非常的灵活，适用于大众。
一、前端使用步骤 1.下载框架 下载koajsAdmin开源框架
可直接下载也可以用git命令下载
git clone https://gitee.com/zhoushuigui/koajs-admin 也可以打开软件之后直接点击按钮来下载
2. 安装前端插件 可直接输入命令
npm install
也可以在软件中点击一下图标自动安装，软件会检测当前项目是否下载，如果下载了会检测当前项目是否安装，未安装会出现一下安装按钮。
3. 启动前端服务 注意：启动之前电脑需要安装vite脚手架
输入以下命令
npm run dev
同样的如果项目已经安装也可以直接在软件中点击启动按钮来启动前端服务
4. 停止服务 关闭命令窗口即可
或者在软件中点击停止图标
二、后端步骤 1. 安装后端插件 后端代码全部放在servers文件夹中
打开这个servers文件夹目录，然后输入以下命令即可安装
npm install
2.启动后端服务 注意：后端服务启动需要nodemon插件支持，nodemon插件作用是每次修改后端代码即可自动重启后端服务。
可用以下命令全局安装nodemon
npm install nodemon -g
启动后端服务输入以下命令
npm run dev
3.数据库连接配置 koajsAdmin用的是mongodb数据，所以电脑需要安装mongodb数据库。
在.env文件夹中可以修改各种配置
详情请看以下注释
NODE_ENV=dev SERVER_PORT=8086 // 服务端口号 DB_HOST=localhost // 数据库地址 DB_NAME=koaadmin // 数据库名称 DB_USER= // 数据库用户名，无需密码登录可不填写 DB_PASSWORD= // 数据库密码 无需密码登录可不填写 DB_PORT=27017 // 数据库端口号 JWT_SECRET=245509608@qq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/456b806c82bcfe6ef5bbc64ec78c5657/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36effddc159d94d362f594642a32aa23/" rel="bookmark">
			元旦到了，手把手教你用 Python 制作一个炫酷烟花秀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小张，
今天是2021 的最后一天，到了这个时间点，部分小伙伴已经开始复盘这一年的得与失。比如今年增加了多少技能点，看了多少本书，写了多少篇文章或者年前的小目标实现进度大概多少等等；做一个象征性的年终总结来告别2021，迎接2022：
本篇文章，带大家用 Python 制作一个炫酷烟花秀，来迎接即将到来的元旦佳节。开始之前先看一下最终效果
环境介绍：
语言：Python；
库：Pygame；
原理介绍 在介绍代码之前，先介绍下 Pygame 绘制烟花的基本原理，烟花从发射到绽放一共分为三个阶段：
1，发射阶段：在这一阶段烟花的形状是线性向上，通过设定一组大小不同、颜色不同的点来模拟“向上发射” 的运动运动，运动过程中 5个点被赋予不同大小的加速度，随着时间推移，后面的点会赶上前面的点，最终所有点会汇聚在一起，处于 绽放准备阶段；
2，烟花绽放：烟花绽放这个阶段，是由一个点分散多个点向不同方向发散，并且每个点的移动轨迹可需要被记录，目的是为了追踪整个绽放轨迹。
3，烟花凋零，此阶段负责描绘绽放后烟花的效果，绽放后的烟花，而在每一时刻点的下降速度和亮度（代码中也叫透明度）是不一样的，因此在代码里，将烟花绽放后将每个点赋予两个属性：分别为重力向量和生命周期，来模拟烟花在不同时期时不同的展现效果，
代码实操 代码部分将烟花封装为三个类：
Firework : 烟花整体；
Particle： 烟花粒子（包含轨迹）
Trail： 烟花轨迹，本质上是一个点 。
三个类之间的关系为：一个Firework 由多个 Particle 构成，而一个 Particle 由多个 Trail 构成
首先设置全局变量，例如重力向量，窗口大小，Trail 的颜色列表（多为灰色或白色）以及不同状态下 Trail 之间间隔
gravity = vector(0, 0.3) DISPLAY_WIDTH = DISPLAY_HEIGHT = 800 trail_colours = [(45, 45, 45), (60, 60, 60), (75, 75, 75), (125, 125, 125), (150, 150, 150)] dynamic_offset = 1 static_offset = 3 创建 Trail 类，定义 show 方法绘制轨迹 、get_pos 实时获取轨迹坐标
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36effddc159d94d362f594642a32aa23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4791a2081aa6d93073f3ee55416e5b7d/" rel="bookmark">
			通俗易懂的YOLO系列（从V1到V5）模型解读！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“小白学视觉”，选择加"星标"或“置顶”
重磅干货，第一时间送达 0 前言 本文目的是用尽量浅显易懂的语言让零基础小白能够理解什么是YOLO系列模型，以及他们的设计思想和改进思路分别是什么。我不会把YOLO的论文给你用软件翻译一遍，这样做毫无意义；也不会使用太专业晦涩的名词和表达，对于每一个新的概念都会解释得尽量通俗一些，目的是使得你能像看故事一样学习YOLO模型，我觉得这样的学习方式才是知乎博客的意义所在。
为了使本文尽量生动有趣，我用葫芦娃作为例子展示YOLO的过程。
同时，会对YOLO v1和YOLOv5的代码进行解读，其他的版本就只介绍改进了。
1 先从一款强大的app说起 i detection APP
YOLO v5其实一开始是以一款app进入人们的视野的，就是上图的这个，叫：i detection(图上标的是YOLO v4，但其实算法是YOLO v5)，使用iOS系列的小伙伴呢，就可以立刻点赞后关掉我这篇文章，去下载这个app玩一玩。在任何场景下(工业场景，生活场景等等)都可以试试这个app和这个算法，这个app中间还有一个button，来调节app使用的模型的大小，更大的模型实时性差但精度高，更小的模型实时性好但精度差。
值得一提的是，这款app就是YOLO v5的作者亲自完成的。而且，我写这篇文章的时候YOLO v5的论文还没有出来，还在实验中，等论文出来应该是2020年底或者2021年初了。
读到这里，你觉得YOLO v5的最大特点是什么？
答案就是：一个字：快，应用于移动端，模型小，速度快。
首先我个人觉得任何一个模型都有下面3部分组成：
前向传播部分：90%
损失函数部分
反向传播部分
其中前向传播部分占用的时间应该在90%左右，即搞清楚前向传播部分也就搞清楚了这模型的实现流程和细节。本着这一原则，我们开始YOLO系列模型的解读：
2 不得不谈的分类模型 在进入目标检测任务之前首先得学会图像分类任务，这个任务的特点是输入一张图片，输出是它的类别。
对于输入图片，我们一般用一个矩阵表示。
对于输出结果，我们一般用一个one-hot vector表示： ，哪一维是1，就代表图片属于哪一类。
所以，在设计神经网络时，结构大致应该长这样：
img cbrp16 cbrp32 cbrp64 cbrp128 ... fc256-fc[10]
这里的cbrp指的是conv，bn，relu，pooling的串联。
由于输入要是one-hot形式，所以最后我们设计了2个fc层(fully connencted layer)，我们称之为“分类头”或者“决策层”。
3 YOLO系列思想的雏形：YOLO v0 有了上面的分类器，我们能不能用它来做检测呢？
要回答这个问题，首先得看看检测器和分类器的输入输出有什么不一样。首先他们的输入都是image，但是分类器的输出是一个one-hot vector，而检测器的输出是一个框(Bounding Box)。
框，该怎么表示？
在一个图片里面表示一个框，有很多种方法，比如：
x,y,w,h(如上图)
p1,p2,p3,p4(4个点坐标)
cx,cy,w,h(cx,cy为中心点坐标)
x,y,w,h,angle(还有的目标是有角度的，这时叫做Rotated Bounding Box)
......
所以表示的方法不是一成不变的，但你会发现：不管你用什么形式去表达这个Bounding Box，你模型输出的结果一定是一个vector，那这个vector和分类模型输出的vector本质上有什么区别吗？
答案是：没有，都是向量而已，只是分类模型输出是one-hot向量，检测模型输出是我们标注的结果。
所以你应该会发现，检测的方法呼之欲出了。那分类模型可以用来做检测吗？
当然可以，这时，你可以把检测的任务当做是遍历性的分类任务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4791a2081aa6d93073f3ee55416e5b7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9749e0742d644de3f63da8a4b05dda1f/" rel="bookmark">
			spring注入实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public interface TestInterface&lt;T&gt; { void test(); } @Scope("prototype") @Component("top") public class TestSub1 implements TestInterface&lt;TestSub1&gt;{ @Override public void test() { System.out.println("test1"); } } @Component public class TestSub2 implements TestInterface&lt;TestSub2&gt;{ @Override public void test() { System.out.println("test2"); } } @Component public class Test { @Autowired private ApplicationContext applicationContext; /** * 以下两种注入皆可 */ @Autowired private TestInterface&lt;TestSub1&gt; testInterface; // private TestInterface&lt;TestSub1&gt; testInterface; // // public Test(TestInterface&lt;TestSub1&gt; testInterface) { // this.testInterface = testInterface; // } @PostConstruct public void init() { testInterface.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9749e0742d644de3f63da8a4b05dda1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1056b8f1723b3f4a4c1afdbb60e2051/" rel="bookmark">
			sap信贷管理的操作流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了降低企业在实际业务中的信贷风险，SAP系统提供了一个复杂的信贷管理解决方案，当客户超过它的信贷许可范围时，系统能够做出迅速而有效的反应。如下图所示显示了SAP系统中一个客户的信贷管理信息。 同一个企业所有客户的信贷管理信息是以信用主数据的方式维护到系统中的，完全实现了客户信贷管理信息的共享。而且每一个客户的信贷管理信息随着对其销售业务的开展，系统能够实现及时动态更新。SAP系统对客户信贷管理信息的及时动态更新，以及信贷控制策略的实现是通过SAP系统的后台配置完成的。在这里针对不同信贷控制范围、不同风险类别、不同信贷组的组合进行详细的信贷控制设置，以实现企业的信贷控制策略。
1.定义信贷控制范围。信贷控制范围是SAP销售和应收账款模块中用于控制信用风险的组织机构。系统配置的后台路径为：企业结构=&gt;定义=&gt;财务会计=&gt;定义信贷控制范围及组织值事例。为了提高工作效率，建议在“信贷控制范围明细项”里面维护客户信用主数据的默认值，实现在创建客户主数据时自动创建该客户的信用主数据。这样只需对不同风险类别的客户和授信客户的信贷限额进行维护。
2.给公司代码分配信贷控制范围。根据不同的产品，不同的销售方式，一个公司代码可以有多个信贷控制范围。同时一个信贷控制范围也可以分配给多个公司代码，比如，集团公司的一个客户可以有一个总的信用限额，而在各个信贷控制范围内又可以设定该信贷控制范围内的信用限额。系统配置的后台路径为：财务会计=&gt;应收账目和应付账目=&gt;信用管理=&gt;信用控制会计科目=&gt;分配允许的信用控制范围给公司代码及组织值事例。
3.给销售范围分配信贷控制范围。销售组织、分销渠道和产品组三者之间的有机组合构成一个销售范围。销售范围反应了一个企业不同的产品以及不同的销售方式的组合，一个信贷控制范围可以分配多个销售范围，一个销售范围只能分配给一个信贷控制范围，信贷控制范围和销售范围之间是一对多的关系。系统配置的后台路径为：企业结构=&gt;分配=&gt;销售分销=&gt;分配贷款控制范围的销售范围及组织值事例。
4.定义风险类别。风险类别可以理解为风险等级，首先对客户区分不同的风险类别，然后针对不同的风险类别可以执行不同的信贷政策。 系统配置的后台路径为：财务会计=&gt;应收账目和应付账目=&gt;信用管理=&gt;信用控制会计科目=&gt;定义风险类别及组织值事例。
5.定义信贷组。信贷组可以理解为对信贷控制区分不同的控制环节，信贷控制一般可以在三个业务环节进行：销售订单、交货和发货过账。系统配置的后台路径为：销售分销=&gt;基本功能=&gt;信贷管理/风险管理=&gt;信贷管理=&gt;定义信贷组及组织值事例。
6.定义进行信贷控制的定价过程。这一项主要是对包含哪些价格条件类型的值进行信贷控制。关键是需要对进行信贷控制的价格条件类型设置相应的标志，将需要控制的价格转到贷方价格。具体系统配置的后台路径为：销售分销=&gt;基本功能=&gt;信贷管理/风险管理=&gt;信贷管理/风险管理设置=&gt;输入设置。
7.激活项目类别的信贷更新。这一配置在项目类别层次控制实际的销售业务数据是否更新信贷总额。要实现客户信贷及时动态更新，需将相应销售单据类型的活跃信贷选中。系统配置的后台路径为：销售分销=&gt;基本功能=&gt;信贷管理/风险管理=&gt;信贷管理/风险管理设置=&gt;确定每一项目类别的有效的应收款及组织值事例。
8.给销售凭证和交货凭证分配信贷组和信贷控制方式。通过这一配置实现了不同类型的销售订单和交货单与信贷组及系统信用控制的结合。
9.定义自动信贷控制。在这里定义具体的怎样执行信贷控制，反映了一个企业的基本信贷政策。系统配置的后台路径为：销售分销=&gt;基本功能=&gt;信贷管理/风险管理=&gt;信贷管理=&gt;定义自动信贷控制及组织值事例。
SAP中的信用控制可以实现分公司代码、分销售范围、分不同风险类别的客户、分单据类型的控制。要实现信用控制，还需要首先对要进行信贷控制的定价过程做定义，其次是要激活项目类别的信贷控制。信贷控制范围的确定一般有四个层次：公司代码、销售范围、客户主数据以及用户出口，四者的优先级依次升高。
SAP系统的信用管理功能非常强大，而在销售管理过程中，信用管理也是主要的内部控制点，为此建议将风险类别按低、中、高划分成三个等级，按客户的信用状况，将客户划分成低风险客户、中风险客户、高风险客户，对客户实行分级管理。
在信用控制策略上，对不同的信贷控制范围，实现销售订单级的控制即可。对于低风险客户，当超信贷限额时，系统只是警告一下，不影响业务操作；对于中风险客户，当超信贷限额时，订单将会被冻结，后续的业务无法继续进行，经过相应的审批，将被冻结的订单释放后才能进行后续操作；而对于高风险客户，当超信贷限额时，订单根本无法保存。
为了保证创建新客户时同时创建该客户的信用主数据，建议通过系统配置实现创建客户主数据时自动创建该客户的信用主数据。
在具体实现策略方面，建议将内部客户维护成低风险客户，将外部客户维护成中风险或高风险客户。对需要授信的客户，由企业信用管理小组根据客户信用状况给予一定的授信额度，从而实现SAP系统对内控的有效支撑。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c76635e8c8a521a01e2b9c9e70f8226c/" rel="bookmark">
			linux 命令：zip 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zip 命令的功能是打包和压缩文件。
用法
zip [-options] [-b path] [-t mmddyyyy] [-n suffixes] [zipfile list] [-xi list]
如果 zipfile 未提供，压缩标准输入并把结果写到标准输出。
选项
-A 调整自解压程序。
-c 添加单行注释。
-d 从 zipfile 中删除条目。
-db 展示正在执行的字节数和尚未执行（压缩）的字节数。
-dc 展示正在执行的文件数和尚未执行（压缩）的文件数。
-dd 每10MB展示为一个点。
-dg 将整个归档用点代表，而不是为每个文件。
-ds 每个点都代表一个 siz ，其中 siz 是以 nm 为单位作为分割（0 代表没有点）。
-D 不添加目录条目。
-DF 也写作 --dif。只包括有改变的文件或比输入归档较新的文件。
-e 设置解压权限，使用标准（弱）PKZip 2.0 编码，提示输入密码。
-f 只更新有改变的文件。
-F 修复 zipfile（-FF 更努力地修复）。拷贝潜在损坏的归档中的文件到新归档中。 -F 尝试正常读取归档并仅复制完整条目，而 -FF 尝试挽救可能导致不完整条目 的内容。必须使用 --out 指定输出的归档。使用 -v 查看详细信息。
-FS 如果日期或大小改变了就更新，系统不存在的文件就删除。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c76635e8c8a521a01e2b9c9e70f8226c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f6db47e669d31a18ac3347a27d62b30/" rel="bookmark">
			MicroLib微库和ARM标准C库：usart使用中printf重定向引起的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：使用微库（微雪）
在usart.c中添加如下代码：
#ifdef __GNUC__ /* With GCC/RAISONANCE, small printf (option LD Linker-&gt;Libraries-&gt;Small printf set to 'Yes') calls __io_putchar() */ #define PUTCHAR_PROTOTYPE int __io_putchar(int ch) #else #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f) #endif /* __GNUC__ */ /** * @brief Retargets the C library printf function to the USART. * @param None * @retval None */ PUTCHAR_PROTOTYPE { /* Place your implementation of fputc here */ /* e.g. write a character to the EVAL_COM1 and Loop until the end of transmission */ HAL_UART_Transmit(&amp;huart1, (uint8_t *)&amp;ch, 1, 0xFFFF); return ch; } 之后引入相关头文件，并在设置中勾选使用微库，编译成功后即可使用printf()进行串口通信。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f6db47e669d31a18ac3347a27d62b30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4593ec96ad0fd11b140abfd250d57dec/" rel="bookmark">
			linux c语言sleep不占用cpu的验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 不使用sleep的循环程序1.c：
void main(void) { while(1) { ; } } 编译：gcc 1.c -o 1
运行程序1之前的cpu：
运行一次./1 &amp;，用htop查看cpu：
运行8次./1 &amp;，用htop查看cpu：
运行killall 1，终止所有程序1，用htop查看cpu：
结论：不使用sleep,循环会一直占用cpu
2.使用sleep(0)的循环程序0.c：
void main(void) { while(1) { sleep(0); } } 运行8次./0 &amp;，用htop查看cpu：
结论：sleep(0)的循环仍然会占用cpu。
3.使用sleep(1)的循环程序2.c： void main(void) { while(1) { sleep(1); } } 运行16次./2 &amp;，用htop查看cpu：
结论：sleep(1)的循环基本不占用cpu。
3.使用sleep(1000)的循环程序3.c： void main(void) { while(1) { sleep(1000); } } 运行16次./3 &amp;，用htop查看cpu：
结论：sleep(1000)的循环基本不占用cpu。
4.使用usleep(1)的循环程序4.c： void main(void) { while(1) { usleep(1); } } 运行16次./4 &amp;，用htop查看cpu：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4593ec96ad0fd11b140abfd250d57dec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc25ea3c557d315a3d107d2015841573/" rel="bookmark">
			CUDA unknown error - this may be due to an incorrectly set up environment 问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天查看服务器一个使用了pytorch的项目升级后突然出错。报错的全内容由于标题限制，下面我发出来。
builtins.RuntimeError: CUDA unknown error - this may be due to an incorrectly set up environment, e.g. changing env variable CUDA_VISIBLE_DEVICES after program start. Setting the available devices to be zero.
报错截图
后来查阅了一些资料，下面说下几种解决方法。
解决方法 方案1：添加环境变量
由于我是docker容器启动项目，所以进入容器后安装完vim，然后在~/.bashrc最后添加了一下内容。
export CUDA_VISIBLE_DEVICES=0 由于在构建容器的时候选的显卡编号为0，所以上面我配置的编号为0。
重启容器后检查$ CUDA_VISIBLE_DEVICES输出正常，但是没有解决问题，报错依旧。
方案2：代码添加环境变量
在初始化cuda区域最开始添加一下代码。
import os os.environ['CUDA_VISIBLE_DEVICES'] =‘0’ 还是没有解决问题。
方案3：重启服务器
参考了一些文章，提到了如果系统升级了显卡驱动而没有重启的话，也会导致同样的报错。
所以重启了一下服务器，问题解决。
总结 3种方案虽然只有最后一个解决了问题，但是可能因为我的情况特殊。给自己解决过程留个记录，顺便分享一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a5e55e81ab881339c7d1cb7d0ed90be/" rel="bookmark">
			k8s 查看日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查看指定pod的日志
kubectl logs &lt;pod_name&gt;
kubectl logs -f &lt;pod_name&gt; #类似tail -f的方式查看(tail -f 实时查看日志文件 tail -f 日志文件log)
2、查看指定pod中指定容器的日志
kubectl logs &lt;pod_name&gt; -c &lt;container_name&gt;
3、查看Docker容器日志
docker logs &lt;container_id&gt;
参考资料：第5.2.24节 kubectl logs · Kubernetes 中文文档
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/266d30639c43e507127d7c39bdfcc446/" rel="bookmark">
			Mybatis使用的9种设计模式，你知道几种
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Mybatis源码中使用了大量的设计模式，阅读源码并观察设计模式在其中的应用，能够更深入的理解设计模式。
Mybatis至少遇到了以下的设计模式的使用：
Builder模式，例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder；
工厂模式，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory；
单例模式，例如ErrorContext和LogFactory；
代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；
组合模式，例如SqlNode和各个子类ChooseSqlNode等；
模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler；
适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；
装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现；
迭代器模式，例如迭代器模式PropertyTokenizer；
接下来挨个模式进行解读，先介绍模式自身的知识，然后解读在Mybatis中怎样应用了该模式。
1、Builder模式 Builder模式的定义是“将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。”，它属于创建类模式，一般来说，如果一个对象的构建比较复杂，超出了构造函数所能包含的范围，就可以使用工厂模式和Builder模式，相对于工厂模式会产出一个完整的产品，Builder应用于更加复杂的对象的构建，甚至只会构建产品的一个部分。
在Mybatis环境的初始化过程中，SqlSessionFactoryBuilder会调用XMLConfigBuilder读取所有的MybatisMapConfig.xml和所有的*Mapper.xml文件，构建Mybatis运行的核心对象Configuration对象，然后将该Configuration对象作为参数构建一个SqlSessionFactory对象。
其中XMLConfigBuilder在构建Configuration对象时，也会调用XMLMapperBuilder用于读取*Mapper文件，而XMLMapperBuilder会使用XMLStatementBuilder来读取和build所有的SQL语句。
在这个过程中，有一个相似的特点，就是这些Builder会读取文件或者配置，然后做大量的XpathParser解析、配置或语法的解析、反射生成对象、存入结果缓存等步骤，这么多的工作都不是一个构造函数所能包括的，因此大量采用了Builder模式来解决。
对于builder的具体类，方法都大都用build*开头，比如SqlSessionFactoryBuilder为例，它包含以下方法：
即根据不同的输入参数来构建SqlSessionFactory这个工厂对象。
2、工厂模式 在Mybatis中比如SqlSessionFactory使用的是工厂模式，该工厂没有那么复杂的逻辑，是一个简单工厂模式。
简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。java培训在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
SqlSession可以认为是一个Mybatis工作的核心的接口，通过这个接口可以执行执行SQL语句、获取Mappers、管理事务。类似于连接MySQL的Connection对象。
可以看到，该Factory的openSession方法重载了很多个，分别支持autoCommit、Executor、Transaction等参数的输入，来构建核心的SqlSession对象。
在DefaultSqlSessionFactory的默认工厂实现里，有一个方法可以看出工厂怎么产出一个产品：
private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) { Transaction tx = null; try { final Environment environment = configuration.getEnvironment(); final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment); tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit); final Executor executor = configuration.newExecutor(tx, execType); return new DefaultSqlSession(configuration, executor, autoCommit); } catch (Exception e) { closeTransaction(tx); // may have fetched a connection so lets call // close() throw ExceptionFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/266d30639c43e507127d7c39bdfcc446/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa2cf803dabcebdc2cf3696b838d6ae1/" rel="bookmark">
			CIDR表示IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CIDR表示的IP地址段解析 举例：IP号段是125.203.96.0 - 125.203.127.255，转换成CIDR格式是多少？
解析：转换为CIDR就是找相同部分，把十进制数转换成二进制数，例如125.203.96.0 - 125.203.127.255，相同的忽略不计，把不同的数字转换成二进制，然后找相同的位数：
IP号段：125.203.96.0 - 125.203.127.255
转成二进制：125.203.0110 0000.0000 0000 - 125.203.0111 1111.1111 1111
分析：十进制125和203是相同的，8+8=16位；二进制011是相同的，再加上3位，16+3=19位
所以，IP号段：125.203.96.0 - 125.203.127.255 转换成CIDR格式为125.203.96/19
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10b534c2e555be276a5f769bbfb3065a/" rel="bookmark">
			C&#43;&#43; 创建unordered_map将vector作为key
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unordered_map&lt;vector&lt;int&gt;,int&gt; hashtable; 自定义哈希函数 // cited from: // https://stackoverflow.com/questions/20511347/a-good-hash-function-for-a-vector // equivalent to : hash_combine() (from boost lib) struct HashFunc_t { size_t operator() (const vector&lt;int&gt;&amp; key) const { std::hash&lt;int&gt; hasher; size_t seed = 0; for (int i : key) { seed ^= hasher(i) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2); } return seed; } }; 自定义等价操作函数（可选） struct Equalfunc_t { bool operator() (vector&lt;int&gt; const&amp; a, vector&lt;int&gt; const&amp; b) const { for (int i = 0; i &lt; a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10b534c2e555be276a5f769bbfb3065a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b30b05525c2c3b5857c25f673abcdef6/" rel="bookmark">
			Unity初级案例-愤怒的小鸟:五:14添加失败和胜利的游戏UI界面&#43;15修改火花粒子系统&#43;16渲染层级关系&#43;17把粒子系统显示在UI之前
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.目的
1.想知道:愤怒的小鸟:如何制作
2.做好学习笔记，方便下次查看
二.参考
1.SIKI学院
三.注意
1.版本
操作:1:14添加失败和胜利的游戏UI界面
1.新建UI的Image作为失败、胜利的整体背景图
1.在lose下再新建Image，作为按钮的背景图
1.切割按钮图​ 1.设置按钮
1.设置lose界面的动画 ​
1.设置win界面+动画
1.代码：GameManager：制作输赢
1.代码：Win：给赢的UI添加逻辑
1.动画设置：win界面动画播放完毕，显示星星
1.运行结果：成功
操作:2:15修改火花粒子系统
1.裁剪星星+添加星星到赢的UI界面中
1.导入火花粒子的资源
1.烟火粒子特效调整
操作:3: 16渲染层级关系
1.渲染层级知识： 一.目的 1.想知道:愤怒的小鸟:如何制作 2.做好学习笔记，方便下次查看 二.参考 1.SIKI学院 登录 - SiKi学院 - 生命不息，学习不止！
good：学习的网址
三.注意 1.版本 Unity2017.2.0f3VS2019UnityHUB 2.5.6 操作:1:14添加失败和胜利的游戏UI界面 1.新建UI的Image作为失败、胜利的整体背景图 新建后，如图所视，全屏显示+改名字为lose
如果所视将其弄成半透明度
1.在lose下再新建Image，作为按钮的背景图 如图所视，将其颜色、位置等设置好
1.切割按钮图 1.设置按钮 如图所视设置2个按钮图片+1个猪头 +改名字为home和retry
1.设置lose界面的动画 1.设置win界面+动画 基本都是从lose界面和动画中复制过来的+将win里面的动画修改一下
1.代码：GameManager：制作输赢 using System.Collections; using System.Collections.Generic; using UnityEngine; /// &lt;summary&gt; /// 【Author：xzy;Time:2021-12-29】【10游戏逻辑的判定，实现多只小鸟的飞出：添加】 /// Function:小猪身上的代码 /// &lt;/summary&gt; public class GameManager : MonoBehaviour { /// &lt;summary&gt;List：所有的小鸟【10游戏逻辑的判定，实现多只小鸟的飞出：添加】&lt;/summary&gt; public List&lt;Bird&gt; birds; /// &lt;summary&gt;List：所有的猪【10游戏逻辑的判定，实现多只小鸟的飞出：添加】&lt;/summary&gt; public List&lt;Pig&gt; pigs; /// &lt;summary&gt;单例【10游戏逻辑的判定，实现多只小鸟的飞出：添加】&lt;/summary&gt; public static GameManager _instance; /// &lt;summary&gt;Vector3：初始化位置【11解决重复划线和小鸟轮换速度突然变大的问题：添加】&lt;/summary&gt; private Vector3 originPos; /// &lt;summary&gt;GameObject：赢界面【14 - 添加失败，胜利的游戏UI界面：添加】&lt;/summary&gt; public GameObject win; /// &lt;summary&gt;GameObject：输界面【14 - 添加失败，胜利的游戏UI界面：添加】&lt;/summary&gt; public GameObject lose; private void Awake() { _instance = this;//单例 if (birds.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b30b05525c2c3b5857c25f673abcdef6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf50133d44b4270934288711bf811503/" rel="bookmark">
			MapReduce实战案例：发现共同好友
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mapreduce原理 MapReduce是一种编程模型，用于大规模数据集的并行运算，其中包含 Map（映射） 和 Reduce（归约） 两个阶段。
接下来以最经典的 Word Count 案例进行解析
在MapReduce整个过程可以概括为以下过程：
输入 --&gt; map --&gt; shuffle --&gt; reduce --&gt;输出
流程说明如下：
输入文件分片，每一片都由一个MapTask来处理
Map输出的中间结果会先放在内存缓冲区中，这个缓冲区的大小默认是100M，当缓冲区中的内容达到80%时（80M）会将缓冲区的内容写到磁盘上。也就是说，一个map会输出一个或者多个这样的文件，如果一个map输出的全部内容没有超过限制，那么最终也会发生这个写磁盘的操作，只不过是写几次的问题。
从缓冲区写到磁盘的时候，会进行分区并排序，分区指的是某个key应该进入到哪个分区，同一分区中的key会进行排序，如果定义了Combiner的话，也会进行combine操作
如果一个map产生的中间结果存放到多个文件，那么这些文件最终会合并成一个文件，这个合并过程不会改变分区数量，只会减少文件数量。例如，假设分了3个区，4个文件，那么最终会合并成1个文件，3个区
以上只是一个map的输出，接下来进入reduce阶段
每个reducer对应一个ReduceTask，在真正开始reduce之前，先要从分区中抓取数据
相同的分区的数据会进入同一个reduce。这一步中会从所有map输出中抓取某一分区的数据，在抓取的过程中伴随着排序、合并。
reduce输出
案例背景 假设有以下好友列表，A的好友有B,C,D,F,E,O; B的好友有A,C,E,K
那我们要如何算出A-O用户每个用户之间的共同好友呢？
A:B,C,D,F,E,O B:A,C,E,K C:F,A,D,I D:A,E,F,L E:B,C,D,M,L F:A,B,C,D,E,O,M G:A,C,D,E,F H:A,C,D,E,O I:A,O J:B,O K:A,C,D L:D,E,F M:E,F,G O:A,H,I,J 解决思路 下面我们将演示分步计算，思路主要如下：
提取用户的好友列表 提取共同好友 代码实现 由上可知，此次计算由两步组成，因此需要两个MapReduce程序先后执行
Maven项目配置 在编写程序前需要先导入Maven依赖与打包插件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--此处为Maven项目信息--&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;!--Maven项目全局配置--&gt; &lt;properties&gt; &lt;project.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf50133d44b4270934288711bf811503/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e91b33589191fc68cc964cdd9627e225/" rel="bookmark">
			Unity初级案例-愤怒的小鸟:三:07猪的受伤&#43;08弹弓划线操作&#43;09死亡和加分特效的制作&#43;10游戏逻辑的判定，实现多只小鸟的飞出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.目的
1.想知道:愤怒的小鸟:如何制作
2.做好学习笔记，方便下次查看
二.参考
1.SIKI学院
三.注意
1.版本
操作:1:07猪的受伤
1.游戏逻辑
1.图片裁剪：制作背景等
1.创建空物体，取名字为env​ 1.拖拽地面图片在env下面+并且添加碰撞器+调整碰撞器的位置+复制地面
1.设置鸟的角阻力：让其 不会一直滚动
1.运行结果：成功
1.添加小猪，改名字为pig
1.运行结果：
1.小猪添加代码： 1.小猪设置
1.运行结果
操作:2: 08弹弓画线操作
1.制作左边弹弓的位置：
1.左右弹弓添加划线组件
1.代码：弹弓划线
1.小鸟设置+划线宽度设置
1.运行结果：成功
操作:3:09死亡、加分特效的制作
1.游戏逻辑 1.新建爆炸的特效：
1.给特效添加代码：Boom
1.BOOM特效最后一帧添加事件
1.Boom作为预制件
1.小猪代码：进行销毁的处理
1.运行效果：成功
1.加分特效图片制作：
1.代码：pig添加加分特效产生、销毁 ​
1.运行效果：成功
操作：4：10游戏逻辑的判定，实现多只小鸟的飞出
1.游戏逻辑
1.新建空物体：
1.代码： GameManager
1.鸟的代码：
1.猪的代码：
1.Unity设置
1.运行效果：完成
一.目的 1.想知道:愤怒的小鸟:如何制作 2.做好学习笔记，方便下次查看 二.参考 1.SIKI学院 登录 - SiKi学院 - 生命不息，学习不止！
good：学习的网址
三.注意 1.版本 Unity2017.2.0f3VS2019UnityHUB 2.5.6 操作:1:07猪的受伤 1.游戏逻辑 ​
1.图片裁剪：制作背景等 ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e91b33589191fc68cc964cdd9627e225/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d917d6dc03348d9505b7fc53546765b1/" rel="bookmark">
			计算机基础常识快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 常用快捷键 待更新！
2.页面回到页尾、页首 ctrl+end
ctrl+home
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/817467dcedcd4aeddb239f13ff3f003f/" rel="bookmark">
			linux用户登陆被锁定查看与解锁（后续补充策略）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查看是否被锁定 sudo pam_tally2 --user=root
sudo pam_tally2 --user root
2.解锁 sudo pam_tally2 -u root -r --reset
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0fb7098a0d9ba7f8056579e8af109c1/" rel="bookmark">
			[Nginx] nginx屏蔽某个url和指定参数访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有个地址总是被人恶意访问，可以配置nginx屏蔽这个请求
域名/chatIndex?kefu_id=l5702123&amp;ent_id=324
location ~ / { if ( $query_string ~* ^(.*)?kefu_id=l5702123&amp;ent_id=324 ){ return 403; } } 这样对方的请求全都变成403
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ec34910e3ae4a3d4dcfc88d93b475c8/" rel="bookmark">
			Qt之QString字符串类的详细介绍及功能函数示例用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前序：为了加深对Qt各个类的认识和了解，决定以后再闲暇的时间对Qt类进行详细的阅读（基于Qt cteater 的帮助文档），这样既可以提高自己的英文阅读能力，也可以对各个类有一个更加深入的认识和了解。
注：整个对Qt的拆解和分析都是基于Qt 5.80
开始啃帮助文档。以下总结不会对帮助文档全篇内容翻译，会在自己翻译的基础上加上自己的理解，进行一个简单的总结，以便在使用时忘记的时候复习查看。
目录
1.Detailed Description（详细描述）
2. Public Functions 公有的函数
2.1 类对象的构造
2.2 追加字符串（前追加prepend or push_front和后追加append or push_back）
2.3 组合字符串（arg）
2.4 字符串的裁剪（chop，truncate，resize，remove）
2.5 字符串的比较（compare,constData）
2.6 判断字符串是否存在（contains）
2.7 判断字符串出现的次数（count）
2.8 字符串的大小长度（count，size，length）
2.9 判断字符串是否以某一个子串开始（startsWith）
2.11 查找字符串获取第一次出现位置索引（indexof）
2.12 查找字符串获取最后一次出现位置索引（lastIndexof）
2.13 字符串的插入（insert，left，leftJustified，rightJustified）
2.14 字符串的分割（mid）
2.15 字符串的删除（remove）
2.16 字符串的替换（replace）
2.17 字符串的截取（section）
2.18 字符串的裁剪（fill）
2.19 字符串的简化（simplified，trimmed）
2.20 分隔字符串 （split）
2.22 字符串------&gt;数（toDouble，toInt......）
2.23 数------&gt;QString字符串（setNum，number）
2.24 字符串的大小写转换（toLower，toUpper）
2.25 其他（at，begin，end，isEmpty，isNull，clear）
3. 字符串的重载
1.Detailed Description（详细描述） ①、首先QString字符串类是提供的基于Unicode的字符串。QString存储一个16位的QChar字符串，每个QChar对应一个Unicode 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ec34910e3ae4a3d4dcfc88d93b475c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa267e0d2f6ae41e90cdaf4a3672f60c/" rel="bookmark">
			【C语言】输入一行字符，分别统计出其中英文字母 空格 数字和其他字符的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 输入一行字符，分别统计出其中英文字母 空格 数字和其他字符的个数
#include &lt;stdio.h&gt; int main() { char c; int letters=0,space=0,digit=0,other=0; printf("请输入一行字符："); while ((c=getchar())!='\n'){ if (c &gt;= 'a'&amp;&amp;c &lt;= 'z' || c &gt;= 'A'&amp;&amp;c &lt;= 'Z'){ letters++; }else if(c == ' '){ space++; }else if(c&gt;='0'&amp;&amp;c&lt;='9'){ digit++; }else{ other++; } } printf("字母数:%d\n空格数:%d\n数字数:%d\n其他字符:%d\n",letters,space,digit,other); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/248bae9cea8712c67280f43c8376063d/" rel="bookmark">
			SpringCloud微服务 Liquibase pdman实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优势 安全（网络隔离）保障，生产环境不提供内网数据库ip地址，数据库所有变更全部通过liquibase操作
pdman轻量级文档导出，方便阅读、评审
pdman数据库通过git多人协作设计、版本管理比较方便
pdman自动生成ddl，方便liquibase反向生成changeLog
liquibase 多个微服务（多个数据库）场景下，表结构、初始数据（字典、基础配置等）版本管理方便，全自动创建、变更、自检
liquibase 多环境下（开发、测试、UAT、生产），保障表结构、初始数据（字典、基础配置等）一致，多环境自动同步，无额外成本
liquibase 表重构changeSet语法简单，易上手，官方文档全面、易懂
liquibase 再也不用担心在dev环境里做的变更，是否在其它环境也同步了。
1.liquibase简介 Liquibase是一个用于跟踪、管理和应用数据库变化的开源的数据库重构工具。它将所有数据库的变化（包括结构和数据）都保存在XML文件中，便于版本控制。
不依赖于特定的数据库，目前支持包括Oracle/Sql Server/DB2/MySql/Sybase/PostgreSQL/Caché等12种数据库，这样在数据库的部署和升级环节可帮助应用系统支持多数据库。
提供数据库比较功能，比较结果保存在XML中，基于该XML你可用Liquibase轻松部署或升级数据库。
以XML存储数据库变化，其中以作者和ID唯一标识一个变化（ChangSet），支持数据库变化的合并，因此支持多开发人员同时工作。
在数据库中保存数据库修改历史（DatabaseChangeHistory），在数据库升级时自动跳过已应用的变化（ChangSet）。
提供变化应用的回滚功能，可按时间、数量或标签（tag）回滚已应用的变化。通过这种方式，开发人员可轻易的还原数据库在任何时间点的状态。
可生成数据库修改文档（HTML格式）
提供数据重构的独立的IDE和Eclipse插件。
2.pdman 官方网址：PDMan数据库建模
开源的数据库建模工具，json文档，DDL生成，文档生成，通用字段模板，数据域自定义，多数据库类型支持。
3. 使用场景-流程 微服务liquibase配置
pdman数据库设计文件
pdman数据库设计表自动生成DDL
3.1 新库（微服务）-表设计
pdman新建项目
pdman在新项目中创建模块（根据微服务）
pdman配置默认数据通用字段（如乐观锁、租户id、创建人等）
pdman在模块中创建表和索引
表设计评审后，将pdman json文件放到项目根目录下并提交-版本管理
dbclient（navicat/datagrip）连接上dev环境数据库实例，使用pdman生成ddl，然后执行ddl生成表对象及索引
在微服务pom中配置liquibase maven插件，如数据库连接、chagelog配置、指定影响的表、表结构、表数据，其中outputChangeLogFile配置changelog输入的位置
使用maven命令 ：liquibase:generateChangeLog生成resource_init-1.0.0.xml，resource为微服务标识，按需修改
使用maven命令 ：liquibase:dropAll命令，删除数据库手工创建的所有表结构和索引
启动项目，查看日志，数据库确认已经按changeLog自动生成相应的表结构和索引
3.2 库中有表-表重构
3.2.1 新增表
pdman模块中设计表、索引
评审通过后提交json文件
pdman生成新增表的ddl（结构和索引），dbclient手动生成表结构和索引
在微服务pom中配置liquibase maven插件，通过diffIncludeObjects标签指定新增表的表名，指定changeLog输出文件名resource_init-1.0.1.xml
使用maven命令 ：liquibase:generateChangeLog生成resource_init-1.0.1.xml，resource为微服务标识，按需修改
dbclient手动删除新增的表结构和索引
启动项目，查看日志，数据库确认已经按changeLog自动生成相应的表结构和索引
3.2.2 表结构变更
pdman模块中变更表设计
评审通过后提交json文件
resource_init-1.0.1.xml中编写相应changeSet，或者新建resource_init-1.0.2.xml，在其中相应changeSet，内部达成共识（变更的业务是否独立，changeSet数量）
启动项目，查看日志，数据库确认已经按changeLog自动对表结构进行重构
提交变更的changeSet
4 项目配置 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/248bae9cea8712c67280f43c8376063d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0401e2651bcbfc244ae0c2c71151381f/" rel="bookmark">
			Scanner类的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.hasNext()
当执行hasNext()时，它会先扫描缓冲区中是否有字符，有则返回true，继续扫描。直到扫描为空，这时并不返回false，而是将方法阻塞，等待你输入内容然后继续扫描。
也就是说，hasNext()会一直等待方法调用者的输入，不会停止。那么应该如何停止呢，这时就要用到hasNext()的重载函数
(图片来自https://blog.csdn.net/gao_zhennan/article/details/80562548）
即hasNext("")，使用一个字符串作为匹配符，当出现该字符串，即返回true。然后我们将其取反，即变成当出现该字符串，返回false的结果，也就可以将该字符串当作结束标志来使用从而使得程序块停止。
另外,hasNext还有一系列衍生的函数比如hasNextInt,hasNextDouble等，效果跟hasNext差不多，但是当hasNextxxx读到与xxx不匹配的类型时，该程序块就结束了。我们可以利用这点来设置输入数据的结束标志，比如要计算一串数字的平均值，我们可以采用累加的方法获取sum，最后除以数字个数m。我们可以在输入的最后输入一个end字符串，这样字符串和Int类型不匹配，累加就会自动结束了。
2.nextxxx()方法
next()：接收一个字符串，以空格为间隔；
nextInt()：接收一个整数，以空格为间隔；
nextDouble()：接收一个数字，以空格为间隔。
nextFloat(）等等以此类推
3.nextLine()
接收一行字符串，以回车作为结束符
4.next()和nextLine()的区别
next():
1、一定要读取到有效字符后才可以结束输入。
2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。
3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。
next() 不能得到带有空格的字符串。
nextLine()：
1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。
2、可以获得空白。
注：为了文件读写的安全性，Scanner类使用完后要用close()方法关闭
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9b6a06046880c77e517943c9beb0b07/" rel="bookmark">
			SiamMask环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方项目：https://github.com/foolwood/SiamMask
直接按照给出的步骤配置即可
可参考下：SiamMask详解
不过呢，按照官方给的步骤一般问题不大，需要注意有两个地方：
（1）环境版本
平常常用的就可以，不是一定要和推荐一致
我采用的版本是：Python 3.6
Pytorch 1.0
CUDA 10.2
torch 1.2.0 torchvision 0.4.0
（2）若是执行
python ../../tools/demo.py --resume SiamMask_DAVIS.pth --config config_davis.json 遇到调用某个函数或变量不存在，记得执行以下两步：
1、在项目主目录执行
export PYTHONPATH=$PWD:$PYTHONPATH
2、在
experiments/siammask_sharp 文件夹下执行
export PYTHONPATH=$PWD:$PYTHONPATH 这样就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22d86cc4df429c3d8f3fcbc8f059bc98/" rel="bookmark">
			包过滤防火墙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		包过滤防火墙
包过滤( Packet Filter )是在网络层中根据事先设置的安全访问策略(过滤规则) ,检查每一个数据包的源IP地址、目的IP地址以及IP分组头部的其他各种标志信息(如协议、服务类型等) , 确定是否允许该数据包通过防火墙一般会配置成双向过滤包过滤器设置成一些基于IP或TCP字头域匹配的规则当没有匹配的规则，防火墙执行默认策略
默认=丢弃
默认=传递 缺点
由于包过滤防火墙不检查更高层数据，因此这种防火墙不能阻止利用了特定应用的漏洞或功能所进行的攻击
包过滤防火墙对利用 TCP / IP 规范和协议栈存在的问题进行的攻击没有很好的应对措施（网络层地址假冒、无法阻止ip欺骗）
大多数包过滤防火墙不支持高级的用户认证机制。
针对包过滤路由器可能受到的攻击方式以及合适的应对措施
IP 地址假冒攻击——丢弃那些外部接口到达的而源地址标记为内部主机地址的包
源路由攻击——丢弃所有使用了此选项的包
细小帧攻击——包的第一个帧必须包含最少的预定的传输字头。如果第一个帧被否决了，过滤器将记住这个包并丢弃紧接着的所有帧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c78a8f5e1ecd2cc3e772f756dd3ca525/" rel="bookmark">
			技术分享 | 常见的DDoS攻击类型及防御措施
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		据权威数据显示，2021年上半年，全球发生DDoS攻击约 540 万次，同比增长11%，据估计，2021年整年DDoS攻击次数将创纪录地达到1100万次。其中超百G的大流量攻击次数在上半年就达到了2544次，同比增长50%以上，大幅高于整体攻击次数的增长幅度。
从这些数据中可以看出，随着网络技术的快速发展，DDoS攻击将呈现高频次、高增长、大流量等特点，对网络安全的威胁也会与日俱增，因此做好DDoS攻击的防护工作已是刻不容缓。
一、什么是DDoS攻击 分布式拒绝服务攻击(Distributed Denial of Service，简称“DDoS”)是指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。由于攻击的发出点分布在不同地方，因此称这类攻击为分布式拒绝服务攻击。
二、DDoS攻击原理 单一的DoS攻击一般采用一对一方式，利用网络协议和操作系统的一些缺陷，采用欺骗和伪装的策略来进行网络攻击，使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务。
与DoS攻击由单台主机发起攻击相比较，分布式拒绝服务攻击（DDoS）是借助数百、甚至数千台被入侵后安装了攻击进程的主机同时发起集团行为，从而快速达到消耗网络资源，造成网络或系统瘫痪的攻击效果。
三、DDoS攻击常见类型 1.流量型攻击
攻击原理：通过多个随机源“肉鸡”向攻击目标发送大量的数据包，占用攻击目标网络资源和处理单元，造成攻击目标的网络堵塞或宕机。
流量型DDoS攻击根据攻击方式的不同可以分为IP lood、SYN Flood以及UDP反射Flood等。
（1）IP lood
以多个随机的源主机地址向目的主机发送超大量的随机或特定的IP包，造成目标主机不能处理其他正常的IP报文。
（2）SYN Flood
以多个随机的源主机地址向目的主机发送syn包，而在收到目的主机的syn+ ack包后并不回应，目的主机为这些源主机建立大量的连接队列，由于没有收到ack一直维护这些连接队列，造成资源的大量消耗而不能向正常的请求提供服务。
（3）UDP 反射Flood
在短时间内冒充被攻击地址向外部公用的服务器发送大量的UDP请求包，外部服务器收到虛假的UDP请求就会回复大量的回应包给被攻击服务器地址，造成目标主机被保护，服务器不能处理其他正常的交互流量。
2.连接型攻击
攻击原理：利用目标用户获取服务器资源时需要交换DNS数据包的特性，发送大量的伪装DNS数据包导致目标用户网络拥塞，不能访问目标服务器。
连接型DDoS攻击根据攻击方式的不同可以分为DNS Query Flood和DNS Reply Flood等。
DNS Query Flood通过发起大量的DNS请求，导致DNS服务器无法响应正常用户的请求，正常用户不能解析DNS，从而不能获取服务。
DNS Reply Flood通过发起大量伪造的DNS回应包，导致DNS服务器带宽拥塞无法响应正常用户的请求，正常用户不能解析DNS，从而不能获取服务。
3.特殊协议缺陷攻击
攻击原理：利用目标用户平时使用服务所需要的协议漏洞，通过协议漏洞向目标用户递送大量的数据交换包，导致目标用户无法正常使用主机。特殊协议缺陷攻击常见的方式有Https Flood、Sip Invite Flood、Sip Register Flood、Ntp Request Flood、Connection Flood等。
（1）Https Flood
攻击者向被攻击服务器大量高频地发送请求服务，使服务器忙于向攻击者提供https响应资源，从而导致不能向正常的合法用户提供请求响应服务。
（2）Sip invite Flood
通过发起大量的Sip invite请求，导致网络视频电话会议Sip服务器无法响应正常用户的请求报文，占用服务器带宽使其阻塞，达到Sip报文洪水攻击的目的。
（3）Ntp Request Flood
攻击者向NTP服务器发送大量的请求报文，占用服务器带宽使其阻塞达到NTP攻击的目的。
（4）Connection Flood
利用真实IP地址(代理服务器、广告页面)在服务器上建立大量连接，造成服务器上残余连接过多，效率降低，甚至资源耗尽，无法响应。
四、DDoS攻击防护 1、网络设施
（1）保证足够带宽
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c78a8f5e1ecd2cc3e772f756dd3ca525/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/153258dd80b908a39f8f0d72319aa656/" rel="bookmark">
			unnamed prototyped parameters not allowed when body is present
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写了一段代码，本以为没什么问题，结果报错：
: error: #141-D: unnamed prototyped parameters not allowed when body is present
结果查看了一下，使用的一个第三方库里面，居然把code定义成了一个宏
更改一下刚才函数的局部变量定义即可
发生这种错误，一般是变量和宏名称冲突导致的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93029d5c42d9697e21324348071517f1/" rel="bookmark">
			31 个 CSS Javascript 按钮悬停案例的效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		英文 | https://niemvuilaptrinh.medium.com/31-css-javascript-button-hover-effects-d536679cfbf4
翻译 | 杨小爱
今天，我们将进入使用 HTML、CSS、Javascript 构建的网站中按钮的精美效果示例！
01、带有箭头图标的按钮 CSS
演示地址：https://codepen.io/littlesnippets/pen/VjJmPB
02、动画按钮
演示地址：https://codepen.io/littlesnippets/pen/LxRKJm
03、多样动画按钮
演示地址：https://codepen.io/emanuelgsouza/pen/YVJOZo
04、动画按钮
演示地址：https://codepen.io/littlesnippets/pen/JXNYwe
05、悬停动画按钮
演示地址：https://codepen.io/Carlos1162/pen/eJdLXa
06、糖果色动画按钮
演示地址：https://codepen.io/yuhomyan/pen/OJMejWJ
07、订单动画按钮
演示地址：https://codepen.io/aaroniker/pen/oNgPOwo
08、动画按钮
演示地址：https://codepen.io/milanraring/pen/QWwyLdp
09、文本动画按钮
演示地址：https://codepen.io/madshaakansson/pen/iqDsG
10、悬停动画按钮
演示地址：https://codepen.io/dan10gc/pen/LzLwWp
11、删除动画按钮
演示地址：https://codepen.io/aaroniker/pen/MWwGbVb
12、动画按钮
演示地址：https://codepen.io/pizza3/pen/qmerBv
13、动画按钮
演示地址：https://codepen.io/prvnbist/pen/pWLJpa
14、动画按钮集合
演示地址：https://codepen.io/sazzad/pen/yNNNJG
15、动画按钮
演示地址：https://codepen.io/matchboxhero/pen/EwdmmP
16、动画按钮悬停效果
演示地址：https://codepen.io/colette-wilson/pen/EKaJvJ
17、纯CSS悬停效果
演示地址：https://codepen.io/marioandrade/pen/aOBZee
18、悬停按钮动画效果
演示地址：https://codepen.io/chrishammond/pen/eEmrww
19、动画按钮
演示地址：https://codepen.io/valentingalmand/pen/ggKrpY
20、CSS动画按钮
演示地址：https://codepen.io/githiro/pen/LwtzG
21、动画按钮
演示地址：https://codepen.io/aydev/pen/BbIsg
22、气泡按钮动画
演示地址：https://codepen.io/Grsmto/pen/RPQPPB
23、按钮动画
演示地址：https://codepen.io/nguyenlong/pen/kXGxJG
24、按钮动画
演示地址：https://codepen.io/Alexb98/pen/XWrqpxB
25、渐变按钮动画
演示地址：https://codepen.io/mars2601/pen/MKVNMX
26、花式菜单按钮动画
演示地址：https://codepen.io/nodws/pen/KgObjM
27、按钮动画
演示地址：https://codepen.io/littlesnippets/pen/dYoZpE
28、颜色动画按钮
演示地址：https://codepen.io/kitsune/pen/wWoRVW
29、颜色变化动画按钮
演示地址：https://codepen.io/alexpate/pen/YyLOWQ
30、Anmation的按钮动画合集
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93029d5c42d9697e21324348071517f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/268e861a690004d83a55db84bd9a60e3/" rel="bookmark">
			Flink将数据写入到hdfs中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 场景 随机产生数据然后将产生的数据写入到hdfs 中。
2. 随机数据源 代码：
package com.wudl.flink.hdfs.source; import org.apache.flink.api.java.tuple.Tuple; import org.apache.flink.api.java.tuple.Tuple4; import org.apache.flink.streaming.api.functions.source.SourceFunction; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Random; /** * @author ：wudl * @date ：Created in 2021-12-27 0:29 * @description： * @modified By： * @version: 1.0 */ public class MySource implements SourceFunction&lt;String&gt; { private boolean isRunning = true; String[] citys = {"北京","广东","山东","江苏","河南","上海","河北","浙江","香港","山西","陕西","湖南","重庆","福建","天津","云南","四川","广西","安徽","海南","江西","湖北","山西","辽宁","内蒙古"}; int i = 0; @Override public void run(SourceContext&lt;String&gt; ctx) throws Exception { Random random = new Random(); SimpleDateFormat df = new SimpleDateFormat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/268e861a690004d83a55db84bd9a60e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/771bb3d5cfa5c11aca159190dc8799ea/" rel="bookmark">
			python基础——库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		库与方法
（1）turtle：图库
导入格式：
A:
import&lt;库名&gt;
&lt;库名&gt;.函数名（参数）
B:
import&lt;库名&gt; as &lt;库的简名&gt;
&lt;库的简名&gt;.函数名（参数）
C:
from&lt;库名&gt;import&lt;库名/函数名&gt;
函数名（参数）
（2）函数（方法）：
pensize(画笔大小像素)
pencolor(‘画笔的颜色’)/（R,G,B）(0-1)
color（‘画笔颜色’，‘填充颜色’）/（R,G,B）(0-1)
circle(园半径r像素)，r为正--左，r为负--右。
right（角度）
left（角度）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cec482c3428c320024ca14548e7e4d1/" rel="bookmark">
			用python画玫瑰花
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import turtle as t t.setup(800,800) t.hideturtle() t.speed(11) t.penup() t.goto(50,-450) t.pensize(5) t.pencolor("black") t.seth(140) t.pendown() t.speed(10) t.circle(-300,60) t.fd(100) #叶子 t.seth(10) t.fd(50) t.fillcolor("green") t.begin_fill() t.right(40) t.circle(120,80) t.left(100) t.circle(120,80) t.end_fill() t.seth(10) t.fd(90) t.speed(11) t.penup() t.fd(-140) t.seth(80) #一片叶子 t.pendown() t.speed(10) t.fd(70) t.seth(160) t.fd(50) t.fillcolor("green") t.begin_fill() t.right(40) t.circle(120,80) t.left(100) t.circle(120,80) t.end_fill() t.seth(160) t.fd(90) t.speed(11) t.penup() t.fd(-140) t.seth(80) t.pendown() t.speed(10) # t.fd(100) #花瓣 t.seth(-20) t.fillcolor("red") t.begin_fill() t.circle(100,100) t.circle(-110,70) t.seth(179) t.circle(223,76) t.end_fill() #2花瓣 t.speed(11) t.fillcolor("red") t.begin_fill() t.left(180) t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cec482c3428c320024ca14548e7e4d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a9b049abfdb9bffe0e409b726528934/" rel="bookmark">
			python基础——标识符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标识符是编程时使用的名字，用于给变量、函数、语句块等命名，Python 中标识符由字母、数字、下划线组成，不能以数字开头，区分大小写。
以下划线开头的标识符有特殊含义，单下划线开头的标识符，如：_xxx ，表示不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 导入；双下划线开头的标识符，如：__xx，表示私有成员；双下划线开头和结尾的标识符，如：__xx__，表示 Python 中内置标识，如：__init__() 表示类的构造函数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26f4c636076b92be701c4ee1a2d8be4c/" rel="bookmark">
			csv文件和txt文件的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 csv文件：Comma-Separated Values，逗号分隔值文件。其基本规则：
纯文本格式（txt）
特殊符号分隔（逗号）
以行为单位（line/row），中间没有空行
逗号一定是英文半角，分隔每列数据（二维数组）
txt文件：由单一特定编码（如UTF_8）组成的文件,能用记事本打开和读取的文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3403198dcb18d0328b7ece29b007c6c4/" rel="bookmark">
			【批量地点检索-高德百度地图地理编码对比】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		批量地点检索 基于python地理位置描述转经纬度坐标 前提： 需要安装部署python环境
安装导入模块：
import requests
import json
import math
发送请求 调用函数
html = requests.get(url)
发送url获取html，调用函数
JasonData = json.loads（html.txt）
获取返回文本信息，字符串解码为字典
1. 百度地图开放平台 web服务api 百度地图返回百度坐标系，需要注册申请百度地图开放平台个人账户，每日额度30w条，申请api接口key（AK）:
https://lbsyun.baidu.com/apiconsole/key#/home
1.1 地理位置检索poi接口 可通过该功能，检索某一行政区划内（目前最细到城市级别）的地点信息。此方法搜索同百度地图主界面地点搜索；注：宽容度低，可能会有大量地点搜索失败，返回空值，但可强制约束行政区，可返回WGS84坐标。
url格式：
https://api.map.baidu.com/place/v2/search?query=ATM机&amp;tag=银行&amp;region=北京&amp;output=json&amp;ak=您的ak
参数解释详见：
https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-placeapi
1.2 地理编码检索 地理编码服务提供将结构化地址数据（如：北京市海淀区上地十街十号）转换为对应坐标点（经纬度）功能，地理编码服务当前未推出国际化服务，解析地址仅限国内；注：此方法宽容度较高，地点数据库较大，与百度地图主界面检索不同，但有可能返回较大错误地址，不可强制约束行政区，不可返回WGS84坐标。
url格式：
https://api.map.baidu.com/geocoding/v3/?address=北京市海淀区上地十街10号&amp;output=json&amp;ak=您的ak&amp;callback=showLocation
参数解释详见：
https://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding
2. 高德地图开放平台 web服务api 高德地图使用国家火星坐标系，使用需要注册申请高德地图开放平台个人账户，每日额度30w条，申请api接口key（AK），https://lbs.amap.com/?ref=http%3A%2F%2Flbs.amap.com%2Fdev%2F
2.1 地点检索poi接口 地点搜索服务2.0是一类Web API接口服务；服务提供多种场景的地点搜索能力，包括关键字搜索、周边搜索、多边形区域搜索、ID搜索。可通过文本关键字搜索地点信息，文本可以是结构化地址，例如：北京市朝阳区望京阜荣街10号；也可以是POI名称，输出格式为火星坐标系，例如：首开广场；
url格式：（参数间使用‘&amp;’符号连接）
https://restapi.amap.com/v5/place/text?parameters
参数详见：
https://lbs.amap.com/api/webservice/guide/api/newpoisearch
2.2 地理（逆）编码 结构化地址的定义： 首先，地址肯定是一串字符，内含国家、省份、城市、区县、城镇、乡村、街道、门牌号码、屋邨、大厦等建筑物名称。按照由大区域名称到小区域名称组合在一起的字符。一个有效的地址应该是独一无二的。注意：针对大陆、港、澳地区的地理编码转换时可以将国家信息选择性的忽略，但省、市、城镇等级别的地址构成是不能忽略的。暂时不支持返回台湾省的详细地址信息，输出不会出现大范围偏移现象，输出格式为火星坐标系。
结构化地址举例：北京市朝阳区阜通东大街6号
转换后经纬度：116.480881,39.989410
url格式：
https://restapi.amap.com/v3/geocode/geo?parameters
参数详见：
https://lbs.amap.com/api/webservice/guide/api/georegeo
3. 百度/火星坐标系转WGS84坐标系 详见作者：https://blog.csdn.net/yzyssg1/article/details/76120617
4. 参考代码 以下范例为使用百度地理编码接口批量获取地点坐标
# Editor: Jason Huang # 输入地理名称检索WGS84坐标` # 导入csv文件，有且仅有首列保存地理位置描述，去除表头` import requests import json import math``` pi = 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3403198dcb18d0328b7ece29b007c6c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8479652b8301a4a69d92d8187f8bcdb1/" rel="bookmark">
			问题记录--Win11中文家庭版利用VMware安装虚拟机linux系统Ubuntu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1--前言 最近更换了新电脑，预装了正版中文家庭版的Windows11系统，由于学业的需要，需要安装虚拟机linux系统。在安装过程中，涌现了诸多问题，本文旨在汇总本人遇到的所有问题及其解决方法。
2--VMware和Ubuntu版本的选择 最初，本人使用了VMware14和Ubuntu18.04.1的版本，安装过程中出现了以下两个问题：
①VMware14启动虚拟机时，物理机自动重启；
②VMware Workstation 与 Device/Credential Guard 不兼容；
本人搜寻了网上各种解决方案，发现上述问题并没有得到有效解决，最终通过升级VMware的版本为Vmware16得以解决。Vmware16的下载地址如下：参考蓝白的回答
Ubuntu18.04.1版本的下载可通过微信搜索软件安装家园公众号，回复linux即可获得下载地址。
3--针对Win11中文家庭版的问题 如果利用VMware16无法成功安装Ubuntu系统，依然出现上面两个问题，则采用以下方案解决。
3-1--VMware打开虚拟机自动重启的问题 针对虚拟机自动重启的问题，可以参考这个链接勾选虚拟机平台的选项来解决。
3-2--版本不兼容的问题 针对版本不兼容的问题，即VMware Workstation 与 Device/Credential Guard 不兼容，可通过以下两个链接解决：参考链接1和参考链接2
依照上述两个链接，会出现以下两个问题，这也是Win中文家庭版的问题：
①家庭版系统没有Hyper-V这个选项；
②家庭版系统没有gpedit.msc这个文件；
③gpedit.msc没有Device Guard这个选项；
针对第①个问题，可参考无尘落得清自在的回答，进行解决。
针对第②个问题，可参考度支的回答，进行解决。
针对第③个问题，可参考链接评论区的回答，但本人测试发现并不能解决。
4--总结 本人使用上述方法最终成功在win11家庭中文版系统中安装了Ubuntu系统，最核心的操作是升级VMware软件的版本为WMware16，用于解决版本冲突的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23a8094000a9861467d5dcdb868e8d9a/" rel="bookmark">
			git clone的时候遭遇fatal: early EOF fatal: index-pack failed解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git clone的时候遭遇fatal: early EOF fatal: index-pack failed解决办法 一般这种情况都是因为项目分支过多，导致你要下载的东西太多，从而引起这个问题。
引起这个问题的根源是文件过多，所以我们可以分批次下载文件，先下载一部分，再下载剩下的。以下就是我的解决方案：
首先关闭 core.compression
git config --global core.compression 0
然后使用depth这个指令来下载最近一次提交
git clone --depth 1 url
然后获取完整库
git fetch --unshallow
最后pull一下查看状态，问题解决
git pull --all
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd26a05a8218476904bdacc47d8004d6/" rel="bookmark">
			西南交通大学高级语言程序设计(SCAI000812)第3次实验报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景描述：
身为大一新生的我，面对这样一次的实践报告，本来是想趁着网上冲浪的时候顺手解决掉，但是让我气愤的是，居然有学长把这个作业写了一半并且发在了csdn上付费下载，我本人咽不下这口气，所以自己写了这份报告，并且决定免费开源，拒绝恰烂钱的行为，帮助后来的同学。
题目描述：
1.从键盘输入打印行数n，打印如下所示杨辉三角形到屏幕上和字符文件a.txt中。
n=5时的图形是
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
输出的每个整数的格式是%4d。
要求实验报告中描述杨辉三角形的计算与生成算法。
2. 在字符文件b.txt中录入n个整数，录入整数的分隔符为空格、换行或TAB。若n=5，则b.txt的一种正确格式为
5
9 12 -15
30 -7
即b.txt的第一个数为n，后面是n个整数。
编写程序，从文件b.txt读出n值，建立长度为n的动态1维整型数组，然后继续从文件b.txt读入n个整数存于该数组，进行由小到大排序，最后将排序结果输出到字符文件c.txt中。
要求的输出格式是每个整数%6d，每输出10个整数换一行。
实验报告中要求给出该程序的流程图。
3. 从键盘输入一个字符文件名，以及一个英文字符串，将该文件中的该英文字符串中的小写英文字母变成大写。
示例：字符文件内容如下：
We are students. All the students study very hard.
So, these students are outstanding students.
输入的字符串为students
则程序运行结束后，文件内容变为:
We are STUDENTS. All the STUDENTS study very hard.
So, these STUDENTS are outstanding STUDENTS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd26a05a8218476904bdacc47d8004d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09ddcdc661c149ea557d0eca18b53f48/" rel="bookmark">
			nginx &#43; lua 请求转发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一次
公众号大量同一时间发送模板，微信回调公众号告诉后台是否发送成功，因为没有业务处理，直接返回的success，报错Event=Template Send Job Finish。
这时候，nginx写了个转发到lua脚本处理请求，期间也出现过各种问题来阻碍我，简直疯了。实测有效~
-- 将请求交给PHP处理 function return_declined() ngx.req.set_uri('/' .. ngx.var.uri .. '?' .. ngx.var.args, true); ngx.exit(ngx.DECLINED); end -- 读取请求体 ngx.req.read_body(); local content = ngx.req.get_body_data(); if (not content) then -- 如果请求体是空的, 不处理 return_declined(); end -- 如果含有TEMPLATESENDJOBFINISH字符串, 响应success local event = content:match('&lt;Event&gt;&lt;!%[CDATA%[(.*)]]&gt;&lt;/Event&gt;'); if (event == 'TEMPLATESENDJOBFINISH' or event == 'VIEW') then ngx.say('success'); ngx.exit(ngx.HTTP_OK); end -- 读取加密字符串 local encrypted = content:match('&lt;Encrypt&gt;&lt;!%[CDATA%[(.*)]]&gt;&lt;/Encrypt&gt;'); if (not encrypted) then -- 如果加密字符串是空的, 不处理 return_declined(); else -- base64解码 local _encrypted = ngx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09ddcdc661c149ea557d0eca18b53f48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b99d3d60ec7140548318733559b770a5/" rel="bookmark">
			unity 播放音频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.Video; public class PlayVoice : MonoBehaviour { AudioSource voicePlayer;//定义音频播放器 readonly float voiceVolumeValue = 0.5f;// 音量默认值 // Start is called before the first frame update void Start() { voicePlayer = transform.Find("GameObject").GetComponent&lt;AudioSource&gt;();//音频所挂物体“GameObject” PlayAudio("Silent Night");//“Silent Night”为导进音频的名字，然后利用PlayAudio播放 } void PlayAudio(string audioName) { AudioClip audio = (AudioClip)Resources.Load("Scenes/" + audioName, typeof(AudioClip));//"Scenes"为音频在工程中存放的位置 voicePlayer.clip = audio; //播放 } } 将此C#脚本挂在一个物体上即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cfe38a898eb3e0dd7f940b6db97803e/" rel="bookmark">
			【踩坑idea 2021.2.3】【Gradle】 Building with Lombok‘s @Slf4j and Intellij: Cannot find symbol log
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于idea 2020.3以上版本都带有lombok插件，用maven正常运行的项目，由于改用gradle7.3，导致报错Cannot find symbol log，排查lombok有问题，将注意事项记录一下，希望对大家有用。
import lombok.extern.slf4j.Slf4j; @Slf4j public class TestClass { public TestClass() { log.info("Hello!"); } } 第一步：使能 Annotation Processor，windows路径File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Compiler -&gt; Annotation Processor，mac路径Preferences-&gt; Build, Execution, Deployment -&gt; Compiler -&gt; Annotation Processor
第二步：在build.gradle中，增加 dependency
compileOnly 'org.projectlombok:lombok:1.18.22' annotationProcessor 'org.projectlombok:lombok:1.18.22' 如果在tests也有调用，需要添加下面注释
testCompileOnly 'org.projectlombok:lombok:1.18.12' testAnnotationProcessor 'org.projectlombok:lombok:1.18.12' 可以参考一下：
https://stackoverflow.com/questions/14866765/building-with-lomboks-slf4j-and-intellij-cannot-find-symbol-log https://developervisits.wordpress.com/2020/09/16/building-with-lomboks-slf4j-and-intellij-cannot-find-symbol-log/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a705ced61e2a4dd45ac007136d840375/" rel="bookmark">
			Dock避坑指南(一)：源服务器未能找到目标资源的表示或者是不愿公开一个已经存在的资源表示 Apache Tomcat | 端口是通的无法访问tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误描述 类型 状态报告
描述 源服务器未能找到目标资源的表示或者是不愿公开一个已经存在的资源表示。
Apache Tomcat/10.0.14
首先恭喜你，看到这个界面说明Tomcat是OK的，只是没有访问到自己想要的页面。
1.如果是在学习Docker的tomcat容器部署，出现上述错误，则是镜像本身的问题，换个镜像就可以了。
如果不想换镜像，通过#docker ps 获取你Tomcat容器的ID（复制ID）,然后再通过#docker exec -it Tomcat容器ID，这个命令，进入容器内部，#cd webapps，随意创建个文件夹web_demo,然后里面随意写一个index.html。然后再通过地址栏访问：http://192.168.31.191:8080/web_demo/index.html 此时自然是可以访问通的。 2.如果是在常规访问，出现的这个错误，那么道理是一样的，要进入你的部署目录检查你访问地址对应的工程目录，看一下webapps下面的工程是否部署成功。
该错误，本身说明Tomcat是通的，仅仅是你因为你访问的路径不对(后面缺失一些具体路径，比如忘记带工程名称了)，或者被访问的路径下缺失默认页面index.html或者index.jsp。
具体步骤 1.用标准流程停掉tomcat #docker ps 查看容器列表，然后根据容器ID移除 #docker stop 46ac1401f5b8 停掉服务后，再重新移除 #docker rm 46ac1401f5b8 如果容器正在运行会被要求先停掉服务 2.删除/移除指定版本的Tomcat镜像 docker rmi tomcat:latest 移除指定镜像 注：后面的latest是Tomcat镜像标签，用命令：docker images 可以获取（第二列）
3.重新下载镜像 docker pull tomcat:8.5.46-jdk8-openjdk 该版本镜像，可以访问到tomcat首页 4.宿主机8000重新关联容器中的Tomcat8080端口 docker run -p 8000:8080 -d tomcat:8.5.46-jdk8-openjdk 后台阻塞运行（如果不带-p，则前台窗口运行） 注：如果只安装了一个版本的Tomcat后面的标签（Tomcat版本） 可以不带
5.再次访问 http://192.168.31.191:8000
附注 既然能看到图像界面上的Tomcat版本号，说明很可能是tomcat本身的问题，比如是精简版，默认没有index.jsp（tomcat首页）。如果上述步骤没有界面，则要认真排查一下了
1.本地打开cmd窗口ping一下访问的ip ping 192.168.31.191
如果不能ping通，则要检查linux的ip配置问题了，可参考：ping不通，点击这里 2.如果能ping通，再telnet一下 telenet 192.168.31.191 8000 成功后是一个纯黑色的界面
如果端口没有通，页面则会直接有错误提示，此时就要检查防火墙等方面的问题了，要么让防火墙给此端口放行，要么关闭防火墙。 提示：如果Windows系统的cmd界面，无法识别telnet命令，请点击这里。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a705ced61e2a4dd45ac007136d840375/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/572d4447493c329ea46aa9d81323206a/" rel="bookmark">
			使用vue-cli搭建vue.js项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.安装nodejs2.创建项目 1.安装nodejs nodejs下载地址
左边是长期服务的，右边是当前版本的，本用户选择左边的
下载完成后安装，在cmd输入node -v 查看版本
然后再查看npm，在cmd输入npm -v查看版本
输入npm -g install npm 更新最新版本的npm
npm属于国外资源有时候下载包会失败或者很慢，可以选择下载cnpm国内镜像资源，输入指令 npm install -g cnpm –registry=http://registry.npm.taobao.org
可通过指令 cnpm -v 查看指令
可以安装webpack一款开源的前端打包工具，输入指令cnpm install webpack -g
通过指令webpack -v查看版本
然后就是安装vue的脚手架vue-cli，通过指令cnpm install vue-cli -g
查看版本vue -V
2.创建项目 创建一个vue项目
在本地目录下新建一个文件夹，在当前目录下cmd输入vue init webpack vuedemo（自己的项目名），过程输入y进行
创建完成后，在生成文件夹下cmd输入npm run dev
启动
前端一般使用vscode比较方便
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e2ba472c76d7c316b606452af8732e1/" rel="bookmark">
			minHash
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		寻找文本相似度Outline Shingling : 将文档转化成集合；
Minhashing : 将集合转化成较短签名，并保留集合间相似度；
Locality-sensitive hashing : 计算两两签名向量间的相似度。
Jaccard distance/similarity Jaccard(A, B)= |A ∩ B| / |A ∪ B|
在上述例子中，sim(A,B)=2/7。
Shingling A k-shingle (or k-gram) for a document is a sequence of k tokens that appears in the doc
(Tokens can be characters, words or something else, depending on the application)
直接举例子说明：
k=2,D1=abcab,那么2-shingles set:S(D1)={ab, bc, ca}
对于较长的shingle，可以将其hash.
For instance,to map 9-shingles to a bucket number of bucket in the range of 0-2^32-1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e2ba472c76d7c316b606452af8732e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a37cce4c63462cd64f51878ec95403f/" rel="bookmark">
			电脑桌面显示不全设置方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑屏幕上边显示不全说明屏幕的分辨率不是最佳。
调整电脑屏幕分辨率至最佳的步骤：
1.打开电脑的“开始”菜单，选择“控制面板”；
2.选择之后继续点击“外观和个性化”单击即可；
3.然后找到选项功能中的“调整分辨率”；
5.最后需要对自己的电脑进行识别和选择电脑分辨率，与此同时需要对电脑的分辨率检测，检测成功之后我们选择所需要的分辨率参数，点击确定就可以成功设置。
这个是你显示器的问题 和你的电脑系统什么的无关 你的显示器上面你找下 应该有几个按钮的。 那几个按钮就是设置显示器的东西。。 你自己摸索下 看下怎么设置就可以了。。或是看下显示器的说明说 是怎么设置的 ``因为每个显示器按你都不同。。所以具体的也没办法告诉你。
显示屏按钮，寻找OverScan设置，修改尝试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f1f59ff7defc6b34cb9d145b5608ebe/" rel="bookmark">
			Linux操作系统下的贪吃蛇小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习Linux操作系统，为了加深自己对于C语言的掌握和理解，这两天写了一个比较复杂的小游戏。贪吃蛇代码量大概有300行左右，基本上运用上了C语言的常见的知识点（指针，链表，结构体，函数封装与调用等），对于自己的C语言能力的加强和逻辑思考能力的提升有较大的帮助。
啰嗦的话不多说了，先上代码吧！
#include &lt;curses.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;pthread.h&gt; #define UP 0403 #define DOWN 0402 #define LEFT 0404 #define RIGHT 0405 #define TURN_UP 1 #define TURN_DOWN -1 #define TURN_RIGHT 2 #define TURN_LEFT -2 struct snake { int hang; int lie; struct snake *next; }; struct snake *head=NULL; struct snake *tail=NULL; struct snake food; int key; int turn; int now_turn; void Init_Curses() { initscr(); keypad(stdscr,1); noecho(); } void Turn_Statu(int now_turn) { if(abs(now_turn)!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f1f59ff7defc6b34cb9d145b5608ebe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a22a524f5807870ac43643c2ad7be8a/" rel="bookmark">
			简单好用的Java虚拟机监控工具——Jvmm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多童鞋是不是想在程序运行时获取虚拟机信息？甚至采样获取火焰图？用jdk自带的jstat、jps使用总感觉不方便而且不太好自定义，使用Arthas功能倒是很全但是太重了，可能用不到那么多，而且也没办法在自己代码中调用这些接口，今天推荐一个工具：Jvmm
github地址：https://github.com/tzfun/jvmm
gitee地址：https://gitee.com/tzfun/jvmm
这个工具提供了三种方式使用：API调用、Server服务、命令行客户端。
一、API方式 先说API调用吧，想要在自己的程序中使用它只需要引入core包
&lt;dependency&gt; &lt;groupId&gt;io.github.tzfun.jvmm&lt;/groupId&gt; &lt;artifactId&gt;jvmm-core&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt; &lt;/dependency&gt; 然后在自己的代码中就可以直接获取内存、CPU负载、线程栈信息等，甚至你可以用他的JvmmProfiler直接生成出火焰图
public class ApiCallDemo { public static void main(String[] args) { // The jvmm collector can obtain the following information: // Operating system: basic information, Memory, CPU, Process information // JVM: Memory, GC, Class, Thread, Compilation information JvmmCollector collector = JvmmFactory.getCollector(); MemoryInfo memory = collector.getMemory(); List&lt;MemoryManagerInfo&gt; memoryManager = collector.getMemoryManager(); List&lt;MemoryPoolInfo&gt; memoryPool = collector.getMemoryPool(); SystemStaticInfo systemStatic = collector.getSystemStatic(); SystemDynamicInfo systemDynamic = collector.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a22a524f5807870ac43643c2ad7be8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df73a182f9cab52c82272a8610540e39/" rel="bookmark">
			【Dash搭建可视化网站】项目6：利用Dash callback高级特性实现货币汇率计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手动反爬虫，禁止转载：原博地址 https://blog.csdn.net/lys_828/article/details/122088723（CSDN博主：Be_melting）
知识梳理不易，请尊重劳动成果，文章仅发布在CSDN网站上，在其他网站看到该博文均属于未经作者授权的恶意爬取信息 项目6：利用Dash callback高级特性实现货币汇率计算 之前的项目3,4,5使用的callback都是一对一的数据流向关系，项目6要实现的就是一个输入多个输出的关系，并且尝试进行网页的美化操作。以一个货币汇率计算的小工具为例：用户输入一个值，自动转换出其它三个国家/地区的货币金额。
6.1 基础功能实现 [1] 新建一个py文件，搭建Dash框架，代码如下。xxx中就是待完善的部分。
import dash from dash import html from dash import dcc from dash import dependencies from dash.dependencies import Output,Input app = dash.Dash() app.layout = html.Div(children=[ xxx ]) app.run_server(debug=True) [2] 构建输入和输出流向实体。一个输入文本框，三个输出内容。
app.layout = html.Div(children=[ dcc.Input(value=0,id='ipt'), html.Div(['JPY',html.Span('---',id='JPY')]), html.Div(['USD',html.Span('---',id='USD')]), html.Div(['GBP',html.Span('---',id='GBP')]) ]) [3] 简化代码。对于三个输出的内容，发现存在着大量重复，最直接的反应就是进行函数的封装，代码如下。
def item(name): return html.Div([name,html.Span('---',id=name)]) app.layout = html.Div(children=[ dcc.Input(value=0,id='ipt'), item('JPY'), item('USD'), item('GBP') ]) [4] 构建数据输入和输出处理规则。注意是一对三，callback中就是对应的为一个输入三个输出，此外还要留意的就是赋值的参数。即便一个输入，对应的参数赋值是给inputs，但是就是有多个输出，赋值对应的参数也只是output。输入和输出都是放在列表中。
@app.callback( output = [Output(),Output(),Output()], inputs = [Input()] ) def rule(rmb): return ( '', '', '' ) 接着完善上述代码中要填写的信息，流向实体中输入的id信息和传递的值分别是ipt和value，而对应输出的id信息和传递的值分别是各种货币名称及children（Div中返回的基本就是children），故代码完善如下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df73a182f9cab52c82272a8610540e39/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/166/">«</a>
	<span class="pagination__item pagination__item--current">167/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/168/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>