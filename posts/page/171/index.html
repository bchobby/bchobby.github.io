<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/867c80a3081446d0e8da093080b48852/" rel="bookmark">
			04-Nacos服务注册中心应用实践（记录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
注册中心简介
背景分析
Nacos概述
构建Nacos服务
准备工作
下载与安装
初始化配置
服务启动与访问
服务注册与调用入门（重点）
业务描述
生产者服务创建及注册
消费者服务发现及调用
小节面试分析
服务负载均衡设计及实现（重点）
业务描述
LoadBalancerClient应用
@LoadBalanced
Ribbon负载均衡策略(了解)
小节面试分析
基于Feign的远程服务调用（重点）
背景分析
Feign是什么
Feign应用实践（掌握）
Feign配置进阶实践
Feign 调用过程分析（了解）
小节面试分析
总结(Summary)
重难点分析
FAQ分析
Bug分析
注册中心简介 背景分析 在微服务中，首先需要面对的问题就是如何查找服务(软件即服务)，其次,就是如何在不同的服务之间进行通信？如何更好更方便的管理应用中的每一个服务，如何建立各个服务之间联系的纽带，由此注册中心诞生（例如淘宝网卖家提供服务，买家调用服务）。
市面上常用注册中心有Zookeeper(雅虎Apache),Eureka(Netfix),Nacos(Alibaba),Consul(Google),那他们分别都有什么特点，我们如何进行选型呢？我们主要从社区活跃度,稳定性,功能,性能等方面进行考虑即可.本次微服务的学习,我们选择Nacos,它很好的支持了阿里的双11活动,不仅可以做注册中心，还可以作为配置中心，稳定性和性能都很好。
Nacos概述 Nacos（DynamicNaming and Configuration Service）是一个应用于服务注册与发现、配置管理的平台。它孵化于阿里巴巴，成长于十年双十一的洪峰考验，沉淀了简单易用、稳定可靠、性能卓越的核心竞争力。其官网地址如下：
https://nacos.io/zh-cn/docs/quick-start.html 构建Nacos服务 准备工作 第一：确保你电脑已配置JAVA_HOME环境变量(Nacos启动时需要)，例如：
第二：确保你的MySQL版本为5.7以上（MariaDB10.5以上)，例如
下载与安装 第一步：Nacos下载,可在浏览器直接输入如下地址：
Releases · alibaba/nacos · GitHuban easy-to-use dynamic service discovery, configuration and service management platform for building cloud native applications. - Releases · alibaba/nacoshttps://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/867c80a3081446d0e8da093080b48852/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/702185143bd3e71fa57ea1facdff5bc1/" rel="bookmark">
			vue, js 传递自身DOM元素，并添加class名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue, js 传递自身DOM元素，并添加class名称 element.classList.add('yourClass') 具体VUE示例如下：
1： vue 元素传递了本身
&lt;p class="answer" @click.once="chooseFn($event.target)"&gt;{{ item.item1 }}&lt;/p&gt; 2： vue 方法处理该元素，并添加 class名称
chooseFn: function (ele) { ele.classList.add('errorAnswer') } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6853d78dbfdf196b09850da7c04cd016/" rel="bookmark">
			hadoop fs默认操作路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hadoop fs命令默认操作文件路径为：/[主目录]/[用户名]。
主目录的默认路径为/user， 由配置项dfs.user.home.dir.prefix决定，存在于hdfs-site.xml文件中；用户名（非kerberos的情况下），则是根据环境变量HADOOP_USER_NAME、HADOOP_USER_NAME决定，默认为linux当前用户名。
hadoop@ubuntu16:~$ hadoop fs -ls / Found 3 items drwxr-xr-x - hadoop supergroup 0 2021-11-15 15:06 /hdfstest drwxr-xr-x - hadoop supergroup 0 2021-11-15 11:00 /mr_demo drwxr-xr-x - hadoop supergroup 0 2021-10-18 14:19 /user hadoop@ubuntu16:~$ hadoop fs -ls . Found 1 items drwxr-xr-x - hadoop supergroup 0 2021-10-18 14:40 input hadoop@ubuntu16:~$ hadoop fs -ls /user/hadoop Found 1 items drwxr-xr-x - hadoop supergroup 0 2021-10-18 14:40 /user/hadoop/input hadoop@ubuntu16:~$ HDFS查看文件命令 hadoop fs -ls .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6853d78dbfdf196b09850da7c04cd016/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bceee4307ea62ea93b66f74295e2f4dc/" rel="bookmark">
			详解Hive on Spark配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive on Spark配置 Hive引擎默认的是MapReduce，就是没执行一个Hive语句，其实都是运行了一个MR程序，都知道的，MR虽好，但是慢呢。所以在时代的驱使下，就出现了把Hive的引擎更换的需要，通常Hive的引擎还有tez、Spark。我们经常听到Hive on Spark和Spark on Hive，不明所以的小伙伴还会以为这两个是倒装句，其实不然，Hive on Spark 和 Spark on Hive有着很大的区别
Hive on Spark：直译就是把Hive 放到 Spark上，意思就是把Hive的引擎改为Spark，Hive既作为存储元数据又负责SQL的解析优化，语法是HQL语法，执行引擎变成了Spark，Spark负责采用RDD执行
Spark on Hive：直译就是把Spark放到Hive上，就是将Spark处理的数据放在Hive上，Hive只作为存储元数据，Spark负责SQL解析优化，语法是Spark SQL语法，Spark负责采用RDD执行
Hive on SparkSpark on Hive语法HQLSpark SQL引擎SparkSpark存储HiveHive Hive on Spark的配置 兼容性说明
官网下载之后的Hive3.1.2和Spark3.0.0是不兼容的，Hive3.1.2支持的Spark版本是2.4.5，所以需要重新编译Hive才能和Spark3.0.0兼容。或者选择Spark2.4.5版本，当然了，选择Spark2.4.5是不可能的，虽然省事，但是我们都不怕麻烦
编译过程也很简单，是的，也很简单简单简单，只需要去官网下载Hive3.1.2的源码，然后再pom文件中将Spark的引用版本改为3.0.0就可以，如果编译通过，直接打成jar包，是不是很简单。但是如果不通过，那就根据报错信息修改，直到不报错，然后达成jar包，确实很简单吧-~-
配置 上传解压saprk-3.0.0-hadoop-bin-3.2.tgz，具体tar包啥名字记不清了，大概长这个样子吧
配置SPARK_HOME环境变量
在hive的配置文件目录下新建spark的配置文件，添加以下内容
spark.master yarn spark.eventLog.enabled true spark.eventLog.dir hdfs://hadoop102:8020/spark-history spark.executor.memory 1g spark.driver.memory	1g 根据配置文件设置的历史目录，在hdfs上新建相应的目录
hadoop fs -mkdir /spark-history 向HDFS上传Spark纯净版jar包
由于Spark3.0.0非纯净版默认支持的是hive2.3.7版本，直接使用会和安装的Hive3.1.2出现兼容性问题。所以采用Spark纯净版jar包，不包含hadoop和hive相关依赖，避免冲突。
Hive任务最终由Spark来执行，Spark任务资源分配由Yarn来调度，该任务有可能被分配到集群的任何一个节点。所以需要将Spark的依赖上传到HDFS集群路径，这样集群中任何一个节点都能获取到
上传并解压spark-3.0.0-bin-without-hadoop.tgz
tar -zxvf /opt/software/spark-3.0.0-bin-without-hadoop.tgz 上传Spark纯净版jar包到HDFS
hadoop fs -mkdir /spark-jars hadoop fs -put spark-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bceee4307ea62ea93b66f74295e2f4dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b90dbdbefac0c564b3a8fc9443a1317b/" rel="bookmark">
			springBoot集成dynamic-datasource实现多数据源的读写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在开发项目的时候，会遇到一些问题。比如在某个数据库实现读数据，某个数据库实现写数据。所以这个时候就需要使用多数据源的读写。所以使用dynamic-datasource来实现。接下来我们就介绍下如何使用。
1：引入jar包
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; 2：在application.properties中添加相应的数据源
下面是比较简单的配置，复杂的可以参考参考链接。
### datasource begin ### ##设置默认的数据源或者数据源组，默认值为master spring.datasource.dynamic.primary=master #严格匹配数据源,默认false. true未匹配到指定数据源时抛异常,false使用默认数据源 spring.datasource.dynamic.strict=false ###主库设置 spring.datasource.dynamic.datasource.master.url=jdbc:mysql://localhost:3306/mfwow?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=UTC spring.datasource.dynamic.datasource.master.username=root spring.datasource.dynamic.datasource.master.password= spring.datasource.dynamic.datasource.master.driver-class-name=com.mysql.jdbc.Driver ###从库设置 spring.datasource.dynamic.datasource.slave.url=jdbc:mysql://172.31.3.226:3306/Knowdege?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false spring.datasource.dynamic.datasource.slave.username=root spring.datasource.dynamic.datasource.slave.password=YydhTest2019!226 spring.datasource.dynamic.datasource.slave.driver-class-name=com.mysql.jdbc.Driver ### datasource end ### 3：在启动类@SpringBootApplication注解中，添加排除原生Druid的配置类。
@SpringBootApplication(exclude = DruidDataSourceAutoConfigure.class) public class Bootstrap { private static Logger log= LoggerFactory.getLogger(Bootstrap.class); public static void main(String[] args)throws Exception { ConfigurableApplicationContext application = SpringApplication.run(Bootstrap.class, args); Environment env = application.getEnvironment(); String ip = InetAddress.getLocalHost().getHostAddress(); String port = env.getProperty("server.port"); String path = env.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b90dbdbefac0c564b3a8fc9443a1317b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76f2d9b1677c60ff93dc44d2d1e6fed8/" rel="bookmark">
			Linux中文件压缩和归档类命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件压缩和归档类命令 1》gzip、gunzip使命令用来压缩、解压缩文件，文件压缩类命令还有bzip2,bunzip2等。 语法格式：
gzip/gunzip	[参数选项]	[文件] 注意的是：如果是压缩和解压是文件夹时必须要加入是“-r”参数，进行递归压缩和解压，否则会报错。 实例： 1.gzip压缩当前目录下的1.txt文件 gzip 1.txt 2.gzip压缩当前目录下的B文件夹 gzip -r B [myvm168@localhost ~]$ ls 1.txt A Desktop Documents Downloads Music Pictures Public Templates test touch Videos [myvm168@localhost ~]$ gzip 1.txt --对1.txt进行压缩 [myvm168@localhost ~]$ gzip A	--报错的原因是文件夹压缩要必须加入参数‘-r’进行递归压缩 gzip: A is a directory -- ignored [myvm168@localhost ~]$ gzip -r A	--对A文件夹进行压缩 [myvm168@localhost ~]$ ls 1.txt.gz A Desktop Documents Downloads Music Pictures Public Templates test touch Videos [myvm168@localhost ~]$ ll A 总用量 0 [myvm168@localhost ~]$ zip程序是用来压缩文件，而gunzip程序是用来还原gzip压缩的文件的，zcat程序用来显示gzip压缩的文件，同时压缩和解压文件时原始文件，会被删除
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76f2d9b1677c60ff93dc44d2d1e6fed8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/747343ad714cad3e01b34bae96d251ff/" rel="bookmark">
			Error: connect ECONNREFUSED 127.0.0.1:6379 at TCPConnectWrap.afterConnect [as oncomplete]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Error: connect ECONNREFUSED 127.0.0.1:6379 at TCPConnectWrap.afterConnect [as oncomplete] (node:net:1161:16) redis数据库启动时，报错如下图：
解决 需要执行命令如下（Ubuntu）：
sudo apt-get install redis-server 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49cfd6e23771c3a712ba8826d76a4949/" rel="bookmark">
			关于举办“2022年（第15届）中国大学生计算机设计大赛”通知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年（第15届）大赛
内容分类、参赛要求、承办院校与决赛时间 一、大赛说明 本赛事启筹于2007年，始创于2008年，已经举办了14届68场赛事。目前，大赛是全国普通高校大学生竞赛排行榜榜单的赛事之一。大赛国赛的参赛对象，是中国大陆高等院校中所有专业的当年在校本科生和来华留学生，重点是激发学生学习计算机知识和技能的兴趣和潜能，提高学生运用信息技术解决实际问题的综合能力，以赛促学，以赛促教，以赛促创。参赛作品的指导教师是在高校担任中国本科生或来华留学生教学任务的教师。
大赛以三级竞赛形式开展，校级初赛——省级复赛——国家级决赛（简称“国赛”），国赛只接受省级赛（含省市赛、省级跨省区域赛和省级直报赛区）上推的参赛作品。校赛、省级赛可自行、独立组织。参赛院校应安排有关职能部门负责参赛作品的组织、纪律监督与内容审核等工作，保证本校竞赛的规范性和公正性，并由该学校相关部门签发参加大赛报名的文件。
1. 2022年（第15届）大赛作品共分15大类（组），具体包括：
（1） 软件应用与开发。
（2） 微课与教学辅助。
（3） 物联网应用。
（4） 大数据应用。
（5） 人工智能应用。
（6） 信息可视化设计。
（7） 数媒静态设计（普通组，证书上不出现“普通组”三字，下同）。
（8） 数媒静态设计专业组。
（9） 数媒动漫与短片（普通组）。
（10） 数媒动漫与短片专业组。
（11） 数媒游戏与交互设计（普通组）。
（12） 数媒游戏与交互设计专业组。
（13） 计算机音乐创作（普通组）。
（14） 计算机音乐创作专业组。
（15） 国际生“学汉语，写汉字”赛道。
2．数媒各大类参赛作品参赛时，按普通组与专业组分别进行。
界定数媒类作品专业组的专业清单（参考教育部2020年发布新专业目录），具体包括：
（1）教育学类：040105 艺术教育
（2）新闻传播学类：050302 广播电视学、050303广告学、050306T网络与新媒体、050307T数字出版
（3）机械类：080205工业设计
（4）计算机类：080906 数字媒体技术、080912T 新媒体技术、080913T电影制作、080916T虚拟现实技术
（5）建筑类：082801 建筑学、082802 城乡规划、082803 风景园林、082805T人居环境科学与技术、082806T城市设计
（6）林学类：090502 园林
（7）戏剧与影视学类： 130303 电影学、130305 广播电视编导、130307 戏剧影视美术设计、130310 动画、130311T 影视摄影与制作、130312T 影视技术
（8）美术学类：130401 美术学、 130402 绘画、130403雕塑、130404摄影、130405T 书法学、130406T 中国画、130408TK 跨媒体艺术、130410T 漫画
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49cfd6e23771c3a712ba8826d76a4949/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4714db670509781a242f0e26f7a6028f/" rel="bookmark">
			Oracle数据库删除重复数据(保留一条)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如何在oracle数据库中删除重复数据？
表：DWGCHF_ZJB 判断是否重复标识：检验批编号首先进行检验批编号进行分组，筛选出cout（检验批编号）&gt;1的数据然后根据函数最小值min（rowid）进行检验批编号分组，并且用count（*）&gt;1去反选，把两个条件结合起来就可以删除重复的数据，且保留重复数据的源数据。 delete from DWGCHF_ZJB where 检验批编号 in (select 检验批编号 from DWGCHF_ZJB group by 检验批编号 having count(检验批编号)&gt;1 ) and rowid not in (select min(rowid) from DWGCHF_ZJB group by 检验批编号 having count(*)&gt; 1); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/783e2502a993803cb04e7264b459863f/" rel="bookmark">
			为什么modelsim添加altera_mf库文件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看ip文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1176ec3fe708e1f6e8d3079de566c112/" rel="bookmark">
			Provide 和 Inject 的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 父子组件传参可以通过props和emit来实现，但是当组件的层次结构比较深时，props和emit就没什么作用了。vue为了解决这个提出了Provide / Inject，知道这个东西，但是一直没用过，最近碰到了一个问题，踩了一些坑，在这里记录一下
备注：
我安装的是vue3.x，v-model用的是3.x的语法。
2.x和3.x用法一致，我这里是用2.x写的
通用知识 基本用法
provide 选项应该是：一个对象或返回一个对象的函数
inject 选项应该是：一个字符串数组，或 一个对象，对象的 [key] 是本地的绑定名
provide 和 inject 绑定并不是可响应的。这是刻意为之的。
代码执行顺序
data-&gt;provide-&gt;created-&gt;mounted
基本代码
主要使用grandpa和grandson这两个组件，son在这里充当一个层级
//grandpa.vue &lt;template&gt; &lt;div&gt; &lt;h3 style="margin-bottom: 20px"&gt;爷爷组件&lt;/h3&gt; &lt;el-button type="primary" @click="lookDetail"&gt;查看&lt;/el-button&gt; &lt;!-- 儿子组件 --&gt; &lt;son v-model:visible="openDialog"&gt;&lt;/son&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Son from "./son.vue"; export default { components: { Son }, data() { return { message: "aa", openDialog: false, }; }, methods: { lookDetail() { this.openDialog = true; }, }, }; &lt;/script&gt; //son.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1176ec3fe708e1f6e8d3079de566c112/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/581088642ab3f570c2acbaeb683a16d1/" rel="bookmark">
			vue-router如何判断是从哪个路径跳转过来的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 日常项目中经常会出现这种效果 点击添加和编辑 跳转至 编辑页活添加页后，通过保存 el-tab-pane这个组件还是要指向原来的地方
方法一、通过beforeRouteEnter实现 但是要注意哦 beforeRouteEnter是不能访问this的
解决方法如下
beforeRouteEnter(to, from, next) { next(vm =&gt; { if (from.path == "/channel/index/addAdvert") vm.activeName = "fourth"; }); }, 方法二：通过watch监听实现 watch : { '$route' (to, from) { // from 对象中要 router 来源信息. // do your want } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1455eaed95d5566c265114295bd05aa3/" rel="bookmark">
			经典计算哈希值得函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经典计算哈希值得函数
#define BITS_IN_int (sizeof(int)*CHAR_BIT)
#define THREE_QUARTERS ((int)((BITS_IN_int 3)/4))
#define ONE_EIGHTH ((int)(BITS_IN_int/8))
constexpr unsigned int HIGH_BITS = (~((unsigned int)(~0) &gt;&gt; ONE_EIGHTH));
unsigned int HashPJW(const char datum)
{
unsigned int hash_value, i;
for (hash_value = 0; *datum; ++datum)
{
hash_value = (hash_value &lt;&lt; ONE_EIGHTH) + *datum;
if ((i = hash_value &amp; HIGH_BITS) != 0)
hash_value = (hash_value ^ (i &gt;&gt; THREE_QUARTERS)) &amp; ~HIGH_BITS;
}
return hash_value;
}
unsigned long ElfHash(const unsigned char *name)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1455eaed95d5566c265114295bd05aa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b00584195b3172160d71d839c0634d2/" rel="bookmark">
			JAVA中堆，栈，方法区的简单理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.堆（heap） 在JVM中只有一个堆，在虚拟机开启时创建，所有的线程都共用这一个堆。类的对象会储存在堆内存中，而new对象的引用地址会储存在stack栈中。堆中只存储对象本身和数组。
2.栈（stack） Java栈与堆不同每一个线程都有一个stack，栈的区域非常小，大概只有1M左右，但是存储速度非常快，所以我们把快速执行的任务存储在stack。栈中存储的就是基本数据类型和对象的引用（地址，而不是实例！）。
3.方法区（method） 方法区（method）又叫静态区，这里主要存储的就是类（class）、静态方法、静态变量、常量以及成员方法。我们可以发现在方法区中存储的都是整个程序中唯一存在的元素，所以方法区与堆一样被所有线程共享。我们常说的常量池也是方法区的一部分。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495eae3027489fac3d93985bc52c6298/" rel="bookmark">
			Solidworks学习笔记-链接Solidworks
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文用的是SolidWokrs2019 和 VS2019
1)创建窗口程序
2)添加引用
3）创建自己的功能类 并编写代码
Sld4File.cs
添加命名空间
using SolidWorks.Interop.sldworks; //接口对象 using SolidWorks.Interop.swconst; //枚举对象 编写功能函数：
这里注意：
CommandInProgress：通知 SOLIDWORKS 进程外应用程序将进行一系列 API 调用来提高进程外应用程序的性能。
EnableBackgroundProcessing：获取或设置是否开启后台处理。
using SolidWorks.Interop.sldworks; //接口对象 using SolidWorks.Interop.swconst; //枚举对象 using System; //using SldExFunc.Model; //添加 namespace SldExFunc.Model { public static class Sld4File { // 判断进程是够存在，0无，1有 private static bool GetProc(string processName) { System.Diagnostics.Process myProcess = new System.Diagnostics.Process();//得到所有打开的进程 try { foreach (System.Diagnostics.Process thisProcess in System.Diagnostics.Process.GetProcessesByName(processName)) { return true; } } catch (Exception e) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/495eae3027489fac3d93985bc52c6298/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9252612855ffce76f33366dadf61ea1/" rel="bookmark">
			mui 上拉刷新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.引入mui.min.css，mui.min.js。
2.创建html需要刷新的html代码段。
3.页数和每页的条数限制
创建自己需要刷新的分页的html代码段 参考作者代码段 &lt;div id="pullrefresh" class="mui-scroll-wrapper"&gt; &lt;div class="mui-scroll"&gt; &lt;div id="showlist" class="showlist"&gt; //showlist放自己需要刷新的列表 //例如 //&lt;li&gt;1&lt;/li&gt; //&lt;li&gt;1&lt;/li&gt; //&lt;li&gt;1&lt;/li&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; var pageNo = 0;//定义一个页数变量 var id = 0;//好像会用到，我也记不清楚了。。。(ˉ▽￣～) mui.init({ pullRefresh: {//定义一个上拉刷新，这个容器就是上面html定义的pullrefresh container: '#pullrefresh', up: { auto: true, contentrefresh: '正在加载...', callback: userPullupRefresh } } }); //好像类似与监听的事件，只要发现有向上拉就会执行这个方法，pageNo加一，执行下面的showlist方法 function userPullupRefresh() { setTimeout(function() { pageNo++; console.log(pageNo); showlist(); }, 500);//500的意思是毫秒 }; //这个方法用到了公司的内部接口，我就不便展示了，理解逻辑就好(ˉ▽￣～) function showlist() { $.ajax({ type: 'POST', url: '这是一个公司的内部接口地址，（一个热搜话题）', data: { 接口页数参数: pageNo, 接口页数条数限制参数: 16,//一页有16条 }, //调用接口如果成功返回，就会有返回值，这个返回值是一个数组，res数组 success: function(res) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9252612855ffce76f33366dadf61ea1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25631c269aafab0ed0846813089f0859/" rel="bookmark">
			第一章 操作系统基本知识点及概述（初步了解操作系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.操作系统的软件硬件构成和层次 1.1一台电脑是如何诞生的呢？ Step1: 厂家把各个硬件组装为一台裸机
Step2: 给这台电脑安装操作系统（核心）
Step3: 用户安装应用程序等软件（例如 微信 等）
1.2系统的软硬件 ？ 实现应用软件和硬件设备的连接
2.操作系统的基本概念 2.1操作系统的概念：（Operating System OS) 他是一些程序模块的集合 -----他们能合理的组织、调度计算机的工作与资源的分配，合理 的组织、调度计算机的工作与资源的分配，为用户和其它软件提供方便的接口和环境
2.2图示说明 3.操作系统的特征和分类 3.1 并发性：指计算机系统同时运行多个程序；可以体现在用户程序之间，用户程序和操作 系统之间（在微观上，就是顺序执行几个程序，时间间隔很小，宏观就是并发）
3.2共享性：多个用户程序在操作系统的控制下，共用系统的各种资源
3.3随机性：操作系统是在一个随机的硬件环境中都能够运行的，强调操作系统的设计要考 虑各种可能性，实现稳定，安全，高效，可靠的达到程序并发和共享
3.4操作系统的发展和分类
3.5 对各种操作系统的解释 及其优缺点
3.5.1手工操作阶段：人工使用纸带机，输入速度慢，计算机速度快，导致了资源利用很低
3.5.2批处理阶段：一批作业全部传入计算机 由一段的监控程序来控制执行 称为批处理
单道批处理：一次只能处理一个程序，其他程序后面排队 多道批处理：一次可以处理多道程序，并发执行，共享资源，提高了资源利用
缺点：没有人机交互用户提交作业就只能一直等待，中间不能控制 输入和程序执行失败
3.5.3分时操作系统：计算机以时间片为单位 轮流为各个作业服务，可以人机交互
优点：解决人机交互，允许多个作业 / 用户同时使用，多个用户相对计算机是独立的
缺点：不能优先处理 紧急的任务 因为每个作业都是公平的
3.5.4实时操作系统 能够优先响应紧急任务，及时性和可靠性
3.5.6 网络操作系统： 通过网络实现各种资源的共享和各台计算机之间的通信
3.5.7分布式操作系统：多个连接起来的计算机，并行，协同处理这个任务
4.操作系统的功能（后面章节具体详解） 4.1 作为计算机系统资源的管理者 4.1.1 处理器（CPU）管理
在多道程序环境下，cpu的分配和运行都以进程（或线程）为基本单位，因此对cpu的管理 可理解为对进程的管理。进程管理的主要功能包括进程控制、进程同步、进程通信、死 锁处理、处理机调度等
4.1.2 存储器管理 为多道程序的运行提供良好的环境，方便用户使用及提高内存的利用 率，主要包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。
4.1.3 文件管理 算机中所有的信息都是以文件的形式存在的，操作系统中负责文件的管 理的部分称 为文件系统，文件管理包括文件存储空间的管理、目录管理及文件读写管理和保护
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25631c269aafab0ed0846813089f0859/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fe081dcd2340d8afa9886185febdb9d/" rel="bookmark">
			封装el-pagination（记录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 封装
&lt;template&gt; &lt;el-pagination class="pagination" background layout="total, prev, pager, next" :current-page.sync="curPage" :total="total" :page-size="pageSize" @current-change="setCurrentPage" &gt;&lt;/el-pagination&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'pagination', props: { total: { type: Number, default: 0 }, pageSize: { type: Number, default: 10 }, pageNum: { type: Number, default: 1 } }, data() { return { curPage: this.pageNum }; }, mounted() { console.log(this.curPage); }, methods: { /** * 跳转分页 * @curPage 跳转页码 */ setCurrentPage(curPage) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fe081dcd2340d8afa9886185febdb9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac9ac1de5eeea846931f372b516e5b3e/" rel="bookmark">
			关于DBCO-PEG-NH2， DBCO-PEG-Amine 的反应原理介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		英文名称：DBCO-PEG-NH2
DBCO-PEG-Amine DibenzocyclooctynePEG-Amine 中文名称：二苯并环辛烯-聚乙二醇-氨基 二苯并环辛烯PEG氨基 分子量：400、600、1K、2K、3.4K、4K、5K、10K 纯度：95%以上
结构式：
供应商：西安凯新生物科技有限公司
状 态：淡黄色到白色固体，或者半固体，取决于分子量。 反应性：DBCO与含有N3基团化合物的反应。NH2可以和NHS,COOH,CHO等等。
溶解度：水、二甲基亚砜、二甲基亚砜
运输温度：低温运输
在多种有机反应中，由于具有多个优点，点击化学已被选作共轭化学反应。
1. 单击化学发生在水中。DMSO，DMF，乙腈，醇或纯水和缓冲液可用于反应。该反应是生物相
2. 反应迅速而定量。Click Chemistry是一种允许在稀释溶液中制备纳摩尔偶联物的工具。
3. 该反应对pH不敏感。与NHS酯与胺以及其他一些共轭化学的反应不同，无需控制反应混合物的pH。无需添加任何特殊的缓冲液，酸或碱-Click Chemistry在4-11的pH间隔下效果很好.
4. 天然生物分子中没有叠氮化物和炔烃。这些基团应专门引入DNA和蛋白质中。可以在标准寡核苷酸合成过程中用炔亚磷酰胺制备含炔的 DNA 。可以使用叠氮化物活化的酯和炔烃活化的酯来制备标记有叠氮化物和炔烃的蛋白质。
相关推荐：
DBCO-PEG-NH2 ， 二苯基环辛炔-聚乙二醇-氨基
DBCO-PEG-Amine，二苯基环辛炔-聚乙二醇-氨基
DBCO-PEG-COOH ， 二苯基环辛炔-聚乙二醇-羧酸
DBCO-PEG-carboxyl，二苯基环辛炔-聚乙二醇-羧酸
DBCO-PEG-MAL，二苯基环辛炔-聚乙二醇-马来酰亚胺
DBCO-PEG-Maleimide，二苯基环辛炔-聚乙二醇-马来酰亚胺
DBCO-PEG-NHS，二苯基环辛炔-聚乙二醇-N-羟基琥珀酰亚胺
DBCO-PEG-N3，二苯基环辛炔-聚乙二醇-叠氮
DBCO-PEG-azide，二苯基环辛炔-聚乙二醇-叠氮
DBCO-PEG-Alkyne，二苯基环辛炔-聚乙二醇-炔基
DBCO-PEG-SH ，二苯基环辛炔-聚乙二醇-炔基
DBCO-PEG-Thiol， 二苯基环辛炔-聚乙二醇-炔基
DBCO-PEG-Biotin ，二苯基环辛炔-聚乙二醇-生物素
DBCO-PEG-CHO ，二苯基环辛炔-聚乙二醇-醛基
DBCO-PEG-aldehyde ，二苯基环辛炔-聚乙二醇-乙醛
DBCO-PEG-SS-OPSS，二苯基环辛炔-聚乙二醇-邻吡啶二硫 巯基吡啶
DBCO-PEG-OH，二苯基环辛炔-聚乙二醇-羟基
DBCO-PEG-hydroxy l ，二苯基环辛炔-聚乙二醇-羟基
DBCO-PEG-Hydrazide，二苯基环辛炔-聚乙二醇-酰基
DBCO-PEG-HZ，二苯基环辛炔-聚乙二醇-酰基
DBCO-SS-PEG-Silane，二苯基环辛炔-聚乙二醇-硅烷
DBCO-PEG-Acrylates，二苯基环辛炔-聚乙二醇-丙烯酸酯
DBCO-PEG-ACRL ，二苯基环辛炔-聚乙二醇-丙烯酸酯
DBCO-PEG-LA ，二苯基环辛炔-聚乙二醇-硫辛酸
DBCO-PEG-Tosyl ， 二苯基环辛炔-聚乙二醇-甲苯磺酸酯
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac9ac1de5eeea846931f372b516e5b3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/652734023931f66181886edcb8577a8d/" rel="bookmark">
			图解k8s中pod的创建流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是pod Pod 是 k8s 系统中可以创建和管理的最小单元，是资源对象模型中由用户创建或部署的最小资源对象模型，也是在 k8s 上运行容器化应用的资源对象，其他的资源对象都是用来支撑或者扩展 Pod 对象功能的，比如控制器对象是用来管控 Pod 对象的，Service 或者Ingress 资源对象是用来暴露 Pod 引用对象的，PersistentVolume 资源对象是用来为 Pod提供存储等等，k8s 不会直接处理容器，而是 Pod，Pod 是由一个或多个 container 组成Pod 是 Kubernetes 的最重要概念，每一个 Pod 都有一个特殊的被称为”根容器“的 Pause容器。Pause 容器对应的镜 像属于 Kubernetes 平台的一部分，除了 Pause 容器，每个 Pod还包含一个或多个紧密相关的用户业务容器
pod的特性 （1）资源共享
一个 Pod 里的多个容器可以共享存储和网络，可以看作一个逻辑的主机。共享的如namespace,cgroups 或者其他的隔离资源。多个容器共享同一 network namespace，由此在一个 Pod 里的多个容器共享 Pod 的 IP 和端口 namespace，所以一个 Pod 内的多个容器之间可以通过 localhost 来进行通信,所需要注意的是不同容器要注意不要有端口冲突即可。不同的 Pod 有不同的 IP,不同 Pod 内的多个容器之前通信，不可以使用 IPC（如果没有特殊指定的话）通信，通常情况下使用 Pod的 IP 进行通信。一个 Pod 里的多个容器可以共享存储卷，这个存储卷会被定义为 Pod 的一部分，并且可以挂载到该 Pod 里的所有容器的文件系统上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/652734023931f66181886edcb8577a8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/778711383b2d7a920ff59c5416d20060/" rel="bookmark">
			解决远程登陆CentOS7 Vmware 虚拟机无法显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用VNC 远程登陆Linux 服务器时，当使用服务器上的Vmware虚拟机时，虚拟机可以正常启动，但是并不会将虚拟机的界面显示到本地，这需要对虚拟机进行设置，方便在使用远程登陆是能够正常使用虚拟机，下面的步骤介绍具体设置：
步骤1：打开Vmware虚拟机
步骤2： 选择菜单栏Edit选项：并打开网络设置选项
步骤3，进行设置如下图所示：
步骤4：设置完成并保存设置后，正常启动虚拟机，即可顺利见到虚拟机界面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd1c22c3839d032b32e7beb6fd1c457/" rel="bookmark">
			字符指针char*用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、char*指向单个字符
char ch = 'w'; char* pc1 = &amp;ch; cout &lt;&lt; *pc1 &lt;&lt; endl; //w 2、char*指向字符数组
char arr[] = "abcdef"; char* pc2 = arr; //数组首元素地址赋值给指针pc2，指针大小只有4字节不可能放下整个数组 cout &lt;&lt; *pc2 &lt;&lt; endl; //输出是a，说明pc2存放的只是数组首元素地址 cout &lt;&lt; pc2 &lt;&lt; endl; //abcdef ，表示从pc2指向的地址位置开始打印 cout &lt;&lt; arr &lt;&lt; endl; //abcdef 3、char*指向字符串的首地址
//指针pc3是肯定放不下整个字符串的，把常量字符串首个字符a的地址赋给pc3;常量字符串前必须加const,不能char* pc3 = "abcdef"; const char* pc3 = "abcdef"; cout &lt;&lt; *pc3 &lt;&lt; endl; //输出是a，说明pc3存放的就只是a地址 cout &lt;&lt; pc3 &lt;&lt; endl; //abcdef，表示从pc3指向的地址位置开始打印字符串 //*pc3 = 'w'; 错误，常量字符串不可以修改 4、字符数组与常量字符串比较
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfd1c22c3839d032b32e7beb6fd1c457/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f36dfe14795ebffa05fe7f7d0cad57b1/" rel="bookmark">
			PTA | 实验二 | 奇偶分家
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给定N个正整数，请统计奇数和偶数各有多少个？
输入格式： 输入第一行给出一个正整N（≤1000）；第2行给出N个非负整数，以空格分隔。
输出格式： 在一行中先后输出奇数的个数、偶数的个数。中间以1个空格分隔。
输入样例： 9 88 74 101 26 15 0 34 22 77 输出样例： 3 6 代码： #include &lt;iostream&gt; using namespace std; int main(){ int N, n, even = 0, odd = 0; cin &gt;&gt; N; for(int i = 1;i &lt;= N;i ++){ cin &gt;&gt; n; if(n%2) odd++; else even++; } cout &lt;&lt; odd &lt;&lt; ' ' &lt;&lt; even; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de107ef894802be2cb5b859997e4bec5/" rel="bookmark">
			一些课后延展:逢七拍手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Python写了一个逢七拍手小游戏
代码如下
运行结果如下:
用for语句循环，当你输入一个数值时，自动列出从1到该数值中需要拍手的数值。
我又按照书上的课后扩展做了延伸:
计算从1-99需要拍手几次？(前提是没人数错)
依旧用for语句，代码如下
这里我用了一个新的函数:endswith
其作用是用来判断字符串是否以指定字符或子字符串结尾，常用于判断文件类型
相关函数还有判断字符串开头的startswith()
运行结果如下:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b93afd437c2f2f45dbbe089664a42b85/" rel="bookmark">
			VSCode开发ESP32
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、VSCode坏境配置二、CP210X三、串口连接问题总结 前言 提示：以下是本篇文章正文内容
一、VSCode坏境配置 安装好VSCode后下载PlatformIO IDE
安装后可以看到如下界面
然后再新建立一个工程
工程名字，开发板类型一般选ESP32 Dev Module即可，框架选择Arduino,
最后可以选择文件创建的位置，点击完成等待下载即可。
然后就可以编写程序了
编译，下载过程：
1是编译整个工程，2是下载程序到开发板上，3是删除生成的*.o连接文件
二、CP210X 由于没有看视频教程，忘记安装CP210X驱动，导致下载不了程序到开发板上，浪费了我一个下午的时间
CP210X下载连接
链接：https://pan.baidu.com/s/138ngHmZ-pXohrLvAKvtACQ
提取码：s59f
三、串口连接问题 若驱动也安装了，开发板连接到电脑了，电脑毫无反应，首先换根数据线试试，很有可能你用的是随厂附赠的充电线，没有传数据的通道
这种情况也是一个大坑
总结 提示：这里对文章进行总结：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52a5c384775d908f328ecea34687246c/" rel="bookmark">
			Python中列表的常用方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在平常的数据处理中我们经常会用到列表的方法，对此，向大家介绍一些列表中常用的方法！
首先，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。列表的数据项不需要具有相同的类型。创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。
以下是列表最常用的方法：
1.append() -------- 向列表的尾部添加元素
2.insert(index，object) -------- 向指定的下标处添加元素
3.sort（）-------- 进行排序（从下到大 int类型）可以对字母进行排序（ASCII值）类型不能混
4.index（）-------- 返回的是元素在列表中的第一个位置
5.reverse（）------------ 将列表进行翻转
6.remove（）---------- 删除某个元素，如果有重复，删除的是第一次出现的元素，如果元素不存在会 报错
7.count（）-------- 返回的是某个元素在列表里面的个数
8.clear（）--------- 清除元素
9.copy（）-------- 浅拷贝对象 不等价与 =
10.extend（）-------- 合并列表
11.pop（）-------删除列表尾部的元素（与append相反）,返回删除的元素，pop(i) i指的是下标
以下是列表里所有方法：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65992428f543f91e96a9652881a87713/" rel="bookmark">
			编译原理第二章课后习题答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad2203f5ee2969376acea1f7bd8d17c5/" rel="bookmark">
			PyEcharts 基本图表之饼图 educoder
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：Pie：饼图（一） from PreTest import * from pyecharts import options as opts from pyecharts.render import make_snapshot from snapshot_phantomjs import snapshot from pyecharts.charts import Pie from pyecharts.faker import Faker data = [list(z) for z in zip(Faker.choose(), Faker.values())] def pie_chart() -&gt; Pie: # ********* Begin *********# pie = ( Pie() .add("",data) .set_colors(["blue", "green", "yellow", "red", "pink", "orange", "purple"]) .set_global_opts( title_opts=opts.TitleOpts(title="Pie-基本示例") ) .set_series_opts( label_opts=opts.LabelOpts(formatter="{b}: {c}") ) ) # ********** End **********# return pie make_snapshot(snapshot, pie_chart().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad2203f5ee2969376acea1f7bd8d17c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/115d7e506ca2e800bf44ea09512422e7/" rel="bookmark">
			SpringSecurity 微服务权限方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是微服务 1.1微服务由来：
微服务最早由 Martin Fowler 与 James Lewis 于 2014 年共同提出，微服务架构风格是一种使用一套小服务来开发单个应用的方式途径，每个服务运行在自己的进程中，并使用轻量级机制通信，通常是 HTTP API，这些服务基于业务能力构建，并能够通过自动化部署机制来独立部署，这些服务使用不同的编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理。
1.2微服务优势：
（1）微服务每个模块就相当于一个单独的项目，代码量明显减少，遇到问题也相对来说比较好解决。
（2）微服务每个模块都可以使用不同的存储方式（比如有的用 redis，有的用 mysql等），数据库也是单个模块对应自己的数据库。
（3）微服务每个模块都可以使用不同的开发技术，开发模式更灵活。
1.3微服务本质:
（1）微服务，关键其实不仅仅是微服务本身，而是系统要提供一套基础的架构，这种架构使得微服务可以独立的部署、运行、升级，不仅如此，这个系统架构还让微服务与微服务之间在结构上“松耦合”，而在功能上则表现为一个统一的整体。这种所谓的“统一的整体”表现出来的是统一风格的界面，统一的权限管理，统一的安全策略，统一的上线过程，统一的日志和审计方法，统一的调度方式，统一的访问入口等等。
（2）微服务的目的是有效的拆分应用，实现敏捷开发和部署。
2.微服务认证与授权实现思路 2.1认证授权过程分析：
（1）如果是基于 Session，那么 Spring-security 会对 cookie 里的 sessionid 进行解析，找到服务器存储的 session 信息，然后判断当前用户是否符合请求的要求。
（2）如果是 token，则是解析出 token，然后将当前请求加入到 Spring-security 管理的权限信息中去。
如果系统的模块众多，每个模块都需要进行授权与认证，所以我们选择基于 token 的形式进行授权与认证，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限值，并以用户名为 key，权限列表为value 的形式存入 redis 缓存中，根据用户名相关信息生成 token 返回，浏览器将 token 记录到 cookie 中，每次调用 api 接口都默认将 token 携带到 header 请求头中，Spring-security 解析 header 头获取 token 信息，解析 token 获取当前用户名，根据用户名就可以从 redis 中获取权限列表，这样 Spring-security 就能够判断当前请求是否有权限访问。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/115d7e506ca2e800bf44ea09512422e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a65f3eb720424878ae8198964a03c540/" rel="bookmark">
			Selenium之css怎么实现元素定位？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		世界上最远的距离大概就是明明看到一个页面元素站在那里，但是我却定位不到！！
Selenium定位元素的方法有很多种，像是通过id、name、class_name、tag_name、link_text等等，但是这些方法局限性太大， 随着自动化测试的深入，和不同框架要求，会发现上面的定位方式无法解决一些元素定位。尤其对于这样一些元素：
1、没有id、name、class等属性;
2、标签的属性或文本信息特征没有或者不明显；
3、标签嵌套复杂，层次太多等。
所以这些方法了解一下即可，我们真正需要熟练掌握的是通过xpath和css定位，一般只要掌握一种就可以应对大部分定位工作了。
CSS定位方式和XPATH定位方式基本相同，只是CSS定位表达式有其自己的格式。CSS定位方式拥有比XPATH定位速度快，且比XPATH稳定的特性。下面详细介绍CSS定位方式的使用方法
那这里我跟大家分享如何通过css定位元素，css定位元素的方法是
find _element_by_css_selector
如下是百度首页html代码：
1.css定位通过绝对路径定位 什么是绝对路径？绝对路径其实就是从开始标签（html）一级一级找到目标元素，上下级元素分隔符为&gt;或者空格
例如：通过css绝对路径定位百度输入框，并输入内容检索，代码如下：
from selenium import webdriver import time # 打开浏览器 driver=webdriver.Chrome() # 加载项目地址（百度） driver.get("http://www.baidu.com") time.sleep(3) #定位百度输入框 driver.find_element_by_css_selector("html body div div div div div form span input").send_keys("小龙女") driver.find_element_by_css_selector("html&gt;body&gt;div&gt;div&gt;div&gt;div&gt;div&gt;form&gt;span&gt;input").send_keys("小龙女") 2.css定位通过id或class定位 id选择器符号：#，class选择器符号：.还是刚才案例，通过id或者class定位代码如下：
# 通过id定位 driver.find_element_by_css_selector("#kw").send_keys("小龙女") #class进行定位 4driver.find_element_by_css_selector(".s_ipt").send_keys("小龙女") 3.通过属性或者部分属性定位 css定位可以通过除元素id、class以外的其他属性或者通过多个属性唯一定位元素，也可以通过部分属性值来定位。通过部分属性定位，有这么些常规匹配符，以字符^指明从字符串的开始匹配，以字符以字符*指明在需要进行模糊查询，以字符$指明在字符串的结尾匹配，代码如下：
driver.find_element_by_css_selector("[autocomplete='off']").send_keys("小龙女") driver.find_element_by_css_selector("[autocomplete='off'][name='wd' ]").send_keys("小龙女") # 4）通过部分属性值定位 driver.find_element_by_css_selector("[autocomplete^='o'][name='wd']").send_keys("小龙女") driver.find_element_by_css_selector("[autocomplete*='f']").send_keys('小龙女') driver.find_element_by_css_selector("[autocomplete$='f']").send_keys("小龙女") 4.通过层级定位 层级定位一般很难唯一定位到元素，一般情况下层级跟id/class/属性或者部分属性值一起组合定位：
driver.find_element_by_css_selector("form&gt;span&gt;input").send_keys("小龙女") driver.find_element_by_css_selector("form.fm&gt;span&gt;input.s_ipt").send_keys("小龙女") driver.find_element_by_css_selector("form&gt;span&gt;input#kw").send_keys("小龙女") 5.通过兄弟节点定位 什么是兄弟节点，就是同一父级元素下，存在多个相同子标签，那么这些子元素就是兄弟节点，比如像下面这个html代码
如何来定位这些兄弟节点呢？定位第一个元素first-child,定位第2/3/4…N位置元素则用nth-child(n),定位最后一个元素last-child，代码如下：
# 6)通过兄弟节点定位 driver.find_element_by_css_selector("div#u1 a:first-child").click() driver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a65f3eb720424878ae8198964a03c540/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e87c3d57d57a443ca4523611b77f068/" rel="bookmark">
			基于 Labelme 制作手部关键点数据集 并转 COCO 格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Labelme 制作手部21个关键点数据 1：环境准备1.1 基础环境1.2 安装 Labelme1.2.1：创建anaconda虚拟环境1.2.2：激活虚拟环境1.2.3：安装labelme的依赖1.2.3：安装labelme1.2.4：运行 2. 标注图片 （要先用rectangle把手圈起来，然后在rectangle里面打点）3. 标注转化（运行代码的时候一定要保证rectangle和keypoints都有） 因为导师的项目是手部姿态估计，经过一些技术预研，最后选定了 Open-MMLab 的 MMPose 作为基础框架来做底层架构。先说下Open-MMLab我认为的优点：
1. 代码优质：模块化做的非常好，易于扩展
2. 多研究方向支持：现在有十几个研究方向，包括MMCV（用于计算机视觉研究的基础）、MMDetection（目标检测工具箱）、MMDetection3D（3D目标检测）、MMSegmentation（语义分割工具箱）、MMClassification（分类工具箱）、MMPose（姿势估计工具箱）、MMAction2（动作理解工具箱）、MMFashion（视觉时尚分析工具箱）、MMEditing（图像和视频编辑工具箱）、MMFlow（光流工具箱）等等
3. 社区活跃：社区沟通一般是通QQ群或者微信群进行沟通，有任何问题都在社区得到相对及时的回答，而且针对一些业务思路，社区志愿者或者官方也会给出一些思路或者建议，这个非常不错。
4. 高性能：提供的现成SOTA算法和预训练模型都比官方的实现有显著的提升
5. 文档丰富：官方文档在不同研究方向上都有非常详细的中英文教程，新手可以按照教程迅速上手，赞一个
技术预研的时候看了包括百度的飞浆（PP）、旷视的天元（MegEngine），也都做得非常好，但是支持的研究方向就少了一些。
实验过程和一些注意事项如下文，希望帮助到有缘人，o(￣︶￣)o
1：环境准备 1.1 基础环境 操作系统：Windows 10
Python：3.8
Anaconda：4.10.1 （这个版本不重要）
Anaconda环境安装，如果没有安装的请自行搜索安装下，或者参考我之前的安装教程（Windows10 安装 Anaconda + CUDA + CUDNN ）
1.2 安装 Labelme 可以参考官方的安装，地址：https://github.com/wkentaro/labelme 1.2.1：创建anaconda虚拟环境 conda create -n labelme python=3.8 1.2.2：激活虚拟环境 conda activate labelme 1.2.3：安装labelme的依赖 conda install pillow conda install pyqt 1.2.3：安装labelme pip install labelme 1.2.4：运行 lableme 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e87c3d57d57a443ca4523611b77f068/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1526e87833490af44fa212c1ce13bef/" rel="bookmark">
			基于Spring的aop实现多数据源动态切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring多数据源管理类AbstractRoutingDataSource
实现AbstractRoutingDataSource重写determineCurrentLookupKey
首先配置项目的多数据源实体类交给spring管理
&lt;beans&gt; &lt;!-- 加载配置属性文件 --&gt; &lt;context:property-placeholder ignore-unresolvable="true" location="classpath:application.properties" /&gt; &lt;!-- 数据源配置, 使用 BoneCP 数据库连接池 --&gt; &lt;bean id="dataSourceMaster" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;!-- 数据源驱动类可不写，Druid默认会自动根据URL识别DriverClass --&gt; &lt;property name="driverClassName" value="${default.jdbc.driver}" /&gt; &lt;!-- 基本属性 url、user、password --&gt; &lt;property name="url" value="${default.jdbc.url}" /&gt; &lt;property name="username" value="${default.jdbc.username}" /&gt; &lt;property name="password" value="${default.jdbc.password}" /&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name="initialSize" value="${default.jdbc.pool.init}" /&gt; &lt;property name="minIdle" value="${default.jdbc.pool.minIdle}" /&gt; &lt;property name="maxActive" value="${default.jdbc.pool.maxActive}" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="60000" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1526e87833490af44fa212c1ce13bef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bf12e7872d50bf015d4da489a2e4b78/" rel="bookmark">
			LeetCode 算法入门 Day7 广度优先搜索 / 深度优先搜索 Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		733. 图像渲染
题目描述:
代码:
class Solution { int []dx={1,0,0,-1}; int []dy={0,1,-1,0}; public int[][] floodFill(int[][] image, int sr, int sc, int newColor) { int currColor = image[sr][sc]; if(currColor==newColor){ return image; } int n=image.length,m=image[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;(); queue.offer(new int[] {sr,sc}); image[sr][sc]=newColor; while(!queue.isEmpty()){ int []cell=queue.poll(); int x=cell[0],y=cell[1]; for(int i=0;i&lt;4;i++){ int mx=x+dx[i],my=y+dy[i]; if(mx&gt;=0&amp;&amp;mx&lt;n&amp;&amp;my&gt;=0&amp;&amp;my&lt;m&amp;&amp;image[mx][my]==currColor){ queue.offer(new int[]{mx,my}); image[mx][my]=newColor; } } } return image; } } 思路:
695. 岛屿的最大面积
问题描述:
代码:
class Solution { public int maxAreaOfIsland(int[][] grid) { int ans = 0; for(int i=0;i!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bf12e7872d50bf015d4da489a2e4b78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b753fff34641b5d3554b815f0f190f69/" rel="bookmark">
			点击打印按钮，第一次获取不到数据，一定要第二次才能获取到数据------this.$nextTick()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（第一次分享，还有点小忐忑，如果哪里说的不对，请及时纠正哦~~）
----------------------------------------------------------------------------------------------
我写了一个打印按钮，点击按钮时会弹出打印框显示四张表格以及表格里面的数据（数据是后端传过来的），我本来是这样写的（如下图），如果是顺序执行 ，我这样写会倒置先打印后获取数据，就会造成的我表格获取不到数据。
---------------------------------------------------------------------------------------------------------------------------------
然后，我把它们的位置互换了，发现第一次点还是获取不到数据，一定要第二次点才可以获取到。噢！原来axios 是异步（简而言之就是不按顺序执行）。
所以我的理解是：当getList()在获取数据的时候，我的打印事件也执行了，所以我第一次获取不到数据，当我第二次点击打印按钮的时候（也就是在第一次getList()获取到数据之后），我就能获取到数据。
---------------------------------------------------------------------------------------------------------------------------------
后来，我就在getList（）里使用了 this.$nextTick()方法，在数据获取完之后立即执行打印事件，在print事件里调用getList（），然后就实现了第一次点击就能获取到数据啦。
总结：更改数据后当你想立即使用js操作新的视图的时候就使用this.$nextTick()
---------------------------------------------------------------------------------------------------------------------------------
提出一个问题：我在created和mounted里调用getList（）的时候，会报“数据不存在的错”，请问这是为什么？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d863ce159d939f129252c2970e872a92/" rel="bookmark">
			Ubuntu 18.04安装搜狗输入法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 18.04安装搜狗输入法 包下载地址教程 完成教程的步骤后，配置输入法如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b92652d9ce50b85b3e21cc5732e054e2/" rel="bookmark">
			element折叠面板(默认展开)的使用及样式修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图：
HTML部分：
&lt;el-collapse v-model="activeNames" style="border:none;margin-left:30px;"&gt; &lt;el-collapse-item name="1"&gt; &lt;template slot="title"&gt; &lt;p class="title"&gt;运行信息&lt;/p&gt; &lt;/template&gt; &lt;div class="row" style="margin-top:18px;"&gt; &lt;span&gt;开关:{{on}}&lt;/span&gt; &lt;span style="margin-left:77px"&gt;亮度:{{light}}&lt;/span&gt; &lt;/div&gt; &lt;/el-collapse-item&gt; &lt;el-collapse-item name="2"&gt; &lt;template slot="title"&gt; &lt;p class="title"&gt;设备信息&lt;/p&gt; &lt;/template&gt; &lt;div class="row" style="margin-top:18px;"&gt; &lt;p class="col_left"&gt;设备名称:{{devName}}&lt;/p&gt; &lt;p class="col_right"&gt;产品名称:{{prodName}}&lt;/p&gt; &lt;/div&gt; &lt;div class="row" style="overflow:hidden"&gt; &lt;p class="col_left"&gt;设备ID:{{devId}}&lt;/p&gt; &lt;p class="col_right"&gt;规格型号:{{modelId}}&lt;/p&gt; &lt;/div&gt; &lt;/el-collapse-item&gt; &lt;/el-collapse&gt; script部分：
&lt;script&gt; export default { data () { return { on: "开", light: 100, devName: '虎牌双色灯', prodName: '双色灯', devId: 'M000012', modelId: '双色灯5045', activeNames: ['1', '2'] //这里的activeNames要与&lt;el-collapse&gt;绑定的v-model值一致 //['1', '2']里面的值要与&lt;el-collapse-item&gt;唯一表示name属性值一致 //这样就可以实现默认展开指定折叠面板块 } } } &lt;/script&gt; css部分：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b92652d9ce50b85b3e21cc5732e054e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d69a0252a7ec327551bf8b83c2b77a8/" rel="bookmark">
			python交流群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		q群：707499462
本群旨在为初学python的小伙伴们提供交流机会
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25c468529e4cec692875f81e29302758/" rel="bookmark">
			Java内存区域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新生代主要存一些朝生夕死的对象，老年代存的是比较稳定的对象或者是大对象，持久代用于存放用于存放静态文件，如今Java类、方法等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/259615232fd48fb82d12073737d56f00/" rel="bookmark">
			[Python]解决UnicodeDecodeError: ‘ascii‘ codec can‘t decode byte 0xe6 in position 0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的Linux服务器的Python版本是2.*，在将中文encode(UTF-8)的时候出现了UnicodeDecodeError: 'ascii' codec can't decode byte 0xe6 in position 0: ordinal not in range(128)的问题。而在3.*中没有问题。
解决方法：
在代码前端加入
import sys
reload(sys)
sys.setdefaultencoding('utf8')
Python 2.x，字符编码方面，设计的不好。字符串包含两种-----&gt;str字符串（此时字符串的编码类型，对应着你的Python文件本身保存为何种编码有关）和unicode字符串
而在Python 3.*中，字符串则是unicode编码的str。上面这个问题，就是Python2.*渣编码的一个体现
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7003b348a5952f6763f25513a2c2e803/" rel="bookmark">
			Java读写文件的常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java读写文件提供了几种流来提供文件读写。
FileWriter和FileReader 读写字符流。read()方法只支持对单个或指定个数的char读取。
import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; /** * 使用FileWriter类写文本文件 */ public static void writeMethod1() { String fileName="C:\\test.txt"; try { //使用这个构造函数时，如果存在test.txt文件， //则先把这个文件给删除掉，然后创建新的test.txt FileWriter writer=new FileWriter(fileName); writer.write("This is a test\n"); writer.close(); } catch (IOException e) { e.printStackTrace(); } } //注意：上面的例子由于写入的文本很少，使用FileWrite类就可以了。但如果需要写入的 //内容很多，就应该使用更为高效的缓冲器流类BufferedWriter。 /** * 使用FileReader类读文本文件 */ public static void readMethod1() { String fileName="C:/test.txt"; int c=0; try { FileReader reader=new FileReader(fileName); c=reader.read(); while(c!=-1) { System.out.print((char)c); c=reader.read(); } reader.close(); } catch (Exception e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7003b348a5952f6763f25513a2c2e803/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/598f81ead28ec533c57551de6bc75cc5/" rel="bookmark">
			Mars--xlog加密踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础 - Xlog 加密使用指引 - 《Mars 开发文档》 - 书栈网 · BookStack
一、环境准备–Python2环境安装openssl
以下一起操作都需要在python2环境下进行操作
文档中使用的是pyelliptic1.5.7，在新版本的macos中已经不可用，有人提交了Issues
Exception: Couldn’t load OpenSSL lib , 升级到MACOS 11.5.1后出现 · Issue #969 · Tencent/mars (github.com)
下载pyelliptic 1.5.10
https://github.com/mfranciszkiewicz/pyelliptic/archive/1.5.10.tar.gz#egg=pyelliptic
解压后，修改源文件中的openssl.py文件,目录如下
pyelliptic-1.5.10/pyelliptic/openssl.py def find_crypto_lib(): if sys.platform != 'win32': # 注释掉下面路径,写绝对路径 # return ctypes.util.find_library('crypto') return '/usr/lib/libcrypto.dylib' 在Python2环境下到pyelliptic-1.5.10进行安装
python setup.py install 二、生成公私钥
到Mars项目目录下找到gen_key.py，目录如下
mars-master/mars/log/crypt/gen_key.py 修改decode_mars_crypt_log_file.py中的公私钥
PRIV_KEY = "私钥" PUB_KEY = "公钥" 三、修改Android中xlog的初始化代码
val SDCARD: String = Environment.getExternalStorageDirectory().absolutePath val logPath: String = SDCARD + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/598f81ead28ec533c57551de6bc75cc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5a6bb63f0105aa74cfc4a5ac77f90ff/" rel="bookmark">
			Labelme 批量转 dataset 使用 labelme_json_to_dataset 命令 （简明图文教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Labelme 批量转 dataset 0.概述1.原理2.代码3.试验过程3.1 实验一：输入单个目录3.2 实验二： 增加参数 --out 输出文件目录 4.方法二4.1 重新创建虚拟环境4.2 进入虚拟环境和标注目录：4.3 安装labelme的依赖4.4 安装labelme4.5 编写bat文件 实验环境
操作系统：Windows 10
Python：3.8
Labelme：4.5.13 (这个版本比较重要，不同版本代码可能会不一样）
Anaconda：4.10.1
如果还有同学没有安装好 Anaconda，或者 Labelme 请参见，我的另外两篇文章：安装Anaconda，安装 Labelme
0.概述 现有的标注 json 文件转 dataset 的工具只能转单个 json 文件，没有办法批量转多个标注文件。本文中笔者根据转换原理修改相关代码实现了批量转换一个目录下所有 json 文件的方法，该方法支持输入一个目录，并且兼容 -o, --out 参数来指定输出 dataset 的目录，详细介绍如下。
1.原理 默认安装的 Labelme 有个可以单个转换 json 标注文件成 dataset 的工具，在 $python目录\Scripts 下，例如：
Anaconda虚拟环境 ：
D:\anaconda3\envs\labelme\Scripts\labelme_json_to_dataset.exe
非虚拟环境：
E:\python\Python37\Scripts\labelme_json_to_dataset.exe
这个exe文件，调用的代码是 $python目录\Lib\site-packages\labelme\cli\json_to_dataset.py ，例如
Anaconda虚拟环境：
D:\anaconda3\envs\labelme\Lib\site-packages\labelme\cli\json_to_dataset.py
非虚拟环境：
E:\python\Python37\Lib\site-packages\labelme\cli\json_to_dataset.py
执行命令
(labelme) PS D:\anaconda3\envs\labelme\Scripts&gt; .\labelme_json_to_dataset.exe E:\annotation\xx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5a6bb63f0105aa74cfc4a5ac77f90ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a77f1b2a43485fb26c9c0f76cccc014c/" rel="bookmark">
			计概基础知识串讲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谁能想到以这种方式再次打开文章管理
计算概论期中复习&amp;串讲 一： 发展史 （一）.数学危机 希帕索斯发现无理数——实数论贝克莱悖论（无穷小）——集合论罗素悖论——哥德尔不完备性定理——可计算问题——图灵机 （二）.计算机 第一台——埃尼阿克ENIAC 1946 宾夕法尼亚大学
*无存储器，用布线板控制，效率低
现代意义上第一台 ——EDVAC 1951 冯诺依曼
二进制表示数组和程序，使用“存储程序”的方法控制计算机
冯诺依曼结构
摩尔定律：
CPU芯片上的零件密度每18月增加一倍
CPU性能18个月提高一倍，价格下降一半
保证摩尔定律？ 提高工作效率&amp;在一枚处理器中集成多个内核 第一代计算机(1946年-1957年)电子管计算机，采用电子管作为逻辑线路主要元件。应用范围十分有限，主要应用于军事领域及科学计算。
第二代计算机(1957年-1964年) 晶体管计算机 采用晶体管作为逻辑线路主要元件。与第一代计算机相比，由于晶体管体积小、耗电少、寿命长、计算性能有了很大改进，成本随之下降。应用范围扩大到数据处理和事务管理等方面。
第三代计算机(1964年-1970年)集成电路计算机，采用中、小规模集成电路代替了传统的独立式晶体管。与第二代计算机相比，这一时期的计算机其软件、硬件系统都向标准化、模块化、系列化发展。应用范围扩大到工业控制等领域。
第四代计算机(1970年-今) 大规模集成电路计算机，采用大规模、超大规模集成电路为计算机主要功能元件。
以上设计都采用“冯·诺依曼”结构，
“以二进制、存储程序以及指令和数据统一存储”为基础
二：网络 （一）互联网络 组成
各种类型的计算机或嵌入式设备互联线路或无线通信介质网络通信设备与网络软件 分类：
广域网（WAN）：跨越国家和省市地域的网络局域网（LAN）：一个建筑物范围内、利用以太网技术形成的计算机网络内联网（Intranet）：企业/组织的内部网（可能是WAN、LAN） （二）局域网 计算机
网卡（NC）连接线路
有线：双绞线
无线网络设备：
集线器
交换机
路由器 （三）管理 协议
通信协议栈协议 HTTP超文本传输（客户端于服务器之间的通讯协议）TCP传输控制协议（可靠的传输协议）IP互联网协议（非可靠的传输协议）
地址 IP地址——计算机在IP网络上的标识，32位二进制数域名——文字标识IP地址DNS——把域名映射成IP地址的服务系统 （四）基础设施 通信线路（介质）
双绞线、光纤，无线，同轴电缆……
网络设备
集线器、交换机、路由器
技术
以太网、ATM、蓝牙
（五）基本模式 客户端 /服务器 client/server
客户端早读发出请求，服务器被动接受服务请求对等 peer to peer
客户端和服务器仅仅是角色，在不同的交互中同一计算机可以有不同角色 （六）应用 万维网
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a77f1b2a43485fb26c9c0f76cccc014c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c8d2061b812f3fce0cbd61072c1ff2e/" rel="bookmark">
			Caused by: java.lang.StackOverflowError: null
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考
由于深度递归，抛出此错误以指示应用程序的堆栈已耗尽。
在方法执行过程中调用自己引起递归。
解决：查看方法中哪些部份反复调用自己。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ca5a563cdf73b732b80ff895f388225/" rel="bookmark">
			Flutter 架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该文章旨在提供更深入的 Flutter 架构概览，包含其设计层面的核心原则及概念。
​
在开发中，Flutter 应用会在一个 VM（程序虚拟机）中运行，从而可以在保留状态且无需重新编译的情况下，热重载相关的更新。对于发行版 (release) ，Flutter 应用程序会直接编译为机器代码（Intel x64 或 ARM 指令集），或者针对 Web 平台的 JavaScript。 Flutter 的框架代码是开源的，遵循 BSD 开源协议，并拥有蓬勃发展的第三方库生态来补充核心库功能。
​
接下来我们主要分为以下几部分内容来了解 Flutter 架构：
简介：Flutter 是什么？干什么？谁会用到？架构层：Flutter 的构成要素。响应式用户界面：Flutter 用户界面开发的核心概念。布局和渲染：Flutter 如何将界面布局转化为像素。widgets 树：构建 Flutter 用户界面的基石。平台嵌入层：让 Flutter 应用可以在移动端及桌面端操作系统执行的代码。与其他代码进行集成：Flutter 应用可用的各项技术的更多信息。 一. Flutter 简介 Flutter 是 Google 的便携式 UI 工具包，帮助你在移动、web、桌面端创造高质量的绝妙原生体验的应用。 Flutter 可以和世界上的开发人员和开发组织广泛使用的那些现存代码一起使用，并且是开源的、免费的。
​
对于用户来说，Flutter 让漂亮的应用 UI 变得生动有趣。
对于开发者来说，Flutter 降低了创建移动应用的门槛。它加速了移动应用的开发，降低了兼顾 Android 和 iOS 应用开发的成本和复杂性,减少了跨平台开发的成本以及复杂度。 对于设计师而言，Flutter 可以确保精确地实现设计意图，而无需降低保真度或被迫进行妥协。在设计师的手里，Flutter 还可以作为一种高效的原型设计工具。
​
Flutter 适用于希望快速构建精美的移动应用，或者希望用一套代码库覆盖更多用户的开发者。 Flutter 也适用于需要领导研发团队的工程经理们。 Flutter 可以让工程经理打造一个统一的应用研发团队，这个“应用”包含：移动端、Web 端以及桌面端。这可以帮助以便更快地开发更多功能，将相同的功能部署到多平台的应用中，并降低维护成本。 说到底，如果您想要漂亮的应用，令人愉悦的动效和动画，以及富有个性和身份感的 UI，那您就是 Flutter 的目标用户。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ca5a563cdf73b732b80ff895f388225/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c680043cadd03ecaf89b950f0bcfd77/" rel="bookmark">
			redhat中Telnet服务器搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要说明：
利用yum源来下载安装Telnet服务器
准备步骤：进入root界面
[ly@localhost 桌面]$ su 密码：
[root@localhost 桌面]#
配置好yum源文件（此处省）检查是否安装了Telnet和xinetd 开始进行安装 安装Telnet服务端
#yum -y intall telnet-server.86_64
注：一般如下找不到镜像文件的原因是 没有连接网络！！！
此时需要在本电脑连好网络后，再在虚拟机桌面右上角出开启连网，如图
安装Telnet客户端
#yum -y install telnet.x86_64
4、安装xinetd进程
注：xinetd进程是Telnet的守护进程
#yum -y install xinetd.x86_64
5、检查是否都安装成功
# rpm -qa | grep telnet # rpm -qa | xinetd 6、 安装成功后，将xinetd服务加入开机自启动：
# systemctl enable xinetd.service 如果失败了，一般是没有关闭防火墙造成，需要暂时关闭防火墙：
# systemctl stop firewalld
7、 将telnet服务加入开机自启动：
# systemctl enable telnet.socket
8、启动telnet和xinetd两个服务即可
# systemctl start telnet.socket
# systemctl start xinetd
9、 开启端口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c680043cadd03ecaf89b950f0bcfd77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22c9f035471d338688a2a78037b2de70/" rel="bookmark">
			如何简单编写斗地主发牌程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们先来看一看要求
* 纸牌管理类
* 斗地主游戏规则如下:
* 1.有三名玩家，可从控制台赋值玩家姓名，玩家中会有牌类集合的属性，还有是否是地主的状态
* 2.牌类有两个属性:花色和点数。花色有4种:黑红梅方（可用枚举）点数对应有13加上两张王牌（可用枚举）。
* 3.扑克牌管理类:用于产生54张随即顺序的牌堆（牌类集合，54张牌不变，变得是顺序），给玩家发牌，并随机产生地主，把剩余3张底牌给地主，并展示三位玩家的手牌。同时把手牌信息存入文件中
一，首先创建纸牌类
可以利用数组，也可以利用集合
先把花色和数字定义好，然后把大小王添加进去，接着利用递归的方法，将花色和数字一一对应，这里要注意下标的问题
public class Playcard { public static void main(String[] args)throws IOException { ArrayList&lt;Integer&gt; numCards = new ArrayList&lt;&gt;();//numcards为下标的集合 HashMap&lt;Integer, String&gt; cards = new HashMap&lt;&gt;();//cards为纸牌的集合，包括下标和纸牌数字花色 String[] num = {"A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"}; String[] colour = {"♠", "♦", "♣", "♥"}; numCards.add(0); numCards.add(1); cards.put(0, "大王"); cards.put(1, "小王"); int a = 2; for (String s : colour) { for (String s1 : num) { numCards.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22c9f035471d338688a2a78037b2de70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/446152c0d7cfeb05e7a432abd7b5c71a/" rel="bookmark">
			pyecharts Graphic使用（加水印）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Graphic 添加文字 可以通过添加文字作为水印
首先随便选一个图
from pyecharts import options as opts from pyecharts.charts import Bar from pyecharts.faker import Faker c = Bar() c.add_xaxis(Faker.choose()) c.add_yaxis("商家A", Faker.values(), stack="stack1") c.add_yaxis("商家B", Faker.values(), stack="stack1") c.set_series_opts(label_opts=opts.LabelOpts(is_show=False)) c.set_global_opts(title_opts=opts.TitleOpts(title="Bar-堆叠数据（全部）")) c.render("./picture/bar_stack0.html") 大概长这样
接下来使用Graphic增加水印
from pyecharts import options as opts from pyecharts.charts import Bar from pyecharts.faker import Faker from pyecharts.commons.utils import JsCode c = Bar() c.add_xaxis(Faker.choose()) c.add_yaxis("商家A", Faker.values(), stack="stack1") c.add_yaxis("商家B", Faker.values(), stack="stack1") c.set_series_opts(label_opts=opts.LabelOpts(is_show=False)) c.set_global_opts( title_opts=opts.TitleOpts(title="Bar-堆叠数据（全部）") ,graphic_opts=[ opts.GraphicGroup( #定位位置 具体配置看官方文档https://pyecharts.org/#/zh-cn/global_options?id=graphicrect%ef%bc%9a%e5%8e%9f%e7%94%9f%e5%9b%be%e5%bd%a2%e7%9f%a9%e5%bd%a2%e9%85%8d%e7%bd%ae%e9%a1%b9 graphic_item=opts.GraphicItem( rotation=JsCode("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/446152c0d7cfeb05e7a432abd7b5c71a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3114b8a50cc13ea034e51bdcbd969f8c/" rel="bookmark">
			vue-pure-admin项目的学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 感谢作者的开源，让我们有机会学习
项目地址： vue-pure-admin
只是记录自己的学习，有问题地方感谢指正
只会记录一些自己目前感觉有用的知识点
代码demo都是基于vue3、ts、element plus
目录结构 -src --api	存放与请求有关的文件 --assets	存放静态文件（图标、文字） --components	存放全局公共组件 --config	项目配置 --directives	全局指令 --layout	全局布局 --plugins	插件 --router	路由 --store	vuex --style	全局样式 --utils	全局工具方法 --views	页面 登录页 登录页小功能 项目效果如下，感觉挺不错的
demo
&lt;template&gt; &lt;div class="login"&gt; &lt;div class="user"&gt; &lt;div ref="nameRef" class="user_name"&gt;用户名&lt;/div&gt; &lt;input class="input" type="text" v-model="userName" @focus="onUserFocus(nameRef)" @blur="onUserBlur(nameRef, userName)" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang="ts"&gt; import { defineComponent, ref } from "vue"; export default defineComponent({ setup() { let nameRef = ref(null); let userName = ref("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3114b8a50cc13ea034e51bdcbd969f8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78de9acc632e6a63f88e22fe36c760c7/" rel="bookmark">
			Windows部署的gogs开机自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、编写自启动脚本gogs.bat
脚本含义就是进入到gogs目录，然后后台启动gogs服务，如下：
cd/ d: cd D:/gogs/ gogs web &amp; 2、添加开机启动脚本
win+r弹出运行窗口，输入
gpedit.msc 弹出本地组策略编辑器，按下图所示添加刚才编写的gogs.bat脚本，应用确定即可。
然后重启就能自启动gogs了。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/170/">«</a>
	<span class="pagination__item pagination__item--current">171/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/172/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>