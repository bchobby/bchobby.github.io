<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/563c0c90a30e7bb7f902764ecc45cc7d/" rel="bookmark">
			生信入门（六）——单细胞分析（Seurat）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生信入门（六）——单细胞分析（Seurat） 文章目录 生信入门（六）——单细胞分析（Seurat）一、数据导入1、数据来源2、数据导入 二、标准预处理1、QC和选择细胞进行进一步分析2、规范化数据3、识别高度可变的特征（特征选择）4、缩放数据 三、主成分分析（PCA）1、线性降维2、确定数据集的“维度” 四、聚类细胞五、非线性降维（UMAP/tSNE）六、寻找差异表达的特征（簇生物标志物） 一、数据导入 1、数据来源 点击此处下载数据
数据说明：分析10X Genomics提供的外周血单细胞（PBMC）数据集，有2700个单细胞在illuminate NextSeq500上测序
2、数据导入 setwd("D:/RData/prac004") # BiocManager::install("Seurat") library(Seurat) library(dplyr) library(patchwork) # 导入数据 pbmc.data&lt;-Read10X(data.dir = "./filtered_gene_bc_matrices/hg19") # 初始化seurat数据 pbmc&lt;-CreateSeuratObject(counts = pbmc.data,project = "pbmc3k",min.cells = 3,min.features = 200) # pbmc 运行结果
二、标准预处理 该处包括基于QC指标（质控分析）、数据标准化和缩放以及高度可变特征检测的细胞选择和过滤
1、QC和选择细胞进行进一步分析 常用的QC指标包括：
在每个细胞中检测到的独特基因的数量。
低质量细胞或空液滴通常只有很少的基因 细胞双联体或多重联体可能表现出异常高的基因计数 同样，在细胞内检测到的分子总数（与独特的基因密切相关）
映射到线粒体基因组的读数百分比
低质量/垂死的细胞通常表现出广泛的线粒体污染 我们使用该PercentageFeatureSet()函数计算线粒体 QC 指标，该函	数计算源自一组特征的计数百分比 我们使用所有基因MT-的集合作为一组线粒体基因 #使用PercentageFeatureSet函数计算线粒体QC指标 pbmc[['percent.mt']]&lt;-PercentageFeatureSet(pbmc,pattern = "^MT-") # 使用violin plot可视化 QC指标，并使用这些指标过滤单元格 VlnPlot(pbmc,features = c("nFeature_RNA","nCount_RNA","percent.mt"),ncol = 3) # FeatureScatter 通常用于可视化两个特征之间的关系 plot1&lt;-FeatureScatter(pbmc,feature1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/563c0c90a30e7bb7f902764ecc45cc7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11b972b8f0677b88a25179f8e1c3b43d/" rel="bookmark">
			制作window11系统U盘启动盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言1. U盘分区2. 复制系统文件到U盘3. 编辑bcd文件4. 查看系统安装盘（U盘） 前言 制作系统安装U盘需要使用到bootice这个工具(下载地址)，它主要是用来给U盘分区以及编辑bcd引导文件的。
这里说明一下为什么给U盘分区，主要是因为uefi启动现在目前只支持Fat文件格式，但是它有一个缺点就是支持的单个文件大小最大到4GB,也就说系统文件单个有大于4GB的就放不了，所以这里我分了两个分区，一个是引导分区，给300MB足以，文件格式为Fat32，剩下的空间为普通分区，文件格式为exfat或是NTFS都可以，这两个文件系统格式支持最大为TB级，所以可以支持大于4GB的单个文件（主要是这个install.wim文件大于4GB），我这里就把镜像文件里面的sources文件夹全部放在普通分区，然后把引导分区里面的bcd文件指向sources文件夹所在的分区就可以了
1. U盘分区 打开bootice工具，选中我们要制作系统U盘启动盘，点击分区管理进入分区管理界面
点击重新分区
选择USB-HDD模式（多分区），点击确定
设置分区参数如下，点击确定执行分区
分区完成显示如下:
2. 复制系统文件到U盘 把window11的iso镜像的文件（除了sources文件夹）全部复制到刚才完成分区的引导分区（FAT32的那个分区）
把window11的iso镜像sources文件夹复制到刚才完成分区的普通分区（ExFAT的那个分区）
3. 编辑bcd文件 bootice切换到BCD编辑，选择其他BCD文件
选中U盘引导分区根目录下boot文件夹下的bcd文件
点击智能编辑模式，进入bcd文件编辑界面
启动磁盘就选我们制作系统安装盘的U盘，启动分区就选sources文件夹所在的分区，然后点击保存当前系统设置，点击关闭退出
再选中U盘引导分区根目录下efi/microsoft/boot文件夹里面的bcd文件
再次点击智能编辑模式，进入bcd文件编辑界面
启动磁盘就选我们制作系统安装盘的U盘，启动分区就选sources文件夹所在的分区，然后点击保存当前系统设置，点击关闭退出
到此编辑BCD引导文件完成
4. 查看系统安装盘（U盘） 这里可以看到U盘分成了两个分区，并且引导分区已经显示系统安装盘的图标了，到此大功告成，可以去试试我们的系统安装盘了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43680d26c42e41b0923cffc95c95d8d4/" rel="bookmark">
			JavaScript数组常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 向数组的末尾添加（push）
2. 向数组的末尾删除（pop）
3. 向数组的开头添加元素（unshift）
4. 向数组的开头删除元素（shift）
5. 数组排序（sort）
6. 替换或删除数组中的元素（splice）
7. 数组反转（reverse）
8. 连接两个数组（concat）
9. 从数组中截取元素（slice）
10. 查到数组中的元素 indexOf()
inCludes()
11. 遍历数组 forEach
12. 当数组中所有元素都满足条件，返回true，只要有一个不满足条件，返回 false（every）
13. 当数组中所有元素都不满足条件，返回false,只要有一个条件满足，返回true(some)
14. 数组过滤方法 （filter）
15. 数组映射方法（map）
16. 判断数组中的元素是否满足条件，返回第一个满足条件的下标（findIndex）
17. 判断数组中的元素是否满足条件，返回第一个满足条件的元素（find）
18. 判断一个变量是否是数组（isArray）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2e3aa8eadaf80c1d13186ffa920360d/" rel="bookmark">
			基于Pytorch下在Huggingface中加载数据集参考资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Pytorch下在Huggingface中加载数据集参考资料 1. 加载公共/本地数据集到环境中 加载公共数据集并进行增删改查等预处理步骤Use the Datasets library of Hugging Face in your next NLP project
写脚本scirpt.py加载本地数据集并在github上push pull等My experience with uploading a dataset on HuggingFace’s dataset-hub
如何写一个脚本HuggingFace Datasets来写一个数据加载脚本
2. 加载数据喂给torch Pytorch教程：Dataset和DataLoader
在pytorch中自定义dataset读取数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32abb353f7d038299dedac05fb1d275f/" rel="bookmark">
			C&#43;&#43;1.作业定义学生类Student：每个学生的信息包含有姓名（字符指针）和成绩（int类型），定义两个构造函数2.设计一个点类Point，分别用成员函数、友元函数、普通函数求两点之间的距离。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(程序题)
定义学生类Student：每个学生的信息包含有姓名（字符指针）和成绩（int类型），定义两个构造函数：
1、 定义带两个参数的构造函数，在构造函数中为保存姓名信息的字符指针开辟空间，并向空间中存入表示姓名的字符串。
2、 定义拷贝构造函数，完成深拷贝
3、 定义析构函数，释放资源
4、 统计学生的总人数
编写程序，使用以上定义的三种函数。
使用的主函数进行测试，代码如下： int main()
{
Student stu1(“John”, 98);
Student stu2(stu1);
Student *pstu=new Student(“Tom”,99);
cout&lt;&lt;“共”&lt;&lt;Student::getCount()&lt;&lt;“名学生。”&lt;&lt;endl;
delete pstu;
cout&lt;&lt;“共”&lt;&lt;Student::getCount()&lt;&lt;“名学生。”&lt;&lt;endl;
stu2.setName(“Tom”);
stu1.print_info();
stu2.print_info();
return 0;
}
输出（注意：逗号后有一空格）：
共3名学生。
共2名学生。
name:John, score:98
name:Tom, score:98
#include&lt;iostream&gt; using namespace std; class Student { public: Student(string name, int score) { num++; m_name = new string(name); m_score = score; } Student(const Student&amp; p) { num++; m_name = new string(*p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32abb353f7d038299dedac05fb1d275f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e295e325af79aca2a2fde307c388c18d/" rel="bookmark">
			springboot中@Test注解碰到的问题 详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们初始化springboot项目的时候，会自动给我们导入一下该测试的依赖，springboot项目所有测试类都依赖该依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 初始化给我们导入了import org.junit.jupiter.api.Test类
springboot提供的测试类
package com.zz.es02; import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest class Es02ApplicationTests { @Test void contextLoads() { } } 但@Test还有一个类是import org.junit.Test
package com.zz.es02; import org.junit.Test; import org.springframework.boot.test.context.SpringBootTest; /** * @Author zz * @Date 2021/10/1 19:47 */ @SpringBootTest public class test { @Test //该测试类必须加上public权限修饰符 public void test(){ System.out.println("Method test() should be public"); } } 我们创建测试类的时候很容易导错包，那么springboot提供的这两个测试类，什么区别那？
org.junit.Test
该类定义的方法必须带有权限修饰符
用在2.2.x之前
org.junit.jupiter.api.Test
用在2.2.x之后
2.2.x之后规范使用org.junit.Test不会报异常
但2.2.x之前使用org.junit.jupiter.api.Test会报异常
还有时候会碰到@RunWith(SpringRunner.class)注解的测试类，那么使用该测试类首先要导入以下junit的依赖
&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; 测试类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e295e325af79aca2a2fde307c388c18d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7001596bf38dcb939aee640629c486ad/" rel="bookmark">
			C语言实现——打印菱形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
如何实现
代码实现
定义一个变量line来接收输入的行数
实现上半部分
实现下半部分
代码汇总 前言 输入一个数，打印对应的菱形
该菱形表现为：
从第一行到中间行的行数为输入的数，
从中间行到结束行的行数为输入的数。
如图：输入7，打印以下菱形
如何实现 实现的思路如下：
经过观察可以发现，菱形是由空格和 * 组成的，就可以分四步来实现
1.定义一个变量line来接收输入的行数，假设输入值为7
2.将菱形分解为两部分，上半部分和下半部分
定义一个变量 i ,循环打印上半部分和下半部分每行的内容，i 从0开始
上半部分行数为 line
下半部分行数为 line-1
3.打印上半部分的内容
4.打印下半部分的内容
代码实现 定义一个变量line来接收输入的行数 #include &lt;stdio.h&gt; int main() { int line = 0; scanf("%d",&amp;line); return 0; } 实现上半部分 //上半部分 int i = 0; for (i = 0; i &lt; line; i++) { //打印一行 //空格 int j = 0; for (j = 0; j &lt; line - 1 - i; j++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7001596bf38dcb939aee640629c486ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99890ae02c1299eeb8be6bb95f270304/" rel="bookmark">
			网站的数据库在哪里？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		某个数据库文件夹里。一般会命名为data之类的。你可以搜索一下。另外可以按文件大小排序，一般数据库文件会特别大
一般命名为config.php，或con.php
附： 几个常用CMS网站程序数据库路径地址
帝国CMS /e/class/config.php
ECShop /data/config.php
ShopEX /config/config.php
WordPress /wp-config.php
Joomla! /configuration.php
HDWiki /config.php
PHPwind 8.0 /data/sql_config.php
织梦Dede /data/config.cache.inc.php
phpcms /include/config.inc.php
康盛 UCenter /data/config.inc.php
Discuz! /config.inc.php
UCH /config.php
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e0b27eaf5519f0d5d8cf6806d085ea5/" rel="bookmark">
			eCharts无数据时 清空图形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eCharts中通过后台返回值来渲染的data 数据
发现返回值为空时，图形依然有内容，
1. 将data部分都做空
2.还有一点就是 myChart.setOption(option, true)
这里的true要加上，此处的true会重新渲染，并且不合并上一次的结果， 默认为 false
参考：echarts重绘 &amp;setOption第二个参数的含义_mrhaoxiaojun的博客-CSDN博客_setoption
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63620a260505b015b06d738f0c16fdd0/" rel="bookmark">
			SSL certificate problem
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在clone 仓库的时候报：SSL certificate problem: unable to get local issuer certificate
大概就是 SSL证书过期导致的
解决办法：
直接关闭SSL证书校验
git config --global http.sslVerify false 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83e5cb22dae50e1f2ec29ef5e6a24171/" rel="bookmark">
			lua 贪心算法（找钱算法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 function GetChipsFromNum(num) if not num then return end gLog("--- 开始找钱") local chipType = {1, 2, 5, 10, 50, 100, 500, 1000, 5000} -- 排序 table.sort(chipType, function(a, b) return a &gt; b end) local changeTbl = {} for k,value in pairs(chipType) do local zheng_shu = math.floor(num/value) local yu_shu = num%value if zheng_shu ~= 0 then num = yu_shu table.insert(changeTbl, {chipsType = value, num = zheng_shu}) gLog("币种：{2}-- 数量：{0} --- 余数：{1}", zheng_shu, yu_shu, value) end end return changeTbl end 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4e733aa8cb9c36370c00fa097cb6eda/" rel="bookmark">
			[lua] cannot use ‘...‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [lua] cannot use ‘…’ 使用可变长参数，遇到如下
cannot use '...' outside a vararg function near '...' 出现问题示例：
local testFn = function(cb) cb() end local testFn2 = function(cb, ...) testFn(function() cb(...) end) end 引发错误原因：不可以在一个可变长参数函数的外部使用…，因为 … 是匿名的，lua5.1以后不再为vararg自动创建一个表，需要我们手动创建表：
local testFn = function(cb) cb() end local testFn2 = function(cb, ...) local args = {...} testFn(function() cb(unpack(args)) end) end 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a10f45bf5f2b2eb536d19fa94fe1aa13/" rel="bookmark">
			利用python爬虫程序爬取豆瓣影评
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取至少两个页面的豆瓣影评，包括每一条影评的标题、评论，然后将多条影评信息存入CSV文件。
具体代码如下：
#doubanyingping.py import requests from bs4 import BeautifulSoup import re def getHTMLText(url): kv={'cookie':'viewed="26987890"; bid=LtZlXs-lxWE; __gads=ID=2f05664627755103-228fcabf2eca0085:T=1625664681:RT=1625664681:S=ALNI_MbErnNq9E-gQKSusKFmubZ33JrR1A; gr_user_id=23ab9cd5-12ea-402d-af1f-f82384037c1a; douban-fav-remind=1; ll="108291"; dbcl2="220543507:+d6RaThYFJg"; push_noty_num=0; push_doumail_num=0; _vwo_uuid_v2=D2BBDC590CDF4A6D94F22488FC0507F3C|f20d9349bb838c0ffda7ad25fbd40373; __utmz=30149280.1631793610.4.3.utmcsr=link.csdn.net|utmccn=(referral)|utmcmd=referral|utmcct=/; __utmz=223695111.1631793610.2.2.utmcsr=link.csdn.net|utmccn=(referral)|utmcmd=referral|utmcct=/; ck=re1Y; __utma=30149280.516384608.1625664683.1632279401.1632391188.7; __utmb=30149280.0.10.1632391188; __utmc=30149280; __utma=223695111.1494505190.1631782526.1632279401.1632391188.5; __utmb=223695111.0.10.1632391188; __utmc=223695111; _pk_ref.100001.4cf6=%5B%22%22%2C%22%22%2C1632391194%2C%22https%3A%2F%2Flink.csdn.net%2F%3Ftarget%3Dhttps%253A%252F%252Fmovie.douban.com%252Ftop250%253Fstart%253D0%2526filter%253D%22%5D; _pk_id.100001.4cf6=f45412f108713ba2.1631782532.5.1632391194.1632279427.; _pk_ses.100001.4cf6=*', 'user-Agent':"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.135 Safari/537.36"} try: r = requests.get(url,headers=kv,timeout=30) r.raise_for_status() r.encoding = 'utf-8' return r.text except: return "" def fillReviewList(rlist,html): soup = BeautifulSoup(html,"html.parser") for div in soup.find_all('div',{"class":"main-bd"}): rlist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a10f45bf5f2b2eb536d19fa94fe1aa13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a99123bcfc9678b1f25fd40937293043/" rel="bookmark">
			用python编写程序，输入三门课成绩，计算平均值和总分。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python小作业 a=input("请输入三科成绩(用空格分隔）：") b=a.split(" ") b[0]=int(b[0]) b[1]=int(b[1]) b[2]=int(b[2]) print("均分：%d"%((b[0]+b[1]+b[2])/3)) print("总分：%d"%(b[0]+b[1]+b[2])) 平时的小练习，谢谢大家的关注！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fcd9431d86d9f8331a5bdc2833ecf7d/" rel="bookmark">
			Andoid 仿自如裸眼 3D 效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1.自如的思路分析探究
2.具体实现
2.1 实现效果
2.2 具体实现
2.3 使用步骤
3.补充说明
4.最后
前言 前段时间自如技术团队发布了一篇名为《自如客APP裸眼3D效果的实现》的技术分享文章，简述了通过将图层分为前中后景，监听手机倾斜角度，再根据倾斜角度反向移动前后景，实现类似裸眼 3D 的效果。 该文章中已将思路与原理讲述清楚，抱着好奇心尝试仿现了一下。
1.自如的思路分析探究 1.1 自如 APP 上的裸眼 3D 效果 UI 层面上：将普通的 2D 图像切割出 背景、中景、前景 三个部分
1.2 普通 2D 图像 1.3 切割出来的 背景、 中景 及 前景 ( “ 切割 ” 这部分操作当然是交给专业的 UI 同事来进行)
技术层面上：通过 Android 中的 磁场传感器 和 加速度传感器 监听设备的倾斜角度，保持 中景 不动，根据倾斜角度反向移动 背景 和 前景 ，将 2D 图像转化为景深效果，呈现出类似裸眼 3D 的视觉效果。
1.4 根据倾斜角移动前后景（图片来自自如技术文章） 思路上就是这么清晰和简单，需求如下：
根据设备倾斜角度 平稳移动 前后景，实现裸眼 3D 效果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fcd9431d86d9f8331a5bdc2833ecf7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55b239735181fe64921eb1dd19b648ac/" rel="bookmark">
			算法基础部分6-贪心算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法部分 基础6 一、贪心算法简述 贪心算法的每一步行动总是按照某种指标选取最优的操作来进行该指标，只看眼前并不考虑以后可能造成的影响。证明方法通过替换法和数学归纳法实现。
二、贪心算法例子 1. 圣诞老人的礼物 问题描述：圣诞节来临了，中圣诞老人准备分发糖果，现在有多箱不同的糖果，每箱糖果都有自己的价值和重量，每箱糖果都可以拆分成任意散装组合带走。圣诞老人的驯鹿雪橇最多只能装下重量为 W 的糖果，请问圣诞老人最多能带走多大价值的糖果。
输入：第一行由两个部分组成，分别为糖果箱数正整数 n (1 &lt;= n &lt;= 100), 驯鹿能承受的最大重量正整数 w (0 &lt; w &lt; 10000), 两个数用空格隔开。其余 n 行每行对应一箱糖果，由两部分组成，分别为一箱糖果的价值正整数 v 和重量 正整数 w , 中间用空格隔开。 输出：输出为圣诞老人能带走的糖果的最大总价值，保留 1 位小数。输出为一 行，以换行符结束。 样例输入 输入： 4 15 100 4 412 8 266 7 591 2 输出： 1193.0 分析和程序如下
按礼物的价值/重量比从大到小一次选取礼物，对选取的礼物尽可能地多装，直到 重量为 w , 复杂度 O(nlogn). 程序如下： #include &lt;stdio.h&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const double eps = 1e-6; struct Candy{ int v; int w; }candies[110]; //箱子按单位重量价值排序 bool operator &lt; (const Candy &amp; a, const Candy &amp; b) { return float(a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55b239735181fe64921eb1dd19b648ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8c7a4325cdf84b0f87dffe320bc6dd9/" rel="bookmark">
			修改第三方源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果第三方库通过pip instal *或者conda install *安装，那么直接更改’…/site_packages/…’中相应的.py文件将不起作用（Python: how to edit an installed package?），这是因为使用pip安装库时已经自动编译了python代码，所以更改原始文件并没有改动编译内容。此时可以将该项目源码从GitHub中clone下来，更改源码，然后使用python setup.py build和python setup.py install手动安装。
注意在Pycharm中clone完以后需要标识为Source才能够继续使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64d72bbe5c12fb1e9da290b19972d372/" rel="bookmark">
			Linux系统设置history显示命令运行的时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该设置支持Centos以及Ubuntu系统 linux系统使用history命令可以展示系统在当前用户下运行过的历史命令 从上图中可以看出，在展示历史命令时是不显示命令运行的时间的
为了使得运行history之后展示历史命令运行的时间 修改配置文件：/etc/bashrc、/etc/profile、~/.bashrc（改任意一个都行）
我们这里修改 /etc/profile 文件
IP_USER=`who -u am i 2&gt;/dev/null | awk '{print $NF}' | sed -e 's/[()]//g'` if [ -z $USER_IP ] then USER_IP=`hostname` fi HISTTIMEFORMAT="%F %T: " export HISTTIMEFORMAT 修改之后重新加载文件：
source /etc/profile 运行history查看效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aac04b9ada62af7a54ed80da5803cbef/" rel="bookmark">
			VBA操作剪切板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VBA操作剪切板 一，利用MsForms.DataObject操作1，什么是DataObject对象2，用vba操作剪切板注意3，声明方式4，文本写入剪切板5，读取剪切板文本 二，利用API操作剪切板1，用到得API函数2，写入剪切板3，读取4， 提取剪贴板所有数据格式的代码5，整理一个上面用得全部api 一，利用MsForms.DataObject操作 1，什么是DataObject对象 传输操作中使用的格式化文本数据的保留区域。 还保留 DataObject 中存储的文本块所对应的 格式 的列表
DataObject 可包括一段针对剪贴板文本格式的文本和一段针对每种其他文本格式（如自定义格式和用户定义的格式）的文本。
DataObject 与剪贴板不同。 DataObject 支持涉及剪贴板和文本的拖放操作的命令。 在启动涉及剪贴板的操作（如 GetText）或拖放操作时，该操作中涉及的数据将移动到 DataObject。
DataObject 的工作方式与剪贴板类似。 如果您将文本字符串复制到 DataObject，则 DataObject 将存储文本字符串。 如果您将同一格式的第二个字符串复制到 DataObject，则 DataObject 将弃用第一个文本字符串并存储第二个字符串的副本。 它将存储一段指定格式的文本并保留最近操作中的文本。
2，用vba操作剪切板注意 不要打开剪切板，同时只能一个操作，否则强制退出
3，声明方式 前期绑定
勾选–&gt;Micorosoft Forms 2.0 Object LIbrary
后期绑定
CreateObject("new:{1C3B4210-F441-11CE-B9EA-00AA006B1A69}")
4，文本写入剪切板 Sub test() Dim jq As New MSForms.DataObject Dim ss As String ss = "测试文本" '文本变量 jq.SetText ss '赋值给DataObject jq.PutInClipboard '写入剪切板 End Sub 5，读取剪切板文本 Sub test2() Dim jq As New MSForms.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aac04b9ada62af7a54ed80da5803cbef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2849fc4699956bc572c40e6f206b881c/" rel="bookmark">
			【从零学习硬件】I2C总线协议学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I2C协议 I2C是由 Phiilps提出的，目前被广泛应用在系统内多个IC间的通讯。
I2C是每个连接到总线的设备都有一个独立的地址，主机可以通过该地址来访问不同设备。主机通过SDA线发送设备地址（SLAVE_ADDRESS）查找从机，SLAVE_ADDRESS可以是7位或10位，紧跟着SLAVE_ADDRESS的一个数据位用来表示数据传输方向，即第8位或11位。
物理层介绍 I2C总线是一种双向的同步串行总线，它支持设备之间的短距离通信，经常用于处理器和一些外围设备之间的接口通信。
通信模式
速率
电容负载
上拉电阻
标准模式
100Kbps
400pF
快速模式
400Kbps
200pF
高速模式
3.4Mbps
一个支持多个设备的总线，I2C总线物理层由两根线组成：串行时钟线SCL、串行数据线SDA。由于这两根线都是开漏输出结构，因此必须都接上拉电阻到高电平，因此当总线处于空闲状态时，两根线都处于高电平状态。
而且各个设备之间的SCL和SDA线都是线与关系。I2C总线上扩展的器件的数量主要由电容负载来决定，其负载能力为400pF。I2C总线具有极低的电流消耗。0时表示写；1时表示读。
I2C总线的上拉电阻的阻值要精心考虑，
上拉电阻的阻值太大，则由于I2C设备输入端的输入电容的存在，会造成信号上升沿和下降沿变缓，以至于不能满足I2C设备的建立时间和保持时间，造成通信的错误发生；上拉电阻的阻值过小，则会造成较大的功率损耗。因此I2C通信的上拉电阻的阻值要满足设备上升沿和下降沿要求的同时尽量选择较大的阻值，以降低消耗的功耗问题。 协议相关的硬件相关的时序描述详见下图
硬件时序及电平要求详见下表
协议层 2C总线上的每一个设备都可以作为主设备或者从设备，而且每一个设备都会对应一个唯一的设备地址。
通常将CPU模块作为主设备，而挂接在总线上的其他设备作为从设备。
I2C总线上的主设备与从设备之间以8字节为单位进行双向数据传输，并且每个单位后还须跟着一位ACK位。
其中数据在SCL处于低电平时被放到SDA数据线上，在SCL处于高电平时进行数据的采样。
I2C总线的传输时序包括：开始条件、地址帧、数据帧、停止条件、重复开始条件。
数据有效性 SCL为高电平时表示有效数据，SDA为高电平表示“1”，低电平表示“0”；
SCL为低电平时表示无效数据，此时SDA会进行电平切换，为下次数据表示做准备。
起始条件S和停止条件P 起始条件S：标识传输正式开始，当SCL高电平时，SDA由高电平向低电平转换； 停止条件P：当SCL高电平时，SDA由低电平向高电平转换。 起始和停止条件一般由主机产生。总线在起始条件后处于busy，停止条件的某段时间后，总线才再次处于空闲状态。
数据传输格式 传输的每个字节必须为8位，而总字节数不受限制。每个字节后必须跟一个响应位。首先开始传输的是数据最高位，即MSB位。如果此时从机正忙于其他功能，如正在中断服务程序，则需要使SCL线保持低电平迫使主机进入等待状态，直到从机准备完成。
数据接收方收到传输的一个字节数据后，需要给出响应，此时处在第九个时钟，发送端释放SDA线控制权，将SDA电平拉高，由接收方控制。若希望继续，则给出“应答（ACK）”信号，即SDA为低电平；反之给出“非应答（NACK）”信号，即SDA为高电平。
通讯过程 地址帧：地址帧总是在一次通信的最开始出现，通常包括7位的设备地址(MSB)和最后1位的读写控制位(1表示读，0表示写)。接下来是1位的NACK/ACK，当这8位地址发送完成后，Slave设备获得SDA的控制权，此时Slave设备应该在第9个时钟脉冲之前回复一个ACK(将SDA拉低)以表示数据接收正常，否则表示数据接受失败，控制权交由Master设备处理。
数据帧：在地址帧发送之后，就可以开始传送数据了。每个数据帧8位，数据帧的数量可以是任意的，直到产生停止条件。每一个8位数据传输完成之后，接收方就需要回复一个ACK/NACK。
最后在产生一个停止条件结束整个通信过程。
注1：上面都是以8位为一个单元进行的数据传输，其实I2C也是支持10位地址空间的。对于10位地址的传输时序，需要2个地址帧完成地址的传输，其他和8位的传输协议相同。下图为10位地址传输时序图。
通讯过程中会不断地往状态寄存器I2C_SRx写入参数，我们可以通过读取相应位的值来了解通讯状态。
主机产生起始信号S，产生“EV5”事件，对I2C_SR1寄存器的SB位置1，表示起始信号已发送；接下来发送设备地址，并等待从机应答（A），从机应答后产生“EV6”和“EV8”事件，此时I2C_SR1寄存器的ADDR位和TxE位被置1。ADDR置1表示地址已发送，TxE置1表示数据寄存器为空；往数据寄存器I2C_DR写入要发送的数据，此时TxE被置0，数据寄存器非空，通过SDA信号线逐位发送数据后，又会产生“EV8”事件，TxE位又被置1，并且从机给出应答。那么，重复这个过程，就可以连续发送多个字节的数据了；数据发送完成后，产生停止信号P，产生“EV8_2”事件，此时I2C_SR1的TxE位和BTF位被置1，BTF位被置1表示字节发送结束。那么至此，通讯结束。 以上的过程会在I2C读写数据编程中作为参考。
另外，如果设置控制寄存器I2C_CR2相应位的中断使能，则以上事件产生时，都会进入I2C中断，进入中断程序后再通过检查寄存器的相应位来判断具体为哪个事件。
而接收数据的过程，也就是读数据的过程，有两次起始信号。第一次起始信号后，发送从设备地址找到从设备后，向从设备内部写入需要读取的数据地址；在第二次起始信号后才开始读取数据。
时钟同步：低电平由时钟低电平最长的器件决定 从机希望主机降低传送速度，通过将SCL主动拉低延长其低电平时间来通知主机，当主机在准备下一次传送发现SCL的电平被拉低时就进行等待，直至从机完成操作并释放SCL线的控制控制权。这样，主机实际上受到从机的时钟同步控制。
可见SCL线上的低电平是由时钟低电平最长的器件决定；高电平的时间由高电平时间最短的器件决定。这就是时钟同步，它解决了I2C总线的速度同步。
I2C仲裁 IIC设备对总线的操作仅有“把线路接地”——输出逻辑0。基于IIC总线的设计，线路上不可能出现电平冲突现象。
如果一设备发送逻辑0，其他发送逻辑1，那么线路看到的只有逻辑0。也就是说，发送逻辑0的始终是“赢家”。
总线的物理接法允许主设备往总线写数据的同事读取数据。这样两主设备争总线的时候“赢家”并不知道竞争的发生，只有“输家”发现了冲突——当写一个逻辑1，却读到了0——而退出竞争。
假设主控器1要发送的数据DATA1为“101 ……”；主控器2要发送的数据DATA2为“1001 ……”总线被启动后两个主控器在每发送一个数据位时都要对自己的输出电平进行检测，只要检测的电平与自己发出的电平一致，他们就会继续占用总线。在这种情况下总线还是得不到仲裁。当主控器1发送第3位数据“1”时（主控器2发送“0” ），由于“线与”的结果SDA上的电平为“0”，这样当主控器1检测自己的输出电平时，就会测到一个与自身不相符的“0”电平。这时主控器1只好放弃对总线的控制权；因此主控器2就成为总线的唯一主宰者。
不难看出：
① 对于整个仲裁过程主控器1和主控器2都不会丢失数据；
② 各个主控器没有对总线实施控制的优先级别；
③总线控制随即而定，他们遵循“低电平优先”的原则，即谁先发送低电平谁就会掌握对总线的控制权。
根据上面的描述，“时钟同步”与“总线仲裁”可以总结如下规律：
①主机通过检测SCL上的电平来调节与从机的速度同步问题——时钟同步；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2849fc4699956bc572c40e6f206b881c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e824f905f7818a16de7fdcc503e252a8/" rel="bookmark">
			浅谈三极管、运放、MOS管驱动 的常见电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浅谈三极管、运放、MOS管驱动的常见电路 前言一、三极管的应用电路二、运算放大器的应用电路三、MOS管驱动电路总结 前言 随着对电路应用能力的要求越来越高，模拟电路中的三极管和运放显得越来越重要，很多人都开启了模拟电路的学习，本文就介绍了三极管和运放中常见电路及应用的基础内容。
一、三极管的应用电路 三极管有三个工作状态：截止、放大、饱和，放大状态很有学问也很复杂，多用于集成芯片，比如运放……
其实，对信号的放大我们通常用运放处理，三极管更多的是当做一个开关管来使用，且只有截止、饱和两个状态。截止状态看作是关，饱和状态看作是开。Ib≥1mA时，完全可以保证三极管工作在饱和状态，对于小功率的三极管此时Ic为几十到几百mA，驱动继电器、蜂鸣器等功率器件绰绰有余。
常见的例子有：
把三极管箭头理解成一个开关，如下图为NPN型三极管，按下开关S1，约1mA的Ib流过箭头，三极管工作在饱和状态，c极到e极完全导通，c极电平接近0V(GND)，负载RL两端压降接近5V。
Ib与Ic电流都流入e极，根据电流方向，e极为低电平，应接地，c极接负载和电源。对于NPN三极管更应该在b极加一个下拉电阻，一是为了保证b、e极间电容加速放电，加快三极管截止；二是为了保证给三极管b极一个已知逻辑状态，防止控制输入端悬空或高阻态时对三极管工作状态的不确定。
如下图为PNP型三极管，按下开关S2，约1mA的Ib流过箭头，三极管工作在饱和状态，e极到c极完全导通，c极电平接近5V，负载RL两端压降接近5V。
Ib与Ic电流都流出e极，根据电流方向，e极为高电平，应接电源，c极接负载和地；对于PNP三极管，更应该在b极加一个上拉电阻，原理同上。
下图NPN三极管，对于感性负载，必须在负载两端并联一个反向续流二极管，因为三极管在关断时，线圈会自感产生很高的反向电动势，而续流二极管提供的续流通路，同时钳位反向电动势，防止击穿三极管。续流二极管的选型必须是快恢复二极管或肖特基二极管，两者响应速度快。
为三极管延时导通，快速关断的一个仿真电路，D1、R2、C1、D2构成延时导通Q2的回路，C1的电压为12V的时候Q2导通，R3、Q1、R4、R1构成快速关断Q2的回路，C1通过R3和Q1快速放电。
总结：
（1）对于NPN三极管，在不考虑三极管的情况下，b极电阻与下拉电阻的分压必须大于0.7V，PNP同理。
（2）b极电流必须≥1mA可保证三极管处于饱和状态，此时Ic满足三极管 大的驱动能力。
（3）另外，对于三极管的放大倍数β，指的是输出电流的驱动能力放大了β，比如100倍，并不是把输出电流真正的放大了100倍。
二、运算放大器的应用电路 运算放大器组成的电路五花八门，令人眼花瞭乱，是模拟电路中学习的重点。在分析它的工作原理时倘没有抓住核心，往往令人头大。在介绍运算放大器电路的时候，无非是先给电路来个定性，比如这是一个同向放大器，然后去推导它的输出与输入的关系，然后得出Vo=(1+Rf)Vi，那是一个反向放大器，然后得出Vo=-RfVi……最后学生往往得出这样一个印象：记住公式就可以了!如果我们将电路稍稍变换一下，他们就找不着北了!
今天，芯片级维修教各位战无不胜的两招，这两招在所有运放电路的教材里都写得明白，就是“虚短”和“虚断”，不过要把它运用得出神入化，就要有较深厚的功底了。
虚短和虚断的概念
由于运放的电压放大倍数很大，一般通用型运算放大器的开环电压放大倍数都在80dB以上。而运放的输出电压是有限的，一般在 10 V～14 V。因此运放的差模输入电压不足1 mV，两输入端近似等电位，相当于 “短路”。开环电压放大倍数越大，两输入端的电位越接近相等。
“虚短”是指在分析运算放大器处于线性状态时，可把两输入端视为等电位，这一特性称为虚假短路，简称虚短。显然不能将两输入端真正短路。
由于运放的差模输入电阻很大，一般通用型运算放大器的输入电阻都在1MΩ以上。因此流入运放输入端的电流往往不足1uA，远小于输入端外电路的电流。故通常可把运放的两输入端视为开路，且输入电阻越大，两输入端越接近开路。
“虚断”是指在分析运放处于线性状态时，可以把两输入端视为等效开路，这一特性 称为虚假开路，简称虚断。显然不能将两输入端真正断路。
在分析运放电路工作原理时，首先请各位暂时忘掉什么同向放大、反向放大，什么加法器、减法器，什么差动输入……暂时忘掉那些输入输出关系的公式……这些东东只会干扰你，让你更糊涂﹔也请各位暂时不要理会输入偏置电流、共模抑制比、失调电压等电路参数，这是设计者要考虑的事情。我们理解的就是理想放大器(其实在维修中和大多数设计过程中，把实际放大器当做理想放大器来分析也不会有问题)。
好了，让我们抓过两把“板斧”------“虚短”和“虚断”，开始“庖丁解牛”了。*
图一运放的同向端接地=0V，反向端和同向端虚短，所以也是0V，反向输入端输入电阻很高，虚断，几乎没有电流注入和流出，那么R1和R2相当于是串联 的，流过一个串联电路中的每一只组件的电流是相同的，即流过R1的电流和流过R2的电流是相同的。流过R1的电流I1 = (Vi - V-)/R1 ……a 流过R2的电流I2 = (V- - Vout)/R2 ……b V- = V+ = 0 ……c I1 = I2 ……d 求解上面的初中代数方程得Vout = (-R2/R1)Vi 这就是传说中的反向放大器的输入输出关系式了。
图二中Vi与V-虚短，则 Vi = V- ……a 因为虚断，反向输入端没有电流输入输出，通过R1和R2 的电流相等，设此电流为I，由欧姆定律得：I = Vout/(R1+R2) ……b Vi等于R2上的分压， 即：Vi = IR2 ……c 由abc式得Vout=Vi*(R1+R2)/R2 这就是传说中的同向放大器的公式了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e824f905f7818a16de7fdcc503e252a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/869d220a381dc866fd4167805e03200d/" rel="bookmark">
			如何通过 AirPlay 镜像您的 Mac 显示器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AirPlay 可让您将 Mac 显示器的内容流式传输到兼容设备，例如 Apple TV、支持 AirPlay 的第三方电视机或 Squirrel 的 Reflector 软件，它将许多设备转换为 AirPlay（和 Google Cast）目的地。
使用起来轻而易举：在 macOS 中打开“显示”首选项面板，然后从“隔空播放显示”或“添加显示”弹出菜单中选择目标。这会将 AirPlay 目标添加为 Mac 的附加显示器。
但是，如果您希望该显示器镜像您的屏幕（或主显示器）而不是扩展桌面呢？这个过程不是很明显——部分是因为你必须设置镜像的顺序，部分是因为 Apple 现在有三个关于如何扩展或镜像桌面的“时代”。Apple 在 10.15 Catalina 中进行了更改，该更改保留在 11 Big Sur 中，并且即将在 macOS 12 Monterey 中推出一个完全不同且卓越的流程，该流程目前处于 Beta 测试阶段。
让我们来看看这些版本中的三种不同的 macOS 方法，以便您可以找到适合您 Mac 的选项。
在 Mojave 及更早版本中通过 AirPlay 镜像
在 Mojave 和更早版本中，如果有可用的 AirPlay 屏幕目标并且您在“显示”首选项窗格中选中了“可用时在菜单栏中显示镜像选项”，macOS 会在菜单栏中放置一个 Apple TV 图标。您还可以从 AirPlay 显示菜单中选择目的地。
只有在您选择 AirPlay 目的地并开始共享后，您才能选择是否镜像。在 Apple TV 菜单中，您可以从标有“AirPlay: Destination Name ”的灰色项目下方进行选择， 以从您的内部或任何其他显示器镜像（如“镜像显示名称”），或者选择“用作 单独的显示器”以扩展您的桌面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/869d220a381dc866fd4167805e03200d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/425a4bb4ff13bf9ed0efb13b4cafd39e/" rel="bookmark">
			Final Cut Pro中文新手教程 (八) 如何导出视频「下」
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，欢迎来学习Final Cut Pro的基础教程，我是Mac小伯通，本期视频讲解——如何导出视频「下」。
本教程基于Final Cut Pro10.4.10，但是适用于整个Final Cut Pro X系列，各子版本都是差不多的，大同小异。
单个片段导出成视频
在素材窗口中选中单个片段，可以看到有黄色高亮，按快捷键cmd+e调出导出窗口可以直接导出成视频
多个片段导出成视频
除可以选择单个片段，也可以选择多个片段鼠标按shirt全部选中，如图：
按快捷键cmd+e可以看到也可以导出多个不同的一个片段，可以直接导出成视频
导出成图片
因为截图没有快捷键所以我们必须选择图标或者说是在文件共享这边进行
只有这个母版文件才可以使用cmd+e的一个快捷键
如果要截图的话也是一样的我们选中片段点击导出图标截图
可以看到这一帧的截图就被我们截图下来了，非常方便，设置也是一样的操作。
单独范围的选择
按快捷键i设置开头然后鼠标移到左边或者右边设置O设置结尾
就可以选择一小段的一个范围进行一个导出，可以用i和O进行一个片段范围的导出
导出多个i和O
我们在时间线窗口中是没有方法的，但是我们在素材窗口中是有方法的
我们可以按住command键，鼠标进行一个拖拽，就会有两个片段范围进行一个存在
按快捷键cmd+e调出导出窗口看到可以导出多个片段直接导出成视频，非常方便
除可以按cmd来进行多个片段操作，也可以按快捷键cmd+shift+i和cmd+shift+o
当我们使用cmd+shift+i和cmd+shift+o的时候，i和O就可以同时存在多个
但是如果我们仅仅只用i和O是不可以的，可以看到仅仅只用i和O其他都会消失的
这就是我们如何使用多个i和O的一个方法
我们想取消的话也可以直接按住option+x取消它的一个范围选择
我们继续来选择一个片段，我们点击导出母版文件
选择母带录制的时候，角色栏是可以进行一个更改的 Macv.comMacv.com
这边选择发布下面的随便任意的一个选项我们的角色是无法进行一个更改的
你们导出的话就只能选择母带录制而不能选择发布因为发布的话角色是无法进行一个更改的
发布选项可以修改分辨率，选中片段质量决定分辨率的高低
小编选中的片段是4k视频，所以分辨率最高是3840*2160
母带录制和网页托管选择
我们以4K的一个片段为例按cmd+e导出，母带录制和网页托管都是mov的格式
在不考虑这个角色的一个前提下
如果我们选择是网页托管下的mov选择一个4K的分辨率可以看到它是57.2兆
如果我们选择母在录制里面，它是一个98.5兆接近了两倍的一个大小
我们选择母带录制这个视频和音频母带它就是极限画质
如果我们选择网页托管他就是中上的一个画质，即使中上画质也是十分清楚的，根据自己需要进行选择
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0967499dbd9597f4f4eac12dafaa9f1/" rel="bookmark">
			C# 使用Minio Api上传图片无法预览，直接在管理界面上传的图片可以预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# 使用minio api上传图片无法预览，直接在管理界面上传的图片可以预览 记录一下最近在使用minio api上传图片到minio服务器遇到一些问题，如下图使用minio api PutObjectAsync方法上传到minio
上传至minio管理界面，然后是没有预览的操作的
找了许多原因，一开始以为是文件的问题，由于公司文件加密，所以一直觉得是加密的问题，直到拿到自己电脑测试，才发现也会出现同样的问题，最后查看官方文档，发现是 PutObjectAsync方法如果不为Content-Type参数传值，默认就是“application/octet-stream”，那么我就在想如果是图片，应该不是这个类型，最后通过获取本地文件的类型，告诉minio api 我传递的是什么类型的文件，才解决问题，代码如下：
使用 C# Http.Web下的MimeMapping.GetMimeMapping()方法获取用户上传的文件类型，最终上传。
效果图如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec7c27431a806c4ff024d3749462463d/" rel="bookmark">
			Qt使用Ogre引擎开发3d项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于个人开发者来说，选择开源工具应该是最好的选择。
此次选择 开源建模软件Blender + 开源3d渲染引擎Ogre + 开源程序框架Qt来实现。
Ogre下载
https://www.ogre3d.org/
Blender下载
https://www.blender.org/
Blender导出Ogre模型
https://github.com/OGRECave/blender2ogre
Qt调用Ogre
https://ogrecave.github.io/ogre/api/latest/setup.html
https://wiki.ogre3d.org/Integrating+Ogre+into+QT5
继承基类，创建自己的app类
class MyTestApp : public OgreBites::ApplicationContextQt, public OgreBites::InputListener { public: MyTestApp(); bool keyPressed(const OgreBites::KeyboardEvent&amp; evt); bool mouseMoved(const OgreBites::MouseMotionEvent&amp; evt); bool mousePressed(const OgreBites::MouseButtonEvent &amp;evt); bool mouseReleased(const OgreBites::MouseButtonEvent &amp;evt); void setup(void); Ogre::SceneNode* node; bool mPressed; }; 。。。
然后获取Ogre的窗口widget
{ ... mApp = new MyTestApp(); // mApp-&gt;useQtEventLoop(true); QWindow *mWindow = new QWindow(); // mApp-&gt;createWindow(mWindow); mApp-&gt;injectMainWindow(mWindow); mApp-&gt;initApp(); //由window创建的widget auto widget = QWidget::createWindowContainer(mWindow); //我自己做的一些修正。因为原Ogre窗口老是超出父控件的空间。 OgreView *v = new OgreView(); v-&gt;setOgreWidget(widget); //塞到对应位置 QVBoxLayout *mLayout = new QVBoxLayout(); mLayout-&gt;addWidget(v); .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec7c27431a806c4ff024d3749462463d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/342024ed173b7939304c87155450d83d/" rel="bookmark">
			如何在 Linux 中创建并运行 Shell 脚本（Bash 初学者教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、创建并运行第一个 shell 脚本2、将 shell 脚本转换为 bash 脚本3、为什么大多数 shell 脚本都包含 #! /bin/bash 在 shell 脚本的开头？4、将 shell 脚本添加到 PATH（以便它可以从任何目录运行） 1、创建并运行第一个 shell 脚本 首先创建一个名为 scripts 的新目录，它将托管我们所有的 bash 脚本。
mkdir scripts cd scripts 现在在这个“脚本目录”中，使用 cat 命令创建一个名为 hello.sh的新文件：
cat &gt; hello.sh 通过在终端中键入以下内容，在其中插入以下行：
echo 'Hello, World!' 按 Ctrl+D 将文本保存到文件中，同时从 cat 命令中出来。
你还可以使用基于终端的文本编辑器，如 Vim、Emacs或 Nano。如果你使用的是桌面 Linux，还可以使用图形文本编辑器（如 Gedit）将文本添加到此文件中。
基本上你是在使用echo 命令来打印“Hello World”。你可以直接在终端中使用此命令，但在本测试中，你将通过 shell 脚本运行此命令。
现在使用 chmod 命令使文件 hello.sh 可执行，如下所示：
chmod u+x hello.sh 最后，通过在 hello.sh 前面加上“bash”来运行你的第一个 shell 脚本：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/342024ed173b7939304c87155450d83d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f71228e32ac0dcaa226d5f0e6e997be9/" rel="bookmark">
			Final Cut Pro 中文基础教程(四八)精确度编辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为大家带来Final Cut Pro 中文基础教程，此教程非常适合刚接触Final Cut Pro的小白，或者想进阶的一些新手。想快点熟悉FCPX这款视频剪辑插件的朋友可以收藏学习哦！今天我们来说一说精确度编辑。
在Final Cut Pro中有两种方法可以进入精确度编辑器
首先第一种方法就是我们在片段的开头和结尾，当鼠标放到这里的时候我们可以看注意到我的选择工具的图标已经变了，当图标变成这个的时候双击它就可以进入精确度编辑器
还有另外一个方法就是我们选中任意一个片段按Control+E这样的话也可以快速的进入它的一个精确度编辑器
可以在这里面就进行一个画面的延长或者缩短，往右边它就会整体都延长，往左边就可以整体缩短
全部选中这些片段，找到修剪工具结合可以把它缝合成一个完整的片段
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2193ce9bab136c6df21279fc4ad7e7a5/" rel="bookmark">
			初识Python 和搭建Python环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程语言是什么？ Python 代码示例：
print("hello world") 这段代码在稍后的课程就会学习到，它能让电脑在屏幕上打印"hello world"这样一段内容。
可以看到这段代码是由英文单词和标点符号来组成的，实际上编程就像是写作文，只是书写的时候必须要遵守一些特殊的格式规定。
但是计算机是基于二进制的 0 和 1 来处理运算，所以当今的世界才会叫数字化时代。
这种 0 和 1 的组合指令又叫做机器语言，机器语言是电脑能够直接处理的指令，换而言之电脑根本不认识我们编程时写的英文单词和标点符号。
那么我们编程写的代码究竟如何控制电脑运行的？
就像我们和外国人说话要把内容翻译成英语一样。如果我们的代码想要运行，就必须要经过翻译处理，把 Python 语言的代码翻译成机器语言，这个过程叫做 编译，用来处理代码编译的软件叫做 编译器。
编程语言就是用来定义 计算机程序 的形式语言。我们通过编程语言来编写程序代码，再通过语言处理程序执行向计算机发送指令，让计算机完成对应的工作。
简单来说，编程语言就是人类和计算机进行交流的语言。
** **
计算机是如何处理程序的？ 按照冯·诺依曼存储程序的原理，计算机的工作流程大致如下：
用户打开程序，程序开始执行；操作系统将程序内容和相关数据送入计算机的内存；CPU根据程序内容从内存中读取指令；CPU分析、处理指令，并为取下一条指令做准备；取下一条指令并分析、处理，如此重复操作，直至执行完程序中全部指令，最后将计算的结果放入指令指定的存储器地址中。
Python简介 Python是由荷兰人吉多·范罗苏姆（Guido von Rossum，后面都称呼他为Guido）发明的一种编程语言。
Python的历史
** **
1989年圣诞节：Guido开始写Python语言的编译器。
1991年2月：第一个Python解释器诞生，它是用C语言实现的，可以调用C语言的库函数。
1994年1月：Python 1.0正式发布。
2000年10月：Python 2.0发布，Python的整个开发过程更加透明，生态圈开始慢慢形成。
2008年12月：Python 3.0发布，引入了诸多现代编程语言的新特性，但并不完全兼容之前的Python代码。
说明：大多数软件的版本号一般分为三段，形如A.B.C，其中A表示大版本号，当软件整体重写升级或出现不向后兼容的改变时，才会增加A；B表示功能更新，出现新功能时增加B；C表示小的改动（例如：修复了某个Bug），只要有修改就增加C。
Python的优点
Python的优点很多，简单为大家列出几点：
简单明确，跟其他很多语言相比，Python更容易上手。
开放源代码，拥有强大的社区和生态圈。
能够在Windows、macOS、Linux等各种系统上运行。
Python的应用领域
目前Python在Web服务器应用开发、云基础设施开发、网络数据采集（爬虫）、数据分析、量化交易、机器学习、深度学习、自动化测试、自动化运维等领域都有用武之地。
安装Python环境 想要开始你的Python编程之旅，首先得在计算机上安装Python环境，简单的说就是得安装运行Python程序的工具，通常也称之为Python解释器。我们强烈建议大家安装Python 3的环境，很明显它是目前更好的选择。
Windows环境
可以在Python官方网站（Download Python | Python.org）找到下载链接并下载Python 3的安装程序。
对于Windows操作系统，可以下载“executable installer”。
需要注意的是，如果在Windows 7环境下安装Python 3，需要先安装Service Pack 1补丁包，大家可以在Windows的“运行”中输入winver命令，从弹出的窗口上可以看到你的系统是否安装了该补丁包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2193ce9bab136c6df21279fc4ad7e7a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50d45253cc9a4587ec8581e957bb5321/" rel="bookmark">
			【B站视频教程笔记】基于VSCode和CMake实现C/C&#43;&#43;开发 | Linux篇（gcc/g&#43;&#43;）（安装、配置、使用详细教程）（VSCode教程）（CMake教程）（精！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于VSCode和CMake实现C/C++开发 | Linux篇
文章目录 目录结构文件编辑vim（编辑器之神，linux里可以畅通无阻，必学，但不是现在！） 安装GCC和GDBg++编译过程动手操作 g++编译参数编译带调试信息的可执行文件 -g优化源代码 -O[n]案例：优化等级 -l （小写L）指定库文件和 -L 指定库文件路径-I （大写i）指定头文件搜索目录打印警告信息 -Wall 和关闭警告信息 -w设置编译标准 -std=c++xx指定输出文件名 -o-D定义宏（选择开启宏或关闭宏）使用 man gcc 或 man g++ 查看手册 实战：g++命令行编译编译生成可执行文件编译生成静态库（扩展名.a），并链接生成可执行文件编译生成动态库（扩展名.so），并链接生成可执行文件 GDB调试器（GNU Debugger）【实战】命令行调试相应快捷指令 VSCode在linux16.04下的安装及使用（以及插件，比如CMake）安装使用，自己看视频吧插件安装高频使用快捷键或操作 Cmake使用 目录结构 Bin：全称binary，含义是二进制。该目录中存储的都是一些二进制文件，文件都是可以被运行的。
Dev：该目录中主要存放的是外接设备，例如盘、其他的光盘等。在其中的外接设备是不能直接被使用的，需要挂载（类似window下的分配盘符）。
Etc：该目录主要存储一些配置文件。
Home：表示“家”，表示除了root用户以外其他用户的家目录，类似于windows下的User/用户目录。
Proc：全称process，表示进程，该目录中存储的是Linux运行时候的进程。
Root：该目录是root用户自己的家目录。
Sbin：全称super binary，该目录也是存储一些可以被执行的二进制文件，但是必须得有super权限的用户才能执行。
Tmp：表示“临时”的，当系统运行时候产生的临时文件会在这个目录存着。
Usr：存放的是用户自己安装的软件。类似于windows下的program files。（应该说错啦！！这是unix系统资源目录）
Var：存放的程序/系统的日志文件的目录。
Mnt：当外接设备需要挂载的时候，就需要挂载到mnt目录下。
d表示文件夹，- 表示文件 树工具
sudo apt install tree 文件编辑 vim（编辑器之神，linux里可以畅通无阻，必学，但不是现在！） 还介绍了gedit、nano编辑器，，鸡肋
安装GCC和GDB 每次安装新的程序之前都要运行下这个：
sudo apt-get update 安装gdb
sudo apt install build-essential gdb 查看版本
gcc --version g++ --version gdb --version 安装CMake
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50d45253cc9a4587ec8581e957bb5321/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf7474e088135178e6acdae04b9dd95c/" rel="bookmark">
			ggplot2分组柱图barplot添加误差线以及显著标记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分组barplot添加均值标准差误差线显著标记 library(ggplot2) library(ggpubr) mydata1 &lt;- data.frame(fenzu=rep(c(1,2),each=15),shijain=rep(c("入院","7天","14天"),each=5),value=seq(1,30,1)) mydata1$fenzu &lt;- as.factor(mydata1$fenzu) mydata1$shijain &lt;- as.factor(mydata1$shijain) mydata1$shijain &lt;- factor(mydata1$shijain,levels = unique(mydata1$shijain)) p&lt;- ggplot(mydata1, aes(x = shijain, y = value, fill = fenzu)) + #下面fun后边跟的median或者mean一定要加引号！！否则会报错 geom_bar(stat = "summary", fun ="mean", position = position_dodge(),alpha=0.7) + stat_summary(fun.data = 'mean_sd', geom = "errorbar", colour = "black", width = 0.15,position = position_dodge( .9)) #p#注意调透明度的位置 q &lt;- p +　stat_compare_means(method = "wilcox.test",method.args = list(alternative = "two.sided")) q &lt;- q+scale_fill_brewer(palette = 'Accent')+ theme(text = element_text(family = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf7474e088135178e6acdae04b9dd95c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44611ed6ead3fdbfd99134009bd6e588/" rel="bookmark">
			Chrome浏览器本地调试：阻止不安全、本地网络请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天打开Chrome浏览器，本地开发联调突然报错。
Access to script at 'http://localhost:8001/xxx.js' from origin 'http://xxx.xxx.xxxx.com' has been blocked by CORS policy: The request client is not a secure context and the resource is in more-private address spacelocal.
报错说我本地的文件因为跨域安全被阻止访问了。那我们本地调试就改一下Chrome的配置吧。
打开新的网页，浏览器输入：chrome://flags/#block-insecure-private-network-requests
重新启动一下浏览器，问题就解决啦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31c09b6cc56baaf965ab5f734646f0d1/" rel="bookmark">
			ggplot2分组箱线图添加均值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ggplot2分组箱线图添加均值 一、不分组的简单箱线图加均值stat_summary分组箱线图 一、不分组的简单箱线图加均值 代码如下（示例）：
# Library library(ggplot2) # create data names=c(rep("A", 20) , rep("B", 8) , rep("C", 30), rep("D", 80)) value=c( sample(2:5, 20 , replace=T) , sample(4:10, 8 , replace=T), sample(1:7, 30 , replace=T), sample(3:8, 80 , replace=T) ) data=data.frame(names,value) # plot p &lt;- ggplot(data, aes(x=names, y=value, fill=names)) + geom_boxplot(alpha=0.7) + stat_summary(fun="mean", geom="point", shape=20, size=2.5, color="red", fill="red",alpha=0.7) + theme(legend.position="none") + scale_fill_brewer(palette="Accent") p stat_summary 用到了stat_summary函数算均值，具体介绍一下
代码如下（示例）：（图片略，直接跑可以跑出来）
library(tidyverse) library(gapminder) #---------------------- gapminder %&gt;% ggplot(aes(x = year, y = lifeExp)) + stat_summary(fun = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31c09b6cc56baaf965ab5f734646f0d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97eb57e51ce19dfa40c15af01d6a36b8/" rel="bookmark">
			生信入门（四）——使用DESeq2进行RNA-seq数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生信入门（四）——使用DESeq2进行RNA-seq数据分析 文章目录 生信入门（四）——使用DESeq2进行RNA-seq数据分析一、学习目标二、实验数据1、数据来源2、建模计数数据3、转录本丰度4、salmon定量 三、用tximport导入R1、指定文件位置2、将转录本映射到基因3、tximport命令 今日学习内容DESeq2分析RNA-seq数据 一、学习目标 直观地评估 RNA-seq 数据的质量对 RNA-seq 数据进行基本的差异分析将 RNA-seq 结果与其他实验数据进行比较从 FASTQ 文件中量化转录表达将定量导入 R/Bioconductor执行质量控制和探索性数据分析执行差异表达与其他实验数据重叠构建动态报告整合 DESeq2 和 zinbwave 以获取单细胞 RNA-seq 数据 二、实验数据 1、数据来源 GEO 条目 GSE52778
本文将展示如何使用替代数据集（tximport小插图中使用的tximportData包）导入 RNA-seq 量化数据。后来我们将加载了数道数据集，其使用计数summarizeOverlaps从GenomicAlignments包。如下所述，我们推荐使用tximport管道来生成计数矩阵，但我们还没有包含气道数据集必要量化文件的 Bioconductor 包。 2、建模计数数据 作为输入，基于计数的统计方法，例如DESeq2 , edgeR , limma with the voom method , DSS、EBSeq 和baySeq期望输入数据是从 RNA-seq 或其他高通量测序实验中获得的计数矩阵。第i行和j 中的值矩阵的第 -th 列表示样本j 中的基因i分配了多少读数（或片段，对于双端 RNA-seq）。类似地，对于其他类型的检测，矩阵的行可能对应于例如结合区域（使用 ChIP-Seq）、细菌种类（使用宏基因组数据集）或肽序列（使用定量质谱）。
3、转录本丰度 在此工作流程中，我们将展示如何使用由Salmon (Patro et al. 2017)软件包量化的转录本丰度。Salmon和其他方法，例如Sailfish 、kallisto 或RSEM ，估计所有（已知的、带注释的）转录本的相对丰度，而没有对齐读取。因为估计转录本的丰度涉及推理步骤，所以估计计数. 大多数方法要么使用称为估计最大化或贝叶斯技术的统计框架来估计丰度和计数。在量化之后，我们将使用tximport （Soneson、Love 和 Robinson 2015）包来组装估计计数和偏移矩阵，以便与 Bioconductor 差异基因表达包一起使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97eb57e51ce19dfa40c15af01d6a36b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/342f365877dacf4874a2ba946a72cc99/" rel="bookmark">
			vue在哪个生命周期可以获取和操作DOM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue从mounted钩子函数开始可以获取和操作dom，此前操作DOM浏览器会报错。
vue生命周期Vue 实例
测试代码如下。在每个钩子函数中添加相应的DOM，测试能否获取及修改DOM。
&lt;template&gt; &lt;div id="body"&gt; &lt;input v-model="test" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { test: "", }; }, beforeCreate() { let body = document.getElementById("body"); if (body !== null) { console.log("beforeCreate 可以获取 DOM"); } else { console.log("beforeCreate 不可以获取 DOM"); } let div = document.createElement("div"); div.innerHTML = "beforeCreate"; body.appendChild(div); }, created() { let body = document.getElementById("body"); if (body !== null) { console.log("created 可以获取 DOM"); } else { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/342f365877dacf4874a2ba946a72cc99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ee2959b607084a37ac24f72c0798859/" rel="bookmark">
			一项关于使用非参数检验分析进化算法行为的研究:2005年中欧委员会实参数优化特别会议的案例研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一项关于使用非参数检验分析进化算法行为的研究:2005年中欧委员会实参数优化特别会议的案例研究 Abstract 摘要近年来，在进化算法领域，实验分析越来越受到人们的关注。值得注意的是，目前已有大量的论文分析并提出了不同类型的问题，如算法实验比较的基础、算法比较中不同方法的提出、算法比较中使用不同统计技术的建议等。在这篇论文中，我们重点研究了统计技术在分析进化算法在优化问题上的行为方面的应用。利用进化算法的实编码优化模型，研究了统计分析结果的必要条件。本研究采用单问题分析和多问题分析两种方法进行。结果表明，当我们处理多个问题的结果时，参数统计分析是不合适的。在多问题分析中，我们建议使用非参数统计检验，因为它们比参数统计检验的限制性更小，而且它们可以在结果的小样本中使用CEC’2005用非参数测试程序优化实参数专题会议。
筹备工作:2005年中央委员会特别会议设置 在本节中，我们将简要介绍CEC2005特别会议中比较的算法、测试功能和实验的特点。
2.1进化算法 在本节中，我们列举了在CEC“2005年特别会议”上提出的11种算法。如需详细了解每一项的描述和参数，请参阅各自的贡献。算法如下:BLX。GL50 (García-Martínez and Lozano 2005)、BLX-MA (Molina et al. 2005)、CoEVO（波伊克2005年），德（伦克嫩等人2005年），DMS-L-PSO（梁和苏甘塔尔）2005), EDA (Yuan and Gallagher 2005), G-CMA-ES (Auger and Hansen 2005a)K-PCX（辛哈等人2005年），L-CMA-ES（奥格和汉森2005b），L-萨德（基尔和Suganthan 2005)， SPC-PNX (Ballester et al. 2005)。
2.2 测试函数 在下面的文章中，我们介绍了为2005年IEEE进化大会上组织的实参数优化特别会议设计的一组测试函数
所有函数都被替换了，以确保它们的最优值永远不会在搜索空间的中心被找到。在两个函数。此外。在初始化范围内找不到optima，搜索域不受限制(最优不在初始化范围内)
2.3 实验的特点 这些实验是按照与竞赛相关的文件中的说明进行的。主要特点有:
对于每个测试函数，每个算法运行25次，并计算出总体中最优个体的平均误差。我们将使用维数D = 10的研究，算法对适应度函数进行10万次评估在上述竞赛中，还进行了D30和D50尺寸的实验每次运行都在获得的错误小于10-8时停止。或者达到最大次数的计算。 3 .研究参数试验安全使用所需条件 在本节中，我们将描述和分析安全使用参数测试必须满足的条件(第3.1节)。为此，我们收集了考虑维数D= 10的25个函数中，采用BLX-MA和BLX-GL50算法得到的全部结果。有了它们，我们将首先在单个问题分析(见3.2节)中，对每个函数的结果的完整样本分析所指示的条件。最后。我们将考虑每个函数的平均结果，以合成两种算法的每个结果样本。有了这两个样本，我们将再次检查在多问题方案中安全使用参数测试所需的条件(见第3.3节)。
3.1参数试验安全使用的条件。 在Sheskin(2003年)中，参数检验和非参数检验之间的区别是基于将要分析的数据所代表的测量水平。这样，参数化测试使用由实值组成的数据。后者并不意味着当我们总是处理这种类型的数据时，我们应该使用参数测试。对于参数检验的安全使用，还有其他一些初始假设。不满足这些条件可能会使统计分析失去可信性。为了使用参数测试，必须检查以下条件(Sheskin 2003;Zar 1999):
独立性:在统计学中，当一个事件的发生不改变另一个事件发生的概率时，两个事件是独立的。正态性:当观察的行为符合正态分布或高斯分布，其平均值为u，方差为o时，观察就是正态的。对一个样本进行正态性检验可以表明观察数据中是否存在这种情况。我们将使用三种常态测试: Shapiro-WilkKolmogorov-Smirnov:将观测数据的累积分布与高斯分布的预期累积分布进行比较，得到基于两者差异的p值Shapiro-Wilk:它分析观察到的数据，计算对称程度和峰度(曲线的形状)，然后计算与高斯分布的差异，从这些差异的平方和得到p值。D’agostino - pearson:它首先计算偏度和峰度，以量化分布在不对称和形状方面与高斯分布的距离。然后计算这些值与高斯分布的期望值之间的距离。并从这些差异的总和中计算出一个p值。 异方差性:这一性质表明存在违背方差相等假设的情况。Levene检验用于检验k个样本是否存在方差齐性(方差齐性)。当观测数据不满足正态性条件时，该检验结果比Bartlett检验更可靠。检查相同的属性。 在我们的例子中，很明显事件的独立性，因为它们是随机生成初始种子的算法的独立运行。下面我们将使用Kolmogorov-Smirnov进行正态性分析。ShapiroWilk和D’agostino - pearson检验对单问题和多问题分析，并用Levene检验进行异方差分析。
3.2关于单问题分析所需条件的研究 对每个函数运行25次BLX-GL50和BLX-MA算法得到的结果样本，我们可以应用统计检验来确定它们是否检验了正态性和同方差特性。我们以前已经看到，在这类实验中，独立性条件很容易满足。进行统计分析的运行次数可能较低，但这是中央委员会2005年特别会议的要求本节中使用的所有测试将获得相关的p值，它表示样本结果相对于正态形状的不同程度。因此，低p值表示非正态分布。在本研究中，我们将考虑显著性水平a =0.05，因此p值大于a表示满足正态性条件。所有的计算都通过SPSS统计软件包进行。表1显示了结果，符号“*”表示不满足正规性，括号中是p值。表2显示了应用测试的结果：
表3为D’agostino - pearson检验结果。
除了这个一般的研究之外，我们还展示了三种情况下的样本分布，目的是说明正态检验获得不同结果的有代表性的情况。
从图1到图3，显示了直方图和Q-Q图的不同图形表示示例。直方图通过条形图来表示一个统计变量，因此每个条形图的面积与所表示值的频率成正比。Q-Q图表示观察到的四分位数和正态分布的四分位数之间的冲突。
在图1中，我们可以观察到一个异常性质清晰呈现的一般情况。相反，图2是一个正态分布的样本的说明，采用的三个正态检验验证了这一事实。最后，图3显示了一个特殊情况，结果的样本和正态分布之间的相似性，并不是由所有的正态性来证实的。
在这种情况下，一个正态性测试可能比另一个更好，这取决于数据类型、领带数量或收集的结果数量。因为这个事实。我们使用了三个众所周知的正态检验来研究正态条件。
根据问题选择最合适的正态检验超出了本文的范围。对研究同方差性属性,表4显示了通过应用列文的测试,结果,象征“表明分布的方差不同的算法的某些功能异同(我们reiect零hvpothesis在显著性水平= 0.05)显然，在这两种情况下，正态性和同方差条件的不满足是完美的。在大多数的功能。正态性条件在单问题分析中不能得到验证。同方差性也取决于所研究的算法的数目。因为它检验了所有总体样本方差之间的关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ee2959b607084a37ac24f72c0798859/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f543b2cbb98077d42ac36ad494adad4e/" rel="bookmark">
			springmvc静态资源过滤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springmvc静态资源过滤 优雅REST风格的资源URL不希望带 .html 或 .do 等后缀.由于早期的Spring MVC不能很好地处理静态资源，所以在web.xml中配置DispatcherServlet的请求映射，往往使用 *.do 、 *.xhtml等方式。这就决定了请求URL必须是一个带后缀的URL，而无法采用真正的REST风格的URL。
如果将DispatcherServlet请求映射配置为"/"，则Spring MVC将捕获Web容器所有的请求，包括静态资源的请求，Spring MVC会将它们当成一个普通请求处理，因此找不到对应处理器将导致错误。
如何让Spring框架能够捕获所有URL的请求，同时又将静态资源的请求转由Web容器处理，是可将DispatcherServlet的请求映射配置为"/"的前提。由于REST是Spring3.0最重要的功能之一，所以Spring团队很看重静态资源处理这项任务，给出了堪称经典的两种解决方案。
先调整web.xml中的DispatcherServlet的配置，使其可以捕获所有的请求：
&lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 通过上面url-pattern的配置，所有URL请求都将被Spring MVC的DispatcherServlet截获。
采用&lt;mvc:default-servlet-handler /&gt;
在springMVC-servlet.xml中配置&lt;mvc:default-servlet-handler /&gt;后，会在Spring MVC上下文中定义一个org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler，它会像一个检查员，对进入DispatcherServlet的URL进行筛查，如果发现是静态资源的请求，就将该请求转由Web应用服务器默认的Servlet处理，如果不是静态资源的请求，才由DispatcherServlet继续处理。
一般Web应用服务器默认的Servlet名称是"default"，因此DefaultServletHttpRequestHandler可以找到它。如果你所有的Web应用服务器的默认Servlet名称不是"default"，则需要通过default-servlet-name属性显示指定：
&lt;mvc:default-servlet-handler default-servlet-name="所使用的Web服务器默认使用的Servlet名称" /&gt;
采用&lt;mvc:resources /&gt;
&lt;mvc:default-servlet-handler /&gt;将静态资源的处理经由Spring MVC框架交回Web应用服务器处理。而&lt;mvc:resources /&gt;更进一步，由Spring MVC框架自己处理静态资源，并添加一些有用的附加值功能。
首先，&lt;mvc:resources /&gt;允许静态资源放在任何地方，如WEB-INF目录下、类路径下等，你甚至可以将JavaScript等静态文件打到JAR包中。通过location属性指定静态资源的位置，由于location属性是Resources类型，因此可以使用诸如"classpath:"等的资源前缀指定资源位置。传统Web容器的静态资源只能放在Web容器的根路径下，&lt;mvc:resources /&gt;完全打破了这个限制。
其次，&lt;mvc:resources /&gt;依据当前著名的Page Speed、YSlow等浏览器优化原则对静态资源提供优化。你可以通过cacheSeconds属性指定静态资源在浏览器端的缓存时间，一般可将该时间设置为一年，以充分利用浏览器端的缓存。在输出静态资源时，会根据配置设置好响应报文头的Expires 和 Cache-Control值。
在接收到静态资源的获取请求时，会检查请求头的Last-Modified值，如果静态资源没有发生变化，则直接返回303相应状态码，提示客户端使用浏览器缓存的数据，而非将静态资源的内容输出到客户端，以充分节省带宽，提高程序性能。
在springMVC-servlet中添加如下配置：
&lt;mvc:resources location="/,classpath:/META-INF/publicResources/" mapping="/resources/**"/&gt; 以上配置将Web根路径"/"及类路径下 /META-INF/publicResources/ 的目录映射为/resources路径。假设Web根路径下拥有images、js这两个资源目录,在images下面有bg.gif图片，在js下面有test.js文件，则可以通过 /resources/images/bg.gif 和 /resources/js/test.js 访问这二个静态资源。
假设WebRoot还拥有images/bg1.gif 及 js/test1.js，则也可以在网页中通过 /resources/images/bg1.gif 及 /resources/js/test1.js 进行引用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3393b50d525453363fe1772b46fe431a/" rel="bookmark">
			收藏∣ArcGIS Pro 键盘快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArcGIS Pro 中提供了键盘快捷键，用以提高工作效率并帮助您在完成常见工作流的同时节省下时间。
键盘快捷键可按功能区进行分类。 要了解有关每种功能的详细信息以及何时可以使用键盘快捷键的类别，请单击表格后面的链接。
注：
这是 ArcGIS Pro 中可用的键盘快捷键的完整列表，并且在每个软件版本中都会更新。 可以从 https://links.esri.com/arcgis-pro-shortcuts 下载 PDF 版本，但该版本可能不包括最新更新内容。
此处列出的某些快捷键可用于增强鼠标操作；但也可以在没有鼠标的情况下使用 ArcGIS Pro。 有关详细信息，请参阅通过键盘使用 ArcGIS Pro。
常规应用程序
用于 ArcGIS Pro 的常规键盘快捷键
键盘快捷键 操作
Ctrl+O 打开工程。
Ctrl+N 创建新工程。
Ctrl+S 保存工程。
Alt+F4 退出 ArcGIS Pro。
F1 将帮助系统打开到工具的默认主页或上下文相关帮助。
在 ArcGIS Pro 中了解有关上下文相关帮助的详细信息
Ctrl+F1 显示或隐藏功能区。
Ctrl+Z 撤消更改。
Ctrl+Y 恢复更改。
Delete 删除所选内容。
Alt 键或 F10 键 在功能区和活动视图或窗格之间移动。 启用访问键并在功能区上显示按键提示。
Alt + 连字符 (-) 访问相应选项以浮动、停靠或关闭活动视图或窗格。
右箭头键或左箭头键 在功能区或窗格中从一个选项卡移至另一选项卡。
Tab 键或 Shift+Tab 在功能区、窗格、视图或对话框上的命令或项目之间移动。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3393b50d525453363fe1772b46fe431a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1825b98e920f6bdc566064cc0064b3d8/" rel="bookmark">
			VS中断点调试的功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、断点功能及演示1.断点功能2.演示 前言 断点在编写程序找错误的时候能起到很大的作用，希望大家能够好好理解。
一、断点功能及演示 1.断点功能 断点可以实现代码的单步执行，便于我们发现错误是在具体的哪一天，还可以帮助我们理解程序的运行过程。
2.演示 这个红色的点我们称之为断点，在这一条黑线这里点一下即可出现断点。
当我们可以调试运行时会发现程序并没有执行，而是卡在我们下的断点那个位置，控制台调试框也没有东西。这个断点的位置的代码代表将要执行，下面的代码都还没有执行。
按下F10断点会向下走，程序也会向下运行。
按一下就执行一条代码。
断点及大方便了我们理解程序的执行过程，有助于我们理解程序的执行过程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d61f3f6ccab14199b679de33bc9e20ec/" rel="bookmark">
			基于知识获取共享的算法代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于知识获取共享的算法 gainesingsharing knowledge optimization algorithm (GSK)基于在人的生命周期内获取和共享知识的理念。它基于两个关键因素阶段：
第一阶段称为初-中级或初级获取与分享阶段；第二阶段称为中级-专家或高级获取与分享阶段； 下面将分别描述这两个阶段。
事实上，特定人群中的所有个体(人)可以在一起互动，他们通过合作和竞争不断影响彼此，以非常有经验和足够资格处理现实生活中的情况解决复杂的问题。然而，作为一个有经验的人，你必须从别人那里获得和分享知识。因此,人类寿命期间,每个人在一个特定的人口增长知识在早期阶段(早中)获得知识通过不同类型的非常小的网络如他她(家人、邻居、亲戚)比获得更现实的等不同类型的更大的网络(工作、社会朋友和许多其他人)。
此外，由于经验有限，这一阶段的知识来源很少，他/她仍然希望与其他不同类型的人分享他的观点，想法和技能，可能在小的网络之外。事实上，在这个阶段，他必须考虑到，他没有足够的资格，生活经验很少，以区分和分类不同类型的人，不属于他她的小网络，好人和坏人。
另一方面，在(中后期)年阶段，由于与更大的网络(如同事、社交媒体上的朋友和其他人)互动，每个人都有自己的不同领域的知识,可以显著改善获得它从别人主要是派生按照领导人的成功,相信在精英人士的意见除了避免失败的人或激进的概念或糟糕的性能在各个领域。事实上，在这个阶段，每个人都有很强的判断、思考和把不同类型的人分为好、中、坏的等级的能力。因此，他可以很容易地将自己在不同领域的知识和经验分享给最合适、性格和行为良好的人(即从他们的知识和经验中获益)。对上述知识获取-共享概念的数学解释如下。
让 x i = 1 , 2 , 3 , … , N x_i= 1,2,3,…,N xi​=1,2,3,…,N的人一个特定的人口,也就是说,这个人口包含N人每个人喜被定义为 x i j = ( ( ξ 1 , ξ 2 ) , … , x i D ) x_{ij} =((ξ_1,ξ_2),…,x_{iD}) xij​=((ξ1​,ξ2​),…,xiD​), D D D是分配给一个人的学科领域的数量，也就是决定一个人的维度的知识分支和 f i f_i fi​, i = 1 , 2 ， … ， N i = 1,2，…，N i=1,2，…，N分别为对应的适应度值。因此,显然它可以推导出从图6的主要思想是在初中获得和分享阶段(含早阶段)每个向量的维数(改变)被另一个值将替代使用初级获取-共享方案不仅仅是更新的数量维度使用高级获得和共享方案即数量使用初级增益共享规则的更新维数大于使用高级增益共享规则的更新维数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d61f3f6ccab14199b679de33bc9e20ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b4ffaf422c804560f8f0dbb24325e3b/" rel="bookmark">
			记一次gitlab因为修改external URL导致打不开网页的bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是通过docker安装的gitlab,当时跟着教程，用9080映射了80端口，然后修改/etc/gitlab/gitlab.rb下的external URL
再修改gitlab.yml的host和port，把它修改的和gitlab.rb一致，完后重启gitlab，发现打不开网页。
前前后后鼓捣了大半天，后来发现把端口映射内部80到外部9080了，这样，当我设置了扩展url之后，内部不再是80，而是9080，然而外部还是在用9080访问内部的80，所以会打不开。
那么很简单，将容器删除（这里数据卷可以不删，可以保留以前的创建的账户这些，当然你想重开肯定更好）
然后重新创建容器并且不再映射80端口（主要是开着nginx,是我肯定用扩展的URL），直接映射我们的9080端口，然后创建完后进入容器检查一下我们的那两个文件是否一致，如果一致，就ok,这个时候通过192.168.200.130:9080就可以正常打开了！
检查一下你的项目的http和ssh连接中的端口号是否和你自己设置的一致，如果一致就没问题，可以远程提交！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ccffe7ad9edcc1745d07323df28c161/" rel="bookmark">
			leetcode学习（初级算法-数组）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言实现初级数组算法。
1.删除排序数组中的重复项
初级算法 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/实现代码：
int removeDuplicates(int* nums, int numsSize){ int *i = nums, *end = nums + numsSize; while (++nums &lt; end) if (*i != *nums) *(++i) = *nums; return i - nums + numsSize + 1; } 2.买卖股票的最佳时机 II
初级算法 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台 (leetcode-cn.com)https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/实现代码：
int maxProfit(int *prices, int pricesSize){ if (pricesSize &lt; 2) return 0; int *end = prices + pricesSize - 1, min = *prices; int a=*prices,b=*(++prices),c; pricesSize = 0; while(prices&lt;end){ c=*(prices+1); if(b&lt;=a){ if(b&lt;c) min=b; }else{ if(b&gt;=c) pricesSize+=b-min; } a=b; b=c; prices++; } if (b &gt; a) return pricesSize + b - min; return pricesSize; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ccffe7ad9edcc1745d07323df28c161/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a6350019538eb15e0a5a600c19c867a/" rel="bookmark">
			Unity 加载并使用.mp3格式的音频文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文链接
unity 自带的音频加载类仅支持wav、ogg格式的音频文件，当你拿到一堆mp3格式的文件时，你会选择哪种处理方式。
1.格式工厂一键转换
2.写一个函数，把文件格式转换成wav格式
这里介绍以下第二种方式
using NAudio.Wave;//要下载一个NAudio.dll才引用得到 private static void LoadMp3(string audioUrl) { FileInfo fileInfo= new FileInfo(audioUrl); using (var audioStrem = new Mp3FileReader(fileInfo.FullName)) { WaveFileWriter.CreateWaveFile(fileInfo.FullName.Replace(".mp3","")+ ".wav", audioStrem); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abd8fc11cd71a180b29469a71ac20d12/" rel="bookmark">
			Docker中微服务的消费者访问提供者的错误 Connection refused
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误概述： 微服务的eureka，provider，consumer服务在Windows的IDEA中都能正常运行。
部署进入Centos7的Docker后，eureka，provider服务运行正常，consumer服务总是报 Connection refused的如下错误，
2021-09-15 14:41:51.526 ERROR 1 --- [p-nio-exec-4] o.a.c.c.C.[.[.[/]. [dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://localhost:8001": Connection refused (Connection refused); nested exception is java.net.ConnectException: Connection refused (Connection refused)] with root cause	java.net.ConnectException: Connection refused (Connection refused)	at java.net.PlainSocketImpl.socketConnect(Native Method) ~[na:1.8.0_111] at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350) ~[na:1.8.0_111] at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206) ~[na:1.8.0_111] .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abd8fc11cd71a180b29469a71ac20d12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/210ffd46ef34b3df4d3d918e48f1e7d9/" rel="bookmark">
			miktex配置cjk中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装MiKTex后配置中文（安装CJK）
先从官网下载basic-miktex-21.6-x64，并安装。
1.打开miktex console 进入管理员模式。
2.在设置里点更改-下一步，点中国的镜像如清华、华为什么的比较快的网址。
3.检查一下更新，能更新就更新。
4.点宏包，输入cjk回车，分别右击cjk,cjk-fonts，安装。
接下来就是打开命令行窗口(以管理员身份执行)， 输入:
initexmf -u
等一小会儿，让命令执行完，然后再输入:
initexmf --edit-config-file updmap
此时会出现一个笔记本，我们在其中输入要启用的字型:
Map cwmu.map
Map cwku.map
Map cwfsu.map
Map cwhbu.map
Map cwyu.map
（把上面几行续写入到弹出来的笔记本中）
保存，关闭，接着在控制台输入命令:
initexmf --mkmaps
命令完成后，就大功告成了。
举个例子如下：（其实这是从网上copy的）,打开自带的texworks
\documentclass{article} \usepackage{CJKutf8} \begin{document} \begin{CJK}{UTF8}{gkai} 这是一个楷体中文测试，处理简体字。 \end{CJK} \begin{CJK}{UTF8}{gbsn} 这是一个宋体中文测试，处理简体字。 \end{CJK} \begin{CJK}{UTF8}{bkai} 這是一個big5編碼的楷體中文測試，處理繁體文字。 \end{CJK} \begin{CJK}{UTF8}{bsmi} 這是一個个big5編碼的明體中文測試，處理繁體文字。 \end{CJK} \end{document} 编译过程中如有提示安装包，直接点确认自动安装。
如果成功，则会显示一个含有中文的pdf文件。
本人亲测pdflatex可以使用。
xelatex因为没有安装宏包，所以编译后不可显示中文。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66a3f70287d0056a1cf5f0de32aef75d/" rel="bookmark">
			Java使用for循环：打印直角三角形/倒直角三角形/正三角形/倒正三角形/矩形/平行四边形/菱形的规律
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新人表示总结出规律后，小意思啦~
使用方法：嵌套for循环
1.外层循环控制的是执行的轮数，内层循环控制的是这一轮中执行的次数
2.外层循环控制的是图形的行数，内层循环控制的是这一行的列数
直角三角形：
规律：
1.外层for循环，循环条件 i 值设定具体边长
2.内层for循环，循环条件 j 值与外层循环 i 值挂钩（打印空格加*）
//直角三角形 for (int i = 0; i &lt;= 5; i++) { for (int j = 0; j &lt;= i; j++) { System.out.print(" *");//打印空格加* }System.out.println();//换行 } 倒直角三角形：
规律：(对比上面直角三角形)
1.外层for循环全部相反：开始条件0改成5，循环条件 '&lt;'号 改成 '&gt;'号，更改条件 ++ 改成 --
2.内层for循环不变（打印空格加*）
//倒直角三角形 for (int i = 5; i &gt;= 0; i--){ for (int j = 0; j &lt;= i; j++){ System.out.print(" *"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66a3f70287d0056a1cf5f0de32aef75d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2096a09fec8d16656efbd4a3e51b47c5/" rel="bookmark">
			Elementui中折叠面板默认设置为展开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.Elementui中折叠面板默认设置为展开
当el-collapse 中v-model的值和唯一标识name一样的时候，会使其默认展开(代码如下)
&lt;el-collapse accordion v-model="activeName01" @change="handleChange"&gt; &lt;el-collapse-item name="1"&gt; &lt;template slot="title" &gt; &lt;h3&gt;投放应用&lt;/h3&gt; &lt;/template&gt; &lt;div class="banking"&gt; &lt;span v-for="(item,index) in versionlist" :style="{background:(index==isactive ? item.color:''),color:(index== isactive ? 'white':'')}" @click='switchtab(item.value, index)' :key="index"&gt;{{item.name}}&lt;/span&gt; &lt;/div&gt; &lt;/el-collapse-item&gt; &lt;/el-collapse&gt; &lt;script&gt; data:function(){ return{ activeName01:'1' //默认collapse是展开状态 } } &lt;/script&gt; 2.当在Elementui中需要给collapse子元素el-collapse-item中的title加样式时可以用
&lt;template slot = "title"&gt; &lt;h3&gt;这是用slot替换一般直接在控件中title中写内容的模式&lt;/h3&gt; &lt;/template&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6de2c5a27da354e31c4d4c532943941e/" rel="bookmark">
			Ajax基础：向服务器端传递post请求参数（普通类型&#43;json类型）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（普通类型的请求数据） 客户端 04ajax.html 的代码：
&lt;body&gt; &lt;p&gt;&lt;input type="text" name="" id="username"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="text" name="" id="age"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="button" name="" value="提交" id="btn"&gt;&lt;/p&gt; &lt;script&gt; var btn = document.getElementById('btn'); var usernameV = document.getElementById('username'); var ageV = document.getElementById("age"); btn.addEventListener('click', function() { var name = usernameV.value; var age = ageV.value; var params = 'username=' + name + '&amp;age=' + age; // 创建ajax对象 var aj = new XMLHttpRequest(); // 配置ajax对象 aj.open('post', 'http://localhost:3000/post'); // 如果post请求参数是【params】中的格式，那么这里就要设置成下面的格式，固定写法 aj.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); // 发送请求 aj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6de2c5a27da354e31c4d4c532943941e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e607fdf0583c3ddad8b481556eb4f15e/" rel="bookmark">
			Java实现两个整数的加减乘除运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.util.Scanner; public class CountScore { public static void main(String[] args) { // TODO Auto-generated method stub Scanner input=new Scanner(System.in); System.out.println("请输入你要计算的整数："); int a=input.nextInt(); int b=input.nextInt(); System.out.println(a+b); System.out.println(a-b); System.out.println(a*b); System.out.println(a/b); } } 运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2367d44846979f20869fc8ef724331c8/" rel="bookmark">
			FATE使用手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FATE简介 FATE（Federated AI Technology Enabler）是微众银行AI部门发起的一个开源项目，旨在提供一个安全的计算框架来支持联邦AI生态系统。它实现了基于同态加密和多方计算（MPC）的安全计算协议。它支持联邦学习架构和各种机器学习算法的安全计算，包括逻辑回归、基于树的算法、深度学习和迁移学习。
FATE技术框架 FederatedML ​ 算法功能组件，包括常见机器学习算法联邦化实现。所有模块均采用模块化的解耦的方式进行开发，从而增强可扩展性。
FATE_Flow ​ FATE-Flow是联邦学习框架FATE的作业调度系统，实现联邦学习作业生命周期的完整管理，其中包括数据输入、训练作业调度、指标追踪、模型中心等功能。
FATE-Board ​ 联邦学习建模的可视化工具，为终端用户可视化和度量模型训练的全过程。支持对模型训练过程全流程的跟踪、统计和监控等，并为模型运行状态、模型输出、日志追踪等提供了丰富的可视化呈现，帮助用户简单而高效地深入探索模型与理解模型。
FATE-Serving ​ 高性能可扩展的联邦学习在线模型服务。
角色 Guest ​ Guest表示数据应用方，在纵向算法中，Guest往往是有标签y的一方。一般是由Guest发起建模流程。
Host ​ Host是数据提供方。
arbiter ​ arbiter是用来辅助多方完成联合建模的，主要的作用是用来聚合梯度或者模型,比如纵向lr里面,各方将自己一半的梯度发送给arbiter，然后arbiter再联合优化等等,arbiter还参与以及分发公私钥，进行加解密服务等等。
FATE环境部署指南 单机部署 参考：https://fate.readthedocs.io/en/latest/_build_temp/standalone-deploy/README.html#install-fate-using-docker-recommended，包括使用 Docker 安装 FATE*(推荐)*和在主机中安装 FATE
集群部署 参考：https://fate.readthedocs.io/en/latest/_build_temp/cluster-deploy/README.html
主机进入到docker FATE镜像命令 主机ip:192.168.1.75
FATE版本为1.6.0，主机执行以下命令
CONTAINER_ID=`docker ps -aqf "name=fate"` docker exec -t -i ${CONTAINER_ID} bash 快速启动 FATE 的一般指南 参考：https://fate.readthedocs.io/en/latest/_build_temp/examples/pipeline/README.html
由于FATE已经启动，以下命令不需要执行
（可选）创建虚拟环境
python -m venv venv source venv/bin/activate pip install -U pip 安装FATE客户端
pip install fate_client pipeline init --help 提供部署的 FATE-Flow 的服务器 ip/port 信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2367d44846979f20869fc8ef724331c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/835177f058b9b50113f49923ed2c238b/" rel="bookmark">
			C语言——打印菱形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入上半部分的行数来打印出一个菱形，效果如图：
这里将他分为两部分来分析，主要就是找每一部分的空格个数与 * 个数的规律
分析上半部分：
代码如下：
//上半部分： for (int i = 1; i &lt;= n; i++) {	//行数做循环条件 //1、打印空格 for (int j = 0; j &lt; n - i; j++) {	printf(" "); } //2、打印*号 for (int j = 0; j &lt; 2*i-1; j++) { printf("*"); } //3、没打印完一排换行 printf("\n"); } 分析下半部分：
代码如下：
//下半部分： for (int i = 1; i &lt;= n - 1; i++) { for (int j = 0; j &lt; i; j++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/835177f058b9b50113f49923ed2c238b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/175/">«</a>
	<span class="pagination__item pagination__item--current">176/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/177/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>