<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50dac4a4795d9267d1faf3806ba22f2c/" rel="bookmark">
			[Redis实战]商户查询缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二、商户查询缓存 2.1 缓存 2.1.1 为什么使用缓存？ 一句话：速度快，好用
缓存数据存储于代码中，而代码运行在内存中，内存的读写性能远高于磁盘，缓存可以大大降低用户访问并发量带来的服务器读写压力。
实际开发过程中，企业的数据量，少则几十万，多则几千万，这么大的数据量，如果没有使用缓存，系统几乎是撑不住的，所以企业会大量运用到缓存技术。
但是缓存也会增加代码复杂度和运营的成本。
2.1.2 如何使用缓存？ 实际开发中，会构筑多级缓存来使系统运行速度进一步提升，例如：本地缓存与redis中的缓存并发使用
浏览器缓存：主要是存在于浏览器端的缓存
应用层缓存：可以分为tomcat本地缓存，比如使用redis作为缓存
数据库缓存：在数据库中有一片空间 buffer pool，增删改查数据都会先加载到mysql的缓存中
CPU缓存：当代计算机最大的问题是cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1,L2,L3级的缓存
2.2 添加商户缓存 在我们查询商户信息时，我们是直接操作从数据库中去进行查询的，大致逻辑是这样，直接查询数据库那肯定慢咯，所以我们需要增加缓存
2.2.1 缓存模型和思路 标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。
2.2.2 代码示例 ShopController
/** * 根据id查询商铺信息 * @param id 商铺id * @return 商铺详情数据 */ @GetMapping("/{id}") public Result queryShopById(@PathVariable("id") Long id) { return shopService.queryById(id); } ShopService
@Autowired private StringRedisTemplate stringRedisTemplate; @Override public Result queryById(Long id) { String key = CACHE_SHOP_KEY + id; //1.从redis查询商铺缓存 String shopJson = stringRedisTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50dac4a4795d9267d1faf3806ba22f2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26d001f79f7600cbecdb6bdd80075eb0/" rel="bookmark">
			dvwa问题篇 -- 菜刀蚁剑连接不上图片木马 -- 小黑解决教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位小伙伴初次玩dvwa会出现各种问题，本来想把一些问题直接总结写一篇dvwa文章来着，但因为都是关键字搜索，所以将一些问题都拆分出来，以便大家方便查类似问题。（大家有遇到不一样的问题欢迎投稿！！共享问题解决问题！！）
目录
问题：
解决：
问题： 菜刀蚁剑连接不上图片木马
解决： 1、需要在菜刀上访问dvwa，设定为low级别，访问该图片
2、phpstudy的php版本过高将为5.0版本即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3e481cdf5b41f806e6e169e64acd325/" rel="bookmark">
			代理IP在大数据抓取中的关键角色及其有效配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代理IP在大数据抓取中扮演着以下几个关键角色：
1. 匿名性：代理IP可以隐藏真实用户的IP地址，保护用户的身份和隐私。在数据抓取过程中，这可以帮助避免目标网站识别并封锁原始IP地址。
2. 突破地理限制：通过使用来自不同地区的代理IP，爬虫可以模拟全球各地的用户访问，获取特定地区或国家的专属数据，这对于进行地域性数据分析非常有用。
3. 防止封禁：许多网站会限制频繁或大规模的数据访问。使用代理IP可以轮流切换IP地址，降低被目标网站检测到并封锁的风险。
4. 提高效率：一些代理服务提供高速和稳定的IP，可以提高数据抓取的速度和效率。
要有效配置代理IP进行大数据抓取，以下是一些步骤和考虑因素：
1. 选择合适的代理类型：根据需求选择HTTP、HTTPS或 SOCKS 代理。HTTP代理适用于抓取HTTP网站数据，而HTTPS代理则适用于加密的HTTPS连接。
2. 获取代理IP：可以通过购买专业的代理IP服务，这些服务通常提供高质量、高匿名性和稳定性的IP。免费代理IP虽然成本低，但稳定性、速度和安全性可能较差。
3. 验证代理IP的有效性：在使用代理IP之前，需要验证其是否能够正常工作并且没有被目标网站封锁。这可以通过编写脚本或者使用在线工具来检查代理的响应时间和连接状态。
4. 配置爬虫：在爬虫代码中设置使用代理IP。具体方法取决于使用的编程语言和爬虫框架，但通常包括指定一个代理服务器列表，然后在每个请求或定期间隔中随机选择一个代理。
5. 负载均衡和轮换策略：为了最大化代理IP的使用效率和寿命，可以设计负载均衡和轮换策略。例如，可以设定每完成一定数量的请求或每隔一段时间就更换代理IP。
6. 遵守规则和法律：确保在使用代理IP进行数据抓取时，遵守目标网站的robots.txt规则和相关法律法规，尊重数据所有权和隐私权。
7. 监控和调整：持续监控代理IP的性能和有效性，如果发现某些代理IP失效或速度下降，及时更新和调整代理列表。
通过以上步骤和注意事项，可以有效地配置和使用代理IP进行大数据抓取，提高数据收集的效率和质量，同时降低被目标网站检测和阻止的风险。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a107a6aa5fa1afcdfe6ec510a398233/" rel="bookmark">
			使用Python编写自动传输脚本详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 写一个Python脚本来自动传输文件到FTP服务器是一个非常有用的任务，特别是在需要定期备份文件或与其他人共享文件时。本文将介绍如何编写一个Python脚本来实现FTP文件自动传输，并提供详细的内容和丰富的示例代码，以帮助您了解这个过程。
准备工作 在开始之前，需要安装Python并了解一些基本的FTP概念。此外，还需要确定要连接的FTP服务器的地址、用户名和密码，以及要上传或下载的文件的路径。
使用ftplib库进行FTP操作 Python中有一个名为ftplib的标准库，它提供了与FTP服务器进行通信的功能。
首先，确保已经安装了Python，然后可以使用以下代码导入ftplib库：
from ftplib import FTP 连接到FTP服务器 使用FTP类来连接到FTP服务器。在连接之前，请替换以下示例中的主机名、用户名和密码为实际的值：
ftp = FTP('ftp.example.com') ftp.login(user='your_username', passwd='your_password') 现在，已经成功连接到FTP服务器。
上传文件到FTP服务器 要上传文件到FTP服务器，可以使用storbinary方法。
以下是一个示例，将本地文件上传到FTP服务器：
with open('local_file.txt', 'rb') as local_file: ftp.storbinary('STOR remote_file.txt', local_file) 在上述代码中，local_file.txt是本地文件的路径，remote_file.txt是要在FTP服务器上保存的文件名。可以根据需要更改这些值。
下载文件从FTP服务器 要从FTP服务器下载文件，可以使用retrbinary方法。
以下是一个示例，将FTP服务器上的文件下载到本地：
with open('local_file.txt', 'wb') as local_file: ftp.retrbinary('RETR remote_file.txt', local_file.write) 在上述代码中，local_file.txt是本地文件的路径，remote_file.txt是要从FTP服务器上下载的文件名。
列出FTP服务器上的文件 要列出FTP服务器上的文件，可以使用nlst方法。
以下是一个示例，列出FTP服务器上的所有文件：
file_list = ftp.nlst() for file in file_list: print(file) 断开与FTP服务器的连接 当完成FTP操作时，不要忘记断开与服务器的连接：
ftp.quit() 完整示例 以下是一个完整的示例，演示了如何连接到FTP服务器、上传文件、下载文件和列出文件：
from ftplib import FTP ftp = FTP('ftp.example.com') ftp.login(user='your_username', passwd='your_password') # 上传文件到FTP服务器 with open('local_file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a107a6aa5fa1afcdfe6ec510a398233/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8428334f2897b2f5daceead1be8f629e/" rel="bookmark">
			八怪：再谈 MySQL 8 这两个精准的时间戳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 8.0 的 binlog 中多了 immediate_commit_timestamp 和 original_commit_timestamp 的信息，网上也有很多文章进行解释，最近也刚好遇到相关问题，刚好稍微学习一下。
作者：高鹏（八怪），《MySQL 主从原理》作者，深入透彻理解 MySQL 主从，GTID 相关技术知识。
爱可生开源社区出品，原创内容未经授权不得随意使用，转载请联系小编并注明来源。
本文共约 1700 字，预计阅读需要 6 分钟。
相关解释 immediate_commit_timestamp：代表是当前数据库提交的时间，从库/主库都分别代表其提交的时间。original_commit_timestamp：代表主库提交的时间，不管有多少级联的从库这个时间永远是主库提交事务时候的时间。当然在主库上其就等于 immediate_commit_timestamp 的时间。 它们的生成时间都是在从 binlog cache 写入到 binlog 文件的时候，生成 GTID event 的时候，也就是 commit 的 flush 阶段，我们简称这个为 提交时间。
但是需要注意的是 MGR 中主库的 original_commit_timestamp 和 immediate_commit_timestamp 生成稍有提前（group_replication_trans_before_commit），并不是这里说的提交时间。
生成流程 2.1 关于 thd-&gt;variables.original_commit_timestamp 因为 original_commit_timestamp 来自这个值，一般情况下其值都是 UNDEFINED_COMMIT_TIMESTAMP，但是从库上这个值会在应用 GTID event 的时候更改为主库带过来的 original_commit_timestamp*，因为主库 *original_commit_timestamp 就是提交时间，因此从库的 thd-&gt;variables.original_commit_timestamp 也就设置为了主库的提交时间。
但是有一个例外，就是 5.7 向 8.0 同步的时候，因为没有这个值因此会被设置为 0。如下：
# original_commit_timestamp=0 (1970-01-01 08:00:00.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8428334f2897b2f5daceead1be8f629e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8321e0b022a3d1b5d71c5601837dd38/" rel="bookmark">
			vue3&#43;luckyexcel&#43;php在线编辑excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发过程中，需要开发一个在线编辑excel文档的功能，找到了这个合适的组件
Luckysheet ，一款纯前端类似excel的在线表格，功能强大、配置简单、完全开源。
可以导入文档，预览、编辑、保存、导出等功能，可以满足大部分需求
第一步：需要先安装 vue3 运行下面三个安装命令
npm install exceljs -S npm install luckyexcel -S
npm install file-saver
第二步：前端部分index.html 加入引用代码
&lt;link rel='stylesheet' href='/luckysheet/pluginsCss.css' /&gt; &lt;link rel='stylesheet' href='/luckysheet/plugins.css' /&gt; &lt;link rel='stylesheet' href='/luckysheet/luckysheet.css' /&gt; &lt;link rel='stylesheet' href='/luckysheet/iconfont.css' /&gt; &lt;script src="/luckysheet/plugin.js"&gt;&lt;/script&gt; &lt;script src="/luckysheet/luckysheet.umd.js"&gt;&lt;/script&gt; 组件部分test.vue
&lt;template&gt; &lt;div style="position: absolute; top: 0"&gt; &lt;input id="uploadBtn" type="file" @change="loadExcel" /&gt; &lt;button class="btn" @click="getExcel"&gt;后台数据&lt;/button&gt; &lt;span&gt;Or文件:&lt;/span&gt; &lt;select v-model="selected" @change="selectExcel"&gt; &lt;option disabled value=""&gt;Choose&lt;/option&gt; &lt;option v-for="option in options" :key="option.text" :value="option.value"&gt; {{ option.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8321e0b022a3d1b5d71c5601837dd38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a494bd93557e693b3155a8a933eece9/" rel="bookmark">
			有量纲特征参数和无量纲特征参数是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有量纲特征参数和无量纲特征参数是在特征工程中常用的两种概念，它们涉及到特征的度量单位或尺度的问题。
有量纲特征参数（Dimensional Features）： 这指的是特征具有明确的度量单位或尺度。例如，身高（以厘米为单位）、体重（以千克为单位）等都是有量纲的特征。有量纲特征可能受到度量单位的影响，因此在某些机器学习算法中，它们可能对特征的权重产生影响，导致模型更关注某些度量单位较大的特征。
无量纲特征参数（Dimensionless Features）： 这指的是特征在数值上没有明确的度量单位或尺度，通常是经过一些处理使得特征的数值变得相对无单位。常见的无量纲化方法包括标准化（Standardization）和归一化（Normalization），这些方法可以确保特征在数值上具有相对的一致性，不受度量单位的干扰。
标准化（Standardization） 是通过减去均值并除以标准差的过程，将特征的分布转换为均值为0，标准差为1。这样做可以确保特征的值在一个可接受的范围内，并且不受量纲的影响。
归一化（Normalization） 是通过线性缩放将特征的值缩放到一个指定的范围，通常是[0, 1]。这有助于确保所有特征都在相似的数值范围内。
示例代码如下，使用scikit-learn库进行标准化和归一化：
from sklearn.preprocessing import StandardScaler, MinMaxScaler import numpy as np # 示例数据 data = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]) # 标准化 scaler_standard = StandardScaler() data_standardized = scaler_standard.fit_transform(data) print("Standardized Data:\n", data_standardized) # 归一化 scaler_minmax = MinMaxScaler() data_normalized = scaler_minmax.fit_transform(data) print("Normalized Data:\n", data_normalized) 在上述代码中，data_standardized 是经过标准化处理的数据，而 data_normalized 是经过归一化处理的数据。这两个数据集中的特征都是无量纲的，不受度量单位的影响。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b60834ec4e07035bd28062b46f6c69f/" rel="bookmark">
			12月26日作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		main.c
#include "uart4.h" #include "key_int.h" #include "led.h" void delay(int ms) { int i,j; for(i = 0;i &lt; ms;i++) { for(j = 0;j &lt; 2000;j++); } } int main() { //uart4_config(); all_led_init(); key1_it_config(); key2_it_config(); key3_it_config(); while(1) { puts("waiting...\r\n"); delay(1000); } } key_int.c
#include "key_int.h" void key1_it_config() { //使能GPIOF时钟 RCC-&gt;MP_AHB4ENSETR |= (0x1&lt;&lt;5); //设置PF9管脚为输入 GPIOF-&gt;MODER &amp;= (~(0x3&lt;&lt;18)); //设置PF9作为EXTI9事件的输入 EXTI-&gt;EXTICR3 &amp;= (~(0x1f&lt;&lt;8)); EXTI-&gt;EXTICR3 |= (0x05&lt;&lt;8); //设置下降沿使能检测EXTI9事件 EXTI-&gt;FTSR1 |= (0x1&lt;&lt;9); //设置EXIT9事件不屏蔽 EXTI-&gt;C1IMR1 |= (0x1&lt;&lt;9); //GICD使能EXTI9（99号）中断 GICD-&gt;ISENABLER[3] |= (0x1&lt;&lt;3); //GICD设置99号中断的优先级 GICD-&gt;IPRIORITYR[24] &amp;= (~(0x1f&lt;&lt;27)); //选择器CPU0处理当前中断 GICD-&gt;ITARGETSR[24] |= (0x1&lt;&lt;24); //全局使能组0中断被转发到GICC GICD-&gt;CTRL |= (0x1); //设置中断的优先级掩码 GICC-&gt;PMR |= (0x1f&lt;&lt;3); //允许组0中断被CPU处理 GICC-&gt;CTRL |= (0x1); } void key2_it_config() { //使能GPIOF时钟 //RCC-&gt;MP_AHB4ENSETR |= (0x1&lt;&lt;5); //设置PF7管脚为输入 GPIOF-&gt;MODER &amp;= (~(0x3&lt;&lt;14)); //设置PF7作为EXTI7事件的输入 EXTI-&gt;EXTICR2 &amp;= (~(0x1f&lt;&lt;24)); EXTI-&gt;EXTICR2 |= (0x05&lt;&lt;24); //设置下降沿使能检测EXTI7事件 EXTI-&gt;FTSR1 |= (0x1&lt;&lt;7); //设置EXIT7事件不屏蔽 EXTI-&gt;C1IMR1 |= (0x1&lt;&lt;7); //GICD使能EXTI7（97号）中断 GICD-&gt;ISENABLER[3] |= (0x1&lt;&lt;1); //GICD设置97号中断的优先级 GICD-&gt;IPRIORITYR[24] &amp;= (~(0x1f&lt;&lt;11)); //选择器CPU0处理当前中断 GICD-&gt;ITARGETSR[24] |= (0x1&lt;&lt;8); //全局使能组0中断被转发到GICC GICD-&gt;CTRL |= (0x1); //设置中断的优先级掩码 GICC-&gt;PMR |= (0x1f&lt;&lt;3); //允许组0中断被CPU处理 GICC-&gt;CTRL |= (0x1); } void key3_it_config() { //使能GPIOF时钟 //RCC-&gt;MP_AHB4ENSETR |= (0x1&lt;&lt;5); //设置PF8管脚为输入 GPIOF-&gt;MODER &amp;= (~(0x3&lt;&lt;16)); //设置PF8作为EXTI8事件的输入 EXTI-&gt;EXTICR3 &amp;= (~(0x1f)); EXTI-&gt;EXTICR3 |= (0x05); //设置下降沿使能检测EXTI8事件 EXTI-&gt;FTSR1 |= (0x1&lt;&lt;8); //设置EXIT8事件不屏蔽 EXTI-&gt;C1IMR1 |= (0x1&lt;&lt;8); //GICD使能EXTI8（98号）中断 GICD-&gt;ISENABLER[3] |= (0x1&lt;&lt;2); //GICD设置98号中断的优先级 GICD-&gt;IPRIORITYR[24] &amp;= (~(0x1f&lt;&lt;19)); //选择器CPU0处理当前中断 GICD-&gt;ITARGETSR[24] |= (0x1&lt;&lt;16); //全局使能组0中断被转发到GICC GICD-&gt;CTRL |= (0x1); //设置中断的优先级掩码 GICC-&gt;PMR |= (0x1f&lt;&lt;3); //允许组0中断被CPU处理 GICC-&gt;CTRL |= (0x1); } key_int.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b60834ec4e07035bd28062b46f6c69f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a2cad504bf7e284ef33dfe30c4b11d8/" rel="bookmark">
			scala学习八：类和对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、类和对象 类是对象的抽象，而对象是类的具体实例。
类是抽象的，不占用内存，而对象是具体的，占用存储空间。
类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。
object NewTest { def main(args: Array[String]): Unit = { val pt = new Point(10, 20) pt.move(5,5) val locat = new Location(10, 20, 30) locat.move(5,5,5) } class Point(xc: Int, yc: Int) { var x: Int = xc var y: Int = yc def move(dx: Int, dy: Int) { x = x + dx y = y + dy println("x 的坐标点: " + x); println("y 的坐标点: " + y); } } class Location(override val xc: Int, override val yc: Int, zc: Int) extends Point(xc, yc){ var z: Int = zc def move(dx: Int, dy: Int, dz: Int): Unit = { x = x + dx y = y + dy z = z + dz println("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a2cad504bf7e284ef33dfe30c4b11d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/670ba75d21b6af63e99703e7e944e083/" rel="bookmark">
			el-input类型为number时限制输入最大长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在elementui里el-input类型为number时，并不能使用maxlength或者max限制长度，限制长度为7
&lt;el-input type="number" v-model="SYQX" @input="limitPhoneNum" style="width:100%" placeholder="请输入"&gt; &lt;/el-input&gt; limitPhoneNum(value) { if (value.toString().length &gt; 7) { this.SYQX = this.SYQX.toString().slice(0, 7) } }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cad2d98e286f2bf3ea6d24fb64187195/" rel="bookmark">
			StructuredTaskScope - JAVA 中的新并发模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自从 Java 中虚拟线程出现以来，我们引入了一个新的、更好的并发模型，即 StructuredTaskScope。我们将在这个新的编程模型中看到一些常用的编程模式。
对于虚拟线程，由于它们非常轻量级，所以不需要将它们池化。此外，我们知道虚拟线程在阻塞任何操作时可以将其运行栈从底层平台线程 保存到堆上，并且在完成后可以将其运行栈固定到任何可用的平台线程。这是 Java 中的新功能，而且非常棒。
考虑以下代码片段：
public static Weather readFromServerA() throws InterruptedException { Thread.sleep(RandomUtils.nextLong(1, 100)); return new Weather("Partly Sunny", "server-A"); } public static Weather readFromServerB() throws InterruptedException { Thread.sleep(RandomUtils.nextLong(1, 100)); return new Weather("Partly Sunny", "server-B"); } public static Weather readFromServerC() throws InterruptedException { Thread.sleep(RandomUtils.nextLong(1, 100)); return new Weather("Partly Sunny", "server-C"); } 上面的代码返回天气信息。它模拟服务器并在 1-100 毫秒内返回信息。我们的需求是查询所有服务器并得到结果。我们只考虑第一个返回结果的请求，并立即取消其他两个请求（通过中断它们）。
让我们在 StructuredTaskScope 对象的帮助下实现这个逻辑。
public static Weather readWeather() throws ExecutionException, InterruptedException, TimeoutException { try (var scope = new StructuredTaskScope.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cad2d98e286f2bf3ea6d24fb64187195/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c2a49a6a201c2beb79d2e4979166f8/" rel="bookmark">
			Flink1.17实战教程（第七篇：Flink SQL）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 Flink1.17实战教程（第一篇：概念、部署、架构）
Flink1.17实战教程（第二篇：DataStream API）
Flink1.17实战教程（第三篇：时间和窗口）
Flink1.17实战教程（第四篇：处理函数）
Flink1.17实战教程（第五篇：状态管理）
Flink1.17实战教程（第六篇：容错机制）
Flink1.17实战教程（第七篇：Flink SQL）
文章目录 系列文章目录1. sql-client准备1.1 基于yarn-session模式1.2 常用配置 2. 流处理中的表2.1 动态表和持续查询2.2 将流转换成动态表2.3 用SQL持续查询2.4 将动态表转换为流 3. 时间属性3.1 事件时间3.2 处理时间 4. DDL（Data Definition Language）数据定义4.1 数据库4.2 表 5. 查询5.0 DataGen &amp; Print5.1 With子句5.2 SELECT &amp; WHERE 子句5.3 SELECT DISTINCT 子句5.4 分组聚合5.5 分组窗口聚合5.6 窗口表值函数（TVF）聚合5.7 Over 聚合5.8 特殊语法 —— TOP-N5.9 特殊语法 —— Deduplication去重5.10 联结（Join）查询5.10.1 常规联结查询5.10.2 间隔联结查询5.10.3 维表联结查询 5.11 Order by 和 limit5.12 SQL Hints5.13 集合操作5.14 系统函数5.15 Module操作 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1c2a49a6a201c2beb79d2e4979166f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50f15676ae0498de886e15c112d26da3/" rel="bookmark">
			Flink1.17实战教程（第六篇：容错机制）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 Flink1.17实战教程（第一篇：概念、部署、架构）
Flink1.17实战教程（第二篇：DataStream API）
Flink1.17实战教程（第三篇：时间和窗口）
Flink1.17实战教程（第四篇：处理函数）
Flink1.17实战教程（第五篇：状态管理）
Flink1.17实战教程（第六篇：容错机制）
Flink1.17实战教程（第七篇：Flink SQL）
文章目录 系列文章目录1. 检查点（Checkpoint）1.1 检查点的保存1.2 从检查点恢复状态1.3 检查点算法1.3.1 检查点分界线（Barrier）1.3.2 分布式快照算法（Barrier对齐的精准一次）1.3.3 分布式快照算法（Barrier对齐的至少一次）1.3.4 分布式快照算法（非Barrier对齐的精准一次） 1.4 检查点配置1.4.1 启用检查点1.4.2 检查点存储1.4.3 其它高级配置1.4.4 通用增量 checkpoint (changelog)1.4.5 最终检查点 1.5 保存点（Savepoint）1.5.1 保存点的用途1.5.2 使用保存点1.5.3 使用保存点切换状态后端 2. 状态一致性2.1 一致性的概念和级别2.2 端到端的状态一致性 3. 端到端精确一次（End-To-End Exactly-Once）3.1 输入端保证3.2 输出端保证3.3 Flink和Kafka连接时的精确一次保证 1. 检查点（Checkpoint） 在Flink中，有一套完整的容错机制来保证故障后的恢复，其中最重要的就是检查点。
1.1 检查点的保存 1）周期性的触发保存
“随时存档”确实恢复起来方便，可是需要我们不停地做存档操作。如果每处理一条数据就进行检查点的保存，当大量数据同时到来时，就会耗费很多资源来频繁做检查点，数据处理的速度就会受到影响。所以在Flink中，检查点的保存是周期性触发的，间隔时间可以进行设置。
2）保存的时间点
我们应该在所有任务（算子）都恰好处理完一个相同的输入数据的时候，将它们的状态保存下来。
这样做可以实现一个数据被所有任务（算子）完整地处理完，状态得到了保存。
如果出现故障，我们恢复到之前保存的状态，故障时正在处理的所有数据都需要重新处理；我们只需要让源（source）任务向数据源重新提交偏移量、请求重放数据就可以了。当然这需要源任务可以把偏移量作为算子状态保存下来，而且外部数据源能够重置偏移量；kafka就是满足这些要求的一个最好的例子。
3）保存的具体流程
检查点的保存，最关键的就是要等所有任务将“同一个数据”处理完毕。下面我们通过一个具体的例子，来详细描述一下检查点具体的保存过程。
回忆一下我们最初实现的统计词频的程序——word count。这里为了方便，我们直接从数据源读入已经分开的一个个单词，例如这里输入的是：
“hello”，“world”，“hello”，“flink”，“hello”，“world”，“hello”，“flink”…
我们所需要的就是每个任务都处理完“hello”之后保存自己的状态。
1.2 从检查点恢复状态 检查点的保存具体流程：
处理数据过程发生故障
重启应用 ==&gt;&gt; 读取检查点，重置状态
重置偏移量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50f15676ae0498de886e15c112d26da3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ade1ffc9151e015c51fd799874794d4/" rel="bookmark">
			Flink1.17实战教程（第四篇：处理函数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 Flink1.17实战教程（第一篇：概念、部署、架构）
Flink1.17实战教程（第二篇：DataStream API）
Flink1.17实战教程（第三篇：时间和窗口）
Flink1.17实战教程（第四篇：处理函数）
Flink1.17实战教程（第五篇：状态管理）
Flink1.17实战教程（第六篇：容错机制）
Flink1.17实战教程（第七篇：Flink SQL）
文章目录 系列文章目录1. 基本处理函数（ProcessFunction）1.1 处理函数的功能和使用1.2 ProcessFunction解析1.3 处理函数的分类 2. 按键分区处理函数（KeyedProcessFunction）2.1 定时器（Timer）和定时服务（TimerService）2.2 KeyedProcessFunction案例 3. 窗口处理函数3.1 窗口处理函数的使用3.2 ProcessWindowFunction解析 4. 应用案例——Top N4.1 使用ProcessAllWindowFunction4.2 使用KeyedProcessFunction 5. 侧输出流（Side Output） 1. 基本处理函数（ProcessFunction） 之前所介绍的流处理API，无论是基本的转换、聚合，还是更为复杂的窗口操作，其实都是基于DataStream进行转换的，所以可以统称为DataStream API。
在Flink更底层，我们可以不定义任何具体的算子（比如map，filter，或者window），而只是提炼出一个统一的“处理”（process）操作——它是所有转换算子的一个概括性的表达，可以自定义处理逻辑，所以这一层接口就被叫作“处理函数”（process function）。
1.1 处理函数的功能和使用 我们之前学习的转换算子，一般只是针对某种具体操作来定义的，能够拿到的信息比较有限。如果我们想要访问事件的时间戳，或者当前的水位线信息，都是完全做不到的。跟时间相关的操作，目前我们只会用窗口来处理。而在很多应用需求中，要求我们对时间有更精细的控制，需要能够获取水位线，甚至要“把控时间”、定义什么时候做什么事，这就不是基本的时间窗口能够实现的了。
这时就需要使用底层的处理函数。处理函数提供了一个“定时服务”（TimerService），我们可以通过它访问流中的事件（event）、时间戳（timestamp）、水位线（watermark），甚至可以注册“定时事件”。而且处理函数继承了AbstractRichFunction抽象类，所以拥有富函数类的所有特性，同样可以访问状态（state）和其他运行时信息。此外，处理函数还可以直接将数据输出到侧输出流（side output）中。所以，处理函数是最为灵活的处理方法，可以实现各种自定义的业务逻辑。
处理函数的使用与基本的转换操作类似，只需要直接基于DataStream调用.process()方法就可以了。方法需要传入一个ProcessFunction作为参数，用来定义处理逻辑。
stream.process(new MyProcessFunction()) 这里ProcessFunction不是接口，而是一个抽象类，继承了AbstractRichFunction；MyProcessFunction是它的一个具体实现。所以所有的处理函数，都是富函数（RichFunction），富函数可以调用的东西这里同样都可以调用。
1.2 ProcessFunction解析 在源码中我们可以看到，抽象类ProcessFunction继承了AbstractRichFunction，有两个泛型类型参数：I表示Input，也就是输入的数据类型；O表示Output，也就是处理完成之后输出的数据类型。
内部单独定义了两个方法：一个是必须要实现的抽象方法.processElement()；另一个是非抽象方法.onTimer()。
public abstract class ProcessFunction&lt;I, O&gt; extends AbstractRichFunction { ... public abstract void processElement(I value, Context ctx, Collector&lt;O&gt; out) throws Exception; public void onTimer(long timestamp, OnTimerContext ctx, Collector&lt;O&gt; out) throws Exception {} .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ade1ffc9151e015c51fd799874794d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5ebe5addfbac1d597a5b3bab9bb8928/" rel="bookmark">
			STM32 IAR7.30开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要内容来至于网络，感谢网络同仁的贡献。
1 Keil-MDK
工程后缀: .uvprojx
1.1 Keil-MDK Install Guide
PSN: U1E21-CM9GY-L3G4L
MDK: Microcontroller Development Kit
2 IAR Embedded WorkBench for ARM (EWARM)
工程后缀: .eww
由于ST官方的examples基于IAR编写，所以选择IAR安装。
2.1 生成序列号（IAR7.30注册机）
首先打开IAR7.30注册机文件夹里面有四个文件
按照使用方法操作就可以。
2.1.1 单击IARID.EXE得到本机的ID号
我这里的电脑硬件ID号为：0x1A556。每个电脑都不一样，所以这步必须要有。强调：千万不要直接就用该手册上的ID号。
2.1.2 用UltraEdit软件打开Key.cmd，将ID修改为本机ID
上面是直接打开Key.cmd的界面。
修改之后的界面如下。
可以看出我已经把ID从之前的“0x178D8”改为“0x1A556”了。改了之后需要保存。
2.1.3 运行KEY.cmd，在key.txt中的含有EW8051-EV的序列号就是7.30的序列号
运行KEY.cmd之后，在文件夹中会多出一个文件key.txt
那么打开key.txt
选中部分就是我们需要的东西了。
2.2 安装IAR
运行
Next
Accept
这里就要开始用到序列号了。
把上图的
改成
改了之后为
Next
可以看到LicenseKey是空的，那么把
带色部分复制过去
Next
不要使用带有中文的路径
Next
Next
Next
Next
进入安装过程，要等个几分钟
Finish。
3 DEBUG工具
3.1 JLINK
JLINK使用的SoC是AT91SAM7S64，JLINK是通用的开发工具，可以用于Keil MDK、IAR、ADS等平台，速度、效率、功能均比ULINK强。
3.2 STLINK
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5ebe5addfbac1d597a5b3bab9bb8928/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/967e2a4e7aa471690e8e6b00bef10b06/" rel="bookmark">
			el-select可输入下拉框限制长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		el-select可输入或可输入创建限制长度
可创建自定义指令v-Length=“50”，限制输入最大长度为50
&lt;el-select v-model="JSDW" filterable clearable v-limitLength="50" allow-create default-first-option style="width:100%"&gt; &lt;el-option v-for="(item, index) in ListJSDW" :key="index" :label="item" :value="item"&gt; &lt;/el-option&gt; &lt;/el-select&gt; 局部创建自定义指令
created() { }, // 控制-select输入长度 自定义指令 // 控制-select输入长度 自定义指令 directives: { limitLength: { bind: function (el, binding, vnode) { const input = el.getElementsByTagName('input')[0] if (input) { input.setAttribute('maxlength', binding.value) } } } }, mounted() { }, 全局创建自定义指令，在main.js里
Vue.directive('limitLength',{ inserted: function (el, binding, vnode) { const input = el.getElementsByTagName('input')[0] if (input) { input.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/967e2a4e7aa471690e8e6b00bef10b06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cbd56553fef6e38a9cc79fdc21c77b8/" rel="bookmark">
			网络PDF文件转图片并通过nginx代理预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、网络PDF转图片
/** * @param pdfOss 原文件 * @param desFilePath 生成图片的路径 * @param desFileName 生成图片的名称（多页文档时会变成：名称+下划线+从1开始的数字） * @param imageType 图片类型 * @return */ public static Pair&lt;Boolean, Object&gt; pdfToImage(String pdfOss, String desFilePath, String desFileName, String imageType) { File destination = new File(desFilePath); if (!destination.exists()) { destination.mkdirs(); } try { URL url = new URL(pdfOss); PDDocument document = PDDocument.load(url.openStream()); PDFRenderer pdfRenderer = new PDFRenderer(document); //获取PDF文档的页数 int pageCount = document.getNumberOfPages(); System.out.println("文档一共" + pageCount + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cbd56553fef6e38a9cc79fdc21c77b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/900c5d9208a7426b8ffa25f20fc7f7d7/" rel="bookmark">
			探索未来的方向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运维工程师的出路到底在哪里？ 随着技术的不断发展和进步，运维行业也在不断演变。对于许多运维人员来说，他们可能会感到困惑，不知道自己的出路在哪里。本文将探讨运维人员未来的发展方向和机会。
首先，对于那些对技术有浓厚兴趣的运维人员，他们可以选择深入研究和掌握新技术。例如，云计算、容器技术、Kubernetes、DevOps 等新技术为运维人员提供了广阔的发展空间。通过学习和实践这些新技术，运维人员可以提高自己的技能和知识，并更好地应对不断变化的 IT 环境和技术。
其次，运维人员可以考虑向开发或测试方向发展。随着 DevOps 理念的普及，开发和运维之间的界限逐渐模糊。运维人员了解应用程序的部署、监控和故障排除等方面的知识，这些知识也可以应用于开发和测试领域。通过了解开发流程、测试技术和工具等方面的知识，运维人员可以更好地与开发团队合作，提高应用程序的质量和稳定性。
此外，运维人员还可以探索大数据和人工智能领域。随着大数据和人工智能技术的快速发展，这些领域需要大量的运维人员来支持数据的存储、处理和管理。通过学习和实践这些新技术，运维人员可以扩展自己的技能范围，并寻找新的职业机会。
最后，运维人员可以考虑向管理岗位发展。随着经验的积累和技能的提升，运维人员可以逐渐转向管理岗位，成为项目经理或团队负责人等。在这个过程中，运维人员需要学习如何管理团队、协调项目和制定计划等方面的知识。
总之，运维的出路在于不断学习和探索新的技术和理念。通过提升自己的技能和知识，运维人员可以应对不断变化的 IT 环境和社会需求，并找到适合自己的职业发展方向。无论选择哪个方向，重要的是保持学习的态度和对技术的热情，不断追求进步和发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbe3a89c07bc0b0d2cbdefe53c4a4dd5/" rel="bookmark">
			PYTHON基础：数据可视化绘图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python数据可视化入门 –常见的四种数据图形绘制
数据可视化在数据分析和数据科学中起着重要的作用。它可以帮助我们更直观地理解和解释数据，发现数据中的模式、趋势和异常。
在数据可视化中，常用的图表类型包括折线图、散点图、直方图和饼图，每种图表类型都适用于不同类型的数据和目的。
折线图：用于显示随时间或其他连续变量而变化的数据，可以展示趋势和变化情况。
散点图：用于显示两个变量之间的关系，每个数据点代表一个观测值，可以帮助发现变量之间的相关性或集群。
直方图：用于显示数据的分布情况，将数据分成若干个区间，并统计每个区间内的观测数量或频率。
饼图：用于显示分类数据的占比情况，将数据按照类别划分，并展示每个类别的相对比例。
除了以上常用的图表类型，还有其他更复杂的图表类型和可视化技术，如箱线图、热力图、地图等，可以根据具体的数据和分析目的选择合适的图表类型。
在Python中，使用Matplotlib、Seaborn、Plotly等库可以轻松地进行数据可视化。这些库提供了丰富的函数和方法，可以进行数据处理、图表绘制、样式设置等操作，帮助我们快速生成高质量的图表。
通过数据可视化，我们可以更好地理解数据，发现数据中的规律和趋势，从而支持决策制定、问题解决和进一步的数据分析工作。
这里我就先介绍最基础的四个数据图的创建方法，按折线图、散点图、直方图和饼图的先后顺序，我直接把讲解以注释的形式打在代码旁边就不多写旁白了
折线图
import matplotlib.pyplot as plt ’‘’每次绘图基本上都会用到matplotlib这个模块，import 表示引用，as 的意思就是因为每次都写这个字母太长了，直接用一个plt代替‘’‘ squares=[1,4,9,16,25]#我们的y轴 x=[1,2,3,4,5]#我们的x轴 plt.style.use('seaborn')#这里其实可有可无，这个用来选择 plt.plot(x,squares,linewidth=5)#这个就是创建图像，括号里面的是先x轴，y轴还有我创建的线的大小 plt.title('square nunber',fontsize=24)#这里英文叫title中文的意思，用来设置标题的 plt.xlabel('value',fontsize=14)#设置x轴名称和字体大小 plt.ylabel('square of value',fontsize=14)#设置y轴的名称和字体大小 plt.tick_params(axis='both',labelsize=12)#设置刻度样式，指定的实参将影响x y轴的刻度（axis=both），labelsize是设置字号 plt.show()#让图像显示出来 这段代码同样使用了Matplotlib库来创建一个折线图。
代码中首先定义了两个列表x和squares，分别表示横坐标和纵坐标的数据。
接着，使用plt.style.use(‘seaborn’)选择了一个风格为’seaborn’的样式。
然后，使用plt.plot()函数绘制折线图，传入x和squares作为数据点的横坐标和纵坐标。linewidth参数设置折线的宽度。
接下来，使用plt.title()、plt.xlabel()和plt.ylabel()函数设置图表的标题、x轴和y轴的名称，并指定字体大小。
使用plt.tick_params()函数设置刻度样式，其中axis='both’表示同时设置x轴和y轴的刻度样式，labelsize=12指定刻度标签的字号为12。
最后，使用plt.show()显示图表。
整体而言，这段代码通过Matplotlib库创建了一个折线图，展示了x和squares两个列表的数据关系。图表具有标题、轴标签和刻度样式等，使得数据更加易于理解和解读。
散点图
import matplotlib.pyplot as plt squares=[1,4,9,16,25] x=[1,2,3,4,5] plt.scatter(x,squares,linewidth=5) plt.title('square nunber',fontsize=24) plt.xlabel('value',fontsze=14)#设置x轴名称和字体大小 plt.ylabel('square of value',fontsize=14)#设置y轴的名称和字体大小 plt.tick_params(axis='both',labelsize=12)#设置刻度样式，指定的实参将影响x y轴的刻度（axis=both），labelsize是设置字号 plt.show() 这段代码使用了Matplotlib库来创建一个散点图。
首先，定义了两个列表x和squares，分别表示横坐标和纵坐标的数据。
接着，使用plt.scatter()函数绘制散点图，传入x和squares作为数据点的横坐标和纵坐标。linewidth参数设置散点的边界宽度。
然后，使用plt.title()函数设置图表的标题为"square number"，并指定字体大小为24。
接下来，使用plt.xlabel()和plt.ylabel()函数设置x轴和y轴的名称，同时指定字体大小为14。
使用plt.tick_params()函数设置刻度样式，其中axis='both’表示同时设置x轴和y轴的刻度样式，labelsize=12指定刻度标签的字号为12。
最后，使用plt.show()显示图表。
整体而言，这段代码通过python库创建了一个散点图，展示了x和squares两个列表的数据关系。图表具有标题、轴标签和刻度样式等，使得数据更加易于理解和解读。
柱状图
import numpy as np#这个也是数据分析常用的库之一，里面有很多有用的函数，比如下面就用到 import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbe3a89c07bc0b0d2cbdefe53c4a4dd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef72aa674633608259adee65bb7ef314/" rel="bookmark">
			iOS/Mac项目接入字体（壳工程/组件库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iOS/Mac项目接入字体 一、准备二、接入1，壳工程接入和使用2，组件库接入和使用 为了减少专利字体对项目的影响，项目工程中需要接入公司自己的字体库，对于iOS/Mac项目来说接入非系统的外部字体，或者第三方字体，放在壳工程下，操作步骤以及使用来说相对简单，并且常用，如果放到组件库中多需要注意Bundle的影响，以及多了字体库的安装步骤（不建议在组件中） 一、准备 1，项目工程2，外部字体（思源字体为例，需要UDC（京东）字体的请小窗）
网盘链接: https://pan.baidu.com/s/1cOgxNGmeTlQdg7HWrrcYag 提取码: kw8v 二、接入 1，壳工程接入和使用 1，字体下载完后，解压到本地，常用字体文件格式有.otf，.ttf，.ttc等。
2，添加到Xcode工程，可以直接把字体文件拖拽到壳工程并"Copy Bundle Resources"，也可以在 File-&gt;Add Files to “xxx”，将字体文件添加到壳工程中
3，Info.plist文件，新增Key- Value，“Fonts provided by application” 添加字体数组，eg.
直接通过索引名称使用，或者通过遍历UIFont.familyNames，找到相应的名字使用。
public extension UIFont { /// 扩展字体，非系统字体, 字体大小，字体名称，如果找不到相关字体，允许返回nil class func ex_extFont(ofSize fontSize: CGFloat, fontName: String) -&gt; UIFont? { return self.init(name: fontName, size: fontSize) } /// 思源黑体字体支持 class func SourceHLight(ofsize fontSize: CGFloat) -&gt; UIFont { return ex_extFont(ofSize: fontSize, fontName: "SourceHanSansCN-Light") ?? ex_light(ofSize: fontSize) } class func SourceHBold(ofsize fontSize: CGFloat) -&gt; UIFont { return ex_extFont(ofSize: fontSize, fontName: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef72aa674633608259adee65bb7ef314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46b6186f8212e4c4a32dfb96917d45f3/" rel="bookmark">
			安全生产信息化平台是如何实现“五要素”的动态管理的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安全生产信息化平台以集成信息技术和管理理念为基础，实现了对“五要素”（人、机、料、法、环）的动态管理。以下是该平台如何实现这一目标的简要说明：
人员管理：通过建立员工档案和记录员工的安全培训、证书、违章记录等信息，平台可以实时监测员工的安全行为并对违章行为进行预警和记录。同时，平台提供在线安全培训和教育资源，帮助提高员工的安全意识和操作技能。
设备管理：平台记录设备的运行状况、维护记录、检修计划等信息，并通过实时监测和分析设备运行数据，及时发现设备故障和隐患，确保设备良好的工作状态。此外，平台还可以进行远程监控和调试，提高设备维护效率和准确性。
物料管理：平台严格管理原料、产品、备品备件等物料的库存，记录其入库、出库、存储情况，并实时监测和分析物料库存数据，以确保物料的安全存储和运输，防止因物料管理不善导致的事故。
法规与制度管理：平台集成国家和地方的安全生产法规、企业内部的安全管理制度和操作规程等信息，以确保这些法规和制度得到有效执行和监督。同时，为员工提供在线培训和考试功能，保证员工对相关法规和制度有深入的了解。
环境监测与管理：平台实时监测生产环境的温度、湿度、压力等参数，确保生产环境符合工艺要求，并对环境监测数据进行历史记录和分析，及时发现并处理潜在的环境问题。
通过上述五个方面的动态管理，安全生产智能化平台能够为企业提供全面的安全管理解决方案，提高企业的安全管理水平，降低安全生产事故的风险。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/119cef7ccde5f9f3a238b8342e1e5d99/" rel="bookmark">
			深入理解通用的HTTP POST请求发送方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入理解通用的HTTP POST请求发送方法 代码解析： 在现代的软件开发中，与服务端进行HTTP通信是一项基础而重要的任务。本篇博客将深入研究并详细解释一个通用的HTTP POST请求发送方法，该方法使用了 RestTemplate 库来简化HTTP通信。我们将逐行分析代码，理解每一步的操作，并通过一个简单的示例演示如何使用这个方法。
public &lt;T&gt; void post(String urlPart, T requestBody) { String url = this.baseUrl + urlPart; HttpHeaders httpHeaders = new HttpHeaders(); httpHeaders.setContentType(MediaType.APPLICATION_JSON); HttpEntity&lt;T&gt; requestEntity = new HttpEntity&lt;&gt;(requestBody, httpHeaders); try { restTemplate.postForObject(url, requestEntity, Void.class); } catch (HttpServerErrorException ex) { handleHttpServerErrorException(ex, url); } catch (HttpClientErrorException ex) { handleHttpClientErrorException(ex, url); } } 步骤 1：构建完整的URL String url = this.baseUrl + urlPart; 这一步将基础URL this.baseUrl 与传入的 urlPart 拼接，形成完整的目标URL。这是为了确保我们向正确的目标发送HTTP请求。
步骤 2：设置HTTP请求头 HttpHeaders httpHeaders = new HttpHeaders(); httpHeaders.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/119cef7ccde5f9f3a238b8342e1e5d99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3637f3119f7cc12cd3c27c42acc631c/" rel="bookmark">
			3D模型自动展开2D版型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍如何将 3D 模型转换为2D版型以进行模拟和缝纫。
首先下载插件的最新版本。将存档保存在电脑上的某个位置。 在 Blender 中，转到编辑 &gt; ⚙️ 首选项 &gt; 附加组件 &gt; 安装...，并选择 .zip 文件。安装后确保启用该附加组件。
NSDT工具推荐： Three.js AI纹理开发包 - YOLO合成数据生成器 - GLTF/GLB在线编辑 - 3D模型格式在线转换 - 可编程3D场景编辑器 - REVIT导出3D模型插件 - 3D模型语义搜索引擎 1、准备网格 输入网格应满足一些要求。 它不一定是完美的，但应该是干净的。 它应该是多方面的，确保法线正确，并且不应该太密集。
2、添加接缝 现在是添加接缝（seam）的时候了。 你可能已经猜到，该插件创建的“缝纫图案”实际上只是 UV 布局，但是是 3D 形式。 因此，为了获得良好的缝纫图案，我们需要良好的 UV 布局。
继续在网格周围你认为合适的地方添加接缝。 有些接缝会很好地包裹现有的几何体，就像此处所示的 Suzanne 示例中的情况一样：
情况并非总是如此，有时你需要使用 Knife K 或 Connect vertex path J 等工具进行额外的切割。 这通常会给你留下不好的几何形状，因为这种切割会产生微小的边缘和三角形。
可以使用此附加组件中包含的“边缘”&gt;“清理刀切”操作符。 干净地解决这个问题。 选择想要清理的边缘链（通常是刚刚切割的部分），然后运行操作。 增加“最小边长”，直到所有小三角形都消失。 如果边链弯曲，可以放松它。 你还可以松弛相邻顶点。
像平常一样展开模型。 重要的是接缝始终与UV 相匹配！ 这是因为接缝用于切割，而 UV 用于展开！ 可以通过想象拉伸来了解你的展开效果如何。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3637f3119f7cc12cd3c27c42acc631c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16359c1040171095ca34f7801f594c37/" rel="bookmark">
			PYTHON基础：SVM不同核函数的区别与选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SVM不同核函数区别与选择 支持向量机（Support Vector Machine，SVM）是一种常用的监督学习算法，它可以将数据从低维空间映射到高维空间，以便更好地进行分类或回归分析。SVM的关键思想是找到一个能够最大化分类边界（或称为超平面）的决策边界，这个边界可以最好地区分不同类别的数据点。
在SVM中，我们使用内核函数（kernel function）来实现数据从低维到高维的映射。常用的内核函数包括线性内核（linear kernel）、多项式内核（polynomial kernel）和径向基函数内核（radial basis function kernel，RBF）。这些内核函数可以帮助SVM处理非线性可分的数据。
为了说明不同内核函数的效果，让我们以红酒数据为例进行说明。我们使用相同的红酒数据，在使用四种不同的内核函数下绘制数据的图形，以观察它们的区别。
首先，我们需要加载红酒数据，并使用SVM算法和不同的内核函数进行建模和预测。然后，我们可以将预测结果可视化，以便比较不同内核函数的分类效果。通过这种方式，我们可以直观地理解不同内核函数在SVM中的作用，以及它们对数据的影响。
在具体编程实现时，我们可以使用Python的相关库（如scikit-learn）来实现SVM算法，并结合matplotlib等库来进行数据可视化。通过这样的实例，我们可以更好地理解SVM的内核函数以及它们在实际数据上的应用效果。
#导入红酒数据库 from sklearn.datasets import load_wine #定义函数来绘制画图 def make_meshgrid(x,y,h=.02): x_min,x_max=x.min()-1,x.max()+1 y_min,y_max=y.min()-1,y.max()+1 xx,yy=np.meshgrid(np.arange(x_min,x_max,h),np.arange(y_min,y_max,h)) return xx,yy #定义一个绘制等高线的函数 def plot_contours(ax,clf,xx,yy,**params): z=clf.predict(np.c_[xx.ravel(),yy.ravel()]) z=z.reshape(xx.shape) out=ax.contourf(xx,yy,z,**params) #使用酒的数据 wine=load_wine() #选取数据中的前两个数据 X=wine.data[:,:2] y=wine.target C=1.0#SVM的正规化参数 models=(svm.SVC(kernel='linear',C=C),#线性可调 svm.LinearSVC(C=C),#线性不可调 svm.SVC(kernel='rbf',gamma=0.7,C=C), svm.SVC(kernel='poly',degree=3,C=C)) models=(clf.fit(X,y) for clf in models) #设定图片的题目 titles=('SVC with linear kernel','linearSVC (linear kernel)','SVC with RBF kernel','SVC with polymomial(degree 3)kernel') #设定一个子图形的个数和排列方式进行画图 fig,sub=plt.subplots(2,2) plt.subplots_adjust(wspace=0.4,hspace=0.4) #使用前面的函数进行画图 X0,X1=X[:,0],X[:,1] xx,yy=make_meshgrid(X0,X1) for clf,title,ax in zip(models,titles,sub.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16359c1040171095ca34f7801f594c37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acb67b2b6121f8170585a10ff99203d5/" rel="bookmark">
			神奇网站1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​ ​​​​​​
有良心的up会留下地址：
1.depix：https://github.com/spipm/Depix
2.amphion：https://huggingface.co/spaces/amphion/singing_voice_conversion
3.outfit anybody：https://humanaigc.github.io/outfit-anyone/
4.NERF：https://developer.nvidia.com/blog/getting-started-with-nvidia-instant-nerfs/
5.PIA：https://pi-animator.github.io/
6.video poet：https://blog.research.google/2023/12/videopoet-large-language-model-for-zero.html
7.AI读心术：https://ai.meta.com/blog/brain-ai-image-decoding-meg-magnetoencephalography/
8.luciddreamer:https://luciddreamer-cvlab.github.io/
9.deepmotion：https://www.deepmotion.com/animate-3d
10.midjourney：https://www.midjourney.com/home?callbackUrl=%2Fexplore
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4869a4f8ca018f33bc9a828c3ea431a/" rel="bookmark">
			2023年，我国有哪些创新成就？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 创新成果令人振奋创新能力稳步提升创新生态持续优化 2023年，对中国的创新事业而言，又是非凡的一年！
这一年，“奋斗者”号完成国际首次环大洋洲载人深潜科考任务，大飞机C919完成首次商业载客飞行，全球首台16兆瓦海上风电机组并网发电，自主三代核电技术“华龙一号”全球首堆示范工程通过竣工验收，国产大型邮轮制造摘取了造船业的“第三颗明珠”，全球首颗忆阻器存算一体芯片诞生……今年以来，一系列新发明、新技术、新产品、新装备成为产业升级、结构优化的重要驱动力量，科技创新持续赋能高质量发展。
丰富的创新成果背后是强劲的创新能力，此二者离不开良好的创新生态。这些熠熠生辉的创新成就表明，中国的科技实力正从量的积累迈向质的飞跃、从点的突破迈向系统能力提升。伴随着加快实现高水平科技自立自强的步伐，强国梦想必将更好地照进现实。
创新成果令人振奋 这一年，中国的创新成果令人振奋!
中国空间站，神舟十七号与神舟十六号两个乘组在中国空间站胜利“会师”。这是在中国首艘载人飞船神舟五号实现中华民族千年飞天梦20周年之际，第一批、第二批和第三批中国航天员首次在中国空间站同框……
江西万安，自主育种研发的油菜新品种“中油早1号”，油菜籽亩产达到175.7公斤——中国农科院油料所团队6年持续耕耘，创造了新的高产纪录。
安徽合肥，“人造太阳”全超导托卡马克核聚变实验装置（EAST），成功实现稳态高约束模式等离子体运行403秒——中国科学院合肥物质科学研究院等离子体物理研究所EAST大科学团队聚力攻关，迎来重大突破。
从头顶的星辰到脚下的大地，从广袤的宇宙到幽微的粒子，2023年，中国不断取得重大原创性科技成果。
顺利起飞、平稳落地、跨过水门……5月28日，中国自主研发的大型客机C919成功完成首次商业载客飞行。在民用航空领域，大型客机被誉为“现代制造业的明珠”。其制造能力直接反映一个国家的工业水平。C919的一飞冲天让中国人的“大飞机梦”成为现实。
为助力“双碳”目标实现，6月1日，中国首个海上二氧化碳封存示范工程项目在南海东部海域正式投用，开始规模化向海底地层注入伴随海上石油开采产生的二氧化碳。该项目填补了中国海上二氧化碳封存技术的空白。
“中国芯”也在技术上取得了突破。9月，一篇在国际学术期刊在线发表的文章介绍了清华大学集成电路学院吴华强教授、高滨副教授团队的最新研究成果——基于存算一体计算范式研制出的全球首颗全系统集成、支持高效片上学习（机器学习能在硬件端直接完成）的忆阻器存算一体芯片。该芯片展现出卓越的能效优势，具有满足人工智能时代高算力需求的潜力。
9月27日，被称为“千眼天珠”的国家重大科技基础设施“空间环境地基综合监测网”（子午工程二期）标志性设备之一——圆环阵太阳射电成像望远镜（以下简称圆环阵）顺利通过工艺测试，正式建成。圆环阵不但能监测太阳的各种爆发活动，还能监测太阳风暴进入行星际的过程。这对于理解太阳爆发机制和日地传播规律、预测太阳活动对地球的影响有重要作用。
随着绿色动力关键技术不断取得新突破，长江黄金水道中的船舶也用上了“新能源”。10月11日，随着“启航”声响彻江面，中国首艘氢燃料电池动力示范船“三峡氢舟1”号在长江三峡起始点湖北宜昌首航，实现了氢燃料电池技术在中国内河船舶应用的“零的突破”，开启了长江航运的氢能时代。
2023年，中国新能源车产业发展迅猛。11月24日，比亚迪公司宣布第600万辆新能源汽车下线。第一个“100万辆”用时13年，第六个“100万辆”仅用时3个多月。今年上半年，中国的汽车出口已经超过日本，跃居世界第一，其中新能源汽车表现尤为亮眼。
2023年，中国长征系列运载火箭也迎来第500次发射。12月10日，中国在西昌卫星发射中心使用长征二号丁运载火箭，成功将遥感三十九号卫星发射升空。自1970年长征一号运载火箭发射东方红一号卫星至今，中国航天用53年的历程完成了“从0到500”的突破。其中，长征火箭第1个百次发射用了37年，第5个百次仅用了2年，不断刷新中国航天新纪录。
2023年，中国还摘取了造船业的“第三颗明珠”。总吨位13.55万吨，长323.6米，宽37.2米，最大高度72.2米；全船搭载107个系统、5.5万个设备，包含2500万个零部件，完工敷设4750公里电缆……11月4日，中国首艘国产大型邮轮“爱达·魔都号”正式命名交付。
中国超高速下一代互联网主干通路也在2023年开通。11月13日，清华大学宣布全球首条1.2T（传输速率为每秒1200G比特）超高速下一代互联网主干通路正式开通。该通路的整体技术水平不仅全球领先，且实现了系统软、硬件设备的全部国产和自主可控。它的建成，意味着中国互联网主干通路技术达到T比特级的门槛。
创新能力稳步提升 2023年，中国创新能力继续稳步提升!
今年以来，中国瞄准关键核心技术进行攻关，着力提升科技前沿领域原始创新能力，不断取得新突破，为持续增强产业链供应链韧性夯实了基础。随着高水平科技自立自强扎实推进，部分领域关键核心技术实现突破和产业化，科技创新对经济增长的带动作用提升。
国家创新指数是反映国家综合创新能力的重要指标。11月21日，由中国科学技术发展战略研究院发布的《国家创新指数报告2022—2023》显示，全球创新格局保持亚美欧三足鼎立态势，科技创新中心东移趋势更加显著，中国创新能力综合排名上升至第十位，向创新型国家前列进一步迈进。
《国家创新指数报告》选取与中国具有可比性的40个国家（其研发投入总和占全球95%以上，GDP之和占世界85%以上）作为评价对象，从创新资源、知识创造、企业创新、创新绩效和创新环境5个维度构建了评价指标体系，使用权威的国际组织和国家官方统计调查数据，客观研判中国在国际科技创新格局中的地位，全面反映中国科技创新投入、产出和支撑经济社会发展能力。结果显示，2023年，中国国家创新指数综合排名世界第十位，较上期提升3位，是唯一进入前15位的发展中国家。国家创新能力取得了显著进步，从2000年的第三十八位快速提升至2011年的第二十位，随后稳步上升至第十位。
从国家创新指数5个分指数来看，中国在各个维度均有不俗表现。尤其是在“知识创造”上表现突出，得分83.7分，排名第三位。
创新生态持续优化 2023年是中国创新生态持续优化的一年!
多项政策相继出台，营造出良好创新生态：青年科技人才发展有了支撑“硬举措”，科研“她力量”迎来更公平的成长环境，企业税惠“大礼包”提质升档助力科技创新……全社会支持创新、投入创新、参与创新、推动创新的热情高涨。
随着创新驱动发展战略深入实施，科技创新持续赋能实体经济，新产业新动能不断发展壮大，对经济增长的带动作用提升。
一方面，一批产业链条长、技术含量高、带动能力强的行业加快发展。1—10月份，汽车制造业、电气机械和器材制造业工业增加值同比增长11.3%、13.6%。边缘计算、工业大数据、通用人工智能等关键技术研发和产业化方兴未艾，推动服务业和制造业加速融合发展，工业互联网网络平台核心产业规模超过1.2万亿元，建成数字化车间和智能工厂近8000个。
另一方面，新模式、新业态持续活跃，引领带动力凸显。今年以来，电信广播电视及卫星传输服务、互联网软件及信息技术服务等文化相关行业的商务活动指数一直处于高景气区间。
今年以来，各地着力突破科技成果转化的市场化断点、利益共享痛点与产业化堵点。1—10月，高技术服务业中，科技成果转化服务业、专业技术服务业投资分别增长37.3%、29.1%。提升科技成果从“书架”到“货架”的转化速度，以效率变革、动力变革促进质量变革，我们就能不断突破高质量发展的卡点瓶颈，更好解决发展不平衡不充分问题。
企业是科技创新的主体。挖掘创新的潜力与活力，重点在企业。2023年，《中共中央国务院关于促进民营经济发展壮大的意见》发布，明确支持提升科技创新能力；国家发展改革委等部门出台促进民营经济发展的若干举措，支持民营企业参与重大科技攻关；国务院国资委推动中央企业加快发展战略性新兴产业……一系列政策举措同向发力、落地生根，企业创新活力得到进一步激发。随着企业科技创新主体地位不断强化，“创新之花”将更好结出“发展之果”，科技创新将持续赋能高质量发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6a5dfa9163365f716e7de3b0f7eb560/" rel="bookmark">
			湘潭大学-软件工程-大题浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 因为打印的资料只有少数几份有答案，所以这个部分比较简短
大题包括分析，设计， UML图，四个大题，占40分
应用设计题 1.建立软件公司的对象模型 矩形方框表示对象，只需要把题干所有信息用图表示出来即可，比较简单
泛化用空心箭头的实线表示，是继承关系
双向关联用一条实线，单向关联用带箭头的实线
空心菱形表示聚合关系
实心菱形表示组合关系
2.成人自学考试系统考务管理系统 要求画出数据流程图
矩形表示外部实体
椭圆表示数据加工
两条平行线表示数据存储
带箭头的实现表示数据流
3.图书分类目录 数据流图和软件结构图
按照前面的方法分析即可，注意不要遗漏信息
4计算机储蓄管理系统 画出数据流程图
同上，突然发现这种图其实非常简单
结语 笔者发现数据流图其实就只有上述这些内容，也有可能是因为资料不够全面，祝大家软工都能顺利通过
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a555035de17304e9ea24ffa16b78f77f/" rel="bookmark">
			14 简约登录页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果演示 实现了一个简单的登录表单的样式，包括背景颜色、边框、字体颜色、字体大小、字体粗细、输入框样式、提交按钮样式等。当用户在输入框中输入内容时，输入框下方的提示文字会动态地变化，以提示用户输入正确的信息。当用户点击提交按钮时，会触发一个事件，例如提交表单数据到服务器。
Code &lt;div class="form"&gt; &lt;div class="title"&gt;Welcome&lt;/div&gt; &lt;div class="subtitle"&gt;Let's create your account!&lt;/div&gt; &lt;div class="input-container ic1"&gt; &lt;input placeholder="" type="text" class="input" id="firstname"&gt; &lt;div class="cut"&gt;&lt;/div&gt; &lt;label class="iLabel" for="firstname"&gt;First name&lt;/label&gt; &lt;/div&gt; &lt;div class="input-container ic2"&gt; &lt;input placeholder="" type="text" class="input" id="lastname"&gt; &lt;div class="cut"&gt;&lt;/div&gt; &lt;label class="iLabel" for="lastname"&gt;Last name&lt;/label&gt; &lt;/div&gt; &lt;div class="input-container ic2"&gt; &lt;input placeholder="" type="text" class="input" id="email"&gt; &lt;div class="cut cut-short"&gt;&lt;/div&gt; &lt;label class="iLabel" for="email"&gt;Email&lt;/label&gt; &lt;/div&gt; &lt;button class="submit" type="text"&gt;submit&lt;/button&gt; &lt;/div&gt; body { height: 100vh; display: flex; justify-content: center; align-items: center; background-color: #e8e8e8; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a555035de17304e9ea24ffa16b78f77f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92465c6273f90973c985ee82bb1b9d47/" rel="bookmark">
			软件工程PPT 笔记摘录（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分析软件需求 UML 提供了用例图来分析和描述用例视角的软件需求模型
UML 提供了交互图和状态图来描述行为视角的软件需求模型
UML 提供了类图来描述和分析业务领域的概念模型
顺序图：强调消息传递的时间序
通信图：突出对象间的合作
类图，描述系统的类构成，刻画系统的静态组成结构
用单数名词来描述类名，少用缩写
对象图是一种静态瞬时快照，归于静态视图范畴
一般而言，控制类并不负责处理具体的任务细节，而是负责分解任务，并通过消息传递，将任务分派给其他对象类来完成，协调这些对象之间的信息交互
如果系列规模较大，分析类的数量多，关系复杂，难以用一张类图来完整和清晰地表示，那么可以分多个子系统来绘制分析类图
评审软件需求：内容的完整性，正确性，准确性，一致性，多余性，可追踪性，文档规范性，表述可读性，图表一致性（我想知道简答题到底是怎么考察，考这些知识确实是写不出来）
软件设计基础 功利一点，现在是期末考试复习，考试会挖什么空，接下来的内容尽量选这方面的
类的地位：类既是最基本的设计单元，也是最基本的模块单元（有点像初中政治，就怕是无用功）
软件设计的基本原则之一：模块化、高内聚度和低耦（ǒu）合度原则（感觉可能可以用上）
（简答题会不会就是每一个ppt的小结部分的内容）
软件设计是要给出软件需求的实现解决方案
设计既要满足需求，也要关注质量；设计用于指导实现和编码
软件设计有其过程，要循序渐进地开展设计
从体系结构设计、用户界面设计、详细设计
软件设计要遵循一系列的基本原则
模块化、信息隐藏、逐步求精、多视点等
面向对象软件设计的特点
基于面向对象的概念和抽象，系统性的设计支持，具有多种优点
对软件设计结果进行文档化和评审
撰写软件设计文档，发现和纠正软件设计中存在的缺陷
软件体系结构设计 包间关系：构成关系，依赖关系
之前一直弄不清楚的图之间的关系的汇总
包在模型管理过程中是配置管理的基本单元，同时也为访问控制提供基本手段
（像是要考察的句子）
软件系统的输入由数据源（data source）提供
管道与过滤器模式的特点
自然地解决具有数据流特征的软件需求
可独立地更新、升级过滤器来实现软件系统的扩展和进化
子系统是服务提供方，边界类是服务请求方
//怎么感觉没有什么内容，根本记不下来 软件体系结构的输出：软件模型和软件文档
软件体系结构设计的特殊性
具有宏观、全局、层次、战略、多视点、关键性等特点
逻辑视点、物理视点等，可用包图、部署图来表示
软件体系结构设计的重要性
针对软件系统全局性、基础性技术问题给出技术解决方案
软件体系结构的风格
管道、层次、MVC、黑板等等，针对不同软件需求及特点
软件体系结构设计的过程、策略和成果
考虑软件关键需求、利用已有软件资产、关注软件质量
软件体系结构的设计模型和文档
用户界面设计 用户界面元素：静态元素，动态元素，输入元素，命令元素
用户界面初步设计不关注美观和布局，关注界面元素及其内容
交互图
表示特定场景下的跳转及跳转发生时的消息传递
类图
表示界面间所有可能发生的跳转及跳转的原因
用户界面设计
以用户为中心
遵循理解性、易操作性、一致性、容错性和人性化等原则
用户界面设计的过程
以软件需求为依据
概念设计、跳转关系设计、界面精化、设计评审
用户界面设计的结果
用户界面原型
UML类图、交互图等模型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92465c6273f90973c985ee82bb1b9d47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad6f9c8c7c8a5179836b7b1d25ca0c51/" rel="bookmark">
			zookeeper基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
环境搭建
单机版搭建
集群版搭建
基本语法使用
可视化客户端
数据结构
节点分类
1. 持久节点
2. 临时节点
3. 有序节点
4. 容器节点
5. TTL节点
节点状态
监听机制
watch监听
永久性watch
应用场景
1. 实现分布式锁
2. 乐观锁更新数据
应用场景总结
Zookeeper集群架构
角色
集群架构
选举机制
选举时机
选举源码
选举规则
四字命令使用
1. 安装nc
2. 开启nc
3. 验证
4. 其他用法 环境搭建 单机版搭建 1. 官网下载zookeeper压缩包, 这里用3.8.3版本, 并解压
官网下载地址: Apache ZooKeeper
2. 复制示例配置文件
cp zoo_sample.cfg zoo.cfg zoo.cfg配置里面参数说明, 不用修改也能启动
# zookeeper基本时间单位，2妙 tickTime=2000 # follower初始化到leader最大时长, 表示tickTime的倍数, 也就是20秒 initLimit=10 # leader和follower同步数据的最大时长, 表示tickTime的倍数, 也就是10秒 syncLimit=5 # 数据和日志存储目录, 也可以配dataLogDir单独指定日志存储目录, 不建议放在默认的/tmp下 dataDir=/tmp/zookeeper # 对客户端提供端口号 clientPort=2181 # 对单个客户端提供最大连接数 #maxClientCnxns=60 # # Be sure to read the maintenance section of the # administrator guide before turning on autopurge.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad6f9c8c7c8a5179836b7b1d25ca0c51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/534a78e4ab0d9cfd38aa265ea22ca3ff/" rel="bookmark">
			Java与前端2023：真相与焦虑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言： 2023年，关于Java和前端行业的未来传言甚嚣尘上，一些人大胆预测“Java已死，前端已凉”。这究竟是真相，还是只是在贩卖焦虑？本文将深入探讨这一议题，解开Java和前端行业的迷雾。
1. Java：是否真的“已死”？ Java自诞生以来一直是企业级应用的首选语言，其强大的生态系统、跨平台性以及成熟的开发模式，使得它在大型项目中仍然占据主导地位。虽然近年来有更多的编程语言涌现，但Java的稳定性和广泛应用使其仍然是编程领域的支柱之一。在云计算、大数据、微服务等领域，Java仍然有着不可替代的地位。因此，说Java“已死”可能是一种过于激进的表述。
2. 前端：为何感到“已凉”？ 前端领域在过去的几年里经历了飞速的发展，各种新技术层出不穷。然而，这也导致了前端开发者需要不断学习新知识的压力。一些传言声称前端的发展已经达到了瓶颈，市场需求相对饱和。但实际上，随着移动端、WebAssembly、桌面应用等多个方向的发展，前端仍有大量的发展空间。只是需要前端开发者不断跟进技术潮流，适应新的工作方式。
3. Java与前端的融合： 在当今互联网的发展中，Java后端与前端技术的融合愈发密切。Java的框架和库支持前后端分离的开发模式，而前端技术的快速迭代也促使Java后端更加注重API的设计和开发效率。因此，Java后端与前端的协同工作仍然是一个重要的趋势。
4. 实际需求： 最终，技术的发展方向往往受实际需求驱动。企业在选择技术栈时更关注的是解决问题的能力，而不是某个特定技术的“生死”。在Java与前端之间，实际上是需要更好的集成、更高效的协同工作，而不是简单地进行“生死”划分。
结论： 在2023年，Java和前端行业都将继续发展，前途光明。而真相是，无论是Java还是前端，都需要适应变化、持续学习，并更加注重实际问题的解决。将两者合理融合，充分发挥各自优势，才是实现可持续发展的关键。贩卖焦虑的说法往往只是表面现象，真正的行业发展要看实际需求和创新能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d86b31a5e553f4da65704afbf5a9fd6/" rel="bookmark">
			如何将语音版大模型AI接入自己的项目里(语音ChatGPT)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何将语音版大模型AI接入自己的项目里语音ChatGPT 一、语音版大模型AI二、使用步骤1、接口2、请求参数3、请求参数示例4、接口 返回示例5、智能生成API代码 三、 如何获取appKey和uid1、申请appKey:2、获取appKey和uid 四、重要说明 一、语音版大模型AI 基于阿里通义千问、百度文心一言等国内主流AI大模型的语音版智能对话AI机器人API,支持聊天对话、行业咨询、语言学习等功能.支持自定义真人音色.
二、使用步骤 1、接口 重要提示:建议使用https协议,当https协议无法使用时再尝试使用http协议
请求方式: POST
https://luckycola.com.cn/voice/vaiV1 2、请求参数 序号参数是否必须说明1ques是你的问题2appKey是唯一验证AppKey, 可前往官网“个人中心“获取(http(s): //luckycola.com.cn), 下面具体介绍获取方法3uid是账号等唯一标识, 可前往官网“个人中心“获取(http(s): //luckycola.com.cn), 下面具体介绍获取方法4isLongChat否是否支持上下文(值为1或者0),1表示支持上下文,默认值0不支持5voiceType否自定义语音真人音色,可选值是:0(活泼男声)、1(俏皮女声)、2(醇厚男声)、3(亲切女声),默认值是0 注意!!!: 如果您还没有appKey和uid,请先请前往官网获取
官网地址:http(s): //luckycola.com.cn/
3、请求参数示例 { // 你的问题 "ques": "hello", // 官网-个人中心-Appkey获取 "appKey": "643************c3", // 官网-个人中心-用户ID "uid": "y*************6", // 自定义语音真人音色,可选值是:0(活泼男声)、1(俏皮女声)、2(醇厚男声)、3(亲切女声) "voiceType": 0, // 是否支持上下文 值1表示支持,0表示不支持 "isLongChat": 0 } 4、接口 返回示例 { // 成功状态码 "code": 0, // 成功提示 "msg": "ai回答返回成功", // 音频数据 "data": { "code": 0, // 当前音色类型 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d86b31a5e553f4da65704afbf5a9fd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d01f68768dea327f60dfe3ad36c3c65/" rel="bookmark">
			外卖订餐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 随着外卖订餐在高校越来越普及，传统的电话订餐给顾客跟外卖店带来不方便，如何使订餐更快速，更方便已成为众多高校学生关注的问题了。本外卖订餐管理系统是针对高校外卖店进行具体的需求分析，采用OOA（面向对象分析）和采用UML工具辅助开发分析，基于S2SH（Struts2+Spring+Hibernate）架构进行设计和开发。论文主要描述外卖订餐管理系统的开发流程，分别从需求分析和系统设计、详细设计与系统实现这几个阶段进行描述。
关键词：订餐管理系统 S2SH OOA
ABSTRACT
With more and more popular in universities order take-out, due to the traditional telephone reservation for customers to bring inconvenience take-away meal, how to make more quickly, more convenient has become the concern of the students. The take-away meal management system in colleges and universities is the concrete take-away demand analysis, using object-oriented analysis (OOA) and using UML tools to assist in the development, using Struts2-Spring-Hibernate framework to design and development.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d01f68768dea327f60dfe3ad36c3c65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7f0b914d6e894900a74c7f6a420a8e8/" rel="bookmark">
			数据库的连接池详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是数据库连接池？ 数据库连接池是一种管理和维护数据库连接的机制，用于提高数据库访问的性能和效率。连接池通过在应用程序启动时创建一组数据库连接，并在需要时将这些连接分配给应用程序，然后在不再需要时将其返回到池中。这可以减少创建和销毁数据库连接的开销，并优化数据库资源的使用。
连接的创建和销毁开销：
创建和销毁数据库连接是一项开销较大的操作。连接池通过预先创建一组连接，避免了每次请求都创建新连接的开销。这些连接在应用程序启动时初始化，并一直保持活动状态，直到应用程序关闭。
连接的重用：
连接池允许应用程序在需要时从池中获取连接，而不是每次都创建新连接。使用完毕后，连接可以被释放回池中以供其他请求使用。这种重用机制可以降低数据库服务器的负担，提高应用程序的性能。
为什么要使用数据库连接池？ 1.减少连接的创建和销毁开销：
数据库连接的创建和销毁是相对昂贵的操作。连接池通过在应用程序启动时创建一组连接，并在需要时将其分配给应用程序，从而减少了每次请求都创建和销毁连接的开销。
2.优化数据库资源的使用：
连接池能够重用连接，而不是每次都创建新连接。这样，数据库资源得以更好地利用，因为连接的重用可以减少服务器端的资源消耗。
3.避免连接泄漏：
连接池监控连接的状态，可以在连接空闲时间过长或者发生异常时进行回收。这有助于防止连接泄漏，即长时间占用的连接没有被及时释放。
4.限制并发连接数：
连接池可以限制同时存在的连接数量，防止过多的连接占用数据库资源。这通过连接池的最大连接数和最大溢出连接数来控制，确保系统不会超过容量。
5.提高系统性能：
通过重用连接、减少连接的创建和销毁，以及优化数据库资源的使用，连接池有助于提高应用程序的性能。系统中的请求能够更快地获取到数据库连接，而不必等待连接的创建。
6.支持并发访问：
在高并发环境下，使用连接池可以更好地支持大量并发请求。连接池会协调多个请求共享有限的数据库连接，以平滑处理高并发情况。
7.连接的超时处理：
连接池可以设置连接的超时时间，即连接在一定时间内没有被使用就会被回收。这有助于释放不再需要的连接，避免长时间占用连接的问题。
8.提高应用程序的可伸缩性：
通过减少数据库连接的创建和销毁开销，连接池有助于提高应用程序的可伸缩性。在高负载时，系统可以更好地处理更多的请求。
怎么使用数据库连接池？ 安装 SQLAlchemy：
pip install SQLAlchemy 创建数据库引擎和连接池：
使用 SQLAlchemy 创建数据库引擎，并在引擎中配置连接池。在配置连接池时，你可以设置最小连接数、最大连接数、连接超时等参数。
from sqlalchemy import create_engine, pool # 连接池配置，这里设置了最小连接数和最大连接数 pool_config = { "pool_size": 5, "max_overflow": 10, "pool_timeout": 30, # 单位是秒，等待连接的最大时间 } # 创建数据库引擎，使用连接池配置 engine = create_engine('sqlite:///:memory:', poolclass=pool.QueuePool, **pool_config) 获取连接和执行操作：
使用创建好的数据库引擎来获取连接，并执行数据库操作。注意，在使用完连接后，需要将连接释放回连接池。
# 从连接池中获取连接 connection = engine.connect() # 执行数据库操作 result = connection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7f0b914d6e894900a74c7f6a420a8e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98cd5e26efff7ce4c4087be5ecf0e0d5/" rel="bookmark">
			MongoDB数字字符串排序问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 MongoDB中有一个集合t_test_sort结构如下，其中数值字段value为字符串类型，现想按照value的数值大小进行降序排列。
{ "_id" : ObjectId("656c87b36ca8100cd4a60348"), "name" : "麻了", "date" : "2033-04-05", "value" : "-1.744353", "_class" : "com.rkyao.spring.boot.mongo.entity.MongoSortEntity" } 使用如下查询语句进行查询，得到的结果显然不对，这样是按照字符串进行排的，而不是数值大小
db.getCollection("t_test_sort") .find({}) .sort({ "value": -1 }) 尝试解决 网上搜索了一波解决方案都是要添加numericOrdering:true 配置，这样可以将字符串按照数值排序，但是试验后依然不行。
db.getCollection("t_test_sort") .find({}) .sort({ "value": -1 }) .collation({"locale": "zh",numericOrdering:true}) 百思不得其姐，查询MongoDB官方文档后找到了原因，原来是numericOrdering:true只支持非负整数，负数和小数都不支持
网上的方案行不通，只能继续研究了。
解决方案 方案一 把value字段的类型修改为数值型，但是修改字段的影响比较大，需要重新刷数据且有可能会影响其他业务，所以除非走投无路暂不考虑。
方案二 再次查询官方文档后找到了一个方法，可以在聚合管道中使用$toDecimal 将value字段的值转换为数值，赋给一个临时字段sortField，然后在根据sortField字段进行排序。
db.getCollection("t_test_sort").aggregate([ { $addFields: { sortField: { $toDecimal: "$value" } } }, { $sort: { sortField: -1 } } ]) 可以看到查询结果完全按照sortField数值大小降序排列，问题解决。
Java代码也一并给出来
public List&lt;MongoSortEntity&gt; sort() { List&lt;AggregationOperation&gt; operationList = new ArrayList&lt;&gt;(); operationList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98cd5e26efff7ce4c4087be5ecf0e0d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7999c3d6c7dae544a1b2253d7d180b9c/" rel="bookmark">
			《数据结构，算法与应用 C&#43;&#43;语言描述》- 第1章 练习题答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chapter1 练习题 Q1 解释：因为形参没有使用引用。形参是通过对实参的值进行的复制得到的，所以函数体中任何对形参的修改都不会作用于实参。
改进：
void swap(int&amp; x, int&amp; y) { int temp = x; x = y; y = temp; } Q2 注意模板函数如何传递数组的常量引用。语法const T (&amp;arr)[N]，解读
const常量，不允许修改实参
T为数组中元素的类型
(&amp;arr)表示对数组的引用
[N]表示数组的元素个数
注意声明数组的方式，未指定数组元素个数，由编译器根据{}中的元素个数确定。通过本例学会如何传递数据(按引用传递)
注意count()调用时，只传递了数组名，未传递数组大小
#include &lt;iostream&gt; template &lt;typename T, std::size_t N&gt; std::size_t count(const T (&amp;arr)[N]) { return N; } int main() { int intArray[] = {1, 2, 3, 4, 5}; double doubleArray[] = {1.1, 2.2, 3.3, 4.4}; std::size_t intCount = count(intArray); std::size_t doubleCount = count(doubleArray); std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7999c3d6c7dae544a1b2253d7d180b9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8bae19f208c6ba38fa83e12c832304c/" rel="bookmark">
			sheng的学习笔记-【目录】【中文】【deplearning.ai】【吴恩达课后作业目录】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 学习吴恩达的深度学习，用于记录笔记
知识目录和引用文章
原文见下面，但已经变为收费的：【目录】【中文】【deplearning.ai】【吴恩达课后作业目录】_吴恩达深度学习 何宽-CSDN博客
免费的用于学习的github地址， 包含笔记和代码，资料来源于
深度学习
GitHub - fengdu78/deeplearning_ai_books: deeplearning.ai（吴恩达老师的深度学习课程笔记及资源）
机器学习
GitHub - fengdu78/Coursera-ML-AndrewNg-Notes: 吴恩达老师的机器学习课程个人笔记
统计学方面知识
GitHub - fengdu78/lihang-code: 《统计学习方法》的代码实现
数据科学仓库：
GitHub - fengdu78/Data-Science-Notes: 数据科学的笔记以及资料搜集
知乎：
黄海广 - 知乎
[**笔记在线阅读**](http://www.ai-start.com/dl2017)
测验题的答案来自：
吴恩达 深度学习 【课后作业答案】 - 知乎
【目录】【吴恩达课后作业目录】备注吴恩达深度学习相关资源下载地址（蓝奏云）课程周数名称类型语言地址课程1 - 神经网络和深度学习第1周深度学习简介测验中传送门修改后无编程作业编程作业————第2周神经网络基础测验中传送门修改后具有神经网络思维的Logistic回归编程作业中文传送门第3周浅层神经网络测验中传送门修改后带有一个隐藏层的平面数据分类编程作业中文传送门第4周深度神经网络的关键概念测验中传送门修改后一步步搭建多层神经网络以及应用（1 &amp; 2）编程作业中文传送门课程2 - 改善深层神经网络第1周深度学习的实践测验中传送门修改后初始化、正则化、梯度校验（1 &amp; 2 &amp; 3）编程作业中文传送门第2周优化算法测验中传送门修改后优化算法实战编程作业中文传送门第3周超参数调整，批量标准化，编程框架测验中传送门修改后TensorFlow入门编程作业中文传送门课程3 - 结构化机器学习项目第1周和平之城中的鸟类识别(案例研究)测验中传送门修改后无编程作业编程作业————第2周自动驾驶（案例研究）测验中传送门修改后无编程作业编程作业————课程4 - 卷积神经网络第1周卷积神经网络的基本知识测验中英传送门修改后搭建卷积神经网络模型以及应用（1&amp;2）编程作业中文传送门第2周深度卷积模型测验中英传送门修改后Keras入门与残差网络的搭建编程作业中文传送门第3周检测算法测验中英传送门修改后车辆识别编程作业中文传送门第4周特殊应用：人脸识别和神经风格转换测验中英传送门修改后人脸识别与神经风格转换编程作业中文传送门课程5 - 序列模型第1周循环神经网络测验中英传送门搭建循环神经网络及其应用编程作业中文传送门第2周自然语言处理与词嵌入测验中英传送门词向量的运算与Emoji生成器编程作业中文传送门第3周序列模型与注意力机制测验中英传送门机器翻译与触发词检测编程作业中文传送门吴恩达深度学习相关资源下载地址（蓝奏云） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2907e617907d406102b5573c865233e9/" rel="bookmark">
			sheng的学习笔记-【中】【吴恩达课后测验】Course 4 -卷积神经网络 - 第四周测验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课程4_第4周_测验题 目录
第一题 1.面部验证只需要将新图片与1个人的面部进行比较，而面部识别则需要将新图片与K个人的面部进行比较。
A. 【 】正确
B. 【 】错误
答案：
A.【 √ 】正确
第二题 2.在人脸验证中函数d(img1,img2)起什么作用？
A. 【 】只需要给出一个人的图片就可以让网络认识这个人
B. 【 】为了解决一次学习的问题
C. 【 】这可以让我们使用softmax函数来学习预测一个人的身份，在这个单元中分类的数量等于数据库中的人的数量加1
D. 【 】鉴于我们拥有的照片很少，我们需要将它运用到迁移学习中
答案：
A.【 √ 】只需要给出一个人的图片就可以让网络认识这个人
B.【 √ 】为了解决一次学习的问题
第三题 3.为了训练人脸识别系统的参数，使用包含了10万个不同的人的10万张图片的数据集进行训练是合理的。
A. 【 】正确
B. 【 】错误
答案：
B.【 √ 】错误
第四题 4.下面哪个是三元组损失的正确定义（请把 α \alpha α也考虑进去）？
A. 【 】 m a x ( ∥ f ( A ) − f ( P ) ∥ 2 − ∥ f ( A ) − f ( N ) ∥ 2 + α , 0 ) max(\left \|f(A)−f(P)\right \|^2−\left \|f(A)−f(N)\right \|^2+\alpha,0) max(∥f(A)−f(P)∥2−∥f(A)−f(N)∥2+α,0)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2907e617907d406102b5573c865233e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90da48e3796fda34f3a58382f8c2ba5a/" rel="bookmark">
			sheng的学习笔记-【中】【吴恩达课后测验】Course 4 -卷积神经网络 - 第三周测验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课程4_第3周_测验题 目录
第一题 1.现在你要构建一个能够识别三个对象并定位位置的算法，这些对象分别是：行人（c=1），汽车（c=2），摩托车（c=3）。下图中的标签哪个是正确的？
注： y = [ p c , b x , b y , b h , b w , c 1 , c 2 , c 3 ] y=[p_c,b_x,b_y,b_h,b_w,c_1,c_2,c_3] y=[pc​,bx​,by​,bh​,bw​,c1​,c2​,c3​]
A. 【 】y=[1, 0.3, 0.7, 0.3, 0.3, 0, 1, 0]
B. 【 】y=[1, 0.7, 0.5, 0.3, 0.3, 0, 1, 0]
C. 【 】y=[1, 0.3, 0.7, 0.5, 0.5, 0, 1, 0]
D. 【 】y=[1, 0.3, 0.7, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90da48e3796fda34f3a58382f8c2ba5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0b32154078c284be6611d9e5bb875ed/" rel="bookmark">
			sheng的学习笔记-【中】【吴恩达课后测验】Course 4 -卷积神经网络 - 第二周测验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课程4_第2周_测验题 目录
第一题 1.在典型的卷积神经网络中，随着网络的深度增加，你能看到的现象是？
A. 【 】 n H n_H nH​和 n W n_W nW​增加，同时 n C n_C nC​减少
B. 【 】 n H n_H nH​和 n W n_W nW​减少，同时 n C n_C nC​也减少
C. 【 】 n H n_H nH​和 n W n_W nW​增加，同时 n C n_C nC​也增加
D. 【 】 n H n_H nH​和 n W n_W nW​减少，同时 n C n_C nC​增加
答案：
D.【 √ 】 n H n_H nH​和 n W n_W nW​减少，同时 n C n_C nC​增加
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0b32154078c284be6611d9e5bb875ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0f756cee3e97c3cc49fd0e710e68ce5/" rel="bookmark">
			编译时AndroidX冲突报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、报错信息 * Exception is: org.gradle.api.tasks.TaskExecutionException: Execution failed for task ':app:checkDebugDuplicateClasses'. at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.lambda$executeIfValid$1(ExecuteActionsTaskExecuter.java:145) at org.gradle.internal.Try$Failure.ifSuccessfulOrElse(Try.java:282) at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeIfValid(ExecuteActionsTaskExecuter.java:143) at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:131) at org.gradle.api.internal.tasks.execution.CleanupStaleOutputsExecuter.execute(CleanupStaleOutputsExecuter.java:77) at org.gradle.api.internal.tasks.execution.FinalizePropertiesTaskExecuter.execute(FinalizePropertiesTaskExecuter.java:46) at org.gradle.api.internal.tasks.execution.ResolveTaskExecutionModeExecuter.execute(ResolveTaskExecutionModeExecuter.java:51) at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:57) at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:56) at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:36) at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.executeTask(EventFiringTaskExecuter.java:77) at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:55) at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:52) at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:204) at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:199) at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:66) at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:59) at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:157) at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:59) at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:53) at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:73) at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter.execute(EventFiringTaskExecuter.java:52) at org.gradle.execution.plan.LocalTaskNodeExecutor.execute(LocalTaskNodeExecutor.java:74) at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:402) at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:389) at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:382) at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:368) at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.lambda$run$0(DefaultPlanExecutor.java:127) at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.execute(DefaultPlanExecutor.java:191) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0f756cee3e97c3cc49fd0e710e68ce5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d00c1f445e75b4feef2e2e1c79a7f4c/" rel="bookmark">
			简析SoBit 跨链桥图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从BTC网络到Solana网络桥接BRC20 1.打开SoBit平台：在您的网络浏览器中启动SoBit Bridge应用程序。
2.连接您的钱包： 选择SoBit界面右上角的比特币网络来连接您的数字钱包。
3.选择源链、目标链和您想桥接的代币： 从下拉菜单中选择’BTC’作为源链，’SOL’（Solana）作为目标链。
4.输入转账细节： 在’数量’字段中指定您希望桥接的BRC20代币数量。确保您的钱包中有足够的余额。如果适用，勾选框以确认服务不适用于美国个人和实体。
5.铭刻和转移费用： 跟随钱包提示选择合适的铭刻费用。做好准备，Unisat/OKX钱包将要求确认两次。
6.交易签名： 当铭刻成功时，在您的钱包中确认并支付交易。
7.交易确认： 一旦转移启动，将生成一个交易ID。您可以在’历史’标签上跟踪状态。
8.完成桥接过程： 在必要的区块链确认后，交易状态将更新为’完成’，表明代币已成功桥接并可在Solana网络上使用，用户将在早些时候提供的地址中收到扣除适用交易费后的相应代币。
从Solana网络到BTC网络桥接BRC20 1.打开SoBit平台： 在您的网络浏览器中启动SoBit Bridge。
2.连接您的钱包： 选择SoBit界面右上角的Solana网络来连接您的数字钱包。
3.选择源链、目标链和您想桥接的代币： 从下拉菜单中选择’SOL’作为源链，’BTC’作为目标链。
4.输入转移细节： 输入您想要桥接的代币数量。确保您的Solana钱包中有必要的数量。输入您的BTC接收地址。如果适用，通过勾选框确认服务不适用于美国个人和实体，然后点击’转移’按钮。
5.确认交易： 将出现一个弹出窗口，要求您在连接的钱包中确认交易细节。这将包括服务费和网络费。在您的钱包中批准交易。一旦您确认，SoBit将处理交易。
6.交易监控： 交易将出现在’历史’标签中，您可以监控其状态。
7.完成： 一旦交易确认，状态将更新为’完成’。
这是实现BRC20到Solana完整桥接生态系统的第一步。我们非常期待社区可能为我们提供的任何反馈。随着我们不断前进，我们致力于持续改进技术并扩展服务，以确保无缝、安全和高效的跨链体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4c1be19f878bb4403aa232f39346ce5/" rel="bookmark">
			软件测试面试会问哪些问题？真实的企业软件测试面试真题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件测试面试，一般会被问到下面这九类问题。
1、基础问题 2、Linux命令 3、数据库 4、功能测试 5、Python基础 6、接口测试 7、自动化测试 8、性能测试 9、人事问题 接下来，以上9类问题，我都会分别结合2个案例，附上答案，给大家参考。最后会免费赠送大家2023年最新面试宝典，祝愿大家测试求职顺利。
一、基础问题 1.1、请做下简单的自我介绍 回答： 【围绕基本信息+项⽬介绍】 ⾯试官您好，我叫张三，来⾃番茄市，在软件测试⾏业有 3 年的⼯作经验，做过 Web/APP及⼩程序项⽬ 的测试⼯作，有独⽴负责整个项⽬的测试经验。 最近做个的项⽬是 xxx，这是⼀款基于（B/S 或 C/S）架构的 xxx 产品， 在该项⽬中我主要负责 xxx 业务和 xxx 业务及 xxx 模块和 xxx 模块的功能，接⼝，及⾃动化测试。 在功能测试中主要运⽤到 xxx 测试⼯具和 xxx 缺陷管理系统， 在接⼝测试中主要使⽤到 xxx ⼯具， ⾃动化测试是基于 Python+Requests+pytest+Jenkins 实现的测试框架搭建和测试实现。以上是我的个⼈介绍 1.2、 你们这项⽬做了多久？多久做⼀次版本迭代？写了多少⽤例？发现了多少Bug？你们的团 队规模是怎么样？具体的⼈员配置请详细说⼀下。 回答： ● 项⽬周期： ○ 中⼩型项⽬： 3-6个⽉ ○ 中⼤型项⽬： 6-12个⽉ ● 多久做⼀次版本迭代？ ○ 互联⽹项⽬： 1-2周⼀个迭代 ○ 传统项⽬： 3-4周⼀个迭代 ● 迭代内容： ○ ⼀般分⼤版本和⼩版本： ■ ⼤版本主要是产品规划的新功能、新业务，⼤版本⼀般2-3个⽉有⼀次 ■ ⼩版本主要是⼀些历史功能优化和缺陷修复版本，⼩版本每周/两周有⼀次 ● 写了多少⽤例？ —— 数测试点 ● 发现了多少bug？ —— ⽤例数的20%-30% ● 团队规模： ○ 互联⽹项⽬： ■ 测试开发⽐： 1： 3 —— 1:5 甚⾄1:7 ■ ⼩项⽬： 1-3个测试⼈员，开发⼈员⼤概为4-15⼈，产品经理与测试基本⼀致（基本1-3⼈） ■ 中项⽬：测试⼈员5⼈以上 ○ 传统项⽬： ■ 银⾏类型的项⽬：（⼈员密集型）测试开发⽐： 1-3左右 二、Linux命令 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4c1be19f878bb4403aa232f39346ce5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/612e41ae1394a7e01f18e1bb94bdca30/" rel="bookmark">
			利用Jmeter做接口测试（功能测试）全流程分析！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用Jmeter做接口测试怎么做呢？过程真的是超级简单。
明白了原理以后，把零碎的知识点填充进去就可以了。所以在学习的过程中，不管学什么，我一直都强调的是要循序渐进，和明白原理和逻辑。这篇文章就来介绍一下如何利用Jmeter做接口测试的流程，主要针对的是功能测试。暂不涉及到自动化测试和性能测试的内容。
一把来说，主要的步骤都大差不差。
第一步：通过分析API文档和需求文档提取接口清单。
也就是说，接口测试工作人员工作的开始就是从API文档和需求文档开始的。所以进入公司的第一件事情就是要拿到API文档和需求文档来了解，来看，来分析。从其中提取接口清单的话，主要是因为API文档中有很多冗余，不必要的信息。这些信息可能对于开发人员是有用的，但是对于我们测试人员是没有用的，所以要去除冗余，提取关键信息。
那么怎么提取呢？方法也很简单，从功能模块和方法模块对API文档中的内容进行提炼，提炼的关键是接口三要素：url+方法+参数+返回值。我的建议是可以先将所有的url提取出来，基本上一个url就是对应一个接口的，这样一条线把整体拎起来，就感觉混乱的局面清晰多了。
当然工作中，有的时候我们是可以直接拿到接口清单的，因为清单这个事情一个团队做一份就好了，并不是说要每个人都做一份。但是我们自己得会，得有这个能力。之前看到过一个面试题，问的是，如果没有API文档，怎么做接口测试？
其实问的就是如果没有API文档，应该怎么提取接口清单的问题。很简单，根据需求文档和原型图来提取。有的公司不正规，确实是没有API文档的。或者有的公司API文档写的不规范，那提取的时候，就很考验测试人员的经验和能力了。所以如果能找到遵循restful风格写的优秀API文档，那就好了，提取的时候很方便。
第二步：针对接口清单，做单接口测试和关联接口测试。
在实际测试过程中，单接口测试和关联接口测试的时间是不一样的，这涉及到业务逻辑测试和功能点测试等。但是在测试的时候，他们的逻辑和方法是类似的。
当然这里主要介绍的是单接口测试，因为单接口测试时会考虑各种可能的情况，而关联接口测试一般是建立在单接口没有问题的前提下的。换个角度来说，就相当于是两个层次，单接口测试是基础，而关联接口测试是拔高。
那么具体应该怎么做呢？比如我们这里已经选定而来某一个接口来测试。
现在我也找了很多测试的朋友，做了一个分享技术的交流群，共享了很多我们收集的技术文档和视频教程。 如果你不想再体验自学时找不到资源，没人解答问题，坚持几天便放弃的感受 可以加入我们一起交流。而且还有很多在自动化，性能，安全，测试开发等等方面有一定建树的技术大牛 分享他们的经验，还会分享很多直播讲座和技术沙龙 可以免费学习！划重点！开源的！！！ qq群号：691998057【暗号：csdn999】 首先，根据选定的接口来搭建测试框架。
接口不是什么大不了的事情，无非就是url、方法、参数、返回数据这四块。这样就意味着，一个接口的框架是固定的，只不过每次传输的数据和返回的数据可能会不一样而已。所以我们要做的第一步就是搭建测试框架。
那么怎么搭建呢？这里就要用到从API文档中整理出来的接口清单和Jmeter了。从接口清单里，可以拿到当下接口的url+方法+参数+预期返回数据。这就是我们搭建测试框架的依据。接下来用Jmeter搭建。
首先需要打开Jmeter，然后基于测试计划，创建线程组，基于线程组创建HTTP请求。考虑到单接口测试，一个框架，要测试N多个数据，而且后面的接口可能也要用到同样的ip地址、同样的content-type，所以一般会先创建一个HTTP请求默认值，将一些可能会重复用到的信息填进去，比如说端口号、协议之类的。如有必要还需要添加HTTP信息头管理器，放一些user-agent、content-type等内容。
好的，有了这两个基础就可以来创建HTTP请求。在新的请求里，已经填写的端口号呀、ip地址呀之类的就无需填写了，只需要填写方法之类的即可。那么搭建框架在哪里搭建呢？一般会考虑para或者body里。比如说，要提交一段json格式的数据，那么就要用body（消息体）来提交，如下图所示。
将从接口清单里拿到的json数据填写到消息体数据里，然后将需要不断传入的数据进行参数化设置，那搭建测试框架就算是完成了。接下来只需要把数据一条一条传入进行测试即可。
那么如何把数据进行传入呢？
其实我们在下面的这篇文章里已经介绍了，传入数据的方法有四种，但主要使用的还是csv data set config 和函数。做功能接口测试，用csv就足够了。那么具体怎么用呢？可以文末领取配套资源！
基于当前的线程组或者请求创建CSV数据文件配置组件。如果这份数据只有这一个请求会用，那么就基于请求创建即可。如果这份数据会被这个线程组里的多个请求使用，那么就基于线程组创建。
创建了以后就需要填入文件了呢？可是文件在哪里呢？这个时候就要稍微停一下jmeter的操作，先去针对当前接口设计测试用例并形成有关文档了。有关于功能接口测试的用例设计，我们之后会专门用一篇文章来介绍，这里先带过。这是因为设计测试用例是做测试过程中最核心的一步。
在测试用例设计完之后，可以将其保存在一个txt文档里，采用utf-8编码，保存到Jmeter脚本的同一父目录下。然后按照上面那篇文章里的设置方法进行设置即可，注意路径可以采用相对路径，便于数据文件的拷贝和使用。
csv组件设置好以后，数据源有了，变量名有了，变量名的赋值也有了，接下来就只剩引用参数就可以了。在测试框架里需要引用参数的地方引用，引用的格式是${参数名}。到这里，针对于某一个接口的测试工作就准备完成了。
然后在Jmeter里面添加查看结果树组件，执行请求，依次查看结果。看一看返回的数据和我们的预期结果是否一致，不一致，那可能就是一个bug。
做一个小小的总结吧，用jmeter做功能接口测试，其实很简单的。逻辑和原理都是类似的，如果遇到新的项目，可能说会用一些新的组件而已，那百度一下几分钟的事情。在学习软件测试的时候，最重要的就是不要怂，不要看起来说怎么要学的东子这么杂这么多，只要能够拎出其中的线索和主干，然后把一些零碎的点给组装上去，就会感觉，哇，忽然之间，好有条理。
END今天的分享就到此结束了！点赞关注不迷路~！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/601d84aded76565967965a2894aeb142/" rel="bookmark">
			Python如何实现邮件的发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python笔记- 发送邮件
依赖：
Python代码实现发送邮件，使用的模块是smtplib、MIMEText，实现代码之前需要导入包：
import smtplib from email.mime.text import MIMEText 使用163邮件发送邮件，具体代码实现如下：
import smtplib from email.mime.text import MIMEText ''' 发送邮件函数，默认使用163smtp :param mail_host: 邮箱服务器，16邮箱host: smtp.163.com :param port: 端口号,163邮箱的默认端口是 25 :param username: 邮箱账号 xx@163.com :param passwd: 邮箱密码(不是邮箱的登录密码，是邮箱的授权码) :param recv: 邮箱接收人地址，多个账号以逗号隔开 :param title: 邮件标题 :param content: 邮件内容 :return: ''' def send_mail(username, passwd, recv, title, content, mail_host='smtp.163.com', port=25): msg = MIMEText(content) # 邮件内容 msg['Subject'] = title # 邮件主题 msg['From'] = username # 发送者账号 msg['To'] = recv # 接收者账号列表 smtp = smtplib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/601d84aded76565967965a2894aeb142/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3699fd4e1d295b248dbb03604314de5/" rel="bookmark">
			12.26
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		key_it.c
#include"key_it.h" void led_init() { // 设置GPIOE/GPIOF时钟使能 RCC-&gt;MP_AHB4ENSETR |= (0x3 &lt;&lt; 4); // 设置PE10/PE8/PF10为输出模式 GPIOE-&gt;MODER &amp;= (~(0x3 &lt;&lt; 20)); GPIOE-&gt;MODER |= (0x1 &lt;&lt; 20); GPIOE-&gt;MODER &amp;= (~(0x3 &lt;&lt; 16)); GPIOE-&gt;MODER |= (0x1 &lt;&lt; 16); GPIOF-&gt;MODER &amp;= (~(0x3 &lt;&lt; 20)); GPIOF-&gt;MODER |= (0x1 &lt;&lt; 20); // 设置PE10/PE8/PF10为推挽输出 GPIOE-&gt;OTYPER &amp;= (~(0x1 &lt;&lt; 10)); GPIOE-&gt;OTYPER &amp;= (~(0X1 &lt;&lt; 8)); GPIOF-&gt;OTYPER &amp;= (~(0x1 &lt;&lt; 10)); // 设置PE10/PE8/PF10输出速度为低速 GPIOE-&gt;OSPEEDR &amp;= (~(0x3 &lt;&lt; 20)); GPIOE-&gt;OSPEEDR &amp;= (~(0X3 &lt;&lt; 16)); GPIOF-&gt;OSPEEDR &amp;= (~(0x3 &lt;&lt; 20)); // 设置PE10/PE8/PF10无上拉下拉 GPIOE-&gt;PUPDR &amp;= (~(0x3 &lt;&lt; 20)); GPIOE-&gt;PUPDR &amp;= (~(0X3 &lt;&lt; 16)); GPIOF-&gt;PUPDR &amp;= (~(0X3 &lt;&lt; 20)); } void key1_it_config() { //使能GPIOF时钟 RCC-&gt;MP_AHB4ENSETR |= (0x1&lt;&lt;5); //设置PF9管脚为输入 GPIOF-&gt;MODER &amp;= (~(0x3&lt;&lt;18)); //设置PF9作为EXTI9事件的输入 EXTI-&gt;EXTICR3 &amp;= (~(0x1f&lt;&lt;8)); EXTI-&gt;EXTICR3 |= (0x05&lt;&lt;8); //设置下降沿使能检测EXTI9事件 EXTI-&gt;FTSR1 |= (0x1&lt;&lt;9); //设置EXTI9事件不屏蔽 EXTI-&gt;C1IMR1 |= (0x1&lt;&lt;9); //GICD使能EXTI9（99号）中断 GICD-&gt;ISENABLER[3] |= (0x1&lt;&lt;3); //GICD 设置99号中断的优先级 GICD-&gt;IPRIORITYR[24] &amp;= (~(0x1f&lt;&lt;27)); //选择CPU0处理当前中断 GICD-&gt;ITARGETSR[24] |= (0x1&lt;&lt;24); //全局使能组0中断被转发到GICC GICD-&gt;CTRL |= (0X1); //设置中断的优先级掩码 GICC-&gt;PMR |= (0x1f&lt;&lt;3); //允许组0中断被CPU处理 GICC-&gt;CTRL |= (0x1); } void key2_it_config() { //设置PF7管脚为输入 GPIOF-&gt;MODER &amp;= (~(0x3&lt;&lt;14)); //设置PF7作为EXTI7事件的输入 EXTI-&gt;EXTICR2 &amp;= (~(0x1f&lt;&lt;24)); EXTI-&gt;EXTICR2 |= (0x05&lt;&lt;24); //设置下降沿使能检测EXTI7事件 EXTI-&gt;FTSR1 |= (0x1&lt;&lt;7); //设置EXTI7事件不屏蔽 EXTI-&gt;C1IMR1 |= (0x1&lt;&lt;7); //GICD使能EXTI7（97号）中断 GICD-&gt;ISENABLER[3] |= (0x1&lt;&lt;1); //GICD 设置97号中断的优先级 GICD-&gt;IPRIORITYR[24] &amp;= (~(0x1f&lt;&lt;11)); //选择CPU0处理当前中断 GICD-&gt;ITARGETSR[24] |= (0x1&lt;&lt;8); //全局使能组0中断被转发到GICC GICD-&gt;CTRL |= (0X1); //设置中断的优先级掩码 GICC-&gt;PMR |= (0x1f&lt;&lt;3); //允许组0中断被CPU处理 GICC-&gt;CTRL |= (0x1); } void key3_it_config() { //设置PF8管脚为输入 GPIOF-&gt;MODER &amp;= (~(0x3&lt;&lt;16)); //设置PF8作为EXTI8事件的输入 EXTI-&gt;EXTICR3 &amp;= (~0x1f); EXTI-&gt;EXTICR3 |= (0x05); //设置下降沿使能检测EXTI8事件 EXTI-&gt;FTSR1 |= (0x1&lt;&lt;8); //设置EXTI8事件不屏蔽 EXTI-&gt;C1IMR1 |= (0x1&lt;&lt;8); //GICD使能EXTI8（98号）中断 GICD-&gt;ISENABLER[3] |= (0x1&lt;&lt;2); //GICD 设置98号中断的优先级 GICD-&gt;IPRIORITYR[24] &amp;= (~(0x1f&lt;&lt;19)); //选择CPU0处理当前中断 GICD-&gt;ITARGETSR[24] |= (0x1&lt;&lt;16); //全局使能组0中断被转发到GICC GICD-&gt;CTRL |= (0X1); //设置中断的优先级掩码 GICC-&gt;PMR |= (0x1f&lt;&lt;3); //允许组0中断被CPU处理 GICC-&gt;CTRL |= (0x1); } do_irq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3699fd4e1d295b248dbb03604314de5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab77c68211b025a5a24b12354b4c7cbb/" rel="bookmark">
			一文读懂SoBit 跨链桥教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从BTC网络到Solana网络桥接BRC20 1.打开SoBit平台：在您的网络浏览器中启动SoBit Bridge应用程序。
2.连接您的钱包： 选择SoBit界面右上角的比特币网络来连接您的数字钱包。
3.选择源链、目标链和您想桥接的代币： 从下拉菜单中选择’BTC’作为源链，’SOL’（Solana）作为目标链。
4.输入转账细节： 在’数量’字段中指定您希望桥接的BRC20代币数量。确保您的钱包中有足够的余额。如果适用，勾选框以确认服务不适用于美国个人和实体。
5.铭刻和转移费用： 跟随钱包提示选择合适的铭刻费用。做好准备，Unisat/OKX钱包将要求确认两次。
6.交易签名： 当铭刻成功时，在您的钱包中确认并支付交易。
7.交易确认： 一旦转移启动，将生成一个交易ID。您可以在’历史’标签上跟踪状态。
8.完成桥接过程： 在必要的区块链确认后，交易状态将更新为’完成’，表明代币已成功桥接并可在Solana网络上使用，用户将在早些时候提供的地址中收到扣除适用交易费后的相应代币。
从Solana网络到BTC网络桥接BRC20 1.打开SoBit平台： 在您的网络浏览器中启动SoBit Bridge。
2.连接您的钱包： 选择SoBit界面右上角的Solana网络来连接您的数字钱包。
3.选择源链、目标链和您想桥接的代币： 从下拉菜单中选择’SOL’作为源链，’BTC’作为目标链。
4.输入转移细节： 输入您想要桥接的代币数量。确保您的Solana钱包中有必要的数量。输入您的BTC接收地址。如果适用，通过勾选框确认服务不适用于美国个人和实体，然后点击’转移’按钮。
5.确认交易： 将出现一个弹出窗口，要求您在连接的钱包中确认交易细节。这将包括服务费和网络费。在您的钱包中批准交易。一旦您确认，SoBit将处理交易。
​
6.交易监控： 交易将出现在’历史’标签中，您可以监控其状态。
7.完成： 一旦交易确认，状态将更新为’完成’。
这是实现BRC20到Solana完整桥接生态系统的第一步。我们非常期待社区可能为我们提供的任何反馈。随着我们不断前进，我们致力于持续改进技术并扩展服务，以确保无缝、安全和高效的跨链体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f370dce0c8750ff3090bf2668417e3ef/" rel="bookmark">
			基于STM32的智慧农业项目(物联网专业毕设)附送源码和文档材料&#43;学习路线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概要整体架构流程硬件选型软件总体框架技术细节实现效果小结 概要 传统农业存在着产量受到环境因素影响较大的问题，现有的农业监测系统数据太过简单、太过理想化。而随着现代科学的持续发展,一个精准化、自动化的现代智能农产品管理系统将在农业生产中起着日益关键的角色。
本项目立足于温室大棚，设计一个能够智能控制和远程监控的智慧农业监测系统，实现了感知节点数据采集、上传，以及接收小程序发来的指令，控制水泵、排风扇、暖灯、蜂鸣器等。本系统主要采用低功率单片机stm32f103作为主控芯片，使用DHT11、MQ-2、XH-M214土壤湿度传感器、BH1750光照强度模块，采集温室大棚环境数据，esp8266作为通讯模块，上传至搭建好的MQTT服务器中。利用串口屏可以进行数据的实时显示和控制。小程序基于mpvue框架进行开发，实现了数据显示、命令下发、账户注册、账户登陆功能。使得温室大棚的环境参数能够可视化，并且能远程控制温室大棚内部的执行器。本项目解决了一些农业中信息闭塞，决策迟缓不科学的问题。可以大大提高农业生产效率，增加农业产量。推动地区温室大棚农业经济蓬勃发展。
整体架构流程 本系统基于stm32单片机和微信小程序，其主要功能包括大棚内部温度、空气湿度、光照强度、大棚内二氧化碳浓度等数据的采集、上传和显示。水泵，风扇，暖灯，报警开关的远程控制。主要模块包含：硬件系统设计（传感器数据的采集、上传、逻辑控制，液晶屏数据显示），软件系统设计（MQTT服务器使用、服务器配置、界面设计）、系统功能实现、系统测试。本系统采用使用stm32单片机和微信小程序，设计包括硬件和软件的智慧农业检测系统。基于传感器、通信、自动化等技术，对农业生产的环境参数和设备进行实时监控。
硬件选型 软件总体框架 技术细节 主函数代码
#include "sys.h" #include "delay.h" #include "usart.h" #include "led.h" #include "dht11.h" #include "beep.h" #include "esp8266.h" #include "onenet.h" #include "stdio.h" #include "bh1750.h" #include "adc.h" #include "timer.h" #include "mq2.h" #include "relay.h" #include "fs.h" #include "pump.h" /************************************************ 参考正点原子工程建立的代码 ************************************************/ u8 humidityH;	//湿度整数部分 u8 humidityL;	//湿度小数部分 u8 temperatureH; //温度整数部分 u8 temperatureL; //温度小数部分 u8 alarmFlag = 0;//是否报警的标志 u8 alarm_is_free = 10;//报警器是否被手动操作，如果被手动操作即设置为0 u8 ESP8266_INIT_OK = 0;//esp8266初始化完成标志 u8 Led_Status = 0;//led状态 //u16 adcx=0;//adc的初始值 u16 adcx1; u16 shidu; char PUB_BUF[256];//上传数据的buf unsigned char HDMI_BUF[64];//HDMI发送数据buf float Light = 0; //光照度 float co2 = 0; //二氧化碳浓度 float temp = 0; float hum = 0; const char* devSubTopic[] = {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f370dce0c8750ff3090bf2668417e3ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f1c4324d73aca21bdfd07847e48a234/" rel="bookmark">
			【番外】在Windows安装Airsim/UE4踩坑合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Windows安装Airsim/UE4踩坑合集 1.安装过程中一定要确保Epic Games Launcher是英文环境，保存路径什么的也尽量是英文。2.UE4中的虚幻引擎一定要安装4.27版本以上的，不然的话最后运行vs的时候会报语法错误，网上根本查不到的那种错误。换了版本之后就正常了。3.Block环境测试的时候：运行指令 `update_from_git.bat` 的时候报错很多文件找不到4.成功在vs2022中运行Blocks.sln之后，程序自动打开UE4引擎，然后点击运行，理论上图像应该出现一架无人机以及球体和锥体。 具体步骤参考知乎大佬宁子安的文章： https://zhuanlan.zhihu.com/p/618440744 或者是airsim官方网站的步骤：
https://microsoft.github.io/AirSim/build_windows/
我这里写几个自己安装过程中踩的坑和报的错：
1.安装过程中一定要确保Epic Games Launcher是英文环境，保存路径什么的也尽量是英文。 2.UE4中的虚幻引擎一定要安装4.27版本以上的，不然的话最后运行vs的时候会报语法错误，网上根本查不到的那种错误。换了版本之后就正常了。 我运行正常的版本为：
win10 vs2022 UE4（4.27.2） Airsim 1.8.1
3.Block环境测试的时候：运行指令 update_from_git.bat 的时候报错很多文件找不到 问题在于没有关联虚幻引擎与Airsim，所以没有办法生成测试文件。
解决步骤：
一定要确保Epic Games Launcher是英文语言
把你已经下载好的虚幻引擎设为启动项：
重启Epic Games Launcher，会弹出一个让你关联的对话框，点确定即可。
重新运行update_from_git.bat ，即可成功生成Blocks.sln工程文件
4.成功在vs2022中运行Blocks.sln之后，程序自动打开UE4引擎，然后点击运行，理论上图像应该出现一架无人机以及球体和锥体。 但是我当时报了这个错：Error at startup: Error creating directory, hr=2
然后点击“OK”之后不出现无人机，其他一切正常。
github上有解决这个问题的人：
https://github.com/microsoft/AirSim/issues/1150
简单地说，就是运行这个工程文件需要有一个settings.json文件支撑这个工程，配置该工程中的各种参数。但是很明显虚幻引擎现在找不到这个文件，无法读取这个文件中的配置。
所谓的““error creating directory””实际意思就是UE或者airsim没有办法生成文件夹去放置settings.json文件。
正常情况下，是应该由程序自动生成一个settings.json文件在："C:\Users\asus\Documents\Airsim"这个目录下面的。但是我们目前手动去找一下发现确实没有。
所以解决办法就是：
在"C:\Users\asus\Documents"这个目录下面手动新建一个“Airsim”文件夹
然后在其中新建一个文本文件，复制下面的代码：
{ "SettingsVersion": 1.2, "SimMode": "Multirotor" } 保存之后，修改后缀名为.json
再次在UE4中点击“运行”按钮即可成功。成功出现无人机，场景也变得正常了。
如果想配置其他的功能，比如加上三个不同摄像头角度的窗口，如图：
就可以修改settings.json文件为：
{ "SettingsVersion": 1.2, "SimMode": "Multirotor", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f1c4324d73aca21bdfd07847e48a234/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a40113842524fc4c49ad9b96d9ab6db/" rel="bookmark">
			轻量级性能测试工具 wrk 如何使用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目设计之初或者是项目快要结束的时候，大佬就会问我们，这个服务性能测试的结果是什么，QPS 可以达到多少，RPS 又能达到多少？接口性能可以满足未来生产环境的实际情况吗？有没有自己测试过自己接口的吞吐量，等等。
作为开发、测试人员，这些问题不仅仅是用来面试，还是实实在在的落地在实际工作中。很多项目上线初期用户量较小，表面上看是风平浪静，实则暗流涌动，慢慢的用户量上来之后，系统的瓶颈慢慢凸显。曾经挖的坑，最后还是要我们自己来填，若不能及时填上，可能整个产品就这么断送了。
今天一起来看看轻量级的性能测试工具 wrk 如何使用：
性能测试相关名词
QPS每秒查询率 (Query Per Second)：每秒查询率 QPS 是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。
并发用户数：指系统可以同时承载的正常使用系统功能的用户的数量。
吞吐量 (Throughput)：吞吐量是指系统在单位时间内处理请求的数量。
响应时间 (RT)：指系统对请求作出响应的时间。
wrk 是什么？
wrk 是 github 的一个项目，地址：https://github.com/wg/wrk
根据官方的说明，wrk 是一个HTTP基准测试工具，当运行在单个多核CPU上时，它能够产生巨大的负载。它结合了多线程设计和可伸缩的事件通知系统，如 epoll 和 kqueue 等等。
wrk 中的一个可选的 LuaJIT 脚本可以执行 HTTP 请求生成、响应处理和自定义报告。
wrk 如何使用？
那么 wrk 如何使用呢，我们就来实操一下看看效果 ， 既然是开源工具，下载安装编译的方式都很类似：
1、下载 wrk 项目
git clone https://github.com/wg/wrk.git wrk 2、编译项目
cd wrk
make
3、将编译出来的 wrk 可执行程序放到用户自己的 bin 目录下
cp wrk /usr/local/sbin/ 4、这个时候，我们就可以开始使用 wrk 工具了
咱们直接执行 wrk 来看看效果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a40113842524fc4c49ad9b96d9ab6db/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/17/">«</a>
	<span class="pagination__item pagination__item--current">18/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/19/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>