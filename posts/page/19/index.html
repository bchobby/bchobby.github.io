<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/302cbe9b0a611ba65d925aa95a48a035/" rel="bookmark">
			shell之readelf命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shell之readelf命令 参数例子 参数 readelf 是一个在 Linux 中用于显示二进制文件内容的工具，特别是 ELF (Executable and Linkable Format) 格式的文件。ELF 格式是 Unix 和 Unix-like 系统（如 Linux）中的主要可执行文件、目标代码、共享库和核心转储格式。
readelf 命令提供了大量选项，允许用户查看 ELF 文件的详细信息。下面是一些常用的选项：
1)-a 或 --all: 显示所有信息。这包括文件头、节头、重定位表、符号表等。
2)-h 或 --file-header: 显示 ELF 文件头信息。
3)-l 或 --program-headers: 显示程序头信息。这些描述了程序的段如何存储在文件中。
4)-S 或 --section-headers: 显示节头信息。这些描述了文件中各个段的内容和属性。
5)-s 或 --symbols: 显示符号表。这包括在 ELF 文件中的所有符号（例如函数和变量名）。
6)-r 或 --relocations: 显示重定位表信息。这些表包含用于将程序从其执行文件加载到内存中的信息。
7)-d 或 --dynamic: 显示动态节的内容。这通常包含运行时信息，如需要加载的共享库和动态链接器脚本。
8)-p 或 --program-header-only: 只显示程序头信息。
9)-n 或 --section-name: 显示特定节的名称。
10)-v 或 --version: 显示版本信息。
11)-V 或 --verbose: 提供详细输出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/302cbe9b0a611ba65d925aa95a48a035/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf5ee76fba15ebb59250bd7e7cbce7b4/" rel="bookmark">
			w16php系列之基础数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、索引数组 概念 索引数组 是指键名为整数的数组。默认情况下，索引数组的键名是从0开始，并依次递增。它主要适用于利用位置（0、1、2……）来标识数组元素的情况。另外，索引数组的键名也可以自己指定
示例代码 &lt;?php # 索引数组 $arr=[5,1,2]; echo $arr[0]; echo '&lt;hr&gt;'; echo $arr[2]; ?&gt; 输出结果 二、关联数组 概念 关联数组是指键名为字符串的数组。通常情况下，关联数组元素的“键”和“值”之间有一定的业务逻辑关系。
示例代码 #array()数组基本用法 &lt;?php $age=array("A"=&gt;"1","B"=&gt;"2","C"=&gt;"3"); echo "A is " . $age['A'] . " years old."; ?&gt; 输出结果 三、遍历数组 3-1.fori循环读取数组中的所有元素 &lt;?php $arr = ['A', 'B', 'C', 'D']; #count() 统计数组元素个数 $arr_len=count($arr); for($i=0;$i&lt;$arr_len;$i++){ echo $arr[$i]; echo "&lt;br/&gt;"; } ?&gt; 输出结果 3-2.foreach循环读取数组中的所有元素 &lt;?php $arr = ['D', 'B', 'C', 'D']; foreach($arr as $value ){ echo $value; echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf5ee76fba15ebb59250bd7e7cbce7b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7b7c8ebc71fad0a28d0bed0d8feb065/" rel="bookmark">
			Spring Boot学习随笔- 第一个Thymeleaf应用（基础语法th:，request、session作用域取值）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习视频：【编程不良人】2021年SpringBoot最新最全教程
第十五章、Thymeleaf Thymeleaf是一种现代化的服务器端Java模板引擎，专门用于Web和独立环境。Thymeleaf在有网络和无网络的环境下皆可运行，即可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。它与Spring Boot集成良好，是Spring Boot官方支持的模板引擎之一。
比较其他模板引擎
目前主流模板引擎：Thymeleaf、FreeMarker、Groovy和Mustache
整体来说：FreeMarker在性能方面略有优势，但Thymeleaf在整体上胜出
注意：jsp可以直接在服务器访问，而Thymeleafa必须要经过控制器跳转访问
第一个Thymeleafaf网页 引入依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;**spring-boot-starter-thymeleaf**&lt;/artifactId&gt; &lt;/dependency&gt; 配置thymeleaf模板配置
# THYMELEAF (ThymeleafAutoConfiguration) spring: thymeleaf: cache: false # 开启模板缓存（默认值： true ） 开发过程中改成false check-template: true # 检查模板是否存在，然后再呈现 check-template-location: true # 检查模板位置是否正确（默认值 :true ） servlet: content-type: text/html #Content-Type 的值（默认值： text/html ） enabled: true # 开启 MVC Thymeleaf 视图解析（默认值： true ） encoding: UTF-8 # 模板编码 excluded-view-names: # 要被排除在解析之外的视图名称列表，⽤逗号分隔 mode: HTML5 # 要运⽤于模板之上的模板模式。另⻅ StandardTemplate-ModeHandlers( 默认值： HTML5) prefix: # 在构建 URL 时添加到视图名称前的前缀（默认值： classpath:/templates/ ） suffix: # 在构建 URL 时添加到视图名称后的后缀（默认值： .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7b7c8ebc71fad0a28d0bed0d8feb065/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/104b32c2f84e64fdec8efb974624c208/" rel="bookmark">
			基于WINAPI的CPP进程与线程使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内核对象 物质 内核对象的本质 : 一个数据块,可理解成结构体,由两部分组成,共有( 安全描述符和使用计数)和私有(不同对象各有不同),属于操作系统
安全描述符(security descriptor,SD) : 指向所有者,其他用户的访问权限
使用计数 : 创建是为1,每次使用加1,关闭时和使用结束后-1,当为0时被操作系统销毁(操作系统管理)
运动 创建 : 通过create api来创建并返回其句柄,创建失败返回0
使用 : 通过WINAPI和句柄来使用
销毁 : 使用close api后,由操作系统根据使用计数来销毁
常见的内核对象 : 进程(process)、线程(thread)、文件(file)，存取符号对象、事件对象(event)、文件对象、作业对象、互斥对象(mutex)、管道对象、等待计时器对象，邮件槽对象，信号对象
每一个进程都会创建一个句柄表,用来存放使用的句柄
WaitObject 阻塞代码,直到进程完成
//单个 DWORD WINAPI WaitForSingleObject( __in HANDLE hHandle,//线程句柄 __in DWORD dwMilliseconds);//等待时间 INFINITE代表无限,直到waited //多个 DWORD WINAPI WaitForMultipleObjects( __in DWORD nCount,//线程个数 __in const HANDLE *lpHandles,//句柄数组 __in BOOL bWaitAll,//TRUE代表所有都结束,FALSE代表任意一个结束 __in DWORD dwMilliseconds);//等待时间 信号量 用于管理多条线程
用来表示内核对象的状态
组成 : 计数器 + 最大资源计数 + 当前资源计数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/104b32c2f84e64fdec8efb974624c208/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2d102c3efa461272ce1b2ba17d2994a/" rel="bookmark">
			SQL语句操作数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		让我为大家介绍一下操作数据库的基本操作吧！
创建数据库
语法：CREATE DATABASE 数据库名;
#创建一个叫data1的数据库 CREATE DATABASE data1; 判断数据库是否已经存在，不存在则创建数据库
语法：CREATE DATABASE IF NOT EXISTS 数据库名;
#创建一个叫data1的数据库 如果不存在就创建 CREATE DATABASE IF NOT EXISTS data1; 创建数据库并指定字符集
语法：CREATE DATABASE 数据库名 CHARACTER SET 字符集;
#创建一个叫data1的数据库 字符集为utf8 CREATE DATABASE data1 CHARACTER SET utf8; 查看所有的数据库
语法：SHOW DATABASES;
#查看所有数据库 SHOW DATABASES; 查看某个数据库的定义信息
语法：SHOW CREATE DATABASE 数据库名;
#查看data1数据库的定义信息 SHOW CREATE DATABASE data1; 修改数据库默认的字符集
语法：ALTER DATABASE 数据库名 DEFAULT CHARACTER SET 字符集;
#修改数据库data1的字符集 修改为gbk ALTER DATABASE data1 DEFAULT CHARACTER SET gbk; 删除数据库的语法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2d102c3efa461272ce1b2ba17d2994a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c7eab8ac15c6d239b21120570ed2f55/" rel="bookmark">
			K8S异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 1、k8s有时候会报错The connection to the server ip:6443 was refused - did you specify the right host or port ，本文档提供几种可能产生该报错的原因和排障思路。
二、发现问题 使用任意Kubectl 命令会报错：The connection to the server ip:6443 was refused - did you specify the right host or port
三、可能原因 情况一：集群硬件时间和系统时间不同步，在重启服务器后系统时间会同步硬件时间，集群的时间管理混乱，进而导致此类问题
情况二：查看端口是否被占用或者是否被防火墙、iptables这些拦截下来了
情况三：更改主机名或者服务器重启后出现此报错
情况四：通用排查
四、处理方案 情况一解决方案：此类现象需要重新更改系统时间并把硬件时间和软件时间同步
systemctl status kubelet #首先检查服务是否启动有无报错，如果服务报错进行排查
date #确认系统时间
hwclock #确认硬件 #如果此时系统时间和硬件时间同步，但明显不是服务器重启之前的时间。请继续往下看。否则就不是本情况，请查看其他案例。
date -s "2023-03-25 12:00:00" #首先进行系统时间的修改
hwclock --hctosys #然后用硬件时钟同步系统时钟
timedatectl |awk -F":" '/synchronized/{print $2}' #检查ntp时间同步是否就绪，一般等待20-30分钟左右后会显示yes
kubectl get node #检查是否还会报错
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c7eab8ac15c6d239b21120570ed2f55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1361ed931b6d0821d43e5c37f28aff25/" rel="bookmark">
			整理了45个Python小技巧，非常实用！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家介绍一个Python备忘单，可以作为学习Python编程的快速参考指南。
无论你是学习基础知识的初学者，亦或是稍有经验的开发人员。
使用这个备忘单不仅可以简化你的编码任务，还能提高你的Python熟练程度。
接下来，就来一起学习下~
01 数据类型
int_num = 42 float_num = 3.14 string_var = "Hello, Python!" bool_var = True 02 变量和赋值
x = 10 y = "Python" 03 列表和元组
my_list = [1, 2, 3, "Python"] my_tuple = (1, 2, 3, "Tuple") 04 字典
my_dict = {'name': 'John', 'age': 25, 'city': 'Pythonville'} 05 条件语句
if x &gt; 0: print("Positive") elif x == 0: print("Zero") else: print("Negative") for item in my_list: print(item) while condition: # code 06 函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1361ed931b6d0821d43e5c37f28aff25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cec74fc9a7c66bd36ab71f7c74692a1d/" rel="bookmark">
			【Spark-HDFS小文件合并】使用 Spark 实现 HDFS 小文件合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Spark-HDFS小文件合并】使用 Spark 实现 HDFS 小文件合并 1）导入依赖2）代码实现2.1.HDFSUtils2.2.MergeFilesApplication 需求描述：
1、使用 Spark 做小文件合并压缩处理。
2、实际生产中相关配置、日志、明细可以记录在 Mysql 中。
3、core-site.xml、hdfs-site.xml、hive-site.xml、yarn-site.xmlx 等文件放在项目的 resources 目录下进行认证。
4、下面的案例抽取出了主体部分的代码，具体实现时需要结合 HDFS 工具类，利用好 Mysql 做好配置、日志、以及相关明细，结合各自业务进行文件合并。
1）导入依赖 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;test.cn.suitcase&lt;/groupId&gt; &lt;artifactId&gt;mergefiles&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;!-- &lt;spark.version&gt;3.0.2&lt;/spark.version&gt;--&gt; &lt;spark.version&gt;2.4.8&lt;/spark.version&gt; &lt;scala.version&gt;2.11.12&lt;/scala.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.20.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-client --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.hadoop/hadoop-hdfs --&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cec74fc9a7c66bd36ab71f7c74692a1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b0d4a381b5ae820646d977d616cc2de/" rel="bookmark">
			[oracle数据库]dblink的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Oracle 中，使用数据库链接（Database Link，简称 dblink）可以在一个数据库中访问另一个数据库中的对象。通过数据库链接，您可以在当前数据库会话中访问远程数据库中的表、视图、存储过程等对象，就像它们是本地的一样。
以下是在 Oracle 中创建和使用数据库链接的基本语法：
创建数据库链接： CREATE DATABASE LINK link_name CONNECT TO username IDENTIFIED BY password USING 'remote_database'; link_name 是您为链接指定的名称。username 和 password 是远程数据库的凭据。remote_database 是远程数据库的网络地址，可以是服务名或者 TNS 别名。 使用数据库链接访问远程对象： 一旦数据库链接创建成功，您可以通过该链接访问远程数据库中的对象，比如表或视图：
SELECT * FROM remote_table@link_name; 其中，remote_table 是远程数据库中的表名，link_name 是数据库链接的名称。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a37a3486e25ee8f396dae62243f79d1/" rel="bookmark">
			java.lang.IllegalArgumentException: When allowCredentials is true, allowedOrigins cannot contain the
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在做项目的时候，新创建了一个SpringBoot的项目，并且提供了一个接口，但是在局域网内和前端同学进行本地联调的时候出现了跨域的问题。对于这种问题，不想自己手写，也不想麻烦助理，于是直接百度了一下，大概有这么几种方式：
在Controller里面增加@CrossOrigin(“*”)注解
新建一个类，然后去实现WebMvcConfigurer接口，代码大概如下：
@Configuration public class WebConfigurer implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping("/**") .allowedOriginPatterns("*") .allowedMethods("GET", "HEAD", "POST", "PUT", "DELETE", "OPTIONS") .allowCredentials(true) .maxAge(3600) .allowedHeaders("*"); } } 新建一个Filter,代码大概如下：
@Component public class CorsFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletResponse response = (HttpServletResponse) servletResponse; response.setHeader("Access-Control-Allow-Origin","*"); response.setHeader("Access-Control-Allow-Credentials", "true"); response.setHeader("Access-Control-Allow-Methods","PUT, POST, GET, OPTIONS, DELETE"); response.setHeader("Access-Control-Max-Age", "3600"); response.setHeader("Access-Control-Allow-Headers", "content-type, authorization"); filterChain.doFilter(servletRequest, servletResponse); } } 于是我尝试了第一种办法,发现并没有解决问题；于是我尝试了第二种办法，发现报错了。于是我暂时略过了，尝试第三种办法，发现还是没有解决。于是对于第二种办法我产生了一丝好奇，可以不生效，但是为什么要报错呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a37a3486e25ee8f396dae62243f79d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3b62bde393a4c3f1d84558f98ab73c4/" rel="bookmark">
			调优-mybatis saveBatch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一条一条插入：
批量插入：
批量插入-优化：
在url配置
# rewriteBatchedStatements=true url: jdbc:mysql://localhost:3306/xi_ning?characterEncoding=utf-8&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true rewriteBatchedStatements=true 是一个在 JDBC 连接池（例如 HikariCP、c3p0、Tomcat JDBC Connection Pool 等）中使用的配置选项。
当 rewriteBatchedStatements 设置为 true 时，连接池会尝试重写批处理语句以提高性能。具体来说，它会把批处理语句中的每个单独的语句转换为一个预批处理语句，然后执行批处理执行。这样做的好处是，每个单独的语句都可以使用其自己的参数绑定，从而减少了解析和准备查询的时间。
需要注意:不是所有的 JDBC 驱动都支持这种重写。如果驱动不支持，这个选项可能不会带来任何性能提升，甚至可能导致性能下降。
简单来说，rewriteBatchedStatements=true 的目的是为了提高批处理操作的性能，但使用前需要确保你的 JDBC 驱动支持这种重写。
优化后：
为什么能优化？
插入的重写就是将sql拼接成 insert into xxx values (a),(b),(c)...这样一条语句的形式然后执行，跟拼接 sql 的效果一样。(即整合SQL，达到批量处理的目的)
可能会出现的问题：
如果批量语句中的某些语句失败，则默认重写会导致所有语句都失败。批量语句的某些语句参数不一样，则默认重写会使得查询缓存未命中。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53f8662c044496d7b386528238b552c2/" rel="bookmark">
			Spring Boot学习：Flyway详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flyway Flyway 是一款开源的数据库版本管理工具，用于管理和自动化数据库结构的变更。它可以跟踪和管理数据库的版本控制，并在应用程序启动时自动执行升级或回滚操作。
使用Flyway，你可以将数据库的变更以可重复且可控的方式应用到不同环境中，如开发、测试和生产环境。它支持多种数据库系统，包括MySQL、Oracle、PostgreSQL、SQL Server等。
Flyway将数据库结构的变更定义为一系列迁移脚本，通常是SQL脚本文件。每个迁移脚本都有一个唯一的版本号，Flyway会按照版本号的顺序依次执行这些脚本，以达到数据库结构的变更和更新。当应用程序启动时，Flyway会自动检测并执行未应用的迁移脚本，将数据库升级到最新版本。如果需要回滚到之前的版本，Flyway也提供了回滚操作的支持。
通过使用Flyway，开发团队可以更好地管理数据库结构的变更，保持不同环境之间的数据库一致性，并轻松地进行版本控制和追踪。
官方文档：https://documentation.red-gate.com/fd/
Flyway 工作流程 1、检测数据库状态：Flyway会连接到配置的数据库，并检测当前数据库的状态，包括已应用的迁移脚本版本和未应用的迁移脚本。
2、执行迁移脚本：Flyway会将未应用的迁移脚本按照版本号的顺序逐一执行。它会查找项目中指定的迁移脚本目录（默认为db/migration），并依次运行其中的SQL脚本。
3、更新数据库状态：每当一个迁移脚本成功执行后，Flyway会将其记录为已应用的脚本，并将其版本号存储在数据库的元数据表（ flyway_schema_history）中，以便下次启动时进行跟踪和管理。
Spring Boot集成Flyway 1、添加依赖
在项目的pom.xml文件中，添加Flyway的Maven依赖，如果是springboot 2.xx，使用5.2.1或5.2.4：
&lt;dependency&gt; &lt;groupId&gt;org.flywaydb&lt;/groupId&gt; &lt;artifactId&gt;flyway-core&lt;/artifactId&gt; &lt;version&gt;${flyway-core.version}&lt;/version&gt; &lt;/dependency&gt; 2、数据库连接信息配置
在Spring Boot项目的application.properties或者application.yml文件中配置数据库的连接信息，例如：
spring.datasource.url=jdbc:mysql://localhost:3306/db_example spring.datasource.username=dbuser spring.datasource.password=dbpass 3、Flyway配置
在Spring Boot项目的application.properties或者application.yml文件中进行Flyway的相关配置，例如
# Flyway配置 #开启flyway功能，默认为true spring.flyway.enabled=true # 用于存储迁移历史记录的表名，默认为flyway_schema_history spring.flyway.table=flyway_schema_history # 迁移脚本编码，默认为UTF-8 spring.flyway.encoding=UTF-8 # 当迁移数据库存在但没有元数据的表时，自动执行基准迁移，新建flyway_schema_history表 spring.flyway.baseline-on-migrate=true # 数据库迁移脚本的位置，默认为classpath:db/migration spring.flyway.locations=classpath:db/migration # SQL迁移脚本文件名前缀，默认为V spring.flyway.sql-migration-prefix=V # SQL迁移脚本文件名后缀，默认为.sql spring.flyway.sql-migration-suffixes=.sql # 是否在迁移时验证脚本，默认为true spring.flyway.validate-on-migrate=true # 检测迁移脚本的路径是否存在，默认为true，如不存在，则抛出异常，如果不想抛出异常可设为flase spring.flyway.check-location=false # 用于控制是否禁用 Flyway 的 clean 操作。 spring.flyway.clean-disabled=true 大家可以按照自己的需求来进行配置，上述配置除了spring.flyway.baseline-on-migrate和spring.flyway.clean-disabled，其他都比较见名知义，所以下面讲解下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53f8662c044496d7b386528238b552c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52e3e097be3d63d6eaa02dc29db30bac/" rel="bookmark">
			K8s简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、定义：是一种开源的容器集群管理系统，在docker 容器技术的基础之上，为容器化的集群提供部署、运行、资源调度、服务发现、动态伸缩等一系列完整的功能的大规模容器管理
2、功能
（1）对docker的容器技术应用的包，部署、运行、停止、销毁，全生命周期管理
（2）集群方式运行，跨机器的容器管理
（3）解决docker的跨机器运行的网络问题
（4）k8s可以自动修复，使得整个容器集群可以在用户期待的状态下运行
3、作用：自动部署、自动扩展和管理容器化部署的应用程序
负责自动化运维管理多个容器化程序的集群，是一个功能强大的容器编排工具。以分布式和容器化的方式进行容器管理
4、常用版本：K8s 1.20（支持容器，1.23版本后不再支持容器）
5、k8s以google的borg系统作为原型，后期经由go语言编写的开源软件
官网：Kubernetes
源码包：https://github.com/kubernetes/kubernetes
6、传统部署、容器部署、k8s部署的区别
（1）传统部署方式：一般意义上的二进制部署，安装、运行、运行维护需要专业人员，若出现故障，需要人工重新拉起来，若业务量增大，只能水平拓展，再部署一台
（2）容器化部署：用dockerfile方式，编写好自定义容器，基于镜像，随时都可以运行。数量少，还可以管理，数量一旦增多，管理复杂，而且docker一般是单机运行，没有高可用
（3）k8s部署：简单、高效的部署容器化的应用
①可以解决docker单机部署和无法集群化的问题
②可以解决随着容器数量的增加，对应增加的管理成本的问题
③可以解决容器的高可用问题，提供一种容器的自愈机制
④可以解决容器没有预设模板，以及无法快速、大规模部署，以及大规模容器调度的问题
⑤提供集中化配置管理的中心
⑥可以解决容器生命周期的管理工具的问题
⑦提供图形化工具对容器进行管理
7、k8s特性
（1）弹性伸缩：基于命令或图形化界面基于CPU的使用情况，自动对部署的程序进行扩容和缩容，以最小成本运行服务
（2）自我修复：出现节点故障时，自动重新启动失败的容器，也可以手动替换和重新部署
（3）服务发现和负载均衡：k8s为多个容器提供一个统一的访问入口（内部地址，需要暴露才能访问。和内部的DNS名称），自动负载均衡关联的所有容器
nginx-1
10.244.0.10:3000
DNS服务名称：nginx
nginx-2
nginx-3
（4）自动发布和回滚：k8s采用滚动的策略更新应用，若更新过程中出现问题，可以根据回滚点进行回滚到上一个老版本
nginx-1
先更新1
最新版本
nginx-2
再更新2
1和2若有问题，自动回滚到上一个版本
nginx-3
老版本
（5）集中化的配置管理和密钥管理：k8s集群内的各个组件都需要进行密钥对验证，但k8s的安全性不高，核心组件不建议部署在k8s上，适合部署一些自定义应用
（6）存储编排
①可以自动化的把容器部署在节点上
②可以通过命令行或者yml文件（自定义pod）实现指定节点部署
③可以通过网络存储、NFS、GFS实现指定节点部署
（7）批次处理任务：提供一次性任务、定时任务，满足需要批量处理和分析的场景
8、master组件（核心组件）【重要】
（1）kube-apiserver—所有请求的入口服务：k8s集群中每个组件都靠密钥对进行验证，组件之间通信靠kube-apiserver
API是应用接口服务，在k8s的所有资源请求和调用操作都是通过kube-apiserver来完成。所有对象资源的增删改查和监听操作，都是kube-apiserver处理完后交给etcd来存储。apiserver接收k8s的所有请求（命令行和图形化界面的操作），然后根据用户的具体请求通知对应的组件，展示或运行命令。apiserver相当于整个集群的大脑
（2）kube-controller-manger：运行管理控制器，k8s集群中处理常规任务的后台线程，是集群中所有资源对象的自动化控制中心，一个资源对应一个控制器，kube-controller-manger负责管理所有控制器
控制器
node controller节点控制器
负责节点的发现，以及节点故障的发现和响应
replication controller副本控制器
控制关联pod的副本数，可以随时扩、缩容（手动、自动）
endpoints controller端点控制器
监听service和对应pod的副本变化端点就是服务暴露出的访问点，要访问这个服务必须要知道endpoint，就是内部每个服务的IP地址+端口
service account和
roken controllers服务账户和令牌控制
为命名空间创建默认账户和API访问令牌。访问不同的命名空间
resourcequota controller资源控制器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52e3e097be3d63d6eaa02dc29db30bac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d5c1178baa684792023fc6e628856b3/" rel="bookmark">
			Java与前端的未来，超越流言，把握发展机遇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、为什么会出现“前端已死”的言论 最近，IT圈流传着“Java已死、前端已凉”的言论，引发了广泛的讨论和争议。本文将对这一言论进行剖析，并表达笔者对Java和前端的未来发展的看法。我们将看到，虽然技术领域的竞争激烈，但Java和前端仍然拥有广阔的发展前景和机遇。
二、如何看待“前端已死” 近年来，随着技术的快速发展和新兴技术的涌现，IT圈中经常会传出各种关于技术的言论和预测。在这样的背景下，最近流传的“Java已死、前端已凉”的言论引起了广泛的关注和讨论。这样的言论一方面引发了人们的焦虑和不安，另一方面也引发了对Java和前端未来发展的思考和探讨。
然而，我们需要理智地对待这样的言论，避免被过度的焦虑所左右。事实上，Java和前端作为技术领域中的两个重要方向，依然具备广阔的发展前景和机遇。
首先，让我们来看看Java。作为一门成熟而强大的编程语言，Java一直在企业级应用开发领域扮演着重要的角色。无论是大型企业应用还是后端服务，Java都展现出了其稳定性、可靠性和安全性的优势。而随着云计算、大数据、人工智能等技术的蓬勃发展，Java在这些领域中的应用仍然十分重要。同时，Java生态系统庞大且成熟，拥有丰富的开源框架和工具，为开发者提供了广泛的选择和支持。因此，可以说Java在企业级应用领域的地位是稳固的，并且有望继续发展。
此外，Java在移动应用开发领域也有着不可忽视的地位。虽然移动应用开发中出现了一些新兴的技术，例如React Native和Flutter，但Java仍然是Android平台的主要开发语言。而且，Android系统在全球范围内的市场份额仍然巨大，这为Java在移动应用开发领域提供了广阔的机遇。
三、前端技术的未来发展趋势 首先，让我们来看看Java。作为一门成熟而强大的编程语言，Java一直在企业级应用开发领域扮演着重要的角色。无论是大型企业应用还是后端服务，Java都展现出了其稳定性、可靠性和安全性的优势。而随着云计算、大数据、人工智能等技术的蓬勃发展，Java在这些领域中的应用仍然十分重要。同时，Java生态系统庞大且成熟，拥有丰富的开源框架和工具，为开发者提供了广泛的选择和支持。因此，可以说Java在企业级应用领域的地位是稳固的，并且有望继续发展。
此外，Java在移动应用开发领域也有着不可忽视的地位。虽然移动应用开发中出现了一些新兴的技术，例如React Native和Flutter，但Java仍然是Android平台的主要开发语言。而且，Android系统在全球范围内的市场份额仍然巨大，这为Java在移动应用开发领域提供了广阔的机遇。
四、前端人，该如何打好这场职位突围战？ 对于前端而言，它也在不断地发展和创新。新的前端框架和工具的涌现使得前端开发更加高效和便捷。同时，前端技术的跨平台能力也在不断增强，使得前端应用能够更好地适应不同的终端和设备。随着WebAssembly的兴起，前端应用的性能和功能也得到了大幅提升。这些进步使得前端开发在不同领域和行业中的需求不断增加。
总的来说，虽然技术领域的竞争激烈，但我们不应过分担忧和相信盲目的言论。Java和前端作为成熟和广泛应用的技术方向，依然具备广阔的发展前景和机遇。它们在不断演进和创新，为开发者提供更好的工具和平台，使得他们能够更加高效地开发和交付优秀的软件产品。
因此，对于从业者而言，关键是保持学习和适应能力。及时了解和掌握新的技术趋势和工具，不断提升自己的技术水平和能力。同时，也要注重全面发展，提升与人沟通、解决问题和创新思维等软技能。这样，无论是Java还是前端，都能够在激烈的竞争中立于不败之地，并抓住发展的机遇。
综上所述，虽然“Java已死、前端已凉”的言论在IT圈内引起了一定的关注和争议，但我们应该理性对待。Java和前端作为技术领域中的重要方向，依然具备广阔的发展前景和机遇。关键在于我们要保持学习和适应能力，不断提升自己的技术水平和能力。只有这样，我们才能超越流言，把握发展的机遇，并在技术的浪潮中不断前行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1bafa8a46df0048da1f0c83a29656da/" rel="bookmark">
			2024 年 11 款最佳 Android 数据恢复软件应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 设备上的数据丢失可能是一种令人痛苦的经历，通常会导致不可替代的信息瞬间消失。
意外删除、系统崩溃或格式错误都可能发生，重要数据的丢失可能会扰乱日常工作并影响您的工作效率。 幸运的是，技术进步带来了多种恢复解决方案，在本文中，我们将介绍 11 款最好的 Android 数据恢复软件，它们有望有效地挽救丢失的文件。
2024 年 11 款最佳 Android 数据恢复软件应用 1.奇客数据恢复安卓版 我们最推荐的软件奇客数据恢复安卓版是一款以其多功能性而闻名的全面 Android 数据恢复解决方案。 该软件旨在解决各种数据丢失情况，包括意外删除、水损坏和系统崩溃。
奇客数据恢复安卓版的与众不同之处在于它能够从内部存储和外部 SD 卡恢复各种文件，包括照片、视频和消息。 安卓数据恢复-奇客官网免费下载Android数据恢复软件扫描数据，支持文件、照片、视频、邮件、音频、微信消息等1000+种文件格式。https://www.geekersoft.cn/geekersoft-recovergo-android.html此外，其直观的界面确保了无忧的用户体验，使数据恢复过程变得简单且适合所有人，无论技术专业知识如何。
奇客数据恢复安卓版的突出功能之一是其预览功能，允许您有选择地恢复特定文件，从而节省时间和精力。 此外，该软件还提供强大的数据扫描功能，即使在水损坏或病毒攻击等复杂情况下，也能确保检索丢失数据的高成功率。
该工具拥有数据恢复所需的一切，并且有数百万人使用它，因此它是我们列表中的第一个条目也就不足为奇了。
2. iToolab RecoverGo Android 在这里，我们拥有最可靠、最高效的 Android 数据恢复工具之一，优先考虑易用性和有效恢复。 该恢复工具拥有简化的界面，适合所有级别的用户使用。
iToolab RecoverGo Android值得注意的是它的深度扫描功能。
它会在各种情况下详细搜索丢失的文件，包括意外删除、系统崩溃等。 它擅长检索照片、联系人、消息、文档等多种文件类型，为用户提供全面的数据恢复解决方案。
iToolab RecoverGo Android 的另一个显着优势是扫描和恢复数据的速度和效率，可在不影响检索质量的情况下快速提供结果。
3.Dr.Fone Dr.Fone因其令人印象深刻的成功率和广泛的设备兼容性（涵盖三星、Oppo 等领先品牌）而在 Android 数据恢复领域赢得了声誉。 它无需设备根访问即可无缝恢复各种数据类型，包括照片和 WhatsApp 消息等复杂数据。
UltData 之所以脱颖而出，是因为它承诺即使在备份不可用的情况下也能恢复各种文件类型，例如 WhatsApp 等应用程序中的视频、文档和录音。 然而，需要注意的是，虽然 UltData 擅长在无需 root 的情况下检索某些文件类型，但获取联系人或内存照片等文件可能需要 root。 UltData 兼容 6000 多种设备，确保跨 Android 设备的用户具有广泛的覆盖范围和可访问性。
4.iMyFone D-Back iMyFone D-Back 是一款专为 Android 用户设计的专用数据恢复软件。 该软件可以轻松恢复 Android 手机中已删除的照片，无需root 访问权限。 此外，它还可以在 Android 设备上恢复已删除的 WhatsApp 消息，而无需备份或 root 访问权限。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1bafa8a46df0048da1f0c83a29656da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6974e49a7c813ca912b520c5945e83c8/" rel="bookmark">
			【深度学习-目标检测】05 - YOLOv1 论文学习与总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文地址：You Only Look Once:Unified, Real-Time Object Detection
论文学习 1. 摘要 YOLO的提出：作者提出了YOLO，这是一种新的目标检测方法。与传统的目标检测方法不同，YOLO将目标检测视为一个回归问题，直接从图像像素到边界框坐标和类别概率的映射。方法特点： 统一的架构：YOLO使用单一的神经网络直接从完整图像中预测边界框和类别概率。这种统一的架构使得YOLO在检测性能上可以进行端到端的优化。实时性能：YOLO极其快速。基础的YOLO模型可以实时处理图像，每秒处理45帧。而更小的版本，Fast YOLO，可以处理高达155帧每秒，同时仍保持较高的平均精度（mAP）。 性能比较： 与其他实时检测系统相比，YOLO在本地化错误方面表现更好，但在背景误判方面的表现较差。YOLO在从自然图像到其他领域（如艺术作品）的泛化能力方面优于其他检测方法，如DPM和R-CNN。 补充：YOLO将目标检测视为回归问题的理解 想象一下，你有一张包含多个物体的照片，比如一张客厅的照片，里面有沙发、电视和一只猫。现在，如果我们要用一个计算机程序来识别这张照片中的物体及其位置，这就是一个典型的目标检测问题。
在传统的目标检测方法中，这个过程通常分为两步： 定位：首先识别出照片中可能有物体的区域（比如沙发的位置、电视的位置和猫的位置）。分类：然后对这些区域进行分类，判断它们是什么物体（比如这是沙发、那是电视、还有一只猫）。 而在YOLO这种使用回归方法的目标检测中，这个过程被简化为一步： 程序一次性直接从照片中“预测”出每个物体的位置（用边界框坐标表示）和类别（用类别概率表示）。这里的“预测”就是回归问题中的输出。具体来说，对于照片中的每个物体（比如猫），YOLO会输出： 边界框坐标：这是一组连续的数值，描述了猫在照片中的确切位置。通常包括猫所在区域的左上角和右下角的坐标。类别概率：这是一组数值，表示这个区域是猫的概率有多高，以及它可能是其他类别（如沙发、电视）的概率。 所以，YOLO通过一次计算就能告诉我们：“在这个位置有一只猫，我有90%的把握它是猫，10%的可能是其他东西。” 这就是回归问题在YOLO中的应用。
一般来说，YOLO会预测五个值（中心x坐标，中心y坐标，宽度，高度，类别概率）。
2. 引言 人类视觉系统的效率：作者首先指出，人类能够迅速且准确地通过视觉系统识别图像中的物体、它们的位置以及它们之间的相互作用。这种能力使我们能够轻松地执行复杂任务，例如驾驶汽车。
计算机视觉的挑战：作者强调，如果能开发出快速且准确的目标检测算法，那么计算机将能够在没有特殊传感器的情况下驾驶汽车，为残疾人提供实时场景信息，甚至实现通用的、响应灵敏的机器人系统。
现有目标检测系统的局限性：
传统的目标检测系统通常将分类器重新用于检测。这些系统通过在测试图像中的不同位置和尺度上评估分类器来检测物体。例如，形变部件模型（DPM）使用滑动窗口方法，而最近的方法如区域卷积神经网络（R-CNN）使用区域提议方法来首先生成潜在的边界框，然后在这些提议的框上运行分类器。这些复杂的流程不仅速度慢，而且难以优化，因为每个组件都需要单独训练。 YOLO的提出：鉴于现有方法的这些局限性，作者提出了YOLO，这是一种全新的目标检测方法。 YOLO将目标检测视为一个单一的回归问题，直接从图像像素到边界框坐标和类别概率的映射。
3. 统一检测 目标检测的统一化：
YOLO方法将目标检测的多个组成部分统一到一个单一的神经网络中。这种统一化的方法使得从整个图像中直接预测边界框和类别概率成为可能。与传统的、由多个阶段组成的目标检测方法不同，YOLO的统一网络同时处理多个任务，包括特征提取、边界框预测和类别概率预测。 网络结构：
YOLO网络将输入图像划分为一个S×S的网格。如果某个物体的中心落在一个网格单元内，那么这个网格单元就负责检测该物体。每个网格单元预测B个边界框和这些框的置信度（confidence scores）。置信度反映了模型对框中包含物体的把握，以及预测框与实际框的匹配程度。每个边界框包含5个预测值：中心点的x和y坐标、宽度、高度和置信度。每个网格单元还预测C个条件类别概率，这些概率是在网格单元包含物体的条件下计算的。
训练和优化：
YOLO网络在整个图像上进行训练，直接优化检测性能，而不是像传统方法那样分别训练不同的组件。网络使用大量的真实图像进行训练，学习如何准确地预测物体的位置和类别。 实时性能：
由于YOLO将检测过程简化为单一网络的前向传递，因此它能够以非常快的速度运行，实现实时目标检测。YOLO的这种快速性能使其适用于需要实时反馈的应用，如自动驾驶汽车和机器人导航。 4. 训练 预训练卷积层： YOLO首先在ImageNet 1000类竞赛数据集上预训练其卷积层。这一步骤旨在让网络学习到丰富的特征表示，这些特征对于后续的目标检测任务至关重要。预训练使用的是网络的前20个卷积层，后接平均池化层和全连接层。 转换为检测模型： 在预训练完成后，模型被转换为目标检测模型。这包括在网络中添加额外的卷积层和全连接层，这些层的权重是随机初始化的。为了适应目标检测任务，输入图像的分辨率被提高到448×448。 损失函数： YOLO使用平方和误差作为其损失函数。这个选择简化了优化过程，但并不完全符合目标检测的最终目标，即最大化平均精度。损失函数对不同类型的误差（如定位误差、分类误差）进行加权，以处理不同重要性的误差。 训练细节： 在训练过程中，使用了多种技术来提高模型的泛化能力和减少过拟合。这包括dropout和数据增强（如随机缩放和平移图像，调整图像的曝光和饱和度）。训练使用不同的学习率安排，初始阶段使用较低的学习率，随后逐渐提高。 边界框预测的特殊处理： YOLO对边界框的宽度和高度预测使用平方根变换，以更好地处理不同大小的边界框。训练时，只有与真实边界框重叠最多的预测框被认为是“负责”该目标的，这有助于模型学习到更准确的边界框。 5. 推理 单次网络评估： 在推理（即目标检测）阶段，YOLO只需要对测试图像进行一次网络评估。这与传统的目标检测方法不同，后者可能需要多次评估来检测图像中的不同区域。这种单次评估方法使得YOLO能够快速处理图像，实现实时目标检测。 网格设计和空间约束： YOLO将输入图像划分为S×S的网格，并在每个网格单元内进行预测。这种设计强制实现了预测的空间多样性，即每个网格单元负责检测位于其内部的目标。这种方法有助于减少重复检测和提高检测的准确性。 边界框和类别预测： 对于每个网格单元，YOLO预测多个边界框和这些框的置信度，以及条件类别概率。置信度反映了模型对框中包含物体的把握，以及预测框与实际框的匹配程度。条件类别概率则表示在检测到物体的情况下，它属于各个类别的概率。 非极大值抑制： YOLO使用非极大值抑制（Non-maximal Suppression，NMS）来处理多个重叠的边界框。这一步骤有助于去除冗余的检测结果，确保每个物体只被检测一次。NMS通过保留置信度最高的边界框，并去除与其重叠度较高的其他边界框来实现。 实时性能： 由于YOLO的简单和高效，它能够在保持较高检测精度的同时，实现实时的处理速度。这使得YOLO适用于需要快速响应的应用场景，如视频监控、自动驾驶等。 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6974e49a7c813ca912b520c5945e83c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/911c7b14a7aee16b4da1a05a465ff1b8/" rel="bookmark">
			MongoDB定容集合（Capped Collection）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
定容集合
定容集合行为
使用场景
限制和建议
使用方法
构建定容集合
查询
确定集合是否定容
将集合转换成定容集合
修改空间大小
修改文档数量限制
末尾持续游标（tailable cursor）
Mongodb的文档保存在集合当中，类似关系型数据库当中的表。用户对集合进行增删改查操作。
定容集合 定容集合，是一种固定大小的集合。支持数据的快速插入和按照插入顺序的高速读取。定容集合工作机制类似循环缓存。当集合大小达到用户指定的大小时，新插入的数据会覆盖最早插入的数据。
作为定容集合的替代方案，用户还可以选择定时索引。建立索引是指定索引数据的过期时间。当插入数据的时间索引字段超过过期时间后，mongodb或自动清除该数据。本文终点探讨定容集合，定时索引内容请参照其他文档。
定容集合行为 定容集合容量大小是确定的，并且保证数据按照插入顺序排列，因此具有下面的几个行为。
数据按照插入时间排序，查询时无需构建其他时间字段索引来对文档查询顺序。因此提高了数据插入性能。自动删除最先插入的数据。当达到容量限制时，定容集合自动删除最先插入的数据，无需显示执行删除操作或额外的删除脚本。定容集合有_id字段和_id字段索引。 使用场景 针对定容集合高效插入和保证按照插入顺序读取数据的特性，定容集合适应下面两个场景
保存系统日志。 因为无需构建额外的索引，索引向定容集合插入数据时，具备与直接写入文件系统类似的性能。其先入先出的特性，保证了写入时间的顺序。因此适合用来保存系统日志。 mongodb的oplog就使用了定容集合。将定容集合作为缓存，保存少量数据。 限制和建议 自mongodb5开始，定容集合禁止使用snapshot读取方式当用户更新定容集合的数据时，可以添加索引避免全表扫描。当然，更新完成后，建议删除改索引。定容集合，不可分片使用默认排序可以高效的读取定容集合数据，这与在unix系统中使用tail方法读取日志文件类似。禁止使用$out方法向定容集合写入数据禁止在mongodb事务中向定容集合写入数据。 使用方法 构建定容集合 使用db.createCollection()方法，显式创建定容集合。定义定容集合时，必须指定集合空间大小。mongodb在分配定容集合存储空间时，按照256bytes的倍数来分配大小。mongodb计算出小于用户指定空间大小的最大的256的倍数。定容集合最大存储空间，不能超过1PB。
db.createCollection("&lt;collectionName&gt;", {capped: true, size: &lt;collection_size&gt;}) 其中，collection_size的单位是字节(bytes)
db.createCollection("log", {capped: true, size: 100000}) db.getCollectionInfos({name: "log"}) { "name" : "log", "type" : "collection", "options" : { "capped" : true, "size" : 100000 }, "info" : { "readOnly" : false, "uuid" : UUID("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/911c7b14a7aee16b4da1a05a465ff1b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/869289133f47f94e5b51c21879d92853/" rel="bookmark">
			[DL]深度学习_AlexNet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AlexNet网络详解
目录
一、AlexNet
1、详细介绍
2、网络框架
二、网络详解 1、首次使用ReLu激活函数
2、模型基本结构与双GPU实现
3、局部响应归一化(LRN)
4、重叠池化(Overlapping Pooling)
5、数据增强
6、Dropout
一、AlexNet 1、详细介绍 AlexNet是一种经典的卷积神经网络模型，由Alex Krizhevsky、Ilya Sutskever和Geoffrey E. Hinton于2012年提出。它是第一个在ImageNet比赛中获得冠军的深度神经网络模型，引领了深度学习在计算机视觉领域的发展。
AlexNet的结构包含了8个图层，其中前5个是卷积层，后3个是全连接层。下面是对每个图层的详细介绍：
输入层（Input Layer）：接受输入的图像，并进行预处理。ImageNet数据集的图像大小为224x224x3，即224个像素的高度、224个像素的宽度和3个颜色通道（RGB）。
卷积层1（Convolutional Layer 1）：使用96个大小为11x11x3的卷积核对图像进行卷积操作，步长为4，不进行零填充（zero-padding）。这一层的目的是提取低级特征，例如边缘和纹理等。
激活函数1（Activation Function 1）：在卷积层之后，通过ReLU（线性整流函数）激活函数处理卷积层的输出。ReLU函数将所有负值变为零，保留正值不变。这一步帮助网络更好地拟合数据。
池化层1（Pooling Layer 1）：使用大小为3x3的最大池化操作，步长为2。这一步有助于减小特征图的尺寸，并且在一定程度上保留重要的特征。
卷积层2（Convolutional Layer 2）：使用256个大小为5x5x48的卷积核对特征图进行卷积操作，步长为1，零填充。这一层进一步提取高级特征。
激活函数2（Activation Function 2）：同样使用ReLU函数对卷积层输出进行激活。
池化层2（Pooling Layer 2）：同样使用大小为3x3的最大池化操作，步长为2。这一步继续减小特征图的尺寸。
卷积层3（Convolutional Layer 3）：使用384个大小为3x3x256的卷积核对特征图进行卷积操作，步长为1，零填充。这一层进一步提取高级特征。
激活函数3（Activation Function 3）：同样使用ReLU函数对卷积层输出进行激活。
卷积层4（Convolutional Layer 4）：使用384个大小为3x3x192的卷积核对特征图进行卷积操作，步长为1，零填充。这一层继续提取高级特征。
激活函数4（Activation Function 4）：同样使用ReLU函数对卷积层输出进行激活。
卷积层5（Convolutional Layer 5）：使用256个大小为3x3x192的卷积核对特征图进行卷积操作，步长为1，零填充。这一层继续提取高级特征。
激活函数5（Activation Function 5）：同样使用ReLU函数对卷积层输出进行激活。
池化层3（Pooling Layer 3）：同样使用大小为3x3的最大池化操作，步长为2。这一步再次减小特征图的尺寸。
全连接层1（Fully Connected Layer 1）：有4096个神经元，将池化层输出的特征图展平为一个向量，并通过该层进行分类。
全连接层2（Fully Connected Layer 2）：有4096个神经元，同样用于分类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/869289133f47f94e5b51c21879d92853/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35d1650fdcb7a748fed11a1edf74c40c/" rel="bookmark">
			jquery上传图片单图多图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要用到的就是input里面的file，上传完成拿到文件流发给后端后端返回图片路径，让后前端展示出来。本篇文章包含单图上传和多图上传。最后有代码复制后更换上传接口，即可使用。 1.单图上传。 思路：拿到中间点击上传元素，点击后给父元素下面增加一个input标签，自触发点击事件并且监听input的上传如果上传成功，隐藏上传二维码元素再增加img元素。
2.多图上传。 思路：多图上传和单图上传方法都一样不过多了一点东西，那就是上传完之后要拿到的是个图片数组，所以我们要先var一个空数组，用来上传完毕后拿到上传的图片数组。每次上传成功都向数组里面push一个数据，删除就用splice这里也可以设置最大上传，用来做校验。
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"&gt; &lt;title&gt;上传图片&lt;/title&gt; &lt;meta name="keywords" content="关键词" /&gt; &lt;meta name="description" content="描述" /&gt; &lt;link href="/static/css/css.css" rel="stylesheet" type="text/css" /&gt; &lt;script type="text/javascript" src="/static/js/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/static/js/jquery.SuperSlide.2.1.1.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;style&gt; .c_left2 .items { min-height: 45px; display: flex; margin-bottom: 24px; margin-top: 40px; } .c_left2 .items .left_text::before { content: '*'; display: inline-block; margin: 5px; color: #FF9C00; font-size: 14px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35d1650fdcb7a748fed11a1edf74c40c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef93145abab372d0521691a54485ad23/" rel="bookmark">
			Failed to initialize the nvidia kernel module。Can‘t find org.freedesktop.portal.， no screens found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统：debian12
关机重启时没注意选上了自动更新系统软件，然后重启就打不开了。黑屏+左上角有光标闪烁。进不去图形化界面。
按ctrl+alt+F3切换命令行模式，查看日志：
cat /var/log/Xorg.0.log
显示，Failed to initialize the nvidia kernel module。no screens found (EE)。
这时候应该安装内核就完事了。
uname-r 得到系统内核版本，假设是 6.1.0-16-amd64，
然后下载 sudo apt-get install linux-headers-6.1.0-16-amd64 记得换(uname -r 的值)
应该就可以了。
然而，我并不知道这么回事，我把配置文件重命名
mv /etc/X11/xorg.conf /etc/X11/xorg.conf.org 这时候就能启动图形化界面了，只不过这时候驱动得重新装。
所以，下载相应版本的nvidia驱动，
NVIDIA GeForce 驱动程序 - N 卡驱动 | NVIDIANVIDIA GeForce 驱动程序官方提供下载最新版的 Geforce 驱动程序，可提升 PC 游戏体验和应用程序速度。更多关于更新显卡驱动程序以及显卡驱动程序下载的信息，请访问 NVIDIA 官网。https://www.nvidia.cn/geforce/drivers/
然后直接加权限运行，这方面有很多教程，比如：
Linux系统下的Nvida显卡驱动安装 - Fight!GO - 博客园 (cnblogs.com)https://www.cnblogs.com/Fight-go/p/15828351.html#:~:text=%E6%89%93%E5%BC%80%E7%BB%88%E7%AB%AF%EF%BC%8C%E8%BE%93%E5%85%A5%E5%A6%82%E4%B8%8B%E6%8C%87%E4%BB%A4%EF%BC%9A%20sudo%20apt%20install%20gcc%20libgtk,-3%20-dev%20libpolkit-gobject%20-1%20-dev%20%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F%E7%9A%84%E8%AF%9D%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8CNvida%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%89%E8%A3%85%E4%BA%86%EF%BC%8C%E8%8B%A5%E6%8F%90%E7%A4%BA%E4%B8%8D%E8%83%BD%E5%AE%89%E8%A3%85%EF%BC%8C%E8%AF%B7%E8%87%AA%E8%A1%8C%E6%90%9C%E7%B4%A2%E8%A7%A3%E5%86%B3%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%A1%8C%E5%8F%AF%E4%BB%A5%E8%AF%84%E8%AE%BA%E9%97%AE%E7%AC%94%E8%80%85%EF%BC%8C%E7%AC%94%E8%80%85%E4%BC%9A%E5%B8%AE%E5%BF%99%E8%A7%A3%E5%86%B3%E7%9A%84%E3%80%82
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8b1f3eb70497868abe5932f63f3fa1d/" rel="bookmark">
			android RecyclerView1.3.2与NestedScrollingParent的变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章，可能不懂的人将会不知所云，懂的自然懂，不懂的可能需要遇到类似问题回头来看我的帖子好了。
RecyclerView1.3.0+版本，与1.2.1版本有一个比较大的变化是：内部对于edge的处理不同。
edge是什么？
就是当我们下拉或者上拉（横向RecyclerView则是左右拉），会有一个极限。当到了极限，则会出现边缘效果，就是有一个额外的小头部效果贴在边上。并且，RecyclerView就会出现简单的拉伸变长，以表现它无法继续滑动的现象。
而我们经常会开发下拉刷新功能。那么，就相当于用一个ParentConstraintLayout（以下用parent代替）内部持有一个子View RecyclerView（以下用rcv代替）。
我通过自行解压RecyclerView库1.3.2和1.2.1的代码来对比，最大的差异为：
public boolean onTouchEvent(MotionEvent e) { ... if (mScrollState == SCROLL_STATE_DRAGGING) { mReusableIntPair[0] = 0; mReusableIntPair[1] = 0; dx -= releaseHorizontalGlow(dx, e.getY()); //1.3.2多出来的 dy -= releaseVerticalGlow(dy, e.getX()); //1.3.2多出来的 //触发NestedScroll框架的必须 if (dispatchNestedPreScroll( canScrollHorizontally ? dx : 0, canScrollVertically ? dy : 0, mReusableIntPair, mScrollOffset, TYPE_TOUCH )) { dx -= mReusableIntPair[0]; dy -= mReusableIntPair[1]; // Updated the nested offsets mNestedOffsets[0] += mScrollOffset[0]; mNestedOffsets[1] += mScrollOffset[1]; // Scroll has initiated, prevent parents from intercepting getParent().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8b1f3eb70497868abe5932f63f3fa1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0d71b77ac2ea991f39f9dfdd5e985b5/" rel="bookmark">
			mybatis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		resultType和resultMap功能类似 ，都是返回对象信息 ? resultMap 高级映射 ：（resultMap） 如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。（高级映射，字段名称可以不一致，通过映射来实现
单表查询 关联查询（一对一） resultMap对于一对一表连接的处理方式通常为在主表的pojo中添加嵌套另一个表的pojo，然后在mapper.xml中采用association节点元素进行对另一个表的连接处理。例如
订单查询关联用户的resultMap
将整个查询的结果映射到cn.itcast.mybatis.po.Orders中
association:
作用：将关联查询信息映射到一个pojo对象中
关联查询（一对多） resultMap的处理方式为在订单表数据的pojo中添加一个list,list中为订单明细表的属性，在mapper.xml中采用如下的处理方式：
订单及订单明细的resultMap
使用extends继承，不用在中配置订单信息和用户信息的映射
collection：
作用：将关联查询信息映射到一个list集合中。
resultType 基本映射 ：（resultType）使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。（数据库，实体，查询字段,这些全部都得一一对应）
SQL删除数据空格函数 1、Trim()函数：前后空格 用来删除数据左右两边（开始和结尾处）的空格。
2、RTrim()函数：后面空格 用来删除数据右边（结尾处）的空格。
3、LTrim()函数：前面空格 用来删除数据左边（开始处）的空格。
注意：Trim()、RTrim()、LTrim() 函数不光可以用于SELECT语句中，还可以用于WHERE等语句中。
4、Replace函数：中间空格 字符中的空格，用replace(string, ' ', '')
语法： Mybatis之&lt;trim prefix="" suffix="" suffixOverrides="" prefixOverrides=""&gt;&lt;/trim&gt;
prefix: 在trim标签内sql语句加上前缀。
suffix: 在trim标签内sql语句加上后缀。
prefixOverrides: 指定去除多余的前缀内容
suffixOverrides: 指定去除多余的后缀内容，如：suffixOverrides="," 去除trim标签内sql语句多余的后缀"," 概述： MyBatis 是一款优秀的持久层框架
它的前身是IBatis
它支持定制化 SQL、存储过程以及高级映射。
它是一个半自动化的ORM（对象 关系 映射）映射框架
MyBatis的前身就是iBatis,iBatis本是apache的一个开源项目，2010年5月这个项目由apahce sofeware foundation 迁移到了google code，并且改名为MyBatis。
MyBatis 是支持普通 SQL 查询,存储过程和高级映射的优秀持久层框架。MyBatis 消除了几乎所有的 JDBC 代码和参数的手工设置以及结果集的检索。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0d71b77ac2ea991f39f9dfdd5e985b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b45f6892004746157541405ca8b38a7/" rel="bookmark">
			算法测试流程脚本工具站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍉一、录入sql和批量上传minIo图片， 录入sql（掠过）...,
一个上传，一个下载，只需上传，找到
def upload(): # NOTE：Step:3 把拉下来的图片传上去给XXX服务器的minio up_data_minio("test", image_Urls_path='res') 修改image_Urls_path，为批量上传图片目录位置。 找到
# 上传图片到minio def up_data_minio(bucket: str, image_Urls_path='imageUrlFromminIO'): # TODO：minio_conf唯一要修改的地方！ minio_conf = { 'endpoint': '10.168.1.96:9000', # 'endpoint': '172.20.0.67:9000', 'access_key': 'minioadmin', # 'access_key': 'root', 'secret_key': 'minioadmin', # 'secret_key': 'Lidar4d@#321', 'secure': False } 修改minio_conf为需要上传到指定minIO的绑定信息。 import minio import pymysql import openpyxl import os def get_data_from_mysql(): # 连接数据库- conn = pymysql.connect(host="10.168.1.94", user="root", passwd="root", db="RemotePatrolDB", port=3369, charset="utf8") cur = conn.cursor() # 创建游标对象 # 查询表中数据 cur.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b45f6892004746157541405ca8b38a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e33745c82ad4e142f014c9d2bb7bbd8/" rel="bookmark">
			2024年测量、信号处理与深度学习国际会议（ICMSPDL 2024）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年测量、信号处理与深度学习国际会议（ICMSPDL 2024）
2024 International Conference on Measurement, Signal Processing, and Deep Learning
ICMSPDL 2024是一个汇集行业和学术界的顶级论坛。会议将邀请国内外知名专家就信号处理、测量、深度学习方法和技术领域的技术进展、研究成果和应用进行专题报告，并进行学术交流。我们诚挚邀请国内外相关高校和研究机构的研究人员以及企业的工程技术人员参加会议。
征稿主题
（以下主题包括但不限于）
测绘学
海洋测绘
摄影测量
大地测量
水文测量
矿山测量
工程测量
重力测量
航空摄影测量
地图制图
精密仪器制造
图形图象复制技术
传感器技术
测绘技术
测绘仪器
考古测绘
信号处理与检测
雷达和声纳信号处理
通信信号处理
音频和声音信号处理
传感器阵列和多通道信号处理
多媒体信号处理
语音和语言处理
图像和视频处理
计算机视觉和机器人技术的信号处理
优化方法
计算成像/光谱成像
机器学习
通过图形和网络进行信号处理
压缩感知和稀疏建模
非线性信号处理
统计信号处理
物联网信号处理
信息取证和安全
教育信号处理
大数据信号处理
电力系统的信号处理
信号处理系统的设计/实现
认知架构
常识推理
机器学习
可视化推理
智能化叙事
认知架构
常识推理
机器学习
可视化推理
投稿邮箱：ieee_conf@163.com （投稿时请在邮件正文备注：苏老师推荐，将享有优先审稿及录用和学生优惠价）
论文出版
所有投稿都必须先经过2-3位专家审稿，评审录用后，文章将以会议论文集的形式出版，最终提交EI Compendex、Scopus 和Inspec检索。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e33745c82ad4e142f014c9d2bb7bbd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eec19db0907d93e3bf1ae274cdb146b0/" rel="bookmark">
			检索稳定▉2024年能源、信息技术与科学应用国际会议（ICEITSA 2024）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		检索稳定▉2024年能源、信息技术与科学应用国际会议（ICEITSA 2024） 2024 International Conference on Energy, Information Technology, and Scientific Applications
2024年能源、信息技术与科学应用国际会议（ICEITSA 2024）定于三亚举行。会议主要讨论了能源资源和信息技术等研究领域。会议旨在为从事能源材料和科学研究的专家、学者、工程技术人员和技术研究人员提供一个平台，分享科学研究成果和前沿技术，了解学术发展趋势，拓宽研究思路，加强学术研究和探索，推动学术成果产业化。大会诚挚邀请国内外高校专家、科研机构专家、学者、工商界人士及其他相关人员参加交流。 大会主题: (主题包括但不限于, 更多主题请咨询会务组苏老师)
能源材料
储能技术
节能技术
能源化学工程
能源安全与清洁使用
能源设备与技术
热物理与热工程
绿色能源
通信工程
通讯网络
物联网（IoT）
新面板显示
云计算
语音处理和图像处理
模式识别与装置
信息系统与安全
模式识别与人工智能
实时信号与处理
信息管理与信息处理
5G 通信与信号处理
5G应用技术、发展与服务标准
智能通信开发与软件开发
通讯安全和隐私
应用数值分析
图论集
蒙特卡洛方法
分子动力学
模型拟合与数据分析
计算数学
计算物理学
计算化学
计算金融学
大型科学和工程计算
社会计算
量子计算
以人为本的计算
机器学习
网络分析
模式识别
分布式和并行系统
高性能计算与算法
基于Web和网格的计算和模拟
Matlab编程与应用
认知计算
云计算
嵌入式计算
可伸缩计算
移动计算
投稿邮箱：intee_conf@163.com
【投稿时请附言:“论文投稿+苏老师推荐,申请优惠价”。方便安排审稿，避免文章遗漏，以及后续增值税普票（专票）、论文集寄送等】
会议论文投稿与参会说明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eec19db0907d93e3bf1ae274cdb146b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/952eadf1e4cf5896892b49af89a697dd/" rel="bookmark">
			Linux中的SetUid和capability权能机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中国科学院大学操作系统安全课小实验。
1. 前置知识 以下内容来自课件。
1.1 用户划分和访问控制 用户划分
访问控制 r读 w写 x执行
访问控制
实现举例
实现举例
1.2 特殊权限的访问控制setuid/setgid 必须有一种方法，允许用户执行那些只有超级用户或者管理者才有读写权限的程序或命令。
概念讲解
设置UID passwd的拥有者（也就是root）原本对passwd有执行权限，所以passwd拥有者对它的访问控制从rwx变成了rws。
设置GID 设置粘滞位STICKY 小测试 增加问题：
当进程P显示England时，对文件filex有什么访问权限？当进程P显示Australia时，对文件filex有什么访问权限？ 1.3 权能体系capabilites 权能体系提出背景
权能体系目的
完整的权能列表请见第二章实验内容。
权能列表
2. 实验内容 实验环境：Ubuntu 18.04 64位
第一题 Q：解释“passwd”,“sudo”, “ping”等命令为什么需要setuid位，去掉s位试运行，添加权能试运行。
A：
① 为什么需要setuid位：
首先明确setuid的作用是：执行该设置后，文件执行时将以文件拥有者的身份执行，而非普通用户的身份。
以普通用户的身份登录操作系统，通过whoami命令查看当前用户：
通过which命令查看passwd、sudo、ping文件所在位置：
通过ls -all查看这些文件的详细信息：
从上图可以看出passwd、sudo和ping的文件拥有者是root，即超级用户，所属用户组是root，并且都设置了SUID。
当其他的普通用户执行passwd、sudo和ping时，由于不是root，无法执行这些文件。而setuid之后，普通用户便可以临时以文件拥有者root的身份执行这些文件。所以passwd、sudo和ping等命令需要setuid。
② 去掉uid位
通过chmod命令移除passwd、sudo和ping文件的setuid：
移除setuid后再以普通用户的身份执行这些命令，发现这些命令全部都无法执行：
③ 恢复uid位
由于恢复passwd和ping的setuid时需要使用sudo，故应先恢复sudo。
在重启系统时按下ESC键，进入GNU GRUB界面，选择Advanced options for Ubuntu：
再选择一个recovery mode：
选择root，进入最高级管理员的shell界面，输入chmod u+s /usr/bin/sudo恢复sudo的setuid：
继续在shell界面输入exit退回上一个界面，选择resume，回车重启系统。
通过sudo+chmod恢复passwd和ping的setuid：
重新添加权能后上述三个命令又可以正常运行了：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/952eadf1e4cf5896892b49af89a697dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f8fa927eb7a95e62ce1ea69bb89fa25/" rel="bookmark">
			大厂面试题集合之蚂蚁一面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉搜索树和平衡二叉树有什么关系？ 平衡二叉树也叫做平衡二叉搜索树，是二叉搜索树的升级版，二叉搜索树是指节点左边的所有节点都比该节点小，节点右边的节点都比该节点大，而平衡二叉搜索树是在二叉搜索的基础上还规定了节点左右两边的子树高度差的绝对值不能超过1
强平衡二叉树和弱平衡二叉树有什么区别 强平衡二叉树AVL树，弱平衡二叉树就是我们说的红黑树。
AVL树比红黑树对于平衡的程度更加严格，在相同节点的情况下，AVL树的高度低于红黑树红黑树中增加了一个节点颜色的概念AVL树的旋转操作比红黑树的旋转操作更耗时 B树和B+树的区别，为什么MySQL使用B+树 B树的特点：
节点排序一个节点可以存多个元素，多个元素也排序了 B+树的特点：
拥有B树的特点叶子节点之间有指针非叶子节点的元素在叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好顺序 MySQL索引使用的是B+树，因为索引是用来加快查询的，而B+树通过对数据进行排序所以是可以提高查询速度的，然后通过一个节点中可以存储多个元素，从而可以使得B+树的高度不会太高，在MySQL中InnoDB页就是一个B+树节点，一个InnoDB页默认16kb，所以一般情况下一颗两层的B+树可以存储2000万行左右的数据，然后通过利用B+树叶子节点存储了所有数据并且进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等SQL语句。
epoll和poll的区别 select模型：使用的是数组来存储Socket连接文件描述符，容量是固定的，需要通过轮询来判断是否发生了IO事件poll模型：使用的是链接来存储Socket连接文件描述符，容量是不固定的，同样需要通过轮询来判断是否发生了IO事件epoll模型：epoll和poll是完全不同的，epoll是一种事件通知模型，当发生了IO事件时，应用程序才进行IO操作，不需要poll模型那样主动去轮询 简述线程池原理，知道FixedThreadPool用的阻塞队列是什么嘛？ 线程池内部是通过队列+线程实现的，当我们利用线程池执行任务的时候：
如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。如果此时线程池中的数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列中。如果此时线程池中的数量大于等于corePoolSize，缓冲队列workQueue已满，并且线程池中的数量小于maximumPoolSize，则会创建新的线程来处理被添加的任务。如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue已满，并且线程池中的数量等于maximumPoolSize，那么通过handler所指定的策略来处理此任务。当线程池中的线程数量大于corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。 FixedThreadPool代表的是定长线程池，底层用的是LinkedBlockingQueue，表示无界的阻塞队列。
Synchronized和ReentranLock的区别知道嘛？ Synchronized是一个关键字，ReetrantLock是一个Java类。Synchronized会自动地加锁与释放锁，ReetrantLock需要程序员的手动加锁和释放锁。Synchronized的底层是JVM层面的锁，ReentranLock是API层面的锁。Synchronized是非公平锁，ReentrantLock可以选择公平锁或非公平锁。Synchronized锁的是对象，锁信息保存在对象头中，ReetrantLock通过代码中的int类型的state标识来标识锁的状态。Synchronized底层有一个锁升级的过程。 Sychronized的自旋锁、偏向锁、轻量级锁、重量级锁，分别介绍和联系 偏向锁：在锁对象的对象头中记录一下当前获取到该锁的线程ID，该线程下次如果又来获取该锁就可以直接获取到了轻量级锁：由偏向锁升级而来，当一个线程获取到锁后，此时这把锁是偏向锁，此时如果有第二个线程来竞争锁，偏向锁就会升级为轻量级锁，之所以叫轻量级锁，是为了和重量级锁区分开来，轻量级锁底层是通过自旋来实现的，并不会阻塞线程如果自旋次数过多仍然没有获取到锁，则会升级为重量级锁，重量级锁会导致线程阻塞自旋锁：自旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就无所谓唤醒线程，阻塞和唤醒这两个步骤都是需要操作系统去进行的，比较消耗时间，自旋锁是线程通过CAS获取预期的一个标记，如果没有获取到，则继续循环获取，如果获取到了则表示获取到了锁，这个过程线程一直在运行中，相对而言没有使用太多的操作系统资源，比较轻量。 HTTPS是如何保证安全传输的 Https通过使用对称加密、非对称加密、数字证书等方式来保证数据的安全传输。
客户端向服务端发送数据之前，需要先建立TCP连接，所以需要先建立TCP连接，建立完TCP连接后，服务端会先给客户端发送公钥，客户端拿到公钥后就可以用来加密数据了，服务端到时候接收到数据就可以用私钥解密数据，这种就是通过非对称加密来传输数据。不过非对称加密对比对称加密要慢，所以不能直接使用非对称加密来传输数据，所以可以通过非对称加密的方式来传输对称加密的密钥，之后就可以使用对称加密来传输请求数据了。但是仅仅通过非对称加密+对称加密还不足以能保证数据传输的绝对安全性，因为服务端向客户端发送公钥时，可能会被截取。所以为了安全的传输公钥，需要用到数字证书，数字证书具有公信力、大家都认可的，服务端向客户端发送公钥时，可以把公钥和服务端相关信息通过Hash算法生成消息摘要，再通过数字证书提供的私钥对消息摘要进行加密生成数字签名，在把没进行Hash算法之前的信息和数字签名已经形成数字证书。最后把数字证书发送给客户端，客户端收到数字证书之后，就会通过数字证书提供的公钥来解密数字证书，从而得到非对称加密要用到的公钥。在这个过程中，就算有中间人拦截到服务器发送出来的数字证书，虽然它可以解密得到非对称加密要使用的公钥，但是中间人时没办法伪造数字证书发送给客户端的，因为客户端上内嵌的数字证书时全球具有公信力的。某个网站如果要支持https，都是需要申请数字证书的私钥的，中间人如果要生成能被客户端解析的数字证书，也是要申请私钥的，所以是比较安全了。 本文福利， 免费领取C/C++ 开发学习资料包、技术视频/代码，1000道大厂面试题，内容包括（C++基础，网络编程，数据库，中间件，后端开发/音视频开发/Qt开发/游戏开发/Linuxn内核等进阶学习资料和最佳学习路线）↓↓↓↓↓↓见下面↓↓文章底部点击免费领取↓↓
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a9f6495d7ca58d22622a28ed28e3dd4/" rel="bookmark">
			游戏服务器选择高防服务器的好处
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游戏服务器选择高防服务器的好处
1.保障游戏的正常运行
目前游戏行业深受很多用户的喜爱，但也存在众多的恶意网络攻击，游戏服务商深受其害。一旦遭受了网络攻击，轻者游戏体验感变差，重者游戏玩家无法访问，对游戏服务商的危害是巨大的。如果游戏服务商采用了高防服务器，就能对网络攻击进行防御和流量清洗，保障游戏的正常运行。
2.服务器配置突出
针对高防御的服务器，其配置都是很高的。在服务器的cpu、内存、硬盘等方面都比普通的服务器更具优势，在数据处理和响应层面更快速。这能为游戏玩家创造流畅的使用环境，在游戏同行之间也更有竞争优势。
3.网络资源丰富
高防服务器是需要丰富的带宽资源来支撑的。因此，在使用高防服务器租用的时候，网络带宽一定是经过线路优化的，访问更快，网速也更稳定，这能提升游戏玩家的体验感。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88cd2d6d7712c6a2c38a069afa0c8db2/" rel="bookmark">
			Windows使用netsh命令端口映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		显示所有的端口映射信息：
netsh interface portproxy show all
添加端口映射：
netsh interface portproxy add v4tov4 listenaddress=监听地址 listenport=监听端口 connectaddress=映射IP connectport=映射端口
删除端口映射：
netsh interface portproxy delete v4tov4 listenaddress=监听地址 listenport=监听端口
注：要以管理员的身份运行cmd窗口
参考 代理转发与隧道应用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b0e01501d4b9fd9e5ec3997848e786d/" rel="bookmark">
			rpm 版本问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rpm 版本问题处理 错误信息 错误原因 rpm 升级过，本来应该是rpm-4.11.3-45.el7 版本但现在变成了rpm-4.11.3-48.el7_9.x86_64，所以rpm-python-4.11.3-45.el7.x86_64.rpm无法安装，需要 rpm-4.11.3-45.el7 解决方案 下载 rpm-4.11.3-45.el7 清华大学开源镜像网站： 清华大学开源镜像网站
– 右键复制链接下载即可
下载 rpm-python-4.11.3-48.el7_9.x86_64.rpm 官方镜像网站： 官方镜像网站 – 右键复制链接下载即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c39ac6f09e3eb85c216c1d6540bbc097/" rel="bookmark">
			Spark的生态系统概览：Spark SQL、Spark Streaming
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Spark是一个强大的分布式计算框架，用于大规模数据处理。Spark的生态系统包括多个组件，其中两个重要的组件是Spark SQL和Spark Streaming。本文将深入探讨这两个组件，了解它们的功能、用途以及如何在Spark生态系统中使用它们。
Spark SQL Spark SQL是Spark生态系统中的一个核心组件，它提供了结构化数据处理的能力，允许以SQL查询方式分析和操作数据。Spark SQL具有以下重要特性：
1 结构化数据处理 Spark SQL可以处理各种结构化数据，包括JSON、Parquet、Avro、ORC等数据格式，以及关系型数据库中的数据。这使得它非常适用于大数据分析和ETL（抽取、转换、加载）任务。
2 DataFrame API Spark SQL引入了DataFrame API，这是一个类似于关系型数据库表的数据结构，可以轻松进行数据操作和转换。DataFrame API提供了丰富的操作函数，允许执行过滤、聚合、排序等数据操作，同时还支持用户自定义函数（UDF）。
3 与Hive的整合 Spark SQL与Apache Hive集成得非常好，可以查询Hive表并将查询结果作为DataFrame返回。这使得现有的Hive用户可以无缝迁移到Spark平台，并继续使用他们熟悉的查询语言。
4 示例代码：使用Spark SQL分析数据 通过一个简单的示例代码来演示如何使用Spark SQL来分析数据。假设有一个存储在Parquet格式中的用户日志数据，想要统计每个用户的访问次数：
from pyspark.sql import SparkSession # 创建SparkSession spark = SparkSession.builder.appName("SparkSQLExample").getOrCreate() # 读取Parquet文件为DataFrame user_logs = spark.read.parquet("hdfs://&lt;HDFS_MASTER&gt;:&lt;HDFS_PORT&gt;/path/to/user_logs") # 使用Spark SQL查询 user_logs.createOrReplaceTempView("logs") result = spark.sql("SELECT user_id, COUNT(*) as visit_count FROM logs GROUP BY user_id") # 显示查询结果 result.show() Spark Streaming Spark Streaming是Spark生态系统中用于实时数据处理的组件，它允许以微批次的方式处理实时数据流。以下是Spark Streaming的关键特性：
1 高吞吐量 Spark Streaming可以处理高吞吐量的数据流，如日志文件、传感器数据、社交媒体流等。它能够在短时间内处理大量数据，适用于需要快速响应的应用场景。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c39ac6f09e3eb85c216c1d6540bbc097/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3233bf30af8d1473dfe8844a58697ac0/" rel="bookmark">
			C&#43;&#43;篇 memset() 函数 数组初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;cstring&gt; int a[1024]; memset(a,1,sizeof(a)); a数组元素值将全部初始化为16843009，为什么会这样呢？
memset()函数原理是对内存块中字节元素进行初始化，上述代码中每字节将初始化为十六进制下ox01，(1字节=8bit ox01=0000 0001)，int类型为4字节（32bit），故a[i]=ox01 01 01 01转化为十进制为16843009。
所以我们在使用memset()函数时通常将初始化值设为0，即
memset(a,0,sizeof(a)); 即使经过计算机内部硬件转化 初始化仍未0。（ox00 00 00 00 == 0）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a17b0c3c5bc3fc604f696508e6d368c/" rel="bookmark">
			Mac 修改报错Permission denied、chmod命令详细用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息 Permission denied 解决方案 一、给文件加权限
一个文件有3种权限，读、写、可执行，Permission denied就是没有可执行权限，所以需要加上可执行权限。
进入终端先 cd 到该文件的目录下执行命令 chmod a+x ./文件名 二、赋予文件夹权限
sudo chmod -R 777 目录路径 其中 -R 是指级联应用到目录里的所有子目录和文件
777 是所有用户都拥有最高权限
chmod命令详细用法 使用方式 :
chmod [-cfvR] [--help] [--version] mode file... 说明 : Linux/Unix 的档案调用权限分为三级 : 档案拥有者、群组、其他。利用 chmod 可以藉以控制档案如何被他人所调用。
参数 :
mode : 权限设定字串，格式如下 : [ugoa...][[+-=][rwxX]...][,...]，其中 u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 + 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。 -c : 若该档案权限确实已经更改，才显示其更改动作 -f : 若该档案权限无法被更改也不要显示错误讯息 -v : 显示权限变更的详细资料 -R : 对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更) --help : 显示辅助说明 --version : 显示版本 [ u/g/o/a ]说明uuser 表示该文件的所有者ggroup 表示与该文件的所有者属于同一组( group )者，即用户组oother 表示其他以外的人aall 表示这三者皆是 [ + - = ]说明+增加权限-取消权限=唯一设定权限 rwxX说明rread 表示可读取，对于一个目录，如果没有r权限，那么就意味着不能通过ls查看这个目录的内容。wwrite 表示可写入，对于一个目录，如果没有w权限，那么就意味着不能在目录下创建新的文件。xexcute 表示可执行，对于一个目录，如果没有x权限，那么就意味着不能通过cd进入这个目录。X表示只有当该档案是个子目录或者该档案已经被设定过为可执行。 名称说明-c若该档案权限确实已经更改，才显示其更改动作-f若该档案权限无法被更改也不要显示错误讯息-v显示权限变更的详细资料-R对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更)–help显示辅助说明–version显示版本 范例：将档案 file1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a17b0c3c5bc3fc604f696508e6d368c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e94e2c5a2adab698dbbce731d3a05b2/" rel="bookmark">
			操作系统：linux（在虚拟机上详细步骤安装）Centos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言：一、如何在自己的电脑上安装centos?二、在虚拟机上安装centos2.1安装步骤： 前言： 操作系统有：windows server 不开源的收费的、linux 开源的免费的，精简安装（没有UI)。国产的操作系统有：银河麒麟、中标麒麟、统信UOS,但是都是基于linux再开发的。 一、如何在自己的电脑上安装centos? 1.刷机
大部分人都不愿意的。2.虚拟机软件。（VMware）虚拟机安装系统需要的对应的镜像：
centos选择7.0
镜像下载去清华大学镜像站。点击去清华大学镜像站
下载的时候建议选择完整版不要选择最小版。 二、在虚拟机上安装centos 2.1安装步骤： 第一步先打开虚拟机并创建新的虚拟机：
第二步建议选择自定义然后下一步：
第三步点击下一步：
第四步选择稍后安装：
第五步选择linux版本为centos 7
第六步给自己的虚拟机命名和存放的位置：
第七步给虚拟机配置处理器（根据自己的电脑配置来）
第八步根据自己电脑的内存多大来配置虚拟机的内存
第九步选择联网类型（NAT）
第十步点击下一步：
第十一步点击下一步：
第十二步点击下一步：
第十三步给虚拟机磁盘大小，选择将虚拟磁盘拆分成多个文件
第十四步点击下一步：
第十五步点击完成：
因为我前面选择的是稍后安装镜像，所以不要急着开启虚拟机。第十六步点击编辑虚拟机设置：
第十七步选择CD/DVD把镜像存放的位置放进去：
第十八步开启虚拟机：
第十九步选择
等待安装：
第二十步选择中文：
第二十一步选择软件安装再选择桌面：
第二十二步点击安装位置选择它：
-第二十三步点击开始安装：
-第二十四步安装的时候可以去设置密码：
第二十五步点击重启：
第二十六步接受许可证：
要远程连接的话虚拟机必须要有网：第二十七步把以太网开关打开：
- 第二十八步点击完成配置就可以进桌面了：
选择语言
第二十九步设置用户名：
第三十步设置密码：
第三十一步点击开始使用
就装好啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b524da82ab504c4f217f12f9fb8638b/" rel="bookmark">
			利用策略模式与Spring Boot实现灵活的文件上传功能：多策略选择与动态实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当涉及文件上传功能时，使用策略模式是一个明智的选择。在Spring Boot中，您可以利用策略模式来实现文件的动态上传功能。这种模式允许您定义一系列的算法，将它们封装成独立的类，使得这些算法可以相互替换，而不影响客户端的使用。接下来，我将为您详细介绍如何在Spring Boot中实现这一点。
**
1. 定义接口和策略类 **
首先，创建一个接口来定义文件上传的策略：
public interface FileUploadStrategy { void uploadFile(MultipartFile file); } 然后，实现该接口来创建具体的上传策略类：
@Service public class LocalFileUploadStrategy implements FileUploadStrategy { @Override public void uploadFile(MultipartFile file) { // 实现本地文件上传逻辑 } } @Service public class CloudFileUploadStrategy implements FileUploadStrategy { @Override public void uploadFile(MultipartFile file) { // 实现云端文件上传逻辑 } } 2. 创建策略选择器 接下来，创建一个策略选择器，用于根据条件选择合适的上传策略：
@Component public class FileUploadStrategySelector { private final Map&lt;String, FileUploadStrategy&gt; strategies; public FileUploadStrategySelector(List&lt;FileUploadStrategy&gt; strategyList) { this.strategies = strategyList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b524da82ab504c4f217f12f9fb8638b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3defb46c400344529b8a1aadcd66ac5a/" rel="bookmark">
			AOSP 下载编译Linux内核源码，各个发行版本号都有(官方文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 官方文档，不需要科学上网：
构建内核 | Android 开源项目 | Android Open Source Project
查看官方文档不需要科学上网，但是下载内核源码需要；
如果没办法科学上网可以通过清华源下载：
git clone https://aosp.tuna.tsinghua.edu.cn/android/kernel/goldfish.git cd goldfish #查看分支 git branch -a git checkout android-goldfish-4.14-gchips 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49245d9c0f8e7611a6666936a9d3e241/" rel="bookmark">
			Java 将PDF 转为图片 工具 【Free Spire.PDF for Java】（免费版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 将PDF 转为图片 使用工具：Free Spire.PDF for Java（免费版） Jar文件获取及导入：
方法1：通过官网下载jar文件包。下载后，解压文件，并将lib文件夹下的Spire.Pdf.jar文件导入Java程序。
方法2：可通过maven仓库安装导入。参考导入方法。
&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;com.e-iceblue&lt;/id&gt; &lt;name&gt;e-iceblue&lt;/name&gt; &lt;url&gt;https://repo.e-iceblue.cn/repository/maven-public/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependency&gt; &lt;groupId&gt;e-iceblue&lt;/groupId&gt; &lt;artifactId&gt;spire.pdf.free&lt;/artifactId&gt; &lt;version&gt;5.1.0&lt;/version&gt; &lt;/dependency&gt; Java代码示例 public class PdfToImageExample { public static void main(String[] args) { //程序的逻辑代码 String pdfFilePath = "D:\\Users\\65720\\Desktop\\电信项目-方案\\文艺\\勇罕\\勇罕\\勇罕 2022年 第 4 期.pdf"; // 替换为您的PDF文件路径 String outputImagePath = "D:\\Users\\65720\\Desktop\\电信项目-方案\\文艺\\book\\fc5484fd24b72fb25bd57adf57138d3d\\"; // 保存为PNG格式的图片路径 spirePdfFree(pdfFilePath, outputImagePath); } private static void spirePdfFree(String pdfFilePath, String outputImagePath) { try { PdfDocument pdf = new PdfDocument(pdfFilePath); BufferedImage image; for (int i = 0; i &lt; pdf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49245d9c0f8e7611a6666936a9d3e241/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/125a1f5d8642fb948d408582b6591005/" rel="bookmark">
			特殊的bug：element 0 of tensors does not require grad and does not have a grad_fn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多帖子都说了，设置requires_grad_()就行。
但是我这次遇到的不一样，设置了都不行。
我是这种情况，在前面设置了torch.no_grad():，又在这个的作用域下进行了requires_grad_()，这是不起作用的。
简单版：
with torch.no_grad(): model.eval() pos_embed = model(homo_data.x, homo_data.edge_index) .... pos_embed.requires_grad_()# 不起作用 .... 这样子直接看，傻瓜都不会犯错。而我这个就比较隐蔽了。。。
我的：
# file1.py with torch.no_grad(): pos_embed = model(homo_data.x, homo_data.edge_index) ... fun_A(pos_embed) ... # file2.py def fun_A(x): ... fun_B(x) ... # file3.py def fun_B(x): ... x.requires_grad_() # 由于x是在torch.no_grad中传过来的，所以不起作用 ... 就这样一直会报错element 0 of tensors does not require grad and does not have a grad_fn。
太坑了。
大家引以为鉴，看看出现这个情况没。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca0d57af53c83cf411f254da2f2c498a/" rel="bookmark">
			Android保存WebView HTML源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import android.content.Context; import android.util.Log; import com.example.MyApplication; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStreamWriter; public class JavascriptInterface { @android.webkit.JavascriptInterface public void onReceivedSource(String source) { Log.d("WebViewSource", source); saveHtmlToFile(source, "saveFile"); } private void saveHtmlToFile(String htmlContent, String fileName) { try { // 获取应用的 data 目录 Context context = MyApplication.getContext(); String filePath = context.getFilesDir().getPath() + "/" + fileName; // 使用 FileOutputStream 和 OutputStreamWriter 将 HTML 写入文件 FileOutputStream fileOutputStream = new FileOutputStream(filePath); OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream); outputStreamWriter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca0d57af53c83cf411f254da2f2c498a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb1259f153061503384b5733227f08f5/" rel="bookmark">
			给软件行业带来了春天——揭秘Spring究竟是何方神圣（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 给软件行业带来了春天——揭秘Spring究竟是何方神圣（一）
给软件行业带来了春天——揭秘Spring究竟是何方神圣（二）
给软件行业带来了春天——揭秘Spring究竟是何方神圣（三）
给软件行业带来了春天——揭秘Spring究竟是何方神圣（四）
给软件行业带来了春天——揭秘Spring究竟是何方神圣（五）
文章目录 系列文章目录简介Spring核心知识点SpringIOC创建对象方法一：调用无参数构造器创建对象方法二：调用有参构造方法来创建对象方法三：使用静态工厂方法创建对象方法四：使用实例工厂方法来创建对象方法五：使用实例工厂创建对象 DI依赖注入基于对象属性set方法进行注入利用构造器方式进行注入p名称空间注入集合类型属性注入util标签注入 bean的常见属性作用域生命周期自动装配 SpringBean的注解形式 简介 Spring是一个JavaEE开源的轻量级别的框架，可以解决我们企业开发中遇到的难题，能够让编码变的更加简单，核心组件IOC容器和Aop面向切面编程。 spring优点：
方便解耦，简化开发管理对象集成其他框架Junit单元测试方便进行事务操作降低API开发难度 spring框架图
Spring 是模块化的。
Core 容器
Core 容器由 Core、Beans、Context 和 Expression Language 模块组成。
Core 模块提供了框架的基本部分，包括 IoC 和依赖注入功能。Bean 模块提供了 BeanFactory，它是工厂模式的一个复杂的实现。Context 模块建立在 Core 和 Beans 模块提供的坚实基础之上，它是访问任何已定义和配置的对象的媒介。 ApplicationContext 接口是上下文模块的焦点。SpEL 模块提供了一种强大的表达式语言，用于在运行时查询和操作对象图。 数据访问/集成
数据访问/集成层由 JDBC、ORM、OXM、JMS 和 Transaction 事务模块组成。
JDBC 模块提供了一个 JDBC 抽象层，它消除了繁琐的 JDBC 相关编码的需要。ORM 模块为流行的对象关系映射 API 提供集成层，包括 JPA、JDO、Hibernate 和 iBatis。OXM 模块提供了一个抽象层，它支持 JAXB、Castor、XMLBeans、JiBX 和 XStream 的 Object/XML 映射实现。Java 消息传递服务 JMS 模块包含用于生成和使用消息的功能。Transaction 模块支持对实现特殊接口的类和所有 POJO 的编程和声明式事务管理。 Web
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb1259f153061503384b5733227f08f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0035378714484a26c548efddf812cfc2/" rel="bookmark">
			给软件行业带来了春天——揭秘Spring究竟是何方神圣（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 给软件行业带来了春天——揭秘Spring究竟是何方神圣（一）
给软件行业带来了春天——揭秘Spring究竟是何方神圣（二）
给软件行业带来了春天——揭秘Spring究竟是何方神圣（三）
给软件行业带来了春天——揭秘Spring究竟是何方神圣（四）
给软件行业带来了春天——揭秘Spring究竟是何方神圣（五）
文章目录 系列文章目录AOP简介AOP底层原理JDK动态代理Cglib代理 Aop术语Aop实现 AOP简介 AOP（Aspect Oriented Programming） 意为：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。通俗表示：不通过修改源代码方式，在主干功能中添加新的功能。
eg:登录功能和权限判断可以分离，权限判断的功能的有无不影响登录功能。
AOP底层原理 AOP：面向切面编程，一种编程思想。
AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码的编写方式（性能监视、事务管理、安全检查、缓存,日志记录等）。
AOP就是要对目标进行代理对象的创建，AOP底层使用动态代理的：JDK动态代理和CGLIB动态代理。
动态代理和静态代理区别？
动态代理：在虚拟机内部，运行的时候，动态生成代理类(运行时生成，runtime生成) ，并不是真正存在的类。
静态代理：存在代理类 （例如：struts2 Action的代理类 ActionProxy）
简单来说：有接口，实现接口的类对象，无接口，继承类，创建子对象。
JDK动态代理 JDK动态代理：基于接口的代理，一定是基于接口，会生成目标对象的接口类型的子对象。
JDK动态代理的一般步骤如下：
1.创建被代理的接口和类；
2.实现InvocationHandler接口，对目标接口中声明的所有方法进行统一处理；
3.调用Proxy的静态方法，创建代理类并生成相应的代理对象；
实现原理：利用拦截器机制必须实现InvocationHandler接口中的invoke方法实现对我们的目标方法增强。
public class jdkproxy { public static void main(String[] args){ //创建接口实现类的代理对象 Class[] interfaces={UserDao.class}; /* proxy实现 调用newProxyInstance 方法 public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) {} 返回 指定接口的代理类的实例， 三个参数： 1.类的加载器 2.增强方法所在的类，这个类实现的接口，支持多个接口，。 3.实现这个接口InvocationHandler，创建代理对象，写增强的部分 */ UserDaoImpl userDao=new UserDaoImpl(); UserDao userDao1=(UserDao) Proxy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0035378714484a26c548efddf812cfc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a8db6789cb63fa49478bb16bee2f760/" rel="bookmark">
			给软件行业带来了春天——揭秘Spring究竟是何方神圣（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 给软件行业带来了春天——揭秘Spring究竟是何方神圣（一）
给软件行业带来了春天——揭秘Spring究竟是何方神圣（二）
给软件行业带来了春天——揭秘Spring究竟是何方神圣（三）
给软件行业带来了春天——揭秘Spring究竟是何方神圣（四）
给软件行业带来了春天——揭秘Spring究竟是何方神圣（五）
文章目录 系列文章目录Webflux简介响应式编程使用 Webflux 简介 webflux是spring推出的响应式web框架，它的对标产品为spring-mvc, 与传统的spring-mvc相比较，webflux是完全非阻塞式的。
Webflux 特点：
第一 非阻塞式：在有限资源下，提高系统吞吐量和伸缩性，以 Reactor 为基础实现响应式编程。
第二 函数式编程：Spring5 框架基于 java8，Webflux 使用 Java8 函数式编程方式实现路由请求。
同步与异步，阻塞与非阻塞
同步：调用者发送请求，一直等待回应再去做其他的事情。
异步，调用者发送请求，不等对方回应就去做其他事情。
阻塞，被调用者受到请求之后，做完请求任务之后才给出反馈
非阻塞，被调用者受到请求之后，马上给出反馈再去做事情。
响应式编程 响应式编程是一种编程示例，可促进异步，非阻塞，事件驱动的数据处理方法。 响应式编程涉及将数据和事件建模为可观察的数据流，并实现数据处理例程以对这些流中的更改做出反应。
响应式编程可以理解为，当某一主题发生改变时，观察此主题的观察者就会立刻收到通知并做出一系列相应。
举个例子，在一个数据系统中，如果数据发生了变化，就会触发相应一系列的变化，数据改变，数据访问层发生变化，业务逻辑层发生变化 ，控制器发生变化，UI也做出相应的变化。
观察者模式
public class Observe extends Observable { public static void main(String[] args){ Observe observe=new Observe(); /* * 响应式编程 * */ //添加观察者 observe.addObserver((o,arg)-&gt;{ System.out.println("实施改变"); }); observe.addObserver((o,arg)-&gt;{ System.out.println("接受通知，准备改变"); }); observe.setChanged();//数据变化 observe.notifyObservers();//通知 } } SpringWebflux 基于 Reactor，默认使用容器是 Netty，Netty 是高性能的 NIO 框架，异步非阻塞的框架。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a8db6789cb63fa49478bb16bee2f760/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fbef62395f2bd2b70ae44641c57fd9a/" rel="bookmark">
			Android apk安装包反编译——jadx工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 jadx 是一款功能强大的反编译工具，使用起来简单方便（拖拽式操作），不光提供了命令行程序，还提供了 GUI 程序。一般情况下，我们直接使用 GUI 程序就可以了
jadx 支持 Windows、Linux、 macOS，能够帮我们打开 .apk, .dex, .jar, .zip , .class 等格式的文件
下载 使用 jadx 需要先安装 jdk ，jdk 版本需要大于等于11，这里推荐 安装 jdk17。
然后 jadx发行下载页面 下载 jadx，我这里下载的是 jadx-gui-1.4.7-no-jre-win.exe ，下载后双击便可运行。
反编译jar包 就比如说我们需要反编译一个 jar 包查看其源码的话，直接将 jar 包拖入到 jadx 中就可以了。效果如下：
反编译apk文件 再比如说我们想看看某个 apk 的源码，我们拿到 apk 之后直接拖入进 jadx 中就可以了。效果如下：
反混淆 一般情况下，为了项目的安全，我们在打包发布一个 apk 之前都会对其代码进行混淆加密比如用无意义的短变量去重命名类、变量、方法，以免代码被轻易破解泄露。经过混淆的代码在功能上是没有变化的，但是去掉了部分名称中的语义信息。为了代码的易读性，我们可以对代码进行反混淆。
在 jadx 中，我们通过 Tools -&gt; Deobfuscation 即可开启反混淆功能
反混淆后：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05c4269cfc00c8e42e158ae82b6c3a2f/" rel="bookmark">
			.net core 表达式树Expression代码定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表达式树是一种数据结构，它将代码表达式表示为可以在运行时修改和执行的层次结构。
我们通常在LINQ中使用表达式树来主动地将查询转换为针对各种数据源的可执行格式。翻译过程包括将查询表达式的声明性语法转换为一系列方法调用。
我们还可以在需要使用运行时代码生成和操作的场景中使用表达式树，比如构建动态查询。
通常，我们使用c#中的Expression类创建表达式树。它包含一组静态方法，可用于创建各种表达式，包括算术表达式、逻辑表达式、比较表达式和方法调用表达式。
安装ExpressionTreeToString
这是用来可视化表达式树定义一个表达式树 using ExpressionTreeToString; using System.Linq.Expressions; Expression&lt;Func&lt;People, bool&gt;&gt; expression = b =&gt; b.Name == "ellis"; Console.WriteLine(expression.ToString("Object notation","C#")); Console.WriteLine("Hello, World!"); class People { public int Id { get; set; } public string Name { get; set; } } 3. 使用代码生成表达式树
// See https://aka.ms/new-console-template for more information using ExpressionTreeToString; using System.Linq.Expressions; Expression&lt;Func&lt;People, bool&gt;&gt; expression = p =&gt; p.Name == "ellis"; ParameterExpression parameterExpression = Expression.Parameter(typeof(People), "p"); MemberExpression memberExpression = Expression.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05c4269cfc00c8e42e158ae82b6c3a2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7b1e531c5d595b670713c2f5607c945/" rel="bookmark">
			云上安全责任共担模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于传统自建物理服务器模式，用户需要承担所有的安全责任，负责从物理基础设施到上层应用的所有层面的安全体系构建。
云服务器的安全责任确实与物理服务器不同，云上的安全性是一种责任共担模式，其中云服务器ECS的安全责任需要你（用户）与阿里云（云服务提供商）双方一起承担。
云上安全责任共担模型
用户与阿里云双方的责任内容和边界如下：
阿里云（云服务提供商）负责云服务器ECS底层软硬件设施的安全性，包括物理设备的安全性，虚拟化服务的安全性，数据安全以及合规方面的安全性。
用户负责ECS实例内的安全性，包括实例的操作系统本身的安全性、以及操作系统内应用程序、数据等的安全性。为了提升ECS实例内的安全性，推荐用户需要及时更新操作系统补丁、通过快照定期备份云盘中的重要数据、设置合理的安全组访问规则和RAM访问控制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cea86fbea029d795a7bcd1307fc1a1c1/" rel="bookmark">
			AI赋能金融创新：ChatGPT引领量化交易新时代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、引言二、ChatGPT与量化交易的融合三、实践应用：ChatGPT在量化交易中的成功案例四、挑战与前景五、结论《AI时代Python量化交易实战：ChatGPT让量化交易插上翅膀》📚→ [当当](http://product.dangdang.com/29658180.html) | [京东](https://item.jd.com/14297538.html)亮点内容简介作者简介目录获取方式 一、引言 随着人工智能技术的不断进步，金融领域也经历着一场技术革命。量化交易，作为金融领域的一大分支，正逐渐受到AI技术的深刻影响。特别是近年来，ChatGPT等自然语言处理技术的崛起，为量化交易带来了前所未有的机遇。本文将深入探讨ChatGPT如何助力量化交易，以及这一结合所带来的挑战与前景。
二、ChatGPT与量化交易的融合 数据挖掘与信息处理：ChatGPT能够从海量的金融文本数据中提取有价值的信息，帮助量化交易者更准确地把握市场动态。策略开发与优化：基于ChatGPT的自然语言生成能力，交易者可以快速地测试和验证交易策略，提高策略开发效率。风险管理：ChatGPT能够识别和分析市场情绪、舆论趋势等，为风险管理提供有力支持。 三、实践应用：ChatGPT在量化交易中的成功案例 情感分析驱动的交易策略：利用ChatGPT分析社交媒体上的情感倾向，进而预测市场走势并制定相应的交易策略。新闻事件驱动的交易策略：通过ChatGPT实时解析新闻事件，捕捉市场反应并快速作出交易决策。智能投顾与客户服务：ChatGPT可以作为智能投顾，为客户提供个性化的投资建议和风险管理方案。 四、挑战与前景 数据安全与隐私保护：在使用ChatGPT处理金融数据时，如何确保数据安全和隐私保护是一个亟待解决的问题。技术成熟度与可靠性：目前ChatGPT在处理复杂金融问题时的准确性和稳定性仍需进一步提高。监管与合规：随着AI技术在金融领域的广泛应用，相关监管政策也需要不断完善以适应新技术的发展。 五、结论 ChatGPT等自然语言处理技术的兴起为量化交易带来了无限的可能。它们不仅提高了数据处理和策略开发的效率，还为风险管理和客户服务等领域注入了新的活力。然而，随着技术的不断进步和应用范围的扩大，我们也必须正视其中存在的挑战和问题，如数据安全、技术成熟度和监管合规等。通过不断地研究和探索，我们相信在未来，ChatGPT等AI技术将在量化交易领域发挥更加重要的作用，推动金融行业朝着更加智能化、高效化的方向发展。
《AI时代Python量化交易实战：ChatGPT让量化交易插上翅膀》📚→ 当当 | 京东 C h a t G P T 让量化交易师率飞起来！ ChatGPT让量化交易师率飞起来！ ChatGPT让量化交易师率飞起来！
金融量化交易新模式
一本专注于帮助交易师在AI时代实现晋级、提高效率的图书
书中介绍了如何使用 ChatGPT 来完成量化交易的各个环节
并通过实战案例展示了ChatGPT在实际量化交易中的应用方法
亮点 量化交易新模式：让量化交易更高效、更快捷、更完美。全流程解析：涵盖量化交易的不同应用场景，介绍从发量化交易Python语言基础、工具库、可视化库、数据采集与分析，再到量化交易、套利策略等关键环节。实战检验：ChatGPT结合多种量化交易工具及案例实操讲解，理解更加透彻。100%提高量化交易效率：揭秘ChatGPT与量化交易高效融合的核心方法论和实践经验。赠送资源：赠送教学视频及配套工具，供读者下载学习。 内容简介 本书是一本旨在帮助架构师在人工智能时代展翅高飞的实用指南。全书以ChatGPT为核心工具，揭示了人工智能技术对架构师的角色和职责进行颠覆和重塑的关键点。本书通过共计 13 章的系统内容，深入探讨AI技术在架构
设计中的应用，以及AI对传统架构师工作方式的影响。通过学习，读者将了解如何利用ChatGPT这一强大的智能辅助工具，提升架构师的工作效率和创造力。
本书的读者主要是架构师及相关从业人员。无论你是初入职场的新手架构师还是经验丰富的专业人士，本书都将成为你的指南，帮助你在人工智能时代展现卓越的架构设计能力。通过本书的指导，你将学习如何运用ChatGPT等工具和技术，以创新的方式构建高效、可靠、可扩展的软件架构。
同时，本书也适用于对架构设计感兴趣的其他技术类从业人员，如软件工程师、系统分析师、技术顾问等。通过学习本书的内容，你可以深入了解人工智能对架构设计的影响和带来的挑战，拓展自己的技术视野，提升对软件系统整体架构的理解和把握能力。
作者简介 关东升，一个在IT领域摸爬滚打20多年的老程序员、知名培训专家、畅销书作家，精通多种信息技术。曾参与设计和开发北京市公交一卡通系统、国家农产品追溯系统、金融系统微博等移动客户端项目，并在App Store发布多款游戏和应用软件。长期为中国移动、中国联通、中国南方航空、中国工商银行和天津港务局等企事业单位提供培训服务。先后出版了50多部IT图书，广受读者欢迎。
韩文锋，计算机专业本科，工程师，智慧农业和期货交易领域专家。擅长农业信息技术和期货交易风险管理，熟练使用Python、Java等编程语言。曾参与国家农产品溯源系统设计，利用区块链技术追溯农产品质量安全；主导开发iPad和Android客户端，实现消费者扫码查验源头信息。长期从事期货交易系统开发，掌握交易策略模型。利用机器学习算法，开发大豆期货交易分析系统，支持农业生产者规避市场风险。
目录 第1章ChatGPT、Python和量化交易概述 1.1 ChatGPT的应用领域2 1.2 Python编程在量化交易中的重要性和优势2 1.3 ChatGPT、Python和量化交易的结合价值和应用前景3 1.4 本章总结4 第2章 量化交易Python语言基础 2.1 Python解释器6 2.2 IDE工具7 2.2.1 安装Jupyter Notebook8 2.2.2 启动Jupyter Notebook9 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cea86fbea029d795a7bcd1307fc1a1c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c859cc85db9cd285507ba9c7d6ac076/" rel="bookmark">
			[SWPUCTF 2021 新生赛]error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[SWPUCTF 2021 新生赛]error wp 信息搜集 查看页面：
输个单引号会报错：
显然是 SQL 注入。
提示看看有没有什么捷径，你要说捷径的话，sqlmap？你不说我也会用 sqlmap 先跑一下，哈哈。
sqlmap 的使用 先简单测试一下看能不能跑出来： sqlmap -u "http://node4.anna.nssctf.cn:28069/index.php?id=1" --batch -u URL, --url=URL Target URL (e.g. “http://www.site.com/vuln.php?id=1”) （指定 URL）
–batch Never ask for user input, use the default behavior （不再询问，默认执行）
返回结果：
sqlmap identified the following injection point(s) with a total of 223 HTTP(s) requests: Parameter: id (GET) Type: boolean-based blind Title: AND boolean-based blind - WHERE or HAVING clause Payload: id=1' AND 1142=1142 AND 'Bbac'='Bbac Type: error-based Title: MySQL &gt;= 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c859cc85db9cd285507ba9c7d6ac076/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fac136ebc08f6585ea6245dffea5cd73/" rel="bookmark">
			【MIMO 从入门到精通】[P5]【What is Least Squares Estimation】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
本章详细介绍一下MIMO 中MSE 译码器原理
向量 代表每根天线发送的数据
向量 代表每根天线实际收到的数据
矩阵 代表接收和发送天线之间的传播信道，这个通过信道估计是一个已知值
我们通过接收到的y 如何还原出原始的发送信号 MSE 模型：
要找到, 我们实际测量到的y 要和 模型预测到的 偏差最小，
忽略噪声：
对求微分：
所有这个模型有两个限制：
1： 噪声特别小
2： 可逆，有的时候会使用L2正规化，保证可逆增加模型的泛化性。
参考：
Iain Explains Signals, Systems, and Digital Comms
Explains Least Squares (LS) Estimation with two examples:
1. line-fitting a data set, and
2. digital communications. Derives the LS equation and shows how it can be viewed as a pseudo inverse.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4831e68571015db19e1028e0834fb17/" rel="bookmark">
			12月25日作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		串口发送控制命令，实现一些外设LED 风扇
uart4.c
#include "uart4.h" void uart4_config() { //1.使能GPIOB\GPIOG\UART4外设时钟 RCC-&gt;MP_AHB4ENSETR |= (0x1 &lt;&lt; 1); RCC-&gt;MP_AHB4ENSETR |= (0x1 &lt;&lt; 6); RCC-&gt;MP_APB1ENSETR |= (0x1 &lt;&lt; 16); //=============================================== //led时钟使能 RCC-&gt;MP_AHB4ENSETR |= (0x3 &lt;&lt; 4); //设置PE10输出 GPIOE-&gt;MODER &amp;= (~(0x3&lt;&lt;20)); GPIOE-&gt;MODER |= (0x1&lt;&lt;20); //设置PE10为推晚输出 GPIOE-&gt;OTYPER &amp;= (~(0x1&lt;&lt;10)); //PE10为低速输出 GPIOE-&gt;OSPEEDR &amp;= (~(0x1&lt;&lt;10)); //设置无上拉下拉 GPIOE-&gt;PUPDR &amp;= (~(0x3&lt;&lt;20)); //=============================================== //设置PE9输出 GPIOE-&gt;MODER &amp;= (~(0x3&lt;&lt;18)); GPIOE-&gt;MODER |= (0x1&lt;&lt;18); //设置PE10为推晚输出 GPIOE-&gt;OTYPER &amp;= (~(0x1&lt;&lt;18)); //PE9为低速输出 GPIOE-&gt;OSPEEDR &amp;= (~(0x1&lt;&lt;18)); //设置无上拉下拉 GPIOE-&gt;PUPDR &amp;= (~(0x3&lt;&lt;18)); //=============================================== //2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4831e68571015db19e1028e0834fb17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa71d73666fa2eb848b5b86ba0d68a0/" rel="bookmark">
			基于大语言模型LangChain框架：知识库问答系统实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT 所取得的巨大成功，使得越来越多的开发者希望利用 OpenAI 提供的 API 或私有化模型开发基于大语言模型的应用程序。然而，即使大语言模型的调用相对简单，仍需要完成大量的定制开发工作，包括 API 集成、交互逻辑、数据存储等。
为了解决这个问题，从 2022 年开始，多家机构和个人陆续推出了大量开源项目，帮助开发者快速创建基于大语言模型的端到端应用程序或流程，其中较为著名的是 LangChain 框架。
LangChain 框架是一种利用大语言模型的能力开发各种下游应用的开源框架，旨在为各种大语言模型应用提供通用接口，简化大语言模型应用的开发难度。它可以实现数据感知和环境交互，即能够使语言模型与其他数据源连接起来，并允许语言模型与其环境进行交互。本文将重点介绍 LangChain 框架的核心模块，以及使用 LangChain 框架搭建知识库问答系统的实践。
LangChain框架核心模块
使用 LangChain 框架的核心目标是连接多种大语言模型（如 ChatGPT、LLaMA 等）和外部资源（如 Google、Wikipedia、Notion 及 Wolfram 等），提供抽象组件和工具以在文本输入和输出之间进行接口处理。大语言模型和组件通过“链（Chain）”连接，使得开发人员可以快速开发原型系统和应用程序。LangChain 的主要价值体现在以下几个方面。
（1）组件化：LangChain 框架提供了用于处理大语言模型的抽象组件，以及每个抽象组件的一系列实现。这些组件具有模块化设计，易于使用，无论是否使用 LangChain 框架的其他部分，都可以方便地使用这些组件。
（2）现成的链式组装：LangChain 框架提供了一些现成的链式组装，用于完成特定的高级任务。这些现成的链式组装使得入门变得更加容易。对于更复杂的应用程序，LangChain 框架也支持自定义现有链式组装或构建新的链式组装。
（3）简化开发难度：通过提供组件化和现成的链式组装，LangChain 框架可以大大简化大语言模型应用的开发难度。开发人员可以更专注于业务逻辑，而无须花费大量时间和精力处理底层技术细节。
LangChain 提供了以下 6 种标准化、可扩展的接口，并且可以外部集成：模型输入/输出（Model I/O），与大语言模型交互的接口；数据连接（Data connection），与特定应用程序的数据进行交互的接口；链（Chain），用于复杂应用的调用序列；记忆（Memory），用于在链的多次运行之间持久化应用程序状态；智能体（Agent），语言模型作为推理器决定要执行的动作序列；回调（Callback），用于记录和流式传输任何链式组装的中间步骤。
知识库问答系统实践
大语言模型虽然可以很好地回答很多领域的各种问题，但是由于其知识是通过语言模型训练及指令微调等方式注入模型参数中的，因此针对本地知识库中的内容，大语言模型很难通过此前的方式有效地进行学习。通过 LangChain 框架，可以有效地融合本地知识库内容与大语言模型的知识问答能力。
基于 LangChain 的知识库问答系统框架如下图所示。
知识库问答系统的工作流程主要包含以下几个步骤。
（1）收集领域知识数据构造知识库，这些数据应当能够尽可能地全面覆盖问答需求。
（2）对知识库中的非结构数据进行文本提取和文本分割，得到文本块。
（3）利用嵌入向量表示模型给出文本块的嵌入表示，并利用向量数据库进行保存。
（4）根据用户输入信息的嵌入表示，通过向量数据库检索得到最相关的文本片段，将提示词模板与用户提交问题及历史消息合并输入大语言模型。
（5）将大语言模型结果返回给用户。
上述过程的代码示例如下：
from langchain.document_loaders import DirectoryLoader
from langchain.embeddings.openai import OpenAIEmbeddings
from langchain.text_splitter import CharacterTextSplitter
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aa71d73666fa2eb848b5b86ba0d68a0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/18/">«</a>
	<span class="pagination__item pagination__item--current">19/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/20/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>