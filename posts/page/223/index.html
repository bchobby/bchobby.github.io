<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/328adb55b4495dc1cdef068096703a44/" rel="bookmark">
			Nginx结合Lua——Nginx通过Lua&#43;Redis实现自动封禁访问频率高的IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 实验背景实验一、安装使用 OpenResty二、安装Redis三、在Nginx中使用Lua脚本访问Redis四、Nginx+Lua+Redis 实验背景 为了防止某恶意用户多次对服务器端口进行攻击，我们需要建立一个动态的 IP 黑名单。对于黑名单之内的 IP ，拒绝提供服务。
实现 IP 黑名单的功能有很多途径：
在操作系统层面，配置 iptables，拒绝指定 IP 的网络请求；在 Web Server 层面，通过 Nginx 自身的 deny 选项 或者 lua 插件 配置 IP 黑名单；在应用层面，在请求服务之前检查一遍客户端 IP 是否在黑名单。 为了方便管理和共享，我们通过 Nginx+Lua+Redis 的架构实现 IP 黑名单的功能，架构图如下：
实验 一、安装使用 OpenResty OpenResty是一个集成了各种 Lua 模块的 Nginx 服务器，是一个以Nginx为核心同时包含很多第三方模块的Web应用服务器，使用Nginx的同时又能使用lua等模块实现复杂的控制
1、安装OpenResty
[root@server1 local]# yum -y install readline-devel pcre-devel openssl-devel gcc 2、下载openresty-1.13.6.1.tar.gz 源码包，并解压；下载ngx_cache_purge模块，该模块用于清理nginx缓存；下载nginx_upstream_check_module模块，该模块用于ustream健康检查
[root@server1 ~]# cd /usr/local [root@server1 local]# wget https://openresty.org/download/openresty-1.13.6.1.tar.gz [root@server1 local]# tar -zxvf openresty-1.13.6.1.tar.gz [root@server1 local]# cd openresty-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/328adb55b4495dc1cdef068096703a44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fe6a88c1f93216cfd5e1a70f90118c7/" rel="bookmark">
			TeamViewer可免费用于个人用途，但所使用的设备数量受限。您已达到设备数量上限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		登陆teamviewer网站，登陆账号后点击右上角的头像--&gt;编辑配置文件 进入可信设备界面，删除多余的可信设备 进入免费设备界面，解绑多余的设备即可 若免费设备无法更换（已达到更换次数），可以删除账号，重新注册。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8075ab16cd3f556bb232968467441036/" rel="bookmark">
			git查看某个文件的修改历史
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候在比对代码时，看到某些改动，但不清楚这个改动的作者和原因，也不知道对应的BUG号，也就是说无从查到这些改动的具体原因了～
【注】：某个文件的改动是有限次的，而且每次代码修改的提交都会有commit描述，我们可以从这里进行入手；
一、切换到目录
首先切换到要查看的文件所在的目录：
cd packages/apps/Mms/src/com/android/mms/ui/ 二、git log --pretty
然后使用下面的命令可列出文件的所有改动历史，注意，这里着眼于具体的一个文件，而不是git库，如果是库，那改动可多了去了～
git log --pretty=oneline 文件名 如：
root@ubuntu:android_src/packages/apps/Mms/src/com/android/mms/ui# git log --pretty=oneline MessageItem.java 27209385caf678abe878375a470f4edd67a2d806 fix to process force close when empty address contained in card 0e04b16f1dad7dc0a36e2235f7337bc656c365c7 display for 1970-1-1 e4abf3a213197491e0855e101117b59b5dc0160d HREF#13954 receive, store, and display wap push 356f6def9d3fb7f3b9032ff5aa4b9110d4cca87e HREF#16265_uim_show_time_error 350f9d34c35ab50bdb4b2d43fb3ff9780e6c73fa fix xxxx 715e32f97bd9d8ce4b5ba650b97ba4b137150456 Fix ANR from calling Contact.get() fd8357ff5febab0141e1beb8dd3b26f70416b108 Fix missing From field d130e2e6dc448fd80ecb70f0d31e3affb9888b9a fix bug 2112925: don't display zip file garbage content in MMS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8075ab16cd3f556bb232968467441036/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69c9b6ef39b78e8c0e37319d6a6bf34c/" rel="bookmark">
			求完数及其因子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在这里插入代码片 #include&lt;stdio.h&gt; int main() { double i,x;//	i是10000以内某个数 ，x用来求因子 int a,b;//	b是因子，a是因子相加 for(i=2;i&lt;=1000;i++)	{ for(x=1,a=0;x&lt;=i;x++) { if(int(i/x)==i/x&amp;&amp;i/x!=i)	// 判断i/x是不是整数 { b=i/x;	// 若i/x=b是个整数，则b就是i的其中一个因子 a+=b;	}	} if(a==i)	//判断是不是完数 { printf("%.0lf its factors are ",i);	for(x=1,a=0;x&lt;=i;x++) { if(int(i/x)==i/x&amp;&amp;i/x!=i) { b=i/x; printf("%d,",b); }	} printf("\n"); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67e1da7f422c02f8c9a00e2dea69470b/" rel="bookmark">
			python利用嵌套循环打印九九乘法表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python利用嵌套循环使用for-for打印九九乘法表（下三角、上三角，九宫格） 1.end=" "：末尾不换行，加空格（python中print默认是打印 一行）
2.\t:横向制表符
下三角 for i in range(10):
for j in range(i+1):
print("%d*%d=%d\t" % (i,j,i*j),end="")
print()
效果图如下：
上三角 for i in range(1,10):
for k in range(1,i):
print(end=" “)
for j in range(i,10):
print(”%d*%d=%2d" % (i,j,i*j),end=" “)
print(”")
效果图如下：
九宫格列表 for i in range(1,10):
for j in range(1,10):
print("%d*%d=%d\t" % (i,j,i*j),end=" “)
print(”")
效果图如下:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ed3412067aea6c77ed9039d6a158a9/" rel="bookmark">
			Python numpy Import Error Something is wrong with the numpy installation. an older
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息描述 症状一
ImportError: Something is wrong with the numpy installation.
ImportError: Something is wrong with the numpy installation. While importing we detected an older version of numpy in ['D:\\Anaconda3\\envs\\tensorflow\\lib\\site-packages\\numpy']. One method of fixing this is to repeatedly uninstall numpy until none is found, then reinstall this version. 出现这个报错说明在你安装新的软件，或者更新numpy或者干什么的时候，旧的numpy没有卸载掉，两版numpy导致出现冲突。
症状二
一般这种情况下还会伴随有另一个报错：
UserWarning: loaded more than 1 DLL from .libs 进到信息中指定的.libs文件夹中会发现，确实是多了一个DLL文件，注意，这两个文件有一个你有权限删除，但是另一个你不能删除，因为python正在占用。 报错信息more 在前两个症状下进行下一步检测。
如果在未采取措施时，您卸载python再重新安装，在python的语句中import numpy。您会看到这样的信息：（不想看的主儿往后翻，朕有翻译的）
症状三
&gt;&gt;&gt; import numpy Traceback (most recent call last): File "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4ed3412067aea6c77ed9039d6a158a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f5d1b644a172dcc822182c81cb48317/" rel="bookmark">
			IDEA失去焦点，取消自动编译【已解决】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA失去焦点，取消自动编译（已解决） 项目用热部署的方式部署，然后以Debug方式启动（方便我们在项目执行的过程中调试代码）。具体的热部署方式，网上有很多教程，请自行百度。 但是当我们以Debug方式启动项目以后，我们在编写Java代码的时候，一旦失去焦点项目就会报错，从编译的角度来说这是一个便捷的功能，毕竟能及时发现我们项目的错误，但是从用户的体验角度来说，我个人觉得没有那么友好。所以我建议我们取消这个功能
网上很多热部署的教程都是让我们把这两个选项都设置为Update classes and resources，却没有告诉我们这两个是什么东西，修改的关键也就是在这里。
On Update action：当代码发生改变时，IDEA执行什么操作
Update resource：如果有更新，且更新资源为（xx.jsp，xx.xml，不包括Java文件），就会立即生效
Update classes and resources：如果有更新，且更新资源为（资源文件或Java文件），就会立即生效。在正常运行模式下，修改Java文件也不会立即生效；但是在Debug模式下，就会立即生效。这两种模式下，修改resource资源文件都是可以立即生效的。
Redploy：重新部署项目，把原来的war包（我们的项目是以war包的形式放在Tomcat服务器上的）重新部署
Restart：重新启动服务器（时间最久，不建议使用）
On Frame deactivation：当失去焦点（不停留在IDEA里面），IDEA执行什么操作
Do nothing：不做任何事情（推荐使用）
Update resource：如果有更新，且更新资源为（xx.jsp，xx.xml，不包括Java文件），就会立即生效
Update classes and resource：如果有更新，且更新资源为（资源文件或Java文件），就会立即生效。在正常运行模式下，修改Java文件也不会立即生效；但是在Debug模式下，就会立即生效。这两种模式下，修改resource资源文件都是可以立即生效的。
所以我们只需要把On Frame deactivation，修改为Do nothing即可
设置为Do nothing之后，我们的项目就会不自动编译（在我们没有进行自动编译的设置基础上）。不过我更建议使用手动编译，毕竟也就是点一下的事情，开启自动编译多少还是会耗费计算机性能。开启自动编译的方式，也请自行百度。
Debug启动项目的情况下，可以点击小甲虫图标用于更新我们想要的资源。
但我发现不同版本的IDEA这个小甲虫图标的点击效果不一样，具体操作根据你的IDEA再看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b39afad85b9907209873629b1311fb1/" rel="bookmark">
			DBUtils的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、DBUtils简介二、JDBC的一般性流程三个接口总结 一、DBUtils简介 JDBC即Java数据库连接，而DBUtils为工具类，是为数据库连接提供简便的，因为在连接过程中，会出现代码重复，可读性不好，而工具类就是把这些重复的地方封装起来，对代码进行简化，可读性也会增强。
二、JDBC的一般性流程 加载驱动（Driver Manger）
获得链接（Driver Manger，Connection）
获得执行sql对象（Statement，PreparStatement）
解析结果集（ReslutSet）
释放资源（close()）
在这五个流程中，都可以使用DBUtils来简化代码。
三个接口 三个API（都是接口，主要依靠底层的实现子类）：
org.apache.commons.dbutils.QueryRunner ; 查询器
org.apache.commons.dbutils.ResultSetHandler ; 结果处理器
org.apache.commons.dbutils.Dbutils; 普通工具
QueryRunner: 增删改查 (线程安全)
new QueryRunner(); 它的事务可以手动控制。也就是说此对象调用的方法（如：query、update、batch）参数中要有Connection对象。
new QueryRunner(DataSource ds); 它的事务是自动控制的。一个sql一个事务。此对象调用的方法（如：query、update、batrch）参数中无需Connection对象。
小结:简化了SQL语句
public void testQuery1(){ //之前做法 Connection connection = MyDBUtil.getconnection(); //查看API，QueryRunner的构造方法有4个，2个给Oracle， //其他两个，一个无参，一个参数为DataSource DataSource dataSource = MyDBUtil.getDataSource(); QueryRunner QR = new QueryRunner(dataSource); //查看QueryRunner的成员方法，只需要查看query()的重载方法 //构造方法为一参的有数据源的话，就不用传入connection //构造方法为无参构造方法的话，就要传入connection //查询所有用户，需要返回的是所有User的集合 users = new ArrayList&lt;&gt;(); ArrayList&lt;User&gt; users = QR.query("select * from tt_user;",new ResultSetHandler&lt;ArrayList&lt;User&gt;&gt;(){ @Override public ArrayList&lt;User&gt; handle(ResultSet result){ while(result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b39afad85b9907209873629b1311fb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccec89a9b49d52aa33c98e596cd88248/" rel="bookmark">
			ArcGIS API For Javascript（针对版本4.x）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：
https://www.bilibili.com/video/BV1Mf4y1D7Eb
ArcGIS APl for JavaScript是什么?
用来构建2D和3D地图应用的一套简单、易用的API，具备强大制图能力和基于数据驱动的地图可视化能力，用来构建WebGIS系统。
特性:三维支持更加完善，BIM支持进一步加强
特性:三维与GP服务结合，解决三维世界更多实际问题。
特性:根据用户需求和发展趋势，不断增加和更新功能
特性:数据驱动的可视化，让数据变得更加直观和美观
升级指南 属性: ○例如:
○在3.x中，设置要素图层的definitionExpression看起来类似于:
.myFeatureLayer.setDefinitionExpression(expression);
○在4.0中设置要素图层的definitionExpression，使用如下形式:
.myFeatureLayer.definitionExpression = expression;
o在4.0之前，可以通过调用get MethodName或set MethodName来获取
(读取）或设置（写入）一些属性。由于4.xAPl支持获取和设置所有属性，因此不再需要这些类型的方法。
监听属性变化 在4.0之前，属性更改是通过事件处理的。在4.x中，监听属性变化变得更加容易。4.x版本通过.watch(property,callback)方法处理。每次属性更改时都会调用回调，并允许您获取属性的新值，旧值和名称以及监听对象。
·例如:
每次地图底图的标题发生变化时，都会触发回调。
Views 一、在4.x中，地图可以以2D或3D形式显示。因此，绘图逻辑进行了
修订，Map和Layers不再处理绘图逻辑，而是由Views处理。
二、Views是4.x版本中引入的概念。Views可以是以下两种类型之一:
MapView，适用于2D;
SceneView，适用于3D工作;
三、Views专门用于可视化地图或场景中的数据。地图包含要显示的实际数据或图层，而Views负责显示这些数据。这些数据的可视化或显示方式取决于您是使用2D还是3D。
四、Views具有对地图的引用，例如view.map。但是地图没有对Views的引用。重要的是，多个Views可以使用同一个地图。
Autocasting: Autocasting用于将JavaScript对象转换为ArcGlS APl for JavaScript类类型，而无需使用require()加载这些类。
下面使用示例说明使用Autocasting编程的不同。
Autocasting:
ArcGlS APl for JavaScript将获取传递给构造函数中属性的值，并在内部实例化类型化对象。
Promise 01*
Promise在ArCGIS API for JavaScript中发挥着重要作用。使用promises
可以在处理异步操作时编写更清晰的代码。
02*
Promise通常用于then()。这是一个强大的方法，它定义了在解析promise时调用的回调函数，以及在promise被拒绝时调用的错误函数。第一个参数始终是成功回调，第二个可选参数是错误回调。
03*
使用Promises的一个好处是利用then()将多个Promise链接在一起。回调函数必须使用return关键字将解析值返回到下一个Promise。
someAsyncFunction().then(callback,errorCallback);
重要的API Map Map对象仅仅是个容器，存储了baselayers和operational layers包含的地理相关信息。
Map对象包含一系列属性和方法来存储、管理和叠加图层到2D和3D场景中。
View View为Map对象提供的一种渲染和交互的方式;
View是MapView和SceneView的基类，本身没有构造函数，只能通过MapView或者SceneView来创建实例。
View和Map的关系 实例：GraphicsLayer用于加载图形（点击弹出事件）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccec89a9b49d52aa33c98e596cd88248/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/907aa0d4dc1be8df54393cd9768c05f1/" rel="bookmark">
			三极管
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三个极怎么判定
G极(gate)—栅极，不用说比较好认
S极(source)—源极，不论是P沟道还是N沟道，两根线相交的就是
D极(drain)—漏极，不论是P沟道还是N沟道，是单独引线的那边
N沟道还是P沟道
箭头指向G极的是N沟道
箭头背向G极的是P沟道
寄生二极管方向如何判定
不论N沟道还是P沟道MOS管，中间衬底箭头方向和寄生二极管的箭头方向总是一致的：
要么都由S指向D，要么都有D指向S
MOS开关实现的功能
1&gt;信号切换
2&gt;电压通断
MOS管用作开关时在电路中的连接方法
关键点:
1&gt;确定那一极连接输入端，那一极连接输出端
2&gt;控制极电平为？V 时MOS管导通
3&gt;控制极电平为？V 时MOS管截止
、
NMOS：D极接输入，S极接输出
PMOS：S极接输入，D极接输出
MOS管的开关条件
N沟道—导通时 Ug&gt; Us,Ugs&gt; Ugs(th)时导通
P沟道—导通时 Ug&lt; Us,Ugs&lt; Ugs(th)时导通
总之，导通条件：|Ugs|&gt;|Ugs(th)|
相关概念
BJT
Bipolar Junction Transistor 双极性晶体管，BJT是电流控制器件；
FET
Field Effect Transistor 场效应晶体管，FET是电压控制器件.
按结构场效应管分为：结型场效应（简称JFET）、绝缘栅场效应（简称MOSFET）两大类
按沟道材料：结型和绝缘栅型各分N沟道和P沟道两种.
按导电方式：耗尽型与增强型，结型场效应管均为耗尽型，绝缘栅型场效应管既有耗尽型的，也有增强型的。
总的来说场效应晶体管可分为结场效应晶体管和MOS场效应晶体管，而MOS场效应晶体管又分为N沟耗尽型和增强型；P沟耗尽型和增强型四大类。
MOS管重要参数
①封装
②类型（NMOS、PMOS）
③耐压Vds（器件在断开状态下漏极和源极所能承受的最大的电压）
④饱和电流Id
⑤导通阻抗Rds
⑥栅极阈值电压Vgs(th)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d137ed4c60d794543b5bb0b77274acf4/" rel="bookmark">
			「NOIP2016」蚯蚓
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		description 传送门 solution 因为每次蚯蚓长度的变化是对除去剪断的蚯蚓外，所有蚯蚓同时变化的，所以容易想到用一个大根堆维护所有蚯蚓的长度，每次长度变化改为新产生的蚯蚓长度 − q -q −q但是这样是 O ( m l o g n ) O(mlogn) O(mlogn)的，无法通过本题考虑2个蚯蚓的长度 x x x与 y y y，其中 x x x比 y y y先从堆中取出，故 x ≥ y x\ge y x≥y，那么产生的新蚯蚓长度 ⌊ p x ⌋ ≥ ⌊ p y ⌋ \lfloor px \rfloor\ge\lfloor py \rfloor ⌊px⌋≥⌊py⌋，且 ⌊ ( 1 − p ) x ⌋ ≥ ⌊ ( 1 − p ) y ⌋ \lfloor (1-p)x \rfloor\ge\lfloor (1-p)y \rfloor ⌊(1−p)x⌋≥⌊(1−p)y⌋，所以先产生的第一类蚯蚓一定比后产生的第一类蚯蚓长，先产生的第二类蚯蚓一定比后产生的第二类蚯蚓长所以可以使用三个队列分别维护原有的蚯蚓以及产生的2类蚯蚓，则后2个队列保证单调，接下来只需要让初始的蚯蚓按长度从大到小插入第一个队列，就可以保证每次操作中选中的蚯蚓一定是三个队列队首中最大的一个，就可以 O ( 1 ) O(1) O(1)完成操作了总复杂度 O ( n l o g n + m ) O(nlogn+m) O(nlogn+m) code #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; using namespace std; const int N=1e5+10; int n,m,d,del,u,v,t,a[N]; double p; inline int read(){ int x=0,f=1;char ch=getchar(); while(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d137ed4c60d794543b5bb0b77274acf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/433414b8979739620d3609262beb276b/" rel="bookmark">
			C&#43;&#43;使用sort函数对vector的任意区间排序(某一段元素排序)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用迭代器进行区间指定，注意start和end为前闭后开区间；sort函数内也可自行添加cmp比较函数，默认为从小到大排序。
#include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int main(){ vector&lt;int&gt;input = { 1, 5, 2, 1, 3, 2, 5 }; //排序整个vector //sort(input.begin(), input.end()); //对任意区间进行排序，同样使用迭代器 auto start = input.begin()+2;//下标对应2 auto end = start +3;//下标对应5 sort(start, end);//区间[2，5)进行排序 for (auto itr : input){ cout &lt;&lt; itr &lt;&lt; " "; } cout &lt;&lt; endl; return 0; } 运行结果如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15c83ca4834663aab6f19cfbb0065a8d/" rel="bookmark">
			2020TI省级大学生电子竞赛推荐芯片简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020TI省级大学生电子竞赛推荐芯片简介
2020TI省级大学生电子竞赛芯片 不知道用什么单片机？不知道用什么AD/DA模块，不知道用什么运放，不知道用什么稳压器?
所以官方给了一些推荐的。
我也是第二时间给大家安排上了，每种芯片的半句话简介。
搜了搜，相信对每位参加电赛的同学选择时候会有所启发。
手搜不易，别忘了点赞。
1
MSP430F5529
MSP430F5529-T
具有 128KB 闪存、8KB SRAM、12 位 ADC、比较器、DMA、UART/SPI/I2C、USB 和硬件乘法器的 25MHz MCU
2
MSP432P401R
MSP432P401R-T
具有精密 ADC、256KB 闪存和 64KB RAM 的 SimpleLink™ 超低功耗 32 位 Arm Cortex-M4F MCU
3
ADS1118
ADS1118-T
具有 PGA、振荡器、电压基准、温度传感器和 SPI 的 16 位、860SPS、4 通道 Δ-Σ ADC
4
ADS112C04
ADS112C04-T
具有 PGA、VREF、2 个 IDAC 和 I2C 接口的 16 位 2kSPS 4 通道低功耗小型 Δ-Σ ADC
5
ADS7142
ADS7142-T
具有 1.8V 运行电压并采用 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15c83ca4834663aab6f19cfbb0065a8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e717f98265a10b62d4ee641846587fc9/" rel="bookmark">
			pymysql.err.OperationalError: (1698, “Access denied for user ‘root‘@‘localhost‘“)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 pymysql.err.OperationalError: (1698, “Access denied for user ‘root’@‘localhost’”) $ sudo mysql -u root mysql&gt; USE mysql; mysql&gt; UPDATE user SET plugin='mysql_native_password' WHERE User='root'; mysql&gt; FLUSH PRIVILEGES; mysql&gt; exit; $ service mysql restart 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ce3b42ce09e26dca9e1ecf2bd425c11/" rel="bookmark">
			LOJ#539. 「LibreOJ NOIP Round #1」旅游路线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		description 题面较长，这里给出题目链接 solution 考虑预处理出 f [ i ] [ j ] f[i][j] f[i][j]表示在第 i i i个点加满油后，从第 i i i个点出发，至多消耗 j j j元钱走过的最大路程，那么对于每一个询问就可以二分答案 O ( l o g q ) O(logq) O(logq)查询了可以得出转移方程 f [ i ] [ k ] = max ⁡ ( f [ j ] [ k − p [ j ] ] + g [ i ] [ j ] , f [ i ] [ k ] ) f[i][k]=\max(f[j][k-p[j]]+g[i][j],f[i][k]) f[i][k]=max(f[j][k−p[j]]+g[i][j],f[i][k])，其中 g [ i ] [ j ] g[i][j] g[i][j]表示从在 i i i点加满油后从 i i i走到 j j j能走过的最大路程 g g g可以使用倍增 f l o y d floyd floyd预处理出 h [ k ] [ i ] [ j ] h[k][i][j] h[k][i][j]表示从 i i i走到 j j j,至多走 2 k 2^k 2k步的最长路程后求出。倍增 f l o y d floyd floyd代码： for(int k=1;k&lt;=16;++k){ memcpy(h[k],h[k-1],sizeof(h[k])); for(int w=1;w&lt;=n;++w) for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) if(h[k-1][i][w]&gt;inf&amp;&amp;h[k-1][w][j]) h[k][i][j]=max(h[k][i][j],h[k-1][i][w]+h[k-1][w][j]); } 于是我们就可以 O ( n 3 l o g C ) O(n^3logC) O(n3logC)完成预处理，总时间复杂度 O ( n 3 l o g C + T l o g q ) O(n^3logC+Tlogq) O(n3logC+Tlogq) code #include&lt;bits/stdc++.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ce3b42ce09e26dca9e1ecf2bd425c11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d53294c491f62969c7b249f730beb42f/" rel="bookmark">
			less常见使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 变量 // Variables @link-color: #428bca; // sea blue @link-color-hover: darken(@link-color, 10%); // Usage a, .link { color: @link-color; } a:hover { color: @link-color-hover; } .widget { color: #fff; background: @link-color; } Selectors
v1.4.0
// Variables @my-selector: banner; // Usage .@{my-selector} { font-weight: bold; line-height: 40px; margin: 0 auto; } Compiles to:
.banner { font-weight: bold; line-height: 40px; margin: 0 auto; } URLs
// Variables @images: "../img"; // Usage body { color: #444; background: url("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d53294c491f62969c7b249f730beb42f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f93952fe7c4b650dc74b304a3ebf96f9/" rel="bookmark">
			Python编写简单的计算器，用户输入两个数字和一个四则运算符，计算结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、程序要求 （1）提示用户从键盘输入第一个数字
（2）提示用户从键盘输入第二个数字
（3）提示用户选择运算符
（4）打印结果
二、代码实现 a = int(input("请输入第一个数：")) b = int(input("请输入第二个数：")) symbol = input("请输入四则运算符号：(+-*/)") if symbol == "+": print("%s%s%s=%s"%(a,symbol,b,a+b)) elif symbol == "-": print("%s%s%s=%s"%(a,symbol,b,a-b)) elif symbol == "*": print("%s%s%s=%s"%(a,symbol,b,a*b)) elif symbol == "/": if b == 0: print("除数不能为零") else:print("%s%s%s=%s"%(a,symbol,b,a/b)) else: print("符号输入有误，请重新输入！！！") 三、运行结果图 加法：
乘法：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daee4cc5aa540ba819de96c9a964a11a/" rel="bookmark">
			Quartus Prime基本使用方法及仿真遇到的错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Quartus Prime基本使用方法 前言1. 电路图2.VHDL/Verilog HDL语言3.自底向上（语言+原理图）4.两种仿真方式 前言 Quartus常用的几种设计方法，电路图、直接使用语言或者两者结合的方法，本文简要介绍三种方法及可能出现的问题以及两种仿真方式。
1. 电路图 这种方式适合门级电路，搭建简易的电路模块。
首先新建Block Diagram/Schematic File
2. 打开新创建的.bdf文件。双击空白处课添加所需门单元以及更大的电路单元。
3. 电路搭建成功后，编译即可。 2.VHDL/Verilog HDL语言 同上，新建VHDL/Verilog HDL文件写相关代码，编译即可 3.自底向上（语言+原理图） 注意：顶层实体名需要与bdf的命名相同用VHDL/Verilog HDL语言编写不同的电路单元，生成符号文件。新建bdf文件，双击，在project中可以发现刚刚创建的电路单元。
4. 将电路单元连线后即可编译。 4.两种仿真方式 直接用Quartus中的仿真 创建University Program VWF文件
打开创建的波形文件，在空白处双击，添加所需观察的节点
点击node Finder，通过list可以显示电路节点
将寻找到的节点移入选择的节点中，点击OK确认
点击OK确认
显示波形文件
通过菜单栏快捷按钮，可置0，置1，设置时钟，选择功能仿真或者时序仿真，出现仿真波形。
可能出现的错误
1 文件路径错误Error (199014): Vector source file F:/quartuslite/Waveform2.vwf specified with --testbench_vector_input_file option does not exist
Error: Quartus Prime EDA Netlist Writer was unsuccessful. 1 error, 1 warning
Error: Peak virtual memory: 4723 megabytes
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daee4cc5aa540ba819de96c9a964a11a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f3f28c3c063df36d8fee197d2a83ed1/" rel="bookmark">
			Linux下安装Bazel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网很详细
Linux版本:
第一步:
sudo apt install curl gnupg curl -fsSL https://bazel.build/bazel-release.pub.gpg | gpg --dearmor &gt; bazel.gpg sudo mv bazel.gpg /etc/apt/trusted.gpg.d/ echo "deb [arch=amd64] https://storage.googleapis.com/bazel-apt stable jdk1.8" | sudo tee /etc/apt/sources.list.d/bazel.list 第二步:
sudo apt update &amp;&amp; sudo apt install bazel 若已安装bazel
sudo apt update &amp;&amp; sudo apt full-upgrade 第三步(非必须)
sudo apt install openjdk-8-jdk 检查bazel是否安装成功:
输入bazel看结果即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b24fc11267f55db97c3112e93badc175/" rel="bookmark">
			source /etc/profile后，新的环境变量只能在一个终端里
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题的提出 我的实验环境是开了一个Ubuntu的虚拟机，想给它配置个代理，由于我想让使用该虚拟机的所有用户都能使用代理，所以我首先切换到root用户，然后进入到/etc/profile.d目录下（至于我为什么不直接修改/etc/profile文件请自行查阅了解），我新建一个proxy.sh文件，使用vim编辑，内容如下:
export proxy="http://192.168.124.6:1080" export http_proxy=$proxy export https_proxy=$proxy export ftp_proxy=$proxy export no_proxy="localhost,127.0.0.1,::1" 然后，以root用户的身份，执行
source /etc/profile 接着我使用
curl www.google.com 发现能够愉快地“出去”。
接着我退出root用户，回到普通用户，发现刚刚的环境变量的设置并未对普通用户有效（也就是说，我的代理对于普通用户来说没有设置成功），于是乎，我立马以普通用户的身份打开一个终端，执行
source /etc/profile 然后也能愉快地“出去”，但是问题是，当以普通用户的身份重新打开一个终端时，先前设置的环境变量已经失效了。
二、解决方案 2.1 重启Ubuntu即可。 2.2 将上述配置写在~/.bashrc中 2.3 在~/.bashrc中最后加入source /etc/profile 三、解决后的思考 3.1 /etc/profile 它是一个文件，不建议修改它里面的内容，它里面的内容默认如下：
# /etc/profile: system-wide .profile file for the Bourne shell (sh(1)) # and Bourne compatible shells (bash(1), ksh(1), ash(1), ...). if [ "${PS1-}" ]; then if [ "${BASH-}" ] &amp;&amp; [ "$BASH" != "/bin/sh" ]; then # The file bash.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b24fc11267f55db97c3112e93badc175/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/630ce3e30a078c2cef06edc2b9f0b86e/" rel="bookmark">
			Android粗浅系统学习（适合入门）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.emperinter.info/2020/10/03/android-study/ AndroidStudy Android系统学习的笔记!系统但并非详细！图片并不能直接上传到文档中，如需了解详情请访问：https://www.emperinter.info/2020/10/03/android-study/
参考视频 可惜没有网络,json,xml等等的教程！还有没有6教程这个有点懵圈，自己在B站上找到出处也是没有的，而且B站有多几个教程！
学习的主要来源：
YouTube（不全） | https://www.youtube.com/watch?v=sehxt5wbsgM&amp;list=PLoDvOw64tSYsWvlxk9aIDOGPVrFQeHull
B站（较全） | https://www.bilibili.com/video/BV1Rt411e76H?p=36
util | 工具类 布局 LinearLayout GridLayout Button,View等 Button 继承自 TextView
EditText 继承自 TextView​
ImageView scaleType | 值 | 含义 |
| :------------: | :------------: |
| fitXY | 撑满控件，宽高比可能发生改变 |
| fitCenter | 保持宽高缩放，直至能够完全显示 |
|centerCrop| 保持宽高比缩放，直至完全覆盖控件，剪裁显示|
网络图片 | 第三方库 ListView | Grid View Adapter 写法
ScrollView 只能有一个子元素
分类 垂直滚动： ScrollView
水平滚动: HorizontalScrollView
RecyclerView（使用较多） 灵活实现大数据集的展示，视图的复用管理比Listview更好，能够显示列表、网格、瀑布流等形式，且不同的ViewHoler能够实现item多元化的功能；
LinearRecyclerView 分隔线；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/630ce3e30a078c2cef06edc2b9f0b86e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d967efa2a055588ba6bb8c658356a9f9/" rel="bookmark">
			论文笔记：AAAI 2019 Hypergraph Neural Networks
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 论文链接：http://gaoyue.org/paper/HGNN.pdf
github：https://github.com/iMoonLab/HGNN
在本文中提出了一个用于数据表示学习的超图神经网络(HGNN)框架，它可以在超图结构中编码高阶数据相关性。面对在实践中学习复杂数据表示的挑战，特别是在处理复杂数据时，超图在数据建模方面更加灵活。该方法设计了超边卷积运算来处理表示学习过程中的数据相关性。通过这种方法，可以有效地利用超边卷积运算来进行传统的超图学习。HGNN能够学习考虑到高阶数据结构的隐含层表示，这是考虑复杂数据相关性的通用框架。我们进行了引文网络分类和视觉对象识别任务的实验，并将HGNN与图卷积网络等传统方法进行了比较。
2. 背景 在现实世界中，复杂的网络关系单纯依靠普通图边的表示有时并不足以很好的阐释，例如在社交网络中推特和微博之间的视觉链接、文字链接、社会性链接。
图1提供了社交媒体数据上的复杂连接示例。
一方面，数据相关性可能比两两关系更复杂，难以用普通图结构建模。另一方面，数据表示往往是多模式的，如本例中的视觉连接、文本连接和社会连接。在这种情况下，传统的图结构在表述数据相关性方面存在局限性，这就限制了图卷积神经网络的应用。在这种情况下，进一步研究更好、更通用的数据结构模型来学习表示就显得尤为重要和迫切。 为了解决这一问题，本文提出了一个超图神经网络(HGNN)框架，该框架使用超图结构进行数据建模。与所有边的度都必须为2(一条边仅连接两个节点，因此普通图中边的度为2)的简单图相比，超图可以使用其无限制的度超边编码高阶数据相关性(超越成对连接)，如图2所示。在图2中，图是用邻接矩阵表示的，其中每条边仅连接两个顶点。相反，超图可以通过其灵活的超边扩展以实现多模态、异构的数据表示。例如，一个超图可以通过合并邻接矩阵，联合使用多模态数据来生成超图，
因此，hypergraph已经被用于许多计算机视觉任务，如分类和检索任务(Gao et al. 2012)。然而，传统的超图学习方法(Zhou, Huang, and Scholkopf 2007)存在计算复杂度高和存储成本高的问题，限制了超图学习方法的广泛应用。
本文提出的HGNN将复杂数据相关性表述为超图结构，并设计了超边卷积操作，以更好地利用高阶数据相关性进行表示学习。更具体地说，HGNN是一个通用框架，它可以合并多模态数据和复杂的数据相关性。传统的图卷积神经网络可以看作是HGNN的一个特例。为了评估提出的HGNN框架的性能，进行了引文网络分类和视觉对象识别任务的实验。在4个数据集上的实验结果以及与图卷积网络(GCN)等传统方法的比较表明，HGNN具有更好的性能。这些结果表明，本文提出的HGNN方法在学习使用高阶复杂关联表示的数据时更加有效。
本文创新点如下：
提出一个超图神经网络框架，即HGNN，用于使用超图结构进行表示学习。HGNN能够通过其超图结构表达复杂的、高阶的数据相关性。并且使用超边卷积操作有效地处理多模态数据/特征。此外，GCN (Kipf和Welling 2017)可以看作是HGNN的一种特殊情况，其简单图中的边可以看作是仅连接两个顶点的2阶超边。该模型在引文网络分类和视觉对象分类任务方面进行了广泛的实验。与最先进的方法的比较证明了所提出的HGNN框架的有效性。实验表明，该方法在处理多模态数据时具有较好的性能。 3. HGNN 3.1 模型框架 从图中大概可以看出来，整个模型的思路是首先将多模态的数据关系作为输入(其中包含训练数据和测试数据)，将他们同时考虑进行超边的生成(一种半监督的学习策略，与2017年的经典GCN方法类似，属于一种直推式的学习方法)。将生成的超边组进行超图卷积得到最后的结果，根据下游任务的要求进行输出。
3.2 Hypergraph learning statement 相关超图的定义问题就不再赘述，如果有些概念不清楚可以参考我的前两篇文章
https://blog.csdn.net/qq_44015059/article/details/108871728
https://blog.csdn.net/qq_44015059/article/details/108901941
这里直接给出论文中超图关联矩阵的表达形式
之后考虑下游任务之一的超图节点分类任务(在本文中以引文网络为例)，那么这个任务的目标函数可以定义为
其中 Ω ( f ) \Omega(f) Ω(f) 代表超图的规范化处理过程， R e m p ( f ) \mathcal{R}_{emp}(f) Remp​(f) 代表监督的损失， f ( ⋅ ) f(\cdot) f(⋅) 代表分类的函数。其中 Ω ( f ) \Omega(f) Ω(f) 被定义为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d967efa2a055588ba6bb8c658356a9f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7ce3aa90f240941cc79aaf5d86ea76f/" rel="bookmark">
			pyuic5: error: no such option: -m的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景
pycharm使用pyqt5做gui，将.ui文件转换为.py文件时，出现错误：pyuic5: error: no such option: -m
解决
external tools里的pyui5中的arguments改为：
$FileName$ -o $FileNameWithoutExtension$.py 即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7926120d76f9363ae4508fc243194e4e/" rel="bookmark">
			论文笔记：KDD 2020 Multi-level Graph Convolutional Networks for Cross-platform Anchor Link Prediction
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 论文链接：https://arxiv.org/abs/2006.01963?context=cs.LG
github：https://github.com/sunxiangguo/MGCN
如今，大多数人都参与了不止一个在线社交网络(OSN)，如Facebook、Twitter、微博、Linkedin。通常情况下，用户为了不同的目的在不同的OSNs上注册，不同的OSNs显示了不同的观点和人的不同方面。例如，一个用户在Facebook上联系他们的朋友，但是使用Linkedin联系他/她的同事，感兴趣的公司和寻找工作机会。虽然不同的OSNs表现出不同的特性和功能，但在不同的社交平台上，个人用户帐户的重叠现象一直存在。然而，出于隐私考虑或缺乏动机，在大多数社交网络中，属于同一个人的多个账户的信息并没有明确给出。
在数据挖掘研究领域中，将来自不同社交网络的属于同一个人的账号匹配问题定义为Account Mapping(账号映射)、Socia Network De-anonymization(社交网络去匿名化)或Social Anchor Link Prediction(社交锚链预测)。不同社交平台上的账户匹配在社交网络分析中扮演着重要的角色
因为它有助于改善许多下游应用，如在线个性化服务、链接预测、推荐系统、生物蛋白-蛋白对老化相关复合物的比对，以及犯罪行为检测。尽管人们对这一具有挑战性的课题给予了很大的关注，但仍有很大的改进空间。以往的研究提出利用可用的辅助信息，如自生成的用户资料、每日生成的内容和其他人口统计特征(如用户名、头像、位置、性别、帖子、博客、评论等)来解决这一问题。然而，随着公众隐私和信息权利意识的提高，这些信息越来越难以获得和获取。
跨平台账户匹配在社交网络分析中扮演着重要的角色，并且有利于广泛的应用。然而，现有的方法要么严重依赖高质量的用户生成内容(包括用户配置文件)，要么仅关注网络拓扑结构就存在数据不足的问题，这给研究者带来了模型选择的两难困境。为了解决这个问题，本文提出了一个新的框架，在局部网络结构和超图结构上统一考虑多层次的图卷积。该方法克服了现有工作中数据不足的问题，且不需要依赖用户的人口统计信息。此外，为了使所提方法能够处理大规模社交网络，提出了一种两阶段空间协调机制，以在基于网络划分的并行训练和跨不同社交网络的账户匹配中对齐嵌入空间。在两个大规模的现实社会网络上进行了广泛的实验。实验结果表明，该方法的性能优于现有模型。
近年来，随着网络嵌入(NE)技术的发展，相关问题的研究重点已转移到挖掘网络结构信息上。社交网络结构数据在正确性和完整性方面更加可靠。但是，只注重网络结构本身的建模，使得几乎所有现有的方法都存在数据不足的问题，特别是在小规模网络和冷启动设置(即用户是网络的新用户)。因此，在现实场景中，这一直是从业者所面临的困境，迫切需要有效的解决方案。基于此提出利用并整合从原始网络中提取的超图信息来进行数据增强。在本文的其余部分，我们分别使用“简单图”和“超图”来表示原始网络和从原始网络中提取的超图。与简单图相比，超图允许一条边(又名heperedge)同时连接两个以上的节点。这意味着图中节点之间的非成对关系可以很容易地组织并表示为超边。此外，超图具有鲁棒性和灵活性，能够适应各种各样的社交网络，无论给定的社交网络是纯社交网络还是具有各种属性和链接的异构社交网络。
更具体地说，提出了一种新的多层图卷积网络的嵌入框架，即MGCN，用于联合学习不同粒度灵活GCN核(即简单图GCN、超图GCN)的网络顶点的嵌入。社交网络的简单图结构信息揭示了用户之间的关系(如友谊、关注者)，而超图则根据其在社交网络中的具体定义具有不同的语义意义。例如，基于N-hop邻居的超图(用户的N-hop邻居通过同一个超边连接)在一定程度上表示朋友圈。基于中心的超图表示不同的社会层次(具有相似中心性值的用户可能具有相同的社会地位)。因此，通过定义各种超图并将其嵌入到网络嵌入学习中，将有助于学习更好的用户表示。为了支持这一点，MGCN框架是灵活的，可以包含各种超图定义，它可以将任何超图作为向量表示，使模型结构对各种超图定义不变性。通过扩展GCN来利用和集成超图的基本原理是，超图提供了更灵活的网络。与本地网络拓扑上的单个图GCNs相比，可以包含更多更丰富的信息的表示。在大多数情况下，GCN层的最优数量总是被设置为2，因为添加更多的层不能显著提高的性能。因此，GCNs只能捕获网络中某个节点周围的本地信息。这一现象也使得solo GCN存在矛盾，因此在account matching task上表现的一般，因为task的关键是探索更多更深的信息来进行预测。从直观上看，在从原始网络中提取的hypergrpahs上定义GCNs将补充现有基于gc的网络嵌入模型的局限性。
然而，这仍然是一项具有挑战性的任务，因为社交网络是大规模的，有数百万个节点和数十亿个边缘。传统的集中训练方法由于计算量大，无法适应这样大的网络。为了使MGCN适应于大规模社交网络，提高其可扩展性和效率，提出了一种新的训练方法，该方法首先将大规模社交网络分割成簇，然后以完全分散的方式学习网络嵌入。为了对齐不同簇的学习嵌入空间，提出了一种新的两相空间协调机制。在第一阶段，我们对齐从同一网络内的每个簇中学习到的嵌入空间。除了不同子网之间的排列在同一网络,推导空间和解对齐两个不同网络通过少量的观测锚节点,这使得我们的MGCN框架实现更精确的锚点链接比最先进的模型和预测效率高在大型社交网络。
总结论文主要贡献如下：
提出了一个新的框架MGCN，用于预测跨不同社交网络的锚链接这一具有挑战性的任务。该方法同时考虑了局部和超图级的图卷积来学习网络嵌入，能够为任务捕获更广泛、更丰富的网络信息。
为了使所提出的框架能够适应大规模的社交网络，提出了一系列的处理方法，包括网络分割和空间调和来处理分布式的训练过程。
对大规模真实数据集进行了广泛的评估，实验结果证明了提出的MGCN模型相对于最新模型的优越性。
2. 定义 2.1 问题定义 已知多个图例如： G 1 = { V 1 , E 1 } \mathcal{G_1=\{V_1,E_1\}} G1​={V1​,E1​} 和 G 2 = { V 2 , E 2 } \mathcal{G_2=\{V_2,E_2\}} G2​={V2​,E2​} 和 一组锚点链接 S a n c h o r = { ( u , v ) ∣ u ∈ V 1 , v ∈ V 2 } S_{anchor}=\mathcal{\{(u,v)|u \in V_1,v \in V2\}} Sanchor​={(u,v)∣u∈V1​,v∈V2}，目标是对无法观测到的跨平台锚点链接进行预测，并把整个问题看成是一个二分类问题，进而将问题转化为：给出一组节点 ( u , v ) \mathcal{(u,v)} (u,v) 并满足 u ∈ V 1 , v ∈ V 2 \mathcal{u \in V_1},v \in V_2 u∈V1​,v∈V2​，利用模型对他们之间是否存在链接进行预测。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7926120d76f9363ae4508fc243194e4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6490306efee9afeb01ecb52a6192919e/" rel="bookmark">
			pandas中的几个时间序列生成函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 pd.date_range函数pd.period_range函数pd.timedelta_range函数pd.interval_range函数 最近在处理跟时间相关的数据，用到了pandas中的datetime的几个函数，本篇来说一下pandas中几个常见的时间序列生成函数。
pd.date_range函数 pd.date_range(start=None, end=None, periods=None, freq=None, tz=None, normalize=False, name=None, closed=None)
先来讲一下各参数的含义：
start：即开始时间，得是字符形式的，如"2020-1-9"；end：结束时间，格式同start；periods：生成的时间个数；freq：生成时间的间隔频率，不写默认“D”；我列出常用的几个： freq别称说明/以下述为频率B工作日C自定义工作日D日历的日期W周M月末Q季度末Y年末H小时T分钟S秒MS月初QS季度初YS年初SMS前半月（1号和15号） tz：设置时区，如设置上海时间–“Asia/Shanghai”；normalize：是否在生成序列前将start或end的日期设为凌晨00点；默认False；name：设置该时间序列的名称；closed：有三个值–None、left、right，设置是否为闭区间，默认为None，全闭。 接着可以看一个示例：
date = pd.date_range(start="2019-9-15", periods=7, freq="2SMS", tz="Asia/Shanghai") date ''' 返回： DatetimeIndex(['2019-09-15 00:00:00+08:00', '2019-10-15 00:00:00+08:00', '2019-11-15 00:00:00+08:00', '2019-12-15 00:00:00+08:00', '2020-01-15 00:00:00+08:00', '2020-02-15 00:00:00+08:00', '2020-03-15 00:00:00+08:00'], dtype='datetime64[ns, Asia/Shanghai]', freq='2SMS-15') ''' 可以看到，加上时区之后多加了8个小时；同时freq里并不是单纯的示例格式，反而多了一个2，可以这样计算：原SMS代表半月即15天，加上2之后代表乘以2，即变为了30天。
pd.period_range函数 - pd.period_range(start=None, end=None, periods=None, freq=None, name=None)
参数意思都是一样的，因此就不解释了。直接上厘子例子。
# 频率默认以“天”算 period = pd.period_range(start="2019-2-2", periods=2) period ''' 返回： PeriodIndex(['2019-02-02', '2019-02-03'], dtype='period[D]', freq='D') ''' 单这样看肯定会觉得和date_range函数没有多大区别，最多只是数据类型不一样。不过无需着急，接下来我再放几个该函数的例子，一对比，就能很快发现区别。
# 频率以“季度”算 period = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6490306efee9afeb01ecb52a6192919e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3fed9f2e71b7cde81c1df83f3ee6153/" rel="bookmark">
			vscode配置python-flask
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：对vscode配置python扩展
打开vscode，打开左端扩展，在上端搜索框输入python，并安装
第二步：在文件管理器中新建一个文件夹（vscode不能创建文件夹），然后用vscode打开这个文件夹
第三步：在文件夹下新建一个py文件：
鼠标移动到文件夹下，点击第一个按钮新建文件，并在框中输入文件名，后缀须是.py，vscode方能将其识别为python文件
第四步：输入print('Hello,world!')并尝试运行，查看能否成功运行。若可以，请跳转第五步；若不能，请查看vscode配置python环境
第五步：在该文件下将 print('Hello,world!')替换成以下代码
from flask import Flask app = Flask(__name__) @app.route('/') def index(): return 'Hello World' if __name__ == '__main__': app.debug = False # 设置调试模式，生产模式的时候要关掉debug app.run() 第五步：快捷键ctrl+shift+p，在弹出的输入框中输入tasks，选择第一个：
再点击第一个：
点击最后的Others
第六步：点击上方标题栏的“terminal”打开终端，输入以下代码创建虚拟环境：
py -m venv venv 输入以下代码跳转到venv/Scripts文件夹
cd venv/Scripts 输入start cmd跳转到命令行：
在命令行中输入：
activate.bat 以进入虚拟环境，在这之后，在虚拟环境中安装flask包：
pip install flask pip install watchdog 第七步，尝试运行文件中的上述代码，在终端中出现
按住ctrl点击下面的链接，可以看到
恭喜，配置完成！
本文配置系web开发小白在网上搜寻资料经几番辗转尝试总结出的一套方法，虽然在组员的电脑上可以成功运行，但亦有错漏之处，如有发现，敬请指正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b93d74fa2fd296ca2d8f8ae20c0f6fd3/" rel="bookmark">
			KALI更新时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看系统时间
date
查看硬件时间
hwlock --show
安装ntpdate
apt-get install -y ntpdate
删除etc/localtime文件
rm -rf etc/localtime
复制shanghai时区文件替换到这里
cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
更新时间
ntpdate -u ntp.api.bz
此时系统时间已经更新
将系统时间同步到硬件时间
hwclock -w
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06e0ee49a2d9c4eba20b69287f1ff0aa/" rel="bookmark">
			DCDC降压电路学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.输出建立过程分析 BUCK电路的基本原理就不说了，首先来分析一个BUCK电路它到输出电压稳定这个过程是如何建立起来的。
假设输入电压15V输出电压5V，达到稳态时的电流为3A。它的基本电路如图所示
当输入端上电，控制电路就工作起来，MOS管开始工作；当需要5V，3A输出时，稳态时PWM的占空比为0.3，但是刚开始时PWM占空比是从0开始，通过若干个pwm周期加到0.3的，完成一个软启动，这样不会对整个系统造成大的冲击电流，PWM波形如下图所示。
同时输出电流和输出电压也是一个缓慢变化过程，如下图所示
电感电流波形如下图所示
图a
图b
图a中电感电流上升斜率大于下降斜率，电感电流由断续模式慢慢过渡到连续模式。
开始时候占空比很小，充电阶段电感电流以VIN/L的斜率上升，由于充电时间很短，∆I很小。放电阶段电感电流以（Vo+VD）/L斜率下降，VD是二极管导通压降，由于Vo开始很小，电感电流缓慢下降toff的时间。
当占空比增大到一定程度，电感电流上升斜率不变且时间加长，电感电流下降斜率（Vo+VD）/L逐渐加大，电感电流会波动上升，直到VIN*ton=（Vo+VD）*toff时，电感电流稳定，其平均值等于负载电流。图b显示了电感经历了几次平均电流跃迁后，逐渐达到负载电流，这是TPS5454芯片的一个仿真波形，电感电流不是一下子达标的，而是稳定之后跃升再稳定再跃升。
二．稳态过程分析 假设输入电压15V，输出电压5V，当忽略二极管两端的压降时，电感电流CCM模式下，PWM占空比应该是0.3；
电容：
在这样的一个稳态过程下，输出电容上的电压是稳定不变的，可以等效看成它是没有电流流过的，只起一个稳压作用：当开关管导通，输入电压一部分给电感充电，另外一部分维持负载电流；当开关管关断，电感续流为负载供电。
电感：
电感电流在一个开关周期内电流上升量等于下降量，满足∆Ionton=∆Iofftoff，即Von/Lton=Voff/Ltoff。每个周期都是如此，电感中的电流一直保持动态稳定，且电感电流的几何中心就是负载电流；负载电流越大，电感平均电流越大，电感电流就会在一个更高的电流平台上升和下降，∆I是不变的。∆I由f、D、L决定（f是pwm频率、D是pwm占空比
L是电感值）。当f翻倍，D、L不变，∆I减半；L变为两倍，f、D不变，∆I减半。
MOS管：
MOS管导通时，ton的时间流过的电流于电感电流相等；MOS管关断后，承受VIN端电压（忽略二极管电压），所以MOS管承受的平均电流为IL*D。
二极管
在开关管导通时，二极管反向承受输入电压；开关管关断时，二极管导通为电感续流，所以二极管中流过的平均电流为IL*（1-D）。
如上图所示，从上到下依次为MOS管驱动，电感电流，输出电容电流，二极管电流；可以看到开关管导通时，电感电流、输出电容电流上升，二极管关断；开关管关断时，电感通过电容、二极管续流。
三．DCDC降压芯片功能描述 了解了BUCK的暂态建立和稳态情况，就可以对相关元器件进行选型设计了。选型之前，先要了解一下DCDC降压芯片的一些基本功能，对我们的设计有很大帮助。
3.1过流保护功能 逐周期限流模式：包括谷值电流限制、峰值电流限制，每一个PWM周期里面，分别对电感电流上升和下降阶段的电流进行检测，当检测电流高于设定阈值时，让MOS管关断。 优点：能够及时进行电流限制；缺点：当电路严重过流时，输出电流会维持在限流阈值上下，会产生较大损耗
打嗝模式：可以解决逐周期过流保护损耗大的不足，打嗝模式可以定时开启保护检测，当出现过流时，等待一段时间再检测是否过流，不让芯片每个PWM周期都监测，减小损耗。 3.2芯片的使能回滞引脚
降压芯片内部都有一个启动和关断电压，比如4.3V开通，3.1V关断。
通过外接电阻将VIN分压到EN脚。，可以自己设定一个开启关断电压。
（通过外接电阻的分压，使得EN脚电压等于1.2V，此时启动电压为：R2VIN/（R1+R2）+i1R2，自主设定了一个启动电压（高于4.3V），比如是10V，启动之后芯片内部会产生一个电流ihsy，EN脚电压升高到： R2VIN/（R1+R2）+i1R2+ihsy*R2，此时停止电压要低于10V才能停。）这样的回滞电压能够防止芯片欠压保护后的二次启动。
3.3芯片软启动
如图，上面芯片的软启动时间为1024个PWM周期，使能脚电压过低、温度保护、电流保护动作都会使得软启动复位。
3.4芯片开关频率的配置
可以选择电阻大小来配置开关频率
3.5轻载情况下的ECO模式
在空载或轻载模式下，芯片会跳掉一部分PWM，减小损耗；
轻载模式下的PWM波形如图所示，振荡是由电感与MOS管的ds间寄生电容产生的，振荡的中心就是输出电压大小。
待续。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d877ba7a72101db8f0cf2db20d03bc1/" rel="bookmark">
			word 自带公式编辑器中公式等号对齐方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 注意：这种方法只能对带括号的公式有用，比如下面的括号；且行数是根据 Enter 换行自动填补的，不是矩阵设定的 ！ 我们在写论文时经常遇到公式不对齐问题，影响美观，下面详细介绍一下 word 自带公式编辑器中公式等号对齐方法
形如下公式：
我们可以看到公式没有对齐，此时
第一步：全选公式，右击，选择，线性 得到如下结果
第二步：在每个 等号= 前打入 &amp; 符号， 第三步：然后全选，右击，选择专业型。 结果如下：
完美解决 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1697fc1eef69aa6dabf67b1ac343e5b0/" rel="bookmark">
			python 解密 M3U8 AES 加密的视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 从浏览器下载的M3U8格式视频有时会被AES加密。windows下解密AES需要安装pycryptodome 模块和pycrypto模块，使用conda或pip安装这两个模块。
conda install pycryptodome conda install pycrypto 安装完成后在Python文件中导入AES包，进行解密操作。M3U8一般使用CBC方式加密，key一般会与ts文件在同一目录，记事本打开key文件即可获取。iv需要从M3U8文件中获取。使用记事本打开此文件，如果属性列表出现 IV，则使用该值；如果未出现，则默认使用EXT-X-MEDIA-SEQUENCE作为 IV 值。使用大端字节序，往左填充 0 直到序列号满足128位，一般为全0。
示例代码如下。
from Crypto.Cipher import AES def decryptSingleAES( src,dec,key,iv ): try: f1 = open(src, 'rb') f2 = open(dec, 'wb') part = f1.read() cipher = AES.new(key.encode('utf-8'), AES.MODE_CBC, iv) plain_data = cipher.decrypt(part) if part: f2.write(plain_data) finally: if f1: f1.close() if f2: f2.close() if __name__ == '__main__': src='D:\\test\\old.ts' dec='D:\\test\\new.ts' key='9999999999999999' iv=b'0000000000000000' decryptSingleAES( src,dec,key,iv ) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a2fee219fa1e26833860f0dc3b3fb06/" rel="bookmark">
			数据库执行update语句，一直执行不完【已解决】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天执行了一个很简答的更新数据的SQL，结果一直执行不过去。最开始我以为是我的过滤条件不对，导致数据量太大，但是当我用select语句去执行时，发现过滤条件并没有问题，然后便开始了面向百度。
原来是发生了锁表现象，先将我的处理过程做一个总结：
1、使用SQL查看我们的锁表进程
SELECT SESS.SID, SESS.SERIAL#, LO.ORACLE_USERNAME, LO.OS_USER_NAME, AO.OBJECT_NAME, LO.LOCKED_MODE FROM V$LOCKED_OBJECT LO, DBA_OBJECTS AO, V$SESSION SESS WHERE AO.OBJECT_ID = LO.OBJECT_ID AND LO.SESSION_ID = SESS.SID 能查出来数据则说明存在锁表进程
记录下我们对应进程的SID、SERIAL#，为后面杀进程做准备
2、使用SQL杀死我们的锁表进程
ALTER SYSTEM KILL SESSION 'SID,SERIAL#'; 3、杀死进程再次执行第一步就没有对应的数据了
什么是锁表？为什么会发生？
数据库使用的是独占式封锁机制，当执行对应的SQL语句时（INSERT、UPDATE、DELETE），我们的表就会被锁住，直到commite、回滚或者退出数据库用户，才能执行下一条。
这里的细节和数据库的事务并发问题有关
事务的隔离级别和并发问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4678f445b6f0abef19f21cd4239b5149/" rel="bookmark">
			windows服务器直播推流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx flv/rtmp/hls for Windows x64 windows推流转码确实麻烦,真要用到必须一步一步来,不要急
环境 win 7 64位，openssl-1.0.2r，nginx-http-flv-module
下载 1、下载以下工具，并依次安装：
下载VS2010+VS2010 SP1msys-1.0.11.exeActicePerl-5.24.2.2403-MSWin32-x64-403863.exemercurial-4.3.1-x64.msinasm-2.12.02rc9-installer-x64.exe（32位需要用，64位不需要）sed-4.2.1-setup.exe下载配套的所需库代码PCRE，zlib 和 OpenSSL libraries sources下载nginx-http-flv-module：https://github.com/winshining/nginx-http-flv-module 以上工具需要确保加入到了环境变量（控制面板\系统和安全\系统\高级系统设置\环境变量）。
2、获取Nginx源码：
打开cmd命令，切换到Mercurial安装根目录，执行命令：
hg clone http://hg.nginx.org/nginx 下载成功后会在Mercurial安装目录下，创建nginx源代码文件夹。
3、添加依赖资源包：
使用MSYS工具，在nginx源代码分别创建objs/lib文件夹，将下载好的nginx-http-flv-module、openssl、pcre、zlib分别解压在lib文件夹下面
编译 1、生成makefile文件，用于c++编译器：
继续使用MSYS工具，返回到nginx源代码根目录，执行以下脚本：
auto/configure --with-cc=cl --builddir=objs --prefix= \ --conf-path=conf/nginx.conf --pid-path=logs/nginx.pid \ --http-log-path=logs/access.log --error-log-path=logs/error.log \ --sbin-path=nginx.exe --http-client-body-temp-path=temp/client_body_temp \ --http-proxy-temp-path=temp/proxy_temp \ --http-fastcgi-temp-path=temp/fastcgi_temp \ --http-scgi-temp-path=temp/scgi_temp \ --http-uwsgi-temp-path=temp/uwsgi_temp \ --with-cc-opt=-DFD_SETSIZE=1024 --with-pcre=objs/lib/pcre-8.40 \ --with-zlib=objs/lib/zlib-1.2.11 --with-openssl=objs/lib/openssl-1.0.2r \ --with-select_module --with-http_ssl_module --add-module=objs/lib/nginx-http-flv-module 成功后输出以下：
1、修改nginx\auto\lib\openssl\makefile.msvc文件：
将VC-WIN32改为VC-WIN64A，将ms\do_ms 改为ms\do_win64a
修改objs\Makefile文件：将“-WX”删除，否则nmake时会报错“nginx error:c2220:警告被视为错误 - 没有生成object文件”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4678f445b6f0abef19f21cd4239b5149/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93c40c31402dd0946dffeb8481e2a037/" rel="bookmark">
			java后端图形验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;img src="/login/valicode" οnclick="upimg(this)"&gt; //刷新图片 function upimg(dd){ $(dd).attr("src","/login/valicode") } //随机生成登录验证码 @RequestMapping("/valicode") //对应/login/valicode请求 public void valicode(HttpServletResponse response, HttpSession session) throws Exception { //利用图片工具生成图片 //第一个参数是生成的验证码，第二个参数是生成的图片 Object[] objs = ImageUtil.createImage(); //将验证码存入Session session.setAttribute("imageCode", objs[0]); //将图片输出给浏览器 BufferedImage image = (BufferedImage) objs[1]; response.setContentType("image/png"); OutputStream os = response.getOutputStream(); ImageIO.write(image, "png", os); } 获取验证码 String pp=session.getAttribute("imageCode").toString(); 工具类
public final class ImageUtil { // 验证码字符集 private static final char[] chars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}; // 字符数量 private static final int SIZE = 4; // 干扰线数量 private static final int LINES = 5; // 宽度 private static final int WIDTH = 80; // 高度 private static final int HEIGHT = 40; // 字体大小 private static final int FONT_SIZE = 30; /** * 生成随机验证码及图片 * Object[0]：验证码字符串； * Object[1]：验证码图片。 */ public static Object[] createImage() { StringBuffer sb = new StringBuffer(); // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93c40c31402dd0946dffeb8481e2a037/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd3f66cd9e6cc2c568258b36bf64d152/" rel="bookmark">
			linux 模糊批量删除文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 find命令和xargs 组合使用，通过管道 |命令传值
模糊查找某个目录的文件
find ./ -name *.png 查找当前目录下所有带 .png后缀的文件
将查询的结果传值给 xargs， 到达模糊批量删除的效果
find ./ -name *.png | xargs rm 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a31b528de259ec07efb7fa404864083/" rel="bookmark">
			xlwings的基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 新建工作簿及、插入值并关闭打开已有文件、查看/删除单元格值更改单元格颜色、行高列宽、插入公式 新建工作簿及、插入值并关闭 首先先导入需要的模块。
import pandas as pd import xlwings as xw import numpy as np 接着新建一个test.xlsxexcel文件。
# visible-是否打开相应excel文件，即是否可视化当前工作簿； # add_book=True，此时立即创建一个有sheet表的工作簿 # add_book=False，此时立即创建一个没有sheet表的工作簿 app = xw.App(visible=True, add_book=False) wb = app.books.add() 此时就能获取wb的sheet表，进行操作了。
sht = wb.sheets[0] # a1到d1单元格插入值 sht.range("a1:d1").value = ["序号", "姓名", "年龄", "性别"] 可以实时看到excel文件的结果：
接下来编辑完就能保存并关闭。
# 保存到当前文件夹下 wb.save("./test.xlsx") # 关闭此工作簿 wb.close() 此时关闭工作簿之后，因为app还在，所以excel整体界面是这样子的。
接下来再关闭app就行。
app.quit() 打开已有文件、查看/删除单元格值 打开工作簿有两种方式：
# 方式一：推荐，更灵活 app = xw.App(visible=True, add_book=False) wb = app.books.open("test.xlsx") # 方式二 wb = xw.Book("test.xlsx") 接下来获取到sheet，就可以对表中的单元格编辑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a31b528de259ec07efb7fa404864083/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9febd330cf6add7f051f9ae6e7a84890/" rel="bookmark">
			firefox 火狐浏览器 跨域设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在用开发Web应用时，常常需要跨域请求资源，这就需要解除浏览器的跨域限制。
否则会报
已拦截跨源请求：同源策略禁止读取位于 ..... 的远程资源。（原因：CORS 头缺少 'Access-Control-Allow-Origin'）。
这样的错误。
对于Chrome浏览器，设置跨域很容易。例如：https://www.cnblogs.com/shihaiming/p/10984394.html 但对于firefox并不容易，许多人介绍了设置 security.fileuri.strict_origin_policy 的方法，但它在最新的firefox浏览器中似乎并不生效。
在此，我们可以使用firefox浏览器插件来实现跨域，例如CORS-EVERYWHERE
https://addons.mozilla.org/en-US/firefox/addon/cors-everywhere/
它是可用的。它的github地址是https://github.com/spenibus/cors-everywhere-firefox-addon。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaf7effaab4e8b984ac23bcf56f21737/" rel="bookmark">
			正则表达式提取省市区县乡镇等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 (?&lt;province&gt;[^省]+省|.+自治区|上海|北京|天津|重庆|内蒙古|.+特别行政区)?(?&lt;city&gt;[^市]+市|.+自治州)?(?&lt;county&gt;[^县]+县|.+区|.+镇|.+局)?(?&lt;town&gt;[^区]+区|.+镇)?(?&lt;village&gt;.*) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/249eaf6b805f84de39af92de58d0c71a/" rel="bookmark">
			云讯健身管理系统-12--SSO单点登录、阿里云短信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、单点登录 1. 用户登录业务介绍 1.1 单一服务器模式—sessiong广播机制 早期单一服务器，用户认证，将其session复制
1.2. SSO(single sign on)模式 1.3. Token模式 业务流程图{用户访问业务时，必须登录的流程}
二、使用JWT进行跨域身份验证 1、传统用户身份验证 Internet服务无法与用户身份验证分开。一般过程如下：
1、用户向服务器发送用户名和密码。
2、验证服务器后，相关数据（如用户角色，登录时间等）将保存在当前会话中。
3、服务器向用户返回session_id，session信息都会写入到用户的Cookie。
4、用户的每个后续请求都将通过在Cookie中取出session_id传给服务器。
5、服务器收到session_id并对比之前保存的数据，确认用户的身份。
这种模式最大的问题是，没有分布式架构，无法支持横向扩展。
2、解决方案 1、session广播
2、将透明令牌存入cookie，将用户身份信息存入redis
另外一种灵活的解决方案：
使用自包含令牌，通过客户端保存数据，而服务器不保存会话数据。 JWT是这种解决方案的代表。
三、JWT令牌 1、访问令牌的类型 2、JWT的组成 典型的，一个JWT看起来如下图：
该对象为一个很长的字符串，字符之间通过"."分隔符分为三个子串。
每一个子串表示了一个功能块，总共有以下三个部分：JWT头、有效载荷和签名
2.1 JWT头 JWT头部分是一个描述JWT元数据的JSON对象，通常如下所示。
{ "alg": "HS256", "typ": "JWT" } 在上面的代码中，alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；typ属性表示令牌的类型，JWT令牌统一写为JWT。最后，使用Base64 URL算法将上述JSON对象转换为字符串保存。
2.2 有效载荷 有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。 JWT指定七个默认字段供选择。
iss：发行人 exp：到期时间 sub：主题 aud：用户 nbf：在此之前不可用 iat：发布时间 jti：JWT ID用于标识该JWT 除以上默认字段外，我们还可以自定义私有字段，如下例：
{ "sub": "1234567890", "name": "Helen", "admin": true } 请注意，默认情况下JWT是未加密的，任何人都可以解读其内容，因此不要构建隐私信息字段，存放保密信息，以防止信息泄露。
JSON对象也使用Base64 URL算法转换为字符串保存。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/249eaf6b805f84de39af92de58d0c71a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7174db64e074208b0cfb053dfab3e46f/" rel="bookmark">
			通过深度学习从胸部X射线检测肺炎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Note from Towards Data Science’s editors: While we allow independent authors to publish articles in accordance with our rules and guidelines, we do not endorse each author’s contribution. You should not rely on an author’s works without seeking professional advice. See our Reader Terms for details.
Towards Data Science编辑的注意事项： 尽管我们允许独立作者按照我们的 规则和指南 发表文章 ，但我们不认可每位作者的贡献。 您不应在未征求专业意见的情况下依赖作者的作品。 有关 详细信息， 请参见我们的 阅读器条款 。 In 2017, 2.56 million people died from pneumonia. About a third of those people were children less than 5 years old.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7174db64e074208b0cfb053dfab3e46f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81c5dbdf26f475b9d5fe18b7301df64b/" rel="bookmark">
			自变量向量的函数的泰勒公式_向量自变量的线性函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自变量向量的函数的泰勒公式
数据科学与机器学习的线性代数 (LINEAR ALGEBRA FOR DATA SCIENCE AND MACHINE LEARNING) In mathematical analysis, one studies functions of any number of variables. Such functions can be regarded as vector functions.
在数学分析中，人们研究许多变量的函数。 这样的函数可以被视为向量函数。 Linear vector functions, also known as linear operators, are of great importance in linear algebra and it’s applications.
线性向量函数，也称为线性算子，在线性代数及其应用中非常重要。 线性形式 (Linear forms) A numerical function L(x) of a vector argument x, defined on a linear space K over a number field K, is called a linear form if it satisfies the following conditions:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81c5dbdf26f475b9d5fe18b7301df64b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57f9303f0e7b0d489dc8b7c40b14ac0f/" rel="bookmark">
			hdfs创建文件夹及目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import java.io.IOException; import java.net.URI; import java.net.URISyntaxException; import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.FileSystem; import org.apache.hadoop.fs.Path; public class nkdirDemo { public static void main(String [] args) throws IOException, URISyntaxException { FileSystem fs = FileSystem.get(new URI("hdfs://Master:9000"), new Configuration()); fs.mkdirs(new Path("/aaa/bbb/ccc"));//创建文件夹 fs.create(new Path("/aaa/bbb/ccc/ddd.txt"));//创建文件 fs.delete(new Path("/user/hadoop/file4.abc"));//删除文件，不常用 fs.close(); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12475d2d24d205d7949a0250f5f640bd/" rel="bookmark">
			解决Git报错:error: You have not concluded your merge (MERGE_HEAD exists)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git fetch和git pull的区别: 都可以从远程获取最新版本到本地 1.Git fetch:只是从远程获取最新版本到本地,不会merge(合并) $:git fetch origin master //从远程的origin的master主分支上获取最新版本到origin/master分支上 $:git log -p master..origin/master //比较本地的master分支和origin/master分支的区别 $:git merge origin/master //合并 2.Git pull:从远程获取最新版本并merge(合并)到本地 $:git pull origin master //相当于进行了 git fetch 和 git merge两部操作 实际工作中,可能git fetch更好一些, 因为在merge前,可以根据实际情况决定是否merge 再说导致报错:error: You have not concluded your merge (MERGE_HEAD exists).的原因可能是在以前pull下来的代码自动合并失败 解决办法一:保留本地的更改,中止合并-&gt;重新合并-&gt;重新拉取 $:git merge --abort $:git reset --merge $:git pull 解决办法二:舍弃本地代码,远端版本覆盖本地版本(慎重) $:git fetch --all $:git reset --hard origin/master $:git fetch 参考以下链接:
http://stackoverflow.com/questions/11646107/you-have-not-concluded-your-merge-merge-head-exists
http://yijiebuyi.com/blog/5b55eb51ad49ce41e2de9c85dd4513ca.html
https://download.csdn.net/download/XiaoRungen/12825664
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92a9c3576767bef0ee5f0463e92ab6dc/" rel="bookmark">
			关于安装Jenkins插件报错问题的最新发现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎大家去我的个人网站踩踩 点这里哦 一、关于Jenkins安装插件的最新发现 我在前面写过两篇文章，是解决Jenkins安装插件报错的问题
真正解决Jenkins安装插件总是报错的问题（网上查的解决方案都无效）
真正解决Jenkins安装插件总是报错的问题（二）
主要就是把update-center.json里的下载地址替换成镜像站的下载地址，而这两天我又发现了update-center.json里面的下载地址没有被替换掉，于是我看了看update-center.json里面的地址，发现已经由下载地址前缀已经由 http://updates.jenkins-ci.org 变成了 https://updates.jenkins.io/ ，打开网站，发现地址确实换新的了，然后我试着下载一个附件 https://updates.jenkins.io/download/plugins/BlazeMeterJenkinsPlugin/4.7/BlazeMeterJenkinsPlugin.hpi
发现居然自己重定向到了清华的镜像，大家可以试一下
我觉得很奇怪，于是乎在官网上找找看，有没有什么发现，最后在下面找到了清华大学
好了，现在什么都不用改了，官方帮你转到清华镜像了。。。
嗨，你早点弄出来，我也不用费劲搞了半天呐，⊙﹏⊙b汗
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f640427051bc44e883375ad8fed49df/" rel="bookmark">
			RK1109 RK1126等芯片来袭，2020年瑞芯微旗下SoC一览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019年就要结束了，来年的主角也已经到位，在此跟大家分享一下瑞芯微在2020年推出的RK35XX系列的新一代通用型SoC：RK3588、RK3566和RK3530，以及其应用场景，方便行业定制项目选型。在此附上一张瑞芯微的产品路线图，以供大家参考。
瑞芯微旗下SoC路线图
从上面这张图我们可以清晰的看出，在2020年瑞芯微推出的产品主要是面向物联网人工智能/机器视觉和机顶盒领域。鉴于在前不久瑞芯微刚发布了RK2108和RK2208这两款面向音频领域的SoC，因此2020年没有新品推出也算正常。不过平板电脑的SoC再次缺席，也让我们感受到消费类平板电脑的大势已去，平板电脑的市场规模越来越小了。
RK3588是瑞芯微的新一代旗舰SoC，采用A76+A55的大小核设计，内置独立的NPU主要面向人工智能和物联网场景。支持8K视频解码和4K视频编码，同时还支持多路4K输出，这对于高端显示应用来说是非常有吸引力的。借助5G网络环境的成熟，高清视频的传输有了网络条件支持，8K视频会迎来新的增长点。
RK3566也是一款面向物联网应用的SoC，采用A55架构处理器，搭载G52图形处理器，支持双屏异显。总的来看RK3566的芯片定位比较尴尬，图形处理器与S922X一致，主逻辑处理器确是S905X3同款。RK3530就是直接对标S905X3了，同款A55处理器，外挂同款G31图形处理器。按照简单思维来排列，这几款的性能排名大概是：S922X强于RK3566强于RK3530约等于S905X3。鉴于目前S905X3已经开始支持8K视频解码和输出，不知道RK3530是否有等待的价值。
RV1126和RV1109都是人工智能下机器视觉分支的SoC，都内置独立NPU。RV1126可提供1.5TOPS算力，RV1109可提供1TOPS算力。单从性能来讲这两款视觉处理器应该弱于S905D3，不过Rockchip在机器视觉领域算是有一定技术积累的，最终产品的实际表现有待确认。
总的来讲，瑞芯微2020年更专注于物联网和人工智能领域的产品规划。物联网设备有着巨大的市场潜力，如今的大厂瑞芯微推出了一揽子专用DSP，为了销量和报表，瑞芯微需要增强产品的适用性。人工智能不多说了，瑞芯微在这个赛道上一直身先士卒，是个勇士。不过我们也看到，一直专注于家庭影音市场的晶晨（Amlogic）也开始有想法了。已经吃下国内大部分智能机顶盒市场份额的晶晨，开始把触角伸向了行业通用领域，不但在自身产品上，也在市场策略上发生了变化。再加上一个4G时代失利，5G时代磨拳擦掌的联发科（MTK）。2020年，国内通用型SoC市场竞争将会异常激烈。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d5b9a0dda4623b246f45607568f7fcc/" rel="bookmark">
			Redis中删除过期Key的三种策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中有个接口要频繁调用查询数据库中的数据，为了降低数据库的压力，所以把一部分记录先缓存在redis中，对redis中的数据设置了期限。今天无意间发现一个问题，使用dbsize查询出来的数量，比实际缓存量要高一部分。用
redis-cli keys '*'|wc -l 1 获取到的数据和实际情况是一样的。如下面两图：
对比发现，redis中key的总量为286957，比数据库中的264032高出了20000多个！为什么会这样呢？查找程序原因，并没有发现逻辑问题。查找redis相关资料，发现原来是redis对过期键处理机制导致的误差。
dbsize返回的是包含过期键的总数，所以造成了误差！结合查找的资料，拿来一起分享。
Redis对于过期键有三种清除策略：
被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批已过期的key当前已用内存超过maxmemory限定时，触发主动清理策略 被动删除
只有key被操作时(如GET)，REDIS才会被动检查该key是否过期，如果过期则删除之并且返回NIL。
1、这种删除策略对CPU是友好的，删除操作只有在不得不的情况下才会进行，不会对其他的expire key上浪费无谓的CPU时间。
2、但是这种策略对内存不友好，一个key已经过期，但是在它被操作之前不会被删除，仍然占据内存空间。如果有大量的过期键存在但是又很少被访问到，那会造成大量的内存空间浪费。expireIfNeeded(redisDb *db, robj *key)函数位于src/db.c。
但仅是这样是不够的，因为可能存在一些key永远不会被再次访问到，这些设置了过期时间的key也是需要在过期后被删除的，我们甚至可以将这种情况看作是一种内存泄露—-无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说，肯定不是一个好消息。
主动删除
先说一下时间事件，对于持续运行的服务器来说， 服务器需要定期对自身的资源和状态进行必要的检查和整理， 从而让服务器维持在一个健康稳定的状态， 这类操作被统称为常规操作（cron job）
在 Redis 中， 常规操作由 redis.c/serverCron 实现， 它主要执行以下操作
更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。清理数据库中的过期键值对。对不合理的数据库进行大小调整。关闭和清理连接失效的客户端。尝试进行 AOF 或 RDB 持久化操作。如果服务器是主节点的话，对附属节点进行定期同步。如果处于集群模式的话，对集群进行定期同步和连接测试。 Redis 将 serverCron 作为时间事件来运行， 从而确保它每隔一段时间就会自动运行一次， 又因为 serverCron 需要在 Redis 服务器运行期间一直定期运行， 所以它是一个循环时间事件： serverCron 会一直定期执行，直到服务器关闭为止。
在 Redis 2.6 版本中， 程序规定 serverCron 每秒运行 10 次， 平均每 100 毫秒运行一次。 从 Redis 2.8 开始， 用户可以通过修改 hz选项来调整 serverCron 的每秒执行次数， 具体信息请参考 redis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d5b9a0dda4623b246f45607568f7fcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c17b0f1aabe3c8e461df2c1914291e0e/" rel="bookmark">
			pyecharts中堆叠柱形图的绘制及颜色更改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 导入模块构建数据并绘制基本柱形图绘制堆叠图 堆叠柱形图的绘制相比普通柱形图，只需要多添加几个.add_yaxis()—y轴即可。
导入模块 import pandas as pd from pyecharts.charts import Bar from pyecharts import options as opts 构建数据并绘制基本柱形图 此处我直接重新构建了一组数据来绘制，方便的小伙伴可以直接拿自己的数据练习。
data = pd.DataFrame({ "区域": ["A区", "B区", "C区"], "总销量": [23, 32, 14], "上衣销量": [3, 5, 10], "裤子销量": [15, 5, 1], "鞋袜销量": [5, 22, 3] }) data 获得如下数据：
接着可以先通过”总销量“绘制一个基本的柱形图。
bar = ( Bar(init_opts=opts.InitOpts(width="900px", height="500px")) .add_xaxis(data["区域"].tolist()) .add_yaxis("总销量", data["总销量"].tolist()) ) bar.render_notebook() 绘制出图形：
绘制堆叠图 堆叠柱形图的绘制相比普通柱形图，只需要多添加几个.add_yaxis()—y轴即可。同时，再再每个y轴的属性里添加一个参数就行。
stack_bar = ( Bar(init_opts=opts.InitOpts(width="900px", height="500px")) .add_xaxis(data["区域"].tolist()) .add_yaxis("上衣销量", data["上衣销量"].tolist(), stack="stack1") .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c17b0f1aabe3c8e461df2c1914291e0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e5548035ece104177c6b06077aa37a3/" rel="bookmark">
			Hive不支持不等值连接；构建近一年的日期辅助列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 不等值连接指的是 ON 条件中出现不等式，HIVE暂时不支持这种写法。
改成用INNER JOIN + WHERE 的方式
with date_para as ( select period_date, date_sub(period_date,366) as year_ago from dim.dim_app_period_d where year&gt;2019 ) select a.period_date, b.period_date, b.year_ago from date_para a inner join date_para b on 1=1 WHERE a.period_date &gt;= b.year_ago and a.period_date &lt; b.period_date and year(a.period_date)=2020 and year(b.period_date)=2020 order by a.period_date desc; dim.dim_app_period_d 含有一个日期列，包含2020年的每一天period_date
data_para新增了一个列year_ago,表示365天以前。
最后结果
案例介绍：
经常需要统计每一天的近一年的去重结果，比如购买人数（如果不去重就可以用窗口函数）
可以直接inner join 上述的结果表，然后按period_date, year_ago group by算count(distinct 人的标识)，就可以算出每一天的近一年购买人数。
月累 使用同样的方式可以构建月累，年累列。实现每一天都可以计算月累，年累。
年累 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c208e2d02701d5e6bce1ebb571901fb9/" rel="bookmark">
			IDEA打开窗口的数量及打开窗口的排列方式调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA打开窗口的数量及打开窗口的排列方式调整 在我们项目的开发过程中，由于项目涉及的类过多，以至于我们会打开很多的窗口。使用IDEA默认的配置，个人觉的十分不便。但我们可以对窗口的排列方式和打开窗口的排列方式进行设置。（默认设置为一行展示所有窗口，窗口数量限制10个）
修改IDEA编译器展示页面，使其能够堆叠显示，不在横着一排
//默认的设置为在一行显示 File --&gt; Setting --&gt; Editor --&gt; General --&gt; Editor Tabs //去掉选项 Show tabs in single row 修改IDEA编译器的最多展示窗口
//默认窗口显示的数量是10个 File --&gt; Setting --&gt; Editor --&gt; General --&gt; Editor Tabs --&gt; Tab limit //将窗口的数量设置为50 Tab limit:50 最终效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d725f00eee2462c6bbac8ac81cc2b8ef/" rel="bookmark">
			DolphinScheduler对比Airflow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 DolphinSchedulerAirFlow稳定性单点故障去中心化的多Master和多Worke是（单一调度程序）HA额外要求不需要(本身就支持HA)Celery / Dask / Mesos + Load Balancer + DB过载处理任务队列机制，单个机器上可调度的任务数量可以灵活配置，当任务过多时会缓存在任务队列中，不会造成机器卡死任务太多时会卡死服务器易用性DAG监控界面任务状态、任务类型、重试次数、任务运行机器、可视化变量等关键信息一目了然不能直观区分任务类型可视化流程定义是（所有流程定义操作都是可视化的，通过拖拽任务来绘制DAG,配置数据源及资源。同时对于第三方系统，提供api方式的操作）否（通过python代码来绘制DAG，使用不便，特别是对不会写代码的业务人员基本无法使用）快速部署一键部署集群化部署复杂功能是否能暂停和恢复支持暂停（非真暂停），恢复操作否(只能先将工作流杀死再重新运行)是否支持多租户支持（DolphinScheduler上的用户可以通过租户和hadoop用户实现多对一或一对一的映射关系，这对大数据作业的调度是非常重要的）否（只支持多用户）任务类型支持传统的shell任务，同时支持大数据平台任务调度： MR、Spark、SQL(mysql、postgresql、hive、sparksql)、Python、Procedure、Sub_ProcessBashOperator、DummyOperator、MySqlOperator、HiveOperator、EmailOperator、HTTPOperator、SqlOperator契合度支持大数据作业spark,hive,mr的调度，同时由于支持多租户，与大数据业务更加契合由于不支持多租户，在大数据平台业务使用不够灵活任务重跑支持失败任务重跑，但是不能指定从任意一个任务开始重跑可以指定从任意一个任务节点开始重跑跳过某些任务/运行节点是否跨项目依赖否否项目内依赖是（在一个项目中前驱依赖可以指定不同工作流中任意一个任务，后继依赖可以指定一整个工作流，但是无法指定其他工作流中的任意一个任务）是（将DAG定义在一个脚本中）扩展性是否支持自定义任务类型是是是否支持集群扩展是(调度器使用分布式调度，整体的调度能力会随便集群的规模线性增长，Master和Worker支持动态上下线)是(但是Executor水平扩展复杂)监控告警服务状态监控是否告警类型自带邮件告警，支持分组监控告警不自带告警系统版本系统版本要求均7.0以上暂无任务迁移支持任务迁移/Copy是否支持组件命令支持Python命令是是支持Hive-SQL命令是是支持Shell命令是是支持Http命令是是支持Sqoop命令是否支持Spark命令是否支持Flink命令是否支持MR命令是否支持Datax命令是否支持Hadoop命令否否 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b85748e87116cf1884a4a30d813bcd39/" rel="bookmark">
			Spring Cloud ---Nacos、Feign、Hystrix
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是微服务 1.微服务的由来 微服务最早由Martin Fowler与James Lewis于2014年共同提出，微服务架构风格是一种使用一套小服务来开发单个应用的方式途径，每个服务运行在自己的进程中，并使用轻量级机制通信，通常是HTTP API，这些服务基于业务能力构建，并能够通过自动化部署机制来独立部署，这些服务使用不同的编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理。
1.1微服务与单体架构区别 （1）单体架构所有的模块全都耦合在一块，代码量大，维护困难。微服务每个模块就相当于一个单独的项目，代码量明显减少，遇到问题也相对来说比较好解决。
（2）单体架构所有的模块都共用一个数据库，存储方式比较单一。
微服务每个模块都可以使用不同的存储方式（比如有的用redis，有的用mysql等），数据库也是单个模块对应自己的数据库。
（3）单体架构所有的模块开发所使用的技术一样。微服务每个模块都可以使用不同的开发技术，开发模式更灵活。
1.2 微服务的本质 （1）微服务，关键其实不仅仅是微服务本身，而是系统要提供一套基础的架构，这种架构使得微服务可以独立的部署、运行、升级，不仅如此，这个系统架构还让微服务与微服务之间在结构上“松耦合”，而在功能上则表现为一个统一的整体。这种所谓的“统一的整体”表现出来的是统一风格的界面，统一的权限管理，统一的安全策略，统一的上线过程，统一的日志和审计方法，统一的调度方式，统一的访问入口等等。
（2）微服务的目的是有效的拆分应用，实现敏捷开发和部署 。
（3）微服务提倡的理念团队间应该是 inter-operate, not integrate 。inter-operate是定义好系统的边界和接口，在一个团队内全栈，让团队自治，原因就是因为如果团队按照这样的方式组建，将沟通的成本维持在系统内部，每个子系统就会更加内聚，彼此的依赖耦合能变弱，跨系统的沟通成本也就能降低。
1.3 什么样的项目适合微服务 微服务可以按照业务功能本身的独立性来划分，如果系统提供的业务是非常底层的，如：操作系统内核、存储系统、网络系统、数据库系统等等，这类系统都偏底层，功能和功能之间有着紧密的配合关系，如果强制拆分为较小的服务单元，会让集成工作量急剧上升，并且这种人为的切割无法带来业务上的真正的隔离，所以无法做到独立部署和运行，也就不适合做成微服务了。
1.4 微服务开发框架 目前微服务的开发框架，最常用的有以下四个：
Spring Cloud：（现在非常流行的微服务架构）
Dubbo：
Dropwizard： （关注单个微服务的开发）
Consul、etcd&amp;etc.（微服务的模块）
2.什么是Spring Cloud Spring Cloud是一系列框架的集合。它利用Spring Boot的开发便利性简化了分布式系统基础设施的开发，如服务发现、服务注册、配置中心、消息总线、负载均衡、 熔断器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过SpringBoot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。
总的来说：
1.Spring Cloud并不是一种技术，是很多技术总称，很多框架
2.Spring Cloud里面有很多框架（技术），很多spring cloud里面的框架用于实现微服务框架
3.使用Spring Cloud，需要依赖技术spring boot
2.1 Spring Cloud和Spring Boot是什么关系 Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务，Spring Cloud是一个基于Spring Boot实现的开发工具；Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架； Spring Boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud很大的一部分是基于Spring Boot来实现，必须基于Spring Boot开发。可以单独使用Spring Boot开发项目，但是Spring Cloud离不开 Spring Boot。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b85748e87116cf1884a4a30d813bcd39/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/222/">«</a>
	<span class="pagination__item pagination__item--current">223/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/224/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>