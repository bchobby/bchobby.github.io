<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c2ae5ac1d88fa50dd69e07ea7c459b5/" rel="bookmark">
			大数据Hadoop学习之——好友推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、算法说明 好友关系如图：
1、直接相连的表示两个人是直接好友关系；
2、两个人有相同的好友表示两个人是间接好友（当然可能两个人同时也是直接好友，如图hello和hive）。
3、好友推荐列表就是按照两个用户的共同好友数量排名
二、MapReduce分析 1、分两步MapReduce计算完成；
2、第一步先得到用户的间接好友关系数目，注意有直接好友关系的用户需要过滤掉；
3、第二步根据间接好友关系数就可以得到用户推荐列表。
三、MapReduce实现 输入数据 tom hello hadoop cat word hadoop hello hive cat tom hive mr hive hello hive cat hadoop word hello mr hadoop tom hive word hello tom word hive mr 第一个是当前用户，后面的是其好友列表
第一步——计算好友间接关系数 一、mapper输出两种数据
1、对各用户的好友列表好友俩俩组合，输出间接好友关系；
2、当前用户和好友列表好友一一组合，输出直接好友关系。
注意！！！这里好友关系key需要顺序排序，避免重复记录，如hello:tom和tom:hello都表示同样两个人的关系。
public class FriendMapper extends Mapper&lt;LongWritable, Text, Text, IntWritable&gt; { private final Text text = new Text(); private final IntWritable mval = new IntWritable(); @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException { //样本数据：tom hello hadoop cat String[] users = StringUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c2ae5ac1d88fa50dd69e07ea7c459b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b45997efe1452a4eaa3f60b89d162d/" rel="bookmark">
			你确定 LinkedList 在新增/删除元素时，效率比 ArrayList 高？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每天早上七点三十，准时推送干货
在面试的时候都会被问到集合相关的问题，比如：你能讲讲 ArrayList 和 LinkedList 的区别吗？
那么我相信你肯定能够答上来：ArrayList 是基于数组实现的， LinkedList 是基于链表实现的
接下来面试官就会连环问了，那你能讲讲，它们都用在什么场景下吗？
阿粉知道这种程度肯定难不倒咱们读者的：因为 ArrayList 是基于数组实现的，所以在遍历的时候， ArrayList 的效率是要比 LinkedList 高的， LinkedList 是基于链表实现的，所以在进行新增/删除元素的时候， LinkedList 的效率是要比 ArrayList 高的
面试官：哦哦，好的，我大概了解了，我这边没有什么想问的了，您回去等消息可以吗
？？？发生了什么？
哈哈，上面模拟了一个面试场景，是想引出来这篇文章的主题：LinkedList 在新增/删除元素时，效率比 ArrayList 高，这是真的吗？
我相信你也知道套路，一般这么一问，那肯定就不是真的了
放一张图片，这是经过我测试之后的真实结果
因为微信不能放外链的缘故，可以在公众号后台发送 “20200821” 获取测试代码
ArrayList 与 LinkedList 新增元素比较 从图中可以看出来， LinkedList 在新增元素时，它的效率不一定比 ArrayList 高，这是要分情况的
如果是从集合头部位置新增元素的话，那确实是 LinkedList 的效率要比 ArrayList 高
但是如果是从集合中间位置或者是尾部位置新增元素， ArrayList 效率反而要比 LinkedList 效率要高
Excuse me ？竟然和我以前学的不一样？阿粉我学的浅，你别骗我
哈哈哈，为什么会这样呢
这是因为 ArrayList 是基于数组实现的嘛，而数组是一块连续的内存空间，所以在添加元素到数组头部时，需要对头部后面的数据进行复制重排，所以效率是蛮低的
但是 LinkedList 是基于链表实现的，在添加元素的时候，首先会通过循环查找到添加元素的位置，如果要添加的位置处于 List 前半段，那就从前向后找;如果位置在后半段，那就从后往前找，所以 LinkedList 添加元素到头部是非常高效的（小声 BB ，这我知道
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98b45997efe1452a4eaa3f60b89d162d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ba2dc38f48b661f31389b93d424652a/" rel="bookmark">
			定义一个日期类Date，包括年、月、日等私有数据成员。要求为所定义的Date类设计如下重载运算符函数：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题：
定义一个日期类Date，包括年、月、日等私有数据成员。要求为所定义的Date类设计如下重载运算符函数：
Date operator+（int days）；//返回一个日期加天数days后得到的日期
Date operator-（int days）；//返回一个日期减去天数days后得到的日期
Int operator-（Date&amp; b）；//返回两个日期相差的天数
#include&lt;iostream&gt; using namespace std; class Date { private: int year; int month; int day; public: Date(int, int, int); Date operator+(int days); Date operator-(int days); int operator-(Date&amp; b);//运算符重载 int getYear(); int getMonth(); int getDay();//访问器 }; Date::Date(int y = 0, int m = 0, int d = 0) :year(y), month(m), day(d) { }//初始化列表 Date Date::operator+(int days) { if (day + days &gt; 30) { month++; if (month &gt; 12) { month = 1; year++; } day = day + days - 30; } else { day += days; } return *this; }//运算符重载“+”，几天后的天数 Date Date::operator-(int days) { if (day - days &lt; 0) { month--; if (month == 0) { month = 12; year--; } day = day - days + 30; } else { day -= days; } return *this; }//运算符重载“-”，几天前的天数 int Date::operator-(Date&amp; b) { int tmpdays1 = year * 360 + month * 30 + day; int tmpdays2 = b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ba2dc38f48b661f31389b93d424652a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26a4ea1deb0db2e4a50d974e88632c62/" rel="bookmark">
			定义一个Student类，在该类定义中包括：两个数据成员name（学生姓名）和score（分数）；两个静态数据成员total（总分）和count（学生人数）。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题：
定义一个Student类，在该类定义中包括：两个数据成员name（学生姓名）和score（分数）；两个静态数据成员total（总分）和count（学生人数）。成员函数scoretotalcount（float s）用于设置每个学生的分数；静态成员函数sum（）用于返回总分；静态成员函数average（）用于求分数平均值。在main函数中，输入某班同学的成绩（班级学生人数随个数录入情况自动增加），并调用上述函数求全班学生的总分和平均分。``
#include&lt;iostream&gt; using namespace std; class Student { public: Student(string); static float total; static int count;//定义静态数据成员 void scoretotalcount(float s); static float sum(); static float average();//定义静态成员函数 private: string name; float score; }; int Student::count = 0; float Student::total = 0; Student::Student(string name) { this-&gt;name = name; count++;	}//录入学生姓名 void Student::scoretotalcount(float s) { score = s; total += s; }//录入学生成绩并随录入计算总分 float Student::sum() { return total; }//返回全班总分 float Student::average() { return total / count; }//返回全班平均分 int main() { Student student1("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26a4ea1deb0db2e4a50d974e88632c62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4a3ae8a747b6b9c32676de6103f03cc/" rel="bookmark">
			设计一个名为Person的类，并设计两个Person的派生的类Student和Employee。Employee的Faculty和Staff的派生类。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题：
设计一个名为Person的类，并设计两个Person的派生的类Student和Employee。Employee的Faculty和Staff的派生类。Person类具有name，address，phone number和e-mail。Student具有freshmen， sophonore, junior, or senior四个状态。Employee有office，salary和datehired。定义一个名为MyDate的类，其中包含year，month和day字段。Faculty有officehour和rank。Staff有title。在Person类中定义一个常量虚拟toString函数，并在每个类中覆盖它以显示类名和人名。
实现类。编写一个测试程序，创建一个Person，Student，Employee，Faculty和Staff，并调用它们的toString（）函数。
题解：通过继承从基类中派生获取基类的函数等，在派生类中可以设计属于自己的函数可来区别于父类，达到自己的特色，用虚函数和动态绑定来实现tostring（）函数的功能。
#include&lt;iostream&gt; using namespace std; class Person { public: Person() { name = "0"; address = "0"; number = 0; mail = "0"; }//无参构造函数 /*Person(string name, string address, int number, string mail) { this-&gt;name = name; this-&gt;address = address; this-&gt;number = number; this-&gt;mail = mail; }*/ Person(string name) { this-&gt;name = name; } void setAddress(string address) { this-&gt;address = address; }//设置地址 void setNumber(int number) { this-&gt;number = number; }//设置电话号码 void setMail(string mail) { this-&gt;mail = mail; }//设置邮箱地址 string name; string address; int number; string mail; virtual string toString() const { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4a3ae8a747b6b9c32676de6103f03cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f28bbbc0089b074cf9d91f13fc21adde/" rel="bookmark">
			js计算数组中每个元素出现的次数（2种方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 var names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice']; var countedNames = names.reduce((obj, name) =&gt; { if (name in obj) { obj[name]++ } else { obj[name]=1 } return obj }, {}) //reduce的第二个参数就是obj的初始值 console.log(countedNames) // { 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 } 二 function getEleNums(data) { var map = {} for (i = 0; i &lt; data.length; i++) { var key = data[i] if (map[key]) { map[key] += 1 } else { map[key] = 1 } } return map } var data = ['b','a','c','a','b','b','b','c','c','a','c','a','a','a','b','c'] console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f28bbbc0089b074cf9d91f13fc21adde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59d871b6a1309eaf1f53e0e19daf0041/" rel="bookmark">
			anaconda 安装 PuLP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 Ananconda Prompt 中输入
搜索pulp包 anaconda search -t conda pulp 2. 展示安装方式
anaconda show conda-forge/pulp 安装 conda install --channel https://conda.anaconda.org/conda-forge pulp 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81d1cf3fa90caf697e1719c10693f676/" rel="bookmark">
			Ubuntu下UMFPACK安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 记录程序人生
环境：linux 我用的是 ubuntu 16.04
具体步骤：
1 . 下载ubuntu下的umfpack包
sudo apt-get install libsuitesparse-dev sudo apt-get install libsuitesparse-doc 2 . 在程序中添加umfpack头文件
#include &lt;suitesparse/umfpack.h&gt; 3 . 在编译时链接umfpack库
-lumfpack 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30ef686c8fb52fea14b518344cb5da4b/" rel="bookmark">
			stm32从bootloader跳转到app不进中断问题分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、设置VECT_TAB_OFFSET，在system_stm32fxxx.c中。
在keil中这样设置，可以通过target的设置自动设置VECT_TAB_OFFSET大小。 extern int Image$$ER_IROM1$$Base; #define VECT_TAB_OFFSET ((uint32_t)&amp;Image$$ER_IROM1$$Base) 2、bootloader中开了某个中断，但在app中没有开或没有相应的中断入口。
3、bootloader在跳转前关闭总中断，app中忘记打开总中断
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d1f3e747c32e26d6b5d7f443ec2e2cd/" rel="bookmark">
			定时任务最简单的3种实现方法（超好用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是我的第 86 篇原创文章
作者 | 王磊
来源 | Java中文社群（ID：javacn666）
转载请联系授权（微信ID：GG_Stone）
定时任务在实际的开发中特别常见，比如电商平台 30 分钟后自动取消未支付的订单，以及凌晨的数据汇总和备份等，都需要借助定时任务来实现，那么我们本文就来看一下定时任务最简单的几种实现方式。
TOP 1：Timer Timer 是 JDK 自带的定时任务执行类，无论任何项目都可以直接使用 Timer 来实现定时任务，所以 Timer 的优点就是使用方便，它的实现代码如下：
public class MyTimerTask { public static void main(String[] args) { // 定义一个任务 TimerTask timerTask = new TimerTask() { @Override public void run() { System.out.println("Run timerTask：" + new Date()); } }; // 计时器 Timer timer = new Timer(); // 添加执行任务（延迟 1s 执行，每 3s 执行一次） timer.schedule(timerTask, 1000, 3000); } } 程序执行结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d1f3e747c32e26d6b5d7f443ec2e2cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f40edb4b1670714b14f60e4648da460/" rel="bookmark">
			springboot之http头中返回码-301,302,304
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3xx-返回码简单介绍
301：资源已经永久迁到新的地址，新的URL会在响应头中返回 302：资源临时被迁到新的地址，新的URL会在响应头中返回 304：表明资源未改变。主要配合请求头中的If-None-Match和If-Modified-Since使用 1.pom.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.ma&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 2.启动类配置
package com.ma.demo; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.Bean; import org.springframework.web.filter.OncePerRequestFilter; import org.springframework.web.filter.ShallowEtagHeaderFilter; /** * created by &lt;a href="mailto:18045142590@163.com" &gt; mameng &lt;/a&gt; */ @SpringBootApplication public class DemoApplication { public static void main(String[] args) { SpringApplication.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f40edb4b1670714b14f60e4648da460/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8634037f214f30bfb26cb9d49970d052/" rel="bookmark">
			字，字节，位的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、位（bit） 来自英文bit，音译为“比特”，表示二进制位。位是计算机内部数据储存的最小单位。
2、字节（byte） 字节来自英文Byte，音译为“拜特”，习惯上用大写的“B”表示。 字节是计算机中数据处理的基本单位。
3、字 （word）计算机进行数据处理时，一次存取、加工和传送的数据长度称为字。一个字通常由一个或多个（一般是字节的整数位）字节构成。
论据：
先看一段摘抄自《Computer system: a programmer’s perspective》的说明：
Buses are typically designed to transfer fixed-sized chunks of bytes known aswords. The number of bytes in a word (the word size) is a fundamental system parameter that varies across systems. Most machines today have word sizes of either 4 bytes (32 bits) or 8bytes (64 bits).
翻译过来就是说：总线一般被设计来传输固定大小的一块数据，这块数据被称为字(word),一个字包含的字节数(即字的大小)是各种计算机系统里面的基本参数，而且这个参数在不同的系统里通常是不同的。大多数的现代计算机系统里面，一个字要么是4个字节（32位），要么是8个字节（64位）.
结论：
一个字等于多少个字节，与系统硬件（总线、cpu命令字位数等）有关，不应该毫无前提地说一个字等于多少位。
①：1字节（byte） = 8位（bit）
②：在16位的系统中（比如8086微机） 1字 （word）= 2字节（byte）= 16（bit）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8634037f214f30bfb26cb9d49970d052/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdcbd854e5bfbd6700f9d626344e144f/" rel="bookmark">
			简单了解一下电商系统中的SPU、SKU、ID，它们都是什么意思，三者又有什么区别和联系呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、SPU：标准化产品单元三、SKU：库存量单位四、小总结 一、前言 电商时代，数据为王。
所以电商人入门要懂的第一课，通常会涉及到各种常用名词，UV、PV、GMV、CPC、CPS、CPA、CPM等等，这里对比一下几个常见的产品名词，SPU、SKU、ID，它们都是什么意思，三者又有什么区别和联系呢？
首先，无论是哪一个电商平台，都是有spu和sku的，只是叫法会不同，以淘宝和京东为例，商品，淘宝叫item，京东叫product。所以淘宝我们虽然看不到spu，但有商品ID。
二、SPU：标准化产品单元 SPU，是standard product unit，标准化产品单元，是商品信息聚合的最小单位，属性值、特性相同的商品就可以成为一个SPU。（在淘宝看不到spu这个概念，淘宝商品都拥有商品ID(item design)，相当于spu）。SPU 属性(不会影响到库存和价格的属性, 又叫关键属性)。
SPU是用来定位的，京东前台看不到单品的spu是多少，想查看只能到店铺后台中查看，淘宝是可以在前台链接中看到该商品的ID的，比如：
这是天猫的一款产品点击主图后进入的页面，最后是id=544576894375，这个是商品的id，在出售中的宝贝中也可以看到：
而京东的spu就需要到京东后台查看了：
这个是商智系统，当然后台商品管理里面也是可以看到的，这里写的是商品编码，也就是spu。
三、SKU：库存量单位 SKU=stock keeping unit(库存量单位)
SKU是用来定价和管理库存的，7Plus有很多颜色，很多配置，每个颜色和配置的组合都会形成新的产品，这时就产生很多SKU，sku在传统线下行业也是一个非常常用的概念，尤其是服装行业，同款不同尺码不同色都是独立的SKU，需要有独立的条形码，独立的库存管理等。
SKU是物理上不可分割的最小存货单元。也就是说一款商品，可以根据SKU来确定具体的货物存量。SKU 属性(会影响到库存和价格的属性, 又叫销售属性)。
如一件M码（四个尺码：S码、M码、L码、X码）的粉色（三种颜色：粉色、黄色、黑色）Zara女士风衣，其中M码、粉色就是一组SKU的组合。
SKU在生成时，会根据属性生成相应的笛卡尔积，根据一组SKU可以确定商品的库存情况，那么上面的Zara女士风衣一共有4 * 3 = 12个SKU组合。
M码+粉色 这两个属性组合被称为一组SKU、因为SKU是物理上不可分割的最小存货单元，单凭尺寸或者颜色是没有办法确认这款商品的库存情况。
同理商家进货补货也是通过SKU来完成的，试问淘宝店家跟供货商说我要100件红色女士风衣？供应商知道该怎么给他备货吗？
显然是不知道的。因为还欠缺了另外的一个销售属性【尺码】。
在京东，所有的商品在前台都是看不到spu值的，链接中都是直接显示sku。
在淘宝，可以从链接中看出ID和sku两个值。
刚才我们举例的这个商品，这个商品其实是有多个颜色的，接下来我们选择其中的一个颜色，比如青色：
选择后，我们发现顶部的链接发生的变化，&amp;id=544576894375&amp;skuId=3281815068747刚才的id后，又出现了skuId。
四、小总结 1）SKU（或称商品SKU）指的是商品子实体。
2）商品SPU和商品SKU是包含关系，一个商品SPU包含若干个商品SKU子实体，商品SKU从属于商品SPU。
3）SKU不是编码，每个SKU包含一个唯一编码，即SKU Code，用于管理。
4）商品本身也有一个编码，即Product Code，但不作为直接库存管理使用
iPhone 7 Plus 就是一个独立的SPU，爱普生6721墨水也是一个SPU，至于7 plus还有各种颜色，各种配置，墨水有多种颜色，那都是SKU的事情了。统计销售数据，我们通常用到的是SPU，比如我想知道7plus卖了多少台，我通过SPU来查看；但分析客户和市场，通常用SKU更多，比如我想看7plus哪个颜色和配置更受买家欢迎，肯定要用的SKU。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c683a4114e07711e94a24113bed5c1b2/" rel="bookmark">
			.Net Framework Cookie 和 JS localStorage使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.Net Framework Cookie 和 JS localStorage使用 背景：
下载万方文档，要求每月有次数限制，超过20次不可以下载，
以前是每点一次在线阅读，下载全文都计数，并且有重复记录的bug。
解决方案
引入Cookie，将文献ID和到期时间记录到Cookie，五分钟内针对同一篇文章不做计数，五分钟以后重新计数并及重新计时。
原理
Cookie设置到期时间后，到期自动清除，并不受用户关闭浏览器影响。
Code
private bool IsAddCount(HttpContext context) { string id = HttpUtility.UrlDecode(context.Request["id"]), title = HttpUtility.UrlDecode(context.Request["title"]); //读取Cookie, 过期浏览器自动清除, 5min之内不计入次数 if (context.Request.Cookies["wfArticle_" + id] != null) { var sessionid = context.Request.Cookies["wfArticle_" + id]; return false; } else { //过期重新记录 System.Web.HttpCookie newcookie = new HttpCookie("wfArticle_" + id); newcookie.Values["id"] = id; newcookie.Values["title"] = title; newcookie.Expires = DateTime.Now.AddMinutes(5); context.Response.AppendCookie(newcookie); } return true; } Cookie时间没法从浏览器传到后台，浏览器只根据过期时间管理Cookie
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c683a4114e07711e94a24113bed5c1b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac2016752464cafa52721b1eedc90981/" rel="bookmark">
			idea中导入项目后main方法无法Run
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题:如截图所示,红色框处并未出现run按钮,无法运行
2.解决办法:调试run按钮
2.1)如图所示,进行如下两步操作,先点击自己的项目,再点击Open Module Settings
2.2点击Sources,别忘了点击右下角的Apply或OK
2.3就这样Run按钮就调试出来了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae129ad499a56c1b730be0096ba3122b/" rel="bookmark">
			bmap.geocoder_使用Geocoder PHP和Leaflet.js进行映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bmap.geocoder
Interactive maps inside a web application have a lot of great uses. From visualizing data to highlighting points of interest, maps are expected to communicate ideas within the context of location easily. Web应用程序中的交互式地图有很多用途。 从可视化数据到突出显示兴趣点，人们期望地图可以在位置范围内轻松传达想法。 The hardest part, however, is converting that data into coordinates that the map can understand. Luckily, Geocoder PHP allows us to connect to different geo-coding providers. Combined with Leaflet.js, a simple Javascript library, creating maps is a breeze.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae129ad499a56c1b730be0096ba3122b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47ebd0db455c2f5284c602cc634a091b/" rel="bookmark">
			使用Nginx的Docker镜像部署前端项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前项目开发方式基本采用前后端分离的方式。前端作为一个独立的项目，一般是使用Webpack方式进行编译打包生成 dist 目录（特指vue项目），再通过Nginx单独进行部署。
为了和基于Docker的部署方式有个对比，我们先来说下服务器部署方式
服务器部署方式 一般来说，常规的部署方式的流程基本如下：
服务器环境配置及安装 nginx将项目dist目录上传到服务器的指定位置修改 nginx安装目录/conf/nginx.conf 文件，配置dist目录及后端项目的代理地址启动nginx
ok搞定，说起来很简单，其实最繁琐的操作基本是在第1步，nginx安装及环境配置。
为了解决环境难的问题，锵锵锵，上docker 基于Docker的部署方式 基于Docker的部署方式可以简单分为两种，一种是直接使用原生的nginx镜像进行部署，一种是通过构建新的业务镜像进行部署。
使用原生的nginx镜像进行部署 这种方式和 服务器部署方式 基本类似。基本流程如下：
将项目dist目录上传到服务器的指定位置（eg: /home/dist）准备好已经配置了 dist 目录及后端项目代理地址的 nginx.conf（eg: /home/nginx.conf）拉起nginx镜像，通过挂载数据卷将 dist目录以及事先准备好的nginx.conf挂在到nginx容器中（eg: docker run -d -v /home/dist:/dist -v /home/nginx.conf:/etc/nginx/nginx.conf -p 8088:80 nginx:latest）
ok搞定，访问 ip:8088即访问前端项目。 通过构建新的业务镜像进行部署 “使用原生的nginx镜像进行部署”的方式对比“服务器部署方式”来说是方便了一点，但是，部署时还要搞下dist目录，再搞下nginx.conf，这好像也有丢丢麻烦。咋办呢？
主角出场：构建新的业务镜像进行部署
问：为什么要这么做？
答：前端项目部署，说到底无非就是准备好dist目录以及在nginx.conf配置后端项目的地址。对于dist目录，静态目录完全可以预先放置在镜像中；而配置后端项目地址，其实就是一个值的问题，完全可以把这个值抽取成镜像中的一个环境变量。既然相关的步骤都能支持，直接构建一个新的镜像，部署时只需要配置个环境变量，舒舒服服，何乐而不为呢
具体操作
编写 nginx.conf.template（配置dist目录、后端项目地址抽取为环境变量） user nginx; worker_processes 1; error_log logs/error.log error; pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; log_format combined '$remote_addr - $remote_user [$time_local] ' '"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47ebd0db455c2f5284c602cc634a091b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dee305452b4416036500fe0d6889826/" rel="bookmark">
			FPGA学习日记（七）HDMI图像数据传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实现目标
将像素数据通过HDMI传输，在显示器上显示。
二、数据流传输
HDMI常采用TMDS传输（上升沿复位）方式：
（1）通过三个通道分别可传入8位的rgb视频信号，2位的控制信号，4位的音频信号或其他数据信号，其中行场同步信号在blue的控制信号中传输；
（2）在encode编码器这端，将输入的8位视频信号通过TMDS算法转换为10位的视频信号输出到并串转换模块；
（3）在并串转换模块中将输入的10位数据转为串行数发送到接受设备。
三、数据流传输实现
顶层模块，使用差分输出原语OBUFDS，p端口输出数据与输入数据相同，n端口输出相同时钟下的反相数据。
// Descriptions: DVI发送端顶层模块 module dvi_transmitter_top( input pclk, // pixel clock input pclk_x5, // pixel clock x5，ddr模式只需*5 input reset_n, // reset input [23:0] video_din, // RGB888 video in input video_hsync, // hsync data input video_vsync, // vsync data input video_de, // data enable output tmds_clk_p, // TMDS 时钟通道 output tmds_clk_n, output [2:0] tmds_data_p, // TMDS 数据通道 output [2:0] tmds_data_n, output tmds_oen // TMDS 输出使能 ); //wire define wire reset; //并行数据 wire [9:0] red_10bit; wire [9:0] green_10bit; wire [9:0] blue_10bit; wire [9:0] clk_10bit; //串行数据 wire [2:0] tmds_data_serial; wire tmds_clk_serial; //***************************************************** //** main code //***************************************************** assign tmds_oen = 1'b1; assign clk_10bit = 10'b1111100000; //异步复位，同步释放,TMDS协议中复位信号为高 asyn_rst_syn reset_syn( .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dee305452b4416036500fe0d6889826/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86503c91f2c116fbc9110e13083953a/" rel="bookmark">
			Siddhi（一）能力及架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 author: mys
since: 2020-07
一、介绍： Siddhi是一个流处理和复杂的事件处理平台，可用于构建成熟的事件驱动的应用程序。它可以嵌入Java和Python应用程序中，作为微服务在裸机，VM或Docker上运行，并且可以在Kubernetes中大规模运行。
二、架构和能力： 1、概念： 事件:
Siddhi是一个事件驱动的系统，其中所有消耗，处理和发送的数据都被建模为事件。因此，Siddhi在任何事件驱动的体系结构中都可以发挥至关重要的作用。
如果我们将通过ATM进行的交易视为数据流，那么从其中进行的一次提取就可以视为一个事件。此事件包含诸如金额，时间，帐号等数据。许多此类交易形成一个流。
Siddhi Application：
Siddhi Application是类似于SQL的脚本，具有.siddhi文件扩展名。定义Siddhi的实时处理逻辑，包含消费者(sources), 生产者(sinks), 流, 查询, 表, 方法以及其他必要的约定，这些约定描述了事件的消耗，处理和发布方式。
需按照Siddhi Streaming SQL语法编写Siddhi应用程序，siddhi提供丰富的函数以及api，并支持扩展。
2、能力： 如上所述，Siddhi可以：
接受来自许多不同类型来源的事件输入，包括nats、kafka、tcp、http、file等等，以及不同的数据格式，包括json、text、xml、key-value等；处理事件并进行转化，分析，分析方法支持模式分析、序列分析、增量聚合、机器学习等等；将事件发布到多种类型的接收器，包括nats、kafka、http、file等等； siddhi工作流程，启动Siddhi应用程序后：
（1）按照事件的顺序，依次消费数据；
（2）将事件传递给相应的查询处理；
（3）根据逻辑完成的处理生成新事件；
（4）通过输出将新生成的事件发送到流；
3、Streaming SQL Siddhi Streaming SQL旨在处理事件流。可用于实现流数据集成，流分析，基于规则和自适应决策制定，是复杂事件处理（CEP）和流处理系统的演进，也可用于处理状态计算，检测复杂事件模式以及实时发送通知。
Siddhi Streaming SQL使用类似于SQL的语法和注释来消费来自具有各种数据格式的各种事件源的事件，然后使用有状态和无状态运算符进行处理，并将输出发送到多个端点。
下图描述了Siddhi Application的一些关键Siddhi Streaming SQL元素以及事件如何流经这些元素
通过Sources、inputt Handlers将事件输入到事件流中，使用事件查询结合窗口、数据表、聚合、分区等多种处理方式，生成复杂事件，流入下一个处理流程或通过sink输出。
关键元素：
元素描述Stream事件流，逻辑上按时间顺序排列的事件系列，具有唯一可识别的名称，以及定义其模式的一组定义的类型化属性。Event事件是与流关联的单个事件对象。流的所有事件均包含时间戳和基于它们所属流的模式的相同类型的属性集。table用定义的模式存储的数据的结构化表示。存储的数据可通过进行备份In-Memory，或外部数据存储诸如RDBMS，MongoDB等中的表可以被访问并在运行时操作。Named-Window命名窗口：使用定义的架构和驱逐策略存储的数据的结构化表示。窗口数据将被存储，In-Memory并通过命名窗口约束自动清除。其他siddhi元素只能在运行时查询Windows中的值，但不能修改它们。Named-Aggregation命名聚合：数据的结构化表示，以定义的架构和聚合粒度（例如秒，分钟，小时等）进行增量聚合和存储。聚合数据既存储又存储In-Memory在外部数据存储中，例如RDBMS。其他siddhi元素只能在运行时查询Windows中的值，但不能修改它们。Query一种逻辑构造，通过使用一个或多个流，表，窗口和聚合中的数据以流方式处理事件，并将输出事件发布到流，表或窗口中。Source事件源，其从外部源消耗的数据（如TCP，Kafka，HTTP等）与各种事件格式，例如XML，JSON，binary等，然后转换为西提事件，并进入用于处理流。Sink消费事件，映射到一个预定的数据格式（如XML，JSON，binary等等），并且将它们发布到外部端点（例如E-mail，TCP，Kafka，HTTP，等等）。Input Handler输入处理程序，一种以编程方式将事件注入流中的机制。Stream/Query Callback使用流或查询中的输出事件的机制。Partition一个逻辑容器，它基于从事件派生的分区键来隔离查询的处理。Inner Stream在分区中将部分查询彼此连接的可定位流。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da09e7b4d10e2943e6928a8ef3f5d050/" rel="bookmark">
			设计一个简单的计算器程序，用户输入运算数和四则运算符，输出计算的结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; int main() { float x, y; char c; while(scanf("%f %c %f", &amp;x, &amp;c, &amp;y) == 1); { switch (c) { case '+':printf("%f", x + y); break; case '-':printf("%f", x - y); break; case '*':printf("%f", x * y); break; case '/':if (y != 0) printf("%f", x / y); else printf("分母不能为0"); break; default:printf("Error"); break; } } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8379703800b9d1455db85fb254b713c9/" rel="bookmark">
			scala之语法基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		author: mys
since: 2020-08-13
一、 简介： Scala 也是一种函数式语言，函数是 Scala 语言的核心。
二、基础语法： scala hello world ：
object HelloWorld { def main(args: Array[String]) :Unit={ println("Hello, world!") // 输出 Hello World } } object关键字定义了一个单例对象
1、数据类型： 与java相似，少部分有区别。Any是其他类的超类，Unit等同于Java的void。
数据类型描述Byte8位有符号补码整数。数值区间为 -128 到 127Short16位有符号补码整数。数值区间为 -32768 到 32767Int32位有符号补码整数。数值区间为 -2147483648 到 2147483647Long64位有符号补码整数。数值区间为 -9223372036854775808 到 9223372036854775807Float32 位, IEEE 754 标准的单精度浮点数Double64 位 IEEE 754 标准的双精度浮点数Char16位无符号Unicode字符, 区间值为 U+0000 到 U+FFFFString字符序列Booleantrue或falseUnit表示无值，和其他语言中void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成()。Nullnull 或空引用NothingNothing类型在Scala的类层级的最底端；它是任何其他类型的子类型。AnyAny是所有其他类的超类AnyRefAnyRef类是Scala里所有引用类(reference class)的基类 2、变量声明： 在 Scala 中，使用关键词 “var” 声明变量，使用关键词 “val” 声明常量。
声明语法为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8379703800b9d1455db85fb254b713c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e979a6795420cecc771b50be98bb4dd5/" rel="bookmark">
			CUDA与cuDNN 关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CUDA与cuDNN 1、什么是CUDA
CUDA(ComputeUnified Device Architecture)，是显卡厂商NVIDIA推出的运算平台。 CUDA是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。
2、什么是CUDNN
NVIDIA cuDNN是用于深度神经网络的GPU加速库。它强调性能、易用性和低内存开销。NVIDIA cuDNN可以集成到更高级别的机器学习框架中，如谷歌的Tensorflow、加州大学伯克利分校的流行caffe软件。简单的插入式设计可以让开发人员专注于设计和实现神经网络模型，而不是简单调整性能，同时还可以在GPU上实现高性能现代并行计算。
3、CUDA与CUDNN的关系
CUDA看作是一个工作台，上面配有很多工具，如锤子、螺丝刀等。cuDNN是基于CUDA的深度学习GPU加速库，有了它才能在GPU上完成深度学习的计算。它就相当于工作的工具，比如它就是个扳手。但是CUDA这个工作台买来的时候，并没有送扳手。想要在CUDA上运行深度神经网络，就要安装cuDNN，就像你想要拧个螺帽就要把扳手买回来。这样才能使GPU进行深度神经网络的工作，工作速度相较CPU快很多。
引自：
链接：https://www.jianshu.com/p/622f47f94784
可看详细内容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2ce690b561d1903628cd9ac028fc92c/" rel="bookmark">
			VoLTE业务端到端流程：无线侧信令流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、主被叫接入 该过程主要是终端 INVITE 消息触发 LTE 底层随机接入、 RRC 建立及QCI5/QCI9 的承载建立，主/被叫一致，以主叫为例信令流程如下：
主要消息内容解析：
消息序号消息名称内容/作用0SIP INVITE: Request主被叫的号码， 语音的编码速率协商1MIB/SIB获取接入网络需要的基本信息2Random Access Request随机接入请求3Random Access Response随机接入响应4RRC Connection RequestRRC 建立请求5RRC Connection SetupSRB1 建立， MAC 层配置， 功控信息，
CQI 等6RRC Connection Setup CompleteRRC 建立完成7Initial 终端 Message基站发起初始接入消息8Initial 终端 Context Request核心网触发终端上下文请求， 恢复
SRB2、 QCI5/9 承载9Security Mode Command安全模式命令10Security Mode Complete安全模式完成11RRC Con ReconfigurationSRB2、 QCI5/9 承载建立12RRC Con Reconfiguration ComQCI5/9 承载建立完成13Initial 终端 Context
Response基站反馈上下文建立完成给核心网14SIP INVITE: Trying 100终端收到 IMS 反馈的 100 trying 临
时响应 2、被叫寻呼流程 主要消息内容解析：
消息序号消息名称内容/作用0PagingEPC 接受到 INVITE 后，存储起来，触发基站
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2ce690b561d1903628cd9ac028fc92c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/830ea3e9975771032abecfd982e11602/" rel="bookmark">
			SQL工具导出CSV文件中文乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DBeaver 导出CSV文件中文乱码 相信在做IT开发的人都碰到过，中文乱码的问题。特别是做数据的工程是，经常有用sql查出一批数据后，要导成CSV文件时，发现导出的信息中，中文都是乱码；便会在网上各种查询处理方案，然后会搜索到一大堆没有治标不治本的方法。
使用DBeaver导出的乱码数据 真实数据确实如下 碰到这种乱码情况怎么办呢？其实只需要在导出时设置一个参数勾选即可（插入BOM）。
导出步骤：
第一步：
第二步：
第三步：导出时选择编码 UTF-8，并且勾选"插入BOM"，然后下一步完成即可。
解释CSV读取数据的原理，以便于碰到csv打开乱码的其他问题。
原理：
Excel在读取csv的时候是通过读取文件头上的bom来识别编码的，如果文件头无bom信息，则默认按照unicode编码读取。这个bom是微软自己定义的一种文件头部协定，存储内容就是标识文件编码的信息，这个BOM 头在被其他的表格展示器（比如 Numbers 或者 Libre Office）打开的时候会被忽略，但对 Excel 就不一样了。我们在生成csv的平台不一定遵循微软的bom协议，导致如果输出非unicode编码的csv文件（例如utf-8），并且没有生成bom信息的话，Excel自动按照unicode编码读取，就会出现乱码问题了。所以只需将非unicode编码的csv文件，用文本编辑器（推荐notepad++）打开并转换为带bom的编码形式（具体编码方式随意），问题解决，变不会乱码。
开发代码层面生成CSV文件，注意设置如下参数：
//代码层面生成csv文件的地方加上如下所示 // 产生 CSV 的过程，body: string[][], header: string[] const csv = body.reduce((prev, current) =&gt; `${prev}\r\n${current}`, header); const BOM = Buffer.from('\uFEFF'); // 设置BOM头 const bomCsv = Buffer.concat([BOM, Buffer.from(csv)]); return bomCsv.toString(); 该文仅为做一个笔记，供自己查阅，请大神勿喷，谢谢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36ed04d497838bbba531f140bee9433d/" rel="bookmark">
			常见几种电子称设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几种常见电子称基本操作：
大华秤修改ip：功能---9002---确定---192-- 去皮---168-- 去皮---1-- 去皮---110---确定
设置称纸条码前两位显示：功能----39706---确认---按置零两次---22（结合自己需要的修改）---确认
奈克斯修改ip：长按设置键----3---1---shift---150---确认---plu----输入ip---确认
寺岗秤修改ip：
按住置零不放按3752---接着再按住置零不放按141---接着输入ip----#---确定---退出。
太航秤设置ip：9999---模式---1---输入---5---输入---ip地址（192168001250）---输入
友声秤设置ip：按住快速编程不放按编程---同时放开-接着---X---150---确认---192--向右箭头---168---向右箭
头...---修正---销售
友声秤修改一系列秤设置：按编程---12---X---203(查看传秤工具里面的数据参数id)---确认---1---修正---销售
寺岗秤调试时间：
1、按3下“方式”键,切换到S模式。 显示： S1 à PLU FILE
2、按8，接着按打印
3、输入你现在的正确日期（YYMMDD）,再按“打印”键
4、输入你现在的正确时间（HHMM），再按“打印”键
5、按“方式”键退出
托利多
托利多管理员操作：菜单——246813——确定 之后需要修改什么设置按上下标志选择
托利多电子秤可通过设置密码的方式，防止操作人员zhi随意改价，步骤如下：
1、按“代码”“24681357”“*”“27”“*”（输入6位数字密码，第一位不能为0）；
2、输入27显示“修改口令 27”；
3、提示输入6位新密码；
4、提示再次输入6位密码即可完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ba9e22e791c54cbc3bf3460b4ccc53f/" rel="bookmark">
			力扣【19】删除链表的倒数第N个节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目:
给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
进阶：你能尝试使用一趟扫描实现吗？
示例 1：
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
示例 2：
输入：head = [1], n = 1
输出：[]
示例 3：
输入：head = [1,2], n = 1
输出：[1]
题解
方法一：//倒数第n个，也就正数第length() - n + 1个，这我倒是想到了，就是忘了怎么找到第n个节点了。// 定义一个新节点用来指向结果链表的头节点，这个我也想到了。
我没有想到使用while来找到链表的长度，使用for循环找到第n个节点的长度。
package test; class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { // 定义一个新节点用来指向结果链表的头节点。 ListNode node = new ListNode(0);//定义一个新节点不要忘了幅值0 // 将新节点指向当前链表的头节点。 node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ba9e22e791c54cbc3bf3460b4ccc53f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06e1caa90eda98e0f9ae4f61e0f33219/" rel="bookmark">
			DB2联邦数据库的创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DB2联邦数据库创建 1、环境 本地：
1）IP：192.168.174.15
2）数据库名称：test
3）数据库用户：db2inst1
远程（被访问机器）：
1）IP：192.168.174.15
2）端口号：56600
3）数据库名称：sample
4）数据库用户：db2dis
2、服务器信息设置 1、查看本地数据库联邦参数是否开启
db2 get dbm cfg | grep -i FEDERATED 如果查询结果为NO，设置为YES
db2 update dbm cfg using federated yes 2、重启实例
db2 force application all //关闭所有连接 db2stop db2start //重启实例 3、远程数据库全局设置如下
db2set 指定当启动数据库管理器时所启动的通信管理器
3、开始编目 1、在本地进行远程数据库的节点编辑
db2 catalog tcpip node node2 remote 192.168.174.15 server 56600 db2 terminate 创建语法：
db2 catalog tcpip node 远程节点名（字符长度不超过8位） remote 远程IP server 远程端口号
2、在本地编目远程数据库
db2 catalog db sample as sample2 at node node2 authentication server db2 terminate 创建语法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06e1caa90eda98e0f9ae4f61e0f33219/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75d86e62ff93845917a86f72dbfd2767/" rel="bookmark">
			MacOS 环境下SBDART模式安装与实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 SBDART（平面平行辐射传输模式）是一种软件工具，用来计算地球大气和表面在无云和多云条件下的平面平行辐射传输。对于该程序的一般性描述和评论请参阅Ricchiazzi在1998年的说明。
网络上搜索可以找到其在线版本或者Matlab版本，遗憾的是这两种都已经无法使用。下面将对离线版本进行编译使用。SBDART是由FORTRAN编写的辐射传输模型，在安装前需要配置FORTRAN开发环境，在上一篇博文中已经有详细的介绍。接下来将围绕SBDART的安装和测试进行。
下载与编译安装 下载 打开Github搜索SBDART，第一个就可以看到paulricchiazzi发布的程序。
点开可以看到自带了安装说明，安装方法是比较简单的，前提是所需的编译环境都以安装好，否则编译室不可能过的。下载后解压可以看到：
编译安装 (1) 打开终端，设置工作路径，在终端中输入下面命令，回车
cd 解压后的SBDART-master路径 (2) 输入make，回车，进行编译，约5秒钟编译结束，如果提示需要命令行工具就安装即可，或者terminal中执行：xcode-select --install 然后点击 “安装”。
编译完成可以看到生成的sbdart程序。
(3) 测试，因为是Fortran的可执行程序，因此，终端中输入./sbdart就可以调用该程序。
(4) 打开TestRuns文件，修改其中的sbdart程序路径后就可以运行。
通过Python代码生成UI，通过图形交互的方式使用SBDART MacOS自带了Python2.7，就不需要重新安装Python以及配置环境了。打开RunRT文件夹找到，RunRT.py文件，修改第29行代码，将变量sbdartexe的值赋值为刚才编译生成的sbdart绝对路径。
接下来在终端输入如下命令
生成UI界面
例子 例1 计算波长0.25至1微米区间，大气顶和表面（大气底）辐照度。
INPUT文件参数：
$input idatm=4, isat=0, wlinf=.25, wlsup=1.0, wlinc=.005, iout=1, $end 效果：
例2 #!/local/gnu/bin/bash ############################################################ # shell script for Example 2 # vary optical depth and surface albedo ############################################################ # rm -f sbchk.2 foralbconin0.2.4.6.81 ;do for tcloud in 0 1 2 4 8 16 32 64 ; do echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75d86e62ff93845917a86f72dbfd2767/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1af10776e15866b48ca3f56b099921de/" rel="bookmark">
			git重置用户git账号与密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、git config --system --unset credential.helper
2、git config --global credential.helper store
3、git pull
输入用户名(邮箱)+密码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/670dad785436e7023244bad255d3fac1/" rel="bookmark">
			解决Spark连接Hive查询数据NullPointerException问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：我们有一个使用Spark做数据计算的项目，一直以来运行正常，近日测试环境突然发生运行时空指针异常问题（已脱敏处理）：
ERROR ApplicationMaster: User class threw exception: java.lang.RuntimeException: serious problem java.lang.RuntimeException: serious problem at org.apache.hadoop.hive.ql.io.orc.OrcInputFormat.generateSplitsInfo(OrcInputFormat.java:1021) at org.apache.hadoop.hive.ql.io.orc.OrcInputFormat.getSplits(OrcInputFormat.java:1048) at org.apache.spark.rdd.HadoopRDD.getPartitions(HadoopRDD.scala:199) at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:252) at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:250) at scala.Option.getOrElse(Option.scala:121) at org.apache.spark.rdd.RDD.partitions(RDD.scala:250) at org.apache.spark.rdd.MapPartitionsRDD.getPartitions(MapPartitionsRDD.scala:35) at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:252) at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:250) at scala.Option.getOrElse(Option.scala:121) at org.apache.spark.rdd.RDD.partitions(RDD.scala:250) at org.apache.spark.rdd.MapPartitionsRDD.getPartitions(MapPartitionsRDD.scala:35) at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:252) at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:250) at scala.Option.getOrElse(Option.scala:121) at org.apache.spark.rdd.RDD.partitions(RDD.scala:250) at org.apache.spark.rdd.UnionRDD$$anonfun$1.apply(UnionRDD.scala:84) at org.apache.spark.rdd.UnionRDD$$anonfun$1.apply(UnionRDD.scala:84) at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:234) at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:234) at scala.collection.immutable.List.foreach(List.scala:381) at scala.collection.TraversableLike$class.map(TraversableLike.scala:234) at scala.collection.immutable.List.map(List.scala:285) at org.apache.spark.rdd.UnionRDD.getPartitions(UnionRDD.scala:84) at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:252) at org.apache.spark.rdd.RDD$$anonfun$partitions$2.apply(RDD.scala:250) at scala.Option.getOrElse(Option.scala:121) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/670dad785436e7023244bad255d3fac1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a0680d0d69199c81c52df48835cd52f/" rel="bookmark">
			前端架构之eslint（三）之 插件开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面两节已经对eslint的配置，eslint源码进行了详细的解释，那接下来我们就来手写一个plugin。
该plugin包含自定义rule、自定义processor、共享配置信息。
完整的项目请看eslint-project
一、创建一个插件 - myPlugin 初始化项目。每个插件是一个命名格式为 eslint-plugin-&lt;plugin-name&gt; 的 npm 模块，你也可以用这样的格式 @&lt;scope&gt;/eslint-plugin-&lt;plugin-name&gt; 限定在包作用域下。我们的插件就取名为eslint-plugin-myPlugin
mkdir myPlugin cd myPlugin npm init 在eslint中，插件可以暴露额外的规则以供使用。为此，插件必须输出一个rules对象，包含规则ID和对应规则的一个键值对。那我们就来自定义一个rule, id取名为replacement。rule解决的问题是将代码块中的XXX替换为Candice。
创建规则需要的属性以及每个属性对应的功能，eslint官网已经给出了详细的解释，这里我就不赘述了，不了解的同学可以移步官网。
创建自定义规则还需要掌握抽象语法树AST(Abstract syntax tree)的知识。
Eslint默认的语法解析工具为Espree，我们可以在AST explorer查看代码解析之后对应的节点类型。
创建myPlugin/rules/replacement.js
"use strict"; //------------------------------------------------------------------------------ // Rule Definition //------------------------------------------------------------------------------ module.exports = { // 规则的元数据 meta: { /** * type (string) 指示规则的类型，值为 "problem"、"suggestion" 或 "layout" * "problem": 指的是该规则识别的代码要么会导致错误，要么可能会导致令人困惑的行为。开发人员应该优先考虑解决这个问题。 * "suggestion": 意味着规则确定了一些可以用更好的方法来完成的事情，但是如果代码没有更改，就不会发生错误。 * "layout": 意味着规则主要关心空格、分号、逗号和括号，以及程序中决定代码外观而不是执行方式的所有部分。这些规则适用于AST中没有指定的代码部分。 */ type: "problem", // 对 ESLint 核心规则来说是必需的 docs: { // 展示在eslint规则首页的描述 description: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a0680d0d69199c81c52df48835cd52f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5833450a0619f3c18565a86389c3613/" rel="bookmark">
			C# 执行Js脚本方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# 运行JS 运行Js脚本方法（1）运行JS脚本方法（2）1 . 新建文本JSCaller.js2. 打开.net的命令行窗口。运行jsc /t:library d:\JSCaller .js 得到JSCaller.dll3.在c#项目中引用JSCaller.dll 和Micosoft.JScript.dll4. C#中调用JSCaller.dll 运行JS脚本的方法（3）4 运行JS脚本方法 运行Js脚本方法（1） /// &lt;summary&gt; /// 执行JS /// this.ExecuteScript("get('{0}')".FormatWith(token0), File.ReadAllText(Server.MapPath("./encodejs.js"))).toUrlEncode(); /// &lt;/summary&gt; /// &lt;param name="sExpression"&gt;参数体&lt;/param&gt; /// &lt;param name="sCode"&gt;JavaScript代码的字符串&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public string ExecuteScript(string sExpression, string sCode) { MSScriptControl.ScriptControl scriptControl = new MSScriptControl.ScriptControl(); scriptControl.UseSafeSubset = true; scriptControl.Language = "JScript"; scriptControl.AddCode(sCode); try { string str = scriptControl.Eval(sExpression).ToString(); return str; } catch (Exception ex) { string str = ex.Message; } return null; } var get = function (a) { var b = CryptoJS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5833450a0619f3c18565a86389c3613/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d58fd7a5a7e21c6f19ec0e40f2195c44/" rel="bookmark">
			[Leetcode][第130题][JAVA][被围绕的区域][DFS][BFS]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题描述】[中等] 【解答思路】 1. 深度优先搜索 使用深度优先搜索实现标记操作。在下面的代码中，我们把标记过的字母 O 修改为字母 A。
复杂度
class Solution { int[] dx = {1, -1, 0, 0}; int[] dy = {0, 0, 1, -1}; public void solve(char[][] board) { int n = board.length; if (n == 0) { return; } int m = board[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;(); for (int i = 0; i &lt; n; i++) { if (board[i][0] == 'O') { queue.offer(new int[]{i, 0}); } if (board[i][m - 1] == 'O') { queue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d58fd7a5a7e21c6f19ec0e40f2195c44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/465b5903dc9492635c71d06fc258bf0d/" rel="bookmark">
			STM32 时延函数之阻塞和非阻塞的实现讨论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 、常使用的几种延时方式 1 自带的hal_delay 函数 毫秒级延迟 void HAL_Delay(__IO uint32_t Delay) { uint32_t tickstart = HAL_GetTick(); //获取tick值（毫秒） uint32_t wait = Delay; /* Add a period to guarantee minimum wait */ if (wait &lt; HAL_MAX_DELAY) { wait++;//传参，延时的时间 } while((HAL_GetTick() - tickstart) &lt; wait) { } } 也可以配置为us延时，改变函数参数 配置方法：也可以配置为1us // HAL_RCC_GetHCLKFreq()/1000 1ms中断一次，即HAL_Delay函数延时基准为1ms // HAL_RCC_GetHCLKFreq()/100000 10us中断一次，即HAL_Delay函数延时基准为10us // HAL_RCC_GetHCLKFreq()/1000000 1us中断一次，即HAL_Delay函数延时基准为1us HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000000); // 配置并启动系统滴答定时器 2 中断延时----利用定时器计时 int main(void) { HAL_Init(); SystemClock_Config(); LED_GPIO_Init(); /* 基本定时器初始化：1ms中断一次 */ BASIC_TIMx_Init(); /* 在中断模式下启动定时器 */ HAL_TIM_Base_Start_IT(&amp;htimx); while (1) { if(timer_count==1000) { timer_count=0; LED1_TOGGLE; } } } void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { timer_count++; //回调函数 } 3 优选方式------获取系统时钟计时，非阻塞式延时 void delay_ms(int32_t nms) { int32_t temp; SysTick-&gt;LOAD = 8000*nms; SysTick-&gt;VAL=0X00;//清空计数器 SysTick-&gt;CTRL=0X01;//使能，减到零是无动作，采用外部时钟源 do { temp=SysTick-&gt;CTRL;//读取当前倒计数值 } while((temp&amp;0x01)&amp;&amp;(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/465b5903dc9492635c71d06fc258bf0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/970792b965b090a613622c0acd4745ad/" rel="bookmark">
			网页设计大作业,仿制品优购页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按照pink老师讲课的内容,手打的品优购网页 品优购网页设计最终效果已经部署到服务器,点击浏览 代码概述:
目录解释csscss样式存放目录font特殊字体存放目录images网页图片存放目录upload经常被修改的图片上传目录jsjavascript存放目录index.html主页list.html购买页register.html注册页 index.html &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;品优购&lt;/title&gt; &lt;meta name="description" content="品优购-专业的综合网上购物商城，销售家电，数码通讯 电脑，服装服饰"&gt; &lt;meta name="keywords" content="哈哈哈哈哈，迪迦，奥特曼"&gt; &lt;link rel="stylesheet" href="css/base.css"&gt; &lt;link rel="stylesheet" href="css/common.css"&gt; &lt;link rel="shortcut icon" href="favicon.ico"/&gt; &lt;link rel="stylesheet" href="css/index.css"&gt; &lt;script src="js/animate.js"&gt;&lt;/script&gt; &lt;!--此句要放到下句上面--&gt; &lt;script src="js/index.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--快捷导航模块start--&gt; &lt;section class="shortcut"&gt; &lt;div class="w"&gt; &lt;div class="fl"&gt; &lt;ul&gt; &lt;li&gt;品优购欢迎您&amp;nbsp;&lt;/li&gt; &lt;li&gt; &lt;a href="#"&gt;请登录&amp;nbsp;&lt;/a&gt;&lt;a href="register.html" class="style_red"&gt;免费注册&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="fr"&gt; &lt;ul&gt; &lt;li&gt;我的订单&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li class="arrow-icon"&gt;我的品优购&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;品优购会员&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;企业采购&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/970792b965b090a613622c0acd4745ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5991969075f4842a9ca0862c0fca85f7/" rel="bookmark">
			Docker 容器常见故障排查及处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker 容器常见故障排查及处理 本文来源于公司论坛发表的帖子
Docker是一种相对使用较简单的容器，我们可以通过以下几种方式获取信息：
1、通过docker run执行命令，或许返回信息
2、通过docker logs 去获取日志，做有针对性的筛选
3、通过systemctl status docker查看docker服务状态
4、通过journalctl -u docker.service 查看日志
以下是整理的docker容器类问题故障，分为9个类
一、启动类故障 1、docker: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?
原因：Docker未正常启动
解决方式：
systemctl start docker
2、can’t create unix socket /var/run/docker.sock: is a directory
原因：docker.sock不能创建
解决方式：
rm -rf /var/run/docker.sock
然后重新启动docker
3、Job for docker.service failed. Failed to start Docker Application
原因：Selinux引起
解决方式：
/etc/sysconfig/selinux , 把 selinux 值改为disabled
重启docker解决
4、docker: Error response from daemon:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5991969075f4842a9ca0862c0fca85f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/599914e736341cfeba06447a7a5e7b59/" rel="bookmark">
			Madagascar-3.0安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Madagascar不支持Ubuntu20，就到https://ubuntu.com/download/alternative-downloads
下载Ubuntu 18
2.到http://www.ahay.org/wiki/Tutorial下载Madagascar-3.0，之后解压出来
安装方法参考
http://blog.sciencenet.cn/home.php?mod=space&amp;uid=898810&amp;do=blog&amp;id=674969
需要启动虚拟化，具体方法参考下面
https://blog.csdn.net/jinchunzhao123/article/details/81226859
https://bbs.360.cn/forum.php?mod=viewthread&amp;tid=2181954&amp;extra=page%3D1&amp;page=1&amp;archive_src=bbs_safe
先设置共享（主机和虚拟机文件共享）
右键点设置出来下面
点总是启用，再点添加选中解压出来的Madagascar-3.0
共享完的文件在other location/mnt/hgfs
（可选）没有VMware Tools共享不了，安装VMware Tools ,教程为https://www.cnblogs.com/huangjianxin/p/6343881.html
配置环境，到http://www.ahay.org/wiki/Advanced_Installation#Ubuntu找到下面命令
点或者快捷键Ctrl+Alt+T调出terminal，复杂输入上面的代码（逐行复制）。
安装时需要输入Y，安装完环境界面是这样
可以先把Madagascar-3.0的文件复制到desktop，找到文件右键点Open in Terminal
再在terminal中输入 ./configure --prefix=/
这就配置完了
接着输入scons; scons install
如果出现下面的
再输入sudo scons install
到Home处快捷键输入Ctrl+H显示隐藏文件，找到.bashrc
在里面输入下面的
其实就是输入一个调用的路径，我是放在桌面的，在末尾输入如下
之后打开终端输入
没有其他问题出现是这样的
最后是测试是不是成功了，在终端输入下面的，如：sfin
如果出来下图就是安装成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b55a84138088b28eca1b99be20b14d77/" rel="bookmark">
			前端架构之eslint（二）之源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上节对eslint的配置进行了详细的解释，这节再来对源码进行分析一波。
执行eslint的流程图如下：
eslint的入口：eslint/bin/eslint.js#main eslint.js是命令的执行文件，用来启动eslint，并向cli传递命令行参数。
... await require("../lib/cli").execute( process.argv, // 命令行eslint后面的参数 process.argv.includes("--stdin") ? await readStdin() : null // eslint命令行是否有--stdin，执行process.stdin读取需lint的内容 ); eslint/lib/cli.js#execute cli.js#execute是eslint的核心，它解析eslint执行命令，调用有效的操作。它还扮演着读取文件、遍历目录，输入和输出的角色。
function execute(args, text) { let options; try { options = CLIOptions.parse(args); // 解析eslint options } catch (error) { ... } ... /** *	translateOptions(options) // 将cli options转换为cli-engine options * *	engine是Eslint的实例，可以用eslint的API。 * **/ const engine = new ESLint(translateOptions(options)); let results; /** * eslint --stdin的优先级高 **/ if (useStdin) { results = await engine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b55a84138088b28eca1b99be20b14d77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e13e479cff3b8860c5eaf6191206ea51/" rel="bookmark">
			高速接口----7系列收发器GTP(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 最近在做以太网相关的东西，其中一个其中想要使用MAC通过光电转换模块来完成数据的收发。在Artix7系列FPGA当中，有GTP这个高速收发器。我手上的板子上的核心芯片是ZYNQ7015,这是一个带一个QUAD的ZYNQ FPGA，上面的收发器是GTP。对于其他稍微高端一点的ZYNQ上带有收发器应该是GTH/GTX的。但是，只是实现一个千兆网，使用GTP应该是足够了。因此需要了解收发器的使用。
本篇博客当中，我只介绍我在初次使用7 Serie FPGA Transceiver Wizard所进行的一些自认为比较重要的东西。
2. UG482 2.1 整体结构 因为手上的ZYNQ芯片带有的收发器是GTP，因此需要参考的手册是ug482,对于GTH/GTX则需要参考ug476。其实GTP和GTX/GTH还是比较相似的，GTP内部的结构和GTX/GTH稍有不同。
上面的图是手册上给出的100T内部的收发器分布图，可以看到对于Artix7系列FPGA的收发器，其是分布在上下两侧的，这与GTX/GTH单列放置是一个区别。
下图是每个QUAD内部的结构：一个QUAD中包含4个channel和一个COMMON。GTPE2_COMMON 中包含两个PLL(PLL0/PLL1),使用到收发器时，COMMON原语必须被例化。每个CHANNEL中都包含一个接收器和一个发送器。
下图是收发器每个CHANNEL中的结构：TX/RX都包含两部分，其中PCS是物理编码层，PMA是物理媒介层。
2.2参考时钟 GTP中的参考时钟选项和GTX/GTH中略有不同，在GTH/GTX中，支持南北方向的时钟路由，在GTP当中支持东西方向的时钟路由。
一个QUAD中包含4个GTPE2_CHANNEL原语，一个GTPE2_COMMON 原语，两个外部参考时钟引脚以及专用参考时钟的路由。
在A7系列FPGA当中，位于上半部分的收发器可以进行时钟的共享，位于下半部分的收发器可以进行时钟的共享。
在下图中，COMMON原语的时钟输入可以有以下几种：两个参考时钟，来自另一个QUAD的参考时钟
2.2.1COMMON参考时钟 GTP COMMON中时钟的选择：common中的每一个PLL时钟来源都包含7个分别为：一个用于测试的时钟，两个外部参考时钟，两个东向参考时钟，两个西向参考时钟，通过PLL0/1REFCLKSEL 来选择具体使用到的时钟参考源。
2.2.2 CHANNEL 参考时钟 GTP CHANNEL的端口具体可以分为，用于选择RX/TX的参考时钟和数据的参考时钟，参考时钟可以来自PLL，也可以来自PLL的参考时钟。
下图是包含了各种情况的时钟路由方式
值得说明的是，这些端口和选项，在GTP的向导这个IP中，都不用可以去记，在向导里面只需设置就可以，IP会自动生成这些逻辑。
3 发送器TX 3.1 TX interface &amp;esmp;TX interface 简单来说，就是位于FPGA逻辑侧和收发器发送这一侧的端口。从这里开始收发器会将FPGA中想要发送的数据进行发送。这里是收发器发送数据的第一步。TX Interface 是与用于逻辑联系最紧密的一个模块，该模块决定了FPGA侧数据的位宽和收发器传输的线速率，并且该模块还与数据的编码有关。
3.1.1 数据位宽 GTP包含2字节的内部数据通道，TX 部分的Interface 的数据位宽通过TX_DATA_WIDTH 属性来配置。当8B/10B编码被使能的时候，TX_DATA_WIDTH必须被配置为20bit/bit。当不使能8B/10B编码的时候，TX_DATA_WIDTH 可以被配置为16，20，32，40。
当不使用8B/10B编码的时候，必须使用TXCHARDISPMODE &amp; TXCHARDISPVAL 来对位宽进行扩充，扩充位宽的方法是每1byte用户数据需要1bit 的TXCHARDISPMODE和 1bit 的TXCHARDISPVAL来对数据进行扩充。如图中的Table 3-2 所示。
3.1.2 用户时钟 FPGA TX接口包含两个并行时钟：TXUSRCLK和TXUSRCLK2。TXUSRCLK是GTP内部PCS部分的内部时钟，TXUSRCLK所需要的速率取决于GTPE2_CHANNEL原语内部的数据路径宽度和TX 的线速率。
TXUSRCLK2是所有进入到GTP TX接口的信号的主要的同步时钟。进入到TXUSRCLK的大多数数据在TXUSRCLK的上升沿进行采样。TXUSRCLK2和TXUSRCLK具有固定的频率关系。根据TX_DATA_WIDTH的值来确定：
从上面的图中可以看出，TXUSRCLK2的时钟频率在不同的模式下可以为TXUSRCLK或者TXUSRCLK的一半,TXUSRCLK 和TXUSRCLK2一般都是由TX接口上的TXOUTCLK来生成的。下面的两幅图中，可以看到TXUSRCLK和TXUSRCLK在不同模式下的生成的示意图。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e13e479cff3b8860c5eaf6191206ea51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bda60dc3f8183c9c760c7918b1c60de2/" rel="bookmark">
			Vivado学习笔记四
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vivado程序固化 初玩FPGA开发板，会遇到这种情况，事先写好的程序编译成功后下载到板子里，随着掉电之后程序也就随之消失，再次上电又要重新编译下载程序。所以学会固化程序十分重要！
目的简介：将FPGA的配置文件（固化用的配置文件是二进制文件，仅bin文件）烧写到板载Flash中，实现上电自启动，完成程序固化
过程步骤：
1）在Vivado软件里找到Settings设置选项，进入，点击Bitstream选项，将 bin_file 勾上，点击 OK
2）点击 Generate Bitstream （Run Synthesis—Run implementation— Genereate Bitstream），生成 bit 文件和 bin 文件
3）点击 open hardware manager，连接板子
4）在Hardware面板中右击FPGA器件，选择Add Configuration Memery Device
5）在弹出的添加配置存储器的界面中，找到板载的Flash存储器型号，点击OK，完成添加
在弹出的添加配置存储器的界面中，找到板载的Flash存储器型号，点击OK，完成添加。（不知道型号可以先任意选择，软件会报错，可以在错误日志中找到正确的型号）
6）添加完成后，Vivado会提示添加完成，是否立即配置存储器。点击OK，进入配置存储器的界面，开始将二进制bin文件烧写到外部配置flash存储器中
如果配置存储器的界面突然找不到，可以右击flash存储器，点击Program Configuration Memory Device，会出现存储器的配置界面
7）找到二进制bin文件，选中，进行代码烧写, 实现上电自启动，完成程序固化
二进制文件路径为：project_name\project_name.runs\impl_1\xxx.bin
或project_name \project_name.runs\impl_2\xxx.bin
点击OK，烧写二进制文件
这样FPGA硬件程序就固化到外部配置存储器中了，下次上电就可以通过QSPI自启动。需要注意的是板载的配置跳线帽需要设置到QSPI模式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aea3303e40dbfe7e7e08b346fd595ea4/" rel="bookmark">
			按钮悬停效果(Button Hover Effects)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按钮悬停效果Button Hover Effects 示例HTMLCSSJS 更多有趣示例 尽在知屋安砖社区
示例 HTML &lt;a href="" class="button"&gt;Button&lt;/a&gt; &lt;a href="" class="button reverse dark"&gt;Reverse&lt;/a&gt; &lt;a href="" class="button fast white"&gt;Fast&lt;/a&gt; &lt;!-- dribbble --&gt; &lt;a class="dribbble" href="https://dribbble.com/shots/7441241-Button-Hover-Effects" target="_blank"&gt;&lt;img src="https://cdn.dribbble.com/assets/dribbble-ball-mark-2bd45f09c2fb58dbbfb44766d5d1d07c5a12972d602ef8b32204d28fa3dda554.svg" alt=""&gt;&lt;/a&gt; CSS .button { &amp;.dark { --background: #2F3545; --shadow: 0 2px 8px -1px #{rgba(#151924, .32)}; --shadow-hover: 0 4px 20px -2px #{rgba(#151924, .5)}; } &amp;.white { --background: #fff; --text: #275efe; --shadow: 0 2px 8px -1px #{rgba(#121621, .04)}; --shadow-hover: 0 4px 20px -2px #{rgba(#121621, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aea3303e40dbfe7e7e08b346fd595ea4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eb89c809e63a4588c5890dbdeeb492d/" rel="bookmark">
			Pycharm建立代码结构模板的方法记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python建立代码模板的方法记录
Pycharm建立代码结构模板的方法记录 1.首先需要将建立好的模板复制
2.在pycharm中选择File-Settings-Live Tempaltes
3. 将代码粘贴进Template text文本框中
4. 如果想让光标定位到所需填写内容的部分，在Template text对应部分添加 内 容 内容 内容即可。
5.最后点击Change选择你所建立结构的语言即可
6.最后在代码插入框输入你所建立的框架的简写，敲击回车即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96a24b1d8f621cbd0ae006144400754b/" rel="bookmark">
			微服务-配置中心环境准备-nacos安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言： nacos 作为阿里微服务框架中的一员，扮演着配置中心的角色，本篇文章，主要是介绍在docker环境下安装ancos,为后续的微服务框架做准备。
二、nacos安装： 前置条件：VMware虚拟机，docker环境：
下载镜像：doker pull nacos/naocs-server
启动容器：
docker run -d --name nacos-server-8848 -p 8848:8848 -e MODE=standalone -e PREFER_HOST_MODE=hostname nacos/nacos-server
三、打开nacos后台页面： http://192.168.213.102:8848/nacos 用户、密码默认nacos
查看服务详情：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/360de294769ba61a7625c5a1654fe64a/" rel="bookmark">
			前端常用面试算法题--数组去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组去重在我们的前端的面试过程中经过会遇到，有一些人可能会想到一两种，但是
数据去重的算法真的太多了，下面我们一起来看一下吧。
这个是我总结的几种方法，如果大家有不一样的方法，欢迎讨论交流。
1.利用Set去重 function uniqueArray(arr) { const newArray = new Array(...new Set(arr)); return newArray; } let arr = [1, 2, 2, 3,4, 5, 2, 3, 8, 9, 10, 8]; const newArray = uniqueArray(arr); console.log(newArray); //[1, 2, 3, 4, 5, 8, 9, 10] 2.利用Map去重 function uniqueArray(arr) { let map = new Map(); const newArray = arr.filter((item)=&gt;{ return !map.has(item) &amp;&amp; map.set(item, 0); }) return newArray; } let arr = [1, 2, 2, 3,4, 5, 2, 3, 8, 9, 10, 8]; const newArray = uniqueArray(arr); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/360de294769ba61a7625c5a1654fe64a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/462e4ee4717aba4e2a5d217f0a836704/" rel="bookmark">
			移动端的几种适配方案及rem dpr  px  font-size之间转换理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端开发中，需要在各种不同屏幕尺寸大小的设备上运行页面，所以就需要进行移动端适配
一般有一下几种方法：
（）媒体查询media：代码冗余
（）百分比布局：图片之类的会乱
（）弹性布局flex:高度固定，宽度自适应，天猫用的这玩意
（）rem+viewport：这个计算比较复杂，淘宝用的就是这玩意
rem是什么？ 移动端布局用的最多的就是rem啦，rem就是相对元素根节点的字体大小的单位，其实就是一个相对单位，或者一个比例
相对的就是这个font-size，也就是整个html设置的font-size
比如现在的浏览器默认的font-size=16px,所以1rem=1*16px;这就是rem和font-size之间的转化，一般为了方便也会将font-size设置成10px，这样正数乘除比较方便
既然移动端用rem做比较好，而rem 和font-size是有比例关系的，所以计算好font-size就很重要
viewport是什么 viewport:用户的可视区域
一般写移动端之前都会在head里面加入meta标签，如下
&lt;meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1,minimum-scale=1, user-scalable=no"&gt; 宽度是设备宽度，缩放比例默认是1，不允许用户缩放
如何设置font-size？两种方法： 1. rem计算后，媒体查询设置font-size 一般前端都会拿到UI给的一个设计稿，现在好像设计稿的尺寸横向分辨率都是640的，但是如果移动端的设备横向分辨率是320的，肯定是要转换的
不同手机的分辨率是不同的，所以需要根据设备的分辨率来计算font-size
举个栗子：640px font-size=20px 那么320px font-size就应该是对应的一半，因为同比缩小一半也就是font-size=10px
这样的话可以通过媒体查询进行设置不同分辨率的对应font-size
@media screen and (min-device-width: 320px)and (-webkit-min-device-pixel-ratio: 2) { html{&lt;br&gt;　font-size:10px;&lt;br&gt;　} } @media only screen and (min-device-width: 375px)and (-webkit-min-device-pixel-ratio: 2) { html{&lt;br&gt;　font-size:12px;&lt;br&gt;　} } @media only screen and (min-device-width: 375px)and (-webkit-min-device-pixel-ratio: 3) { html{&lt;br&gt;　font-size:16px;&lt;br&gt;　} } @media only screen and (min-device-width:412px) and (-webkit-min-device-pixel-ratio: 3) { html{&lt;br&gt;　font-size:20px;&lt;br&gt;　} } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/462e4ee4717aba4e2a5d217f0a836704/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9c6d37dc0355c232c22db88a2df533a/" rel="bookmark">
			go语言执行单个测试函数提示未定义的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在写测试函数的时候的时候单独执行了一个测试函数 编译器提示某个函数未定义，但是这个函数确实是已经定义了
这是go语言在测试函数过程中存在的不足的一点，执行gotest命令 会对上述源码文件生成一个虚拟包，但是被测试函数是不属于这个包中的函数 所以需要把该包也一同写在命令行后面
执行成功 当有多个包引用的时候 就需要写多个包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaaaa421ba7e444966f14585c8f2a17e/" rel="bookmark">
			C&#43;&#43;语言对有理数的封装Rational
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本类也可以采用模板化，将构造函数进行模板处理
#include &lt;iostream&gt; #include &lt;cmath&gt; //包含abs函数取绝对值 using namespace std; class Rational { public: template &lt;class T1,class T2&gt; Rational(T1 numerztor, T2 denominator = 1.0);//含两个参数的构造函数，设置为模板函数，包含（int，int）（double，double）（int，double）（double，int）简化代码 template &lt;class T&gt;//含有一个参数的构造函数 ，设置为模板函数，包含（int）（double）简化代码 Rational(T); Rational();//空构造函数 void Simplify();//化简 friend int LCM(int, int);//求最小公倍数，方便通分，计算 friend const Rational operator+(const Rational R1,const Rational R2);//重载+，设置为常友元函数，参量均用const修饰 friend const Rational operator-(const Rational R1, const Rational R2); friend const Rational operator*(const Rational R1, const Rational R2); friend int GCD(int, int);//求最大公约数，方便化简 friend istream&amp; operator&gt;&gt;(istream &amp;in, Rational&amp;R1);//重载输入符号函数，设置为友元 friend ostream&amp; operator&lt;&lt;(ostream &amp;out,Rational&amp;R1);//重载输出符号函数，设置为友元 friend const Rational operator/(const Rational R1, const Rational R2); template&lt;class T&gt; Rational const operator=(T const);//重载=，类成员函数，设置为常函数，右参数可以为Rational，int，double，简化代码 Rational operator++();//重载前置++, Rational operator++(int);//重载后置++ Rational operator!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaaaa421ba7e444966f14585c8f2a17e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e96266ee3f3250793352921153201f4e/" rel="bookmark">
			几条写的比较好的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BMC介绍
https://blog.csdn.net/weixin_42306122/article/details/95642613
SPI,IIC和SMbus的应用优缺点分析 https://wenku.baidu.com/view/d505c330a1c7aa00b42acb7f.html
linux top命令中各cpu占用率含义及案例分析 https://blog.csdn.net/ydyang1126/article/details/72820349
VCC AVCC VDD AVDD区别 https://blog.csdn.net/whereismatrix/article/details/80510466
电容电阻失效模型
https://wenku.baidu.com/view/53b751ae0a4c2e3f5727a5e9856a561253d32110.html
https://www.eefocus.com/bios_Wei/blog/09-03/167516_2cc85.html
http://blog.sina.com.cn/s/blog_697e8abb0100m5mf.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b2a9683e4410be17a6ad4904d6a69d5/" rel="bookmark">
			Unity项目捏脸解决方案BlendShape
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity项目捏脸解决方案BlendShapes 引子BlendShapes具体使用代码 参考链接 引子 最近公司在开发一个捏脸的SDK，使用的核心功能就是使用Unity的SkinnedMeshRenderer上的BlendShapes来实现的。这个功能在Maya和3ds Max中都可以找到。
BlendShapes BlendShapes是一种动画制作方式，与骨骼动画相比，它主要应用在很小的局部，比如角色的面部表情。
骨骼只适合控制整体的动作，但太局部的动作使用骨骼制作会非常繁琐，同时太多的骨骼对性能也有影响。
BlendShapes的原理很简单，就是在相邻两个网格间做插值运算，从一上形状融合到另一个形状；或者说是单个网格变形以实现许多预定义形状和任何数量之间组合的技术，在Maya/3ds Max中我们称它为变形目标，例如单个网格是默认形状的基本形状（例如无表情的面），并且基本形状的其他形状用于混合/变形，是不同的表达（笑、皱眉、闭合眼皮），这些被统称为混合形状或变形目标。所以美术只要制作若干个形状的模型即可，比摆骨骼要方便很多，特别是对于面部这种很局部的动作来说。
模型在导入时，Import BlendShapes选项默认是选中的。
具体使用 要在Maya或者3ds Max里面制作一个含有BlendShapes的形变动画Avator。把Avator导入到Unity中。导入的模型上面有组件SkinnedMeshRenderer，面板上有BlendShapes参数，它的下面有一连串的数值可以手动或编码设置，来实现捏脸效果。 代码 Unity提供的一些相关接口（组件SkinnedMeshRenderer中）：
void SetBlendShapeWeight(int index, float value)：用于直接设置BlendShape的值，使用index按照面板上的自上而下顺序下标来索引设置的“部位”。float GetBlendShapeWeight(int index)：根据index获取对应的BlendShape值。sharedMesh.blendShapeCount：组建中BlendShape的数量。sharedMesh.GetBlendShapeName(int shapeIndex)：根据index获取对应的BlendShape名称字符串。sharedMesh.GetBlendShapeIndex(string blendShapeName)：根据名称获取索引的下标（第几个）。 这里我只用了了几个，还有一些并没有使用测试过。
void AddBlendShapeFrame(string shapeName, float frameWeight, Vector3[] deltaVertices, Vector3[] deltaNormals, Vector3[] deltaTangents)：添加一个新的BlendShape框架。int GetBlendShapeFrameCount(int shapeIndex)：返回BlendShape的帧数。void GetBlendShapeFrameVertices(int shapeIndex, int frameIndex, Vector3[] deltaVertices, Vector3[] deltaNormals, Vector3[] deltaTangents)：检索BlendShape框架的deltaVertices，deltaNormals和deltaTangents。float GetBlendShapeFrameWeight(int shapeIndex, int frameIndex)：返回BlendShape框架的权重。 之后下面是我使用的一个脚本，当使用的一个模型（FBX）下有好多分支模型节点时，使用这个脚本统一管理设置BlendShape。
using UnityEngine; public class BlendShapeModel : MonoBehaviour { private SkinnedMeshRenderer[] skinnedMeshRenderers; private string[] m_bsNameAll; void Start() {//获取初始化 skinnedMeshRenderers = GetComponentsInChildren&lt;SkinnedMeshRenderer&gt;(); m_bsNameAll = new string[skinnedMeshRenderers.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b2a9683e4410be17a6ad4904d6a69d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fff0f36497d44ad1a72fb8bb35dd9b14/" rel="bookmark">
			浅谈一下，来自vue优点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue有以下优点 轻量级框架: 只关注视图层, 是一个构建数据的视图集合, 大小只有十几kb
简单易学, 国人开发, 中文文档, 不存在语言障碍, 易于理解和学习;
组件化: 保留了react 的优点, 实现了html的封装和重用, 在构建单页面应用方面有着独特的优势; 视图, 数据, 结构分离: 使数据更改更为简单, 不需要进行逻辑代码的修改, 只需要操作数据的能完成相关操作:
虚拟DOM: dom操作是非常耗费性能的, 不再使用原生的dom操作节点, 极大解放dom操作, 单具体操作的还是dom, 只不过是换了另一种方式;
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/226/">«</a>
	<span class="pagination__item pagination__item--current">227/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/228/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>