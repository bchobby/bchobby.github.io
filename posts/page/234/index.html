<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ca3ea0e4d948f0213cf32fba44db8c9/" rel="bookmark">
			变量的命名规则和命名规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变量的命名规则和命名规范
规则:（必须遵守的，不遵守就是错）
1.一个变量名称可以由数字、字母、下划线、美元符号($) 组成
2.严格区分大小写
3.不能由数字开头,不要使用中文汉字命名
4.不能是保留字或者关键字
5.不要出现空格
规范:（建议遵守的，不遵守不会报错）
1.变量名尽量有意义(语义化)
2.遵循驼峰命名规则，由多个单词组成的时候,从第二个单词开始首字母 大写，如countNum
变量的定义
变量:存储数据的容器
变量声明: var num;
变量的赋值: num = 10
定义变量的方式:
显示定义:
var num1 = 10
console. log (num1)
隐式定义:
num2=20
console. log (num2)
两种定义的区分:
显示定义在没有赋值的情况下可以使用，打印的是undefined。而隐式定义在没有赋值的情况下会报错。隐式定义变量在使用的时候必须先赋值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f41f0a998ab37eb439019a915cafb28/" rel="bookmark">
			Tensorflow安装教程 傻瓜式一键安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近又在鼓捣tensorflow，搞到一个比较简单的安装方法，在这里分享一下
之前在网上看到的tensorflow安装教程，尤其是GPU版因为依赖cuda和cudnn，所以很多教程都是分开单独安装，很多小伙伴搞不清楚一不小心就会有版本冲突问题，这里介绍一个简单的方法
1. 安装anaconda，安装就不过多赘述，按各自需要安装就好 anaconda官网下载安装
2. anaconda配置 打开cmd切换到国内的镜像源（为什么要切换原因不用我说了吧...）
切换成清华的镜像 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ 切换成中科大的镜像 conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ 注意！如果切换镜像后当出现下载不了的情况，就先切换默认源，然后再修改另一个可以使用的conda源（一定要先恢复默认，再换另一个！！！）
切回默认源 conda config --remove-key channels 其他镜像网站可以自行上网搜索
3. TensorFlow安装 这里建议安装tensorflow 1.15的版本，需要安装其他版本的只需要在安装tensorflow的命令行中修改对应版本号即可。
打开cmd运行，首先创造tensorflow 1.15需要的环境
conda create -n tensorflow pip python=3.6 激活TensorFlow环境
activate tensorflow 用conda安装tensorflow
CPU版输入 conda install tensorflow=1.15.0 GPU版输入 conda install tensorflow-gpu=1.15.0 （重点！）选择conda安装而不用pip安装，是因为在安装tensorFlow-gpu版的过程中，它会自动配置对应版本号的cuda和cudnn，而不需要再单独安装
（这里截图是tensorflow1.12的安装过程，因为我的电脑只能支持cuda9.0，安装tensorflow1.15的过程也是这样，只是cuda版本号会不一样而已）
然后等待安装完成就好了，不能装gpu版的就老老实实装cpu版！！！
之前作为第一次安装tensorflow的人也踩了不少坑，这算是我目前看到的最简单也最不容易出错的一个安装方法吧，如果有小伙伴还没装过，或者安装出错解决不了的都可以试一试
happy coding~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2451329eefff882b3221d0f67a3afb40/" rel="bookmark">
			计算机组成运算器实验：8位可控加减法电路、4位先行进位电路、4、16、32位快速加法器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 电路1— 8位可控加减法电路 在 Logisim 模拟器中打开 alu.circ 文件，在对应子电路中利用已经封装好的全加器设计8位串行可控加减法电路，可以直接使用在电路中使用对应的隧道标签，其中 X，Y 为两输入数，Sub 为加减控制信号，S 为运算结果输出，Cout 为进位输出，OF 为有符号运算溢出位。
实验原理 1.电路1
（1）overflow：
（2）1位加法逻辑电路：
1位全加器：
（3）N位加法器：
（4）运算控制器：Sub=0 时作加法，Sub=1 时作减法。[−Y]补= [ [Y]补 ]补，对 [Y]补逐位取反, 再在最低位加 1（体现在最右边的sub连接到最低位cin,此时sub=1,做减法）
（5）可控加减法电路
各位逐位相加，进位从右至左传递。
实验电路  电路2— 4位先行进位电路 在 Logisim 中打开 alu.circ 文件，按照图中定义的输入输出引脚，在对应子电路中实现可级联的4位先行进位电路。其中 Gi，Pi 为进位生成函数和传递函数，Cin 为进位输入，C1~C4 为进位输出，G，P 为成组进位生成函数和成组进位传递函数。
实验原理 （1）并行加法器
进位输出仅与最低位进位输入C0有关(Cn=Gn＋PnGn-1＋PnPn-1Gn-2＋PnPn-1Pn-2Gn-3 …＋PnPn-1…P1C0)，而不是依赖于低位进位（Cn= Gn ＋ Pn Cn-1）。
并行加法器进位链：（注意：Ci都是先行进位输出，是中间变量。而不是Si）
C1 = X1Y1+(X1⊕Y1)C0=G1+P1C0
C2 = X2Y2+(X2⊕Y2)C1=G2+P2C1=G2+P2(G1+P1C0)=G2+P2G1+P2P1C0
C3 = X3Y3+(X3⊕Y3)C2=G3+P3G2+P3P2G1+P3P2P1C0
C4 = X4Y4+(X4⊕Y4)C3=G4+P4C3=G4+P4(G3+P3G2+P3P2G1+P3P2P1C0)
= G4+P4G3+P4P3G2+P4P3P2G1+P4P3P2P1C0
G4 = G4+P4G3+P4P3G2+P4P3P2G1（成组进位生成函数）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2451329eefff882b3221d0f67a3afb40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ddbd8075329be16247bd5ab70c608e4/" rel="bookmark">
			贝叶斯估计推理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 贝叶斯定理是18世纪英国数学家托马斯·贝叶斯（Thomas Bayes）提出得重要概率论理论。以下摘一段 wikipedia 上的简介：
所谓的贝叶斯定理源于他生前为解决一个“逆概”问题写的一篇文章，而这篇文章是在他死后才由他的一位朋友发表出来的。在贝叶斯写这篇文章之前，人们已经能够计算“正向概率”，如“假设袋子里面有 N 个白球，M 个黑球，你伸手进去摸一把，摸出黑球的概率是多大”。而一个自然而然的问题是反过来：“如果我们事先并不知道袋子里面黑白球的比例，而是闭着眼睛摸出一个（或好几个）球，观察这些取出来的球的颜色之后，那么我们可以就此对袋子里面的黑白球的比例作出什么样的推测”。这个问题，就是所谓的逆向概率问题。
贝叶斯定理的思想出现在18世纪，但真正大规模派上用途还得等到计算机的出现。因为这个定理需要大规模的数据计算推理才能凸显效果，它在很多计算机应用领域中都大有作为，如自然语言处理，机器学习，推荐系统，图像识别，博弈论等等。
定义 贝叶斯定理是关于随机事件 A 和 B 的条件概率：
其中P(A|B)是在 B 发生的情况下 A 发生的可能性。
在贝叶斯定理中，每个名词都有约定俗成的名称：
P(A)是 A 的先验概率，之所以称为“先验”是因为它不考虑任何 B 方面的因素。
P(A|B)是已知 B 发生后 A 的条件概率，也由于得自 B 的取值而被称作 A 的后验概率。
P(B|A)是已知 A 发生后 B 的条件概率，也由于得自 A 的取值而被称作 B 的后验概率。
P(B)是 B 的先验概率，也作标淮化常量（normalizing constant）。
按这些术语，贝叶斯定理可表述为：
后验概率 = (相似度 * 先验概率)/标淮化常量 也就是说，后验概率与先验概率和相似度的乘积成正比。
另外，比例P(B|A)/P(B)也有时被称作标淮相似度（standardised likelihood），Bayes定理可表述为：
后验概率 = 标淮相似度 * 先验概率 条件概率就是事件 A 在另外一个事件 B 已经发生条件下的发生概率。条件概率表示为P(A|B)，读作“在 B 发生的条件下 A 发生的概率”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ddbd8075329be16247bd5ab70c608e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bedf048d2927ab58f20f75e63b7120f4/" rel="bookmark">
			50_菱形继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 具有公共祖先 的多继承
class Animal { public: int data; }; class Sheep:public Animal { public: }; class Tuo:public Animal { public: }; class SheepTuo:public Sheep,public Tuo { public: }; int main(int argc, char *argv[]) { SheepTuo st; //SheepTuo 从Sheep中继承data 从Tuo继承data 就产生二义性 //st.data = 200;//err //第一中方式：加作用域解决 st.Sheep::data = 200; st.Tuo::data = 300; return 0; } 普通继承：
class Animal { public: int data; }; class Sheep:public Animal { public: }; class Tuo:public Animal { public: }; class SheepTuo:public Sheep,public Tuo { public: }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/841f2cbd7d7f902bc8ba0ef2c2a56be4/" rel="bookmark">
			49_多继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多继承的格式
class 子类: 继承方式1 父类名1,继承方式2 父类名2,继承方式3 父类名3,.... { }; //表示子类 是由 父类名1,父类名2,父类名3...共同派生出来 class Base1 { public: int a; }; class Base2 { public: int b; }; class Son:public Base1,public Base2 { //Son类 拥有了a b }; int main(int argc, char *argv[]) { Son ob; ob.a = 100; ob.b = 200; return 0; } 多继承容易产生二义性： （解决办法1 使用作用域）
class Base1 { public: int a; }; class Base2 { public: int a; }; class Son:public Base1,public Base2 { }; int main(int argc, char *argv[]) { Son ob; //ob.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/841f2cbd7d7f902bc8ba0ef2c2a56be4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f415f5955c15f0ed4d18eb0ab731f6dd/" rel="bookmark">
			48_继承中的静态成员特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class Base { public: //静态成员属于类 而不属于对象 static int num; static int data; static void showData(void); }; int Base::num = 100; int Base::data = 200; class Son:public Base { public: static int data;//父和子类 静态成员 同名 static void showData(void); }; int Son::data = 300; void test01() { //从Base类中访问 cout&lt;&lt;Base::num&lt;&lt;endl; // Son 也拥有了静态成员num cout&lt;&lt;Son::num&lt;&lt;endl; //父和子类 静态成员 同名 在子类中 访问子类中的成员 cout&lt;&lt;Son::data&lt;&lt;endl;//200 //父和子类 静态成员 同名 访问父类中的成员 必须加 Base:: cout&lt;&lt;Son::Base::data&lt;&lt;endl;//200 //父和子类 同名静态成员函数 子类默认访问子类的静态成员函数 Son::showData(); //父和子类 同名静态成员函数 子类访问父类的静态成员函数 必须加 Base:: Son::Base::showData(); } 运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca3a10edd83cfb554ed7737ab28e1ba8/" rel="bookmark">
			VUE 项目安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：安装 vue-cli
npm install -g @vue/cli-service-global 第二步：创建vue项目
vue create kekou //（kekou=&gt;项目名称） defalut(默认) Manually(手动) 相比于默认选择，可口更倾向于选择手动添加(让我们下滑选中 Manually select features )
? Please pick a preset: Manually select features ? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection) &gt;(*) Babel // 将最新版的js语法（es6、es7）转换为现阶段浏览器可以兼容的js代码 ( ) TypeScript // 使用ts语法 ( ) Progressive Web App (PWA) Support //渐进式WEB应用 https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps (*) Router // vue 路由 (*) Vuex // vue 中间键 (*) CSS Pre-processors // css 预处理器 （Scss Sass stylus Less） (*) Linter / Formatter //代码规范标准 ( ) Unit Testing //单元测试 ( ) E2E Testing //e2e测试 键盘上下箭头切换，空格选中。选择好后，回车确定；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca3a10edd83cfb554ed7737ab28e1ba8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c76a4c2034a6308266ed44bb8008d61/" rel="bookmark">
			shell如何获取命令输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将一条命令的执行结果取得命令执行结果的值有：
1、使用反引号`` (数字键1左边的键，tab键上面，英文方式输入) 如：a=echo "hello world";即将命令 echo "hello world"的输出赋给变量a2、可以使用 ( ( ) ) ， 如 ： a = (())，如：a= (())，如：a=(echo “hello world”)，即将命令echo "hello world"的输出赋给变量a。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82ec8ee107df3eb91ea5e3fb8ccd1ec0/" rel="bookmark">
			8B/10B Encode/Decode详解（转）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/YINBin/p/11011232.html
1、编码技术基础理论
在高速的串行数据传输中，传送的数据被编码成自同步的数据流，就是将数据和时钟组合成单一的信号进行传送，使得接收方能容易准确地将数据和时钟分离，而且要达到令人满意的误码率，其关键技术在于串行传输中数据的编码方法。
目前， 高速接口正在被广泛应用于包括 SATA、 SAS、 高速 PCI 等多种标准中。 这些接口的速率甚至可以达到并超过每线 10Gbits/s。 同时， 所有主流 ASIC 和 FPGA 平台也都支持这些高速接口技术。 从结构上看， 这些高速接口主要包括三个组成部分：
1） 电路部分（串行/解串行）
2） 物理部分（实现编码）
3） 链路与协议部分（高层）
支持多速率、 多协议的串行/解串行器已经实现。 以 OIF（光互联论坛） 为例， 他们已经为两组速率制定了电路规范， 分别为 5Gbits/s- 6.375Gbits/s 和 10Gbits/s-11Gbits/s。 OIF 同样为两种应用距离制定了规范， 分别为短距离（采用一个连接器， 8 英寸） 和长距离（采用两个连接器， 40 英寸）。 串行/解串行器还可以被设计用来满足更多的规范， 包括不同的速率、距离、 电路规格等等。
物理部分的主要任务是对数据进行编码， 以保证串行/解串行器的正常运行。 这些编码的目的包括： 确保必须的变换（“1” 到“0” 和“0” 到“1” 的变换）， 保证稳定的直流均衡（“0” 码与“1” 码的个数相当）， 以及满足其它标准的要求（最大化信道带宽利用率， 提高对误差的容忍能力等等）。
在光纤通信中， 线路编码是必要的， 因为电端机输出的数字信号是适合电缆传输的双极性码， 而光源不能发射负脉冲， 只能用光脉冲的“有” 和“无” 来表示二进制码中的“1”和“0"。 该方法虽然简单， 却存在三个问题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82ec8ee107df3eb91ea5e3fb8ccd1ec0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bef4dff91ef71221384b38ad31b8ea87/" rel="bookmark">
			【Java】NIO和BIO有什么区别？回答：天壤之别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引流：第一时间阅读最新文章的方式！
【Java】NIO和BIO有什么区别？答案：天壤之别
【Java】NIO不简单呐，Channel、Buffer、Selector
一、什么是NIO 1.概念 NIO是java1.4中引入的，被称为new I/O，也有说是non-blocking I/O，NIO被成为同步非阻塞的IO。
2.跟BIO流的区别 BIO是面向流的，NIO是面向块（缓冲区）的。BIO的流都是同步阻塞的，而NIO是同步非阻塞的。NIO会等待数据全部传输过来再让线程处理，BIO是直接让线程等待。NIO有选择器，而BIO没有。NIO是采用管道和缓存区的形式来处理数据的，而BIO是采用输入输出流来处理的。NIO是可以双向的，BIO只能够单向。 二、NIO常用组件Channel和Buffer的使用 1.代码 这里以文件复制为例
public class test { public static void main(String[] args){ try{ //存在的照片 File inFile=new File("C:\\Users\\Administrator\\Desktop\\study.PNG"); //复制后要存放照片的地址 File outFile=new File("C:\\Users\\Administrator\\Desktop\\study1.PNG"); //打开流 FileInputStream fileInputStream=new FileInputStream(inFile); FileOutputStream fileOutputStream=new FileOutputStream(outFile); /** * RandomAccessFile accessFile=new RandomAccessFile(inFile,"wr"); * FileChannel inFileChannel=accessFile.getChannel(); * 和下面两行代码是一样的，都是可以拿到FileChannel */ //获取Channel FileChannel inFileChannel=fileInputStream.getChannel(); FileChannel outFileChannel=fileOutputStream.getChannel(); //创建buffer ByteBuffer buffer=ByteBuffer.allocate(1024*1024); //读取到buffer中 while (inFileChannel.read(buffer)!=-1){ //翻转一下，就可以读取到全部数据了 buffer.flip(); outFileChannel.write(buffer); //读取完后要clear buffer.clear(); } //关闭 inFileChannel.close(); outFileChannel.close(); fileInputStream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bef4dff91ef71221384b38ad31b8ea87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97bb12e1c1db56d5be04f88215943735/" rel="bookmark">
			从零开始编译ortp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【版权申明】转载请附上出处链接 从零开始编译ortp ortpde的编译需要依赖其他的库, 依赖关系如下:
bctoolbox
bcunit
mbedtls
故我们在编译ortp之前, 需要依次编译bcunit, mbedtls, bctoolbox.
1. 编译BCUnit git clone https://gitee.com/submodules/bcunit.git (下载之后进入目录, 将README.mk更改为README, 防止autogen漏生成Makefile.in) ./autogen.sh ./configure --prefix=/home/Craftsman/ortp_prjs/deps/bcunit/OUTPUT make make install 2. 编译mbedtls git clone https://github.com/ARMmbed/mbedtls.git vi Makefile 将第一个行的DESTDIR=/usr/local修改为/home/Craftsman/ortp_prjs/deps/mbedtls/OUTPUT make SHARED=1 make install 3. 编译bctoolbox $git clone git://git.linphone.org/bctoolbox.git $cmake . -DCMAKE_INSTALL_PREFIX=$(TARGET_DIR) -DCMAKE_PREFIX_PATH=$(TARGET_DIR) -DCC=$(CC) -DENABLE_TESTS_COMPONENT=NO -DENABLE_DECAF=NO $make $make install 编译bctoolbox遇到的问题:
aclocal: 未找到命令
解: sudo apt-get install automakeconfigure.ac:30: error: Autoconf version 2.65 or higher is required
解: 安装Autoconf
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97bb12e1c1db56d5be04f88215943735/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a40ffd36467a0db80195b9fc597f843/" rel="bookmark">
			wireshake分析stun协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不知道为什么，我用wireshake过滤stun协议过滤不出来，抓包发现解析出来的和3478端口交互的都是udp的数据，弄个半天没弄好，想着udp就udp吧，反正是为了学习，顺道写篇博客记录一下。
过滤掉UDP包头后，前两位是0，对应stun协议的前两位，前两个字节整体为0x0001 是bind request请求
这两个字节为0，说明这个请求的消息只有头部，没有body，没错。
这一段，前面4字节是cookie，后面 Transaction Id 记录下就行，和响应等会对比下
这个是从3478发往本地的包，照例过滤出UDP的包头后，0101不就是bind reponse么，
这是stun消息体的长度，算一下，68字节，记录记录
这一长串是cookie 和 Transaction Id ，比较一下21 12 a4 42 37 76 79 72 74 57 6d 68 4f 58 71 44 没错，他就是刚才那个请求的响应。
剩下的就是message body了，先数一下看包头对应的length对不对，一行16字节，16*4+4=68，没错，看来目前分析的还是正确的，
接下来看看message body中的各个attributes,attributes采用TLV编码，一个一个看
type是0x0020,查一下0x0020:XOR-MAPPED-ADDRESS，这个貌似是老版本才有的，先不管了，先分析着。0x0080 是长度， 说明后面8字节就对应ip和端口，就不分析了接着分析下一条属性
跳过上一个属性的IP和端口那八个字节可以看到是type是0x0001，对应MAPPED-ADDRES，这个就是我们通过coturn映射出来的地址，嘿嘿，length也是0x0008，照例跳过下面的八个字节的ip和端口，
这个属性的type是0x802b,length还是0x0008,RESPONSE-ORIGIN，看来这几个属性格式都一样。
我靠！！！，这时候瞎点突然发现，右键点击协议首选项，选择stun协议，tcp默认端口是3478,udp默认的不是，这里试着修改为3478,确定之后，我哭了，原来问题在这里，终于能过滤出来stun包了。
不过对着UDP分析了半天，这边一对照发现，分析的没错，那也挺好，印象更深刻了。
好了好了，再记录一下这篇博客，分析stun协议可以对照这个博客分析。
STUN协议解析
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51c23620b9ff8f2533f8cee097e1a3e1/" rel="bookmark">
			PyCharm 的初始设置及基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyCharm 的初始设置说明 目标 PyCharm 的初始设置说明目标01. 恢复 PyCharm 的初始设置02. 第一次启动 PyCharm2.1 导入配置信息2.2 选择许可协议2.3 PyCharm 的配置初始界面2.4 欢迎界面 03. 新建/打开一个 Python 项目3.1 项目简介3.2 打开 Python 项目3.3 设置项目使用的解释器版本3.4 新建项目 04. 设置 PyCharm 的字体显示05. PyCharm 的升级以及其他5.1 安装和启动步骤5.2 设置专业版启动图标5.3 卸载之前版本的 PyCharm5.4 教育版安装演练1. 解压缩下载后的安装包2. 将解压缩后的目录移动到 `/opt` 目录下，可以方便其他用户使用3. 启动 `PyCharm`5.5 设置启动图标 PyCharm 注释目标01. 注释的作用02. 单行注释(行注释)这是第一个单行注释 在代码后面增加的单行注释03. 多行注释（块注释）什么时候需要使用注释？关于代码规范 pycharm的基本使用Pycharm的基本使用 目标 PyCharm 的官方网站地址是：https://www.jetbrains.com/pycharm/第一次启动 PyCharm新建一个 Python 项目设置 PyCharm 的字体显示PyCharm 的升级以及其他 PyCharm 的官方网站链接： https://www.jetbrains.com/pycharm/
01. 恢复 PyCharm 的初始设置 PyCharm的 配置信息 是保存在 用户家目录下 的 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51c23620b9ff8f2533f8cee097e1a3e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae719738986dae727f799383ef9b532a/" rel="bookmark">
			六、Hive-DML数据导入导出操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据导入 1．语法 hive&gt; load data [local] inpath '/opt/module/datas/student.txt' overwrite | into table student [partition (partcol1=val1,…)]; （1）load data:表示加载数据 （2）local:表示从本地加载数据到hive表；否则从HDFS加载数据到hive表 （3）inpath:表示加载数据的路径 （4）overwrite:表示覆盖表中已有数据，否则表示追加 （5）into table:表示加载到哪张表 （6）student:表示具体的表 （7）partition:表示上传到指定分区 2、实操案例 2.1 创建一张表 hive (default)&gt; create table student(id string, name string) row format delimited fields terminated by ‘\t’;
2.2 加载本地文件到hive hive (default)&gt; load data local inpath ‘/opt/module/datas/student.txt’ into table default.student;
2.3 加载HDFS文件到hive中 上传文件到HDFS hive (default)&gt; dfs -put /opt/module/datas/student.txt /user/root/hive;
加载HDFS上数据
hive (default)&gt; load data inpath ‘/user//hive/student.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae719738986dae727f799383ef9b532a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d71aa66ef9f3895cf3eab7a2665f1ab/" rel="bookmark">
			Potplayer播放器安装后总是遇到BUG
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Potplayer装了好多次，总是会遇到下面这个BUG，有些视频打开无声音体验感很不爽。
“当前音频无法播放，directX驱动没有安装或者音频设备被禁用，某些设备需要耳机扬声器链接音频设备输出。”
最终找到解决办法，到完美解码器下载神器，按照提示一路安装即可解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/424e57bb5302a673945fb8171e0a7712/" rel="bookmark">
			设计模式的应用场景(19)--访问者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		访问者模式 定义：封装一些施加于某种数据结构上的操作，一旦这些操作需要改变的话，接受这个操作的数据结构可以保持不变。
优点：使用访问者模式，对于原来的类层次增加新的操作只需要实现一个具体访问者角色，而不必改变整个类层次。每个具体的访问者角色都对应于一个相关操作。
缺点：不适合具体元素角色经常发生变化的情况。每增加一个元素类都需要修改访问者类（也包括访问者类的子类或者实现类），修改起来相当麻烦。也就是说，在元素类数目不确定的情况下，应该慎用访问者模式。
使用场合：当一个对象结构包括很多类对象，它们有不同的接口，而系统要求这些对象实施一些依赖于某具体类的操作时，就可以使用访问者模式。
小巩要设计超市收银系统，碰到了困难，有的按重量计价，有的按物件计价，还有其他计价方式。
这时候可以使用访问者模式。
首先设计抽象元素类，提供访问者需要的accept方法
public interface Goods { double accept(Visitor visitor); } 具体元素类，包括猪肉类，，酒类，电视机类
public class Pig implements Goods { public double accountByUnit() { System.out.println("猪肉按斤计价,购买的数量为：" + getCount() + "斤，购买的单价为：" + getPrice() + "，总价为：" + getCount() * getPrice()); return getCount() * getPrice(); } public double accept(Visitor visitor) { return visitor.visit(this); } public float getCount(){ return count; } public void setCount(float count){ this.count = count; } public float getPrice(){ return price; } public void setPrice(float price){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/424e57bb5302a673945fb8171e0a7712/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/487480b9fb4d3b964c35862bc07f4cec/" rel="bookmark">
			webpack学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、webpack从入门到真实项目配置 1、按照教程操作时，遇到了一些报错情况，基本都是版本问题导致的。
2、package.json的"scripts"中可以配置一些常用的操作。
3、Babel 可以让你使用 ES2015/16/17 写代码而不用顾忌浏览器的问题，Babel 可以帮你转换代码。配置 Babel 推荐使用 .babelrc 文件管理。
babel-loader 用于让 webpack 知道如何运行 babel；babel-core可以看做编译器，这个库知道如何解析代码；babel-preset-env 这个库可以根据环境的不同转换代码； 4、webpack-config.js
1）module-&gt;rules：test做匹配、use配置使用的loader和一些参数、exclude是不包括的路径
2）module.exports = {
entry: {
// bundle 和 vendor 都是自己随便取名的，会映射到 [name] 中
bundle: 自己的代码,
vendor: 依赖库的代码
}, // 入口文件
output: {
path: path.resolve(__dirname, ‘build’), // 必须使用绝对地址，输出文件夹
filename: ‘[name].[chunkhash].js’, // 打包后输出文件的文件名，使用哈希来保证缓存
publicPath: ‘build/’ // 知道如何寻找资源（例如处理后的大图片）
}
}
5、处理图片：url-loader 和 file-loader
6、处理CSS：css-loader（可以让 CSS 文件也支持 impost，并且会解析 CSS 文件） 和 style-loader（可以将解析出来的 CSS 通过标签的形式插入到 HTML 中，依赖前者。），可以在options中配置是否开启CSS 模块化，这时候CSS整合到JS中，会造成 JS 文件的大小变大，操作 DOM 也会造成性能上的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/487480b9fb4d3b964c35862bc07f4cec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4578bb19a8d0608b1a7f067a9410b568/" rel="bookmark">
			位、字、字节的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.位和字节的关系：
位：bit （“比特”）
字节：Byte （“拜特”）
1 Byte = 8 bit
计算机内存中，最小的存储单位是“位（bit）”，8个“位”构成一个“字节（byte），字节是内存的基本单位，也是编址单位。
例：某计算机的内存是2GB，指的就是该计算机的内存中共有2×1024×1024×1024个字节。
2.字，字长和字节的关系：
"字"由若干个字节构成，字的位数叫做字长。（这个位数就是01代码的位数）
区别：例如一台8位（bit）机，它的1个字就等于1个字节，字长为8位。如果是一台16位（bit）机，那么，它的1个字就由2个字节构成，字长为16位。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c00210ecb7a3511173a7ab874586936/" rel="bookmark">
			mysql数据库底层原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MySQL 的基本定义： A．术语介绍
1. 数据库（Database）
是按照数据结构来组织、存储和管理数据的仓库。 每个数据库都有一个或多个不同的API用于创建、访问、管理、搜索和复制所保存的数据。 2. RDBMS（Relational Database Management System）
关系数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle公司。 是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。 特点：
数据以表格的形式出现。 每行为各种记录名称。 每列为记录名称所对应的数据域。 许多的行和列组成一张表单。 若干的表单组成Database。 RDBMS术语：
数据库： 数据库是一些关联表的集合。 数据表： 表示数据的矩阵。 列： 一列（数据元素）包含了相同类型的数据。 行： 一行是一组相关的数据。 冗余： 存储两倍数据，冗余降低了性能，但提高了数据的安全性。 主键： 主键是唯一的，一个数据表中只能包含一个主键。 外键： 外键用于关联两个表。 复合键： 复合键（组合键）将多个列作为一个索引键，一般用于复合索引。 索引： 使用索引可快速访问数据库表中的特定信息，索引是对数据库表中一列或多列的值进行排序的一种结构。 参照完整性： 参照完整性要求关系中不允许引用不存在的实体，与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。 B．MySQL常用命令
1. 管理MySQL的命令
MySQL的用户设置，只需要在MySQL数据库中的user表中添加新用户即可。（use mysql; insert into user() values()）。 USE 数据库名 ：选择要操作的MySQL数据库，使用该命令后所有MySQL命令都只针对该数据库。 SHOW DATABASES ：列出MySQL数据库管理系统的数据库列表。 SHOW TABLES ：显示指定数据库的所有表，使用该命令前需要使用use命令来选择要操作的数据库。 SHOW COLUMNS FROM 数据表名 ：显示数据表的属性，属性类型，主键信息，是否NULL，默认值等其它信息。 SHOW INDEX FROM 数据表名 ： 显示数据表的详细索引信息，包括 PRIMARY KEY（主键）。 SHOW TABLE STATUS FROM 数据库名 LIKE ‘pattern’\G ：该命令输出MySQL数据库管理系统的性能及统计信息。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c00210ecb7a3511173a7ab874586936/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6ee13912ea6ccb3257de942287d9a24/" rel="bookmark">
			关于CAN总线的位时间/同步段/传播时间段/相位缓冲段/采样点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据 CAN 规范的要求，总线上的所有器件都必须使用相同的比特率才能完成通信。然而，并非所有器件都要求具有相同的主振荡器时钟频率。所以，CAN 总线能够在一定的范围内容忍总线上 CAN 节点的通信波特率的偏差，这种机能使得 CAN 总线有很强的容错性，同时也降低了对每个节点的振荡器精度。所以，实际上，CAN 总线的波特率是一个范围。举个例子，假设定义的波特率是 250KB/s，但是实际上根据对寄存器的设置，实际的波特率可能为 200-300KB/s（具体值取决于寄存器的设置）。
首先了解一下 CAN 总线系统中的两个时钟：晶振时钟周期和CAN时钟周期：
晶振时钟周期：是由单片机振荡器的晶振频率决定的，指的是振荡器每震荡一次所消耗的时间长度，也是整个系统中最小的时间单位；CAN时钟周期：CAN时钟是由系统时钟分频而来的一个时间长度值，实际上就是一个时间份额TQ。计算公式：CAN时钟周期 = 2 × 晶振时钟周期 × BRP，其中BRP叫做波特率预分频值（baudrate prescaler）； 如上图所述，根据CAN规范，每一个CAN位时间 （Nominal Bit Time，NBT）被分成4个时间段：同步段（Sync_Seg）、传播时间段（Prop_Seg）、相位缓冲段1（Phase_Seg1）和相位缓冲段2（Phase_Seg2），如下图所示：
而采样点则设计在相位缓冲段1和相位缓冲段2之间。如下图所示：
如果用公式来表示，就是：
上述每个段又由若干个时间份额（time quanta，TQ）组成，时间份额 TQ 是位时间的基本时间单元，下面详细解释一下：
1、同步段（Synchronization Segment）
同步段（SyncSeg）为 NBT 中的首段，用于同步CAN总线上的各个节点。输入信号的跳变沿就发生在同步段，该段持续时间为 1 TQ。同步段用于同步总线上的各个节点，一个位的跳边沿在此时间段内。
2、传播段（Propagation Segment）
传播段（PropSeg）用于补偿各节点之间的物理传输延迟时间。传输延迟时间为信号在总线上传播时间的两倍，包括总线驱动器延迟时间。传播段的长度一般有一个取值范围，不同的控制器不完全一致，典型值为 1 – 8 TQ。
3、相位缓冲段（Phase Buffer Segment1）
相位缓冲段用于补偿节点间的晶振误差，又分为相位缓冲段1（PS1）和相位缓冲段2（PS2），在这个时间段的末端进行总线状态的采样。两个相位缓冲段PS1和PS2用于补偿总线上的边沿相位误差。通过再同步，可以延长 PS1（或缩短PS2）。
同理，不同的控制器，PS1/PS2 的取值范围不完全一致，一般 PS1 为 1 – 8 TQ，PS2 为 2 – 8 TQ。
4、采样点
采样点是位时间内的一个时间点。在该时间点，读取总线电平并进行分析。采样点位于相位缓冲段 PS1 的终点。但当采样模式设置为每位采样 3 次时例外。这种情况下，在 PS1 的终点仍然对某一位进行采样时，前两次的采样时间间隔为 TQ / 2，而该位的值将根据三个采样值中至少两次采样的相同值决定。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6ee13912ea6ccb3257de942287d9a24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95d3d182232107c132e51a491af818d3/" rel="bookmark">
			jmeter教程系列（6）--CSV 数据文件设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jmeter教程系列–CSV 数据文件设置 (1)创建csv格式的测试数据文件(编码格式为UTF-8）
(2)选择要读取的csv格式的文件
(3)设置文件的编码UTF-8(csv文件进行保存操作时设置的文件编码相同)
(4)设置文件需要读取的参数
(5)设置文件读取内容的策略
(6)引用读取到的变量名称使用${username} ${password}
变量引用及结果展示：
引用变量使用${变量名}
csv文件架构：
测试结果截图：
（1）CSV文件格式编码必须为UTF-8
（2）CSV文件对正版的OFFICE有效，对于WPS中创建的CSV文件无效
（3）每次修改数据后都要进行另存为操作，覆盖原来的csv格式的文件
（4）变量的引用使用${变量名}
（5）读取文件的时候进行忽略首行数据操作，在CSV组件中可以进行设置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9e94ff5acad44ae0053bc021466738d/" rel="bookmark">
			ASP.NET 几种常用的页面传值的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Session
维护会话数据,会话就是给定用户与Web应用程序之间的交互。会话由HttpSessionState对象表示。为了维护一个特定用户的状态信息。可以使用
Controller类或者Global.asax中的Session属性
经典案例:在线购物车是必须按照用户去维护数据。
如果10个人全部登录到一个在线商场,每个个体都将有一组她(他)想要购买的项并且这个数据需要维护。
当新的用户登录到Web应用程序时,.NET运行库将自动给这个用户分配一个唯一的会话ID,用来识别这个用户。每个会话ID被分配一个自定义的HttpSessionState类型实例,以保存该用户的数据。
格式:
Session[“Name”]=“Value(Or Object)”;
在后台Controller控制器中使用:
HomeController.cs
public ActionResult Index() { //添加session /* Session 个人对话:存放在服务器端的状态,所有的视图中都保存某个数据, 服务器端对象,默认生命周期为20分钟 信息保存在服务器端,相对比较安全 */ Session["user"] = new UserModel() { Id=15000, UserName = "jack",PassWord="jiao7060158",Address="XuZhou"}; string sessionId = Session.SessionID; //Session.Remove("user");//移除指定name的session //Session.Abandon();//取消当前的session //Session.Clear();//清除所有的session //真正部署时ISS和配置文件中都需要配置 Session.Timeout = 30;//设置session的失效时间,以分钟为单位 return View(); } Index()动作方法对应的View视图Index.cshtml:
在该视图中,实现点击产品首页链接,进行跳转,
在Product页面接收传递的参数
@{ Layout = null; } &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta name="viewport" content="width=device-width" /&gt; &lt;title&gt;首页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;a href="/Product/Index" target="_blank"&gt;产品首页&lt;/a&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; ProductController.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9e94ff5acad44ae0053bc021466738d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64d8fe41ff297dc80daefb95e7ddcbcc/" rel="bookmark">
			jmeter教程系列（4）--响应断言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jmeter教程系列–响应断言 响应断言整理介绍：
（1）设置断言字段（响应文本，响应代码，响应信息，请求消息头(resquest Headers)，响应数据头(response Headers)）
（2）设置断言的匹配规则
（3）要测试的模式上添加要断言的内容（要断言的数据不允许有空格）
断言匹配规则介绍：
（1）包括：包括你指定的内容，支持正则匹配　支持对正则表达式提取器引用名称做判断
（2）匹配：响应内容要完全匹配内容，不区分大小写
（3）equals：完全相等，区分大小写
（4）substring：响应内容包括匹配内容即可
jmeter脚本示意图：
断言结果显示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2904ba7fbedd8596e087186cea9dceb/" rel="bookmark">
			SpringBootSecurity（三）网页版登录添加自定义登录页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自定义登录页面 前面无论是使用默认配置，还是自定义配置类，都是使用的springboot-security自带的登录页面，自带的登录页面在这个版本虽然设计的非常不错，但是在实际开发中，我们通常还是使用自己的登录页面。下面来写一个非常简单的登录页面：
这个页面只有填写用户名和密码的地方，然后就是一个form表单提交，没有任何其他内容。特别注意！！这里页面虽然引入了thymeleaf模板，但是没有使用thymeleaf的任何标签属性，使用的是原生的html标签。继续下面，然后是定义登录页面的路径：
这样登录页面就添加完成了。
修改配置类 在配置类中添加自定义登录页面很简单，定义登录页面链接即可：
配置完成后，启动项目，访问登录页面，可以看到这样一个错误：
显示重定向次数过多。原来前面我们授权配置的时候，所有自定义的路径在未登录的情况下，都会重定向到登录页面，现在登录路径也是自定义的，所以它一直在自我重定向。登录路径本身要配置成不需要授权就能访问的路径才合理。配置方式很简单，只需要加上一个 permitAll 方法即可：
现在重启项目，访问登录可以正常访问，输入账号也可以正常访问了！
csrf配置 上面的页面和配置类修改好了以后，输入账号登录，却发现登录一直不成功，总是会跳转到登录页面。这是什么原因呢？上面的提到了页面使用的是原生的html标签，没有使用thymeleaf模板的属性。先说这种原生的情况，之所以登录不成功，原因是Spring Security默认是开启CSRF的，所以需要请求中包含CSRF的token信息，在其官方文档中，提供了在form中嵌入一个hidden标签来获取token信息，其原理是，hidden标签使用了Spring Security提供的标签，即${_csrf.parameterName}、${_csrf.token}， 后台页面渲染过程中，将此标签解所对应的值解析出来，这样，我们的form表单，就嵌入了Spring Security的所需的token信息，在后续的提交登录请求时，就不会出现没有CSRF token的异常。做法如下：
这时候登录，就发现可以成功。在springboot2.1.x版本下，还有第二种更好的解决方案，就是使用thymeleaf模板的form标签属性：
在form标签中，使用th:action属性，这样会在表单中默认添加一个hidden的input标签，效果和第一种解决方式类似，查看源码，就可以看到：
另外，还有一个解决办法是，通过关闭CSRF来解决，这个几乎在任何场景中都能解决这个问题（上面这个解决方案，可能在某些渲染模板不能解析出来token值，不过可以通过后台程序来获取token值，然后自己定义变量来渲染到form中，这个也是可以的）。具体的做法是通过修改配置文件来关闭，我这里使用的是SpringBoot开发的项目，配置文件直接写在配置类中，通过.csrf().disable()来关闭。不过这种方案，会迎来CSRF攻击，不建议在生产环境中使用，如果系统对外界做了隔离，这样做也是可以的。大部分的生产环境采用的也多是这种方案。
上面三种解决方案都可以解决登录不成功的问题。
配置登录成功后的默认页面 现在security登录成功后默认会跳转到一个路径，这个路径就是登录链接去掉后面的/login，这个默认跳转也是可以配置的：
然后再把默认页面改为/home路径：
现在我们登录成功，跳转的就是/home：
配置登出 除了登录，security还有自带的登出，即退出系统功能，默认路径就是/logout。我们可以在home页面中加一个登出操作：
退出后，默认进入的自然是登录页面，但是浏览器路径上面，要显示出刚才是退出系统了。所以应该显示的路径是/login?logout，但是由于这个路径没有授权，会再次跳转到登录页面，显示的也就还是/login，所以我们对登出也要进行授权：
现在显示的就是正常的退出后的路径：
代码地址 ： https://gitee.com/blueses/spring-boot-security 03
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3654f1a17492fa12923fe51939bf1694/" rel="bookmark">
			Recoil - Facebook 官方 React 状态管理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说到状态管理器，轮子满天飞。在 Class 时代，redux 与 mobx 几乎占据了全部市场，几乎没有没用过 redux 的同学。随着 Hooks 的诞生，新的一批轮子应运而生，其中有代表性的有 unstated-next、constate 等等。
当然无论什么轮子，要解决的问题都是一样的：跨组件状态共享。在解决这个核心问题的同时，需要尽可能的满足以下几个特性：
TypeScript 支持
友好的异步支持
支持状态互相依赖
同时支持 Class 与 Hooks 组件
使用简单
Recoil 体验 最近，facebook 官方出了一个状态管理器解决方案 Recoil[1]，我们来体验一下。
准备工作 使用 Recoil，我们需要在项目最外层包一个 RecoilRoot ，这个和大部分状态管理器一致，通过 context 来跨组件传递数据。
import React from 'react'; import { RecoilRoot } from 'recoil'; function App() { return ( &lt;RecoilRoot&gt; ... &lt;/RecoilRoot&gt; ); } 跨组件状态共享 状态最简单的就是定义和使用。在 Recoil 中，通过 atom 来定义一个状态。
const inputValueState = atom({ key: "inputValue", default: "" }); 如上面的代码所示，我们定义了一个 inputValue 状态，它的默认值是空字符串。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3654f1a17492fa12923fe51939bf1694/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c29708b67c6f1dbb01c4b1245cb1f168/" rel="bookmark">
			springCloud技术总结分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.简介2 项目搭建2.1 Commons2.1.1 pojo2.1.2 service2.1.3 util 2.2 item service 商品服务2.3 user service 用户服务2.4 order service 订单服务2.5 测试 3. eureka 注册与发现3.1 实例操作3.1.1 eureka 注册与发现3.1.2 service provider 服务提供者 4.ribbon4.1 项目搭建4.2 eureka 和 “服务提供者”的高可用4.3 ribbon 负载均衡4.4 ribbon 重试 5 hystrix 断路器5.1 原理简介5.2 实例操作5.3 hystrix dashboard 断路器仪表盘 6.feignfeign + ribbon 负载均衡和重试feign + hystrix 降级feign + hystrix 监控和熔断测试order service 调用商品库存服务和用户服务hystrix + turbine 集群聚合监控 7. zuul API网关zuul 路由实例操作zuul 过滤实例操作 8. config 配置中心config创建项目应用 9. Spring Cloud Busconfig bus + rabbitmq 消息总线配置刷新config 本地文系统 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c29708b67c6f1dbb01c4b1245cb1f168/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93eb745d5319089869c641e25b5421bb/" rel="bookmark">
			windows 启动jupyter 提示 cannot import name AsyncGenerator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当输入jupyter notebook 后是可以正常启动本地服务，但进入jupyter的页面后，就会显示连接不上服务器，在控制窗口上显示异常提示 cannot import name ‘AsyncGenerator’
原因是prompt_toolkit这依赖的版本不匹配（我这使用的python 3.6）
解决办法就是降低版本
pip install --upgrade prompt-toolkit==2.0.1
安装成功后，执行
python -m ipykernel --version
如果有版本号，那问题就解决了，jupyter可以正常使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3ba3e98791fd07d1c54daff274aff08/" rel="bookmark">
			计算机组成原理运算器设计实验之8位可控加减法电路设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个实验的本意是用一位全加器和逻辑门搭建电路。用全加器和异或门也可以完成。这里涉及两个“异或”的知识点：
1.位变量a和0异或，结果为a；和1异或，结果为~a（取反）
2.溢出标志可以用最高位（符号位）进位和次高位进位异或得到。即这两个进位相同则不溢出，否则溢出。
步骤1
步骤2：可以通过复制拖拽得到如下图
步骤3，连线如图
步骤4，保存并复制保存代码
步骤5将复制的代码粘贴到Educoder实验的代码框。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/488fcfbfd7eb40527830bb8b14313931/" rel="bookmark">
			Docker 离线安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明
使用虚拟机真实模仿离线环境
虚拟机系统为 CentOS 7.5.1804（kernel-3.10.0-862.el7.x86_64）
本文使用 tgz 文件 离线安装 Docker
提示
如果使用非root用户安装docker，则需要先将该用户加入docker用户组。
创建 docker 用户组 sudo groupadd docker将用户添加到 docker用户组 sudo usermod -aG docker $USER刷新用户组的变更 newgrp docker执行 groups 命令查看当前用户所在用户组，有 docker 则表示加入成功。 安装步骤 下载 Docker 二进制文件（离线安装包）：下载地址
本文使用 /x86_64/docker-17.12.1-ce.tgz，注意对应操作系统类型。通过 FTP工具将 docker-17.12.1-ce.tgz 上传到服务器上解压安装包
tar zxf docker-17.12.1-ce.tgz将docker 相关命令拷贝到 /usr/bin，方便直接运行命令
sudo cp docker/* /usr/bin/启动Docker守护程序
sudo dockerd &amp;验证是否安装成功，执行docker info命令，若正常打印版本信息则安装成功。报错则参考docker环境问题清单进行排查。 另外：可通过运行hello-world镜像进行验证
事先准备好 hello-world 镜像 tar 文件并上传到服务器上（下载链接）通过 docker load -i {tar文件名} 加载镜像执行 docker run hello-world 拉起容器，通过日志判断容器是否成功运行。 如何停止 docker 服务？ 方式一：根据进程号(pid)停止docker服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/488fcfbfd7eb40527830bb8b14313931/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4a4a47e5eec5ebfcc55897b32b1bb25/" rel="bookmark">
			c#图片上传和文件上传Api接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.图片上传 Random rd = new Random(); #region 图片上传 /// &lt;summary&gt; /// 图片上传 /// &lt;/summary&gt; /// &lt;param name="type"&gt;projectPhoto 项目图片 projectRecordPhoto 项目大事记图片 shot 随手拍图片 shotSafe 安全检查图片&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; [HttpPost] [Route("UploadPhoto")] [Description("图片上传")] public async Task&lt;HttpResponseMessage&gt; UploadPhoto(string type = "") { try { string guid = Guid.NewGuid().ToString(); ; if (!Request.Content.IsMimeMultipartContent()) { throw new HttpResponseException(HttpStatusCode.UnsupportedMediaType); } string root = "/Upload/" + type; string uploadFolderPath = HostingEnvironment.MapPath(root); string path = uploadFolderPath + guid; //如果路径不存在，创建路径 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4a4a47e5eec5ebfcc55897b32b1bb25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fabb56838de8a434808669db52dc1af/" rel="bookmark">
			cox计算C-index及两模型进行C-index的比较，survcomp的安装及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算COX模型的C-index 两个COX模型的比较 PART1 计算COX的C-index
方法1：基于cox直接生成系数以及计算的C-index值
library("survminer") library("survival") ######### 生成COX模型 cox_model &lt;- coxph() # 直接查看coxph summary(cox_model) # call之后： Concordance= *** (se = *** ) 即是C-index # 查看cindex - concordance # 可以看出这种方法输出了C指数，也输出了标准误，那么95%可信区间就可以通过加减1.96*se得到。 # 生成cox回归模型的系数以及95%置信区间，查看AIC library(tableone) ShowRegTable(data) ShowRegTable(data, digits = 3) AIC(data) summary(data) #可直接查看C-index以及se tip：通过relevel或者level函数中，设置label的顺序，可以选择参照组，即排名第一个即为参照组。
方法2：基于rms包的rcorr.cens()直接生成C-index，
但是做下来好像C-index偏低？不知道为什么
library(rms) CstatisticCI &lt;- function(x) { se &lt;- x["S.D."]/sqrt(x["n"]) Low95 &lt;- x["C Index"] - 1.96*se Upper95 &lt;- x["C Index"] + 1.96*se cbind(x["C Index"], Low95, Upper95) } cindex &lt;- rcorr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fabb56838de8a434808669db52dc1af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b1683981bf006fb42b1365469a38f0a/" rel="bookmark">
			numpy.loadtxt()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 np.loadtxt()用于从文本加载数据。
文本文件中的每一行必须含有相同的数据。
语法 loadtxt(fname, dtype=&lt;class 'float'&gt;, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0)
fname ：要读取的文件、文件名、或生成器。
dtype ：数据类型，默认float。
comments： 注释，如果行的开头为#就会跳过该行。
delimiter ：分隔符，默认是空格。
skiprows： 跳过前几行读取，默认是0，必须是int整型。
usecols ：要读取哪些列，0是第一列。例如，usecols = （1,4,5）将提取第2，第5和第6列。会把每一列当成一个向量输出, 而不是合并在一起。默认读取所有列。
unpack：如果为True，将分列读取。
对数据进行预处理。
我们可以先定义一个函数， 这里的converters是一个字典, 表示第零列使用函数add_one来进行预处理
def add_one(x): return int(x)+1 #注意到这里使用的字符的数据结构 (a, b) = np.loadtxt('test.txt', dtype=int, skiprows=1, converters={0:add_one}, comments='#', delimiter=',', usecols=(0, 2), unpack=True) print(a, b) 输出结果为： [2 5 8] [3 6 9]	#原结果为[1 4 7][3 6 9] 问题 今天在ipython中读取文件时，
代码为：
import numpy as np x = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b1683981bf006fb42b1365469a38f0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aa3490ad0cd6cfb6cf6dd4471e70718/" rel="bookmark">
			「力扣」第 76 题：最小覆盖子串（滑动窗口例题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 可能可以参考的模板写法：使用字符频数数组，用加法：加法 `continue` 的写法；加法，不 `continue` 的写法； 加法，用哈希表数组，减法哈希表，用减法比较麻烦的加法： 可能可以参考的模板写法： public class Solution { public String minWindow(String s, String t) { // 起始的时候，都位于 0，同方向移动 int left = 0; int right = 0; // 根据题意设计状态变量 while (right &lt; len) { // 在 right 右移的过程中维护状态变量的定义 if () { // 维护状态变量的定义 } // 右边界右移 1 格 right++; // 状态变量满足一定条件，窗口是一个可行解 while ( ) { // 在 left 右移的过程中维护状态变量的定义 if () { // 维护状态变量的定义 } // 左边界右移 1 格 left++; } } return 需要的结果变量; } } 使用字符频数数组，用加法： 加法 continue 的写法； public class Solution { public String minWindow(String s, String t) { int sLen = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aa3490ad0cd6cfb6cf6dd4471e70718/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1f285ae8a89915511a1e413ec0bd24e/" rel="bookmark">
			VS2015 MFC对access2010数据库的增删改查，子对话框修改，双击修改，combobox查询。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VS2015 MFC对access2010数据库的增删改查
特点：1，把access内容导入list control后，可以实现双击修改list control的同时，修改数据库，也可以通过子弹窗修改数据库
2，查询可以通过combo—box实现便捷查询
3，删除可以通过单击listcontrol中的任意一行实现删除，如果单击到空白处，会提示
首先准备vs2015与access2010；
先连接数据库：网上方法有很多，我的office是64位的，所以debug，x64。！！！！！！否则连不上，如果你的机子上是32位的office，那就x86。
下面展示 连接数据库的代码。
try { CoInitialize(NULL); m_pConnection = _ConnectionPtr(__uuidof(Connection)); m_pConnection-&gt;ConnectionTimeout = 5; //设置超时时间为5秒 m_pConnection-&gt;ConnectionString = "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=access.accdb;"; m_pConnection-&gt;Open("", "", "", adConnectUnspecified); /*_variant_t RecordsAffected; CString strSql; BSTR bstrSQL; strSql = _T("CREATE TABLE acces(ID INTEGER,图书编码 REAL,图书名称 REAL,图书作者 REAL,出版社名 REAL )");//INTEGER bstrSQL = strSql.AllocSysString(); m_pConnection-&gt;Execute(bstrSQL, &amp;RecordsAffected, adCmdText);*/ AfxMessageBox(_T("数据库连接成功")); } catch (_com_error e) { //m_pConnection-&gt;ConnectionTimeout = 5; //设置超时时间为5秒 AfxMessageBox(_T("数据库连接失败！")); return FALSE; } 一定要分清数据库和表，我这里在工程目录下放置数据库，我的数据库名字是access，数据库可以有很多表，我这次操作的表名是acces，（少一个s）。当然你可以任意名字。
下面展示 创建list control表头的代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1f285ae8a89915511a1e413ec0bd24e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0714b8d8da70cf1f3c8d636721579962/" rel="bookmark">
			如何写c&#43;&#43;简历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、目的：
1、想知道如何写C/C++方面的简历
1、从别人简历哪里了解一下自己的不足
二、参考
1、c++软件工程师个人简历大全 1、转：C/C++程序员简历模板
1、C++工程师个人简历范文
三、简历模板：
1、
1、
一、目的： 1、想知道如何写C/C++方面的简历 1、从别人简历哪里了解一下自己的不足 二、参考 1、c++软件工程师个人简历大全 https://www.51test.net/show/3041489.html
①总结：good：了解了其实自己的C++项目经验及其不足，需要不断的提高，最好自己拿一些网上的案例进行练手，这样也是属于自己的项目经验中。
1、转：C/C++程序员简历模板 https://blog.csdn.net/weixin_33935505/article/details/93501497?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&amp;spm=1001.2101.3001.4242
总结：good，适合多看看；总结：FAT思想很是不错，Feature：是什么；Advantage：比别人好在哪些地方 ；Benefit：如果雇佣你，招聘方会得到什么好处总结：我喜欢记录分享博客，是个优势可以添加到简历当中 1、C++工程师个人简历范文 http://www.capabcv.com/resumecase/27689.html
总结：good，参考参考 三、简历模板： 1、 https://www.job592.com/doc/job1897.html
直接下载，无需注册 1、 https://www.100chui.com/resume/detail-1264/
要注册 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e705861795bd876b6e679de80d1cab08/" rel="bookmark">
			[SV]SystemVerilog二維數組的初始化和約束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SystemVerilog 2d array initialization &amp; randomize 前言：二维数组是数组的数组。二维数组被组织成矩阵，矩阵可以表示为行和列的集合。
一、SystemVerilog二維數組語法 1.1、SystemVerilog二維數組聲明 data_type array_name [rows][columns]; int array [2:0][3:0]; 二维数组中的数据以表格形式存储，如下图所示。 1.2、SystemVerilog二維數組初始化 array = '{ '{0,1,2,3}, '{4,5,6,7}, '{8,9,10,11}}; 1.3、SystemVerilog二維數組實例 module two_d_array; //declaration of array’s int array[2:0][3:0]; //2 dimension array initial begin //array initialization array = '{'{0,1,2,3},'{4,5,6,7},'{8,9,10,11}}; //displaying array elements $display("-------displaying 2d array-------"); foreach(array[i,j]) $display("\t array[%0d][%0d] = %0d",i,j,array[i][j]); end endmodule Simulation Output -------displaying 2d array------- array3[2][3] = 0 array3[2][2] = 1 array3[2][1] = 2 array3[2][0] = 3 array3[1][3] = 4 array3[1][2] = 5 array3[1][1] = 6 array3[1][0] = 7 array3[0][3] = 8 array3[0][2] = 9 array3[0][1] = 10 array3[0][0] = 11 二、SystemVerilog --- Solving Sudoku 在SystemVerilog中解决数独问题只不过是指定带有约束的规则。有五个限制条件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e705861795bd876b6e679de80d1cab08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db69a53fd01a0ec60a149e2777a6c5a8/" rel="bookmark">
			解决springboot项目无法关闭druid连接池监控功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决springboot项目无法关闭druid连接池监控功能 仅仅注释掉ServletRegistrationBean这个Bean并不能关闭druid连接池监控，因为druid-spring-boot-starter这个starter默认开启了druid监控，自己写的配置类可以生效，自己不写配置类会用默认配置，所以要想完全关闭druid连接池监控，
第一：注释掉ServletRegistrationBean这个Bean；
第二：application.yml中加
spring: datasource: druid: filter: config: enabled: false stat-view-servlet: enabled: false web-stat-filter: enabled: false 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41666af588d5b19c7edb50fa8db92abf/" rel="bookmark">
			css 居中问题的总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.css让浮动的盒子水平居中 解决方法：
给浮动的盒子加一个父盒子，设置宽度跟浮动盒子一样大小，并且overflow:hidden; 设置该盒子为margin: 0 auto; &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; *{ padding: 0; margin: 0; } .box{ width: 400px; height: 300px; background-color: red; } .main{ width: 100px; overflow: hidden; margin: 0 auto; } .child{ width: 100px; height: 100px; background-color: green; margin: 0 auto; float: left; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;div class="main"&gt; &lt;div class="child"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 2.CSS背景颜色 背景图片 居中 重复 固定样式background经验篇 background:url(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41666af588d5b19c7edb50fa8db92abf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b06efefaf55f1938be647d3734937c5b/" rel="bookmark">
			WebBrowser控件自动点击网页中的SPAN标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SPAN标签： &lt;SPAN title=用户信息 class=tabSpan id=shop_tabsTAB_content4 style="BORDER-LEFT-WIDTH: 1px; HEIGHT: 23px; BORDER-RIGHT-WIDTH: 1px; BORDER-BOTTOM-WIDTH: 1px; PADDING-LEFT: 6px; PADDING-RIGHT: 6px; BORDER-TOP-WIDTH: 1px; MARGIN-RIGHT: 2px" name="shop_tabstabs4" jQuery227="2564"&gt;&lt;SPAN class=selected_left&gt;&lt;/SPAN&gt;&lt;SPAN class=selected_right&gt;&lt;/SPAN&gt;&lt;SPAN style="OVERFLOW: hidden; DISPLAY: block"&gt;用户信息&lt;/SPAN&gt;&lt;SPAN class=tabs-closePic style="DISPLAY: none" jQuery227="2568"&gt;&lt;/SPAN&gt;&lt;/SPAN&gt; 用自编函数找到上面的网页元素，并发送点击代码：
bb = FindHtmlElement("用户信息", WebBrowserEx1.Document, "SPAN", "title", True) bb.InvokeMember("click") '点击无效 bb.RaiseEvent("onclick") '点击无效 bb.InvokeMember("MouseDown") '点击无效 bb.InvokeMember("onMouseDown") '点击无效，InvokeMember不检查调用成员（onMouseDown）是否有效 bb.RaiseEvent("onMouseDown") '点击生效，参数不分大小写。RaiseEvent会检查，错误则报：值不在预期的范围内 bb.RaiseEvent("onMouseUp") '该行代码可以不需要 以前一直走入了一个误区，以为点击就是一定是click动作，网上找的也都是如何如何clcik span标签没响应，殊不知，只需要简单的一个RaiseEvent("onMouseDown")就解决问题。
注：
RaiseEvent的参数不对，例如你做引用：RaiseEvent("click")，则报错如下：
************** 异常文本 **************
System.ArgumentException: 值不在预期的范围内。
在 System.Windows.Forms.UnsafeNativeMethods.IHTMLElement3.FireEvent(String bstrEventName, IntPtr pvarEventObject)
在 System.Windows.Forms.HtmlElement.RaiseEvent(String eventName)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b06efefaf55f1938be647d3734937c5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c27cc8eba81eb667e2ec0e289a02ad76/" rel="bookmark">
			深入理解docker容器 (1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个程序运行起来后的计算机执行环境的总和，就是我们今天的主角：进程。一个在运行的Docker镜像，其实也是一个进程，下面请听我细细道来。
我们都知道，容器是一个类似"沙盒"的存在，我们的应用可以放到里面，一个系统启动多个"沙盒"，但是它怎么样实现"沙盒"这个功能的呢？
好了不卖关子
这个沙盒就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。
对于 Docker 等大多数 Linux 容器来说，Cgroups 技术是用来制造约束的主要手段，而 Namespace 技术则是用来修改进程视图的主要方法。
我们先来说说Namespace到底是个什么鬼！
我们先启动一个容器Ubuntu；
&gt;$ docker run -it busybox /bin/sh / # 在里面执行ps，你会发现神奇的事情；
/ # ps PID USER TIME COMMAND 1 root 0:00 /bin/sh 10 root 0:00 ps 我们会发/bin/sh 的进程号 PID = 1 在linux中，1号进程是系统刚启动时创建的进程，负责从创建其它子进程。
这就意味着，前面执行的 /bin/sh，以及我们刚刚执行的 ps，已经被 Docker 隔离在了一个跟宿主机完全不同的"世界"当中。
这究竟是怎么做到的呢？
其实你退出系统来看会发现我们所启动的这个docker镜像就是一个进程，比如它的PID=100。但是为什么在容器中就是1呢？
这时候我们的Namespace就起到作用了。
它其实只是 Linux 创建新进程的一个可选参数。我们知道，在 Linux 系统中创建线程的系统调用是 clone()，比如：
int pid = clone(main_function, stack_size, SIGCHLD, NULL); 而当我们用 clone() 系统调用创建一个新进程时，就可以在参数中指定 CLONE_NEWPID 参数，比如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c27cc8eba81eb667e2ec0e289a02ad76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45590434ff536a5cfe7d3206da9b0898/" rel="bookmark">
			计算机考研复试之C语言简答题 开放题目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为考研准备整理，参考网络资料课本资料，主要是c的简答开放题目有用的话可以点个赞，可以看着目录尝试自己回答后在进行往下看 目录
特点
c 语言的主要用途：
c语言为什么要规定，对所有使用的变量要“先定义，后使用”？
为什么使用符号常量
写出一个程序的组成
内存分配方式有三种：
c语言中变量的存储类别
strlen与sizeof的区别：
C 语言以函数为程序的基本单位，有什么好处？
关键字和一般标识符有什么不同？
循环相关
字符数组与字符串是否相同？若不相同，有何区别？
函数的嵌套调用与递归调用有什么区别？
结构体类型与我们前面学过的基本类型有哪些区别？
指针与地址有什么联系？在使用指针的过程中应注意哪些细节？指针类型对于程序设计有哪些意义？
指针和引用
描述一下gcc的编译过程？
c的执行过程
变量的声明与定义有什么区别
C语言中进行函数声明的作用是什么？
简述C语言的隐式类型转换发生的四种情况。
&amp;&amp;和&amp;、||和|有什么区别？
typedef 和 define 有什么区别
请说出const与#define 相比，有何优点？
#include 与 #include “file.h”的区别？
用两个栈实现一个队列的功能？要求给出算法和思路！
特点 简洁紧凑、灵活方便；运算符丰富；数据结构丰富
C是结构式语言；C语法限制不太严格、程序设计自由度大
C语言允许直接访问物理地址，可以直接对硬件进行操作；C语言程序生成代码质量高，程序执行效率高
C语言适用范围大，可移植性好；具有预处理功能；具有递归功能
c语言具有绘图能力和强大的数据处理能力，它是数值计算的高级语言
c 语言的主要用途： C语言可以用来开发许多系统软件和大型应用软件。如UNIX，LINUX等操作系统。 在软件需要对硬件进行操作的场合，用C语言明显优于其它高级语言。例如，各种硬件设备的驱动程序（象显卡驱动程序、打印机驱动程序等）一般都是用C语言编写的。 在图形、图像及动画处理方面，C语言具有绝对优势，特别是游戏软件的开发主要就是使用C语言。 随着计算机网络飞速发展，特别是Internet的出现，计算机通信就显得尤其重要，而通信程序的编制首选就是C语言。 C语言适用于多种操作系统，象WINDOWS、UNIX、LINUX等绝大多数操作系统都支持C语言，其它高级语言未必能得到支持，所以在某个特定操作系统下运行的软件用C语言编制是最佳选择。
c语言为什么要规定，对所有使用的变量要“先定义，后使用”？ 程序中使用的各种变量都应预先加以说明，即先说明，后使用。对变量的说明可以包括三个方面：?数据类型?存储类型?作用域
数据类型决定数据所占内存字节数，数值取值范围，在其上可进行的操作。
对变量先定义后使用的目的是：
1）凡是未被事先定义的不做为变量名，这就能保证程序中变量名使用得正确，便于编译时发现错误，避免变量名使用时出错。
2）每个变量被指定一确定类型，在编译时就能为其分配相应的存储单元。
3）指定每一个变量属于一个类型，便于在编译时据此检查该变量所进行的运算是否合法。
为什么使用符号常量 1）简化书写格式、减少出错率。
2）定义符号常量可以提高程序的可读性，便于程序的调试和修改。
3）符号常量不同于变量，在其作用域内不能被改变和重新赋值。
4）习惯上人们把符号常量名用大写字母表示，变量用小写，以示区别
写出一个程序的组成 程序名、预编译指令、标准的输入输出、c语言的主函数、函数开始标志、定义变量、给变量赋值、输出结果、程序正常结束、函数结束标志
内存分配方式有三种： 1、从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。 2、在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 3、从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由程序员决定，使用非常灵活，但如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，频繁地分配和释放不同大小的堆空间将会产生堆内碎块
c语言中变量的存储类别 变量的存储类别为两大类，静态存储和动态存储 具体有自动auto，寄存器register和静态static和外部extern 局部缺省为auto变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45590434ff536a5cfe7d3206da9b0898/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef29488790f6ca1579c85d9844acff05/" rel="bookmark">
			微信小程序：使用VantUI组件库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序可以支持npm导入第三方库了（https://developers.weixin.qq…）;VantUI是一个不错的移动UI组件库，下面我们在微信小程序中引入
第一步：
在小程序工程的根目录下执行：
npm init -y //初始化 npm i vant-weapp -S --production 第二步：
保证当前你的微信开发者工具是最新版本，然后点击执行“构建npm“
构建成功后会提示：
同时项目根目录中会多出一个目录“miniprogram_npm”，这个就是小程序可以识别的npm第三方库。
第三步：
这时候当我们需要在一个页面中调用vant组件，那么就要在对应的页面json中添加类似如下配置：
{ "usingComponents":{ "van-button":"/miniprogram_npm/vant-weapp/button/index" } } 接着你就可以在wxml中直接调用这个ui组件了。
注意，对于vant库来说其实你并不需要在页面对应的js中import vant-weapp组件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbe75a419c4cacba3959092d3992b1c5/" rel="bookmark">
			手把手教你，使用JWT实现单点登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每天早上七点三十，准时推送干货
JSON Web Token（JWT）是目前最流行的跨域身份验证解决方案之一，今天我们一起来揭开它神秘的面纱！
一、故事起源 说起 JWT，我们先来谈一谈基于传统session认证的方案以及瓶颈。
传统session交互流程，如下图：
当浏览器向服务器发送登录请求时，验证通过之后，会将用户信息存入seesion中，然后服务器会生成一个sessionId放入cookie中，随后返回给浏览器。
当浏览器再次发送请求时，会在请求头部的cookie中放入sessionId，将请求数据一并发送给服务器。
服务器就可以再次从seesion获取用户信息，整个流程完毕！
通常在服务端会设置seesion的时长，例如 30 分钟没有活动，会将已经存放的用户信息从seesion中移除。
session.setMaxInactiveInterval(30 * 60);//30分钟没活动，自动移除 同时，在服务端也可以通过seesion来判断当前用户是否已经登录，如果为空表示没有登录，直接跳转到登录页面；如果不为空，可以从session中获取用户信息即可进行后续操作。
在单体应用中，这样的交互方式，是没啥问题的。
但是，假如应用服务器的请求量变得很大，而单台服务器能支撑的请求量是有限的，这个时候就容易出现请求变慢或者OOM。
解决的办法，要么给单台服务器增加配置，要么增加新的服务器，通过负载均衡来满足业务的需求。
如果是给单台服务器增加配置，请求量继续变大，依然无法支撑业务处理。
显而易见，增加新的服务器，可以实现无限的水平扩展。
但是增加新的服务器之后，不同的服务器之间的sessionId是不一样的，可能在A服务器上已经登录成功了，能从服务器的session中获取用户信息，但是在B服务器上却查不到session信息，此时肯定无比的尴尬，只好退出来继续登录，结果A服务器中的session因为超时失效，登录之后又被强制退出来要求重新登录，想想都挺尴尬～～
面对这种情况，几位大佬于是合起来商议，想出了一个token方案。
将各个应用程序与内存数据库redis相连，对登录成功的用户信息进行一定的算法加密，生成的ID被称为token，将token还有用户的信息存入redis；等用户再次发起请求的时候，将token还有请求数据一并发送给服务器，服务端验证token是否存在redis中，如果存在，表示验证通过，如果不存在，告诉浏览器跳转到登录页面，流程结束。
token方案保证了服务的无状态，所有的信息都是存在分布式缓存中。基于分布式存储，这样可以水平扩展来支持高并发。
当然，现在springboot还提供了session共享方案，类似token方案将session存入到redis中，在集群环境下实现一次登录之后，每个服务器都可以获取到用户信息。
二、JWT是什么 上文中，我们谈到的session还有token的方案，在集群环境下，他们都是靠第三方缓存数据库redis来实现数据的共享。
那有没有一种方案，不用缓存数据库redis来实现用户信息的共享，以达到一次登录，处处可见的效果呢？
答案肯定是有的，就是我们今天要介绍的JWT！
JWT全称JSON Web Token，实现过程简单的说就是用户登录成功之后，将用户的信息进行加密，然后生成一个token返回给客户端，与传统的session交互没太大区别。
交互流程如下：
唯一的不同点就是：token存放了用户的基本信息，更直观一点就是将原本放入redis中的用户数据，放入到token中去了！
这样一来，客户端、服务端都可以从token中获取用户的基本信息，既然客户端可以获取，肯定是不能存放敏感信息的，因为浏览器可以直接从token获取用户信息。
JWT具体长什么样呢？ JWT是由三段信息构成的，将这三段信息文本用.链接一起就构成了JWT字符串。就像这样:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 第一部分：我们称它为头部（header），用于存放token类型和加密协议，一般都是固定的；
第二部分：我们称其为载荷（payload），用户数据就存放在里面；
第三部分：是签证（signature），主要用于服务端的验证；
1、header JWT的头部承载两部分信息：
声明类型，这里是JWT；
声明加密的算法，通常直接使用 HMAC SHA256；
完整的头部就像下面这样的JSON：
{ 'typ': 'JWT', 'alg': 'HS256' } 使用base64加密，构成了第一部分。
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 2、playload 载荷就是存放有效信息的地方，这些有效信息包含三个部分：
标准中注册的声明；
公共的声明；
私有的声明；
其中，标准中注册的声明 (建议但不强制使用)包括如下几个部分 ：
iss: jwt签发者；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbe75a419c4cacba3959092d3992b1c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6d696e408215a81220ef4cdb6e40146/" rel="bookmark">
			HTTP学习(3)--解析报文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇博客介绍了，如何简单的组装报文，现在来处理比较麻烦的另一部分了–解析报文。组装报文实际上是偷了一个懒，把解析工作交给了浏览器。但是，如果直接解析一下实际的报文的话，还是会对报文的结构认识更加深刻一些，下面就来开始吧！
HTTP学习(2)–组装报文
解析报文 模拟报文 我们根据前面博客知道了报文的具体结构，下面就来解析报文，可是哪里来的报文呢？相信，虽然每天都在经历各种报文的传递，但是真正见到过报文的人还是不多吧。让我们来想象一下，报文从产生到传递给客户（或者服务器）被消费掉，其实时间是很短的。所以说，一个报文存在的时间极短，可以报文说就是朝生夕死。这里我们先来提供一个简单的模拟报文，存放在一个文件里面（把流动的报文固定住），这样处理起来比较方便。如果解析成功了，我们再去处理实际的报文。相当于，开发过程中，先使用模拟的数据，等开发完成了，再使用真实的数据。
模拟请求报文
Host: localhost:8080 Content-Type: image/jpeg Content-Length: 112008 如果只是这样看的话，其实是缺少了很多必要的信息的，比如不可见的回车换行符 CRLF。所以我们换一个方式来查看模拟的报文：
这样是不是就非常清晰了，模拟的报文头部每一行包括一个首部字段信息和CRLF，最后还有一个CRLF（这里把它作为结束读取请求头的标识），后面的就是报文体的部分了，这里只考虑报文头部分。因为只要获取了头部，那么剩下的也就见到那了。（对于GET方式，是没有报文体的！）
首先是构造一个模拟的报文头部 这里就是向文件写入头部的信息，构造一个包含简单报文头的文件。
//构造一个简易的 报文头部，比较简陋，但是应该是可以满足学习条件了。 static void createMessage(File file) { try (BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file))) { out.write("Host: localhost:8080\r\n".getBytes(Charset.forName("UTF-8"))); out.write("Content-Type: image/jpeg\r\n".getBytes(Charset.forName("UTF-8"))); out.write("Content-Length: 112008\r\n".getBytes(Charset.forName("UTF-8"))); out.write("\r\n".getBytes(Charset.forName("UTF-8"))); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } 解析报文头部 static void resolve(File file) { try (BufferedInputStream in = new BufferedInputStream(new FileInputStream(file))) { /** * 当取出来的行为空时，意味着已经取出了所有的头部。 * 下面就是数据部分了（这里考虑的是简单的报文，非Multip-part类型的报文） * */ String header = null; do { header = getHeader(in); //每次取一行，即一个首部字段 if ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6d696e408215a81220ef4cdb6e40146/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb2936835b2d189040922a07f208134e/" rel="bookmark">
			C#中正确读取二维数组的各种长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看了网上一些文章，自己写了写没想到大多是都是错的23333
自己重新整理下
int row = array.Rank;//获取维数，维数！返回的是一维二维即1或2
int col = array.GetLength(0);
//获取指定维度中的元素个数，这里也就是列数了。（0是第一维，1表示的是第二维）
//也就是参数为0时返回是列数
//参数1时返回的是行数
int col = array.GetUpperBound(0)+1;
//获取指定维度的索引上限，在加上一个1就是总数，这里表示二维数组的列数
int num = array.Length;//获取整个二维数组的长度，即所有元的个数
//也可以运用length来除以列数或者行数来得到另外一个数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc03487d808127a794d9c3274a9efde8/" rel="bookmark">
			地震处理软件Madagascar安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装系统：Ubunut 18.04 LTS
网上有很多安装教程，但是都比较老了，用的Ubuntu 10, 14的系统，svn指向的链接也已经失效了。
安装包下载
A方法
下载压缩包 https://sourceforge.net/projects/rsf/files/ 2020年5月下载的是Madagascar 3.0.1，看有的教程说，这个链接下载的不是最新的，但是先凑合用吧。附加一个百度网盘下载链接，以防后面这个链接失效或者版本不对https://pan.baidu.com/s/1gWVMCcH69HhxkcDJ8D8CDg
提取码：zsnf
下载后放至 /home/hhh/rsf/文件夹下，作为存放源代码的文件夹
在该文件下运行tar -xvf madagascar-3.0.1.tar.gz 解压缩后，进入解压出的madagascar-3.0文件夹
B方法
网上还有一种是svn 下载
运行 svn co https://github.com/ahay/src/trunk /home/hhh/rsf
备注：
（1）很多老教程用的https://rsf.svn.sourceforge.net/svnroot/rsf/trunk的链接已经失效了。
（2）这里是用的GitHub的地址，但是没有用git 去clone代码，因为前人教程上说svn更新比较方便，可以直接运行svn update下载更新，再用scons install -k 安装更新。但是我的网速比较慢，没有用这种方法。安装依赖
Ubuntu 18.04安装以下依赖，其他版本参考http://www.ahay.org/wiki/Advanced_Installation#Ubuntu sudo apt install libxaw7-dev freeglut3-dev libnetpbm10-dev libgd-dev libplplot-dev libavcodec-dev libcairo2-dev libjpeg-dev swig python-dev python-numpy g++ gfortran libopenmpi-dev libfftw3-dev libsuitesparse-dev python-epydoc scons git emacs25 编译与安装 cd /home/hhh/rsf/madagascar-3.0/ ./configure --prefix=/home/hhh/Software/RSFROOT ./configure API=c++,f90--prefix=/home/hhh/Software/RSFROOT #建立c++，fortran90等的链接，前提是这些选项已经存在在你的系统中并且可用 sudo make sudo make install #scon install -k 修改环境变量 echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc03487d808127a794d9c3274a9efde8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fb34b4b3fb0e6f0cc4815c155141c11/" rel="bookmark">
			P4.批量创建、复制、移动、删除、重命名文件及文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 P4.批量创建、复制、移动、删除、重命名文件及文件夹.md
#创建文件夹 #创建文件夹 os.mkdir(新文件夹名) 例 os.mkdir('新文件夹') #注意当文件夹已存在时运行这句代码会报错 #检测该文件夹是否存在 os.path.exists(文件夹名称) 例 if not os.path.exists('新文件夹'): os.mkdir('新文件夹') #创建多层文件夹 os.makedirs('第一层文件夹/第二层文件夹/第三次文件夹') #注意，当最里层文件夹已存在时运行这句代码报错 #复制、移动、重命名 #复制文件：shutil模块 shutil.copy(要复制的文件，要复制到的位置) 例 import shutil shutil.copy('file.txt','./新文件夹') shutil.copy('file.txt','./新文件夹/new_file.txt') #第二个参数写某个文件夹位置，则复制到该文件夹下 #第二个参数写某个文件路径，复制到这个路径并且重命名 #复制文件夹：shutil模块 shutil.copytree(要复制的文件夹，要复制到的行文件夹位置) 例 shutil.copytree('文件夹'，'新文件夹') #文件夹内所有文件和文件夹都会复制过去 #注意新文件夹不能已经存在 #移动文件或文件夹 shutil.move(要移动的文件/文件夹，要移动到的位置) 例 shutil.move('file.txt', '新文件夹/file2.txt') shutil.move('file.txt', '新文件夹/') shutil.move('文件夹', 新文件夹') #第二个参数写某个文件夹位置，则移动到该文件夹下 #第二个参数写某个文件路径，移动到这个文件路径并重命名 #如果是文件夹记住后面加斜杠/ #重命名文件或文件夹 os.rename(要重命名的文件/文件夹，新的名字) 例 os.rename('文件夹', '重命名后的文件夹') os.rename('file.txt', 'new_file.txt') #删除文件 os.remove(要删除的文件) 例 os.remove('file.txt') #注意，只能删文件，如果给了一个文件夹路径则会报错 #删除文件夹 shutil.rmtree(要删除的文件夹) 例 shutil.rmtree('文件夹') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69c44dea4bfb2520f8211d9276f2a297/" rel="bookmark">
			我为什么要做程序员？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 是什么让我们选择了996的工作？作者认为是创造性，你以你的方式去解决为题，以你的方式推动着世界的发展。 以下为译文：
在成为专业的软件开发人员之前，我曾在一家公司的技术部门工作，当时我只是Javascript爱好者，渴望成为一名真正的开发人员。
当时，我是一名大学刚毕业的学生，对业务组成的各种原型还抱有天真的想法，而让我感到震惊的是，程序员的做事态度与其他同事的态度截然不同。大多数时候，在我眼中那家公司的文化充斥着阿谀奉承，各种角色的职能也一塌糊涂，工作氛围总是让人倍感紧迫与压力。
为了表现努力工作，你需要表现得惶惶不可终日。尽管嘴上不说，但内心深处大家都知道说‘我不知道’是无能的表现，会令高层人士不满。
但是，程序员似乎不同。如果有人气势汹汹地冲到一个程序员的办公桌前，报告了一个bug，然后怒吼道：“为什么会发生这样的事？！”应该对此负责的程序员只是有气无力地坐在那里，然后说，“你去写票吧，我们会做调查。”
哇，我当时想——“我们会做调查”，他们没有费尽心机讨好权威，没有慌慌张张地做解释，而我想成为他们那样的人。
对我来说印象最为深刻的是，虽然当时我可能不敢说那样的话，但是技术部门对负责的工作信心满满。
这些人很聪明，所以有信心也是自然的，但是原因不仅如此。当时我有一种感觉，软件开发人员的工作与现实紧密相连，而其他岗位则没有。当然这样说可能对那些在其他职位的人来说并不公平，不过这些开发人员工作的成败有明确的定义标准，而且他们完全有能力达到这些标准。
我不是指企业强加给人的那种不切实际的标准。我说的是：“我的单元测试通过了吗？”、“我的应用程序在加载的时候会崩溃吗？”、“我改好了每个人都担心的bug了吗？”这些标准完全是客观的、非政治性的。
相反的例子是，成功与否的标准定义模糊，通过贬低他人的成功来表现自己——这种情况下你需要把自己的信仰托付给有影响力的某个人，而无需对任何真实情况负责；强调做作和夸夸其谈，而不重视诚实和行动。而且在程序员的这边也没那么多扯淡的事儿。
尽管现在我已经意识到：
我上面描述的这些现象其实极其罕见，可能仅限于我曾经工作的那家公司；
这些信仰可能更多地表现了我对我当时的角色的不满，而不是任何“客观性”的真实情况；
如果其他专家能够定义出难以定义的“成功的标准”，那么这并不总意味着完全没有标准；
我也认识到，在软件开发领域，虽然理论上来讲不应该有任何扯淡的事儿，但实际中也并不是完全一尘不染的。
在我成功获得梦寐以求的转职之后（感谢一些人，直到今天我都心存感激），我发现了一些获得自信的技巧，而在以前我只有羡慕别人的份儿。
首先我意识到，如果程序员是公司里最冷静的人，那么这种生理激励就像是让你写好代码的氪石一样。充满压力会限制你的专注力，导致你无法思考抽象的事物。在任何紧急情况下，我都要学会在不提高我的心率的前提下提高思维水平——我需要学习不被他人的压力影响。
我学到的第二件事就是假设测试相对于试错而言的重要性。假设你需要用一个值对一个变量进行初始化，而且你知道这个值应当是几个可能值中的一个。你可以在头脑中模拟系统，直到你知道哪个才是正确的值（假设），或者试验每个值，直到程序正常运行（试错）。
后者可能更快、更“容易”，但很明显前者才对你的掌控能力有帮助，更不用说长远来看前者能增强你以后解决类似问题的能力了。针对正确答案建立假设并验证需要一点“灵感”，相反，无意义地试验集中选项并随机选择一个则无需任何思考——你应该避免那种被代码孤立的感觉，开发者的工作是告诉机器该怎么做，而不是像个机器一样做事。
相反，你的目标应该是发展你的思维模式，使得你认为写代码是一种表达的形式，就像奥威尔提倡的写散文时的观点一样。
不过这里的“灵感”和“孤立”这两个词我想多谈一点。
几年前我读过马斯洛的《Towards a Psychology of Being》一书，书中他提到了安全感和成长之间的根本的对立。他的理论认为，童年时期或以后任何重要时期的个性养成，都是基于“灵感”的积累。有时这可能是通过某种自发的行为，在不可能的情况下成功操纵了世界的某一小部分造成的结果。因此，成长是事业扩展的一部分，能够逐渐培养对成功的感觉。
但这个概念也与价值和天赋有关。例如，马斯洛的书中，可能“亲吻某个人能带来比亲吻其他人更多的灵感”，他继续描述这种“通过灵感获得成长”的结果：
这样，我们能学到我们擅长的东西，喜爱或不喜爱的东西，我们的口味、判别能力和接受程度。一言以蔽之，这就是我们发现自我并解答那个终极问题的方法：“我是谁？我是什么？”
关于孤立，马斯洛是这样说的：
当孩子能够意识到时，与主观灵感（信任自己）相反的，是他人的意见（爱，尊重，认可，仰慕，来自他人的奖励，相信他人而不相信自己）。对于无助的婴儿和孩童而言，他人极其重要，因此失去他人（即失去他人提供的安全感、食物、爱和尊重等）是极其可怕的危险。 因此，当孩必须在自我灵感和他人的认可中二选一时，他们必然会选择他人的认可，然后压抑自己的灵感，或者干脆消灭之，或无视，或者下意识地约束。一般来说，这会造成对自我灵感的否定，或者对其产生害羞或神秘感，最终造成无法表达这种灵感。
我认为这正是他人尊重（特别是来自权威的尊重）和个人信仰之间的对立，让我被技术圈的那些冷静自信的人所打动。自我的发展，包括自信，可以认为是一系列“自我灵感”的结合，每个灵感都在前一个的基础上发展，就像土壤不断增长成小山丘一样。而且这种发展出现在对世界的直接认知过程中，而不会被他人的认知和价值观所影响。
也许正是我的认知失败，使我选择了编程的路。我的能力不足以让我用自己的眼睛和耳朵去认识世界；我也“无法去表达”自我灵感。这让我想起了希伯来圣经中的一段：
异教徒的崇拜是金子和银子，以及人们双手的工作。
他们有嘴，但他们不说；有眼睛，但不看。
编程给我带来了一个方便、决定性的微观世界，在这个世界中我可以得到控制感、精通和对世界的直接认知，而这正是我的一生中失去的东西。新发现的“信任自己的判断”的能力，将我的世界的中心从他人的判断上（一种高度的“自我监视”状态）移动到自己身上。
我发现，在我实施“假设测试”方法之后，某些人认为的冰冷、抽象的原则，对于我来说却十分有意义。如果程序与之前做过的假设相关，那么理解程序（或者任何事物）的行为会更容易记忆，而且特点更明显，产生更多的“灵感”。这样，尽管操纵屏幕上的光标的艺术对于婴儿来说并没有“灵感”科研，但对于成人来说则是个人成长和自信的快车。这就是我的情况。
用自己的眼睛和大脑去决定何为“好的软件程序”，能够导致更少地依赖别人。自己对真实判断负责，能够让你对好的东西负责。我认为“生活方式设计”行动就是个很好的思维成长的例子。它能鼓励你忽视惯例，批判性地评估你的生活方式，并根据你对自己和你的偏好了解的内容进行调整，让这些学习影响你现在和将来的选择。
关于这个话题我还要说最后一件事。马斯洛理论的中心，也是他看到的主要增长障碍，就是对抛弃的恐惧。为了冒险进入操场，孩子需要确保母亲正在等待并且自己能随时返回。再次引用马斯洛的话：
如果维持自我的唯一方式就是失去他人，那么一般的孩子会选择放弃自我。 这段话表明，艾默生在编写《Self-Reliance》一书时头脑中想到的最终技巧，并不是让我们所有人都成为程序员。 这当然不是我想在这篇文章中传达的信息，尽管乔布斯这样推荐过。自信可以通过各种方式实现，而编程恰好是我的方式。更重要的是提醒自己这样一件事：
你永远是人类家族的一员，长期有效且不可撤销。
正是这种信念促使你无所畏惧地生活。它为你带来了探索未知的能力，并赋予你天生的自发性和自然而然的成长，同时保证你不会成为局外人，不会被驱逐。
有了这种信念，一个人才能安全地追随“头脑中的那道闪光”，才能在一群人之中维持“孤独的独立”。我还认为这种信念与人们所说的“自我接受”强烈相关，它可以帮助你摆脱最深刻和最原始的恐惧。
试试吧，结果会很有启发的。
原文：https://medium.com/the-polymath-project/programming-for-personal-growth-64052e407894	作者：Matt Oxley，程序员，专注于设计、音乐科技。 译者：弯月，责编：郭芮 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32a634ad005061e334ac6caab5068c71/" rel="bookmark">
			Unity3d GUID和本地ID(Local Indentifier)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GUID和本地ID都是Unity用于资源管理的ID，GUID是工程里面所有文件、文件夹的唯一标识，通过GUID可以唯一确定一个文件或文件夹。本地ID是一个对象内（比如Scene），标识不同资源实例用的ID。
举个例子，现在有一个预制体A，那么我们可以查看它的.meta文件看到它的GUID：
在场景里面生成两个这个预制体的实例，那么大家应该都知道了，这两个实例肯定表示不同的对象，但是它们都通过GUID指向一个原型预制体A，通过文本方式打开Scene，ctrl+f查找预制体A的GUID：
红框表示处就是实例的本地ID，现在就应该差不多懂了，GUID和本地ID就像是类名和实例名。
那么有什么用呢？ 可以看到场景文件其实就是一些文本数据，我们既然能找到GUID信息，那么同样的可以通过代码替换修改里面的GUID，这也就是说我们可以通过代码批量替换更新场景里面的资源信息，具体操作见我以前的文章。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/233/">«</a>
	<span class="pagination__item pagination__item--current">234/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/235/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>