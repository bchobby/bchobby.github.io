<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efa80164783d59f7bfa90a64c0823a3e/" rel="bookmark">
			win10下Go环境的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境安装 首先我们需要在这里下载所需的安装包，在下载页面提供了比较全面的版本可供下载，目前所用的机器为Win10的机器，所以选择的是go1.13.3.windows-amd64.msi，如下图。
下载完成之后，直接安装即可。安装完成，输入:go version，如果能够正常输出，说明已经安装成功。
运行第一个Demo 在环境安装完成之后，我们就可以运行第一个Demo了。
首先，我们先创建一个项目的根目录，比如笔者是在D:\codes\路径下创建了一个文件夹叫GoProject，之后在项目根目录下创建三个文件夹，分别叫做bin、pkg、src，然后将项目根目录的路径写入环境变量GOPATH中。如下图所示。
之后，我们在src下就可以创建自己的包了，这里笔者在src下创建了一个包，即一个文件夹，叫做MyTest，然后在MyTest文件夹下创建了一个Go文件HelloWorld.go，其中内容为：
package main import "fmt" func main() { fmt.Println("Hello, World!") } 之后，打开控制台，输入go install MyTest，可以看到bin文件夹下出现了这个包所对应的可执行文件。
或者，我们可以输入go run MyTest，之后，我们可以看到在控制台中打印出了Hello World!，至此，我们的第一个Demo便成功运行完毕。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aea2ed1d5a54cc73304f9f875e006a11/" rel="bookmark">
			tensorboard错误经历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019-10-26 09:41:34.625499: W tensorflow/stream_executor/platform/default/dso_loader.cc:55] Could not load dynamic library 'libcuda.so.1'; dlerror: libcuda.so.1: cannot open shared object file: No such file or directory 2019-10-26 09:41:34.625525: E tensorflow/stream_executor/cuda/cuda_driver.cc:318] failed call to cuInit: UNKNOWN ERROR (303) 2019-10-26 09:41:34.625538: I tensorflow/stream_executor/cuda/cuda_diagnostics.cc:156] kernel driver does not appear to be running on this host (lixinming-Lenovo-Product): /proc/driver/nvidia/version does not exist 2019-10-26 09:41:34.625714: I tensorflow/core/platform/cpu_feature_guard.cc:142] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2 FMA 2019-10-26 09:41:34.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aea2ed1d5a54cc73304f9f875e006a11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cde06394eb48839ce658e5d74ab31ac2/" rel="bookmark">
			shell脚本--设置定期自动备份日志文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 每周五23：50自动备份/var/log下的所有日志文件到/root/Backup目录下 ，并以日期命名；
#vim backup.sh [ -d /root/Backup ] &amp;&amp; echo "Backup is ready" || mkdir /root/Backup &gt; /dev/null	#先判断备份文件保存目录是否存在，不存在则创建 tar -czfP /root/Backup/log-`date +%Y%m%d`.tar.gz /var/log	## tar默认为相对路径，可以使用-P参数使用绝对路径 ##保存并退出脚本，编写计划任务，以下命令在系统命令界面设置
#chmod +x /root/backup.sh #添加可执行权限 #crontab -e 30 23 * * 5	/root/backup.sh 每天备份前一天的日志，保留30天日志并定期清理30天前的备份日志
vim logbak.sh #!/bin/bash #获取备份的前一天时间 DAY=`TZ="TAIST+16" date +%Y-%m-%d` #备份前一天的日志文件 tar cvf /u01/mics/log_archive/$DAY.tar /u01/mics/log/$DAY /u01/mics/log/*.log gzip -r /u01/mics/log_archive/$DAY.tar #清除备份目录下30天前的备份文件 find /u01/mics/log_archive/ -mtime +30 -exec rm -rf {} \; #设定计划任务。每天00：30备份昨天的日志 crontab -e 30 00 * * * sh /u01/mics/baklog 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cb1c77c6c3e41329d8fb83dc1ed2b28/" rel="bookmark">
			WebRTC(八) STUN协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STUN简介 STUN（Simple Traversal of User Datagram Protocol through Network Address Translators (NATs)，NAT的UDP简单穿越）是一种网络协议，它允许位于NAT（或多重NAT）后的客户 端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于 NAT路由器之后的主机之间建立UDP通信。(摘抄自百度百科)
概括来说STUN就是一种用于穿越NAT的基于UDP的网络协议。其目的是在两个同时处于NAT之后的主机建立通信。
STUN协议由RFC3489定义，现在已经被RFC5389所取代。在RFC5389中STUN协议的全称是Session Traversal Utilities for NAT即解决NAT转换环境下的会话工具。STUN协议(RFC5389)本身并不是NAT穿越的解决方案，而是用来解决NAT穿越的工具。相比之前的RFC3489来说，这是个很重要的改变。因为RFC3489本身是NAT穿越的完整解决方案。
以下分析基于RFC5389
STUN报文结构 下图是stun请求的抓包
下图是STUN响应的抓包
图的左上部分是用WireShark抓包的16进制数据。右边是用Wire Shark的抓包截图。
左下部分是展开的16进制数据和含义的对应。
STUN Header STUN协议首先包括20字节的Header部分。
Header中包含2个字节的STUN Message Type, 2个字节的Message Length,
4个字节的Magic Cookie，12个字节的Transaction ID。
以下是Header的格式
0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 0| STUN Message Type | Message Length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Magic Cookie | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | | Transaction ID (96 bits) | | | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Message Type:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cb1c77c6c3e41329d8fb83dc1ed2b28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bfb891321d4115b8fedae3651cfc9a1/" rel="bookmark">
			图-弗洛伊德（FloydWarshall）算法详解（含全部代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
适用条件
基本操作函数
功能实现函数
测试使用图
算法讲解
初始化
迭代
弗洛伊德算法代码
全部代码
实验结果
最短路径算法比较
适用条件 图中可以有负权，但不能有负圈（圈中弧或边的权值之和小于0）
基本操作函数 InitGraph(Graph &amp;G) 初始化函数 参数：图G 作用：初始化图的顶点表，邻接矩阵等InsertNode(Graph &amp;G,VexType v) 插入点函数 参数：图G,顶点v 作用：在图G中插入顶点v,即改变顶点表InsertEdge(Graph &amp;G,VexType v,VexType w) 插入弧函数 参数：图G,某弧两端点v和w 作用：在图G两点v,w之间加入弧，即改变邻接矩阵Adjancent(Graph G,VexType v,VexType w) 判断是否存在弧(v,w)函数 参数：图G，某弧两端点v和w 作用：判断是否存在弧(v,w)BFS(Graph G, int start) 广度遍历函数 参数：图G,开始结点下标start 作用：宽度遍历DFS(Graph G, int start) 深度遍历函数（递归形式）参数：图G,开始结点下标start 作用：深度遍历Dijkstra(Graph G, int v) 最短路径 - Dijkstra算法 参数：图G、源点vBellman_Ford(Graph G, int v) 最短路径 - Bellman_Ford算法 参数：图G、源点v 作用：计算不含负圈图的最短路径 返回是否有圈Floyd_Wallshall(Graph G) 最短路径 - Floyd_Wallshall算法 参数：图G 作用：计算不含负圈图的最短路径 返回是否有圈 功能实现函数 CreateGraph(Graph &amp;G) 创建图功能实现函数 参数：图G InsertNode 作用：创建图BFSTraverse(Graph G) 广度遍历功能实现函数 参数：图G 作用：宽度遍历DFSTraverse(Graph G) 深度遍历功能实现函数 参数：图G 作用：深度遍历Shortest_Dijkstra(Graph &amp;G) 调用最短路径-Dijkstra算法 参数：图G、源点vShortest_Bellman_Ford(Graph &amp;G) 调用最短路径- - Bellman_Ford算法 参数：图GShortest_Floyd_Wallshall(Graph &amp;G) 调用最短路径- - Floyd_Wallshall算法 参数：图G 测试使用图 测试使用图 算法讲解 初始化 表格行为i,列为j。D及P后小括号内的值为迭代次数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bfb891321d4115b8fedae3651cfc9a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c148762b1ec1d0c859360fa6859a883f/" rel="bookmark">
			设计模式 - state 状态模式 与 strategy 策略模式 分析实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		策略模式-意图：允许用户根据需要来处理算法方案的变化
状态模式-意图：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。
两种模式都由三个角色组成：
(1)环境(Context)角色：持有一个Strategy/state的引用（或以提供的形式，针对策略模式个人认为当具体的行为是个无状态实体时，没必要以持有的方式来实现，这样会造成改变策略时每次都需要创建一个新的环境和新的策略实体，但其实只要环境中有个提供具体行为的静态方法，每个具体行为都是一个单例就可以了）
(2)抽象策略/状态(Strategy/state)角色：这是一个抽象角色，通常由一个接口或者抽象类实现。此角色给出所有的具体策略/状态类的接口。
(3)具体策略/状态(ConcreteStrategy/ConcreteState)类，包装了相关的算法或者状态行为。
这两种模式都能有效的解决过度冗长的case，if else等逻辑判断问题。
比如：
if(条件1){ ... }else if(条件2){ ... }else if ... 如果只是三个判断左右，看起来并无大碍，当存在十几个判断体，且每个判断体内逻辑及其复杂时，这将看起来非常冗长，对于开发和维护无疑是个巨大的痛点。下面将针对两种设计模式做简单实现：
1、策略模式 样例：在一个系统中存在上百个条款，其中有十几个条款需要针对不同的场景定制不同的条款内容，这个例子不存在状态的转换（比如在策略A执行过程中因某种因素转到策略B执行）：
1.1 条款简体 /** * 条款简体 * &lt;br&gt;实例化方式：ClauseTools.newClause(code,name,value); * @author zhanghaowen */ public class Clause{ private String code; private String name; private String value; public Clause(String code,String name,String value){ this.code =code; this.name =name; this.value = value; } public String getCode() { return code; } public void setCode(String code) { this.code = code; } public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c148762b1ec1d0c859360fa6859a883f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bf137be5256a7237ba8d37cc257c4a3/" rel="bookmark">
			curl 详解（转载阮一峰大佬的博客）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!-- div class="asset-body" --&gt; &lt;h2&gt;简介&lt;/h2&gt; curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。
&lt;!-- /div --&gt; &lt;!-- div id="more" class="asset-more" --&gt; &lt;p&gt;它的功能非常强大，命令行参数多达几十种。如果熟练的话，完全可以取代 Postman 这一类的图形界面工具。&lt;/p&gt; 本文介绍它的主要命令行参数，作为日常的参考，方便查阅。内容主要翻译自《curl cookbook》。为了节约篇幅，下面的例子不包括运行时的输出，初学者可以先看我以前写的《curl 初学者教程》。
不带有任何参数时，curl 就是发出 GET 请求。
$ curl https://www.example.com 上面命令向www.example.com发出 GET 请求，服务器返回的内容会在命令行输出。
-A -A参数指定客户端的用户代理标头，即User-Agent。curl 的默认用户代理字符串是curl/[version]。
$ curl -A 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36' https://google.com 上面命令将User-Agent改成 Chrome 浏览器。
$ curl -A '' https://google.com 上面命令会移除User-Agent标头。
也可以通过-H参数直接指定标头，更改User-Agent。
$ curl -H 'User-Agent: php/1.0' https://google.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bf137be5256a7237ba8d37cc257c4a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/021bbc7ee20b71134d53e20206bd6feb/" rel="bookmark">
			1024
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1024程序员节快乐
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5263e52b1d03bf10c7b4b2196996b93/" rel="bookmark">
			VBA程序 在Word文档中将表格中空白单元格填充为“无”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开宏编辑器功能，输入以下代码，然后编译执行。
Sub 填充文档中所有空白单元格() Dim oCell As Cell For i=1 To ActiveDocument.Tables.Count For Each oCell In ActiveDocument.Tables(i).Range.Cells If oCell.Range.Text = Chr(13) &amp; Chr(7) Then With oCell.Range.Font .NameFarEast = "宋体" .NameAscii = "宋体" .NameOther = "宋体" .Size = 12 oCell.Range.Text = "无" oCell.Range.ParagraphFormat.Alignment = wdAlignParagraphLeft oCell.Range.Cells.VerticalAlignment = wdCellAlignVerticalCenter End With End If Next Next End Sub 如果仅对单个表格进行空白单元格填充，使用以下vba代码
Sub 单个表格填充空白单元格() Dim oCell As Cell For Each oCell In Selection.Tables(1).Range.Cells If oCell.Range.Text = Chr(13) &amp; Chr(7) Then With oCell.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5263e52b1d03bf10c7b4b2196996b93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7647daade73449ac386e4fd87c10fe45/" rel="bookmark">
			【Git】.gitignore文件语法以及修改后无效的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.gitignore文件 .gitignore忽略文件用于添加不需要上传到git远程仓库的文件。
一、忽略规则 1、语法 符号描述#表示注释/表示目录*通配多个字符?通配单个字符[]包含单个字符的匹配列表!表示不忽略匹配到的文件或目录 2、示例 代码描述/file/忽略根目录下的file目录下的全部内容。file/忽略目录file下的全部内容。不管是根目录 /file/ ，还是子目录 /child/file/，都会被忽略。 二、.gitignore文件修改后无效 修改后无效是因为 .gitignore 对已经追踪（track）的文件是无效的，需要清除缓存，清除缓存后文件将以未追踪的形式出现。
git rm -r --cached . 这时重新添加（add）并提交（commit）就可以了。
git add . git commit -m '添加对**文件的忽略' 系列文章 Git专栏 Git使用（一）：安装与配置
Git使用（二）：创建项目并提交到远程仓库
Git使用（三）：分支管理，创建分支、合并分支、合并分支的某一次提交等
Git使用（四）：提交管理，修改提交信息、合并多次提交、版本回退、撤销本地文件修改等
Git使用（五）：解决冲突以及如何避免冲突
SmartGit 安装及使用（一）：安装及配置
SmartGit 安装及使用（二）：工作界面介绍、提交代码以及防止代码冲突等操作
SmartGit 安装及使用（三）：修改提交记录、合并多次提交、撤销本地文件修改、版本回退等操作
SmartGit 安装及使用（四）：创建、合并分支、合并某一次提交以及解决冲突等操作
SmartGit 安装及使用（附录）：注册非商业许可证
【Git】如何生成SSH key
【Git】.gitignore文件语法以及修改后无效的解决办法
【Git】Authentication failed for 错误解决
【Git】SSL certificate problem: unable to get local issuer certificate错误的解决办法
【Git】error: RPC failed； curl 92 HTTP/2 stream 0 was not closed cleanly: PROTOCOL_ERROR
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abee686615ec6e0391489e64429b94ec/" rel="bookmark">
			docker 报错 Container is not running
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在运行docker exec -it 56b90db5253e /bin/bash报错。
出现这个问题，是因为Container容器之前已经启动过了
需要执行docker start 56b90db5253e就可以解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20ed8b832731a0ff025b1cd516a58d82/" rel="bookmark">
			Laravel Passport API token 验证，出现 Route [login] not defined 报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Laravel Passport API token 验证，出现 Route [login] not defined 报错。报错显示确实不太友好，容易把错误引入到其他方向。 我刚开始看，也没看明白，不知道这个错误是啥，laravel 不应该强制用户定义 login 路由啊。通过测试，才知道是未登录导致的错误。 然后，根据 laravel 的报错提醒，我们简单追下源码，分析下问题： 错误位置： 1.laravel/framework/src/Illuminate/Routing/UrlGenerator.php:389 调用 route() 方法根据路由名 login，生成 url 报错 2.route() 方法的调用位置 app/Http/Middleware/Authenticate.php:18 protected function redirectTo($request) { if (! $request-&gt;expectsJson()) { return route('login'); } } 3.我们在控制器的构造方法中，使用了 passport 的中间件 $this-&gt;middleware('auth:api', ['except' =&gt; []]); 从这里，基本就可以看出，就是调用中间件的 redirectTo() 方法，因为没定义 'login' 路由导致了错误 分析： $request-&gt;expectsJson() - 期望返回 json 格式，如果未返回，就返回要重定向的链接地址 这里，我们使用 passport api，所以很明显的是 $request-&gt;expectsJson() 未通过导致的原因 继续看 request 的 expectsJson() 方法 public function expectsJson() { return ($this-&gt;ajax() &amp;&amp; !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20ed8b832731a0ff025b1cd516a58d82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/823f0381e6589f1593db8dfc2db58656/" rel="bookmark">
			el-select 下拉框多选实现全选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在写一个功能时发现el-select支持多选，但是竟然不支持全选，好无语哦，那就自己实现一下吧~有两种方法，第二种感觉简单些 方法一：下拉项增加一个【全选】，然后应该有以下几种情况： 1.下拉选项全都勾选时，【全选】自动勾选； 2.下拉选项部分勾选时，点击【全选】后，所有下拉项全部勾选； 3.下拉选项全都未勾选时，点击【全选】后，所有下拉选项不勾选； 4.下拉选项和【全选】都选上的时候，不勾选任意下拉选项，【全选】按钮就不勾选了； html部分： &lt;template&gt; &lt;el-select multiple collapse-tags v-model='selectedArray' @change='changeSelect' @remove-tag='removeTag' placeholder='请选择'&gt; &lt;el-option label='全选' value='全选' @click.native='selectAll'&gt;&lt;/el-option&gt; &lt;el-option v-for='(item, index) in options' :key='index' :label='item.name' :value='item.name'&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/template&gt; js部分： export default { data() { return { selectedArray: [], options: [ { name: '一一', label: 'one' }, { name: '二二', label: 'tow' }, { name: '三三', label: 'three' }, { name: '四四', label: 'four' }, { name: '五五', label: 'five' } ] } }, methods: { selectAll() { if (this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/823f0381e6589f1593db8dfc2db58656/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f0d5bb9f4e8bc92056d093e0db2dd4c/" rel="bookmark">
			ab压力测试工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.ab的简介 ab是apachebench命令的缩写。ab是apache自带的压力测试工具。ab非常实用，它不仅可以对apache服务器进行网站访问压力测试，也可以对或其它类型的服务器进行压力测试。比如nginx、tomcat、IIS等。
2.原理 ab的原理：ab命令会创建多个并发访问线程，模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的，因此，它既可以用来测试apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其它Web服务器的压力。ab命令对发出负载的计算机要求很低，它既不会占用很高CPU，也不会占用很多内存。但却会给目标服务器造成巨大的负载，其原理类似CC攻击。自己测试使用也需要注意，否则一次上太多的负载。可能造成目标服务器资源耗完，严重时甚至导致死机。
3.安装 yum -y install httpd-tools
4.检验 ab -V
5.参数 [root@gjtest ~]# ab -help Usage: ab [options] [http[s]://]hostname[:port]/path Options are: -n requests Number of requests to perform -c concurrency Number of multiple requests to make at a time -t timelimit Seconds to max. to spend on benchmarking This implies -n 50000 -s timeout Seconds to max. wait for each response Default is 30 seconds -b windowsize Size of TCP send/receive buffer, in bytes -B address Address to bind to when making outgoing connections -p postfile File containing data to POST.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f0d5bb9f4e8bc92056d093e0db2dd4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f70ebb1ffb49e607bba928ef6634ae65/" rel="bookmark">
			SpringBoot-自定义配置-覆盖自动配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Spring Boot 不是有很牛逼的自动配置吗？而且它的牛叉之一就是自动配置，让工程师从繁琐的，重复的配置中解放出来，为什么还要自定义配置？
Maven中的中打开pom.xml 增加如下配置：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 如果是Gradle，则需要在build.gradle中增加如下配置：
compile("org.springframework.boot:spring-boot-starter-security") 配置了安全配置以后，再次运行，输入你想看的阅读列表地址：http://localhost:8000/readlist/lg，发现会自动跳转到验证页面，需要输入用户名和密码。而这个用户名是固定的 user，密码就更蛋疼了，你可以在日志中看到密码。输入用户名和密码以后，就可以正常访问阅读列表了。
我相信，这不是你想要的认证配置：一个用户和一个非常其他的密码，那么，这个时候我们就希望自己配置安全你认证了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3ed69acd6137b41259b67e0bd14e961/" rel="bookmark">
			shell 脚本--变量替换总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shell脚本中进行字符删除操作 使用 # 和 % 进行匹配删除，具体的# 和 % 的总结如下：
${变量#匹配规则} # 从头开始匹配，最短删除 ${变量##匹配规则} # 从头开始匹配，最长删除 ${变量%匹配规则} # 从尾部开始匹配，最短删除 ${变量%%匹配规则} # 从尾部开始匹配，最长删除 ${变量/旧字符串/新字符串} # 替换变量内的旧字符串为新字符串，只替换第一个 ${变量//旧字符串/新字符串} # 替换变量内的旧字符串为新字符串，全部替换 下面举几个例子进行说明
1.关于#的替换规则
~$ vari_1="I love you,Do you love me" ~$ echo $vari_1 I love you,Do you love me # 只有一个#的时候 匹配到第一个 ov 之后就停下来了 ~$ var1=${vari_1#*ov} ~$ echo $var1 e you,Do you love me # 匹配到第一个 ov停下 #配到最后一个ov 最后一个ov之前的全部删除 ~$ var1=${vari_1##*ov} ~$ echo $var1 e me 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3ed69acd6137b41259b67e0bd14e961/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a712211cd12fb12ebec623cdb70e3533/" rel="bookmark">
			Linux常用命令大全（详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于最近刚接触linux，对于一些命令不是很好记，故在网上找了一份非常详细的Linux命令大全，方便日后查看学习
系统信息 arch 显示机器的处理器架构
uname -m 显示机器的处理器架构
uname -r 显示正在使用的内核版本 dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) hdparm -i /dev/hda 罗列一个磁盘的架构特性 hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 cat /proc/cpuinfo 显示CPU info的信息 cat /proc/interrupts 显示中断 cat /proc/meminfo 校验内存使用 cat /proc/swaps 显示哪些swap被使用 cat /proc/version 显示内核的版本 cat /proc/net/dev 显示网络适配器及统计 cat /proc/mounts 显示已加载的文件系统 lspci -tv 罗列 PCI 设备 lsusb -tv 显示 USB 设备 date 显示系统日期 cal 2007 显示2007年的日历表 date 041217002007.00 设置日期和时间 - 月日时分年.秒 clock -w 将时间修改保存到 BIOS 关机 (系统的关机、重启以及登出 ) shutdown -h now 关闭系统
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a712211cd12fb12ebec623cdb70e3533/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf798a8f17176e15b1cebebfc6eea6dc/" rel="bookmark">
			超分辨之----DRCN论文理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度递归网络
Abstract 16层递归网络，不用引入其他参数，就增加递归层数就可以。
我们提出了两个扩展：递归监督和跳过连接。recursive-supervision and skip-connection.
1. Introduction （是介绍遇到的问题，我们的方法）
接受域 41*41。
发现用随机梯度下降法不容易收敛，会导致梯度爆炸。
我们提出两种方法来缓解困难
1.对所有递归进行监督。每次递归后的特征图用于重建
目标高分辨率图像（HR）。 重建方法（专用于重建的层）对于所有递归都是相同的。 由于每次递归都会导致不同的HR预测，我们结合了不同水平的预测结果递归以提供更准确的最终预测。 （下一次递归的输入是上一个的输出么？损失函数怎么计算？）
2.使用从输入到重建层的跳跃连接。 在SR中，低分辨率图像（输入）和高分辨率图像（输出）共享相同的图像信息在。 但是，在许多前向传递中，输入的精确可能会被削弱。我们将输入显式连接到层来进行输出重建。
2.Related work 不用看
深的递归网络可以增加表现。
到目前45min
5. Conclusion 重复使用权重。
3. Proposed Method embedding传进去。传出特征向量。
用于将信息传递到推理网络的中间表示形式，在很大程度上取决于推理网络在内部如何在其隐藏层中表示其特征图。 学习此表示形式与学习其他子网是端到端的。
Inference ：主要部分，解决了sr
（27mins）
有隐藏层。用RELU
还存在一个问题找到最佳的递归次数很难。
不最佳的话会出现梯度消失和梯度爆炸。
递归监督为了解决梯度和最优递归问题。
4 training B100 consists of natural images
in the Berkeley Segmentation Dataset
91 images proposed in Yang et al
Dataset B100 consists of natural images
in the Berkeley Segmentation Dataset [20]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf798a8f17176e15b1cebebfc6eea6dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a35bb6814e2243a675eb3801add18e71/" rel="bookmark">
			深度对比Oracle与SQL Server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本译文采用知识共享署名-非商业性使用-相同方式共享 3.0 Unported许可协议发布，转载请保留此信息
译者：马齿苋 | 链接：http://www.dbabeta.com/2010/oracle-sql-server-comparison-i.html
作者：Sadequl Hussain | 原文：http://www.sql-server-performance.com/articles/dba/oracle_sql_server_comparison_p1.aspx
一般的公司通常会在他们的信息系统架构中引入多种数据库平台，同时引入三到四种不同的RDBMS解决方案的中大型公司也并不少见，当然这些公司里面的DBA们通常也需要同时拥有管理多种不同平台的技能了。
只在一种平台上展开工作的数据库专家们也通常会期待着在他们的下一份工作中能学到点不一样的东西，那些有勇气的人们则愿意花时间、金钱和精力去学习新的东西，也有其他因为换了新公司或者是为了找新的工作而去学习新的系统的人们，毋庸置疑的一点就是公司老板和人力专家们会更加青睐于那些拥有多个领域经验的求职者。
依我个人的经验来看，在学习一个新的数据平台的时候，最好的方法就是在新的环境中去发现那些你已知的东西，这样学习起来会简单很多。当然，当中也会遇到一些全新的概念需要去学习，或者是忘掉一些你现在已知的概念，但不管怎么说你不是从零开始的。比如说一个做SQL Server开发人员在要写Oracle存储过程的时候可能会先去找那些内置的函数然后比较它们之间不同点，她也可能会去比较变量声明以及错误处理的异同。
本系列文章中我将尝试对Microsoft SQL Server和Oracle RDBMS(以10g及以后的版本为主)进行一个深入的比较。我会主要集中于这两种数据库之间架构上的比较，当然不要期望我会给你一个详尽的比较清单，但是我会尽我所能的让你看清这两种当今世上应用最广的数据库之间的相同和相异之处。本文是以一个SQL Server DBA的角度去构思和写作的，不过相信这对Oracle专家门了解SQL Server这一面也是很有参考价值的。
废话少说，开工吧。
top操作系统的支持
Microsoft SQL Server向来都从属于Windows大家族中的一员，要让Microsoft发布一个支持其它操作系统版本的可能性当然是小之又小的了。当前来说 SQL Server可以在XP、Vista、Windows Server 2000、2003、2008上运行，同时也有针对于32位和64位版本Windows的数据库版本。
对Oracle来说，它支持多种不同的操作系统平台，包括Windows（32位和64位），另外还有支持Linux和不同分支的 Unix（Solaris、HP-UX、AIX等等）
top版本和发行版
在本写作时，Microsoft数据库产品的最新版本是SQL Server 2008，即将推出的下一版本是SQL Server 2008 R2，现在已经在CTP阶段了，它的上一个版本，SQL Server 2005，相对于再之前的SQL Server 2000的一个大升级。不过对很多公司来说SQL Server 2005还是有点新，因为他们现在还是在大量的使用着SQL Server 2000.
另一方面Oracle一路走来最新版本已经到了11gR2了，现在主流应用的版本10gR2已经发行有一段时间，已经是公认的领头羊了。 Oracle在10g中第一次提出“网格计算”的概念。当然现在还有公司依然在依赖于Oracle 9i处理业务。
说到发行版，SQL Server 2008 R2现在提供下面这么些版本：
企业版
企业版包含所有的高级特性，适用于大规模、高容量的数据库需求。
标准版
标准版为那些不需要包含企业版高级特性的公司提供了一个相对便宜的数据库平台，大部分公司使用的都是标准版的数据库。
工作组版
工作组版适用于小的部门级别的应用。
Web版
这个适用于作为Web应用的低成本的后台解决方案。
Express版
这是一个很小的内嵌式的SQL Server引擎，通常用于本地数据存储或是小规模的系统开发。Express版可以免费下载并且自由分发。
Compact版
Compact版可以让用户开发Windows桌面或者是手持设备的应用。
开发版
所有企业版所拥有的功能开发版都有，不过它仅仅授权单个用户访问，主要用于开发或是测试目的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a35bb6814e2243a675eb3801add18e71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32f20ed331ba05704e65e5164e3e72a7/" rel="bookmark">
			Unity操控Arduino板接舵机旋转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跟上篇文章差不多 也是串口通讯 只是这次在arduino端加了一个舵机，pc端向arduino传输一个角度
pc端代码（打开端口以及new一个接收数据的线程）ps:接收数据可以不要 因为我们这里不用接收返回数据 //设置串口，波特率 sp = new SerialPort("COM4", 9600); sp.Encoding = Encoding.ASCII; sp.ReadTimeout = 2000; sp.WriteTimeout = 2000; //sp.Encoding = ASCIIEncoding.ASCII; try { if (!sp.IsOpen) { sp.Open(); } } catch (Exception err) { Debug.Log(err); } print("端口打开"); wenben.text="端口打开"; //tPort = new Thread(DealData); //tPort.Start(); tPortDeal = new Thread(ReceiveData); tPortDeal.IsBackground = true; pc端（发送数据） /// &lt;summary&gt; /// 向陀机发送旋转数据 /// &lt;/summary&gt; void SendRotaData() { if (sp.IsOpen) { Thread.Sleep(200); string data=""; //RotaY是我在unity里建的cube的旋转值Y轴（我的舵机最大只能转180度） if (RotaY &gt; 0 &amp;&amp; RotaY &lt; 180) data= RotaY.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32f20ed331ba05704e65e5164e3e72a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e743d909d14a0a2bd4a90e937452e35/" rel="bookmark">
			2019秦皇岛A - Angle Beats Gym - 102361A（极角排序，多少个直角三角形）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Given n points P1,P2,⋯,Pn on 2D plane and q queries. In i-th query, a point Ai is given, and you should determine the number of tuples (u,v) that 1≤u&lt;v≤n and Ai,Pu,Pv form a non-degenerate right-angled triangle.
Input
The first line contains two positive integers n,q (2≤n≤2000,1≤q≤2000), denoting the number of given points and the number of queries.
Next n lines each contains two integers xi,yi (|xi|,|yi|≤109), denoting a given point Pi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e743d909d14a0a2bd4a90e937452e35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/033787b8a894d5e7fc8d0ee81507b1c0/" rel="bookmark">
			在windows命令行批量ping局域网内IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令：for /L %i in (1,1,254) do ping -n 1 -w 60 192.168.0.%i | find "回复" &gt;&gt; resultip.txt
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7783e757b44a608d8e44817edfd23271/" rel="bookmark">
			如何使用正则表达式匹配到第一个符合的字符串就停止
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 ? 字符，正则表达式默认使用贪婪匹配，即尽可能匹配所有符合的，在要匹配的正则后加？可只匹配第一个符合的数字，如 123123 使用 (.) 匹配则group(1)为12323 使用(.?)则会匹配到group(1)-group(6) 内容分别为"1",“2”,“3”,“4”,“5”,“6”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/158b9fe1781fd4e2b8f78e3a8a9d6e0a/" rel="bookmark">
			Android Material Design 之 BottomSheetBehavior
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.c-sharpcorner.com/article/bottomsheet-layout-in-android/
This article talks about the creation of BottomSheet overlay in Android and its behavior.
facebooktwitterlinkedInReddit Expand Download Free .NET &amp; JAVA Files API
Try Free File Format APIs for Word/Excel/PDF
Introduction BottomSheetBehavior is a type of behavior in which two or more layouts are placed on one another and the bottom layout performs the scrolling as other layouts expand the overlay and then collapse. This is why it is called BottomSheetBehavior.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/158b9fe1781fd4e2b8f78e3a8a9d6e0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/598d091212895ffc2bcb98c3d4f1eb70/" rel="bookmark">
			全面总结 JS 中浮点数运算不准确的原因及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		" 经常会碰到一个问题，"为什么 0.1 + 0.2 !== 0.3? "，我找了很多资料，尽可能全面地分析原因和解决办法。
" 这里先给出判断方法
Math.abs(0.1+0.2-0.3) &lt;= Number.EPSILON
IEEE 754 64 位浮点类型 IEEE 754[1]
IEEE 754 规定了四种表示浮点数值的方式：单精确度（32 位）、双精确度（64 位）、延伸单精确度（43 比特以上，很少使用）与延伸双精确度（79 比特以上，通常以 80 位实现）。
该标准的全称为 IEEE 二进制浮点数算术标准（ANSI/IEEE Std 754-1985），又称 IEC 60559:1989，微处理器系统的二进制浮点数算术（本来的编号是 IEC 559:1989）。
单精度浮点数 单精度浮点数格式是一种数据类型，在计算机存储器中占用 4 个位元（32 bits），利用“浮点”（浮动小数点）的方法，可以表示一个范围很大的数值。
在 IEEE 754-2008 的定义中，32-bit base 2 格式被正式称为 binary32 格式。这种格式在 IEEE 754-1985 被定义为 single，即单精度。需要注意的是，在更早的一些计算机系统中，也存在着其他 4 字节的浮点数格式。
定义
第 1 位表示正负，中间 8 位表示指数，后 23 位储存有效数位（有效数位是 24 位）。
中间八位共可表示 28=256 个数，指数可以是二补码；或 0 到 255，0 到 126 代表-127 到-1，127 代表零，128-255 代表 1-128。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/598d091212895ffc2bcb98c3d4f1eb70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c517eb3b9dfdeff3965add41368d244c/" rel="bookmark">
			Windows 多网卡并行通信程序设计（C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.任务要求 在PC上同时插入多个无线USB网卡，利用5个USB网卡并行通信。
2.实验准备 开发环境：VS2015测试工具：wireshark抓包软件(服务器端)硬件条件：多个USB网卡（系统需具备相应驱动），最好是3个以上 3.项目分析 平常我们的PC都是利用一个网卡来通信（无线或者有线），应用程序也只会绑定一个网卡。但现在是实现多个网卡实现并行的收发数据！当多个无线USB网卡接入电脑，都连接同一个AP，怎么才能让自己的程序绑定接入的USB网卡、并行收发数据呢？
获取接入PC的USB网卡信息(名称、MAC地址、IP地址等)；创建多线程，一个线程绑定一个网卡，依据网卡上的信息来异步执行任务；最后，Windows Socket编程，与服务器建立TCP、UDP连接，收发数据。 4.实验过程 4.1 PIP_ADAPTER_INFO结构体获取网卡信息 结构体ADAPTER_INFO用于于获取PC上网络适配器的IPv4信息，该结构体通过调用GetAdaptersInfo函数获取值。
//PIP_ADAPTER_INFO结构体指针存储本机网卡信息 PIP_ADAPTER_INFO pIpAdapterInfo = new IP_ADAPTER_INFO(); //得到结构体大小,用于GetAdaptersInfo参数 unsigned long stSize = sizeof(IP_ADAPTER_INFO); //调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量;其中stSize参数既是一个输入量也是一个输出量 int nRel = GetAdaptersInfo(pIpAdapterInfo, &amp;stSize); //记录网卡数量 int netCardNum = 0; //记录每张网卡上的IP地址数量 int IPnumPerNetCard = 0; if (ERROR_BUFFER_OVERFLOW == nRel){ //如果函数返回的是ERROR_BUFFER_OVERFLOW //释放原来的内存空间 delete pIpAdapterInfo; //重新申请内存空间用来存储所有网卡信息 pIpAdapterInfo = (PIP_ADAPTER_INFO)new BYTE[stSize]; //再次调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量 nRel = GetAdaptersInfo(pIpAdapterInfo, &amp;stSize); } if (ERROR_SUCCESS == nRel){ //输出网卡信息 getUSBWirelessAdapter(pIpAdapterInfo, IPnumPerNetCard, netCardNum); } //释放内存空间 if (pIpAdapterInfo){ delete pIpAdapterInfo; } 其中getUSBWirelessAdapter(PIP_ADAPTER_INFO pIpAdapterInfo,int IPnumPerNetCard, int netCardNum)函数用与筛选出所需要的网卡和分配到的IP地址等信息，结果如下图。其中依据USB关键字在程序里筛选出USB无线网卡。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c517eb3b9dfdeff3965add41368d244c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6380a0d9889f535543c5d05cc3a87de/" rel="bookmark">
			Python 已经将module添加到系统路径,但是调用时编译器还是提示no module named XXX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近再用python+unittest框架尝试写脚本,但是在导自定义mudule的时候遇到了一些问题 使用的编译器是 pycharm,很困惑,难道只是将路径加进去就一定会出现这样的提示? (使用vscode也会有一样的提示.) 目录结构如下 代码如下 import sys path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))#当前文件的绝对路径的上一层路径 pub_path = os.path.join(path,"public") sys.path.append(pub_path) import mobile_json class UserSearch(unittest.TestCase): def setup(self): pass def test_search(self): pass def tearDown(self): pass if __name__ == "__main__": unittest.main() 在百度上也没找到合适的答案,大多都是说将 module 用sys.path.append()的方法加入到系统路径中, 这些module只是临时的文件,不想把这些文件直接放到 python目录下的lib文件夹内(忘了是不是这个文件夹), 各位大哥 有没有了解这一方面的,给小弟指导指导问题所在感激不尽... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d65d928361c7c1674417d3a604a152d3/" rel="bookmark">
			第十三章 会议与WebRTC视频会议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		会议是你希望向用户和客户提供的高级功服务一。在我们处于成本控制和时间限制的夹缝之中时，拥有虚拟会议的能力是一种实打实的好处。
更重要的是，如果你能够管理会议，有序地为每位演讲者配麦，对每个与会者静音/取消静音，等等。
当你能够为与会者混合视频流时，你就能够提供更多的特性：屏幕共享、播放视频、录制，同时提供不同人组成的“舞台”画面…这不仅比在一个实际房间里走来走去参加会议更经济，更便捷，而且会更有成效。
我们还开发了一个WebRTC客户端，充分利用我们的现代VERTO协议，为参与者和主持人提供一个美丽、高效、沉浸式和引人入胜的会议体验！
FreeSWITCH给出了所有构建块，由于WebRTC的支持，你的会议参与者、主持人和演示者只需要在他们的计算机、平板电脑或智能手机上安装一款标准浏览器就够了。
这一章，我们将讨论以下主题：
会议概念，音频和视频FreeSWITCH的会议支持在FreeSWITCH中设置音频会议音频会议操作在FreeSWITCH中设置视频会议视频会议操作视频会议中的Verto通信视频会议的其它技巧 会议概念 会议指的是超过两方参与者的一路话务，它一直是电信领域中最受欢迎的服务之一。
允许两个以上的参与者同时交谈的技术（例如，不在一键通服务中）与两个参与者的“正常”通话的技术大不相同。在“正常”的通话中，你只关心主叫与被叫间的媒体流交换。事实上，你可以让媒体流(以RTP形式)直接在主叫与被叫间双向流动，而不必经过FreeSWITCH或其它任何中间电信服务器。
另一方面，会议需要一台服务器。会议服务中的最基本功能是混合，比如说把不同参与者所发送的媒体流合并。因此，每个参与者把他们自身的媒体流发给服务器，而所有参与者收到的媒体流是服务器收到的所有媒体流的“和”。参与者之间不直接通信，而是通过会议服务器作为中心枢纽的“星型拓扑”连接在一起。
除了基本的“合并所有传入流并发送结果流”功能外，会议服务还可以提供更高级的特性。它们可以接受命令来变更输入流的合并方式：仅合并其中的一些流（或仅广播一个流）；向参与者播放媒体文件；录制会议会话；更改接收或发送的流的特征，请求识别参与者身份的PIN码；把一名或多名与会者视为“主持人”，对其他与会者和会议管理；等等。
如你所料，FreeSWITCH提供所有这些功能，甚至更多。
FreeSWITCH的会议支持 从构思的第一阶段起，FreeSWITCH的设计结构就擅长混音功能。它的内核可以高效地揉合各种流。
Freeswitch内核中的媒体处理引擎非常灵活，并提供钩子，以便内核开发人员和贡献者添加功能，而不会危及系统的稳定性和效率。
显然，媒体处理有两个主要的领域：音频和视频。音频和视频的处理方式完全不同，因为它们的性质完全不同。
音频会议 音频流由一系列音频样本组成。每个音频样本本质上是一个数字(一个量值)，代表声音在时间上的演变。声音可以用我们在高中课本上的正弦波来描述，每个样本都是在某一时刻的振幅值。
混合(合并，组合)两个或更多的声音样本本质上是对它们的数值求和，然后除以我们混合的流的数量(例如:在每个时间点取平均值)。显然，如果之前样本事先经过压缩、编码，情况就完全不是那么简单了。你需要先对体积标准化。但其最简单的概念形式（未压缩、原始、声音样本）是完全相同的。
视频会议 视频流完全是另一回事！它们是一个复杂的值序列，描述图像（“屏幕”）随时间的变化。假设有一部分辨率为1920x1080像素的流式电影（或网络摄像机源）。这些像素中的每一个或大部分（全部变化的情况比较罕见）都可以在每个时间点改变值（颜色、亮度等）。因此，每个时间点的样本并不代表屏幕上每个像素的值，而是分析哪个像素发生了变化以及如何变化的复杂计算结果。你不能直接把它们相加，这样没有任何意义。
而且，当您将视频流组合在一起时，您希望得到的结果一般不是它们的混合叠加（例如“透明”过渡效果）。您希望将屏幕划分为多个区域，并在每个定义的区域中显示不同的视频流（缩放）。或者在每个屏幕区域上显示浮动徽标或标题。这更类似于电视脱口秀节目中导演所使用的“视频混音与特效”处理。
在当今的电信世界中，视频会议（视频流组合）有多种策略，每种策略都有其自身的理由和用例：
Peer-to-Peer (MESH) ：这是基于纯设备到设备的通信（无服务器），其中每个参与者向所有其他参与者发送和接收视频流。视频流在设备端(比如说浏览器)进行组合。如果必须影响所有设备的显示，那么每个参与者必须向所有其他参与者广播控制命令。这种策略的明显问题是带宽的开销与参与者方数呈指数级增长：三方会议交换6路视频流；四方会议交换12路视频流；10方会议需要交换90路视频流…这种技术在WebRTC服务中很流行，但不适用于超过四个参与者的会议场景。Selective Forwarding Unit (SFU)：它是一种中央服务器，它接收所有参与者的视频流，并决定将哪个流转发给哪个参与者。中央服务器（SFU）不组合流或对其应用效果，它只决定数据包的出入路由。流由终端设备(比如说浏览器)负责组合，一般情况下它们仅是在不同的区域显示不同的流，并没有进一步处理。如果需要在参与者屏幕上组合多个流，那么所有流都需要路由给所有参与者。这对带宽使用和客户端CPU要求非常高，代价可能是非常昂贵的。Multipoint Conferencing Unit (MCU)：它是一种中央服务器，它接收所有参与者的视频流，对它们进行混合、转换和应用特效，然后从处理结果中选择一个流发送给所有参与者。对于带宽和客户端的CPU来说，这种策略的要求可能是最低的(每个客户端向MCU发送它们的视频流，并从MCU接收一路视频流)。但是，它对MCU侧的CPU施加了极大的压力，它必解码所有待混合的流，将复杂的计算机图形应用于标题、徽标、合并和缩放，然后对结果重新编码。FreeSWITCH是一个高级的 MCU(混合视频流和应用效果是一项非常繁重的任务)，在“只有一个参与者发起视频流并显示在所有参与者屏幕上”的极端场景下，它会变成对CPU需求极低的SFU(换句话说，没有视频合成，没有特效，只是向所有与会者路由一路视频流)。 FreeSWITCH中的音频会议设置 Freeswitch包含一个功能强大的内置引擎，它允许在多用户音频会议系统中对呼叫者之间的音频通道进行混音。 mod_conference允许完全控制音频混合和用户交互功能，比如说tone音监测，管理每个通道的的音频收发路径、音量控制、增益控制等等。只要服务器上的资源(内存、CPU等等)允许，你可以创建会议，没有数量的限制。
mod_conference的配置文件是/usr/local/freeswitch/autoload_configs/conference.conf.xml。会议的特征和行为都由它的profile决定。你可以在配置文件中设定多个profile，每个profile都有其独特的参数集。创建会议时会分配一个profile(通常是在拨号方案中)。会议的配置文件被划分为几个部分，我们接下来会介绍它们。
profiles 一个会议profile是一组可用于特定会议的设置。与caller-controls(这一节会讨论)结合，会议profiles允许完全定制各个会议的行为。你可以建立几个profiles，并把它们应用到许多会议上；或者为每个打算召开的会议分别建立一个profile；或者干脆简单地使用缺省定义。
通常的会议profile结构是这样的：
&lt;profiles&gt; &lt;profile name="default"&gt; &lt;param name="paramName" value="paramValue"/&gt; &lt;/profile&gt; &lt;/profiles&gt; 你可以有任意数量的&lt;profile&gt;标记，每个&lt;profile&gt;标记可以配置任意数量的&lt;param&gt;标记。下面是部分可用参数的解释。如果需要完整的参数列表和扩展说明，请打开我们的在线文档http://freeswitc h.org/confluence，并搜索"mod_conference"。
rate 这个参数定义会议中采用的缺省(最高)采样率。如果不是使用这个采样率，所有接入这个通道的用户都需要把他们的音频转换为这个采样率。为了混音目的，这定义了系统相关的最低采样率----如果两个用户使用高保真话机接入会议，但会议设置的采样率为8000，那么这些用户的音频采样率也将降到较低的速率。
参数语法：&lt;param name="rate" value="8000"/&gt;
可选值有：8000、12000、16000、24000、32000, 和 48000
caller-controls 这个参数定义会议桥所使用的caller-controls profile。
参数语法：&lt;param name="caller-controls" value="default"/&gt;
auto-record 这个参数定义会议是否需要自动录音。如果与会人数达到min-required-recording-participants要求，会议就开始录音。如果设置了这个选项，那么必须包含一条可写的路径，以便存储会议录音。
参数语法：&lt;param name="auto-record" value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d65d928361c7c1674417d3a604a152d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06cb53f7d013bc5f24382d44fe4df745/" rel="bookmark">
			爬取腾讯视频 爬虫 评论 python urllib
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此文章仅用于笔者交流学习爬虫技术，如有侵权请联系作者删除
文章目录 通过fiddler找到评论的url分析url找到加载评论信息的规律爬取深度评论代码（不包含子评论） 爬取短评（不包含子评论）构建url爬取短评代码（不包含子评论） 面向对象式编程实现爬虫 通过fiddler找到评论的url fiddler是一个抓包软件，这里用的fiddler4.
fiddler4官网
配置好fiddler后，在腾讯视频页面点击查看更多
返回fiddler发现捕获了数据包，
找到评论数据包，右键复制url就得到了评论的url
这里选择的是《权力的游戏第八季》
eg:
https://video.coral.qq.com/filmreviewr/c/upcomment/nilk5fd4bkqdk3a? callback=_filmreviewrcupcommentnilk5fd4bkqdk3a &amp;reqnum=3&amp;source=132&amp;commentid=6523204565596297127&amp;_=1571376131656
https://video.coral.qq.com/filmreviewr/c/upcomment/nilk5fd4bkqdk3a? callback=_filmreviewrcupcommentnilk5fd4bkqdk3a &amp;reqnum=3&amp;source=132&amp;commentid=6534034501152865577&amp;_=1571376131657
第一页的深度评论：
https://video.coral.qq.com/filmreviewr/c/upcomment/nilk5fd4bkqdk3a?callback=filmreviewrcupcommentnilk5fd4bkqdk3a&amp;reqnum=3&amp;source=132&amp;=1571378209126
第二页的深度评论：
https://video.coral.qq.com/filmreviewr/c/upcomment/nilk5fd4bkqdk3a?callback=filmreviewrcupcommentnilk5fd4bkqdk3a&amp;reqnum=3&amp;source=132&amp;commentid=6529339639861532449&amp;=1571378209129
第三页：
https://video.coral.qq.com/filmreviewr/c/upcomment/nilk5fd4bkqdk3a?callback=filmreviewrcupcommentnilk5fd4bkqdk3a&amp;reqnum=3&amp;source=132&amp;commentid=6529032690464222964&amp;=1571378209130
分析url找到加载评论信息的规律 通过老师提示和尝试发现：
·callback、source等参数并不重要
·决定加载对应评论的视频的参数vid
·对加载评论实现“翻页”的必要参数是commentid=
·决定单次加载个数的参数是reqnum=
最后构建的url格式：
https://video.coral.qq.com/filmreviewr/c/upcomment/ (视频ID) ?&amp;reqnum=3&amp;source=132&amp;commentid= (评论ID) &amp;_=1571376131656
打开构建的url发现在评论的json文件中有first和last字段，其中前一页评论的last字段刚好是后一页评论url中的commentid参数的值
可以根据这个实现翻页爬取评论
爬取深度评论代码（不包含子评论） # encoding = "utf-8" # Author = Joker-Face # Date = 2019年10月18日 import urllib import re # 构造请求头 headers = {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0', 'Content-Type':'application/javascript',} opener = urllib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06cb53f7d013bc5f24382d44fe4df745/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c783586b0f9b800ac7dc1c5d66aaace/" rel="bookmark">
			C# SolidWorks 二次开发 API --- 插件Add-In的自动更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写了程序，难免需要更新。所以大家都各自有各自的更新方案。
一般的.net可执行程序可以通过oneclick发布，从而自己更新，在每次用户打开时完成更新，
但是插件的更新有个问题，不能热更新。因为Solidworks在加载完dll之后 无法完全释放，所以无法直接替换。
所以一般的做法是在程序加载完成之后，提示用户有更新，这样就会要求用户必须重启一次Soldiworks.
-----------------------------------------------------------------------------------------------------------------------------------------------------
目前我的做法是创建一个新的Soldiworks插件，用于更新。需要注意的是要保证这个更新程序被solidworks先于功能的DLL加载。
具体我也没有研究它是基于名字还是基于GUID，至少我测试是能用的。
然后就需要在Update.dll中写具体更新的过程了。
需要在实体这个类的时候就去更新，这时solidworks只是加载了这个update.dll Tool.dll是还没有加载到内存的，所以这个时候是可以替换的。
此时是基于网络或者局域网都可以实现更新。
这样用户就会在每次重新开启Solidworks的时候实现了更新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4040e1e2c72b71e6c2ac0eda3e89ac29/" rel="bookmark">
			Linux下使用ntpdate进行时间同步，Linux时间自动同步（本文少部分为自己修改，经过验证）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装ntpdate，执行以下命令
# yum install ntpdate -y 2、手工同步网络时间，执行以下命令，将从time.nist.gov同步时间
# ntpdate 0.asia.pool.ntp.org 若上面的时间服务器不可用，也可以选择以下服务器同步时间
time.nist.gov
time.nuri.net
0.asia.pool.ntp.org
1.asia.pool.ntp.org
2.asia.pool.ntp.org
3.asia.pool.ntp.org
3、使用crontab计划任务定时更新网络时间，修改crontab文件，在末尾增加* */1 * * * ntpdate 0.asia.pool.ntp.org，每隔1小时同步一次时间。
# vi /etc/crontab */1 * * * * root ntpdate 0.asia.pool.ntp.org （1分钟，经过验证的）
4、使用date命令查看当前时间
sudo su -
date -s "2019-10-18 11:05:00"
date "+%Y-%m-%d %H:%M:%S"
5、系统时间同步到硬件，防止系统重启后时间呗还原
# hwclock --systohc 以上来自：https://www.cnblogs.com/zhi-leaf/p/6281549.html
Linux 查看所有定时任务 crontab 命令选项基本只对用户操作的选项：
-u 指定一个用户
-l 列出某个用户的任务计划 （当前用户）
-r 删除某个用户的任务
-e 编辑某个用户的任务
所以，要查看所有用户的，只能根据 /etc/passwd 文件中的用户名一一列举了，可以用脚本。
no crontab for root 解决方案 oot用户下 输入 crontab -l 显示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4040e1e2c72b71e6c2ac0eda3e89ac29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/542d06656e563abb20e24e0a79f277e9/" rel="bookmark">
			SpringCloud-Eureka-Provider&amp;Consumer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Eureka-Provider 服务的提供者 新建一个服务提供者项目 1、导入pom文件
&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.SR3&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 2、在启动类上加注解
@SpringBootApplication @EnableDiscoveryClient // 这个注解加不加都可以，因为Eureka public class EurekaProviderApplication { public static void main(String[] args) { SpringApplication.run(EurekaProviderApplication.class, args); } } 上边那个@EnableDiscoverClient 注解加不加都行的原因会在后边表名
3、在Eureka-Provider项目中添加一个简单的接口
@RestController public class EurekaProviderController { @GetMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/542d06656e563abb20e24e0a79f277e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce4ccac425cfa5f4cae556d308dbb647/" rel="bookmark">
			C# SolidWorks 二次开发 API---创建插件Add-In
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在新建项目时选择SwCSharpAddin
如果没有这一项,可以在把swcsharpaddin.zip放到对应的模板目录下.
https://download.csdn.net/download/zengqh0314/12182239
一般在安装过电脑上都会有这个文件,如果实在找不到可以去网上搜索.
SolidWorks API SDK.msi这个里面有: 可以利用下面的命令解压出来 msiexec /a "SolidWorks API SDK.msi" /qb TARGETDIR="d:\"
在上面输入自己想要的命字之后 .项目会自动创建,并加好引用.
双击swAddin.cs查看内容.
这里会自动做了一些注释:
在调试选项中确认使用的sldworks文件位置.点击启动进行调试.(注意Visual Studio需要用管理员权限启动)
这里会自动启动Solidworks, 手动新建一个零件 ,即可发现新多了菜单 .
然后下一步就是参考这个Addin实例 去修改成自己想要的界面了.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee500792210003c1554c37d6cded39d4/" rel="bookmark">
			数字图像处理：图像的频域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数字图像处理：图像的频域 一、图像高频信号和低频信号的理解 1.1 图像中的低频信号和高频信号也叫做低频分量和高频分量。 1）空间频率指的是图像中灰度值相对它的邻居点变化方式。如果一副图像中灰度从一边到另一边变化很小，那就说这副图像是低频信号。如果某些像素相对于它邻近的像素点变化很剧烈，则说明该图像含有高频信号.
2）简单一点说，图像中的高频分量，指的是图像强度（亮度/灰度）变化剧烈的地方，也就是我们常说的边缘（轮廓）；图像中的低频分量，指的是图像强度（亮度/灰度）变换平缓的地方，也就是大片色块的地方。人眼对图像中的高频信号更为敏感。
3）图像的高低频是对图像各个位置之间强度变化的一种度量方法。
低频分量：主要对整副图像的强度的综合度量。高频分量：主要是对图像边缘和轮廓的度量。 如果一副图像的各个位置的强度大小相等,则图像只存在低频分量,从图像的频谱图上看,只有一个主峰,且位于频率为零的位置。 如果一副图像的各个位置的强度变化剧烈,则图像不仅存在低频分量,同时也存在多种高频分量,从图像的频谱上看,不仅有一个主峰,同时也存在多个旁峰。
1.2直观认识 假设在正弦波中有一个毛刺，并且正弦波的变化非常的缓慢，频率较低，在正弦波上有一个毛刺，这个毛刺在短时间内就完成了一个变化周期，频率较高。所以我们就把这里的正弦波称为低频信号，而毛刺就称为高频信号。如果要对这个曲线平滑滤波的话，效果就是把毛刺滤掉，也就是说，平滑滤波的操作会将高频信号去除而低频信号保留，也就是我们常说的低通滤波器了。 最简单的低通滤波器的实现就是中值或者均值滤波器。 由以上的认识推广到二维图像上，也就不难知道为什么会将图像上变化剧烈的地方叫做高频信号，而变化平缓的地方叫做低频信号了。
二、图像频率的理解 1、不同频率信息在图像结构中有不同的作用。图像的主要成分是低频信息，它形成了图像的基本灰度等级，对图像结构的决定作用较小；中频信息决定了图像的基本结构，形成了图像的主要边缘结构；高频信息形成了图像的边缘和细节，是在中频信息上对图像内容的进一步强化。2、图像的频率是表征图像中灰度变化剧烈程度的指标，是灰度在平面空间上的梯度。如：大面积的沙漠在图像中是一片灰度变化缓慢的区域，对应的频率值很低；而对于地表属性变换剧烈的边缘区域在图像中是一片灰度变化剧烈的区域，对应的频率值较高。3、对图像而言，图像的边缘部分是突变部分，变化较快，因此反应在频域上是高频分量；图像的噪声大部分情况下是高频部分；图像平缓变化部分则为低频分量。也就是说，傅立叶变换提供另外一个角度来观察图像，可以将图像从灰度分布转化到频率分布上来观察图像的特征。4、图像进行二维傅立叶变换得到频谱图，就是图像梯度的分布图，当然频谱图上的各点与图像上各点并不存在一一对应的关系，即使在不移频的情况下也是没有。傅立叶频谱图上我们看到的明暗不一的亮点，实际是上图像上某一点与邻域点差异的强弱，即梯度的大小，也即该点的频率的大小（可以这么理解，图像中的低频部分指低梯度的点，高频部分相反）。5、图像的频率，不是图像上某一个点的频率，它反映了反应了图像像素变化的快慢，也就是说，在某一区域变化的非常大非常的快，那这一区域就携带有一定的高频的信息。图像的高频信息越多，图像的细节特征也就越多。 三、各类滤波器 高通滤波：允许高频信号通过（边缘加强、提取）；
低通滤波：允许低频信号通过（边缘平滑）；
带通滤波：允许一定频率的信号通过；
带阻滤波：注意一定频率通过，并允许其他频率通过；
全通滤波：允许所有频率通过，仅仅改变相位关系；
陷波滤波（Band-Stop Filter）：阻止一个狭窄频率范围通过，一种特殊的带阻滤波器；
边缘区域的灰度变化较大，也就是频率较高，所以对于高通滤波边缘部分将会保留，非边缘部分将会被过滤；对于低通滤波边缘区域将会被平滑过渡掉。(低通即为模糊，高通即为锐化)线性滤波是指：两个信号之和的响应和它的响应之和相等，即，每个像素的输出值是一些输入像素的加权和。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b690389601a4ad8d6a4befc1b88ca00/" rel="bookmark">
			活动安排问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 设有n个活动的集合E＝{1，2，…，n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。
每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi，且si＜fi。如果选择了活动i，则它在半开时间区间[si ，fi )内占用资源。若区间[si ，fi )与区间[sj，fj )不相交，则称活动i与活动j是相容的。当 si ≥ fj 或 sj ≥ fi 时，活动i与活动j相容。
活动安排问题就是在所给的活动集合中选出最大的相容活动子集合。
把活动的起始时间和结束时间定义为结构体:
struct action{ int s; int f; int index; }; 活动集合E记为数组：
action a[1000];
按活动的结束时间升序排序
排序比较因子：
bool cmp(const action &amp;a, const action &amp;b)
{
if (a.f&lt;=b.f) return true;
return false;
}
使用标准模板库函数排序（下标0未用）：
sort(a, a+n+1, cmp);
void Greedy(vector&lt;Action&gt; &amp;v,int n){ v[0].select=1; int select=0; for(int i=1;i&lt;n;i++)	{ if(v[i].gets()&gt;=v[select].gete()){ v[i].select=1; select=i; } } cout&lt;&lt;"可以安排如下的活动："&lt;&lt;endl; for(i=0;i&lt;n;i++) if(v[i].select) v[i].display(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5590b3f633dc2400e4aaf0707bcbf000/" rel="bookmark">
			用nginx实现反向代理，实现外网访问内网的服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境背景，服务器为Ubuntu：
一台可以连接公网和内网的服务器A，公网IP地址：61.174.×.×，另一台内网服务器B上安装jenkins服务，内网的IP地址192.168.3.12
操作步骤：
在A上安装nginx
sudo apt-get install nginx
安装好之后，进入/etc/nginx/sites-enabled目录，打开目录中的文件，修改默认端口号为8085，
然后进入/etc/nginx/conf.d 目录，新建文件 jenkins.conf，文件内容如下：
server{
listen 8085;
server_name 61.174.171.61;
location /{
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;
proxy_set_header Host $http_host;
proxy_set_header X-Nginx-Proxy true;
proxy_pass http://192.168.3.12:8080;
proxy_redirect off;
}
然后执行sudo nginx -t
sudo nginx -s reload
如果出现错误：nginx: [error] invalid PID number "" in "/run/nginx.pid"
则执行 sudo nginx -c /etc/nginx/nginx.conf 然后在公网上访问61.174.171.61:8085，即可访问到内网的jenkins服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aac32955f10690ddd06a36cef69ff710/" rel="bookmark">
			python 比较两个列表, 相同元素和不同元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种，for循环，此情况是list1属于list2
list1 = [1, 2, 3] list2 = [1, 2, 3, 4, 5] for i in list2: if i not in list1: print(i) 第二种，得出列表中相同的元素，和不同元素（两个列表都存在）
list1 = [1, 2, 3, 8] list2 = [1, 2, 3, 4, 5] a = [x for x in list1 if x in list2] #列表中相同元素 b = [y for y in (list1 + list2) if y not in a] #列表中不同元素 （两个列表都存在） print(a) print(b) 第三种 c 为 在list1列表中而不在list2列表中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aac32955f10690ddd06a36cef69ff710/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aabc506e90253ec6fcf1ba5f43787cb5/" rel="bookmark">
			Springcloud 高并发  配置  （一文全懂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章很长，建议收藏起来，慢慢读! 疯狂创客圈为小伙伴奉上以下珍贵的学习资源：
疯狂创客圈 经典图书 ： 《Netty Zookeeper Redis 高并发实战》 面试必备 + 大厂必备 + 涨薪必备疯狂创客圈 经典图书 ： 《SpringCloud、Nginx高并发核心编程》 面试必备 + 大厂必备 + 涨薪必备疯狂创客圈 价值1000元 百度网盘资源大礼包 随便取 GO-&gt;【博客园总入口 】独孤九剑 Netty灵魂实验 ： 本地 100W连接 高并发实验，瞬间提升Java内力 文章目录 价值连城：2021春招月薪过5万 面试题 系列万字长文： 疯狂创客圈 springCloud 高并发系列前言Springcloud的性能问题Servlet 容器 优化Zuul配置 优化Feign 配置优化hystrix配置 优化ribbon 优化 疯狂创客圈 Java 死磕系列疯狂创客圈 Java 死磕系列 价值连城：2021春招月薪过5万 面试题 系列 搞定下面这些面试题，2021春招月薪过5万(猛！)阿里、京东、美团、头条… 随意挑、横着走！！！Java基础1： JVM面试题（史上最强、持续更新、吐血推荐）https://www.cnblogs.com/crazymakercircle/p/14365820.html2：Java基础面试题（史上最全、持续更新、吐血推荐）https://www.cnblogs.com/crazymakercircle/p/14366081.html3：死锁面试题（史上最强、持续更新）[https://www.cnblogs.com/crazymakercircle/p/14323919.html]4：设计模式面试题 （史上最全、持续更新、吐血推荐）https://www.cnblogs.com/crazymakercircle/p/14367101.html5：架构设计面试题 （史上最全、持续更新、吐血推荐）https://www.cnblogs.com/crazymakercircle/p/14367907.html还有 10 几篇 篇价值连城 的面试题具体… 请参见【 疯狂创客圈 高并发 总目录 】 万字长文： 疯狂创客圈 springCloud 高并发系列 springCloud 高质量 博文 nacos 实战（史上最全） sentinel （史上最全+入门教程） springcloud + webflux 高并发实战 Webflux（史上最全） SpringCloud gateway （史上最全）还有 10 几篇 万字长文 的高质量 博文具体… 请参见【 疯狂创客圈 高并发 总目录 】 前言 疯狂创客圈（笔者尼恩创建的高并发研习社群）Springcloud 高并发系列文章，将为大家介绍三个版本的高并发秒杀：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aabc506e90253ec6fcf1ba5f43787cb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27a15408f38b5d2a04b3faed863ea5ff/" rel="bookmark">
			彻底解决Virtualbox共享粘贴板不可使用问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.在虚拟机设置界面-&gt;常规 中选择双向
二.在虚拟机设置界面-&gt;存储 中进行如下勾选
三.在虚拟机设备选项中选择’安装增强功能’
如果有挂载错误Could not mount the media/drive ‘C:\Program Files\Oracle\VirtualBox/VBoxGuestAdditions.iso’
可以直接在驱动盘用运行autorun.sh即可解决
————————————————
原文链接：https://blog.csdn.net/u011311291/article/details/84979704
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaeaf6237954db532682143c4b9ee177/" rel="bookmark">
			使用html2canvas生成海报
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载 npm i html2canvas -s
导入 import html2canvas from ‘html2canvas’
//第一个参数是盒子容器 html2canvas(document.body,{ //设置海报的大小和宽度 height: document.body.offsetHeight+50, width: document.body.offsetWidth, //海报里面的图片是否允许跨域，即访问外链图片 allowTaint: true, }).then(canvas=&gt;{ //将画布转化为base64的图片,图片跨域时无法转化为图片(暂未解决这个问题) var url = canvas.toDataURL(); console.log(canvas); //将画布添加到body元素上 document.body.appendChild(canvas) }); html2canvas的坑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/141970a3b2f09f19f6e6325b0fe5b52a/" rel="bookmark">
			图解 LeetCode 第 421 题：数组中两个数的最大异或值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击蓝色“五分钟学算法”关注我哟
加个“星标”，天天中午 12:15，一起学算法
本文为读者投稿，作者 | 李威
经作者授权转载，来源 |https://www.liwei.party
今天分享的题目来源于 LeetCode 第 421 号问题：数组中两个数的最大异或值。在 异或 这个知识点里面属于一个中高难度的题目。
题目描述 给定一个非空数组，数组中元素为 a0, a1, a2, … , an-1，其中 0 ≤ ai &lt; 231 。
找到 ai 和 aj 最大的异或 (XOR) 运算结果，其中0 ≤ i, j &lt; n 。
你能在 O(n) 的时间解决这个问题吗？
示例:
输入: [3, 10, 5, 25, 2, 8] 输出: 28 解释: 最大的结果是 5 ^ 25 = 28. 题目解析 解决这个问题，我们首先需要利用异或运算的一个性质：
如果 a ^ b = c 成立，那么a ^ c = b 与 b ^ c = a 均成立。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/141970a3b2f09f19f6e6325b0fe5b52a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da74d32b8d68b55e472ab63adf0f8d35/" rel="bookmark">
			Springboot异常java.lang.StackOverflowErrorfen分析及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、报错信息 Caused by: java.lang.StackOverflowError: null at java.io.ObjectInputStream$BlockDataInputStream.readByte(ObjectInputStream.java:2774) at java.io.ObjectInputStream.readHandle(ObjectInputStream.java:1450) at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1512) at java.io.ObjectInputStream.readArray(ObjectInputStream.java:1664) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1345) at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2000) at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1924) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1801) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351) at java.io.ObjectInputStream.readArray(ObjectInputStream.java:1707) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1345) at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2000) at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1924) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1801) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351) at java.io.ObjectInputStream.readArray(ObjectInputStream.java:1707) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1345) at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2000) at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1924) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1801) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351) at java.io.ObjectInputStream.readArray(ObjectInputStream.java:1707) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1345) at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2000) at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1924) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1801) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351) at java.io.ObjectInputStream.readArray(ObjectInputStream.java:1707) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1345) at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2000) at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:1924) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1801) at java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da74d32b8d68b55e472ab63adf0f8d35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a4ae765ff6850e9c3d3cace3aa4aec3/" rel="bookmark">
			modesim se-64 10.4c与Questasim-64 10.6c兼容使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前电脑上一直安装的是modesim se-64 10.4c的版本，用的一直都很好，后面由于项目需要，要用到vivado 18.2来开发项目。由于xilinx自带的仿真软件每次打开都很慢，非常浪费时间，想使用vivado和modesim联合仿真的方式缩短每次仿真时间。网上有一些写的非常详细的博客关于如何将vivado和modelsim联合起来，但是对modesim的版本有要求，modesim10.6c或者Questasim-64 10.6c。（下图是版本要求的说明）
（https://china.xilinx.com/support/documentation/sw_manuals/xilinx2018_2/ug973-vivado-release-notes-install-license.pdf）
Questasim在各个版本的开发软件上比较通用，就下载了一个Questasim-64 10.6c，安装方法跟modelsim差不多，然后进行vivodo和联合仿真，方法跟modelsim一样，链接如下：https://blog.csdn.net/weixin_37603007/article/details/82823965。唯一的不同点在于有个setting（设置）那里，需要改成questasim。
所有的设置完毕之后，vivado调用Questasim仿真可以很快地调出Questasim，得到很好的仿真效果。（有次错误操作，在setting-3rd party simulation那里选择了modelsim，想不到反正居然调出了modesim se-64 10.4c，很奇怪）。
因为我电脑上还安装了ise，ise之前一直联合仿真的时候调用的是modesim se-64 10.4c，可是当我再次使用ise进行联合仿真的时候却报错了，如下错误：
ERROR: Platform mismatch!
ERROR: Error(s) encountered while extracting pre-compiled simulation library information.
后来发现原因是进行vivado和Questasim联合仿真设置的时候，有个步骤不应该设置，可以不用设置那个用户变量。设置用户变量会导致ise在调用modelsim的时候，指向了Questasim的预编译库中的ini文件。就是下图这个步骤：
取消了这个环境变量后，ise可以正常调用modesim se-64 10.4c，vivado也可以正常调用Questasim-64 10.6c。
最近写大论文，笔记本重新换了系统，各种软件全部重装，发现参考的那篇博客有个步骤不太正确，联合之后，vivado在调用questasim的时候，老是报一个fifo库文件的错误，后面从新编译了库之后，才解决，编译库的过程中有个选项要选择一下，如下图所示。其中步骤4那个选项要勾上，不然编译出来的库，不能正确进行questasim仿真。
后续，我会做一个完整的联调安装步骤，敬请期待。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e10a7b3ff369d6fa9e23ab81a1e9da77/" rel="bookmark">
			语义分割评估指标MIOU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、MIOU定义 Mean Intersection over Union(MIoU，均交并比)：为语义分割的标准度量。其计算两个集合的交集和并集之比，在语义分割的问题中，这两个集合为真实值和预测值。在每个类上计算IoU，之后平均。计算公式如下：
i表示真实值，j表示预测值 ，p_{ij}pij​ 表示将i预测为j 。
2、直观理解 MIoU：计算两圆交集（橙色部分）与两圆并集（红色+橙色+黄色）之间的比例，理想情况下两圆重合，比例为1。
3、MIOU实现 （1）先求混淆矩阵
（2）再求mIOU
混淆矩阵的每一行再加上每一列，最后减去对角线上的值
import numpy as np
class IOUMetric:
"""
Class to calculate mean-iou using fast_hist method
"""
def __init__(self, num_classes):
self.num_classes = num_classes
self.hist = np.zeros((num_classes, num_classes))
def _fast_hist(self, label_pred, label_true):
# 找出标签中需要计算的类别,去掉了背景
mask = (label_true &gt;= 0) &amp; (label_true &lt; self.num_classes)
# # np.bincount计算了从0到n**2-1这n**2个数中每个数出现的次数，返回值形状(n, n)
hist = np.bincount(
self.num_classes * label_true[mask].astype(int) +
label_pred[mask], minlength=self.num_classes ** 2).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e10a7b3ff369d6fa9e23ab81a1e9da77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e69ba98bf12604ba692fa41b2a5e1bef/" rel="bookmark">
			three.js材质大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		three.js材质大全 目录 材质(Material)MeshBasicMaterialMeshDepthMaterialMeshDistanceMaterialMeshMatcapMateriaMeshNormalMaterialMeshFaceMaterialMeshLambertMaterialMeshPhongMaterialMeshToonMaterialMeshStandardMaterialMeshPhysicalMaterialSpriteMaterialShaderMaterialLineBasicMaterialLineDashedMaterialPointsMaterial 1.材质(Material) 材质的抽象基类。材质描述了对象objects的外观。它们的定义方式与渲染器无关， 因此，如果您决定使用不同的渲染器，不必重写材质。所有其他材质类型都继承了以下属性和方法（尽管它们可能具有不同的默认值）。 2.MeshBasicMaterial 一个以简单着色（平面或线框）方式来绘制几何体的材质。这种材质不受光照的影响。
属性：
color：颜色wireframe：是否显示线框wireframeLinewidth：线框线宽度wireframeLinecap：线段端点如何显示。可选值有：butt（平）、round、square。默认是round。WebGLRenderer对象不支持该属性。wireframeLinejoin：线段连接点如何显示。可选值有：round、bevel（斜角）、miter（尖角）。默认是round。WebGLRenderer对象不支持属性。shading：着色模式。可选值：THREE.SmoothShading、THREE.FlatShading。vertexColors：为每个顶点定义不同的颜色。在CanvasRenderer对象中不起作用。fog：指示当前是否会受全局雾化效果设置的影响。 3.MeshDepthMaterial 一种按深度绘制几何体的材质。深度基于相机远近平面。白色最近，黑色最远。使用这种材质的物体，其外观不是由光照或某个材质属性决定的；而是由物体到相机的距离决定的。可以将这种材质与其他材质相结合，从而很容易创建逐渐消失的效果。只有两个控制线框的属性：wireframe,wireframeLinewidth可以通过设置相机的near和far的值，来控制创建中使用这种材质的物体的消失速度。如果near和fat之间的差值越大，那么物体远离相机时，只会稍微消失一点；反之，物体消失的效果非常明显。注意：没有颜色属性 4.MeshDistanceMaterial 主要用于通过PointLight光源实现阴影映射。通过将MeshDistanceMaterial的实例分配给Object3D.customDistanceMaterial，还可以用于自定义对象的阴影投射。 5.MeshMatcapMateria 由MatCap（或Lit Sphere）纹理定义，该纹理编码材质的颜色和阴影（理解这种材质的关键！）。由于Matcap图像文件对烘焙的照明进行编码，因此MeshMatcapMaterial对灯光不响应。它将阴影投射到接收阴影的对象上（并且进行阴影修剪），但不会自阴影或接收阴影。 6.MeshNormalMaterial 根据物体表面的法向量计算颜色法向量的作用： 决定光的发射方向、在计算光照、阴影时提供信息、为物体表面上色。法向量所指的方向决定每个面从MeshNormalMaterial材质获取的颜色。 7.MeshFaceMaterial 这是一种容器，可以在该容器中为物体的各个表面上设置不同的颜色。可以为几何体的每一个面指定不同的材质。假设有一个正方体，可以为每个面指定不同的颜色。 8.MeshLambertMaterial 一种非光泽表面的材质，没有镜面高光。
该材质使用基于非物理的Lambertian模型来计算反射率。
这可以很好地模拟一些表面（例如未经处理的木材或石材），但不能模拟具有镜面高光的光泽表面（例如涂漆木材）。
使用Gouraud着色模型计算着色。这将计算每个顶点的着色 （即在vertex shader中）并在多边形的面上插入结果。
基本属性：color、opacity、shading、blending、depthTest、depthWrite、wireframe、wireframeLineWith、wirefLinecap、wireframeLinejoin、vertexColors、fog。
独特属性：
ambient：和AmbientLight光源一起使用。该颜色会与AmbientLight光源的颜色相乘。默认是白色。
emissive：该材质发射的属性。不像是光源，只是一种纯粹的、不受其他光照影响的颜色。默认是黑色。
9.MeshPhongMaterial 该材质使用非物理的Blinn-Phong模型来计算反射率。
与MeshLambertMaterial的区别是，该材质可以模拟具有镜面高光的光泽表面（例如涂漆木材）。
使用Phong着色模型计算着色时，会计算每个像素的阴影（在fragment shader， AKA pixel
shader中），与MeshLambertMaterial使用的Gouraud模型相比，该模型的结果更准确，但代价是牺牲一些性能。
MeshStandardMaterial和MeshPhysicalMaterial也使用这个着色模型。
独特属性：
ambient
emissive
specular：指定该材质的光亮程度及其高光部分的颜色。如果将他设置成跟color属性相同的颜色，将会得到一种更加类似金属的材质。如果设置为灰色，材质将变得更像塑料。
shininess：指定高光部分的亮度。默认是30.
10.MeshToonMaterial MeshPhongMaterial卡通着色的扩展。 11.MeshStandardMaterial 一种基于物理的标准材质，使用Metallic-Roughness工作流程。
基于物理的渲染（PBR）最近已成为许多3D应用程序的标准，例如Unity， Unreal和 3D Studio Max。
这种方法与旧方法的不同之处在于，不使用近似值来表示光与表面的相互作用，而是使用物理上正确的模型。
我们的想法是，不是在特定照明下调整材质以使其看起来很好，而是可以创建一种材质，能够“正确”地应对所有光照场景。 在实践中，该材质提供了比MeshLambertMaterial 或MeshPhongMaterial 更精确和逼真的结果，代价是计算成本更高。
计算着色的方式与MeshPhongMaterial相同，都使用Phong着色模型。
12.MeshPhysicalMaterial MeshStandardMaterial的扩展，能够更好地控制反射率。 13.SpriteMaterial 一种使用Sprite的材质。粒子、点云使用的材质。 14.ShaderMaterial 使用自定义的着色器程序，直接控制顶点的放置方式，以及像素的着色方式。
独特属性：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e69ba98bf12604ba692fa41b2a5e1bef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c7f6725baf7144ed798b56540ef0278/" rel="bookmark">
			pycharm中new environment using和existing interpreter（Virtualenv E*t,Conda E*t,System i*r，pipenv E*t）区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		new environment using和existing interpreter new environment using是为项目创建一个新的环境，这里有三个选择：Virtualenv,Pipenv,Conda
Virtualenv Environment:是虚拟环境的意思，它在项目文件下创建一个独立虚拟环境(venv),他是一款工具，在pycharn中集成了。它会创建一个独立的虚拟环境，可以使一个Python程序拥有独立的库library和解释器interpreter，而不用与其他Python程序共享统一个library和interpreter程序间，避免了不同Python程序间的互相影响，独立的使用一个Python解释器，不会与本地解释器产生影响。
pipnev:包管理模块
conda:在conda环境下创建一个虚拟环境，venv在anaconda下，项目文件在venv下。
新建一个Virtualenv： 第一个Location，项目文件名默认的是untitled，选择Virtualenv后，其下面的第二个Location在项目文件下新增了venv,解释器自动选择的是原来安装的Python解释器(非anaconda下的Python解释器)，第三个箭头的意思是导入Base interpreter对应的解释器中已安装的包，虚拟环境下会自带一些包，但是包的数量少，最好勾选第三个箭头。
虚拟环境下未勾选inherit global site-packages时，package只有pip,setupools
虚拟环境下勾选inherit global site-packages的情况，package多了numpy,这是一个数组包，Python解释器里没有，需要自己手动下载，如果下载了anaconda，anaconda会自带numpy.【如何下载包，详见我的另一篇文章：】
新建一个Conda环境下的虚拟环境： 这里有三种情况：
1.在conda executable下选择conda.exe(此执行文件在scripts下),系统一般自动默认此项，location:项目文件自动到anaconda的envs下。我们也可以自己设置路径，不会有影响。
未修改路径的情况以及包内容：
修改后的路径以及包内容：
2.在conda executable下选择_conda.exe,路径自动变到c盘下。
未修改路径情况及包内容：
修改路径情况及包内容：
3.在conda executable选项下选择anaconda下的Python.exe，会出现问题。
即使修改路径仍然会出现问题
existing interpreter情况: 字面上理解就是已经存在的解释器，可选择得有4种
Virtualenv Environment,Conda environment,System interpreter，Pipenv Environment
Virtualenv Environment:这里还出现Virtualenv Environment，是因为我们也可以在本地安装个虚拟环境，不再是依托pycharm中集成的，具体在本地创建虚拟环境见：https://blog.csdn.net/u011318077/article/details/85318097
Conda environment：这里可以选择anaconda下的python.exe，里面有很多包
如果选择anaconda下的conda.exe，不能创建成功
如果选择anaconda下的_conda.exe，不能创建成功
System interpreter:本地解释器，这个选择安装的Python解释器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd1782e0b02d1c8d8174d66416a9c133/" rel="bookmark">
			Database - PLSQL安装、使用、汉化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇还不完善，之后我会补充plsql的安装，还有汉化软件
安装部分汉化部分无汉化选项 - 处理方式 安装部分 1.执行安装 .exe文件
2.同意协议
3.选择安装目录
4.选正常的安装类型即可
5.确定安装目录、类型
6.完成安装
汉化部分 总步骤：顶部菜单 → Tools → Preferences → User Interface → Appearance → Language → Chinese.lang → Apply → OK
步骤 1：Tools → Preferences
未汉化版
已汉化版
步骤 2：User Interface → Appearance → Language → Chinese.lang → Apply → OK
未汉化版
已汉化版
无汉化选项 - 处理方式 下载PLSQL的汉化包，然后将对应文件放在对应区域内
Chinese文件夹内的文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4996c8101170b6d44c07809716b865ce/" rel="bookmark">
			spark提交任务详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6796468342f856917bec66ac020239d8/" rel="bookmark">
			select、poll、epoll之间的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		select、poll、epoll之间的区别:
(1)、select==&gt;时间复杂度O(n)
select仅仅知道了，有I/O时间发生了，却并不知道是哪几个流（可能一个、多个、甚至全部）,我们只能无差别的轮询所有的流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别的轮询复杂度，同时处理的流越多，无差别轮询时间越长。
(2)、poll==&gt;时间复杂度O(n)
poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，但是它没有最大连接数的限制，原因是它是基于链表来存储的。
(3)、epoll==&gt;时间复杂度O(1)
epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们操作这些流都是有意义的。（复杂度降低到了O(1)）
select、poll、epoll都是I/O多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般就是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll,epoll本质上都是同步I/O,因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。
epoll和select都能够提供多路I/O复用的解决方案。在现在的linux内核里都能够支持，其中epoll是linux所特有的，而select则在一般的操作系统中都有实现，是POSIX所规定。
select:
select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：
（1）、单个进程可监视的fd的数量被限制，即能监听的端口的大小有限。这个数字和系统内存关系很大，可以在cat /proc/sys/fs/file-max查看。32位机器默认是1024个。64位机器默认是2048个。
（2）、对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：
当套接字比较多的时候，每次select（）都要通过遍历FD_SETSIZE个socket来完成调度，不管哪个socket是活跃的，都遍历一遍。这浪费了很多cpu的时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll和kqueue做的。
（3）、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间、内核空间在传递该结构时复制开销大。
poll：
poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有的fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。
poll是基于链表来存储的，所以它没有最大连接数的限制，但同样有一个缺点：
（1）、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。
（2）、poll还有一个特点是“水平触发”,如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。
epoll
epoll有epolllt和epollet两种触发模式，lt是默认的模式，et是高速模式。lt模式下，只要这个fd还有数据可读，每次epoll_wait都会返回它的事件，提醒用户程序去操作，而在et（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读。所以在et模式下，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者遇到eagain错误。还有一个特点，epoll使用事件的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用callback的回调机制来激活该fd,epoll_wait便可以收到通知。
epoll为什么要有epollet触发模式？
如果采用epolllt模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率。
而采用epollet这种边沿触发模式的话，当被监控的文件描述符上有读写事件发生时，epoll_wait（）会通知处理程序去读写。
如果这次没有把数据全部读写完成（如读写缓冲区太小）,那么下次调用epoll_wait（）时，它不会通知你，也就是只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！这种模式比水品触发效率高，系统不会充斥大量你不关心的就绪文件描述符。
epoll的优点：
1、没有最大并发连接的限制，能打开的fd的上限远大于1024（1G的内存上能监听10万个端口）;
2、效率提升，不是轮询的方式，不会随着fd数目的增加效率下降，只有活跃可用的fd才会调用callback函数;即epoll最大的优点是它只管活跃的连接，而与总链接数无关，因此在实际的网络环境中，epoll的效率就会远高于select和poll。
3、内存拷贝，利用mmap()文件映射内存加速于内核空间的消息传递；即epoll使用mmap减少复制开销。
select、poll、epoll的区别总结：
1、支持一个进程所能打开的最大连接数
select 是 32位机默认是1024个，64位机默认是2048。
poll 本质上于select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的。
epoll 虽然有连接数上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的可以打开20万左右的连接。
2、fd剧增后带来的I/O效率问题
select 每次调用事都会对连接进行线性遍历，所以随着fd的增加会造成遍历速度慢，呈线性下降性能问题。
poll 同上
epoll epoll内核中实现是根据每个fd的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃的socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有的socket都很活跃的情况下，可能会有性能问题。
3、消息传递方式
select 内核需要将消息传递到用户空间，都需要内核拷贝动作
poll 同上
epoll 通过内核和用户空间共享一块内存来实现的。
总结：
综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。
1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。
2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cc9441914b5a6d357cde6d945785f4b/" rel="bookmark">
			上传图片到OSS-browser
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OSS-browser下载地址：https://github.com/aliyun/oss-browser/blob/master/all-releases.md
阿里云官方文档 https://help.aliyun.com/document_detail/32008.html
原文链接：https://blog.csdn.net/u014079773/article/details/66968718?locationNum=9&amp;fps=1#
因为所需是kotlin的，所以根据原文改写了一个kotlin语言的 阿里云OSS对象存储上传图片
gradle配置
dependencies里面增加
implementation 'com.aliyun.oss:aliyun-sdk-oss:2.5.0' 常量类
package com.beeb.web.module.aliyun import com.aliyun.oss.OSSClient import com.aliyun.oss.model.ObjectMetadata import java.io.File import java.io.FileInputStream /** * @class: AliyunOSSClientUtils * @descript: java使用阿里云OSS存储对象上传 */ object AliyunOSSClientUtils { /** aliyun静态配置 */ private var ENDPOINT = "XX" // 阿里云API的内或外网域名 private var ACCESS_KEY_ID = "XX" // 阿里云API的密钥Access Key ID private var ACCESS_KEY_SECRET = "XX" // 阿里云API的密钥Access Key Secret private var BACKET_NAME = "XX" // 阿里云API的bucket名称 /** * 获取阿里云OSS客户端对象 * @return ossClient */ val ossClient = OSSClient(ENDPOINT, ACCESS_KEY_ID, ACCESS_KEY_SECRET) /** * 上传图片至OSS * @param ossClient oss连接 * @param file 上传文件（文件全路径） * @param bucketName 存储空间 * @param folder 模拟文件夹名 如"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cc9441914b5a6d357cde6d945785f4b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/247/">«</a>
	<span class="pagination__item pagination__item--current">248/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/249/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>