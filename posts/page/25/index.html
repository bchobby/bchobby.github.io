<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44bf212cf4c648c4454c39dda61092b7/" rel="bookmark">
			关于负载均衡器您需要了解和执行的所有操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嗨，我是 Roman，一位在 Gart 拥有超过 15 年经验的云架构师。今天，我想与你们一起深入探讨负载均衡器的世界。简单来说，负载均衡器就像是互联网的交通警察。
它的主要任务？将传入的网络流量分配给多个服务器。但我们不要试图一口吃掉这头大象；我们将一步步、一块块地品尝它。我将把这个复杂的话题分解成易于理解的小部分。
准备好深入了解了吗？
负载均衡器的工作原理 好吧，让我们揭开负载均衡器工作的神秘面纱。把它们想象成网络流量的指挥家。当你有多个服务器时，负载均衡器就介入并决定谁得到什么。它就像在繁忙城市中扮演交通警察的角色，但处理的是数据。
当你的网站成为城镇中最热门的地方时，大量访客开始涌入。负载均衡器看着传入的流量说：“你去服务器 A，你去服务器 B，你去服务器 C。”
负载均衡器并不是随机分配流量的；它们很聪明地处理。它们检查每台服务器的工作负载，确保没有服务器被压垮。
负载均衡的核心过程涉及在一组服务器（通常称为服务器农场或集群）之间高效分配传入请求。这确保了没有单一服务器被流量压垮，而其他服务器则未被充分利用。负载均衡可以在 OSI 模型的不同层实施，包括应用层、传输层和网络层，具体取决于系统的具体要求和架构。
负载均衡器采用各种算法在服务器之间分配传入流量，以优化性能和资源利用。一种常见的方法是循环算法，其中每个新请求被指向接下来的服务器，形成一个循环。这种简单的方法确保了流量的相对均匀分配，但可能不考虑每台服务器的实际负载或容量。
更复杂的算法，如最少连接或加权循环，考虑了服务器负载、响应时间和服务器容量等因素。最少连接将流量引导至活动连接最少的服务器，而加权循环则根据每台服务器的容量分配权重，实现工作负载更细致的分配。
此外，一些负载均衡器可以执行基于内容的路由，考虑传入请求的特定特征，如 URL 模式或请求类型。这允许根据请求的性质更智能地分配流量，优化专业服务器资源的利用。
硬件负载均衡器 硬件负载均衡器是负载均衡世界中的肌肉车。它们是实体设备，为处理繁重工作而设计。想象一下一台专用的、健壮的机器坐落在你的服务器室中，协调着流量。这些野兽完全是关于原始力量，并配备了专门的硬件以优化性能。
优点 性能野兽：硬件负载均衡器可以轻松处理大量流量。 专用硬件：由于它们是独立设备，通常配备专用处理器和内存，确保最佳性能。 可靠性：较不易受到软件缺陷或操作系统怪癖的影响。 缺点 成本：强大的性能伴随着高昂的价格。 可扩展性挑战：扩展可能意味着需要新的硬件均衡器，这并不总是轻而易举的。 灵活性：配置这些野兽有时感觉像驾驶油轮一样；它们功能强大，但操纵需要时间。 软件负载均衡器 软件负载均衡器是负载均衡领域的数字变色龙。与硬件版本不同，这些是代码，通常运行在标准服务器或虚拟机上。它们为派对带来了灵活性，像经验丰富的变形者一样适应数字化环境。
优点 成本效益：软件负载均衡器通常与现有基础设施兼容，为你节省了不少现金。 可扩展性：需要处理更多流量？没问题。在虚拟环境中启动更多实例即可扩展。 可配置性：无需硬件改造即可调整和优化设置。 缺点 资源利用：由于它们与同一服务器上的其他应用程序共享资源，高峰时期性能可能会受到影响。 复杂性：与硬件版本相比，设置和微调软件负载均衡器可能需要更多的技术知识。 在硬件和软件之间的拉锯战中，通常取决于你的具体需求、预算以及你试图导航的数字交通堵塞类型。明智选择，我的朋友。
负载均衡算法 循环赛
想象一下一场友好的传递包裹游戏。循环法以循环顺序在服务器之间平均分配传入流量。非常适合所有服务器在处理能力方面几乎相同的场景。这就像“每个人都有机会”的策略。虽然循环法易于实现且透明，但它可能不会考虑服务器负载或容量的变化，从而可能导致资源利用率不理想。
最少连接数
该算法将新连接发送到活动连接最少的服务器。这就像在杂货店挑选队伍最短的收银员一样。非常适合服务器负载变化的情况，确保每个服务器具有相似数量的活动连接。
最短响应时间
这种智能算法将流量引导至响应时间最快的服务器。这就像在收费站选择快速车道一样。非常适合通过向能够最快处理请求的服务器发送请求来优化用户体验。
加权循环赛
这是循环法的升级版本，它为每个服务器分配一个“权重”，确定其流量比例。这就像为可以处理更重负载的服务器提供更多票证一样。当服务器具有不同的容量，并且您希望根据其容量分配流量时。
加权最少连接数
与最少连接类似，但具有权重因子。它将新连接发送到具有最少加权连接的服务器。当服务器具有不同的容量并且您希望根据它们的相对优势平衡负载时很有用。
每种算法的比较和用例 循环法与最少连接：如果服务器相似，则循环法是一个简单的选择。如果没有，请选择“最少连接”以更智能地分配负载。
最短响应时间与加权循环：如果响应时间最重要，请使用最短响应时间。如果您有不同的服务器容量，请选择加权循环来有效平衡负载。
选择正确的算法就像为工作选择正确的工具一样。每种技术都有其优点，因此关键在于了解服务器的功能和流量的性质。
负载均衡器使用的常用协议 协议描述HTTP/HTTPS网络通讯基础；HTTPS 添加了加密以确保数据传输安全。传输控制协议确保互联网上数据的可靠传输；对于各种应用程序和服务至关重要。UDP协议适用于视频流和在线游戏等实时应用的轻量级协议。SSL/TLSSSL 建立安全连接；其后继者 TLS 可确保传输过程中的数据加密传输。 HTTP（超文本传输协议）
万维网上数据通信的基础。分配 Web 流量的负载均衡器通常处理HTTP请求。将其视为浏览器在请求网页时使用的语言。
HTTPS（安全超文本传输协议）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44bf212cf4c648c4454c39dda61092b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c65ee44f01e3e71267207ce7aa5e9228/" rel="bookmark">
			Flink集群部署--Standalone模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章：在CDH集群安装Flink
1. 下载安装包 查看自己的hadoop版本和scala版本, 这里是hadoop 2.6, scala 2.11
wget https://archive.apache.org/dist/flink/flink-1.7.2/flink-1.7.2-bin-hadoop26-scala_2.11.tgz 2. 解压 tar -zxf flink-1.7.2-bin-hadoop26-scala_2.11.tgz 3. 配置 flink-1.7.2/conf/flink-conf.yaml
选择一个 master节点(JobManager)然后在conf/flink-conf.yaml中设置jobmanager.rpc.address 配置项为该节点的IP 或者主机名。
# 配置主节点主机名 jobmanager.rpc.address: test-hadoop1 # The RPC port where the JobManager is reachable. jobmanager.rpc.port: 6123 # The heap size for the JobManager JVM jobmanager.heap.size: 1024m # The heap size for the TaskManager JVM taskmanager.heap.size: 5024m # The number of task slots that each TaskManager offers. Each slot runs one parallel pipeline.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c65ee44f01e3e71267207ce7aa5e9228/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/895966f16d4fb385a9c161cb702ca897/" rel="bookmark">
			gramine运行nodejs的环境配置问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 gramine需要使用makefile编译，
但是ubuntu自带的apt-get所使用的nodejs版本过低，而nodejs源码编译js的路径，使用软链接到/usr/bin似乎无法被gramine使用。
只有使用自带的apt-get方法，安装的nodejs才能被gramine识别到作为代码解释器。
因此需要下载脚本修改apt-get，通过apt-get下载大于v14的nodejs，才能正确在gramine中使用web3.js
使用脚本
sudo curl -sL https://deb.nodesource.com/setup_18.x | sudo -E bash - apt-get安装nodejs
sudo apt-get install -y nodejs 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eeb0d7651be99bf65463a854c7795af/" rel="bookmark">
			通话状态监听-Android13
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通话状态监听-Android13 1、Android Telephony 模块结构2、监听和广播获取通话状态2.1 注册2.2 通话状态通知2.3 通话状态 3、通知状态流程* 关键日志 frameworks/base/core/java/android/telephony/PhoneStateListener.java 1、Android Telephony 模块结构 Android Telephony 模块结构简析
Android Telephony 模块结构简析
Telecom 框架概览
Dialer.apk： /product/priv-app/Dialer/Dialer.apk、packages/apps/DialerTelecom.apk： /system/priv-app/Telecom/Telecom.apk、packages/service/telecommTeleService.apk： /system/priv-app/TeleService/TeleService.apk、packages/service/telephony
framework.jar： frameworks/base/telecomm、frameworks/base/telephony
telephony-common.jar： frameworks/opt/telephony
vendor.ril-daemon： hardware/ril 2、监听和广播获取通话状态 主要查看 framework.jar 代码
2.1 注册 PhoneStateListener注册：最终调用TelephonyRegistry.java#listenWithEventList添加到ArrayList&lt;Record&gt; mRecords
packages/apps/Dialer/java/com/android/incallui/InCallPresenter.java this.context .getSystemService(TelephonyManager.class) .listen(phoneStateListener, PhoneStateListener.LISTEN_CALL_STATE); 广播注册：public static final String ACTION_PHONE_STATE_CHANGED = "android.intent.action.PHONE_STATE";，权限android.permission.READ_PHONE_STATE
packages/apps/Dialer/java/com/android/dialer/dialpadview/DialpadFragment.java if (callStateReceiver == null) { IntentFilter callStateIntentFilter = new IntentFilter(TelephonyManager.ACTION_PHONE_STATE_CHANGED); callStateReceiver = new CallStateReceiver(); getActivity().registerReceiver(callStateReceiver, callStateIntentFilter); } / private class CallStateReceiver extends BroadcastReceiver { /** * Receive call state changes so that we can take down the "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7eeb0d7651be99bf65463a854c7795af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f6f6b10716adbf13a7c939f92f1ee54/" rel="bookmark">
			C语言预处理详解及其指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		预处理详解 1.预定义符号2.#define定义常量基本使用方法举例子如果在define定义的表示符后面加上分号会发生什么？用一下来解释 3. #define定义宏举例例1例2 4. 带有副作用的宏参数例如: 5. 宏替换的规则6. 宏函数的对比宏和函数的一个对比 7. #和##7.1 #运算符7.2 ## 运算符例如使用宏，定义不同函数 8. 宏命名约定9. #undef例如以下代码： 10.条件编译常见的条件编译指令 1.预定义符号 C语言设置了一些预定义符号，可以直接使用，预定义符号也是在预处理期间处理的。
__FILE__ //进⾏编译的源⽂件 __LINE__ //⽂件当前的⾏号 __DATE__ //⽂件被编译的⽇期 __TIME__ //⽂件被编译的时间 __STDC__ //如果编译器遵循ANSI C，其值为1，否则未定义 这个代码在vs上面是不可以使用的 int main() { printf("%s\n", __FILE__); printf("%d\n", __LINE__); printf("%s\n", __DATE__); printf("%s\n", __TIME__); //printf("%s\n", __STDC__);//vs不支持 return 0; } 以下是运行结果：
__FILE__:是打印当前文件的路劲
__LINE__:打印当前代码所对应的行号
__DATE__:打印的是当前的日期
__TIME__:打印的是当前的时间
2.#define定义常量 基本使用方法 #define name stuff name是变量名， stuff预定以后的名字
举例子 #define MAX 1000 #define reg register //为 register这个关键字，创建⼀个简短的名字 #define do_forever for(;;) //⽤更形象的符号来替换⼀种实现 #define CASE break;case //在写case语句的时候⾃动把 break写上。 // 如果定义的 stuff过⻓，可以分成⼏⾏写，除了最后⼀⾏外，每⾏的后⾯都加⼀个反斜杠(续⾏符)。 #define DEBUG_PRINT printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f6f6b10716adbf13a7c939f92f1ee54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/321f9c50f306bcaf10ad380116540b8b/" rel="bookmark">
			Redis系列之事务机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Redis事务 学习mysql数据库的时候，我们知道了事务的ACID特性，Redis也是支持事务的，不过和数据库的事务又有什么区别？在mysql数据库中，我们使用begin开启事务，提交是commit，回滚是rollback，然后Redis中的事务是怎么一回事？redis的事务其实可以看做是一组命令按照顺序，串行执行队列中的命令，其它客户端的命令不会写入到这个队列中。总的来说，redis事务就是一次性、顺序性、排他性的执行一个队列中的一组命令
redis事务相关命令和使用 MULTI 、 EXEC 、 DISCARD 和 WATCH、UNWATCH命令是redis实现事务需要的命令
multi：开启事务，事务开启后，事务中的多条命令会排队，等事务提交discard：取消事务，放弃执行队列里的所有命令exec：执行事务里的所有命令watch：监控一个或者多个key，如果事务提交之前，这个key被其它客户端修改了，这个事务就不会提交unwatch： 取消watch对所有key的监视 redis事务例子 正常的事务执行过程 127.0.0.1:0&gt;multi "OK" 127.0.0.1:0&gt;incr testid "QUEUED" 127.0.0.1:0&gt;exec 1) "1" 语法错误导致的事务回滚 127.0.0.1:0&gt;multi "OK" 127.0.0.1:0&gt;incr testid "QUEUED" 127.0.0.1:0&gt;seta a "ERR unknown command `seta`, with args beginning with: `a`, " 127.0.0.1:0&gt;exec "EXECABORT Transaction discarded because of previous errors." 对string类型进行incr
对一个key先设置为string类型的，然后使用incr命令进行递增，再提交事务，出现错误 127.0.0.1:0&gt;set testid aa "OK" 127.0.0.1:0&gt;multi "OK" 127.0.0.1:0&gt;incr testid "QUEUED" 127.0.0.1:0&gt;exec 1) "ERR value is not an integer or out of range"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/321f9c50f306bcaf10ad380116540b8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/035c03fca34c1c20cbbb0c0d3628e6c9/" rel="bookmark">
			ADB命令安装卸载手机APP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 手机内置的浏览器很多广告，推荐的新闻也很多负面的新闻，所以就想卸载内置的手机app，不过现在很多手机都是限制了内置的软件都不能卸载，以前随便获取一下root权限，也是可以卸载的，不过最近搞了一下，发现现在root权限这么难获取，所以就只能另外寻方法了，去网上搜了一下，发现可以使用adb命令来卸载内置软件，不需要root权限
ADB是什么？ 通过网上找资料，在AndroidStudio开发者网找到相关资料：引用官网解释，当个了解熟悉就可以，看不懂也没关系的，不是开发人员了解就行
Android 调试桥 (adb) 是一种功能多样的命令行工具，可让您与设备进行通信。adb 命令可用于安装和调试，并提供对 Unix shell的访问权限。它是一种客户端-服务器程序，包括以下三个组件：
客户端：用于发送命令。客户端在开发计算机上运行。您可以通过发出 adb 命令从命令行终端调用客户端。守护程序 (adbd)：用于在设备上运行命令。守护程序在每个设备上作为后台进程运行。服务器：用于管理客户端与守护程序之间的通信。服务器在开发机器上作为后台进程运行。 环境准备 win7系统ADB 1.0.32adb driver(32/64位)国产安卓手机 安装ADB驱动 因为win7操作系统默认没安装ADB驱动的，所以需要先检查ADB驱动是否安装，选择“我的电脑”-&gt;右键-&gt;设备管理，如图，如果出现类似的带黄色图标的，说明ADB驱动没安装
可以去下载一下adb驱动，网上搜索一下，可以去51脚本网站下载一个驱动https://www.jb51.net/softs/538237.html
选择ADB Interface，右键-&gt;更新驱动程序软件
这里直接浏览计算机本地的，找到刚才下载的驱动安装
安装成功之后，是会显示如图，说明安装成功
开发者模式开启 需要有一条usb数据线，连接笔记本电脑，不同的手机开发者模式开启不一样，这里是设置-&gt;关于手机，然后连续点版本号的文字，就会进入开发者模式，然后退出，在系统和更新选项里，找到开发人员选项，进入开发者模式，开启，同时开启usb调试
使用ADB 如下ADB下载链接：
https://dl.lancdn.com/landian/tools/adb/adb%2Bdriver.zip
下载好之后，解压adb+driver压缩文件到一个文件夹里，如图输入cmd回车：
Microsoft Windows [版本 6.1.7601] 版权所有 (c) 2009 Microsoft Corporation。保留所有权利。 // 校验adb是否安装成功 D:\adbDriver&gt;.\adb devices adb server is out of date. killing... * daemon started successfully * List of devices attached B6LJLFLFPZ4DQKCU device // 进入shell命令 D:\adbDriver&gt;.\adb shell // 卸载oppo自带浏览器 oppo4版本是com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/035c03fca34c1c20cbbb0c0d3628e6c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ace46c57ae64084a4f3d9dd7ecfd633e/" rel="bookmark">
			【sprintboot&#43;vue3】解决前后端分离项目遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Access to XMLHttpRequest at 'http://127.0.0.1:8088/api/hello' from origin 'http://localhost:5173' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
二、报错[@vue/compiler-sfc] 一、Access to XMLHttpRequest at 'http://127.0.0.1:8088/api/hello' from origin 'http://localhost:5173' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. 报错：
原因：来自一个IP端口的页面（前端项目），要访问另一个IP端口的资源（springboot请求接口），会产生跨域访问。跨域问题导致的。
解决：
二、报错[@vue/compiler-sfc] &lt;script&gt; and &lt;script setup&gt; must have the same language type. 原因：在Uniapp + Vue2 项目升级到 Vue3+Ts时，如果&lt;script&gt;使用了setup语法糖，则无法用export default 导出 App.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ace46c57ae64084a4f3d9dd7ecfd633e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf742c1bbd87fa5cdfcef628e59a1d8d/" rel="bookmark">
			SQL进阶理论篇（十）：数据库中的锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介按照锁的粒度进行划分从数据库管理的角度进行划分从程序员的角度进行划分为什么共享锁会发生死锁？参考文献 简介 索引和锁，是数据库中的两个核心知识点。
索引的相关知识点，在之前的几章里我们已经介绍的差不多了。接下来我们会重点讲解一下锁的相关知识。
事务的隔离级别，在底层就是通过锁来实现的。而加锁的目的，就是为了保证数据的一致性。
本节我们将重点描述以下几个问题：
锁有哪些划分方式？为什么共享锁会发生死锁？乐观锁和悲观锁的思想是什么？乐观锁有哪两种实现方式？多个事务并发，发生死锁时该如何解决？如何降低死锁发生的概率？ 按照锁的粒度进行划分 锁是用来对数据进行锁定的。我们可以根据被锁定对象的粒度大小来对锁进行划分，即：行锁、页锁和表锁。
行锁，按照行粒度对数据进行锁定。由于锁定力度小，所以发生锁冲突的概率低，理论上可以实现的并发度很高。但是按行加锁，对资源的消耗太大了，而且加锁也比较慢，容易出现死锁现象。
页锁，就是在页的粒度上对数据进行锁定。因为一个页上可以有很多数据行，所以在使用页锁的时候，很容易会出现数据浪费的情况（即使只是想锁小部分数据，也得锁上一整页），但是这种浪费有限，顶多就是浪费个几页。页锁的开销介于行锁和表锁之间，会出现死锁，并发度一般。
表锁，就是对数据表进行锁定。其锁定粒度很大，出现锁冲突的概率也很高，对并发的影响较大。好处是加锁的开销小，加锁很快。
以上三类锁是数据库中相对常见的三种锁，除此之外其实还有区锁和数据库锁，分别针对区和数据库的粒度。
不同的数据库或者不同的引擎支持的锁粒度并不相通。以MySQL为例，InnoDB支持行锁和表锁，但MyISAM只支持表锁，BDB引擎则支持页锁和表锁。Oracle支持行锁和表锁，SQLServer同时支持行锁、页锁和表锁。教程里整理的图如下：
需要注意，在实际使用中，每个层级的锁数量是有限的，因为锁会占用内存空间，所以锁空间的大小是有限的。
当某个层级的锁数量超过了这个层级的阈值时，就会进行 锁升级。所谓的锁升级，就是将多个细粒度的锁升级成一个更大粒度的锁。比如说在InnoDB中，将多个行锁换成一个表锁，从而减少锁空间的内存占用，当然，代价是并行度降低了。
从数据库管理的角度进行划分 从数据库管理的角度来划分的话，就是我们经常会见到的两种锁：共享锁和排它锁。
共享锁，也叫做读锁或者S锁。共享锁锁定的数据可以被其他事务读取，但是不能修改。
在进行select的时候，就会把对象进行共享锁锁定，待到数据读取完毕后，才释放共享锁。这样子可以保证数据在读取时不会被修改。
我们也可以手动给某个对象加锁。
比如说给一个表加共享锁，可以使用：
LOCK TABLE product_comment READ; 这时候这张表就是只读模式了，如果此时再执行update语句，会提示：
ERROR 1099 (HY000): Table 'product_comment' was locked with a READ lock and can't be updated 解锁的话，可以使用：
UNLOCK TABLE product_comment; 如果是想给某一行加上共享锁，则可以写成这样：
SELECT comment_id, product_id, comment_text, user_id FROM product_comment WHERE user_id = 912178 LOCK IN SHARE MODE 排它锁，也叫做独占锁、写锁或者X锁。其锁定的数据只允许进行锁定的事务使用，其他事务无法对已锁定的数据进行读取或者修改。
比如给一个表添加排它锁，可以这么写：
lock table product_comment write; 此时，其他事务就不能在这张表上读或者更新了，有兴趣可以开两个MySQL客户端试一下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf742c1bbd87fa5cdfcef628e59a1d8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aac683120120c9fc4525ad0b4c8bca5/" rel="bookmark">
			Linux下I2C调试工具--for--Zynq MPSOC/Jetson Xavier
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下I2C调试工具 1、简介 i2c-tools是一个专门调试i2c的工具，无需编写任何代码即可轻松调试I²C设备，可获取挂载的设备及设备地址，还可以在对应的设备指定寄存器设置值或者获取值等功能。i2c-tools有如下几个常用测试命令i2cdetect, i2cdump, i2cget, i2cset,i2ctransfer。
2、i2c-tools工具安装 2.1、Jetson xavier/orin下安装
sudo apt-get install libi2c-dev i2c-tools 2.2、Zynq MPSOC下安装
使用如下命令勾选i2c-tools工具：
使用petalinux 进入文件系统
petalinux-config -c rootfs 进入Filesystem Packages
进入base
进入i2c-tools
勾选i2c-tools工具
重新编译系统
petalinux build 3、i2c-tools工具使用
3.1、i2cdetect
功能：用于检测SOC设备上的i2c总线数量和挂载在i2c总线上的器件。
命令：i2cdetect -l
命令：i2cdetect -r -y 0 //检测i2c-0的挂载情况
3.2、i2cdump
功能：dump i2c设备中所有的数据。
i2cdump -f -y 0 0x1e b 用i2cdump查看挂载在i2c 0 总线上器件地址为0x1e的所有寄存器值
3.3、i2cget
功能：获取指定i2c设备中指定地址的数据．
命令：i2cget -f -y 0 0x1b 0x02 //显示I2C 0号总线上0x1b设备0x02寄存器地址，按字节读取
3.4、i2cset
功能：设置指定i2c设备中指定地址的数据。
命令：i2cget -f -y 0 0x1b 0x20 0x01 //设置I2C 0号总线上0x1b设备0x20寄存器地址的值为0x01
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1aac683120120c9fc4525ad0b4c8bca5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbeabd52fbe49612604e86d998d800aa/" rel="bookmark">
			细胞培养——细胞传代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要涉及到的溶液有四种：
DMSO+细胞培养液的冷冻液（1：9的DMSO和细胞培养液，e.g. 0.4mL DMSO + 3.6mL 细胞培养液）细胞培养液（10%胎牛血清，1%青链霉素）PBS（磷酸盐缓冲液）胰蛋白酶 x.1 细胞孵化（以A594为例） 细胞存储在容量为1mL的冷冻管内（管内装有DMSO甘油和细胞营养液），放在液氮中低温保存（-80度）。
戴好手套，取出液氮中保存的细胞，放进到37度水中水浴加热，等到无菌管内冰块融化。
从冰箱中取出装有细胞培养液的试管，用酒精消毒手套和试管后，将试管放置到细胞培养箱等待15min，等到细胞培养液恢复到37度的合适温度。
关闭超净台的杀菌，打开照明，打开通风，带好手套，每次将手伸入细胞培养箱和超净台时候都需要将手套和器具用酒精消毒。
在超净台中，将1mL冷冻管内细胞移至细胞培养瓶中（可以分装，仍然按照1：7或者1：8的配比加入细胞培养液），加入7-8mL细胞营养液（why？），放入到37度+5%CO2的细胞培养箱中培养4h，等待细胞贴壁完成（用显微镜观察）。
细胞贴壁后，倒掉细胞培养瓶中的细胞营养液（因为DMSO对细胞有毒），加入4mL细胞营养液培养2天左右后进行传代，在瓶子上记录好时间，并记录第一代。
将瓶子放入到细胞培养箱中培养。将超净台的废液和用完的物品丢弃，将纸喷上酒精后，从内向外擦拭；关闭通风，照明，打开杀菌，将超净台玻璃关上。
x.2 细胞传代 等待2天-7天。戴好手套，对手套消毒后，取出细胞培养箱中的上一次传代的亲代细胞，在显微镜下观察细胞是否已经大量贴壁，如果已经大量贴壁则进行传代。
戴好手套，从冰箱中取出PBS，细胞培养液，胰蛋白酶，对试管和手套消毒后，将试管放到细胞培养箱中等待15min左右等待液体恢复到37摄氏度。
关闭超净台的杀菌，打开照明，打开通风，带好手套，每次将手伸入细胞培养箱和超净台时候都需要将手套和器具用酒精消毒。
消毒，将需要的试管和装有亲代细胞的细胞培养皿取出，放入超净台中，晃一晃细胞培养皿（把死细胞晃散），将亲代细胞中的细胞培养液全部倒掉。
加入2mL的PBS（为了将培养液去除，细胞培养液和胰蛋白酶是相冲的），晃一晃后将PBS倒掉。
加入1~2mL的胰蛋白酶，s.t. 贴壁细胞完全覆盖，将细胞培养皿放入到恒温培养箱中等待2min（这个步骤需要快速，为了让80%的贴壁细胞还有小尾巴粘在培养皿上悬浮，20%细胞完全脱离）。
取出培养皿，用显微镜观察，如果80%细胞仍然贴壁且悬浮，则直接进行下一步，如果有大量细胞完全脱离，则进行下面的补救措施。
假设：前面加入的是2mL的胰蛋白酶，则此步溶液的全部体积为2mL。 取出上清液1mL，1mL，分别加入到离心管中，离心装置需要成对配比旋转。 将离心管以500rpm，25摄氏度旋转5min。 取出离心管，丢弃上清液后，加入1mL细胞培养液，摇晃离心管使得沉淀的细胞溶解。 将2mL全部的溶液加入到细胞培养皿中，摇晃均匀后，再按需求（如每1mL）装到原细胞培养皿中。 如果没有大量细胞完全脱离，则将细胞培养皿中的胰蛋白酶溶液全部倒掉后，再加入4mL细胞培养液，使用5mL枪管或者移液枪将培养液吸起来后，先用力击打瓶壁（s.t. 贴壁细胞下来），再用力击打瓶底三四次（s.t. 打散），在显微镜下观察，直到细胞全部悬浮后，去除头0.5mL和尾0.5mL，再从中取1mL的细胞培养液分别封装到3-4个细胞培养皿中，再加入3mL的细胞培养液，使得每一个细胞培养皿中的总容量为4mL；在细胞培养皿上记录时间和传代次数。
将细胞培养皿存放到恒温培养箱中进行培养2天后再传代。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c24f7fb18b42383908fcae0c2bcdfb6/" rel="bookmark">
			git教程（基于vscoede）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。也是Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。
1.打开vscode，创建文件夹gittest，在文件夹中创建文件test.txt，并在其中写入版本号v1.0；
2.在终端输入git version，确认是否已安装git，并随后设置自己的昵称和邮箱；
确认版本
git version 设置昵称
git config --global user.name "*****" 设置邮箱
git config --global user.email "****" 初始化
git init 确认状态
git status 3.存放文件（暂存和提交）；
暂存单个文件
git add test.txt 暂存当前文件夹下所有文件
git add . 提交
git commit 会在提交过程中打开一个vim文件记录你所修改的提交内容，wq后提交
查看提交信息
git log 提交说明简化版操作，通过-m后引号内内容进行描述
git commit -m "第二次提交" 4.回退版本，首先找到想要回退的版本的commit id，并复制进下述引号内；
git reset --hard "***" 5.想要在不同版本间切换，则使用branch，用下述代码完成0.2分支的创建；
git branch 0.2 使用checkout命令不断切换分支.切换到0.2分支；
git checkout 0.2 可以在分支进行开发后回到master进行合并merge，将0.2分支合并进master中；
git checkout master git merge 0.2 merge的作用可以令多个功能并行开发，节约时间；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c24f7fb18b42383908fcae0c2bcdfb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ccba232b69f673c313de81ae442e705/" rel="bookmark">
			2023NEFU实习项目解析 - 中俄贸易供需服务平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 项目概述项目初始化搭建项目初始框架配置Tomcat建立项目数据库编写统一返回类及其工具类编写数据库工具类通过Filter解决Response返回中文乱码问题使用Filter解决权限校验问题 项目主干开发用户登录企业管理（分页查询原生实现）上传VIP申请书模板（文件上传实现）VIP公司的更新操作国际采购管理模块 附：项目值得注意的技术点web.xml文件Jquery&lt; base &gt;：文档根 URL 元素文件上传 附：项目过程中的思考为什么mysql的驱动要使用Class.forName动态加载？ 附：项目可改进点README 项目概述 完成一个中俄贸易服务供需平台后台管理端的后端部分，是一个原生的Javaweb项目，使用到servlet、jsp、jdbc等技术。
大致分为9个模块：
VIP企业管理：
普通企业管理：
国际采购管理
国际供应管理
国际物流管理
新闻资讯管理 新闻资讯
外贸助手
关于我们
首页管理
统计分析
每个模块的大致技术方案：
项目初始化 搭建项目初始框架 直接创建一个Maven的web项目，然后把前端现成的东西塞进去
配置Tomcat 配置Tomcat的过程可以参考我的另一篇文章：
IDEA中使用Tomcat
注意JDK版本与Tomcat的兼容性
注意为了提高效率我们要配置tomcat的热重载：
最后要以Debug模式运行
但是html的修改还是要重启服务器！
建立项目数据库 把提前准备好的sql语句放在项目的sql文件夹下，然后配置一下项目的数据源，确认所用的数据库，执行即可：
编写统一返回类及其工具类 每次返回的时候无需单独构造结果类，更加方便我们返回结果：
@Data @AllArgsConstructor @NoArgsConstructor public class ResultMsg&lt;T&gt; implements Serializable { private int code; private T obj; private String message; public ResultMsg(int code, T obj) { this(code, obj, ""); } } 工具类：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ccba232b69f673c313de81ae442e705/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35e99264bb65134b2fddfe460190c99e/" rel="bookmark">
			基于多智能体系统一致性算法的电力系统分布式经济调度策略MATLAB程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微❤关注“电气仔推送”获得资料（专享优惠）
参考文献：
主要内容：
应用多智能体系统中的一致性算法，以发电机组的增量成本和柔性负荷的增量效益作为一致性变量，设计一种用于电力系统经济调度的算法，通过分布式优化的方式求解经济调度问题。
程序完全采用论文中的数据，对论文中的4种场景进行了复现。
场景1 验证了该分布式调度算法与集中式调度算法一样，能收敛到最优解；
场景2 验证了该分布式调度策略对不同通信拓扑的适应性；
场景3 验证了该分布式调度策略能够有效应对电力元件功率约束发生作用的情形；
场景4 验证了该分布式调度策略能够使电力元件具备“即插即用”的能力。
部分程序：
%迭代%
l=[li lj];
ll=zeros(801,29);
ll(1,:)=l;
dp=zeros(1,801);
dp(1)=spd(1)-spg(1);
pgg=zeros(801,10);
pgg(1,:)=pg;
pdd=zeros(801,19);
pdd(1,:)=pd;
for t=1:1:800
for n=1:1:29 %更新lambda的值
if n==1
ll(t+1,n)=sum(a(n,:).*ll(t,:))+0.005*dp(t);
elseif n==11
ll(t+1,n)=sum(a(n,:).*ll(t,:))+0.005*dp(t);
else
ll(t+1,n)=sum(a(n,:).*ll(t,:));
end
end
for i=1:1:10 %判断pg是否越限并赋值
if (ll(t,i)-be(i))/(2*ga(i))&gt;=pgmax(i)
pgg(t+1,i)=pgmax(i);
elseif (ll(t,i)-be(i))/(2*ga(i))&lt;=pgmin(i)
pgg(t+1,i)=pgmin(i);
else
pgg(t+1,i)=(ll(t,i)-be(i))/(2*ga(i));
end
end
for j=1:1:19 %判断pd是否越限并赋值
if (ll(t,j+10)-b(j))/(2*c(j))&gt;=pdmax(j)
pdd(t+1,j)=pdmax(j);
elseif (ll(t,j+10)-b(j))/(2*c(j))&lt;=pdmin(j)
pdd(t+1,j)=pdmin(j);
else
pdd(t+1,j)=(ll(t,j+10)-b(j))/(2*c(j));
end
end
spg(t+1)=sum(pdd(t+1,:));
spd(t+1)=sum(pgg(t+1,:));
dp(t+1)=sum(pdd(t+1,:))-sum(pgg(t+1,:));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35e99264bb65134b2fddfe460190c99e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9016878b9af8a6eb048e1be34df9ee7a/" rel="bookmark">
			地平线前端实习一面复盘（加深对var的理解&#43;展开运算符&#43;平拍数组）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一，var的作用二，展开运算符三，平拍数组总结 前言 地平线的面试，有提示，很专业，体验很好。
可惜后面未收到消息，但还是要做复盘。收获还是很大的。
一，var的作用 且看下面五个题目：
// 题目1---4 function test(a) { a = 3 } var a = 4 test(a) console.log(a) // 题目2---4 function test(a) { var a = 3 } var a = 4 test(a) console.log(a) // 题目3---3 function test() { a = 3 } var a = 4 test(a) console.log(a) // 题目4---4 function test() { var a = 3 } var a = 4 test(a) console.log(a) 上面这五个题目，实则是对var的考察。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9016878b9af8a6eb048e1be34df9ee7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8985e54e885f8c2289c14d3453d933b7/" rel="bookmark">
			【idea】解决sprintboot项目创建遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、报错Plugin ‘org.springframework.boot:spring-boot-maven-plugin:‘ not found
二、报错java: 错误: 无效的源发行版：17
三、java: 无法访问org.springframework.web.bind.annotation.CrossOrigin
四、整合mybatis的时候，报java.lang.IllegalArgumentException: Unable to instantiate org.mybatis.spring.boot
一、报错Plugin ‘org.springframework.boot:spring-boot-maven-plugin:‘ not found 报错：在使用Maven下载相关包时，出现错误Plugin ‘org.springframework.boot:spring-boot-maven-plugin:‘ not found
原因：无法识别使用哪个版本的 spring-boot-maven-plugin 包。
plugin在maven里需要专门的配置，没有配置的时候就会去普通仓库里找，但是plugin不是maven家的，所以找不到，对于这个情况呢，阿里有一个仓库可以下载这个，但是需要在settings.xml里进行配置。
解决方法：
在你maven安装地址里面的conf文件夹下面有一个settings.xml文件，右击pom.xml文件，选择maven，选择“open settings.xml ”可以快速打开这个文件。
对这个settings.xml文件添加下列代码，
&lt;profile&gt; &lt;id&gt;spring plugins&lt;/id&gt; &lt;activation&gt; &lt;jdk&gt;spring plugins&lt;/jdk&gt; &lt;/activation&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring plugins&lt;/id&gt; &lt;name&gt;Spring plugins&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/spring-plugin&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshotPolicy&gt;always&lt;/snapshotPolicy&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; 保存settings.xml文件，退出。
在pom.xml文件中，使用 &lt;pluginManagement&gt; 标签管理插件。具体做法是在原来的 &lt;plugins&gt; 标签外层增加 &lt;pluginManagement&gt; 标签，如下所示。
二、报错java: 错误: 无效的源发行版：17 原因：POM文件中配置的JDK版本信息 与 "Project Structure" 窗口配置的JDK版本 不一致。
比如在本案例中，POM文件配置的JDK版本为17，而Project Structure"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8985e54e885f8c2289c14d3453d933b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48a1774a4c8a65c15334f9ca464e288e/" rel="bookmark">
			PADS9.5 : 原理图网表导出 及 PCB 网表导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原理图网表导出 PCB 网表导入 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb76cebba8d7b2bb9cddefc20b2d20f0/" rel="bookmark">
			PADS9.5 : 原理图电源网络 和 地网 络添加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理图电源网络 和 地网 络添加 添加电源网络 1、点击连线
2、2、连线
3、3、连线时，右键
4、4、点击电源，因为该网络已经有3.3v，它会弹出网络确认，确定即可，如果 需要其他电源网络，双击即可修改
5、双击 修改网络
添加电源网络 同理 右键选择 接地
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45cb3166ccc5ea3145954192a085092f/" rel="bookmark">
			PADS9.5 : 原图绘图图纸尺寸下修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原图绘图图纸尺寸下修改 图页边界线也要修改
如果二者选择不一致：
会出现下图所示情况：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2c4fd782bbb93690a202a6dcdf3fca9/" rel="bookmark">
			excel手撕BP神经网络（只需高中数学基础）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		神经网络最基础部分是由神经元组成，一个神经元相当于是一个一次函数，y=ax+b
即在已知x，和y情况下，怎么使用神经网络求解a和b
如下是使用excel求解的神经网络，可以方便理解神经网络运行原理
excel BP神经网络下载地址
0 excel数据及任务 构造了如下数据，x0,x1,x2和y_true。其中x0,x1,x2对应真实wTrue(w0,w1,w2)如表格所示（表格数据都可以修改，公式已经编辑好），
即 y=x0 * wt0 + x1 * wt1 + x2 * wt2任务；需要使用神经网络计算出真实的w 1 神经网络求解步骤： 已知 x 和y
1 随机初始化wi
初始化w全为0, w00=0,w01=0,w02=0 （为了简化，只考虑w,不考虑b）2 将x带入 a和b参数函数，得到y的预测值y_pred
y_pred=x0w00+x1w01+x2*w023 将预测y_pred与真实值y进行对比，构建损失函数（刚开始，随机的w误差肯定很大）
loss= ( y _ p r e d − y _ t r u e ) 2 (y\_pred-y\_true)^2 (y_pred−y_true)24 对损失函数求导，使用梯度下降更新参数w.
导数
w00导数：dy_dw00: 2*(y_pred-y_true)x0
w01导数：dy_dw01: 2(y_pred-y_true)x1
w02导数：dy_dw02: 2(y_pred-y_true)*x2
步长：lr=0.001
新的 w00= w00-lr * dy_dw00
新的 w01= w01-lr * dy_dw01
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2c4fd782bbb93690a202a6dcdf3fca9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42ef7c26dbffe83d166337ebfc50277e/" rel="bookmark">
			屏幕超时休眠-Android13
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		屏幕超时休眠-Android13 1、设置界面1.2 属性值1.2.1 默认值1.2.2 最小值限制 1.3 属性值疑问 Settings.System.SCREEN_OFF_TIMEOUT 2、超时灭屏2.1 锁定屏幕的超时2.2 屏幕灭屏的超时 3、永不休眠* 关键日志 1、设置界面 packages/apps/Settings/src/com/android/settings/display/ScreenTimeoutSettings.java
packages/apps/Settings/res/xml/screen_timeout_settings.xml
12-16 12:13:54.707 7976 7976 D SettingsActivity: Switching to fragment com.android.settings.display.ScreenTimeoutSettings 1.2 属性值 Settings.System.SCREEN_OFF_TIMEOUT
adb shell settings get System screen_off_timeout packages/apps/Settings/res/values/arrays.xml
&lt;!-- Display settings. The delay in inactivity before the screen is turned off. These are shown in a list dialog. --&gt; &lt;string-array name="screen_timeout_entries"&gt; &lt;item&gt;15 seconds&lt;/item&gt; &lt;item&gt;30 seconds&lt;/item&gt; &lt;item&gt;1 minute&lt;/item&gt; &lt;item&gt;2 minutes&lt;/item&gt; &lt;item&gt;5 minutes&lt;/item&gt; &lt;item&gt;10 minutes&lt;/item&gt; &lt;item&gt;30 minutes&lt;/item&gt; &lt;/string-array&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42ef7c26dbffe83d166337ebfc50277e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5616c085c1048113a478d684864c2c7/" rel="bookmark">
			Matlab下地形图绘图包m_map安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		〇、引言 m_map是Matlab下用于绘制地图（地形图）的工具箱，和GMT有些相似。
1. 文档 m_map官网：https://www.eoas.ubc.ca/~rich/mapug.html
用法可以参考百度文库中的官网翻译版：M_Map1.4用户指南
https://wenku.baidu.com/view/32b9c4c8d4d8d15abf234e06.html
也可以参考CSDN这位老兄的翻译版：m_map中文文档
https://blog.csdn.net/good_learner_1/article/details/88767974?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-3&amp;spm=1001.2101.3001.4242
2. 推荐教程 再推荐本人写的几个详细教程：
m_map绘制晕渲（shaded relief）地形图m_map绘图包绘制高分辨率海岸线、国界线与河流m_map绘图之添加线段比例尺函数m_rulerm_map如何绘制矩形等距投影图m_map绘制点、线m_map绘图添加遥感图片m_map导入本地地形数据m_map绘制多波束数据 一、官网绘图展示 二、下载与安装 1. 下载 进入m_map官网：https://www.eoas.ubc.ca/~rich/mapug.html
下载tar压缩文件或者zip压缩文件。
2. 安装 将m_map工具包解压后放在matlab的toolbox中，添加路径即可。
对matlab不了解的话，可参考：M_Map绘图笔记——安装（一）
https://blog.csdn.net/wokaowokaowokao12345/article/details/88354118
三、高分辨率地形与海岸线数据加载 m_map自带的底图数据分辨率只有1°，较低，在绘制区域地形图时分辨率无法满足要求，需要额外加载高分辨率的地形数据。如下：
1. 高分辨率海岸线数据文件下载 从NOAA官网下载1分（1’）分辨率的海岸线数据： https://www.ngdc.noaa.gov/mgg/shorelines/gshhs.html
下载二进制（bin）格式的zip压缩文件：
2. 高分辨率地形数据文件下载 从NOAA官网下载1分（1’）分辨率的地形数据 https://www.ngdc.noaa.gov/mgg/global/relief/ETOPO1/data/ice_surface/grid_registered/binary/
有32位浮点型（4字节），即f4，和16位整型（2字节），即i2两种格式。推荐选第二种：i2。 3. 数据解压 下载好这两个数据后分别解压，建议放在matlab的安装目录下，我在matlab的安装目录下新建了一个work文件夹，再把下载的m_map文件解压后放在work目录下。然后，在m_map目录下建立了etopo1和coastline文件夹（文件名随便起），本别放置地形数据和海岸线数据。
4. 路径设置 然后需要设置二者（1分的地形与海岸线数据）的路径，才可以自动调用。打开以下m文件m_etopo2.m：
把其中的
PATHNAME='/ocean/rich/more/mmapbase/etopo1/'; 改成自己的地形数据放置路径，比如我的是/m_map/etopo1/：
PATHNAME='D:/install/MATLAB2019a/work/m_map/etopo1/'; 这样，地形数据路径就设置好了。
同理，打开m_gshhs.m，将路径改为自己的海岸线数据放置路径，比如我的是/m_map/coastline/：
FILNAME='D:/install/MATLAB2019a/work/m_map/coastline/'; 到此安装就大功告成！！！
四、用法 1. 设置投影方式 m_proj(‘mercator’); 2. 查看投影方式类别 m_proj(‘set’); 3. 如何选择投影方式 全球：
m_proj(‘mercator’); m_proj(‘miller’); m_proj(‘hammer’); m_proj(‘Mollweide’); 国家：
m_proj(‘robinson’); 纬度跨度大，经度跨度小：
m_proj(‘sinusoidal’); m_proj(‘Mollweide’); 小区域（如地中海，中国）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5616c085c1048113a478d684864c2c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa8225af4a3b17ee149a33182e29e3a5/" rel="bookmark">
			Pytorch中的contiguous问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在有的程序中，如果对view、transpose、permute等维数变换操作不恰当，就容易引起
"RuntimeError: : dimension must be contiguous"的错误。在连续性中，有两个常用方法，x=x.contiguous()使一个tensor变连续；x.is_contiguous()是检查x内存是否连续，准确地讲是检查内存排列顺序与以行优先的内存排列顺序是否一致，如果一致则返回True，否则返回False。什么意思呢？我们首先来看个例子：
x = torch.tensor([[1,2,3,4],[5,6,7,8]]) output： tensor([[1, 2, 3, 4], [5, 6, 7, 8]]) 那在计算机内存中是如何存储这个矩阵的呢？它是以行展开成一维数组进行存储，称为"按行优先" ，这
与C和C++的存储方式一致，而有的程序就是"按列优先"如matlab。现在，我们按行优先拉直这个矩阵，
x = x.flatten() output: tensor([1, 2, 3, 4, 5, 6, 7, 8]) 这就是内存存储方方式。如果我们要访问这个矩阵的下一个元素，则偏移一个单位就可以了，这个偏移量
我们称为步长(stride=1),但如果是“按列优先”，则stride就不等于1了，因为：
y = x.t()#相当于将x按列优先存储 output: tensor([[1, 5], [2, 6], [3, 7], [4, 8]]) 同样，拉直矩阵有：
y = y.flatten() output： tensor([1, 5, 2, 6, 3, 7, 4, 8]) 这个时候，如果"按列优先"存储，则矩阵访问下一元素也就2，其步长stride=2对内存方法有一个初步了解之后，我们现在来看一下is_contiguous到底在检查什么？
x = torch.tensor([[1,2,3,4],[5,6,7,8]]) output： tensor([[1, 2, 3, 4], [5, 6, 7, 8]]) #检查连续性 x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa8225af4a3b17ee149a33182e29e3a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef94de4972e420a507b8721aaefd3231/" rel="bookmark">
			sass/scss 浅谈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、了解 sass
1、特点
2、语法格式
二、Sass 的语法
1、嵌套
（1）、最简单的嵌套实例
（2）、父选择器——&amp; 符
（3）、属性嵌套
（4）、占位符选择器 %foo
2、注释
（1）、多行注释 /* */ 与 单行注释 //
（2）、! 符 —— 压缩输出模式下保留的注释
（3）、注释中使用插值语句输出变量值
3、SassScript——变量、运算
（1）、$ 符 —— 变量
（2）、数据类型
（3）、运算
（4）、圆括号
（5）、 &amp; 在 SassScript 中
（6）、变量定义 !default
4、函数
（1）、最简单的 SassScript 函数
（2）、带参数变量的 SassScript 函数
（3）、函数中使用 插值表达式 #{}
（4）、自定义 Sass 函数——函数指令 @function
5、@-Rules 与指令
（1）、@import —— 导入文件
（2）、@media —— 媒体查询
（3）、@extend —— 继承（难点）
（4）、@at-root
（5）、@debug（了解）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef94de4972e420a507b8721aaefd3231/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65e559bd222218e0f478396cea66b321/" rel="bookmark">
			linux笔记--VSCode利用交换机跳转服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1--前言
2--VSCode设置
3--ssh连接
1--前言 博主学校的服务器有两个，其中一个服务器（14）可以通过挂内网VPN来进行连接，但另一个服务器（15）即使挂了VPN也不能连接，只能通过内网进行连接。
当不在学校时，就无法顺利连接服务器（15），可以通过将服务器（14）设置为跳转机，通过服务器（14）来间接连接服务器（15）；
2--VSCode设置 VSCode SSH设置：
Host JumpMachine # 跳板机的ip地址 HostName ip_A # 你跳板机的用户名 User user_A # 跳板机登录端口 Port port_A Host TargetMachine # 目标机的ip地址 HostName ip_B # 你目标机的用户名 User user_B # 目标机登录端口 Port port_B ProxyCommand C:\Windows\System32\OpenSSH\ssh.exe -W %h:%p JumpMachine 设置实例：通过 172.25.73.14 服务器来间接连接服务器 172.25.73.15；
Host JumpMachine HostName 172.25.73.14 Port 22 User liujinfu Host TargetMachine HostName 172.25.73.15 Port 50122 User liujinfu ProxyCommand ssh -W %h:%p JumpMachine 3--ssh连接 只需在 VSCode 按正常操作来连接服务器 TargetMachine，就可以顺利跳转；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65e559bd222218e0f478396cea66b321/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cab41f6aa4e2bc3c8f93cb7a17e7f643/" rel="bookmark">
			Spring Boot 创建你自己的自动配置中文文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为官方文档直译版本。原文链接
Spring Boot 创建你自己的自动配置中文文档 引言了解自动配置 Bean查找自动配置候选对象条件注释Class ConditionsBean ConditionsProperty ConditionsResource ConditionsWeb Application ConditionsSpEL Expression Conditions 测试你的自动配置模拟Web Context覆盖 Classpath 创建你自己的 Starter命名配置 keysautoconfigure 模块Starter 模块 引言 如果您在开发共享库的公司工作，或者如果您在开发开源或商业库，您可能想开发自己的自动配置。自动配置类可以捆绑在外部 jar 中，但仍会被 Spring Boot 接收。
自动配置可以与 “starter” 相关联，“starter” 提供自动配置代码以及与之配合使用的典型库。我们首先介绍构建自己的自动配置所需的知识，然后介绍创建自定义启动器所需的典型步骤。
了解自动配置 Bean 实现自动配置的类用 @AutoConfiguration 进行注解。该注解本身用 @Configuration 元注解，使自动配置成为标准的 @Configuration 类。附加的 @Conditional 注解用于限制何时应用自动配置。通常，自动配置类使用 @ConditionalOnClass 和 @ConditionalOnMissingBean 注解。这样可以确保自动配置仅在找到相关类且未声明自己的 @Configuration 时才会应用。
您可以浏览 spring-boot-autoconfigure 的源代码，查看 Spring 提供的 @AutoConfiguration 类（参见 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件）。
查找自动配置候选对象 Spring Boot 会检查发布的 jar 中是否存在 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件。该文件应列出配置类，每行一个类名，如下例所示：
com.mycorp.libx.autoconfigure.LibXAutoConfiguration com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration 您可以使用 # 字符为导入文件添加注释。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cab41f6aa4e2bc3c8f93cb7a17e7f643/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2bdd091634fa7cfd2e05a5ff5585ab3/" rel="bookmark">
			v-bind in vue style
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem example I find an example in a book, it display how to use v-bind in the style section, the code is like below:
h1 { margin-top: v-bind(headingStyles.marginTop); text-align: v-bind(headingStyles.textAlign); color: v-bind(headingStyles.color); } Vue Example But it has compile error, after look into the example in the Vue document v-bind() in CSS
The example is like below:
&lt;template&gt; &lt;div class="text"&gt;hello&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { color: 'red' } } } &lt;/script&gt; &lt;style&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2bdd091634fa7cfd2e05a5ff5585ab3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06ce144cd180ecd01dac1953cdca44e3/" rel="bookmark">
			2机5节点系统潮流MATLAB仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微❤关注“电气仔推送”获得资料（专享优惠）
电力系统潮流计算是电力系统最基本的计算，也是最重要的计算。所谓潮流计算，就是已知电网的接线方式与参数及运行条件，计算电力系统稳态运行各母线电压、各支路电流、功率及网损。对于正在运行的电力系统，通过潮流计算可以判断电网母线电压、支路电流和功率是否越限，如果有越限，就应采取措施，调整运行方式。对于正在规划的电力系统，通过潮流计算，可以为选择电网供电方案和电气设备提供依据。潮流计算还可以为继电保护和自动装置整定计算、电力系统故障计算和稳定计算等提供原始数据。
主体仿真模型：
仿真结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b57078031562252863137d051c694e5/" rel="bookmark">
			手写Promise
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class P { // 定义promise的三个静态属性 static pedding = 'pedding'; static fulfilled = 'fulfilled'; static rejected = 'rejected'; constructor(fn) { // 初始状态为pedding this.status = P.pedding; // 返回的结果先定义为null，随后要进行赋值 this.result = null; // 为了解决异步的 this.successCallback = []; this.failedCallback = []; // 利用错误捕获，实现throw err的功能 try { // 利用bind绑定this, 解决this丢失的问题 fn(this.resolve.bind(this), this.reject.bind(this)); } catch (error) { this.reject(error); } } resolve(result) { setTimeout(() =&gt; { if (this.status === P.pedding) { this.status = P.fulfilled; this.result = result; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b57078031562252863137d051c694e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/253a911c4a0868d69cc17e93404d1624/" rel="bookmark">
			setlocale(LC_ALL,““) 中的 LC_* 是什么意思，以及 LANGUAGE/LANG 都是些啥？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这些都是个啥？ 上面提到的种种，实际上都是 区域 设置相关的东西，因此今天我们所提到的东西都和区域有关。
首先 setlocale(...) 是啥？ setLocale(...) 是C库中的一个设置地域化信息的C函数。
函数原型为：
char *setlocale(int category, const char *locale) 参数解释：
category – 这是一个已命名的常量，指定了受区域设置影响的函数类别，可以设置为以下值。
LC_ALL // 包括下面的所有选项。
LC_COLLATE // 字符串比较。参见 strcoll()。
LC_CTYPE // 字符分类和转换。例如 strtoupper()。
LC_MONETARY // 货币格式，针对 localeconv()。
LC_NUMERIC // 小数点分隔符，针对 localeconv()。
LC_TIME // 日期和时间格式，针对 strftime()。
LC_MESSAGES // 系统响应。
locale – 如果 locale是 NULL 或空字符串 ""，则区域名称将根据环境变量值来设置，其名称与上述的类别名称相同。
一般程序遇到编码方面的问题，百度都会告诉你设置setlocale(LC_ALL,"")来解决，下面我们就了解一下这句代码做了什么.
LC_ALL，LE_* 又是个啥？ 实际上 LC_ALL，LE_* 是 区域 相关的环境变量。简而言之，LC_COLLATE，LC_TYPE等等都是环境变量。
很多程序的运行行为在全球不同的地域、语言环境中是不一样的，例如Linux 中的 date命令的行为就受LC_TIME的影响：
$ LC_TIME=en_US.UTF-8 date Fri Oct 31 19:51:16 CST 2014 $ LC_TIME=fi_FI.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/253a911c4a0868d69cc17e93404d1624/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0500887b45c26444af60352960cfbab8/" rel="bookmark">
			LANG,LC_ALL,locale详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		locale 是国际化与本土化过程当中的一个很是重要的概念，我的认为，对于中文用户来讲，一般会涉及到的国际化或者本土化，大体包含三个方面：看中文，写中文，与 window中文系统的兼容和通讯。从实际经验上看来，locale的设定与看中文关系不大，可是与写中文，及window分区的挂载方式有很密切的关 系。本人认为就像一个纯英文的Windows可以浏览中文，日文或者意大利文网页同样，你不须要设定locale就能够看中文。那么，为何要设定 locale呢？何时会用到locale呢？
Tags: locale 设定 缘由 解释
1、为何要设定locale 正如前面我所讲的，设定locale与你可否浏览中文的网页没有直接的关系，即使你把locale设置成 en_US.ISO-8859-1这样一个标准的英文locale你照样能够浏览中文的网页，只要你的系统里面有相应的字符集（这个都不必定须要）和合适 的字体（如simsun），浏览器就能够把网页翻译成中文给你看。具体的过程是网络把网页传送到你的机器上以后，浏览器会判断相应的编码的字符集，根据网 页采用的字符集，去字体库里面找合适的字体，而后由文字渲染工具把相应的文字在屏幕上显示出来。
在下文本人会偶尔把字符集比喻成密码本，我的以为对于一些东西比较容易理解，假如你不习惯的话，把全文copy到任何文本编辑器，用字符集替换密码本便可。
那有时候网页显示乱码或者都是方框是怎么回事呢？我的认为，显示乱码是由于设定的字符集不对(或者没有相应的字符集)，例如网页是用UTF-8编码的，你 非要用GB2312去看，而系统根据GB2312去找字体，而后在屏幕上显示，固然是一堆的乱码，也就是说你用一个错误的密码本去翻译发给你的电报，固然 内容那叫一个乱；至于有些时候浏览的网页能显示一部分汉字，但有不少的地方是方框，可以显示汉字说明浏览器已经正确的判断出了网页的编码，并在字体库里面 找到了相应的文字，可是并非每一个字体库都包含某个字符集所有的字体的缘故，有些时候会显示不彻底，找一个比较全的支持较多字符集的字体就能够了。
既然我可以浏览中文网页，那为何我还要设定locale呢？
其实你有没有想过这么一个问题，为何gentoo官方论坛上中文论坛的网页是用UTF-8编码的（虽然你们一直强烈建议用GB2312编码），可是新浪 网就是用GB2312编码的呢？而Xorg的官方网页居然是ISO-8859-15编码的，我没有设定这个locale怎么同样的能浏览呢？这个问题就像 是你有全部的密码本，不论某个网站是用什么字符集编码的，你均可以用你手里的密码本把他们翻译过来，但问题是虽然你能浏览中文网页，可是在整个操做系统里 面流动的仍是英文字符。因此，就像你能听懂英语，也能听懂中文。 最根本的问题是：你不能够写中文。
当你决定要写什么东西的时候，首先要决定的一件事情是用那种语言，对于计算机来讲就是你要是用哪种字符集，你就必须告诉你的linux系统，你想用那一 本密码本去写你想要写的东西。知道为何须要用GB2312字符集去浏览新浪了吧，由于新浪的网页是用GB2312写的。
为了让你的Linux可以输入中文，就须要把系统的locale设定成中文的(严格说来是locale中的语言类别LC_CTYPE )，例如 zh_CN.GB23十二、zh_CN.GB18030或者zh_CN.UTF-8。不少人都不明白这些古里古怪的表达方式。这个外星表达式规定了什么东 西呢？这个问题稍后详述，如今只须要知道，这是locale的表达方式就能够了。
2、到底什么是locale？ locale这个单词中文翻译成地区或者地域，其实这个单词包含的意义要宽泛不少。Locale是根据计算机用户所使用的语言，所在国家或者地区，以及当地的文化传统所定义的一个软件运行时的语言环境。
这个用户环境能够按照所涉及到的文化传统的各个方面分红几个大类，一般包括用户所使用的语言符号及其分类(LC_CTYPE)，数字 (LC_NUMERIC)，比较和排序习惯(LC_COLLATE)，时间显示格式(LC_TIME)，货币单位(LC_MONETARY)，信息主要是 提示信息,错误信息, 状态信息, 标题, 标签, 按钮和菜单等(LC_MESSAGES)，姓名书写方式(LC_NAME)，地址书写方式 (LC_ADDRESS)，电话号码书写方式 (LC_TELEPHONE)，度量衡表达方式(LC_MEASUREMENT)，默认纸张尺寸大小 (LC_PAPER)和locale对自身包含信息的概述(LC_IDENTIFICATION)。
因此说，locale就是某一个地域内的人们的语言习惯和文化传统和生活习惯。一个地区的locale就是根据这几大类的习惯定义的，这些 locale定义文件放在/usr/share/i18n/locales目录下面，例如en_US, zh_CN and de_DE@euro都是 locale的定义文件，这些文件都是用文本格式书写的，你能够用写字板打开，看看里边的内容，固然出了有限的注释之外，大部分东西可能你都看不懂，由于 是用的Unicode的字符索引方式。
对于de_DE@euro的一点说明，@后边是修正项，也就是说你能够看到两个德国的locale： /usr/share/i18n/locales/de_DE@euro /usr/share/i18n/locales/de_DE 打开这两个 locale定义，你就会知道它们的差异在于de_DE@euro使用的是欧洲的排序、比较和缩进习惯，而de_DE用的是德国的标准习惯。
上面咱们说到了zh_CN.GB18030的前半部分，后半部分是什么呢？大部分Linux用户都知道是系统采用的字符集。
3、什么是字符集？ 字符集就是字符，尤为是非英语字符在系统内的编码方式，也就是一般所说的内码，全部的字符集都放在 /usr/share/i18n/charmaps，全部的字符集也都是用Unicode编号索引的。Unicode用统一的编号来索引目前已知的所有的 符号。而字符集则是这些符号的编码方式，或者说是在网络传输，计算机内部通讯的时候，对于不一样字符的表达方式，Unicode是一个静态的概念，字符集是 一个动态的概念，是每个字符传递或传输的具体形式。就像 Unicode编号U59D0是表明姐姐的“姐”字，可是具体的这个字是用两个字节表示，三个字节，仍是四个字节表示，是字符集的问题。例如：UTF-8 字符集就是目前流行的对字符的编码方式，UTF-8用一个字节表示经常使用的拉丁字母，用两个字节表示经常使用的符号，包括经常使用的中文字符，用三个表示不经常使用的字 符，用四个字节表示其余的古灵精怪的字符。而GB2312字符集就是用两个字节表示全部的字符。须要提到一点的是Unicode除了用编号索引所有字符以 外，自己是用四个字节存储所有字符，这一点在谈到挂载windows分区的时候是很是重要的一个概念。因此说你也能够把Unicode看做是一种字符集 （我不知道它和UTF-32的关系，反正UTF-32就是用四个字节表示全部的字符的），可是这样表述符号是很是浪费资源的，由于在计算机世界绝大部分时 候用到的是一个字节就能够搞定的 26个字母而已。因此才会有UTF-8，UTF-16等等，要否则大同世界多好，省了这许多麻烦。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0500887b45c26444af60352960cfbab8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3a3c47c2b2c279a81db24b5e59e56cf/" rel="bookmark">
			webpack基本配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		const path = require('path'); const os = require('os'); const ESLintPlugin = require('eslint-webpack-plugin'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); const CssMinimizerPlugin = require('css-minimizer-webpack-plugin'); const TerserWbpackPlugin = require('terser-webpack-plugin'); const ImageMinimizerPlugin = require('image-minimizer-webpack-plugin'); const WorkboxPlugin = require('workbox-webpack-plugin'); const threads = os.cpus().length; // cpu核数 // 封装样式loader函数，获取处理样式的loader function getStyleLoader(pre) { return [ MiniCssExtractPlugin.loader, // 提取css成单独的文件 'css-loader', // 将css资源编译成commonjs的模块到js中 { loader: 'postcss-loader', options: { postcssOptions: { plugins: [ 'postcss-preset-env' // 能解决大多数样式兼容问题 ] } } }, pre ].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3a3c47c2b2c279a81db24b5e59e56cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7be2abaa26ee443ffba8ddde1125df0/" rel="bookmark">
			flatbuffer使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、定义scheme Tables FlatBuffers 中定义对象的主要方式，由名称和字段列表组成。每个字段都有一个名称、一个类型和一个可选的默认值。
如果架构中未指定默认值，则标量类型的默认值将为 0 ，其他类型的默认值将为 null 。
限制 只能在表定义的末尾在架构中添加新字段，如果您希望灵活地在架构中使用任何顺序的字段，您可以手动分配 id。无法从架构中删除不再使用的字段，但您可以简单地停止将它们写入数据中以获得几乎相同的效果。此外，您可以将它们标记为 deprecated如果您可以更改代码，则可以更改字段名称和表名称，直到您也在那里重命名它们为止。 Structs 与表类似，只是现在没有任何字段是可选的（因此也没有默认值），并且不能添加或弃用字段。结构体只能包含标量或其他结构体。将此用于您非常确定不会进行任何更改的简单对象。
结构比表使用更少的内存，并且访问速度更快
Types 内置类型
8 bit: byte (int8), ubyte (uint8), bool16 bit: short (int16), ushort (uint16)32 bit: int (int32), uint (uint32), float (float32)64 bit: long (int64), ulong (uint64), double (float64)
其中括号中的类型名称是别名 内置非标量类型：
[type]
string 只能保存 UTF-8 或 7 位 ASCII。对于其他文本编码或一般二进制数据，请使用向量 [byte]
一旦使用字段，您就无法更改它们的类型，但相同大小的数据除外
Array 数组是固定长度元素集合的便捷简写。
比如说： struct Vec3 { x:float; y:float; z:float; } 可以替换为： struct Vec3 { v:[float:3]; } 默认值、可选值和必需值 枚举 定义一系列命名常量，每个常量都有一个给定值，或者比前一个值增加 1。默认的第一个值为 0 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7be2abaa26ee443ffba8ddde1125df0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8973bdcf4677d7e2b65b708db243f0d3/" rel="bookmark">
			LeetCode：2276. 统计区间中的整数数目（TreeMap Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
2276. 统计区间中的整数数目
题目描述：
实现代码与解析：
TreeMap
原理思路：
2276. 统计区间中的整数数目 题目描述： 给你区间的 空 集，请你设计并实现满足要求的数据结构：
新增：添加一个区间到这个区间集合中。统计：计算出现在 至少一个 区间中的整数个数。 实现 CountIntervals 类：
CountIntervals() 使用区间的空集初始化对象void add(int left, int right) 添加区间 [left, right] 到区间集合之中。int count() 返回出现在 至少一个 区间中的整数个数。 注意：区间 [left, right] 表示满足 left &lt;= x &lt;= right 的所有整数 x 。
示例 1：
输入 ["CountIntervals", "add", "add", "count", "add", "count"] [[], [2, 3], [7, 10], [], [5, 8], []] 输出 [null, null, null, 6, null, 8] 解释 CountIntervals countIntervals = new CountIntervals(); // 用一个区间空集初始化对象 countIntervals.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8973bdcf4677d7e2b65b708db243f0d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d392c8a49de6bbd1e7ee0f19d5ed35/" rel="bookmark">
			SQL进阶理论篇（八）：SQL查询的IO成本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介数据库缓冲池查看缓冲池的大小数据页加载的三种方式通过 last_query_cost 统计 SQL 语句的查询成本总结参考文献 简介 本节将介绍磁盘IO是如何加载数据的，重点介绍一下数据库缓冲池的概念。主要包括：
什么是数据库缓冲池，它在数据库中扮演了什么角色？对数据页进行加载的几种方式如何统计一条SQL语句中，需要在缓冲池中进行加载的页的数量。 数据库缓冲池 为了能够让数据表或者索引中的数据随时为我们所用，DBMS会申请一块内存来作为数据缓冲池。
数据缓冲池里会保存经常使用的数据，这样的话，当数据库进行页面读的时候，会首先来寻找该页面是否在缓冲池里，如果存在就直接读取，如果不存在，就会通过磁盘或者内存，将页面放进缓冲池里再进行读取。
缓冲池在数据库中的结构和作用如下图：
如果我们执行了类似update语句，改变了缓冲池里的数据，那么这些数据会立即同步到磁盘上吗？
当然不是。
实际上，当我们修改数据库中的记录时，首先会修改缓冲池中页的记录信息，然后数据库会以一定的频率将新的数据刷新回磁盘。所以不是每次发生更新操作 ，都会立即回写的。
比如说，当缓冲池空间不够用的时候，就需要释放掉一些不常用的页，这时候就会强行将这些页的数据回写到磁盘，然后在缓冲池里将这些页释放掉。
这里面有一个脏页（dirty Page）的概念，是指在缓冲池里被修改过，尚未回写，因此与磁盘上不同的数据页。
查看缓冲池的大小 如果使用的是MySQL的MyISAM引擎，其只缓存索引，不缓存数据，对应的键缓存参数为key_buffer_size，可以通过查看这个变量来查看缓冲池大小。
如果使用的是InnoDB引擎，则可以通过以下命令查看：
mysql &gt; show variables like 'innodb_buffer_pool_size' 单位是B，转换成MB就是8MB。
如果想修改缓冲池大小为128MB，则可以通过：
set global innodb_buffer_pool_size = 134217728; 在InnoDB中，我们还可以同时开启多个缓冲池。
可以通过以下命令查看当前缓冲池的数量：
mysql &gt; show variables like 'innodb_buffer_pool_instances' 默认情况下，其实是会有8个缓冲池，但是如果你的innodb_buffer_pool_size参数小于1G，那刚才的命令只会显示出1个缓冲池。
数据页加载的三种方式 如果缓冲池中没有我们想要的数据页，那么缓冲池有三种方式，可以将指定数据页加载进缓冲池，每种方式的读取效率会有不同。
内存读取 如果该数据页是在内存里，那么直接读进缓冲池，效率还是很高的。
随机读取 如果数据没有在内存里，那就是在磁盘里，因此我们需要在磁盘上对该页进行查找，假设整体时间是10ms，这 10ms 中有 6ms 是磁盘的实际繁忙时间（包括了寻道和半圈旋转时间），有 3ms 是对可能发生的排队时间的估计值，另外还有 1ms 的传输时间，将页从磁盘服务器缓冲区传输到数据库缓冲区中。
以上过程结束之后，我们才算完成了一页的读取，多页读取的话，时间会继续拉长。
顺序读取 顺序读取其实是一种批量读取的方式，因为我们请求的数据在磁盘上往往都是相邻存储的，顺序读取可以帮我们批量读取页面，这样的话，一次性加载到缓冲池中就不需要再对其他页面单独进行磁盘 I/O 操作了。
采用批量读取的方式，即使是从磁盘上进行读取，平均一页的读取效率也比从内存中单独读取一个页的效率要高。
通过 last_query_cost 统计 SQL 语句的查询成本 如果我们想要查看某条 SQL 语句的查询成本，可以在执行完这条 SQL 语句之后，通过查看当前会话中的 last_query_cost 变量值来得到当前查询的成本。这个查询成本对应的是 SQL 语句所需要读取的页的数量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1d392c8a49de6bbd1e7ee0f19d5ed35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd891dc33865e3d24d328baf233ae865/" rel="bookmark">
			强化学习（四）- Advantage Actor-Critic 及贝尔曼方程推导（A2C）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 概览 Advantage Actor-Critic 主要在于Q函数的计算，其中baseline b选择为状态价值函数，使用神经网络代替 V π ( s , w ) V_\pi (s,w) Vπ​(s,w)Q函数使用贝尔曼方程来近似 Q π ( s , A ) = r t + γ V π ( s t + 1 ) Q_\pi(s,A)=r_t+\gamma V_\pi(s_{t+1}) Qπ​(s,A)=rt​+γVπ​(st+1​)其中Advantage 体现在 Q π ( s , A ) − V π ( s t ) Q_\pi(s,A)-V_\pi(s_t) Qπ​(s,A)−Vπ​(st​)上贝尔曼方程：
Q π ( s t , a t ) = E S t + 1 [ R t + γ ∗ V π ( S t + 1 ) ] Q_\pi(s_t,a_t)=E_{S_{t+1}}[R_t+\gamma *V_\pi(S_{t+1})] Qπ​(st​,at​)=ESt+1​​[Rt​+γ∗Vπ​(St+1​)]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd891dc33865e3d24d328baf233ae865/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c9555fe9bc8e6e3155626d31df6be23/" rel="bookmark">
			常见内存泄漏场景与解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器开发文章目录 文章目录 服务器开发文章目录前言一、内存泄漏是什么？二、常见内存泄漏场景三、内存泄漏规避与定位总结 前言 作为C/C++程序员，谁还不写Bug，Bug中最常见要数内存泄漏、内存崩溃、死锁等问题，本文主要讲解内存泄漏问题，其具有其独有的属性，比如说：隐蔽性强、难以排查、占用资源不断累积等特点，当到达一定程度会出现崩溃、被系统kill掉等……
一、内存泄漏是什么？ 内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。
二、常见内存泄漏场景 场景1：new/malloc与delete/malloc没有成对出现
void callfun(char *p) { std::cout&lt;&lt; p&lt;&lt;std::endl; } void fun() { char *p = new char[128]; return callfun(p); } 场景2：new/malloc 提前返回
void fun(std::string request) { char *p = new char[128]; if(request.length()== 0){ return; } delete []p; return; } 场景3：基类被继承时，虚构函数没有被定义为virtual
class A { public: A(){} ~A(){} //未定义virutal }; class B:public A { public: B(){ p = new char[128]; } ~B(){ if(p) delete [] p; p = nullptr; } private: char *p = nullptr; }; int main() { A* inst = new B; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c9555fe9bc8e6e3155626d31df6be23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20df5df71ffda7e2a40fbd452115954b/" rel="bookmark">
			继电器模块的使用（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继电器模块的工作原理 继电器（Relay）是一种电控开关，其工作原理基于电磁感应。继电器通常包括一个电磁线圈和一组触点。
以下是继电器模块的基本工作原理：
电磁线圈： 继电器内部包含一个电磁线圈，通常由绕制在绝缘芯片上的细导线组成。当通过线圈通电时，产生电磁场。
磁性吸引： 电磁场会使继电器中的铁芯（或磁性材料）受到磁性吸引，导致铁芯在电磁力的作用下移动。
触点操作： 铁芯的移动会导致机械部分的运动，最终使触点（开关）发生动作。继电器通常有常开（Normally Open，NO）和常闭（Normally Closed，NC）两组触点。
常开触点： 在继电器未通电时处于闭合状态，当电磁线圈通电时，触点打开。
常闭触点： 在继电器未通电时处于打开状态，当电磁线圈通电时，触点闭合。
电气隔离： 继电器的主要作用之一是提供电气隔离。通过电磁原理，可以在控制信号与被控制电路之间提供隔离，从而使得不同电路之间的电流不会相互影响。
继电器模块常用于控制高电流或高电压的电路，例如在自动控制系统、电力系统和自动化设备中。由于其可靠性和电气隔离的特性，继电器在各种应用中都有广泛的用途。
电路图 继电器模块引脚说明 不管继电器模块是否一样，或封装不同。大概的引脚图如下所示：
VCC（+）： 供电正极。连接此引脚到电源（通常是直流电源），以提供继电器线圈所需的电流。
GND（-）： 地。连接此引脚到电源的负极或地。
IN（或者类似标记）： 控制输入。通常用于连接控制信号，当该信号变化时，继电器将切换状态。
NC（Normally Closed）： 常闭接口，继电器吸合前与COM连接，吸合后悬空
COM（Common）： 公共端，通常是中间的触点，与常开或常闭触点相连。
NO（Normally Open）： 常开接口，继电器吸合前悬空，吸合后与COM连接
开路即通路、断路，闭合指的是开关闭合，也就是说，在没有任何上电之类的动作时，NC和COM端相当于已经连通
继电器模块的使用 在一般情况下NC是闭合的，所以我们要接到NO接口，然后信号输入引脚即IN引脚给高电平，NC端断，NO端合，负载端电路形成闭合回路，开始工作，当IN端给低电平时，NO端断，负载即停止工作。
如果想一直工作，给信号停止工作，即把线接在NC端就行了。
（切记：继电器的GND要和单片机的GND接在一起共地，也可以使用同一个电源来达到共地的效果）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28d8cf1371b234036f665e366629b24b/" rel="bookmark">
			Ribbon使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ribbon ：处理客户端负载均衡和容错的解决方案
配置Ribbon的负载均衡
Rule接口： 定义客户端负载均衡的规则
RandomRule :随机选择RoundRobinRuleZoneAvoidanceRule 配置ribbon的负载均衡策略 在配置文件中配置 user-center: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 在java代码中配置 /** * * 不同的服务使用不同的ribbon策略 * @RibbonClient : 表示这个配置是为xxx服务的 * */ //@Configuration //@RibbonClient(name = "user-center",configuration = RibbonConfiguration.class) // 全局服务设置 @RibbonClients(defaultConfiguration = RibbonConfiguration.class) public class UserCenterRibbonConfiguration { } 如果是为某个微服务单独配置负载均衡策略 @RibbonClient 指定配置文件的位置，，，这个配置文件不能被springboot扫描到，，父子上下文环境，，就像spring和springmvc的环境，，不能重叠，，如果重叠，相当于会变成全局的配置
Ribbon的配置文件
@Configuration public class RibbonConfiguration { @Bean public IRule ribbonRule(){ // 负载均衡策略为随机 // return new RandomRule(); // 根据权重 这个类是自己写的根据权重判断 return new NacosWeightedRule(); } /** * 配置 ping的规则 * @return */ @Bean public IPing ping(){ return new PingUrl(); } } 写自己的负载均衡算法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28d8cf1371b234036f665e366629b24b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9373acc22543e94a960e674ba8392c4d/" rel="bookmark">
			【迁移学习论文四】Multi-Adversarial Domain Adaptation论文原理及复现工作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Multi-Adversarial Domain Adaptation 多对抗域适应 前言 好久没有更新了，所以这周开始记录下来，也好督促自己。记录本人预备研究生阶段相关迁移学习论文的原理阐述以及复现工作。 问题 跨域混淆或错误对齐
文章介绍 这篇文章于2018年发表在AAAI，作者是清华大学龙明盛老师的学生。作者提到，域适应存在两个技术挑战:
通过最大限度地匹配跨域数据分布的多模式结构来增强正迁移;通过防止跨域分布中模式的错误对齐来减轻负迁移。 在这些挑战的激励下，作者提出一种多对抗域自适应(MADA)方法，它捕获多模式结构，以支持基于多个域鉴别器的不同数据分布的细粒度对齐。与以前的方法相比，一个关键的改进是能够同时促进相关数据的正迁移和减轻不相关数据的负迁移。利用线性时间内的反向传播计算梯度，通过随机梯度下降实现自适应。
模型结构 标签分类器 从图中可以看到，源域样本首先经过 G f G_f Gf​层提取到相关特征，然后送入标签分类器 G y G_y Gy​得到分类标签然后使用交叉熵损失计算分类损失。标签分类器几乎是所有模型必备的一项。这里不过多赘述。 局部域分类器 我们可以看到上面的蓝色线条，这就是局部域分类器。
首先 G f G_f Gf​提取到目标域和源域的特征，然后经过GRL后送入局部域分类器。这里产生一个问题，目标域样本的标签我们是不知道的，只知道源域数据标签，那我们如何知道哪个样本应该送入哪个局部域分类器呢？让经过GRL之后的特征再与各个类别的标签分类概率相乘，然后送入相应类别的局部域分类器，在这个类别的分类概率越高就意味着这个局部域分类器对你的关注度就应该越高。 对抗学习过程是一个双人博弈
第一个参与者是经过训练的域鉴别器 G d G_d Gd​，用于区分源域和目标域第二个参与者是同时经过微调的特征提取器 G f G_f Gf​，用于混淆域鉴别器 损失函数 优点 本文提出的多对抗域自适应网络实现了细粒度自适应，每个数据点 x i x_i xi​仅由相关的域鉴别器根据其概率 y i y_i yi​进行匹配。这种细粒度的适应可能带来三个好处。
避免了将每个点只分配给一个域鉴别器的困难，避免了对目标域数据的不准确。避免了负迁移，因为每个点只对齐到最相关的类，而不相关的类被概率过滤掉，不会包含在相应的域判别器中，从而避免了不同分布中判别结构的错误对齐。用概率加权数据点训练多域鉴别器，自然学习到具有不同参数的多个域鉴别器;这些域具有不同参数的鉴别器促进每个实例的正迁移。 代码 # 前向传播方法 def forward(self, x): # 计算 lambda（lbda） lbda = self.get_lambda_p(self.get_p()) if self.mode == 'Train' else 0 # 提取特征 features = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9373acc22543e94a960e674ba8392c4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d51ae533bd430cbe488eeb4a988076a6/" rel="bookmark">
			【k8s】Helm官方文档链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://helm.sh/zh/docs/chart_template_guide/getting_started/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43d0925a28913d96978747c1b6009d60/" rel="bookmark">
			Flask学习四：补充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插件 flask-caching 简介
Flask-Caching 是一个 Flask 扩展，旨在为 Flask 应用程序添加缓存功能。缓存是一种提高应用性能的技术，通过将常用数据暂时存储在一个快速访问的位置（如内存或磁盘），从而减少对较慢资源（如数据库或网络服务）的重复访问。
Flask-Caching 提供了一种简单的方式来缓存视图函数的结果或者任何可调用对象的结果，并且支持多种缓存后端，包括内存缓存（如 SimpleCache）、文件系统缓存、Memcached 缓存以及 Redis 缓存等。这意味着开发者可以根据应用程序的需求和基础设施选择最适合的缓存方式。
通过 Flask-Caching，开发人员可以轻松实现诸如页面缓存、模板片段缓存、函数结果缓存等功能。此外，它还提供了灵活的配置选项，以便根据业务需求调整缓存行为，如设置过期时间、使用不同的缓存策略等。
使用
安装
pip install flask-caching 初始化
from flask_caching import Cache # 缓存 cache= Cache(config={ 'CACHE_TYPE': 'simple', 'CACHE_DEFAULT_TIMEOUT': 3600 ,# 设置过期时间为1小时，过期后会被自动删除 }) # 缓存 cache.init_app(app=app) # 绑定缓存 使用
在视图函数上添加缓存
@cache.cached(timeout=60) # 1分钟后过期 @userManageBlue.route('/user-manage/') def index(): 使用场景
频繁访问的数据库查询结果：如果某个视图函数执行了复杂的数据库查询操作，并且这个查询结果在短时间内不会发生变化，那么可以使用Flask-Caching来缓存查询结果，避免每次请求都执行这个查询操作，提高响应速度。
渲染的页面内容：如果某个页面的内容不经常变化，并且需要花费较长时间来生成，那么可以使用Flask-Caching来缓存页面内容。这样，当多个用户请求同一个页面时，可以直接返回缓存的页面内容，减少服务器的负载和响应时间。
钩子函数（中间件） 钩子函数的使用
钩子函数是指在执行函数或者目标函数之间挂载的函数，框架开发者给调用方法提供一个point-挂载点，是一种AOP切面编程思想
常见的钩子函数有：
before_first_request：处理第一次请求时执行before_request：在每次请求之前执行，通常使用这个钩子函数预处理一些变量，实现反爬虫after_request：注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行teardown_appcontext：当app上下文被移除后执行的函数，可以进行数据库的提交或者回滚 示例：反爬虫策略
# 相同ip地址1秒内不允许重复访问 key = request.remote_addr + "before" valeu = cache.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43d0925a28913d96978747c1b6009d60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/906216748c8c27ea01081e1c1e094400/" rel="bookmark">
			VSCode配置代码片段，提升效率必备！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.点击文件—&gt; 首选项------&gt;配置用户代码片段
2、新建用户代码片段
3、以js的控制台输出为例
{ //片段名称 "console.log": { "prefix": "cls",//呼出命令 "body": [ "console.log('$1')"//具体片段 ], "description": "console.log"//描述 } } 其他命令一样
4、一个生成模板的网站
自己写，容易出错，可以生成：在线生成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2918656c4d64c85de6655b401ba12475/" rel="bookmark">
			LeetCode：2415. 反转二叉树的奇数层（层次遍历 Java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
2415. 反转二叉树的奇数层
题目描述：
实现代码与解析：
BFS
原理思路：
2415. 反转二叉树的奇数层 题目描述： 给你一棵 完美 二叉树的根节点 root ，请你反转这棵树中每个 奇数 层的节点值。
例如，假设第 3 层的节点值是 [2,1,3,4,7,11,29,18] ，那么反转后它应该变成 [18,29,11,7,4,3,1,2] 。 反转后，返回树的根节点。
完美 二叉树需满足：二叉树的所有父节点都有两个子节点，且所有叶子节点都在同一层。
节点的 层数 等于该节点到根节点之间的边数。
示例 1：
输入：root = [2,3,5,8,13,21,34] 输出：[2,5,3,8,13,21,34] 解释： 这棵树只有一个奇数层。 在第 1 层的节点分别是 3、5 ，反转后为 5、3 。 示例 2：
输入：root = [7,13,11] 输出：[7,11,13] 解释： 在第 1 层的节点分别是 13、11 ，反转后为 11、13 。 示例 3：
输入：root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2] 输出：[0,2,1,0,0,0,0,2,2,2,2,1,1,1,1] 解释：奇数层由非零值组成。 在第 1 层的节点分别是 1、2 ，反转后为 2、1 。 在第 3 层的节点分别是 1、1、1、1、2、2、2、2 ，反转后为 2、2、2、2、1、1、1、1 。 提示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2918656c4d64c85de6655b401ba12475/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac28c3bd8b8dbeac494a6aed5386ec93/" rel="bookmark">
			springcloudalibaba01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整合springcloud 和 springcloudalibaba，，，
版本对应关系
&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 每个springcloud的工具都有一个版本 每个springcloud alibaba的工具都有一个版本 统一版本 --&gt; &lt;!-- 整合springcloud--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.SR12&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 整合springcloud alibaba--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;0.9.0.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 使用nacos
&lt;!--springcloud 里面的nacos--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; 还有一个alibaba里面的nacos，，，区别：
alibaba里面的nacos，，不依赖于 Alibaba Cloud SDK ，，更加灵活的使用nacos
使用nacos 查看nacos对应的版本：
去下载对应的版本，并启动： 输入：http://localhost:8848/nacos
项目中引用nacos的包
配置文件 ,注册地址 spring: datasource: url: jdbc:mysql://localhost:3306/content_center hikari: username: root password: root driver-class-name: com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac28c3bd8b8dbeac494a6aed5386ec93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edeeb42838619c258ece335bb7971b4d/" rel="bookmark">
			C&#43;&#43;执行系统命令的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 执行系统命令可以使用以下几种方法：
1. 使用 system() 函数 system() 函数会调用操作系统的命令行处理器（如 /bin/sh）来执行命令。该函数的语法如下：
int system(const char *command); 其中，command 参数指定要执行的命令。
例如，以下代码将执行 ls 命令：
#include &lt;iostream&gt; int main() { int status = system("ls"); if (status != 0) { std::cout &lt;&lt; "执行命令失败" &lt;&lt; std::endl; } return 0; } system() 函数的返回值为命令的退出状态。如果命令执行成功，则返回值为 0。如果命令执行失败，则返回值为非 0 值。
2. 使用 popen() 函数 popen() 函数会创建一个管道，用于将命令的输入和输出与 C++ 程序进行连接。该函数的语法如下：
FILE *popen(const char *command, const char *mode); 其中，command 参数指定要执行的命令。mode 参数指定管道的模式，可以为 "r"、"w" 或 "rw"。
popen() 函数返回一个 FILE 指针，指向管道。可以使用 fread() 函数从管道中读取命令的输出，使用 fwrite() 函数向管道中写入命令的输入。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edeeb42838619c258ece335bb7971b4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b7fc35a214e0a4bc70287a1fe4cf9e7/" rel="bookmark">
			chipon芯旺微KF32A156/150系列ADC模块的使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请尊重原创，转载需要注明源出处！！！ hello大家好，今天主要来说一下芯旺微32位机的AD模块的使用。本篇文章较长，如有需要不同模式，请耐心仔细看完。首先看一下官方手册提供的AD模块的简介：
可以看到，AD模块对于常规的使用完全能够覆盖。我们最常用的也就是普通AD通道的采样方式。
AD普通通道同一个ADC模块可以同时配置16个普通通道和4个高优先级通道，在我们使用过程中，不建议两种通道混合使用，本篇以普通通道来讲解。
本次主要讲解三种模式：单通道采样，单通道循环采样，多通道单次扫描采样，多通道循环扫描采样。
说在前面：首先AD电路采样电压不建议超过VDDA的电压。
在进行软件配置之前：
首先要对引脚是否能够实现进行确认。通过数据手册的 模拟功能引脚表 进行查询，如图1
通过上图可以看到，144pin的第36脚可实现AD通道号96（ADC_CH96）。第44脚就无法实现AD通道的配置。
正文 使用说明：pin脚上的AD通道是属于硬件通道，这个标号是固定的，比如ADC_CH96，在每个ADC模块进行配置的时候，还需要进行配置采样通道标号（也就是前面说的一个ADC模块最多只能配置16个普通采样通道）。这个是通过软件自行配置。在后面的讲解中有所涉及，需要进行区分。
一、单通道采样配置(以PA1为例，轮询的方式查询结果)，此模式触发一次开始采一个通道结束。 老三步：配置引脚，配置外设，配置中断。
1、进行引脚模式配置：配置为模拟端口 GPIO_Write_Mode_Bits (GPIOA_SFR,GPIO_PIN_MASK_1, GPIO_MODE_AN); ADC_CH66 2、AD模块配置,这里关键参数，时钟，扫描模式失能，循环模式失能，触发源全部失能，通道长度为1，配置1个通道顺序号 ADC_InitTypeDef adcStruct; ADC_Reset (ADC0_SFR); //复位ADC外设并打开ADC的时钟 /* 初始化 ADC时钟源选择 */ adcStruct.m_Clock = ADC_HFCLK; /* 初始化 ADC时钟分频 */ adcStruct.m_ClockDiv = ADC_CLK_DIV_4; //4分频 /* 初始化 ADC扫描模式使能 */ adcStruct.m_ScanMode = FALSE; //扫描模式，一次触发只转换第一个通道 /* 初始化 ADC连续转换模式 */ adcStruct.m_ContinuousMode = ADC_SINGLE_MODE; //不使用连续转换功能，只对设置的通道采样一遍 /* 初始化 ADC转换结果输出格式 */ adcStruct.m_DataAlign = ADC_DATAALIGN_RIGHT; //转换的结果右对齐 /* 初始化 ADC常规通道外部触发转换模式使能 */ adcStruct.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b7fc35a214e0a4bc70287a1fe4cf9e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46b9b4cf5c35ca1b091a3cc7518e1d05/" rel="bookmark">
			一键转换：使用OpenAI的Python脚本制作语音文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这段 Python 代码演示了如何使用 OpenAI 的文本转语音（TTS）服务，将文本转换成语音并保存为音频文件。该脚本通过定义一个函数 generate_speech 来实现这一过程，该函数接收文本、语音模型、选定的声音和文件保存路径作为参数。
from pathlib import Path from openai import OpenAI # api文档:https://platform.openai.com/docs/guides/text-to-speech # 可以将独立与对话分开成两个语音，同时 def generate_speech(api_key, text, model, voice, file_path): """ 使用 OpenAI 的 TTS 生成语音，并保存到指定路径。 :param api_key: OpenAI 的 API 密钥。 :param text: 要转换为语音的文本。 :param voice: 选择的语音模型。 :param file_path: 保存语音文件的路径。 :return: 保存文件的路径。 """ client = OpenAI(api_key=api_key) response = client.audio.speech.create( model=model, voice=voice, input=text ) path = Path(file_path) with open(path, 'wb') as file: file.write(response.content) return f'文件已保存到: {path}' # 使用示例 api_key = '' text = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46b9b4cf5c35ca1b091a3cc7518e1d05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e185fe30d8935adb57fbe58695f51840/" rel="bookmark">
			Tomcat详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言何为TomcatTomcat的下载方法JDK环境tomcat配置方法端口及应用程序位置配置数据源配置 context文件Tomcat的启动、关闭tomcat十个技巧Linux下设置Tomcat 下开机自启动 前言 环境：Windows apache-tomcat-9.0.37.tar.gz jdk-14.0.2
一下以Windows环境来讲解如何安装tomcat，如果你的是Linux环境，其大体上是一样的。
何为Tomcat Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。
Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。Tomcat 实际上运行JSP 页面和Servlet。另外，Tomcat和IIS等Web服务器一样，具有处理HTML页面的功能，另外它还是一个Servlet和JSP容器，独立的Servlet容器是Tomcat的默认模式。不过，Tomcat处理静态HTML的能力不如Apache服务器。
Tomcat最初是由Sun的软件架构师詹姆斯•邓肯•戴维森开发的。后来他帮助将其变为开源项目，并由Sun贡献给Apache软件基金会。由于大部分开源项目O’Reilly都会出一本相关的书，并且将其封面设计成某个动物的素描，因此他希望将此项目以一个动物的名字命名。因为他希望这种动物能够自己照顾自己，最终，他将其命名为Tomcat（英语公猫或其他雄性猫科动物）。而O’Reilly出版的介绍Tomcat的书籍（ISBN 0-596-00318-8）的封面也被设计成了一个公猫的形象。而Tomcat的Logo兼吉祥物也被设计为一只公猫。
Tomcat的下载方法 Tomcat在https://tomcat.apache.org/官网下载，因为tomcat是Apache其下的产品。
JDK环境 Tomcat 需要jdk环境的支持，所以需要到Oracle的官网下载对应版本的jdk，并安装好jdk，配置JAVA_HOME环境变量。
tomcat配置方法 启动内存参数的配置
tomcat/bin/catalina.bat 如果是linux 就是 catalina.sh
在rem 的后面增加如下参数
set JAVA_OPTS= -Xms256m -Xmx256m -XX:MaxPermSize=64m
修改Tomcat的JDK目录
打开tomcat/bin/catalina.bat
在最后一个rem后面增加
set JAVA_HOME=C:\Program Files\Java\jdk1.8.0
增加虚拟目录
/tomcat/conf/server.xml
第一行是以前默认存在的，第二行是新增的
使用默认配置的tomcat,另外虚拟目录也可这设置:
因为默认情况下,tomcat启动过程中配置虚拟目录的时候会从 webapps目录下查找webContent应用。
这样配置好了，即使以后从一台服务器移植到另一台服务器，不做任何修改也能运行起来。
GET方式URL乱码问题解决
打开 tomcat/conf/server.xml
查找下面这部分，在最后增加一段代码就可以了。
................. URIEncoding="UTF-8" useBodyEncodingForURI="true" ............... /&gt; 其中的UTF-8 请根据你的需要自己修改，比如GBK
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e185fe30d8935adb57fbe58695f51840/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ab7b19831555dc48d29f0f13ee60820/" rel="bookmark">
			javascript中常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. .some()方法 let rolesm = ['admin']; let roles = ['admin','developer']; // let res = roles.some(role =&gt; rolesm.includes(role)); function isper(username){ if(username == 'admin'){ return true; } } let res = roles.some(isper); if(res){ console.log(res) console.log("success") }else{ console.log("err") } //输出结果 true success ~~~ 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/24/">«</a>
	<span class="pagination__item pagination__item--current">25/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/26/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>