<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1847e5328f0886bd617c400f84c3ae00/" rel="bookmark">
			rocketmq 雪崩后客户端超时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rocketmq 雪崩后客户端超时 看了源代码,mq broker 方核心日志信息:
1. 通过 mqAdmin 的消息 id,查看信息的 born 和 stroe 时间
2. 通过慢查日志查看.
defaultMessageStore.java 中 PutMessageResult putMessage(MessageExtBrokerInner msg) { log. warn( "putMessage not in lock eclipse time(ms)={}, bodyLength={}", eclipseTime, msg.getBody(). length); 3.业务方的统计日志.
4. 线程堆栈统计.
报错异常信息:
com.paygateway.core.service.integration.bean.PayGatewayPaySuccess@462ba599,Flag=644560335968fcbd9e27515f3bc2ac86 com.alibaba.rocketmq.client.exception.MQClientException: Send [2] times, still failed, cost [6002]ms, Topic: PAY_GATEWAY_CALLBACK_SUCCESS_TOPIC, BrokersSent: [broker_cluster_3, broker_cluster_0, null] For more information, please visit the url, https://github.com/alibaba/RocketMQ/issues/64 at com.alibaba.rocketmq.client.impl.producer.DefaultMQProducerImpl.sendDefaultImpl(DefaultMQProducerImpl.java:590) at com.alibaba.rocketmq.client.impl.producer.DefaultMQProducerImpl.send(DefaultMQProducerImpl.java:1026) at com.alibaba.rocketmq.client.producer.DefaultMQProducer.send(DefaultMQProducer.java:122) Caused by: com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1847e5328f0886bd617c400f84c3ae00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dcf3968d07adc3558d9188a318503f5/" rel="bookmark">
			httpd-2.4编译安装详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 在CentOS 6上利用yum安装的httpd为2.2版本，而CentOS 7本身就支持httpd-2.4，所以这里以CentOS 6为例. 2、解决依赖关系 由于httpd服务依赖于apr,apr-util包。CentOS 6上的这两个包的版本是1.3.9版本的，而httpd-2.4所依赖的这两个包的版本必须是1.4及以上的，所以必须下载、编译安装这两个包. apr下载地址：http://mirror.bit.edu.cn/apache//apr/apr-1.6.2.tar.gz apr-util下载地址：http://mirror.bit.edu.cn/apache//apr/apr-util-1.6.0.tar.gz
编译安装apr,apr-util
[root@ling ~]#ls anaconda-ks.cfg apr-1.5.2.tar.gz apr-util-1.5.4.tar.gz install.log apr-1.5.2 apr-util-1.5.4 httpd-2.4.25.tar.bz2 install.log.syslog apr
[root@ling ~]#tar xf apr-1.5.2.tar.gz [root@ling ~]#cd apr-1.5.2 [root@ling apr-1.5.2]#./configure --prefix=/usr/local/apr [root@ling apr-1.5.2]#make &amp;&amp; make install apr-util 由于apr-util依赖于apr，所以要使用–with-apr=/path/to/apr
[root@ling ~]#tar xf apr-util-1.5.4.tar.gz [root@ling ~]#cd apr-util-1.5.4 [root@ling apr-util-1.5.4]#./configure --prefix=/usr/local/apr --with-apr=/usr/local/apr-util [root@ling apr-util-1.5.4]#make &amp;&amp; make install 3、安装httpd-2.4 创建apche的属组与属主，由于是系统用户与系统组，所以要使用-r选项
[root@ling ~]#groupadd -r apache [root@ling ~]#useradd -r -g apache apache 编译安装： 解压
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dcf3968d07adc3558d9188a318503f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0c2fe94b85477f19f3ce5d6831e628f/" rel="bookmark">
			jquery中each()方法的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在jquery中，遍历对象和数组，经常会用到$().each和$.each()，两个方法。两个方法是有区别的，从而这两个方法在针对不同的操作上，显示了各自的特点。
$().each,对于这个方法，在dom处理上面用的较多。如果页面有多个input标签类型为checkbox，对于这时用$().each来处理多个checkbook，例如：
$(“input[name=’checkbox’]”).each(function(i){ if($(this).attr(‘checked’)==true){ //一些操作代码 } }
//回调函数是可以传递参数，i就为遍历的索引。 对于数组的遍历，使用$.each()来遍历更加方便：
each处理一维数组 var arr1 = [ "aaa", "bbb", "ccc" ]; $.each(arr1, function(i,val){ alert(i); alert(val); }); //alert(i)将输出0，1，2 //alert(val)将输出aaa，bbb，ccc //each处理二维数组 var arr2 = [['a', 'aa', 'aaa'], ['b', 'bb', 'bbb'], ['c', 'cc', 'ccc']] $.each(arr, function(i, item){ alert(i); alert(item); }); //arr2为一个二维数组，item相当于取这二维数组中的每一个数组。 //item[0]相对于取每一个一维数组里的第一个值 //alert(i)将输出为0，1，2，因为这二维数组含有3个数组元素 //alert(item)将输出为 ['a', 'aa', 'aaa']，['b', 'bb', 'bbb']，['c', 'cc', 'ccc'] //对此二维数组的处理稍作变更之后 var arr = [['a', 'aa', 'aaa'], ['b', 'bb', 'bbb'], ['c', 'cc', 'ccc']] $.each(arr, function(i, item){ $.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0c2fe94b85477f19f3ce5d6831e628f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fdbe061b8db1ed6b8e6a18e3b0afa29/" rel="bookmark">
			spring boot应用p6spy监控sql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring boot中使用p6spy监控hibernate sql语句值 开发环境 开发工具：IDEA开发环境：spring mvc、spring boot、spring data数据库:mysql 具体步骤如下： pom.xml中添加p6spy包依赖： &lt;dependency&gt; &lt;groupId&gt;p6spy&lt;/groupId&gt; &lt;artifactId&gt;p6spy&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; application.yml配置中： (1). url中必须增加p6spy,才能对SQL进行拦截：
jdbc:p6spy:mysql://192.0.6.116:3066/testdb
(2). driver-class需替换为：
com.p6spy.engine.spy.P6SpyDriver
具体如下：
spring: datasource: url: jdbc:p6spy:mysql://192.0.6.116:3066/testdb #driver-class-name: com.mysql.jdbc.Driver driver-class-name: com.p6spy.engine.spy.P6SpyDriver username: root password: xxxxxx 将spy.properties放到resources根目录下 spy.properties文件内容参考如下：
### # #%L # P6Spy # %% # Copyright (C) 2013 P6Spy # %% # Licensed under the Apache License, Version 2.0 (the "License"); # you may not use this file except in compliance with the License.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fdbe061b8db1ed6b8e6a18e3b0afa29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a19a06ecfa89532ef98aaab3864d951a/" rel="bookmark">
			你所不知道的快速排序（js实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：本文是在看了两篇大牛的博客后，通过整理供自己学习快速排序所做笔记，分享出来方便大家学习。如需进一步了解可以查看文中博客链接。
一. 快速排序是什么 快速排序是图灵奖得主C. A. R. Hoare（1934--）于1960时提出来的。
快速排序是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一不部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
整个排序过程只需要三步：
（1）在数据集之中，选择一个元素作为"基准"（pivot）。
（2）所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边。
（3）对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。
二. 快速排序的时间复杂度 日本程序员norahiko，写了一个排序算法的动画演示，可以直观地将快排和其他排序方法的速度进行对比。
三. 快速排序为什么那么快 根据刘伟鹏的数学之美番外篇：快排为什么那样快一文所述，快排的本质上是一种通过问问题来缩小结果的可能性区间的策略。
下面我们将从最基本的猜数字和称小球讲起，总结其中蕴含的规律，然后一步步引申到排序问题上去。
1. 猜数字 假设有一个1~64之间的数，你来猜（你只能问答案是“是”或“否”的问题）。为了保证不论在什么情况下都能以尽量少的次数猜中，你应该采取什么策略呢？很显然，二分。先是猜是不是位于1~32之间，排除掉一半可能性，然后对区间继续二分。这种策略能够保证无论数字怎么跟你捉迷藏，都能在log_2{n}次以内猜中。用算法的术语来说就是它的下界是最好的。
为什么这种策略具有最优下界？答案也很简单，这个策略是平衡的。反之如果策略不是平衡的，比如问是不是在1~10之间，那么一旦发现不是在1~10之间的话就会剩下比N/2更多的可能性需要去考察了。
这种策略的本质可以概括成“让未知世界无机可乘”。它是没有“弱点的”，答案的任何一个分支都是等概率的。反之，一旦某个分支蕴含的可能性更多，当情况落到那个分支上的时候你就郁闷了。比如猜数字游戏最糟糕的策略就是一个一个的猜：是1吗？是2吗？… 因为这种猜法最差的情况下需要64次才能猜对，下界非常糟糕。二分搜索为什么好，就是因为它每次都将可能性排除一半并且无论如何都能排除一半（它是最糟情况下表现最好的）。
2. 称小球 12个小球，其中有一个是坏球。有一架天平。需要你用最少的称次数来确定哪个小球是坏的并且它到底是轻还是重。这个问题是一道流传已久的智力题。
我们先回顾一下猜数字游戏。为了保证任何情况下以最少次数猜中，我们的策略是每次都排除恰好一半的可能性。类比到称球问题上：坏球可能是12个球中的任意一个，这就是12种可能性；而其中每种可能性下坏球可能轻也可能重。于是“坏球是哪个球，是轻是重”这个问题的答案就有12×2=24种可能性。现在我们用天平来称球，就等同于对这24种可能性发问，由于天平的输出结果有三种“平衡、左倾、右倾”，这就相当于我们的问题有三个答案，即可以将所有的可能性切成三份，根据猜数字游戏的启发，我们应当尽量让这三个分支概率均等，即平均切分所有的可能性为三等份。如此一来的话一次称量就可以将答案的可能性缩减为原来的1/3，三次就能缩减为1/27。而总共才有24种可能性，所以理论上是完全可以3次称出来的。
如何称的指导原则有了，构造一个称的策略就不是什么太困难的事情了。首先不妨解释一下为什么最直观的称法不是最优的——6、6称：在6、6称的时候，天平平衡的可能性是0，也就是说我们得到的信息量为零。刚才说了，最优策略应该使得天平三种状态的概率均等，这样才能三等分答案的所有可能性。
只要记着这样一个指导思想——你选择的称法必须使得当天平平衡的时候答案剩下的可能性和天平左倾（右倾）的时候答案剩下的可能性一样多。实际上，这等同于你得选择一种称法，使得天平输出三种结果的概率是均等的，因为天平输出某个结果的概率就等同于所有支持这个结果（左倾、右倾、平衡）的答案可能性的和，并且答案的每个可能性都是等概率的。
MacKay在他的书《Information Theory: Inference and Learning Algorithms》（作者开放免费电子书）里面4.1节专门讲了这个称球问题，还画了一张不错的图：
图中“1+”是指“1号小球为重”这一可能性。一开始一共有24种可能性。4、4称了之后不管哪种情况（分支），剩下来的可能性总是4种。这是一个完美的三分。然后对每个分支构造第二次称法，这里你只要稍加演算就可以发现，分支1上的第二次称法，即“1、2、6对3、4、5”这种称法，天平输出三种结果的可能性是均等的（严格来说是几乎均等）。这就是为什么这个称法能够在最坏的情况下也能表现最好的原因，没有哪个分支是它的弱点，它必然能将情况缩小到原来的1/3。
3. 排序（理想情况） 用前面的看问题视角，排序的本质可以这样来表述：一组未排序的N个数字，它们一共有N!种重排，其中只有一种排列是满足题意的（譬如从大到小排列）。换句话说，排序问题的可能性一共有N!种。任何基于比较的排序的基本操作单元都是“比较a和b”，这就相当于猜数字游戏里面的一个问句，显然这个问句的答案只能是“是”或“否”，一个只有两种输出的问题最多只能将可能性空间切成两半，根据上面的思路，最佳切法就是切成1/2和1/2。也就是说，我们希望在比较了a和b的大小关系之后，如果发现ab也是剩下N!/2种可能性。由于假设每种排列的概率是均等的，所以这也就意味着支持ab的也是N!/2个，换言之，ab的概率。
我们希望每次在比较a和b的时候，ab的概率是均等的，这样我们就能保证无论如何都能将可能性缩小为原来的一半了！最优下界。
一个直接的推论是，如果每次都像上面这样的完美比较，那么N个元素的N!种可能排列只需要log_2{N!}就排查玩了，而log_2{N!}近似于NlogN。这正是快排的复杂度。
4. 排序（实际情况） 我们考虑快排的过程：随机选择一个元素做“轴元素”，将所有大于轴元素的移到左边，其余移到右边。根据这个过程，快排的第一次比较就是将一个元素和轴元素比较，这个时候显而易见的是，“大于”和“小于”的可能性各占一半。这是一次漂亮的比较。
然而，快排的第二次比较就不那么高明了：我们不妨令轴元素为pivot，第一次比较结果是a1pivot的话，那么a1，a2，pivot这三个元素之间的关系就完全确定了——a1&lt;pivot&lt;a2，剩下来的元素排列的可能性我们不妨记为P（不需要具体算出来）。而如果a2&lt;pivot呢？那么a1和a2的关系就仍然是不确定的，也就是说，这个分支里面含有两种情况：a1&lt;a2&lt;pivot，以及a2&lt;a1&lt;pivot。对于其中任一种情况，剩下的元素排列的可能性都是P，于是这个分支里面剩下的排列可能性就是2P。所以当a2&lt;pivot的时候，还剩下2/3的可能性需要排查。
再进一步，如果第二步比较果真发现a2&lt;pivot的话，第三步比较就更不妙了，模仿上面的推理，a3&lt;pivot的概率将会是3/4！
这就是快排也不那么快的原因，因为它也没有做到每次比较都能将剩下的可能性砍掉一半。
5. 小节 将排序问题看成和猜数字一样，是通过问问题来缩小/排除（narrow down）结果的可能性区间，这样一来，就会发现，“最好的问题”就是那些能够均分所有可能性的问题，因为那样的话不管问题的答案如何，都能排除掉k-1/k（k为问题的答案有多少种输出——猜数字里面是2，称球里面是3）种可能性，而不均衡的问题总会有一个或一些答案分支排除掉的可能性要小于k-1/k。于是策略的下界就被拖累了。
四. 快速排序的具体实现 知道了快排的思想与原理，下面我们就用javascript来具体实现一下快排。
首先，定义一个quickSort函数，它的参数是一个数组。
var quickSort = function(arr) { };复制代码 然后，检查数组的元素个数，如果小于等于1，就返回。
var quickSort = function(arr) { if (arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a19a06ecfa89532ef98aaab3864d951a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f8848e303356d9000180d474c4fb973/" rel="bookmark">
			Android6.0找不到org.apache.http.Header的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用Android Studio时，采用了最新的编译版本android 6.0,但是发现在运行时，之前程序里引用的org.apache.http.Header类找不到了。通过查找发现： Android 6.0 release removes support for the Apache HTTP client. 也就是说Http Client在android 6.0 被移除了，那怎么使用呢？
解决方法： 官方文档里提供了这么一段话： If your app is using this client and targets Android 2.3 (API level 9) or higher, use the HttpURLConnection class instead. This API is more efficient because it reduces network use through transparent compression and response caching, and minimizes power consumption. To continue using the Apache HTTP APIs, you must first declare the following compile-time dependency in your build.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f8848e303356d9000180d474c4fb973/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bdf2df95c361de01dbc8fd650745219/" rel="bookmark">
			好久没写技术博了，说说最近的生活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2017.7.7正式领双证毕业，至此结束了18年的学生生涯开启人生新篇章。
现在在入职百度的路上，机器学习算法策略工程师，凤巢。
感谢哈尔滨工业大学极佳的学习氛围以及我的导师同学给我的帮助。
很幸运的，认识了我的妻子，哈工大同届，现在签了某D轮创业公司产品经理，薪水跟我持平，今天是我们结婚第40天。
感谢我的父母在大学期间给予了我同龄人中最好的物质支持，爸爸妈妈我爱你们。
最后传张老婆美照镇楼。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb00d5d4540c939558b8f3032dab9d64/" rel="bookmark">
			加密时java.security.InvalidKeyException: Illegal key size or default parameters解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java几乎各种常用加密算法都能找到对应的实现。因为美国的出口限制，Sun通过权限文件（local_policy.jar、US_export_policy.jar）做了相应限制。因此存在一些问题： ●密钥长度上不能满足需求（如：java.security.InvalidKeyException: Illegal key size or default parameters）； ●部分算法未能支持，如MD4、SHA-224等算法； ●API使用起来还不是很方便；一些常用的进制转换辅助工具未能提供，如Base64编码转换、十六进制编码转换等工具。 Oracle在其官方网站上提供了无政策限制权限文件（Unlimited Strength Jurisdiction Policy Files），我们只需要将其部署在JRE环境中，就可以解决限制问题。 下载地址： 1、Java 5.0 无政策限制文件 http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-java-plat-419418.html#jce_policy-1.5.0-oth-JPR 2、Java 6 无政策限制文件 http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html 3、Java 7 无政策限制文件 http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html 4、其他版本 无政策限制文件 http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-java-plat-419418.html
处理办法: 在官方网站下载JCE无限制权限策略文件
JDK7的下载地址: http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html
JDK8的下载地址: http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html 下载后解压，可以看到local_policy.jar和US_export_policy.jar以及readme.txt
切换到%JDK_Home%\jre\lib\security目录下，对应覆盖local_policy.jar和US_export_policy.jar两个文件。同时，你可能有必要在%JRE_Home%\lib\security目录下，也需要对应覆盖这两个文件。
配置权限文件的最终目的是为了使应用在运行环境中获得相应的权限，可以加强应用的安全性。通常，我们在应用服务器上安装的是JRE，而不是JDK。因此，这就很有必要在应用服务器的%JRE_Home%\lib\security目录下，对应覆盖这两个权限文件。很多开发人员往往忽略了这一点，导致事故发生.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/973027e4cf7597aa4806c123cbadb140/" rel="bookmark">
			STM32学习笔记一一PWM 输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 为了方便查看博客，特意申请了一个公众号，附上二维码，有兴趣的朋友可以关注，和我一起讨论学习，一起享受技术，一起成长。
1.PWM 简介
脉冲宽度调制(PWM)，是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术。即对脉冲宽度的控制。
STM32 的定时器除了 TIM6 和 7。其他的定时器都可以用来产生 PWM 输出。其中高级定时器 TIM1 和 TIM8 可以同时产生多达 7 路的 PWM 输出。而通用定时器也能同时产生多达 4路的 PWM 输出，这样，STM32 最多可以同时产生 30 路 PWM 输出！
2.相关寄存器
除了定时器章节介绍的几个寄存器（ ARR、PSC、 CR1 等） 外，还会用到 4 个寄存器（通用定时器则只需要 3 个），来控制 PWM 的输出。这四个寄存器分别是：捕获/比较模式寄存器（ TIMx_CCMR1/2）、捕获/比较使能寄存器（ TIMx_CCER）、捕获/比较寄存器（ TIMx_CCR1~4） 以及刹车和死区寄存器（ TIMx_BDTR）。
（1）捕获/比较模式寄存器（ TIMx_CCMR1/2）
该寄存器总共有 2 个， TIMx _CCMR1和 TIMx _CCMR2。TIMx_CCMR1 控制 CH1 和 2，而 TIMx_CCMR2 控制 CH3 和 4。该寄存器的各位描述如下：
寄存器分了 2层，上面一层对应输出时的设置而下面的则对应输入时的设置。模式设置位 OCxM，此部分由 3 位组成。总共可以配置成 7 种模式，我们使用的是 PWM 模式，这 3 位必须设置为110/111。这两种 PWM 模式的区别就是输出电平的极性相反。 另外 CCxS 用于设置通道的方向（输入/输出）默认设置为 0，就是设置通道作为输出使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/973027e4cf7597aa4806c123cbadb140/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6716608096280862a88268db0de397cd/" rel="bookmark">
			gson
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.cnblogs.com/jiayongji/p/5297187.html(gson把返回的string数据，转化为实体类) Json转换利器Gson之实例一-简单对象转化和带泛型的List转化 http://blog.csdn.net/lk_blog/article/details/7685169 package cardvalue.managementsystem.pojo; import com.google.gson.Gson; /** * Created by Administrator on 2017/7/7. */ public class Result&lt;T&gt; { public String type; public String result; public int code; public String getType() { return type; } public void setType(String type) { this.type = type; } public String getResult() { return result; } public void setResult(String result) { this.result = result; } public int getCode() { return code; } public void setCode(int code) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6716608096280862a88268db0de397cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1edc0967c39ac5feaf9f6113767056be/" rel="bookmark">
			浅谈竞赛中的部分树（块、点、链）【长期更新】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[toc] 本文会从链剖讲起，涉及其变形进阶，之后也会讲到DFS序，树上分块，块状树，点分治与边分治，LCT，仙人掌与仙人球，伪top_tree(AAA树)，top_tree。 本文重点讲述思维，至于例题虽会有涉及，但还是请读者自行百度（毕竟OI是不缺题的。。。。） 详略在文章中体现，如有错误，请各位读者指正。
从树链剖分讲起 其实我是先会LCT，再会链剖的，所以说比较尴尬。。。 但是自我学习了链剖后，我发现链剖给予了树上操作无限的可能性。
长链与重链 重链剖分在OI中很常见，所以这里只放出模板的博客： 感谢博主——Sdchr 长链剖分比较冷门，大部分使用在 O(1) 查询第k级祖先，与重链剖分相对的，就是把size的处理变为deep的处理。 这里也有份比较详细的blog： 感谢博主——ZZQ 这里的长链与重链的关系有些像平衡树中的重量平衡与深度平衡，各有特点，相互弥补在树上操作的不足。 重点即是重链与轻链的交替穿插，使得部分信息能够在树中快速上传，将树变得有序化，层次化就是树链剖分的本质。 长链剖分的题除上述提到外还有 BZOJ1785、BZOJ4543。 讲重点： 1.为什么要学树链剖分？ A:因为要考，lct的常数太大。链剖可以快速地与其他数据结构相关联，易出题。 2.如何学习链剖？ A:做题，做与其他数据结构、算法结合的题，特别是对于链剖在各类的树上运用。链剖模板很简单，但是如何运用是一个需要深度思考的问题。遇到链剖题千万不要裸上LCT水掉，当遇上卡常类、与一些高级算法结合类的题时就会无从下手。（说的就是blog主。。。） 3.学习链剖要到什么程度？ A:模板10~15min，重要的是快判断题目可以用链剖解决，并且知道如何解决（说白了，就是多刷点题）。
上干货（咦？长链剖分都不算干货？） 好吧。。补充长链剖分模板中的核心代码
int fa[N],depth[N],Dep[N],top[N],son[N],dfn[N],cnt; inline void dfs(int u,int f){ Dep[u]=depth[u]=depth[fa]+1,fa[u]=f; for(int p=head[u];p;p=G[p].next) if(V!=f) dfs(V,u),Dep[u]=max(Dep[u],Dep[V]); } inline void ask(int u,int fa,int z){ dfn[u]=++cnt,top[u]=z,son[u]=0; int maxv=0; for(int p=head[u];p;p=G[p].next) if(V!=fa&amp;&amp;Dep[V]&gt;maxv) maxv=Dep[son[u]=V]; if(son[u])ask(son[u],u,z); for(int p=head[u];p;p=G[p].next) if(V!=fa&amp;&amp;V!=son[u]) ask(V,u,V); } 可以看见size不见了只多出来一个新的dep。剩下的就靠自己领悟了。
合并！ 从刘rj的紫书上看到了有关树链剖分的合并，详情可以参考 %%%——idy002学长大佬。 有序链剖概念的提出给予我们一扇新世界的大门 见例题T3 link操作神来之笔，但是反过来说，难道寻常链剖做不到有序吗？不见得吧，用if特判或者再建立一棵倒着的树链剖分不就可以了吗?方法有很多不见得固定死思维，只要算法有正确性，复杂度合适，那么勇敢创新是值得借鉴的。
tips 链剖小技巧： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1edc0967c39ac5feaf9f6113767056be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7084c25eb15f6b9c6634ae8e416cdbf2/" rel="bookmark">
			ffmpeg h264转h265
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ffmpeg -i d:\soft\720p.mp4 -c:v libx265 -b:v 5000k d:\soft\myvideo.mp4
这里码率是5000k，编码是h265
h265的解码貌似用显卡上独立与渲染的硬件解码，不会对显卡造成大负担
ffmpeg -i I:\input\vrgf.mp4 -vcodec hevc -b:v 5000k I:\output\vrgf3.mp4
ffmpeg -i e:\vrgf.mp4 -vcodec hevc -b:v 5000k -keyint_min 60 -g 60 -sc_threshold 0 e:\vrgf_compress1.mp4
-keyint_min 60 -g 60 -sc_threshold 0
其中-keyint_min为最小关键帧间隔，我这里设置为60帧；-sc_threshold这个命令会根据视频的运动场景，自动为你添加额外的I帧，所以会导致你编出来的视频关键帧间隔不是你设置的长度，这是只要将它设为0，问题就得到解决了！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2f178fbfae96cc0eb5fda70dfabd1bb/" rel="bookmark">
			__attribute__((at(0X68000000)))
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 __attribute__((at(0X68000000))) 这句的主要是用法是怎么个回事
这里其实就是要搞懂2个C语言关键字就可以了. 首先,__attribute__,这个是 用来指定变量或结构位域的特殊属性,该关键字后的双括弧中的内容是属性说明。 然后是at关键字,该关键字可以用来设置变量的绝对地址,也就是你可以通过这个关键字,指定某个变量处于内存里面的某个给定的地址. 综合起来,就是设置变量处于0X68000000这个地址.
不能在函数内定义, 局部变量是存放在栈区的, 栈区由编译器自动分配释放, 不能自定义绝对地址 你可以放在函数外,作为全局变量, 把这么大的数组定义在函数内部，栈都溢出了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/639e538799911f9b6df7055500d6f364/" rel="bookmark">
			有序的数组中找到某一目标值首次出现的下标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个升序的数组，这个数组中可能含有相同的元素，并且给定一个目标值。要求找出目标值在数组中首次出现的下标。 思想：题目给出有序数组，应该想到利用二分查找来做。找到左邻居，使其值加一。利用二分查找，算法复杂度为O(logn)
#include&lt;iostream&gt; using namespace std; int findsearch(int *p, int length, int target) { int left = 0; int right = length-1 ; if (p[right - 1] &lt; target&amp;&amp;length&lt;0&amp;&amp;p==NULL) return - 1; while (left &lt; right) { int mid = (left + right) / 2; if (p[mid] &lt; target) left = mid + 1; else right = mid; } if (p[left] == target) return left; else return -1; } int main() { int p[] = { 4,6,6,6,6 }; int length = 5; int target =6; int index = findsearch(p, length, target); cout &lt;&lt; index &lt;&lt; endl; } 类似题目： 找到有序数组中某一目标值在数组中的开始下标以及终止下标以及目标值出现的次数。也可以用下面的方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/639e538799911f9b6df7055500d6f364/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cf4188a384f2feaea2ab2b8906311a5/" rel="bookmark">
			机器学习基础-Knn分类器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题概述：K 近邻算法是分类数据最简单有效的算法，它采用基于实例的学习方法。简单地说，它采用测量不同样本之间距离的方法进行分类。它的工作原理是:存在一个样本数据集合，也称为训练样本集，并且样本集中的每个数据都有标签，即我们知道每个数据所属的分类。输入没有标签的新数据后，将新数据的每个特征与样本集中数据的对应特征进行比较，然后算法 取样本集中特征最相似数据(最近邻)的分类标签。一般来说，我们只选择样本数据集中前 K个最相似的数据，这就是 K 近邻算法中K 的出处。最后，选择K 个最相似数据中出现次数最多的分类，作为新数据的分类。
由以上述可得知，使用 K近邻算法对某个新数据进行分类的伪代码如下:
(1)、计算训练样本集中的各样本与当前数据之间的距离;
(2)、按照距离递增顺序排序;
(3)、选取与当前数据距离最小的K 个样本;
(4)、确定前K 个样本所在类别的出现频率;
(5)、返回前K 个样本出现频率最高的类别作为当前数据的预测类别。要求设计和实现类KnnNumber，构造一个使用K 近邻分类器的手写识别系统，该系统可以识别数字0 到9。需要识别的数字已经处理成具有相同的色彩和大小:使用文本格式表示的32 像素*32像素黑白图像(0/1二值图像)。数据集在 digits.zip中，其中目录 trainingDigits包含了训练样本集，其中包含了大约 2000个样本数据，每个数据的文件名表明了它的标签(0~9中的某个数字)，每个数字大约有 200个样本数据;目录 testDigits中包含了大约 900个测试数据。请合理设计 KnnNumber的数据成员和成员方法，以实现算法的各个步骤。将 K 取值
为[3, 9]之间的一个整数，找出分类准确率最高的K 值。 提示:
(1)、计算距离时采用欧几里得距离;
(2)、可将每个数字图像文件转换为1*1024 的一维数组，于是整个训练样本集可以表示为2000*1024 的二维数组。
声明静态方法trainAllDate（），读取digits／trainingDigits目录下的各个文件，声明int[]型容器trainDigit用来存放各个训练样本数据，声明Integer类型容器存放各个训练样本标签。声明int[]容器testDigit存放各个测试数据，声明Integer类型容器testAnswer存放各个测试标签。声明Distance类，三个数据成员，分别为dis表示各个训练样本到某个测试样本的欧几里得距离的平方，n为各个训练样本的编号，ans为各个训练样本的标签。遍历整个testDigit，对每个测试数据，用一个Distance类型的容器存放它到各个样本数据的欧几里得距离的平方，声明Mycomparator实现了Comparator接口，实现了按Distance类型中的dis由小到大排序。最后取出前k个Distance实例的样本标签，就作为对该测试数据的预测结果。用一个Integer类型的容器TAnswer存放对各个测试数据的预测结果。最后与给出的测试标签相比较，计算出Knn算法预测的正确率。
在实验中，最开始采用了LinkedList容器存放样本数据，然后用索引进行遍历，速度慢的无法想象，后来改成ArrayList解决了该问题。
ArrayList是实现了基于动态数组的数据结构,LinkedList基于链表的数据结构。
当k=3时，946个测试数据中有934个预测正确，有最大的正确率0.9873150105708245。
运行结果：
k = 3
correctcase=934
sumcase=946
correctrate=0.9873150105708245
k = 4
correctcase=930
sumcase=946
correctrate=0.9830866807610994
k = 5
correctcase=927
sumcase=946
correctrate=0.9799154334038055
k = 6
correctcase=924
sumcase=946
correctrate=0.9767441860465116
k = 7
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cf4188a384f2feaea2ab2b8906311a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d286528099b71b0990a1a1ecaa4a8bfb/" rel="bookmark">
			关于解决No service of type Factory available in ProjectScopeServices的错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在项目导入时，出现了如下错误：
打开文件锁定位置，发现好像是plugin出现了问题：
在google一下后，发现相关issue：http://www.jianshu.com/p/c4f4894ad215
将问题定位在根目录的build.gradle
只需要将classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'更新到1.4.1就解决问题了，算是对自己一个总结，希望能够帮助遇到相同问题的朋友。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dff778f1bcdef203d147b34a638335c/" rel="bookmark">
			sqlyog安装详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mysql安装步骤请点击：Mysql5.6安装详细步骤
我的sqlyog百度云链接（永久有效）：http://pan.baidu.com/s/1i5j4GG9
密码获取请点击：获取密码
注册码序列号（Code）：8d8120df-a5c3-4989-8f47-5afc79c56e7c
如果使用sqlyog登陆报错的话请参考https://blog.csdn.net/lihua5419/article/details/80394716 感谢您的阅读。如果感觉文章对您有用，麻烦您动动手指点个赞，以资鼓励。谢谢！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a180afff7e4bed04d6132ce8a52ed654/" rel="bookmark">
			Required String parameter is not present
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		页面报Required String parameter ‘loanOrderNbr’ is not present解决办法 问题描述： 前面代码（angularjs） var loanOrderNumber = $routeParams.loanOrderNumber; $scope.saveButton = true; $http.get("/test/business/order/viewDetail",{ params : { 'loanOrderNbr' : loanOrderNbr } }).success(function(request,status){ // }).error(function (data, status) { // }); 后台代码(spring mvc) //查看数据 @RequestMapping(value = "/viewDetail") @ResponseBody public AtResponse detail(@RequestParam(name = "loadOrderNbr", required = true) String loadOrderNbr) { Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;(); AtResponse&lt;TxnAcct&gt; resp = new AtResponse(System.currentTimeMillis()); //..... return resp; } 页面报错信息 :8080/test/business/order/viewDetail?loanOrderNbr=201706091042631 Failed to load resource: the server responded with a status of 400 (Bad Request) 当时以为是前面angularjs代码写得有问题，然而仔细对比其他功能的写法，发现没有什么区别，只是传的参数不一样而矣，非常迷惑，不解。后台也不报错（没有输出spring日志），然后将请求链接直接在浏览器中访问： http://localhost:9770/test/business/order/viewDetail?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a180afff7e4bed04d6132ce8a52ed654/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/792793b705e342d508b3c6900144862e/" rel="bookmark">
			SQLServer创建索引的5种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前期准备：
create table Employee ( ID int not null primary key, Name nvarchar(4), Credit_Card_ID varbinary(max)); --- 小心这种数据类型。 go 说明：本表上的索引，都会在创建下一个索引前删除。
创建聚集索引 方法 1、 ALTER TABLE table_name ADD CONSTRAINT cons_name priamry KEY(columnname ASC|DESC,[.....]) WITH (drop_existing = ON); ALTER TABLE employee ADD CONSTRAINT pk_for_employee PRIMARY KEY CLUSTERED (id); go 这个是一种特别的方法，因为在定义主键的时候，会自动添加索引，好在加的是聚集索引还是非聚集索引是我们人为可以控制的。
通过sp_helpindex 可以查看表中的索引
execute sp_helpindex @objname = 'Employee'; go 注意:这个索引是无法删除的，不信！ 你去删一下
drop index Employee.PK__Employee__3214EC277D95E615; go 方法 2、 create clustered index ix_name on table_name(columnName ASC|DESC[,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/792793b705e342d508b3c6900144862e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/704490a8183d3dca6d145394d4674747/" rel="bookmark">
			mysql命令行的导入导出sql,txt,excel（都在linux或windows命令行操作）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql导入导出sql,txt,excel
首先我们通过命令行进入到mysql安装目录的bin目录下，比如我输入的命令行为：
d:
cd D:/wamp/bin/mysql/mysql5.6.17/bin
一、导入导出sql( linux或windows命令行方式 )
mysql采用（linux或者windows）命令行方式,导入导出数据库，数据表，字段,
mysql的bin中提供了两个指令，mysqldump以及resource,分别用于导出和导入。
(1)导出sql
mysqldump-u root -p 数据库名&gt; question.sql 导出数据库(输入后会让你输入进入MySQL的密码)
mysqldump-u root -p 数据库名 数据表名&gt; question.sql 导出数据表(输入后会让你输入进入MySQL的密码)
mysql-u root -p 数据库名 -e "select 字段1,字段2,字段3 from 数据表名 order by 字段1 asc into outfile'D:/question.sql'";
导出数据表的某些指定字段(输入后会让你输入进入MySQL的密码)
(2)导入sql
source 导入的文件名;
比如我要导入我刚导出的atm.sql数据文件： source D:/question.sql;
二、导入导出txt或excel（sql语句方式）
----------建议导入和导出都用excel----------
1、导入将excel存储为txt,然后用记事本打开txt,将该txt另存为utf8编码的txt文件
2、导出txt,然后另存txt文件为unicode编码，再修改后缀.txt为.xls
mysql –uroot –p 输入数据库密码
use 数据库名
(1) 导出txt或者excel
select `title`,`word_answer`,`right_answer`,`qgid`
into outfile "C:/Users/Administrator/Desktop/output.txt" //lines terminated by"/r/n" 导成txt或者excel这句不要
from `xy_question` where `id` in (1,2,3);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/704490a8183d3dca6d145394d4674747/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02f2f069bb3320dd093324c4504c0b3c/" rel="bookmark">
			当storm报错：Could not find leader nimbus from seed hosts [&#34;127.0.0.1&#34;]解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决方式： 删除zookeeper下的storm节点数据，重启zookeeper，重新发布topology到storm集群即可。 zk操作方式： 首先到zookeeper目录/bin下面，执行
./bin/zkCli.sh -server [ip]:[port] 例如：
./bin/zkCli.sh -server 192.168.0.10:2181 如果在本机且端口为默认的2181，可直接输入
./bin/zkCli.sh 然后输入命令：
ls / 显示
[zookeeper, storm] 执行命令删除：
rmr /storm 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ffbf207e4df096b2ea4c11cca0ffc68/" rel="bookmark">
			关于使用spring mvc时出现 HTTP Status 400 - Required String parameter &#39;xx&#39; is not present
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先记录一下这个错误 1、后台使用sring mvc的@RequestParam接受form表单提交的两个参数 2、使用Postman测试接口，可以看到在使用默认的form-data类型时出现了 HTTP Status 400 - Required String parameter ‘xx’ is not present 这个错误 3、更换成x-www-form-urlencoded类型时返回成功 4、如果使用@RequestBody接收参数，同@RequestParam一样，都是需要设置x-www-form-urlencoded类型才能正确返回。
再来分析一下这个错误的原因 1、先来看一下@RequestBody和@RequestParam的区别
@RequestParam A） 常用来处理简单类型的绑定，通过Request.getParameter() 获取的String可直接转换为简单类型的情况（由String到简单类型的转换操作由ConversionService配置的转换器来完成）；因为使用request.getParameter()方式获取参数，所以可以处理get方式中queryString的值，也可以处理post方式中 body data的值。B）用来处理Content-Type: 为application/x-www-form-urlencoded编码的内容，提交方式GET、POST。(不设置这个属性，这就是默认值)C) 该注解有两个属性： value、required； value用来指定要传入值的id名称，required用来指示参数是否必须绑定。 在方法参数里面如是：public @ResponseBody JsonResultgetPublishedToposByConnStreamId(@RequestParam(value = “streamId”, required = false) String streamId) {} @RequestBody
A) GET、POST方式提时， 根据request header Content-Type的值来判断:application/x-www-form-urlencoded， 可选（即非必须，因为这种情况的数据@RequestParam,@ModelAttribute也可以处理，当然@RequestBody也能处理）；multipart/form-data, 不能处理（次类型多用来上传文件类型—即使用@RequestBody不能处理这种格式的数据,@RequestParam这个却是可以处理的。）；其他格式， 必须（其他格式包括application/json, application/xml等。这些格式的数据，必须使用@RequestBody来处理）；B) PUT方式提交时， 根据request header Content-Type的值来判断:application/x-www-form-urlencoded， 必须；multipart/form-data, 不能处理；其他格式， 必须；说明：request的body部分的数据编码格式由header部分的Content-Type指定； 总结： @RequestBody这个一般处理的是在ajax请求中声明contentType: “application/json; charset=utf-8”时候。也就是json数据或者xml(我没用过这个，用的是json) @RequestParam这个一般就是在ajax里面没有声明contentType的时候，为默认的urlencode格式时，用这个。
2、spring mvc其他的参数绑定的注释 handler method 参数绑定常用的注解,一般根据他们处理的Request的不同内容部分分为四类：（主要讲解常用类型）
A、处理requet uri 部分（这里指uri template中variable，不含queryString部分）的注解： @PathVariable;B、处理request header部分的注解： @RequestHeader, @CookieValue;C、处理request body部分的注解：@RequestParam, @RequestBody;D、处理attribute类型是注解： @SessionAttributes, @ModelAttribute; 3、关于http中的Content-Type MediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ffbf207e4df096b2ea4c11cca0ffc68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34ea377b0f623c53635c9a24e0736751/" rel="bookmark">
			DataTable插件报错：Uncaught TypeError: Cannot read property &#39;style&#39; of undefined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DataTable插件报错：Uncaught TypeError: Cannot read property 'style' of undefined 原因：table 中定义的列和aoColumns数据表的项数量对不上：比如下面： &lt;table class="table dataTable "&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;列1&lt;/th&gt; &lt;th&gt;列2&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;/tbody&gt; &lt;/table&gt; "aoColumns": [ { "mDataProp": "uuid", "sDefaultContent": "", "fnRender": function (obj) { var sReturn = "&lt;input type='checkbox' name='check' value='" + obj.aData.uuid + "' /&gt;"; return sReturn; } }, { "mDataProp": "warehouseName", "sDefaultContent": "", "sTitle": "&lt;aebiz:showTitle titleId="productsuresalestock.m.warehouseName"/&gt;" }, { "mDataProp": "warehouseNo", "sDefaultContent": "", "sTitle": "&lt;aebiz:showTitle titleId="productsuresalestock.m.warehouseNo"/&gt;" }] 关注本人微信公众号，目前已经发布了完整Docker教程，未来继续努力分享更多资源给您，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cb811e06e21eff5b3379d72810e485d/" rel="bookmark">
			将Office（如：Word、Excel、PPT 等）文件转PDF（通过OpenOffice实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里简单介绍下OpenOffice
OpenOffice.org 是一套跨平台的办公室软件套件，能在Windows、linux、MacOS X (X11) 和 Solaris 等操作系统上执行。它与各个主要的办公室软件套件兼容。 OpenOffice.org 是自由软件，任何人都可以免费下载、使用及推广它。 需要注意: Java环境下操作OpenOffice 要使用 JodConverter。 需要在服务器中安装OpenOffice 点击下载JodConverter
OpenOffice工具大家可以去官网下载，文件比较大我这里没办法分享
安装好OpenOffice跟JodConverter的jar包导入后，就开始编码吧。
下面我直接贴代码
import java.io.File; import org.artofsolving.jodconverter.OfficeDocumentConverter; import org.artofsolving.jodconverter.office.DefaultOfficeManagerConfiguration; import org.artofsolving.jodconverter.office.OfficeManager; import org.springframework.util.StringUtils; /** * 这是一个工具类，主要是为了使Office2003-2007全部格式的文档(.doc|.docx|.xls|.xlsx|.ppt|.pptx) * 转化为pdf文件 * Office2010的没测试 * @author ZhouMengShun */ public class Office2PDF { /** * 使Office2003-2007全部格式的文档(.doc|.docx|.xls|.xlsx|.ppt|.pptx) 转化为pdf文件 * @param inputFilePath 源文件路径,如："D:/论坛.docx" * @return */ public static File openOfficeToPDF(String inputFilePath) { return office2pdf(inputFilePath); } /** * 根据操作系统的名称，获取OpenOffice.org 4的安装目录&lt;br&gt; * 如我的OpenOffice.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cb811e06e21eff5b3379d72810e485d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/754cfcf3bcca8508c97b7e3764fc1f72/" rel="bookmark">
			机器学习实战-K近邻算法（KNN）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、算法概述
最简单的分类器是把全部的训练数据所对应的特征和标签都记录下来，当测试数据的特征和某个训练样本的特征完全匹配时，便可以给测试数据打上该训练样本的标签，但是我们无法保证所有的测试对象都能在训练数据集中找到与之唯一对应的标签，可能该标签不存在或者存在多个不同的标签，基于这些问题产生了K近邻算法（KNN）。
2、工作原理
存在一个样本数据集，并且每个样本数据都存在标签（称作训练数据集），当输入不带标签的数据后，将新数据和训练数据集的特征进行比较，如果新数据与特征空间中的k个训练样本属于同一个类别，则该样本也属于这个类别，通常K的取值不大于20。
3、算法原理
对未知标签的数据集（测试数据集）中的每个点依次执行如下的操作；
1) 计算已知类别数据集中的点与当前点之间的距离；2)按照距离递增次序排序 ；3) 选取与当前点距离最小的K个点；4) 确定前K个点所在类别的出现频率；5) 返回前K个点出现频率最高的类别标签作为当前点的预测分类。
4、实战
1、对未知数据进行分类
from numpy import * import operator # 训练样本数据 def createDataSet(): group = array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]]) labels = ["A", "A", "B", "B"] return group, labels def classify0(inX, dataSet, labels, k): """ # int_x, 分类数据 # data_set, 训练样本集 # labels, 标签向量 # K, 用于选择最近邻居的数目 """ # dataSet训练数据的行数 dataSetSize = dataSet.shape[0] # 将数据拓展成和训练数据相同行数和列数的矩阵。计算差值矩阵 diffMat = tile(inX, (dataSetSize, 1)) - dataSet # 差值矩阵的平方 sqDiffMat = diffMat ** 2 # 计算矩阵中每一行元素之和,axis=1表示矩阵跨列求和 sqDistance = sqDiffMat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/754cfcf3bcca8508c97b7e3764fc1f72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c9bf95f80e4efb1968b7ff247ce624b/" rel="bookmark">
			还是安利几本书，关于操作系统和计算机组成原理的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-《编码》这本书从电学的基本原理（初中物理的水平）讲到操作系统构建等等，可以解开很多疑惑。 -《深入理解计算机操作系统》把计算机系统说了个透，但属于入门书籍，看后还是有很多问题未解决的。 -《穿越计算机的迷雾》和《编码》类似从浅显道理出发，解释现代计算机的构建 -《数字设计原理与实践》属于底层数字电路设计的书，主要用于集成电路，很偏向底层的书籍，里面所讲到的能用到都是大牛啊。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fea7aa8f488470feab462499adc04b50/" rel="bookmark">
			echarts图表坐标刻度过多如何设置刻度间隔（interval）以及配置说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; http://www.sxrczx.com/pages/www.stepday.com/topic/883.html
xAxis.axisLabel.interval number, Function [ default: 'auto' ] 坐标轴刻度标签的显示间隔，在类目轴中有效。 默认会采用标签不重叠的策略间隔显示标签。 可以设置成 0 强制显示所有标签。 如果设置为 1，表示『隔一个标签显示一个标签』，如果值为 2，表示隔两个标签显示一个标签，以此类推。 可以用数值表示间隔的数据，也可以通过回调函数控制。回调函数格式如下： (index:number, value: string) =&gt; boolean 第一个参数是类目的 index，第二个值是类目名称，如果跳过则返回 false。
转载于:https://my.oschina.net/yiqifendou/blog/920418
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90b950de45bfd4d751679b3193a3ee75/" rel="bookmark">
			关于Markdown里的图片并排显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Markdown里的图片并排显示 最近写文章的时候发现，在markdown里插入一些很长的图片的时候，会显得很不好看，于是去查了一下如何实现markdown里图片的并排显示，参考了下面博客内的内容，方法如下：
单张居中显示： &lt;center&gt; &lt;img src="http://dreamofbook.qiniudn.com/Zero.png"&gt; &lt;/center&gt; OR &lt;figure&gt; &lt;img src="http://xxx.jpg"&gt; &lt;/figure&gt; 固定图片宽度/高度： &lt;img src="http://xxx.jpg" title="Logo" width="100" /&gt; 宽度是 Width，高度是 High。Title 为图片描述。
两张并排显示： &lt;figure class="half"&gt; &lt;img src="http://xxx.jpg"&gt; &lt;img src="http://yyy.jpg"&gt; &lt;/figure&gt; 三张并排显示： &lt;figure class="third"&gt; &lt;img src="http://xxx.jpg"&gt; &lt;img src="http://yyy.jpg"&gt; &lt;img src="http://zzz.jpg"&gt; &lt;/figure&gt; 固定宽度，并排显示并居中 就是把上面的几个例子和起来，下面给出代码
&lt;center class="half"&gt; &lt;img src="http://xxx.jpg" width="300"/&gt; &lt;img src="http://yyy.jpg" width="300"/&gt; &lt;/center&gt; 参考资料 上面的基本是我在下面这个博客上看到的，非常不错，推荐给大家 Markdown 简明语法参考
以上，所有 2017/6/12
转载于:https://www.cnblogs.com/wmn7q/p/7265488.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b9a3e21a49bc9c3995d084ea6cb4192/" rel="bookmark">
			SpringBoot事务管理：声明式事务和编程式事务。将Service层的事务执行结果传递出去
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在SpringBoot中使用事务很简单，这一篇不是为了讲事务，主要是讲一下一个工具类，将需要加入事务的Service层代码作为参数传递出去并返回事务的执行结果（成功和回滚）。
声明式事务 在SpringBoot中声明式事务最常见，就是把需要事务的方法用@Transactional标注一下就行了，这个一般用在Service层。标注后该方法就具备了事务的能力，出错了会自动回滚。 在大部分场景下，该方法已经够用了。 编程式事务 在有些场景下，我们需要获取事务的状态，是执行成功了还是失败回滚了，那么使用声明式事务就不够用了，需要编程式事务。 在SpringBoot中，可以使用两种编程式事务。 一个是TransactionTemplate 看名字就知道，又是一个类似于RedisTemplate的模板类。使用很简单，是一个回调。 transactionTemplate.execute(new TransactionCallback() { @Override public Object doInTransaction(TransactionStatus transactionStatus) { try { userRepository.save(user); for (int i = 0; i &lt; 10; i++) { Post post = new Post(); if (i == 5) { post.setContent("dddddddddddddddddddddddddddddddddddddddddddd"); } else post.setContent("post" + i); post.setWeight(i); postService.save(post); } } catch (Exception e) { transactionStatus.isRollbackOnly(); e.printStackTrace(); } return null; } });在doIntransaction里做逻辑处理即可。如果出异常了，就执行isRollbackOnly方法进行回滚。感觉这个比较鸡肋，还不如注解事务来的方便，也不能把事务执行结果同步返回回去。 二是TransactionManager TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition()); try { for (int i = 0; i &lt; 10; i++) { Post post = new Post(); if (i == 5) { post.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b9a3e21a49bc9c3995d084ea6cb4192/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77093a49ab4eef3dbeac7ae107cc70a0/" rel="bookmark">
			TREAP示例代码（排序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; using namespace std; struct node{ int v,w; node *f,*l,*r; node(){ v=0;w=rand();f=l=r=NULL; } }; node *root; void zig(node *h,node *p){ node *t=h-&gt;f; h-&gt;l=p-&gt;r;	if(p-&gt;r)p-&gt;r-&gt;f=h; p-&gt;r=h;	h-&gt;f=p; if(t){ if(h==t-&gt;l)t-&gt;l=p; else t-&gt;r=p; }else root=p; p-&gt;f=t; } void zag(node *h,node *p){ node *t=h-&gt;f; h-&gt;r=p-&gt;l;	if(p-&gt;l)p-&gt;l-&gt;f=h; p-&gt;l=h;	h-&gt;f=p; if(t){ if(h==t-&gt;l)t-&gt;l=p; else t-&gt;r=p; }else root=p; p-&gt;f=t; } void insert(node *h,node *p){ if(p-&gt;v&gt;h-&gt;v){ if(h-&gt;r==NULL){ h-&gt;r=p;	p-&gt;f=h; while(p-&gt;f!=NULL &amp;&amp; p-&gt;w&lt;p-&gt;f-&gt;w){ if(p==p-&gt;f-&gt;l)zig(p-&gt;f,p); else zag(p-&gt;f,p); } }else insert(h-&gt;r,p);	}else{ if(h-&gt;l==NULL){ h-&gt;l=p;p-&gt;f=h; while(p-&gt;f!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77093a49ab4eef3dbeac7ae107cc70a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47cbdccce34b8290274d02f29ba67636/" rel="bookmark">
			Tomcat8 目录结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bin : Tomcat8.0-doc对这个目录的简单说明为： /bin - Startup, shutdown, and other scripts. The .sh files (for Unix systems) are functional duplicates of the .bat files (for Windows systems). Since the Win32 command-line lacks certain functionality, there are some additional files in here.
即该目录存放了tomcat启动、关闭以及其他的一些脚本
conf ： /conf - Configuration files and related DTDs. The most important file in here is server.xml. It is the main configuration file for the container.
存放Tomcat服务器的各种全局配置文件，其中包括server.xml（Tomcat的主要配置文件）、tomcat-users.xml和web.xml等配置文件
server.xml：配置整个服务器信息。例如修改端口号，添加虚拟主机等；tomcatusers.xml：存储tomcat用户的文件，这里保存的是tomcat的用户名及密码，以及用户的角色信息。可以按着该文件中的注释信息添加tomcat用户，然后就可以在Tomcat主页中进入Tomcat Manager页面了；web.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47cbdccce34b8290274d02f29ba67636/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccd653ca44def020b2ff2469f5643e78/" rel="bookmark">
			Python运行机制以及pyc/pyo文件的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：知乎用户 链接：https://www.zhihu.com/question/30296617/answer/112564303 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
作为Python爱好者，需要了解.py脚本的基本运行机制及特性： 在很多工作上Python的运行流程基本上取决于用户，因此源码不需要编译成二进制代码（否则无法实现大部分贴近用户的特性），而直接从源码运行程序。当我们运行python文件程序的时候，Python解释器将源码转换为字节码，然后再由解释器来执行这些字节码。因此总的来说，它具有以下三条特性
源码距离底层更远（根据官方文档的解释。不说，你们也感觉得到）(。・`ω´・)运行时都需要生成字节码，交由虚拟机执行。（你们问我虚拟机在哪儿？！你们也不看看各自都是用什么软件执行的！没错，就是解释器，别和我说是IDLE啊。虚拟机具体实现了由switch-case语句构成的框架函数PyEval_EvalFrameEx，刚刚说的字节码就是这货执行的）每次执行脚本，虚拟机总要多出加载和链接的流程。（所以呢，相比于编译型语言就有点慢了。这与“有丝分裂间期”一样，准备东西也要花时间啊！） 那么，有人要问了：“不是说，运行时总要生成字节码么！那，字节码都去哪儿了？” 咳咳，别急！容我先说说，虚拟机它是怎么执行脚本的（咕噜咕噜喝杯水…）：
完成模块的加载和链接；将源代码翻译为PyCodeObject对象（这货就是字节码），并将其写入内存当中（方便CPU读取，起到加速程序运行的作用）；从上述内存空间中读取指令并执行；程序结束后，根据命令行调用情况（即运行程序的方式）决定是否将PyCodeObject写回硬盘当中（也就是直接复制到.pyc或.pyo文件中）；之后若再次执行该脚本，则先检查本地是否有上述字节码文件。有则执行，否则重复上述步骤。 你看！在我们点击（或输入命令）运行脚本，并悠闲地喝咖啡时，“人家”虚拟机做了这么多的事情。不过，你有没有发现.pyc或.pyo文件是否生成，是取决于我们如何运行程序的（虽然我们不知道要怎么做（ง •̀_•́）ง ）。 同样，有人会吐槽：“哼！为什么不直接生成这些文件，这样来得不是‘更快、更高、更强’！” 其实，虚拟机也是讲究效率的。毕竟对于比较大的项目，要将PyCodeObject写回硬盘也是不可避免地要花些时间的，而且它又不知道你是不是也就只执行一次，之后就对刚刚跑完的脚本“弃之不顾”了呢。不过，它其实也有贴心的一面。比如，
若你在命令行直接输入“python path/to/projectDir”（假设projectDir目录含有“main.py”文件，以及其他将要调用的模块），那么程序运行结束后便自动为当前目录下所有的脚本生成字节码文件，并保存于本地新文件夹pycache当中。（这也有可能是IDE写小项目时自动生成.pyc文件的原因，不过问题描述略微暧昧。详情参见上面知乎问题板块） 或者是，在命令行输入“python path/to/projectDir/main.py”，则生成除main.py外脚本的字节码文件。不过总的来说，上述这两种行为都大大缩短了项目运行前的准备时间（毕竟分工明确的程序，规模应该不会太小，复用率也不会太低。除非吃饱了撑着，搞出这么多事情(Θ皿Θメ)）
模块在每次导入前总会检查其字节码文件的修改时间是否与自身的一致。若是则直接从该字节码文件读取内容，否则源模块重新导入，并在最后生成同名文件覆盖当前已有的字节码，从而完成内容的更新（详见import.py）。这样，就避免了修改源代码后与本地字节码文件产生冲突（当然，设计者也不会这么傻。╮(￣▽￣”)╭）。 若想优化生成字节码，应注意这两点：
.pyc文件是由.py文件经过编译后生成的字节码文件，其加载速度相对于之前的.py文件有所提高，而且还可以实现源码隐藏，以及一定程度上的反编译。比如，Python3.3编译生成的.pyc文件，Python3.4就别想着去运行啦！→_→.pyo文件也是优化（注意这两个字，便于后续的理解）编译后的程序（相比于.pyc文件更小），也可以提高加载速度。但对于嵌入式系统，它可将所需模块编译成.pyo文件以减少容量。 但总的来说，作用上是几乎与原来的.py脚本没有区别的，也就是“然并卵 ”（当然，并非毫无作用。比如，我个人觉得用处最大的地方就是防止别人偷看我的代码。(:з」∠)毕竟.py源文件是直接以源码的形式呈现给大家的）。╮(╯▽╰)╭ 呃…这么说，好像又有点自相矛盾的赶脚。
在所有的Python选项中：
-O，表示优化生成.pyo字节码（这里又有“优化”两个字，得注意啦！）-OO，表示进一步移除-O选项生成的字节码文件中的文档字符串（这是在作用效果上解释的，而不是说从-O选项得到的文件去除）-m，表示导入并运行指定的模块 对此，我们可以使用如下格式运行.py文件来生成.pyc文件（以下调用均假设/path/to目录含有.py脚本）：
python -m py_compile /path/to/需要生成.pyc的脚本.py #若批量处理.py文件 #则替换为/path/to/{需要生成.pyc的脚本1,脚本2,...}.py #或者/path/to/ 其效果等效于如下代码：
import py_compile py_compile.compile(r'/path/to/需要生成.pyc的脚本.py') #同样也可以是包含.py文件的目录路径 #此处尽可能使用raw字符串，从而避免转义的麻烦。比如，这里不加“r”的话，你就得对斜杠进行转义 py_compile是Python的自带模块，这里面就两个函数（看到这个，我笑了(๑•́ ₃ •̀๑)噗噗）。其下的py_compile.compile(file[, cfile[, dfile[, doraise]]])可将.py文件编译生成.pyc文件（默认），对应的参数解释如下
file，表示需要生成.pyc或.pyo文件的源脚本名（字符串）；cfile，表示需要生成.pyc或.pyo文件的目标脚本名。呃…好像没有区别（＞﹏＜） ，也就是源脚本—–[巴拉拉赐予你力量！编译！]（ *￣▽￣）o ─═≡※:☆—–&gt;目标脚本。当然，它默认是以.pyc为扩展名的路径名的字符串（呼…好长）。此外，当且仅当所使用的解释器允许编译成.pyo文件，才能以“.pyo”结尾。这也就是我上面为什么会在函数功能解释上加上“（默认）”这两个字的原因。dfile，表示编译出错时，将报错信息中的名字“file”替换为“dfile”。doraise，设置是否忽略异常。若为True，则抛出PyCompileError异常；否则直接将错误信息写入sys.stderr（什么！不知道sys.stderr？！温馨提示：sys.stderr是Python自带的标准错误输出） （╯’ - ‘)╯︵ ┻━┻ （掀桌子） ┬─┬ ノ( ’ - ‘ノ) （摆好摆好） (╯°Д°)╯︵ ┻━┻(再TA喵掀一次） 另外，生成.pyo文件的格式调用如下：
python -O -m py_compile /path/to/需要生成.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccd653ca44def020b2ff2469f5643e78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3546b680d362e7000d1fde79b2fbd758/" rel="bookmark">
			全国1977——2016年参加高考人数和录取率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序号
时间(年)
参加高考人数(万人)
录取人数(万人)
录取率(%)
备注（高校数）
1
1977
570
27
5%
404
2
1978
610
40.2
7%
598
3
1979
468
28
6%
633
4
1980
333
28
8%
675
5
1981
259
28
11%
704
6
1982
187
32
17%
715
7
1983
167
39
23%
805
8
1984
164
48
29%
902
9
1985
176
62
35%
1016
10
1986
191
57
30%
1054
11
1987
228
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3546b680d362e7000d1fde79b2fbd758/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d6d4f833423f696a3453e16e00c17e9/" rel="bookmark">
			ECharts图表中修改每个category的颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要修改每个类别的显示颜色，需要给每个数据项配置 具体方法为：在series里面给data数组的每个元素设置itemSytle就可以了
var myTestCharts = echarts.init(document.getElementById('myTest')); option如下：
myOption = { title : { text: '场馆内各类人数量' }, tooltip : { trigger: 'axis' }, xAxis : [ { type : 'value', axisLabel : { formatter: '{value} 人' } } ], yAxis : [ { type : 'category', data : ['男人','女人','老人','小孩'] } ], series : [ { type:'bar', data:[ { value:70, itemStyle:{ normal:{color:'blue'} } }, { value:45, itemStyle:{ normal:{color:'purple'} } }, { value:16, itemStyle:{ normal:{color:'yellow'} } }, { value:91, itemStyle:{ normal:{color:'red'} } } ] } ] }; 将图表显示出来：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d6d4f833423f696a3453e16e00c17e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f618d81dd2aaf7876a99d9274f4c266/" rel="bookmark">
			Python 实现字符串反转的四种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是实现python字符串反转的四种方法：
1. 切片 def rev(s):
return s[::-1]
这是采用切片的方法，设置步长为-1，也就是反过来排序。
这种方法是最简洁的，也是最推荐的。
2. 这种方法与切片类似，不过比较麻烦 def rev(s):
str0 = ”
l = len(s)-1
while l &gt;= 0:
str0 += s[l]
l -= 1
return str0
这种方法是先设置一个str0的空变量，然后在s中从后往前取值，然后追加到str0中。
3.列表 def rev(s):
a = list(s)
a.reverse()
return ”.join(a)
这种方法是采用列表的reverse方法，先将s转换为列表，然后通过reverse方法反转，然后在通过join连接为字符串。
注意：这里注意区分列表的reverse和sort（或sorted）方法：
reverse是把列表方向排序;
sort(reverse=True)是按照某种顺序方向排序。
example:
&gt;&gt;&gt; a=['a','c','b','d']
&gt;&gt;&gt; b=['a','c','b','d']
&gt;&gt;&gt; a.sort(reverse=True)
&gt;&gt;&gt; b.reverse()
&gt;&gt;&gt; a
['d', 'c', 'b', 'a']
&gt;&gt;&gt; b
['d', 'b', 'c', 'a']
4. reduce def rev(s):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f618d81dd2aaf7876a99d9274f4c266/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c674f3f0e4ca9d8fedc582d82b79324b/" rel="bookmark">
			使用requests爬取豆瓣电影top250
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天使用requests获取豆瓣电影top250的内容，先说下思路
表设计获取每一页的内容获取当前页每一部电影对应的链接
##获取所有页的url
for i in range(10): top_url = "https://movie.douban.com/top250?start={0}&amp;filter=".format(i*25) ##获取前页每一部电影对应的链接
all_title_urls = selector.css(".grid_view li .hd a::attr(href)").extract() for url in all_title_urls: print(url) ##获取当前页的字段值
###获取排行次数
selector.css('.top250 .top250-no ::text').extract()[0] 这里由于我们需要以整形来保存，所以需要使用正则表达式过滤前面的字符
match_obj = re.match(".*No\.(\d+).*", top_number) if match_obj: top_number = match_obj.group(1) ###获取电影名称
selector.css('#content h1 span::text').extract()[0] ###获取导演名称
selector.css('#info .attrs a::text').extract()[0] ###获取电影评分
selector.css('#interest_sectl .ll.rating_num::text').extract()[0] ###获取电影描述
selector.css('#link-report span[property=v\:summary]::text').extract()[0] ##完整代码
# -*- coding: utf-8 -*- import requests import re from scrapy.selector import Selector import MySQLdb conn= MySQLdb.connect( host='localhost', port=3306, user='root', passwd='root', db='articlespider', charset='utf8', use_unicode=True) cursor = conn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c674f3f0e4ca9d8fedc582d82b79324b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de16ced797eb17b6d131cb4a91fd18c1/" rel="bookmark">
			设计模式-策略模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式-策略模式 概念 策略模式定义了一系列算法，所有这些算法从抽象概念上是相同的，只是实现不同，可以以相同方式（如相同签名的方法）调用；减少客户端掌握方法的数量以及减少各自算法类已使用算法类之间的耦合 优点 1、 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码转移到父类里面，从而避免重复的代码。 2、 策略模式提供了可以替换继承关系的办法。继承可以处理多种算法或行为。如果不是用策略模式，那么使用算法或行为的环境类就可能会有一些子类，每一个子类提供一个不同的算法或行为。但是，这样一来算法或行为的使用者就和算法或行为本身混在一起。决定使用哪一种算法或采取哪一种行为的逻辑就和算法或行为的逻辑混合在一起，从而不可能再独立演化。继承使得动态改变算法或行为变得不可能。 3、 使用策略模式可以避免使用多重条件转移语句。多重转移语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重转移语句里面，比使用继承的办法还要原始和落后。 缺点 1、客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。 2、 策略模式造成很多的策略类，每个具体策略类都会产生一个新类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。 使用场景 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。 角色 抽象策略角色： 策略类，通常由一个接口或者抽象类实现。 具体策略角色：包装了相关的算法和行为。
环境角色：持有一个策略类的引用，最终给客户端调用。
UML类结构图 以代码和文字说明解析类结构图 抽象策略角色 类：AbstarctStrategy 代码： /** * Created by laizhiyuan on 2017/6/1. * * 设计模式-策略模式-抽象策略/算法 */ public abstract class AbstarctStrategy { /** * 计算金额抽象接口 * @param money * @return */ public abstract double countMoney(double money); /** * 不属于策略模式关键部分，我额外定义对参数进行检查的方法 * 检查金额 * @param money * @return */ protected double checkMoney(double money){ if (money == 0){ //TODO 处理为0时逻辑 } return money; } } 具体策略角色
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de16ced797eb17b6d131cb4a91fd18c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7d29b4ec08897adecc6877549dc8d7b/" rel="bookmark">
			解决网站项目本地运行ok,将代码上传到服务器中或github中无CSS效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行环境:IE10,Chrome,Firefox
使用插件及类库:JQFullPage.js,JQuery.
本人由于暂时时间空余,写了一下简单的个人网站,经过几个小时的coding 之后,终于在将网站写出一点效果,运行起来正常,之后自己上传到新浪云(PS:有人喜欢阿里云,华为云,其实基本的都一样的,百度一下有详细的SOP),发现并没有FullPage.js及CSS所渲染的效果.仔细检查代码,并没有发现明显的错误.引入文件的路径也是使用的相对路径.如下图所示
然而并没有发现问题.只好初步怀疑是服务器端不支持该第三方插件或者License没有及时地更新,在查阅相关资料之后发现并没有发现有此类问题.将代码重新github上也出现相同的问题.最后还是回归到JS代码中,在代码中分别加入了两行Alert("语句1")和Alert("语句2"),再次通过IP访问时,发现第二个语句并没有执行,经查资料发现,$(window).ready(){ $('.preloader').delay(100).fadeOut("speed"); }该方法并不一定需要等到所有的JS及图片都加载OK后再执行的,而我所需要的是JQuery.Fullpage.js要执行完才可以执行首页方法.
$(window).on('load',function(){$('.preloader').delay(100).fadeOut("speed"); });更改后重新上传到服务中通过网络访问OK.
总结:下次遇到类似的问题首先考虑引入的文件是否使用的是相对路径.其次再注意使用$(window).ready(){}方法.
如果我的解答对你起到了帮助,请记得点赞哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/917cff5ef0ccbb7c9ea3af83254e9221/" rel="bookmark">
			js中substring方法的详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：记录自己在工作中遇到的小问题，积少成多！因为是新手，有什么写的不好的地方还希望大家能够指出来。有什么更好的解决方法也希望大家能提出来，一起交流分享！（小弟在这里先谢谢大家）
1、介绍
substring方法用于从一个字符串中提取一个子的字符串；
2、用法
stringObject.substring(start,stop)；
3、参数介绍
start（必填）：要提取的子字符串，在原始字符串中的起始位置；
stop（可选）：要提取的子字符串，在原始字符串中的结束位置；
注意事项：起始包含start，但是结束不包含stop；如果不填写stop，那么要提取的子字符串就是从start开始，到原始字符串的最后一个字符；
（要记住下标是从0开始，而非从1开始）
4、例子
1、只有一个参数的例子
&lt;script type="text/javascript"&gt;
var str="Hello world!"
document.write(str.substring(3))
&lt;/script&gt;
输出：lo world!
2、包含两个参数的例子
&lt;script type="text/javascript"&gt;
var str="Hello world!"
document.write(str.substring(3，5))
&lt;/script&gt;
输出：lo
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f41ed51b5b2c41d036d14c720904aef/" rel="bookmark">
			nginx 如何配置来获取用户真实IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		##1.背景知识 1.1. 前提知识点： 还有nginx中的几个变量：
remote_addr 代表客户端的IP，但它的值不是由客户端提供的，而是服务端根据客户端的ip指定的，当你的浏览器访问某个网站时，假设中间没有任何代理，那么网站的web服务器（Nginx，Apache等）就会把remote_addr设为你的机器IP，如果你用了某个代理，那么你的浏览器会先访问这个代理，然后再由这个代理转发到网站，这样web服务器就会把remote_addr设为这台代理机器的IP,除非代理将你的IP附在请求header中一起转交给web服务器。
X-Forwarded-For（简称XFF）
X-Forwarded-For 是一个 HTTP 扩展头部。HTTP/1.1（RFC 2616）协议并没有对它的定义，它最开始是由 Squid 这个缓存代理软件引入，用来表示 HTTP 请求端真实 IP。如今它已经成为事实上的标准，被各大 HTTP 代理、负载均衡等转发服务广泛使用，并被写入 RFC 7239（Forwarded HTTP Extension）标准之中。
XFF的格式为：
X-Forwarded-For: client, proxy1, proxy2 XFF 的内容由「英文逗号 + 空格」隔开的多个部分组成，最开始的是离服务端最远的设备 IP，然后是每一级代理设备的 IP。（注意：如果未经严格处理，可以被伪造）
如果一个 HTTP 请求到达服务器之前，经过了三个代理 Proxy1、Proxy2、Proxy3，IP 分别为 IP1、IP2、IP3，用户真实 IP 为 IP0，那么按照 XFF 标准，服务端最终会收到以下信息：
X-Forwarded-For: IP0, IP1, IP2 Proxy3 直连服务器，它会给 XFF 追加 IP2，表示它是在帮 Proxy2 转发请求。列表中并没有 IP3，IP3 可以在服务端通过 Remote Address 字段获得。我们知道 HTTP 连接基于 TCP 连接，HTTP 协议中没有 IP 的概念，Remote Address 来自 TCP 连接，表示与服务端建立 TCP 连接的设备 IP，在这个例子里就是 IP3。Remote Address 无法伪造，因为建立 TCP 连接需要三次握手，如果伪造了源 IP，无法建立 TCP 连接，更不会有后面的 HTTP 请求。但是在正常情况下，web服务器获取Remote Address只会获取到上一级的IP，本例里则是proxy3 的 IP3，这里先埋个伏笔。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f41ed51b5b2c41d036d14c720904aef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2739daec2af4371ab34f1ba281ba236c/" rel="bookmark">
			Exception in thread &#34;main&#34; java.lang.IncompatibleClassChangeError: Found interface com.mysql.jdbc.Co
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Exception in thread "main"java.lang.IncompatibleClassChangeError: Found interfacecom.mysql.jdbc.Connection, but class was expected
atcom.kevin.imageuploadserver.DBManager.getStatement(DBManager.java:23)
atcom.kevin.imageuploadserver.DBManager.query(DBManager.java:63)
atcom.kevin.imageuploadserver.ScanTest.doScan(ScanTest.java:56)
atcom.kevin.imageuploadserver.ScanTest.main(ScanTest.java:35)
前两天遇到这个奇葩错误，
百度了好多，什么包依赖冲突，JDK版本不匹配，环境变量冲突，还有什么编译问题。
首先查了一下JDK，都是1.6，那就不是版本和编译版本不一致的问题。
包依赖问题，因为项目基本用的都是我之前用过的包，也没有import什么新的不熟的包，应该也没有这个问题。特别是JDBC的那几个，老将了都。
最后查查点点的，还搞了一下refreshing server adapter....
还是不行。
最后就怒重启，再bulid all 和build project，然后运行就...好...了....
经常遇到一些莫名其妙的错误，真的是。
【https://my.oschina.net/itblog/blog/528613】
【http://www.bubuko.com/infodetail-1019393.html】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/687b6f71e125f6f66a1c046c944af0c7/" rel="bookmark">
			jQuery_Ajax: $.ajax()中的常用参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$.ajax()方法中的常用参数 1、 url （paramType:String）发送请求地址。
2、 type （paramType:String）请求方式（post或 get）默认为get。
3、 dataType （paramType:String）服务器返回的数据类型。如果没有指定，则返回responseXML或responseText。 可指定的类型： text: 返回纯文本字符串。 json: 返回JSON数据。 html: 返回纯文本HTML信息。 xml: 返回XML文档。 script: 返回纯文本Javascript代码。 jsonp: JSON格式。
4、data (paramType: String/Object) 发送到服务端的数据。如果不是字符串，将自动转换为字符串格式。
5、 success (paramType:Function） 请求完成后的回调函数，有两个参数。 (1)由服务器返回，并根据dataType参数进行处理后的数据。 (2)描述状态的字符串。 function(data, textStatus){ //data可能是xmlDoc、jsonObj、html、text等等 this; //调用本次ajax请求时传递的options参数 }
6、 contentType (parmType: String)当发送信息至服务器时，内容编码类型默认为”application/x-www-form-urlencoded”
7、 timeout （paramType:Number）设置请求超时时间（毫秒）。
8、 async (paramType: Boolean) 默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。
9、 error (paramType:Function） 请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下： function(XMLHttpRequest, textStatus, errorThrown){ //通常情况下textStatus和errorThrown只有其中一个包含信息 this; //调用本次ajax请求时传递的options参数 }
事例代码：
$(function(){ $("#sendmsg").on('click',function(){//用户点击Send Message按钮发送消息 var c = $("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/687b6f71e125f6f66a1c046c944af0c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96493eb933e731127d3ea6a21877e335/" rel="bookmark">
			JDK 版本号对应的数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		J2SE 8 = 52 (0x34 hex)
J2SE 7 = 51 (0x33 hex)
J2SE 6.0 = 50 (0x32 hex)
J2SE 5.0 = 49 (0x31 hex)
JDK 1.4 = 48 (0x30 hex)
JDK 1.3 = 47 (0x2F hex)
JDK 1.2 = 46 (0x2E hex)
JDK 1.1 = 45 (0x2D hex)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80132b5337b5a7879907fb178825fbfb/" rel="bookmark">
			训练不收敛的几种可能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 学习率 我们可能已经听说了很多，如果loss不收敛就将学习率降低。但是，这在重新训练时是个误区，尤其是在训练的开始阶段。在开始阶段我们不能把学习率设置的太低否则loss不会收敛。我的做法是逐渐尝试，从0.1,0.08,0.06,0.05 ......逐渐减小，如果学习率设置的过大，loss会直接爆炸变成87.33（原因可参考：http://blog.csdn.NET/jkfdqjjy/article/details/52268565?locationNum=14）我们逐渐减小学习率，直到loss正常为止。我们可以用第一个最大值训练网络，开始时loss下降很慢，可能要等到迭代3万次左右才有明显变化，耐心等待。当训练时发现loss不再下降，这时我们可以再降低学习率，继续训练。
影响loss收敛性的因素有很多，还没有一一尝试。dropout_ratio,batchsize等。
2. 数据未归一化
3. 网络结构不合理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e26fa2bbf2d6d006821439f337d863e/" rel="bookmark">
			StringBuffer的delete方法与deleteCharAt的区别！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：记录自己在工作中遇到的小问题，积少成多！因为是新手，有什么写的不好的地方还希望大家能够指出来。有什么更好的解决方法也希望大家能提出来，一起交流分享！（小弟在这里先谢谢大家）
1、介绍
delete方法与deleteCharAt两个方法都是用来删除StringBuffer字符串指定索引字符的方法，
delete（int a,int b）有两个参数，使用时删除索引从a开始（包含a）到b（不包含b）的所有字符；
deleteCharAt（int a）只有一个参数，使用时删除索引为a的字符；
以上就是这两个方法的介绍。
2、java测试代码
public static void main(String[] args) { StringBuffer buff = new StringBuffer("0123456789"); System.out.println("buff="+buff); //删除下标从3到5的字符 buff.delete(3,5); System.out.println("deletionBack="+ buff); buff = new StringBuffer("0123456789"); //删除下标为8字符 buff.deleteCharAt(8); System.out.println("delectCharAtBack="+buff); } 3、控制台输出结果 buff=0123456789
deletionBack=01256789
delectCharAtBack=012345679
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aac39d869c505ae33a277b8c3228cc27/" rel="bookmark">
			tinyint(1)与tinyint(3),int(1)与int(3),tiny(1)与int(1)区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tinyint一个字节 smallint 两个字节 MEDIUMINT三个字节 int四个字节
不管 tinyint 后面的数字是多少，它存储长度=2^（1字节）=2^8，即存储范围是 -2^7 到 2^7 - 1。
不管 int 后面的数字是多少，它存储长度=2^（4字节）=2^32，即存储范围是 -2^31 到 2^31 - 1。
所以，tinyint(1)与tinyint(3),int(1)与int(3)在所占的存储空间都是一样，http://blog.csdn.net/phpwish/article/details/7845921 这里讲区别在于，区别就是显示的长度不同，但是，通过数据库实际操作试了下，我设置一个字段int(1),插入该字段一个值1234567890，仍然能够正常显示啊，而不是只显示1位，所以，我是不是可以认为，tiny或int后设置的这个数字根本没有任何作用呢？
但是char还有varchar后面的数字是表示显示的位数的，看黄色圈中的部分。
MySQL中，int(10)和int(3)的区别
答：int（10）和int（3）在存储上并没有什么区别，他们在存储中都是占用4字节32位，表示范围为：有符号数（-2147483648~2147483647），无符号数（0~4294967295）。
区别在于：在创建类型时加入zerofill来用0填充，可以看出区别。例如int（3），当你存储时，MySQL会帮你补全，存储为011，而当超过3位时，则没有影响。
int(1) 和 tinyint(1) ，在设计数据库的时候应该选择tinyint(1)。所占的储存空间越少越好，当然要够用才行。像这样储存一个 个位数的字段，还是用tinyint(1)的好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f44527e02f8afd70ea37887889a98fd/" rel="bookmark">
			在js中如何获取到你点击的元素的html、对象、属性值、以及自定义的属性值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：记录自己在工作中遇到的小问题，积少成多！因为是新手，有什么写的不好的地方还希望大家能够指出来。有什么更好的解决方法也希望大家能提出来，一起交流分享！（小弟在这里先谢谢大家）
直接上代码：
1、jsp页面代码
&lt;p&gt;首先定义两个按钮,添加一些常规属性type、id、value&lt;/p&gt; &lt;p&gt;其次再定义给每个按钮一个自定义的属性custom&lt;/p&gt; 与方法一配套的input &lt;input type="button" id="button1" value="按钮1" custom="这是自定义的属性1" οnclick="button1(this)"/&gt; &lt;/br&gt; &lt;/br&gt; 与方法二配套的input &lt;input type="button" id="button2" value="按钮2" custom="这是自定义的属性2"/&gt; 2、js代码
&lt;script type="text/javascript"&gt; //现在我们要做的就是点击button,获取到他的整个html或者整个对象 //方法一:直接给button一个onclick事件 function button1(e){ //得到html console.log(e) //得到对象 console.log($(e)) //得到自定义的custom console.log($(e).attr("custom")) } //方法二：通过js动态的给按钮添加一个click事件 $(function(){ $("#button2").click(function(){ //得到html console.log(this) //得到对象 console.log($(this)) //得到自定义的custom console.log($(this).attr("custom")) }) }) &lt;/script&gt; 3、运行结果 红框是点击按钮1的效果！！！
绿框是点击按钮2的效果！！！
见下图：
4、总结
1、使用attr属性可以获取到自定义的属性（attr也可以设置自定义的属性，例：$（this）.attr("custom","这是修改后的自定义属性") 这样就可以吧"这是自定义的属性"修改为"这是修改后的自定义属性值")
想继续了解attr属性可以点击：http://www.w3school.com.cn/jquery/attributes_attr.asp
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19c2f081607625053a9ff3eb71397082/" rel="bookmark">
			Eclipse集成Git插件及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Git插件安装 1.1 下载插件 首先打开Eclipse，然后点击Help&gt;Install New Software&gt;Add。 Name：EGit Location： http://download.eclipse.org/egit/updates 图1 图2 勾选插件，然后一路 next ，最后重启Eclipse。 2. Git提交代码 2.1 建git的本地仓库： 第一种 ： 第一步 如图： 第二步 这里是创建Git的本地仓库(如果没有) 如图： 第二种 ： 第一步 如图： 第二步 如图：这种的仓库默认在项目文件中，最后点击Finish 建库时遇到的错误： eclipse.jgit.api.errors.JGitInternalException: User config file C:\Users\Administrator.gitconfig invalid org.eclipse.jgit.errors.ConfigInvalidException: Cannot read file C:\Users\Administrator.gitconfig 原因：可能是多次配置git时配置文件发生了错误，导致文件损坏，无法读取。 解决：C:\Users\Administrator.gitconfig根据这个路径删除文件，重启Eclipse。
项目创建本地仓库后 如图： 创建本地仓库后项目上会有&gt; ？符号 说明还没提交到本地仓库。 2.2 提交本地仓库： 第一步 如图： 第二步 如图： 2.3 提交远程仓库： 只有提交了本地仓库，才可以提交远程仓库
第一步 如图： 第二步 如图： 第三步 如图： &gt;
第四步 如图： 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19c2f081607625053a9ff3eb71397082/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09d1e7379b06f8206f3029366ac5e765/" rel="bookmark">
			机器学习实战—第2章 k-近邻算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.1 K-近邻算法概述 k-近邻算法
优点： 精度高、对异常值不敏感、无数据输入假定缺点 计算复杂度高、空间复杂度高使用数据范围： 数值型和标称型 k-近邻算法的工作原理：
存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即知道样本集中每一数据与所属分类的关系。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。一般来说，只选择样本数据集中前k个最相似的数据，通常k不大于20，选择k个最相似数据中出现次数最多的分类，作为数据的分类。
k-近邻算法的一般流程：
收集数据：可以使用任何方法准备数据：距离计算所需要的数值，最好是结构化的数据格式分析数据：可以使用任何方法训练算法：此步骤不适用于k-近邻算法测试算法：计算错误率使用算法：首先需要输入样本数据和结构化的输出结果，然后运行k-近邻算法判定输入数据分别属于哪个分类，最后应用对计算出的分类执行后续的处理 # -*- coding: utf-8 -*- """ Created on Wed May 24 21:42:55 2017 @name: kNN.py @author: L. D. Xiao """ from numpy import * import operator #============================================================================== # 创建数据集和标签 #============================================================================== def createDataSet(): group = array([[1.0,1.1],[1.0,1.0],[0,0],[0,0.1]]) labels = ['A','A','B','B'] return group, labels #================================ kNN算法 ====================================== # kNN对未知类别属性的数据集中的每个点依次执行以下操作： # 计算已知类别数据集中的点与当前点之间的距离； # 按照距离递增次序排序； # 选取与当前点距离最小的k个点； # 确定前k个点所在类别的出现频率； # 返回前k个点出现频率最高的类别作为当前点的预测分类 #============================================================================== def classify0(inX, dataSet, labels,k): dataSetSize = dataSet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09d1e7379b06f8206f3029366ac5e765/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91f7a5b217947008912613f3e8bede77/" rel="bookmark">
			机器学习实战—第1章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.1 何谓机器学习 1.2 关键术语 特征（属性）：数值型、二值型、枚举类型。特征或属性通常是训练样本的列，它们是独立测量得到的结果，多个特征联系在一起共同组成了一个训练样本分类：是基本的机器学习任务目标变量：分类任务中通常为标称型，回归任务通常为连续型训练样本训练集训练数据、测试数据 1.3 机器学习的主要任务 分类回归 分类和回归属于监督学习，这类算法必须知道预测什么，即目标变量的分类信息。 与监督学习相对应的是无监督学习，此时数据没有类别信息，也不会给定目标值。在无监督学习中，将数据集合分成由类似的对象组成的多个类的过程被称为聚类；将寻找描述数据统计值的过程称之为密度估计。此外，无监督学习还可以减少数据特征的维度，以便使用二维或三维图形更加直观地展示数据信息。
监督学习算法 k近邻算法朴素贝叶斯算法支持向量机决策树线性回归局部加权线性回归Ridge回归Lasso最小回归系数估计无监督学习算法 K-均值DBSCAN最大期望算法Parzen窗设计 1.4 如何选择合适的算法 选择合适的算法需考虑两点：
使用机器学习算法的目的，想要算法完成何种任务？ 预测目标变量的值可以选择监督学习算法目标变量的值是离散型，可选择分类算法；连续型目标变量选择回归算法需要分析或收集的数据是什么？ 特征值是离散还是连续型变量特征值中是否存在缺失的值数据中是否存在异常值某个特征发生的频率如何 一般说来，发现最好算法的关键环节是反复试错的迭代过程。
1.5 开发机器学习应用程序的步骤 收集数据准备输入数据分析输入数据：确保数据集中没有垃圾数据训练算法测试算法使用算法 1.6 Python语言的优势 可执行伪代码（executable pseudo-code）:具有清晰的语法结构Python比较流行：代码范例多Python语言的特色Python语言的缺点：性能不足 1.7 NumPy函数基础 #将NumPy函数库中的所有模块引入当前的命名空间 from numpy import * #生成4*4的随机数组 random.rand(4,4) #将数组转化为矩阵 randMat = mat(random.rand(4,4)) #矩阵求逆.I invRandMat = randMat.I #创建4*4单位矩阵 eye(4) #得到误差矩阵 randMat*invRandMat-eye(4) 1.8 本章小结 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/286/">«</a>
	<span class="pagination__item pagination__item--current">287/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/288/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>