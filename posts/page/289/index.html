<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/552a34a32fd730877af04e85289703c2/" rel="bookmark">
			关于String.valueOf()方法的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、由基本数据形态转换成String类型：(注意这些方法都是静态的 static) 由String类的valueOf()函数的躲在实现。 String.valueOf(boolean b) : 将 boolean 变量 b 转换成字符串 String.valueOf(char c) : 将 char 变量 c 转换成字符串 String.valueOf(char[] data) : 将 char 数组 data 转换成字符串 String.valueOf(char[] data, int offset, int count) : 将 char 数组 data 中 由 data[offset] 开始取 count 个元素 转换成字符串 String.valueOf(double d) : 将 double 变量 d 转换成字符串 String.valueOf(float f) : 将 float 变量 f 转换成字符串 String.valueOf(int i) : 将 int 变量 i 转换成字符串 String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/552a34a32fd730877af04e85289703c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a276ce7e2966d0b8a8864da58bd9282/" rel="bookmark">
			通过PLSQL导入csv文件时出现乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题现象：从生产环境导入的csv文件，导入到测试环境数据库后发现同一列的数据有一部分是乱码，一部分是正常的。打开csv文件查看数据全部正常显示，无乱码； 问题解决： 第一步：先查看生产环境PLSQL客户端与本地的PLSQL字符编码是否一致，查询脚本为： select userenv(‘language’) from dual; 如不一致可在本地配置环境变量使其一致，配置方法为：我的电脑-&gt;右键-&gt;系统属性-&gt;高级-&gt;环境变量-&gt;新建 变量名=NLS_LANG 变量值=AMERICAN_AMERICA.AL32UTF8 因为生产环境变量值是AMERICAN_AMERICA.AL32UTF8，所以我改成了一致；如果导入还是有乱码，请执行第二步； 第二步：将csv文件用UE打开，将字符编码改为utf-8,然后保存；新建一个excel文件-&gt;数据-&gt;自文本-&gt;选择保存后的csv文件导入到excel，分隔符选择逗号，导入完成后再另存为csv文件。 第三步：从新用plsql导入csv文件，成功导入。
注意：当导入的数据是乱码时可能占用的字符长度也会有变化，所以即使是同样的表结构导入时也可能会报字段长度不够之类的错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cab00fc2b753670cd60fb61389f1bdbd/" rel="bookmark">
			sql 获取当前系统时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sql读取系统日期和时间的方法如下： --获取当前日期(如：yyyymmdd) select CONVERT (nvarchar(12),GETDATE(),112) --获取当前日期(如：yyyymmdd hh:MM:ss) select GETDATE() --获取当前日期(如：yyyy-mm-dd) Select Datename(year,GetDate())+'-'+Datename(month,GetDate())+'-'+Datename(day,GetDate()) --获取当前日期(如：yyyy/mm/dd) select DATENAME(YEAR,GETDATE())+'/'+DATENAME(MONTH,GETDATE())+'/'+DATENAME(DAY,GETDATE()) --获取几种日期 select DATENAME(YEAR,GETDATE()) --年份(YYYY) select DATENAME(YY,GETDATE()) select DATENAME(MM,GETDATE()) --月份 select DATENAME(DD,GETDATE()) --日期 select dateName(hh,getdate()) --获取小时 select DATENAME(MI,GETDATE()) --获取分钟 select DATENAME(SECOND,GETDATE()) --获取秒 select DATENAME(WEEK,GETDATE()) --获取当前星期(周)是这一年中的第几个星期(周) select DATENAME(WEEKDAY,GETDATE()) --星期几 --获取数据格式为(如：yyyy-mm-dd hh:MM:ss) select CONVERT (nvarchar(12),GETDATE(),112) select DATENAME(YEAR,GETDATE())+'-'+DATENAME(MONTH,GETDATE())+'-'+DATENAME(DAY,GETDATE())+' '+DATENAME(hh,GETDATE())+':' +DATENAME(MI,GETDATE())+':'+DATENAME(SECOND,GETDATE()) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ac251de077f35ae8a7b85cde118b3e5/" rel="bookmark">
			java.lang.ClassNotFoundException: sun.io.ByteToCharConverter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Caused by: java.lang.ClassNotFoundException: sun.io.ByteToCharConverter
at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1698)
at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1544)
at java.lang.Class.forName0(Native Method)
at java.lang.Class.forName(Unknown Source)
at com.ibm.db2.jcc.am.kg.run(kg.java:19)
出现这个错误的原因是db2的驱动里面需要用到sun.io.ByteToCharConverter这个类，但是我当前tomcat运行环境是1.8.11，里面没有这个类，改成1.7或者1.6的就OK了，修改如下：
点击Runtime Environment
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39bcc21a85cab3c2b848aa8eabbba48a/" rel="bookmark">
			关于GitLab中文版的那点事儿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		杂序 关于Git的那些事儿，这里不多说。Git这个极好用的分布式版本管理系统，不得不说给我们日常团队研发及代码管理带来了太多益处与效率。
如果要问我他是何方神圣，我只想说你可以关注下：
Git主页：https://git-scm.com/GitHub主页：https://github.com/GitLab主页：https://about.gitlab.com/
本文将以CentOS7为系统，介绍GitLab CE（社区版）。 环境搭建 安装GitLab 通过GitLab首页域名进入首页，选择Download，如下图：
点击Select Oprating System，弹出系统列表选择CentOS7，按照安装步骤向导进行安装。
1、安装系统以来软件包，并且打开http服务和系统防火墙
$ sudo yum install libsemanage-static libsemanage-devel $ sudo yum install curl policycoreutils openssh-server openssh-clients $ sudo systemctl enable sshd $ sudo systemctl start sshd $ sudo yum install postfix $ sudo systemctl enable postfix $ sudo systemctl start postfix $ sudo firewall-cmd --permanent --add-service=http $ sudo systemctl reload firewalld 2、编辑/etc/gitlab/gitlab.rb文件，配置STMP邮件发送服务
gitlab_rails['smtp_enable'] = true gitlab_rails['smtp_address'] = "smtp.exmail.qq.com" gitlab_rails['smtp_port'] = 465 gitlab_rails['smtp_user_name'] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39bcc21a85cab3c2b848aa8eabbba48a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/540503b8308293b40e272867832421bf/" rel="bookmark">
			PHPExcel 多工作表 导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//浏览器输出excel header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'); header('Content-Disposition: attachment;filename="dzg_card_info.xlsx"'); header('Cache-Control: max-age=0'); $this-&gt;load-&gt;library('PHPExcel'); //加载类库,其他框架可以使用require_one $objPHPExcel = new PHPExcel(); $objPHPExcel-&gt;setActiveSheetIndex(0); //设置第一个工作表为活动工作表 $objPHPExcel-&gt;getActiveSheet()-&gt;setTitle('card_info'); //设置工作表名称 //为单元格赋值 //方法①:直接设置单元格的值 /* $objPHPExcel-&gt;getActiveSheet()-&gt;setCellValue('A1', 'PHPExcel'); $objPHPExcel-&gt;getActiveSheet()-&gt;setCellValue('A2', 12345.6789); $objPHPExcel-&gt;getActiveSheet()-&gt;setCellValue('A3', TRUE); */ //方法②:二维数组 $arrHeader = array(['id', '名字', '技能', '创建时间']); $arrAllCardInfo = $this-&gt;admin_model-&gt;getAllCardInfo(); //二维数组 $arrExcelInfo = array_merge($arrHeader, $arrAllCardInfo); $arrExcelInfo = eval('return ' . iconv('gbk', 'utf-8', var_export($arrExcelInfo, true)) . ';'); //将数组转换成utf-8 $objPHPExcel-&gt;getActiveSheet()-&gt;fromArray( $arrExcelInfo, // 赋值的数组 NULL, // 忽略的值,不会在excel中显示 'A1' // 赋值的起始位置 ); //创建第二个工作表 $msgWorkSheet = new PHPExcel_Worksheet($objPHPExcel, 'card_message'); //创建一个工作表 $objPHPExcel-&gt;addSheet($msgWorkSheet); //插入工作表 $objPHPExcel-&gt;setActiveSheetIndex(1); //切换到新创建的工作表 $arrHeader = array(['id', 'uid', '描述']); $arrBody = $this-&gt;admin_model-&gt;getAllCardMsg(); $arrExcelInfo = array_merge($arrHeader, $arrBody); $arrExcelInfo = eval('return ' .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/540503b8308293b40e272867832421bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/142b562c910c449c22a59a58bd3e1a67/" rel="bookmark">
			【原创】python&amp;nbsp;简繁体转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 比较不错的简繁体转换 pyjft (百度云盘下载)，注意：不能有逗号等特殊符号~~ 现在合并到： pyzh 这个就是简繁体转换关键代码 谷歌 code下载pyjft.py。 &gt;&gt;&gt; a=u'飞机飞向蓝天' &gt;&gt;&gt; res= jft.j2f('gbk','utf8',a.encode( 'gbk')).decode('utf8') 飞机飞向蓝天 &gt;&gt;&gt; res u'\u98db\u6a5f\u98db\u5411\ u85cd\u5929' &gt;&gt;&gt; print res 飛機飛向藍天 &gt;&gt;&gt; from __future__ imports must occur at the beginning of the file 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/810e07f78eb5d290ca79479f1692cda3/" rel="bookmark">
			实验吧登陆一下好吗??WP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 登陆一下好吗??（http://www.shiyanbar.com/ctf/1942） username= 1’=’0 password= 1’=’0 或者 username=what’=’ password=what’=’ 或者 username:admin’=’ password:admin’=’ 得到ctf{51d1bf8fb65a8c2406513ee8f52283e7} 好吧，其实我提供的只是万能密码尝试而已，真正的writeup在这里（by wonderkun,侵删）：
根据题目的提示，获知该题目的目的使用sql注入来绕过登陆。
猜测后台的sql应该是
select * from table where username= ‘ username′andpassword=′ password’
进过测试，发现过滤了以下字符 | , – , or , union , # , select ,* ,/ 这写字符没办法绕过。
但是为了登陆成功，需要让 sql语句返回true。 除了pact想到的同双等号绕外，还有一种方法，主要用到以下两个技巧： 第一： mysql的数据类型转换特性。 通过这个图，应该可以看明白啦， user是一个字符串类型的，当他接受到一个整型值切值为0的时候，就会返回数据库的所有条目。 一个字符串加一个整形，会自动的变量类型转换，变为一个整型。 所以，只需要让sql执行 select * from table where username=’a’+0;
就可以返回一个ture了，但是你会发现注释符全部过滤啦，后面的部分去不掉，这时候你需要知道下面的姿势。
第二： mysql的注释符除了 – + ， # ，/**/ 之外，还有一个 ;%00 ，很多人都不知道最后一个。
所以最后的payload 是这样的: username=a’+0;%00&amp;password= 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d006f4f4c19e3f4f6ba0d4b6d934acf/" rel="bookmark">
			文档的相似度（2）--最小哈希签名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接着上一篇的博客继续下去，这篇博客主要讲下最小哈希签名的东西。
对于上篇博客中提到的shingle，可以说是在压缩数据量的基础上又尽可能保留了源文档的特征，以便于后面对不同的文档进行相似度比较。但是我们会发现，shingle集合非常大，即使将每个shingle都哈希为4个字节，一篇文档的shingle集合所需要的空间仍然大概是该文档所需空间的4倍（这是因为shingle分词的特性，导致分词后shingle的 个数略等于文档中字母的个数，而一个字母一般在计算机中占一个字节，shingle哈希占了4个字节，故而是4倍左右）。那么可想而知，如果有数百万篇文档，很可能不能将这些文档的shingle集合都放入内存中，或者及时所有的集合都可以放入到内存中，那所需要对的数目也可能会多到无法估计没对的相似度。
这里就需要将上述大集合替换成规模很多的“签名”（signature）表示。所谓签名，在日常生活中我们很多地方都需要签名，进而代表我们个人，我们这里的“签名”其实代表的 就是一篇文档，它是由文档中经过特殊方法选择出的具有代表性的数据组成。对于签名而言，我们所需要的重要特征是能够仅仅通过比较两篇文档的签名集合就可以估计实际shingle集合之间的Jaccard相似度。当然，通过签名无法得到原始shingle集合之间Jaccard相似度的精确值，但是估计结果与真实结果相差不大，并且签名集合越大，估计的精度越高。例如，50000字节文档的shingle可能会映射为200000字节的哈希结果，然后替换成1000字节大小的签名集合。基于最终签名集合得到的原始文档Jaccard相似度的估计值与真实值的差异也就在几个百分点之内。
集合的矩阵表示
在介绍如何构建哈希签名之前，首先来说一下如何将一系列集合表示成其特征矩阵。矩阵的列对应集合，行对应全集（所有集合中可能的元素组成全集）中的元素。如果行r对应的元素属于列c对应的集合，那么矩阵第r行第r列的元素为1，否则为0。
例如：
下图给出了全集{a，b，c，d，e}中元素组成的多个集合的矩阵表示。这里S1={a，d}，S2={c}，S3={b，d，e}，S4={a，c，d}。图中最上面一行和最左边一列并非矩阵的一部分，而是表示各行和各列的含义。
图1
需要记住的是，特征矩阵并非数据真正的存储方式，但是作为数据可视化的一种方式则是非常有用的。在实际当中，数据不会存储为矩阵的一个原因是该矩阵往往非常稀疏（0的个数远多于1）。只存储1所在的位置能够大大节省存储的开销，同时又能完整地表示整个矩阵。另外一个原因是，数据往往基于其它目的而存储成其它格式。
最小哈希
想要构建的集合的签名由大量计算（比如数百次 ）的结果组成，而每次计算是特征矩阵的最小哈希过程。
为了对特征矩阵每列所表示的集合进行最小哈希计算，首先选择行的一个排列转换（即是将行号重新排列）。任意一列的最小哈希值是在排列转换后的行排列次序下第一个列值为1的行的行号。
例如：
对于图1中的矩阵，假定采用beadc的行序重新排列，如下图。改排列转换定义了一个最小哈希函数h，它将某个集合映射成一行。接下来我们基于函数h计算集合S1的最小哈希值。按照beacd的顺序来扫描集合S1所对应的第一列，由于b行对应的值为0，所以需要往下继续扫描到e行，即排列转换次序中的第二行，其对应的S1列的值仍然是0.于是再往下处理到行a，此时其对应的值为1，因此，就有了h（S1）=a。
尽管物理上不可能对非常大的特征矩阵进行排列转换，最小哈希 函数h却隐式地将图1矩阵的行重新排列，使之变成图2中的举证。在新矩阵中，h函数的值可以通过从上往下扫描至遇到1为止。因此，我们有h（S2）=c、h（S3）=b及h（S4）=a。
图2
最小哈希及Jaccard相似度
在集合的Jaccard相似度及集合的最小哈希函数值之间存在着非同寻常的关联：
□ 两个集合经随机排列转换之后得到的两个最小哈希值相等的概率等于这两个集合的Jaccard相似度。
为了理解上述结论的原因，必须要对两个集合同一列对应的所有可能结果进行枚举。假设只考虑结合S1和S2所对应的列，那么他们所在的行可以按照所有可能的结果分成三类：
（1）数据X类的行，两列的值均为1；
（2）数据Y类的行，其中一列的值为0，另一列的值为1；
（3）属于Z类的行，两列的值均为0。
由于特征矩阵十分稀疏，因此大部分行都属于Z类。但是X和Y类行数目的比例决定了SIM（S1，S2）及概率h（S1）=h（S2）的大小。假定X类行的数目为x，Y类的行的数目为ym，则SIM（S1，S2）=x/(x+y)。原因是S1∩S2的大小为x而S1∪S2的大小为x+y。
接下来考虑h（S1）=h（S2）的概率。设想所有行进行随机排列转换，然后我们从上到下进行扫描处理，在碰到Y类行之前碰到X类行的概率为x/(x+y)。但是如果从上往下扫描遇到的除Z类行之外的第一行属于X类，那么肯定有h（S1）=h（S2）。另一方面，如果首先碰到的是Y类行，而不是Z类行，那么值为1的那个集合的最小哈希值为当前行。但值为0的那个集合必将会进一步扫描下去。因此 ，如果首先碰到Y类行，那么此时h（S1）≠h（S2）.于是，我们可以得到最终结论，即h（S1）=h（S2）的概率为x/(x+y)，而这也是两个集合Jaccard相似度的计算公式。
最小哈希签名
此处将会继续讲解前面介绍的一系列集合的特征矩阵表示M。为表示这些集合，我们随机选择n个排列转换用于矩阵M的行处理。其中n一般为一百或几百。对于集合S对应的列，分别调用这些排列转换所决定的最小哈希函数h1，h2，h3，.......，hn，则可以构建S的最小哈希签名向量[h1(S),h2(S),.......,hn(S)],该向量通常写成列向量方式。因此，基于矩阵M可以构建一个签名矩阵，其中M的每一列替换成该列所对应的最小哈希签名向量即可。
需要注意的是，签名矩阵与 M的列数相同但行数只有n。即使不显示表示M中的全部元素而采用适合于稀疏矩阵的某种压缩形式（比如只存储1所在的位置）来表示，通常情况下签名矩阵所需要的空间仍比矩阵M本身的表示空间要小许多。
最小哈希签名的计算
对于大规模特征矩阵进行显式排列转换是不可行的。即使对上百万甚至数十亿的行选择一个随机排列转换也是极其消耗时间，而对行进行必要的排序则需要花费更多的时间。因此，类似图2给出的排列转换的矩阵在概念上十分吸引人，但却缺乏可操作性。
幸运的是，我们可以通过一个随机哈希函数来模拟随机排列转化的效果，该函数将行号映射到与行数目大致相等的数量的桶中。通常而言，一个将整数0,1,2.....,k-1映射到桶号0,1,2,......,k-1的哈希函数会将某些整数对映射到同一个桶中，而有些桶却没有被任何整数映射到。然而，只要k很大且哈希结果冲突不太频繁的话，差异就不是很重要。于是，我们就可以继续假设哈希函数“h”将原来的第r行放在排列转换后次序中的第h（r）个位置上。
因此，我们就可以不对行选择n个随机排列转换，取而代之的是随机选择n个哈希函数h1，h2，.......，hn作用于行。在上述处理基础上，就可以根据每行在哈希之后的位置来构建签名矩阵。令SIG（i，c）为签名矩阵中第i个哈希函数在第c列上的元素。一开始，对于所有的i和c，将SIG（i，c）都初始化为∞。然后，对行进行如下操作：
（1）计算 h1（r），h2（r），......，hn（r）。
（2）对每列c进行如下操作：
（a）如果c在第r行为0，则什么也不做；
（b）否则，如果c在第r行为1，那么对于每个i=1,2，....，n，将SIG（i，c）置为原来的SIG（i，c）hi（r）之中的较小值。
例如：在此考虑图1对应的特征矩阵，我们在后面加上一些数据形成图3。另外将每一行替换成其对应的行号0,1，.....，4。选择的两个哈希函数分别为h1（x）=x+1 mod 5及h2（x）=3x+1 mod 5.两个哈希函数产生的结果显示在图3-4中的最后两列。注意到这里的两个简单哈希函数对应真正的行排列转换，当然这里这有当行数目为质数（这里为5， 这是为了避免不同的数之间具有相同的约数而导致余数会相等进而会被分配到一个桶号中，这就会产生冲突了）时才会有真正的排列转换。通常来说，哈希结果都会存在冲突，即至少有两行得到的哈希值相等。
图3
接下来 模拟计算签名矩阵的算法。一开始，签名矩阵全部都由∞构成：
首先 ，考虑图3中的第0行。此时，不论是h1（0）还是h2（0）的结果都是1。而只有集合S1和S4在第0行为1，因此签名矩阵中只有这两列的值需要修改。因为1&lt;∞，因此实际上是对S1和S4的对应值进行修改，所以当前签名矩阵的估计结果为：
接下来，我们下移到图3中的第一行。对于该行，只有S3的值为1，此时其哈希值为h1（1）=2，h2（1）=4。因此，SIG（1,3）置为2，SIG（2,3）置为4。因为第一行中其它列的值均为0，所以签名矩阵的相应列的元素保持不变。于是，新的签名矩阵为：
图3第2行中只有S2和S4对应的列的值为1，且其哈希值h1（2）=3，h2（2）=2,。S4对应的标签名本应修改，但是签名矩阵中对应列值为[1,1]，因此其签名最后不会修改。而S2对应的列中仍然是初始值∞，我们将其修改为[3,2]，得到如下图：
再接下来处理图3中的第3行。此时只有S2对应的列的值不为1。而哈希值h1（3）=4，h2（3）=0。h1的结果已经超过了矩阵中所有列上的已有值，因此不需要修改签名矩阵的第一列的任一值。然而，h2的值为0小于矩阵元素，因此将SIG（2,1）、SIG（2,3）及SIG（2,4）减小为0。需要注意的是，由于图3中S2列在当前行的取值已经为0，因此SIG（2,2）不可能再减小。于是，此时得到的签名矩阵为：
最后考虑图3中的第4行，此时h1（4）=0，h2（4）=3。由于第4行只在S3列取值为1，我们仅仅比较S3的当前值[2,0]与哈希值[0,3]即可。由于0&lt;2，因此将SIG（1,3）改为0，而同时由于 3&gt;0，因此SIG（2,3）保持不变。最终得到的签名矩阵为：
基于上述签名矩阵，可以估计原始集合之间的Jaccard相似度。注意到在签名矩阵中S1和S4对应的列向量完全相同，因此我们可以猜测SIM（S1，S4）=1.0。如果回到图3，会发现S1和S4的真是Jaccard相似度为2/3.需要记住的是，签名矩阵中行之间的一致程度只是真实Jaccard相似度的一个估计值，因为本例规模太小，所以并不足以说明在大规模数据情况下估计值和真实值相近的规律。另外，在本例中，S1和S3在签名矩阵中有一半元素一致（真实相似度为1/4），而S1和S2在签名矩阵中没有相同元素，所以相似度估计值为0（真实相似度也为0）。
（注：以上理论性的知识全部是来源于上篇博客中所提到的书里的，所以是可靠的）。
下面附上自己的python代码：
这个是依据上述理论一个版本
""" 此函数用于获得所有文档的最小哈希签名，signatureNum表示签名行数 """ def getMinHashSignature(shingleList,signatureNum): #tatalSet用于存放所有集合的并集 totalSet=shingleList[0] for i in range(1,len(shingleList)): totalSet=totalSet|shingleList[i] temp=int(math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d006f4f4c19e3f4f6ba0d4b6d934acf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8de93c8da81d138df23b8a8ae6f63d29/" rel="bookmark">
			ORACLE登录验证方式的详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle的3种认证方式 1.使用OS操作系统集成身份验证 在数据库服务器本机只要以sqlplus as sysdba连接数据库，不论输入什么用户（哪怕这个用户如aaa在数据库中根本不存在）都可以连接上，并且连接用户是sys 好处就是，如果有时候忘记了数据库用户的密码，而又想登录数据库，可以通过这种方式，前提是在数据库服务器本机上；但是方便的同时也带来了一些安全隐患，想屏蔽os认证，只要修改sqlnet.ora中的SQLNET.AUTHENTICATION_SERVICES的值就可以屏蔽OS功能
没有sqlnet.ora文件时，默认开启OS认证 SQLNET.AUTHENTICATION_SERVICES = none | all | nts(windows下表示启用OS认证)
all : 用于linux、unix、windows平台，启用OS认证 nts : 用于windows平台，启用OS认证，其他平台使用这个值表示关闭OS认证
none : 表示关闭OS认证，只能密码认证或其他认证
all: all for all authentication methods.nts: nts for Microsoft Windows native operating system authentication
none: none for no authentication methods, including Microsoft Windows native operating system authentication. When SQLNET.AUTHENTICATION_SERVICES is set to none, a valid user name and password can be used to access the database.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8de93c8da81d138df23b8a8ae6f63d29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c15d083209411ffdcc6bfa9c60f7b83/" rel="bookmark">
			sigmoid和softmax函数的C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 float sigmoid(float x) { return (1 / (1 + exp(-x))); } float sigmoid_dy_dz(float x) { return (x * (1.0 - x)); } float tanh_dy_dz(float x) { return (1.0 - x*x); } //对每一行进行softmax void softmax(float *x, int row, int column) { for (int j = 0; j &lt; row; ++j) { float max = 0.0; float sum = 0.0; for (int k = 0; k &lt; column; ++k) if (max &lt; x[k + j*column]) max = x[k + j*column]; for (int k = 0; k &lt; column; ++k) { x[k + j*column] = exp(x[k + j*column] - max); // prevent data overflow sum += x[k + j*column]; } for (int k = 0; k &lt; column; ++k) x[k + j*column] /= sum; } } //row*column 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92ea51d11432e03f010ce3dd1525ca30/" rel="bookmark">
			sqoop使用手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sqoop使用手册 转载请注明出处：http://www.cnblogs.com/xiaodf/
1 Sqoop概述2 版本说明3 驱动安装 3.1 MySQL 4 基本用法 4.1 导入 4.1.1 保护密码4.1.2 使用其他文件格式4.1.3 压缩导入的数据4.1.4 提高传输速度4.1.5 自定义类型映射4.1.6 并行控制4.1.7 对NULL值进行编码4.1.8 导入所有表 4.2 增量导入 4.2.1 只导入细腻数据4.2.2 增量导入可变数据4.2.3 保存last-value4.2.4 在metastore中保存密码4.2.5 客户端之间共享metastore 4.3 导出 4.3.1 hive导出数据到mysql4.3.2 批量插入4.3.3 导出所有数据或不导出任何数据4.3.4 更新已有数据4.3.5 更新或插入数据4.3.6 只导出某些列4.3.7 编码NULL值 5 附：import和export参数详解 5.1 import和export工具通用选项5.2 数据导入工具import参数详解5.3 数据导出工具export参数详解5.4 Sqoop Job参数详解 1 Sqoop概述 Sqoop是一个旨在Hadoop和关系数据库或主机之间传输数据的工具。你可以使用Sqoop从关系型数据库管理系统（RDBMS），如MySQL、Oracle或大型机到Hadoop分布式文件系统（HDFS）导入数据，在Hadoop中的MapReduce转换数据，然后将数据导出到一个RDBMS 。Sqoop使用MapReduce导入和导出数据，它提供了并行操作，以及容错。
2 版本说明 本文档适用于Sqoop1。
软件 版本 Sqoop 1.4.5-cdh5.3.0 Mysql JDBC驱动 5.1.32 ORACLE JDBC驱动 和oracle版本保持一致 3 驱动安装 3.1 MySQL 将驱动对应的jar包放置到 /usr/share/java/下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92ea51d11432e03f010ce3dd1525ca30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/870391ba8f80389e56fb5432d93a3fb9/" rel="bookmark">
			Ubuntu使用阿里云源，解决下载速度慢问题。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更换ubuntu源 原文地址：http://www.cnblogs.com/microman/p/6109370.html
在终端中修改方法：
sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup #备份当前也就是默认官方的源列表
sudo gedit /etc/apt/sources.list #修改sources.list文件中源的列表，删除全部内容，替换为国内源地址。 保存编辑好的文件。
sudo apt-get update #更新源列表，换源后必须执行
国内源列表：本人试用过的比较快的源
deb http://mirrors.aliyun.com/ubuntu/ trusty main multiverse restricted universe deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main multiverse restricted universe deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main multiverse restricted universe deb http://mirrors.aliyun.com/ubuntu/ trusty-security main multiverse restricted universe deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main multiverse restricted universe deb-src http://mirrors.aliyun.com/ubuntu/ trusty main multiverse restricted universe deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main multiverse restricted universe deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main multiverse restricted universe deb-src http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/870391ba8f80389e56fb5432d93a3fb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4058150049c8da48c6bab03d3fff0b21/" rel="bookmark">
			butterknife 8.5.1配置使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		butterknife github地址
1、在整个项目 build.gradle 文件下做如下配置
buildscript { repositories { mavenCentral() } dependencies { classpath 'com.jakewharton:butterknife-gradle-plugin:8.5.1' } } 2、在当前module build.gradle 文件下做如下配置
apply plugin: 'com.jakewharton.butterknife' dependencies { compile 'com.jakewharton:butterknife:8.5.1' annotationProcessor 'com.jakewharton:butterknife-compiler:8.5.1' } 3、使用示例
public class TestView extends AppCompatActivity { @BindView(R.id.test_txt) TextView testTxt; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); testTxt.setText("ButterKnife"); } } 4、使用butterknife插件，快速生成，AndroidStudio Setting -&gt; Plugins -&gt; 搜索Android ButterKnife Zelezny 然后重启Studio生效。 插件使用方式：光标移动到布局文件的位置，例如：setContentView(R.layout.activity_main);，鼠标放到activity_main上，快键键Alt + Insert，选择Generate ButterKnife Injections
5、在Library内部使用视图注入 正确配置gradle之后，依然报错 Caused by: java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4058150049c8da48c6bab03d3fff0b21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/422ed9859d617106aa429fbe46c2227e/" rel="bookmark">
			error C3861: “gets”: 找不到标识符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		error C3861: “gets”: 找不到标识符
把“gets”改成“gets_s”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0d810ca918ea335287bd4830f721a62/" rel="bookmark">
			Python中time模块详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中，与时间处理有关的模块就包括：time，datetime以及calendar。这篇文章，主要讲解time模块。 在开始之前，首先要说明这几点：
在Python中，通常有这几种方式来表示时间：1）时间戳 2）格式化的时间字符串 3）元组（struct_time）共九个元素。由于Python的time模块实现主要调用C库，所以各个平台可能有所不同。
UTC（Coordinated Universal Time，世界协调时）亦即格林威治天文时间，世界标准时间。在中国为UTC+8。DST（Daylight Saving Time）即夏令时。
时间戳（timestamp）的方式：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。返回时间戳方式的函数主要有time()，clock()等。
元组（struct_time）方式：struct_time元组共有9个元素，返回struct_time的函数主要有gmtime()，localtime()，strptime()。下面列出这种方式元组中的几个元素：
索引（Index） 属性（Attribute） 值（Values） 0 tm_year（年） 比如2011 1 tm_mon（月） 1 - 12 2 tm_mday（日） 1 - 31 3 tm_hour（时） 0 - 23 4 tm_min（分） 0 - 59 5 tm_sec（秒） 0 - 61 6 tm_wday（weekday） 0 - 6（0表示周日） 7 tm_yday（一年中的第几天） 1 - 366 8 tm_isdst（是否是夏令时） 默认为-1 接着介绍time模块中常用的几个函数：
1）time.localtime([secs])：将一个时间戳转换为当前时区的struct_time。secs参数未提供，则以当前时间为准。
&gt;&gt;&gt; time.localtime() time.struct_time(tm_year=2011, tm_mon=5, tm_mday=5, tm_hour=14, tm_min=14, tm_sec=50, tm_wday=3, tm_yday=125, tm_isdst=0) &gt;&gt;&gt; time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0d810ca918ea335287bd4830f721a62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e07a338615573d8ea6775953ac79e6bd/" rel="bookmark">
			matlab实现滑动平均滤波(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 滑动平均（moving average）：在地球物理异常图上，选定某一尺寸的窗口，将窗口内的所有异常值做算术平均，将平均值作为窗口中心点的异常值。按点距或线距移动窗口，重复此平均方法，直到对整幅图完成上述过程，这种过程称为滑动平均。 滑动平均相当于低通滤波，在重力勘探和测井资料处理解释中常用此方法。 如果滑动窗长为n的话，滑动平均就是让数据通过一个n点的FIR滤波器，滤波器抽头系数都是1，这样取滑动平均就是起到序列平滑的作用。
利用filter函数求滑动平均 Matlab有多种计算滑动平均的方法，现介绍基于filter函数的计算方法。设原始数据为x，平均窗口设为a（a为正整数），那么无权重滑动平均后的数据y为：
windowSize =a;
y=filter(ones(1,windowSize)/windowSize,1,x);
上述命令实际上计算的是：
y(1)=(1/a)*x(1);
y(2)=(1/a)*x(2)+(1/a)*x(1);
... ...
y(a)=(1/a)*x(a)+(1/a)*x(a-1)+...+(1/a)*x(1);
... ...
y(i)=(1/a)*x(i)+(1/a)*x(i-1)+...+(1/a)*x(i-a+1);
... ....
可以看出，计算某一位置处的平均值时，窗口的前端位于该处。有时为了将窗口中部放在所计算的位置处，这样上述计算方式则变为（为叙述方便起见，设a为奇数）：
y(1)=(1/a)*x(1)+(1/a)*x(2)+...+(1/a)*x((a+1)/2);
y(2)=(1/a)*x(1)+(1/a)*x(2)+...+(1/a)*x((a+1)/2+1);
... ...
y((a+1)/2)=(1/a)*x(1)+(1/a)*x(2)+...+(1/a)*x((a+1)/2)+...+(1/a)*x(a);
... ...
y(i)=(1/a)*x(i-(a-1)/2)+(1/a)*x(i-(a-1)/2+1)+...+(1/a)*x(i)+...+(1/a)*x(i+(a-1)/2);
... ...
这种方式的滑动平均称为中心滑动平均，其Matlab的计算语句为：
windowSize =a;
y1=filter(ones(1,a/2+1)/windowSize,1,x); y2=filter(ones(1,a/2+1)/windowSize,1,fliplr(x)); y=y1+fliplr(y2)-(1/a)*x;
如利用1-2-1 滤波器计算有权重的中心滑动平均，其Matlab语句为：
y1=filter([0.50.25],1,x);
y2=filter([0.5 0.25],1,fliplr(x));
y=y1+fliplr(y2)-0.5*x; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75539f298d0d6f4a834b2f41a0a5cc48/" rel="bookmark">
			mapshaper系列之五-  信息类命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面分别介绍了mapshaper的I/O、编辑命令，下面介绍信息类命令。 1. -calc&lt;统计&gt; 利用JS表达式计算并展现数据表的基本描述性统计结果，以下函数已经实现： count() sum() average() median() mode() min() max() collect() 返回包含所有值的集合 first() last() count()没有参数，其他函数将JS表达式或属性名称作为参数，参数表达式与 -each 表达式格式相同。如果没有记录，count()和sum()返回0，其他函数返回 null。 其他可选项： &lt;expression&gt;： 包含调用一个或多个 -calc 函数的JS表达式； where=：利用返回值为boolean的JS表达式对要素进行过滤，参与计算的是满足条件的要素子集。 target=: 示例： # 计算字段POPULATION的和 mapshaper ny-census-blocks.shp -calc 'sum(POPULATION)' # 统计POPULATION=0的记录数据 mapshaper ny-census-blocks.shp -calc 'count()' where='POPULATION == 0' 2. -encoding &lt;编码&gt; 列出所有的文本编码格式。 3. -help &lt;帮助信息&gt; 输出有用的信息和一系列的命名。 &lt;command&gt; ：显示单个命令的可选参数，如 mapshaper -h json 4. -info &lt;数据信息&gt; 打印数据集的信息，对于查看图层属性表的字段很有帮助，对于总结一系列命令的结果也很有作用。 #示例: 获取json数据的信息 mapshaper mystery_file.json -info 5. -inspect 列出属性表中一条要素的信息。 &lt;expression&gt;：用于选择一个要素的JS表达式（查看-each命令中JS表达式的文档说明）。 target： # Example: 查看states.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75539f298d0d6f4a834b2f41a0a5cc48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/321efbf8f493d9fe2d64318dbe40af1d/" rel="bookmark">
			如何解决Qt程序在其他电脑上无法运行的问题（Qt程序打包发布）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天在研究Qt，首先尝试用Qt Creator编写一些小程序来练练手。但是，在这个过程中却遇到了一个问题：使用Qt Creator编写的exe程序，只能在本机运行，跑到别的电脑上就无法运行了，提示缺少各种各样的库。这个问题，我之前在搞VS-MFC的编程时，也遇到过，无非就是一些运行时库的问题导致的。当时的做法时，根据程序运行时报错所缺失的库，一个一个手工查找和拷贝，收集全部所依赖的库到程序目录下，程序就可以正常运行了。因此，对于这次的情况，我原本也打算这么做。但是，无意间在一篇博客里看到，Qt的设计者其实一早就料到有这种情况发生的，所以，他们为Qt专门设计了一个发行程序时自动对依赖库打包的工具，可以全自动为用户完成上述工作，那可就方便多了。下面就对这个工具的用法进行介绍：
1、首先找到这个工具，这个工具叫做“windeployqt”。它一般位于Qt安装目录下的mingw_XX\bin目录下，像我的目录就在C:\ProgramData\Qt\5.8\mingw53_32\bin。
此时，建议将整个目录直接加入系统环境变量，便于后续使用。
2、编译你的程序，注意必须是release版本。debug版本的貌似不行。
3、启动cmd，进入到你要发布的程序所在的目录，比如我的程序放在D:\Test目录下，就输入”cd /d d:\test”，记住里面一定要加”/d”的参数，否则将无法进入该目录。
4、确认你的程序是用Qt Creator哪个模式设计的，总共有2个模式，Qt Widgets Application和Qt Quick Application，不同模式下的参数命令是不一样的：
在Qt Widgets Application模式下 输入”windeployqt hello.exe”命令，其中hello.exe是我的程序名称。
Qt Quick Application模式下 输入”windeployqt hello.exe –qmldir”命令， 其中hello.exe是我的程序名称，qmldir是你的qml目录，这个目录一般位于mingwXX目录下，像我的目录就在C:\ProgramData\Qt\5.8\mingw53_32\qml。
5、输入上述命令之后，Qt就会自动复制它所依赖的各个插件文件夹和 dll文件、qm文件，得到的就完整的 exe 程序发布集合，依赖关系都解决好了，可以直接发布到其他的电脑上运行。
6、要注意的是，按照上述步骤完成之后，仍有可能会提示dll缺失信息，像我就遇到了缺失的提示。不过，好在此时缺失的dll很少（我遇到的就只有3个：libwinpthread-1.dll、libstdc++-6.dll、以及libgcc_s_dw2-1.dll），可以手动去复制，根据我的经验，可以直接在C:\ProgramData\Qt\5.8\mingw53_32\bin目录下面找到这几个dll。
7、其他未尽事项，建议大家参考以下这篇博文，介绍的非常详细。
http://blog.csdn.net/liuyez123/article/details/50462637
8、搞定，收工！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8a7b475a6627b7121a6e4b175b87388/" rel="bookmark">
			Thrift序列化与反序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Thrift提供了可扩展序列化机制, 不但兼容性好而且压缩率高。 我们来比较下常见的数据传输格式 数据传输格式类型优点缺点Xml文本1、良好的可读性
2、序列化的数据包含完整的结构
3、调整不同属性的顺序对序列化/反序列化不影响1、数据传输量大
2、不支持二进制数据类型Json文本1、良好的可读性
2、调整不同属性的顺序对序列化/反序列化不影响1、丢弃了类型信息, 比如"price":100, 对price类型是int/double解析有二义性
2、不支持二进制数据类型Thrift二进制高效1、不宜读
2、向后兼容有一定的约定限制，采用id递增的方式标识并以optional修饰来添加Google Protobuf二进制高效1、不宜读
2、向后兼容有一定的约定限制 Thrift 支持的数据类型 1、基本类型 bool: 布尔值 byte: 8位有符号整数 i16: 16位有符号整数 i32: 32位有符号整数 i64: 64位有符号整数 double: 64位浮点数 string: UTF-8编码的字符串 binary: 二进制串 2、结构体类型 struct: 定义了一个很普通的OOP对象，但是没有继承特性，用法如下： struct User {
1: i32 uid,
2: string name
} 如果变量有默认值，可以直接写在定义文件里: struct User {
1: i32 uid = 1,
2: string name = "User1"
} 说明： a. 每个域有一个唯一的，正整数标识符 b. 每个域可以标识为required或者optional（也可以不注明） c. 结构体可以包含其他结构体 d. 域可以有缺省值 e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8a7b475a6627b7121a6e4b175b87388/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef2d3c39ce7518448470ffa628ce48ba/" rel="bookmark">
			TF-IDF理解及其Java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://www.cnblogs.com/ywl925/archive/2013/08/26/3275878.html
前言 前段时间，又具体看了自己以前整理的TF-IDF，这里把它发布在博客上，知识就是需要不断的重复的，否则就感觉生疏了。
TF-IDF理解 TF-IDF（term frequency–inverse document frequency）是一种用于资讯检索与资讯探勘的常用加权技术, TFIDF的主要思想是：如果某个词或短语在一篇文章中出现的频率TF高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。TFIDF实际上是：TF * IDF，TF词频(Term Frequency)，IDF反文档频率(Inverse Document Frequency)。TF表示词条在文档d中出现的频率。IDF的主要思想是：如果包含词条t的文档越少，也就是n越小，IDF越大，则说明词条t具有很好的类别区分能力。如果某一类文档C中包含词条t的文档数为m，而其它类包含t的文档总数为k，显然所有包含t的文档数n=m + k，当m大的时候，n也大，按照IDF公式得到的IDF的值会小，就说明该词条t类别区分能力不强。但是实际上，如果一个词条在一个类的文档中频繁出现，则说明该词条能够很好代表这个类的文本的特征，这样的词条应该给它们赋予较高的权重，并选来作为该类文本的特征词以区别与其它类文档。这就是IDF的不足之处.
TF公式：
以上式子中 是该词在文件中的出现次数，而分母则是在文件中所有字词的出现次数之和。
IDF公式：
|D|：语料库中的文件总数：包含词语的文件数目（即的文件数目）如果该词语不在语料库中，就会导致被除数为零，因此一般情况下使用 然后
TF-IDF案例 案例：假如一篇文件的总词语数是100个，而词语“母牛”出现了3次，那么“母牛”一词在该文件中的词频就是3/100=0.03。一个计算文件频率 (DF) 的方法是测定有多少份文件出现过“母牛”一词，然后除以文件集里包含的文件总数。所以，如果“母牛”一词在1,000份文件出现过，而文件总数是10,000,000份的话，其逆向文件频率就是 lg(10,000,000 / 1,000)=4。最后的TF-IDF的分数为0.03 * 4=0.12。
TF-IDF实现（Java） 这里采用了外部插件IKAnalyzer-2012.jar，用其进行分词，插件和测试文件可以从这里下载：点击 具体代码如下：
按 Ctrl+C 复制代码 package tfidf; import java.io.*; import java.util.*; import org.wltea.analyzer.lucene.IKAnalyzer; public class ReadFiles { /** * @param args */ private static ArrayList&lt;String&gt; FileList = new ArrayList&lt;String&gt;(); // the list of file //get list of file for the directory, including sub-directory of it public static List&lt;String&gt; readDirs(String filepath) throws FileNotFoundException, IOException { try { File file = new File(filepath); if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef2d3c39ce7518448470ffa628ce48ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4915d2259f9942102f03766c02398ff3/" rel="bookmark">
			matlab建立BP神经网络中train函数的参数及学习算法参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.神经网络主要训练参数
net.trainParam.goal=0.1 % 训练目标最小误差，这里设置为0.1
net.trainParam.epochs=300; % 训练次数，这里设置为300次
net.trainParam.show=20; % 显示频率，这里设置为没训练20次显示一次
net.trainParam.mc=0.95; % 附加动量因子
net.trainParam.lr=0.05; % 学习速率，这里设置为0.05
net.trainParam.min_grad=1e-6; %最小性能梯度
net.trainParam.min_fail=5; % 最大确认失败次数
2.newff函数中训练函数
(1） traingd：基本梯度下降法，收敛速度比较慢。
（2） traingda：自适应学习率的梯度下降法
（3） traingdm：带有动量项的梯度下降法, 通常要比traingd 速度快。
（4） traingdx: 带有动量项的自适应学习算法, 速度要比traingdm 快。
（5） trainrp: 弹性BP 算法, 具有收敛速度快和占用内存小的优点。
（6） traincgf: Fletcher-Reeves 共轭梯度法,为共轭梯度法中存储量要求最小的算法。
（7） traincgp: Polak-Ribiers共轭梯度算法, 存储量比traincgf稍大,但对某些问题收敛更快。
(8) traincgb: Powell-Beale共轭梯度算法,存储量比traincgp稍大,但一般收敛更快，以上三种共轭梯度法,都需要进行线性搜索。
(9) trainscg: 归一化共轭梯度法,是唯一一种不需要线性搜索的共轭梯度法。
(10) trainbfg: BFGS- 拟牛顿法, 其需要的存储空间比共轭梯度法要大,每次迭代的时间也要多,但通常在其收敛时所需的迭代次数要比共轭梯度法少,比较适合小型网络。
(11) traino ss: 一步分割法,为共轭梯度法和拟牛顿法的一种折衷方法。
(12) trainlm: Levenberg-Marquardt算法,对中等规模的网络来说, 是速度最快的一种训练算法, 其缺点是占用内存较大。对于大型网络, 可以通过置参数mem-reduc 为1, 2, 3,⋯,将Jacobian 矩阵分为几个子矩阵。但这样也有弊端, 系统开销将与计算Jacobian的各子矩阵有很大关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4915d2259f9942102f03766c02398ff3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5220e18f477d3ea4d2002a5049e200ba/" rel="bookmark">
			Unity3D Asset文件导出3DMax 可编辑格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章由cartzhang编写，转载请注明出处。 所有权利保留。 文章链接：http://blog.csdn.net/cartzhang/article/details/60878354 作者：cartzhang
一、前言 美术想要一个把unity中*.asset的模型导出来，导成3D Max可以打开的模式，fbx或obj. 需要导出的格式：
图1 也就是需要一个工具，个人觉得这个问题，肯定之前Unity的前辈就有解决方法了。于是乎网上一通下载和测试。
二、解包工具集合 网络上找来了各种测试，但是没有一个适合我的，很多都是失败，打不开。 参考宣雨松的博客，找了还是没有结果。
图3 解包工具有很多种类， disunity github地址: https://github.com/ata4/disunity 还有就是AssetAssetsExport，还有Unity Studio. 别人的博客里面都有比较多的介绍和说明，这里就详细说了。 最后还网上wiki里，找到了一个合适的我自己的解包。 http://wiki.unity3d.com/index.php?title=ObjExporter
三、初步成果 找到了一个网站：http://wiki.unity3d.com/index.php?title=ObjExporter 可以导出部分对象。 如下图：
图0 而原来unity中模型是这个样子的。
图4 导出的只有武器和头盔，没有人物主体body.
四、bug修改 其实也不能算bug，也许人家没有这样的需要呢。
Component[] meshfilter = selection[i].GetComponentsInChildren&lt;MeshFilter&gt;(); MeshFilter[] mf = new MeshFilter[meshfilter.Length]; int m = 0; for (; m &lt; meshfilter.Length; m++) { exportedObjects++; mf[m] = (MeshFilter)meshfilter[m]; } 代码中是要查找所有组件中的MeshFilter，发现SkinnedMeshRender组件居然没有这个MeshFilter这个组件，所以总会导出少一个，而这个居然是人的主体。
图5 本来说让美术自己添加一个MeshFilter组件，然后根据mesh render中的mesh自己来添加一个对应的mesh. 既然是程序，那就想办法，思路很明显，既然是有meshrender,就从这入手呗。 代码还是不难度。
// 没有meshFilter，添加一个meshFilter. SkinnedMeshRenderer[] meshfilterRender = selection[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5220e18f477d3ea4d2002a5049e200ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8977ea3947c101816ca5fbc6684318ad/" rel="bookmark">
			cocos2dx tolua &#43;&#43; 使用 常见得错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤: 1、安装必要的库和工具包，以及配置相关环境变量，请按照cocos2d-x-3.0rc0\tools\tolua\README.mdown说得去做 （注意：尽量用README.mdown说的同一个ndk版本（最好用9系列），不然需要改东西，NDK各个版本链接） 2、写c++类(我测试用的是cocos2d-x-3.0rc0\tests\lua-empty-test\project\Classes\自定义.cpp)
注意：你写的方法一定要public，不然不会编译到lua，会报错attempt to call method ‘方法名’ (a nil value) 注意：在xcode写c++类的时候，如果包含路径一定要写完，xcode不会报错，但是tolua是就会又问题了！（TranslationUnitLoadError: Error parsing translation unit.）
注意：如果自定义的类别里有自行定义的 namespace 时，跑 .bat 后看 output log 的最后一行会发现这样的错误：
Exception: The namespace (Evo::TalkWidget) conversion wasn’t set in ‘ns_map’ section of the conversions.yaml
去找一下 conversions.yaml 这个档，位置应该在 /tools/bindings-generator/targets/lua 底下，直接用文字编辑器打开来看。
把自订的 namespace 加到 ns_map 的变数中，那个 .ini 里的 cpp_namespace 作用
要加的内容如下：
ns_map: “cocos2d::extension::”: “cc.” “cocos2d::ui::”: “ccui.” “cocos2d::”: “cc.” “spine::”: “sp.” “cocostudio::”: “ccs.” “cocosbuilder::”: “cc.” “CocosDenshion::”: “cc.” 3、写一个生成的python脚本，你不会写，没关系，我们会照着葫芦画瓢 1）进入目录cocos2d-x-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8977ea3947c101816ca5fbc6684318ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6d78edc4e24f4ff6ca0f72aa0669d57/" rel="bookmark">
			Java中String字符串初始化细节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中String类型细节 一 . String两种初始化方式 1 . String str1= “abc”;//String类特有的创建字符对象的方式，更高效 在字符串缓冲区中检测”abc”是否存在 若存在则不重复创建，将地址赋值给str1. 若不存在，则在字符串缓冲区中创建对象并赋地址给str1.
2 . String str1= new String( “abc”); //构造函数初始化 或者 char [] ch={‘a’,’b’,’c’}; String str1=new String (ch); 先有 “abc” 对象，然后拷贝给构造函数创建的对象（相当于str1得到的是构造函数的副本）
String对象是不可变的，它的内容不能改变，而在程序中字符串频繁使用，为了提高效率，对具有相同字符串序列的字符串直接量使用同一个实例，这样的实例被称之为限定的（interned）
注意，第二种方式的参数只支持字符串直接量或字符数组创建，这种方式是错误的 String strA = “asd”; String strbB = new Strint(strA);
比较两种创建方式，第一种更高效，只创建了一个对象，第二种创建了两个对象。
二 . 初始化细节 栈中保存基本类型与对象的引用，基本类型在创建前会查看Stack中是否已经有, 有则赋值指向, 没有则创建。
String str1= “abc”; String str1= new String( “abc”); 前者首先在栈中创建一个引用型变量str1，然后查看栈中是否存在“abc”如果没有，则将“abc”存放进栈，并令引用变量str指向它；如果有，则直接令str1指向它；后者是java中标准的对象创建方式，其创建的对象将直接放置到堆中，每调用一次就会创建一个新的对象。
String str = “abc”+”def”; 这条语句创建对象个数？ 1个。 编译器会自己调用Stringbuilder的append方法来合成abcdef，最后只生成一个对象.
实际上，字符串直接量属于常量，在编译的时候已确定，两个常量相加，先检测栈内存中是否有”abcdef” 如有有，指向已有的栈中的”abcdef”空间，若没有，则创建。
package stringDemo; public class stringInitial { public static void main(String[] args) { String str1 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6d78edc4e24f4ff6ca0f72aa0669d57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e11c41c4503651e78554def1d574241/" rel="bookmark">
			react——JSX语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;div id="example"&gt;&lt;/div&gt; &lt;div id="example2"&gt;&lt;/div&gt; &lt;div id="example3"&gt;&lt;/div&gt; &lt;div id="example4"&gt;&lt;/div&gt; &lt;div id="example5"&gt;&lt;/div&gt; &lt;div id="example6"&gt;&lt;/div&gt; &lt;div id="example7"&gt;&lt;/div&gt; &lt;div id="example8"&gt;&lt;/div&gt; &lt;h1&gt;react JSX&lt;/h1&gt; &lt;p&gt; react是使用JSX来代替常规的JavaScript；JSX看起来是一个很像XML的JavaScript语法拓展；我们不需要一定使用JSX， 但它有以下优点：JSX执行更快，因为在编译为JavaScript代码后进行了优化；他是类型安全的，在编译过程中就能发现错误； 使用JSX编写模块更加简单快速 。 &lt;/p&gt; &lt;script type="text/babel"&gt; //JSX看起来类似和HTML，我们可以看下实例 ReactDOM.render( &lt;h1&gt;Hello,World!!&lt;/h1&gt;, document.getElementById("example") ) &lt;/script&gt; &lt;p&gt;我们可以在上一代码中嵌套多个HTML标签，需要使用一个div元素包裹他，实例中的p元素添加了自定义data-myattribute, 添加自定义属性需要使用data-前缀。&lt;/p&gt; &lt;script type="text/babel"&gt; ReactDOM.render( &lt;div&gt; &lt;h1&gt;菜鸟教程&lt;/h1&gt; &lt;h2&gt;欢迎学习react&lt;/h2&gt; &lt;p data-myattribute="somevalue"&gt;这是一个很不错的JavaScript框架&lt;/p&gt; &lt;/div&gt;, document.getElementById("example2") ); &lt;/script&gt; &lt;p&gt;当然也可以将以上代码放到一个独立的js中，不过type="text/babel"&lt;/p&gt; &lt;p&gt;我们可以再JSX中使用JavaScript表达式，表达式写在花括号中&lt;/p&gt; &lt;script type="text/babel"&gt; ReactDOM.render( &lt;div&gt; &lt;h1&gt;{ 25 +25 }&lt;/h1&gt; &lt;/div&gt;, document.getElementById("example3") ) &lt;/script&gt; &lt;p&gt;在JSX中不能使用if else语句，但可以使用conditional（三元运算）表达式来代替。&lt;/p&gt; &lt;script type="text/babel"&gt; var i = 1; ReactDOM.render( &lt;div&gt; &lt;h1&gt;{ i == 1 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e11c41c4503651e78554def1d574241/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c89dbe1e009e4ab8cc696bf77995c57b/" rel="bookmark">
			MFC函数GetModuleFileName()：获得应用程序目录绝对路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GetModuleFileName()得到模块的完整路径名，例如，你载入c:\windows\system32\a.dll，得到模块句柄h，则你可以用GetModuleFileName()得到h模块的完整路径名。
注：直接用LoadLibrary()或AfxLoadLibrary()载入dll，该函数返回值就是handle；如果你隐式载入dll, 用GetModuleHandle("dll文件名")也可以得到handle
DWORD GetModuleFileName( HMODULE hModule, // handle to module。将要得到的模块的句柄。如果是当前模块，NULL LPTSTR lpFilename, // path buffer 得到的文件名。 DWORD nSize // size of buffer 一般MAX_PATH就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca37d9456b58b4ee1b0e0eb7d2411700/" rel="bookmark">
			mapshaper系列之四 - 编辑命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面介绍了mapshaper的输入/输出命令，本节介绍mapshaper的核心内容：编辑命令。编辑命令有很多，下面一一介绍。
1. -clip&lt;裁剪&gt;
移除裁剪范围外的要素或部分要素。有如下参数：
source：数据源，通过裁剪多边形的文件名或图层id指定裁剪的多边形要素数据集；
bbox=&lt;xmin,ymin,xmax,ymax&gt;：通过bbox指定裁剪的范围，删除bbox范围外的要素或部分要素；
remove-slivers：移除由裁剪产生的极小长条形多边形；
其他可选项：name和target。
#示例: 使用land-area.shp裁剪usa_counties.shp mapshaper usa_counties.shp -clip land-area.shp -o 2. -dissolve&lt;合并&gt;
以指定的属性合并一组要素，若没有指定属性字段，则合并所有要素。对于多边形图层，-dissolve 在合并相邻多边形时会删除公共边界；对于点图层，-dissolve 合并后得到一组点的质心；-dissolve 不支持线图层。
&lt;field&gt; ：合并依赖的属性名称；
weight= ：（针对点图层）指定属性名称或JS表达代表各点在生成质心中的权重。例如，如下命令估算美国人口分布的质心：
mapshaper census_tracts.shp -points -dissolve weight=POPULATION planar：（针对点图层）在计算合并后的质心时，将十进制的度坐标当作平面直角坐标看待。默认情况下，mapshaper在3D空间中计算经纬度点的质心）； calc=：在合并后的图层中使用构建的JS函数来创建属性，详情参见下面的示例，也可参考 -calc支持的一系列函数；
sum-fields=：合并时求和的字段名称，多个用逗号分隔；
copy-fields=：合并时复制（保留）的字段，多个用逗号分开；字段值来源于待合并的一组要素中第一个要素的值；
其他可选项：name= 和 target=
# 示例:以属性STATE合并要素 mapshaper counties.shp -dissolve STATE -o states.shp # 示例: 以属性STATE合并要素，同时计数要素个数、总人口、最大人口和最小人口 mapshaper counties.shp -dissolve STATE calc='n = count(), total_pop = sum(POP), max_pop = max(POP), min_pop = min(POP)' 3. -dissolve2&lt;合并&gt; 与dissolve类似，但可以用来合并相邻或重叠的多边形（考虑拓扑关系），若多边形不相交且数据量很大，使用dissolve。
4. -each
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca37d9456b58b4ee1b0e0eb7d2411700/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a491a9b89c5a6bcf6485378293e6daa/" rel="bookmark">
			浅尝树莓派3之串口配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树莓派3硬件串口的使用及编程 发表于 2017-01-29 | 分类于 树莓派 | 暂无评论 | 阅读次数 54 引言 本文转载自： http://etrd.org/2017/01/29/%E6%A0%91%E8%8E%93%E6%B4%BE3%E7%A1%AC%E4%BB%B6%E4%B8%B2%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%BC%96%E7%A8%8B/ 主要为了记录下来下次再配置时的方便。 通常学习一块新的硬件平台，大家第一个工程便是流水灯，实际上这属于IO口的基本控制，这与上篇文章VS使用wiringPi库控制树莓派的GPIO是异曲同工的，接下来便应该是开始使用其通信接口，而通信接口里面最简单的又属串口（uart），虽然简单但目前仍然有很多模块是以串口作为通信接口的，如一些蓝牙模块、低速wifi模块、GPS模块、GPRS模块等。树莓派3代与之前的树莓派相比除了CPU性能上的提升外，还有一个显著的特色便是板载集成了WIFI及蓝牙，正是由于集成的这个蓝牙模块，又使得树莓派3代的串口使用相比于之前版本有了些麻烦，本文的目的便是解决这些麻烦并编写验证了一个简单的串口代码。
树莓派3代串口的麻烦 树莓派从大的方向来说一共出了3代，每一代的CPU外设基本相同，但内核不同，外设里面一共包含两个串口，一个称之为硬件串口（/dev/ttyAMA0），一个称之为mini串口（/dev/ttyS0）。硬件串口由硬件实现，有单独的波特率时钟源，性能高、可靠，mini串口性能低，功能也简单，并且没有波特率专用的时钟源而是由CPU内核时钟提供，因此mini串口有个致命的弱点是：波特率受到内核时钟的影响。内核若在智能调整功耗降低主频时，相应的这个mini串口的波特率便受到牵连了，虽然你可以固定内核的时钟频率，但这显然不符合低碳、节能的口号。在所有的树莓派板卡中都通过排针将一个串口引出来了，目前除了树莓派3代以外 ，引出的串口默认是CPU的那个硬件串口。而在树莓派3代中，由于板载蓝牙模块，因此这个硬件串口被默认分配给与蓝牙模块通信了，而把那个mini串口默认分配给了排针引出的GPIO Tx Rx，下图是树莓派3的接口图
其中红框中就是引出的串口IO，如果我们需要通过UART外接模块，默认情况下必须得使用性能很低的mini串口了，而且随着内核主频的变化，还会造成波特率的变化导致通信的失败，几乎很难使用。所以我们希望恢复硬件串口与GPIO 14/15的映射关系，使得我们能够通过GPIO使用高性能的硬件串口来连接我们的串口设备。
将树莓派3的硬件串口与mini串口默认映射对换 树莓派可以配置文件来修改设备树，我的理解是可以通过配置文件来修改管脚的映射关系，这在许多Cortex-M3内核的单片机中也很常见，可以将同一个串口映射到不同的管脚上，以方便PCB的布线。
为了在树莓派3中通过GPIO使用高性能的硬件串口，我们必须将分配给蓝牙使用的硬件串口与分配给IO排针的mini串口进行对换，这必然会使得蓝牙模块的功能受到影响，但还好，蓝牙并不是必须的。
在树莓派系统中
1 /boot/overlays/ 目录下，提供了一个pi3-miniuart-bt-overlay.dtb的文件，这个文件的作用可以通过该目录下的README文件查看
如果没有pi3-miniuart-bt-overlay.dtb这个文件，点击 http://ukonline2000.com/wp-content/uploads/2016/03/ 下载
README文件中说明了这个文件的功能是将树莓派3的蓝牙切换到mini串口（ttyS0），并且恢复硬件串口（ttyAMA0）到GPIO 14&amp;15脚中。并且给出了载入的方法。
首先在树莓派命令终端中通过命令查看树莓派3当前的串口映射关系
1 ls -l /dev 红色框中体现的应该是一种映射关系，此处暂时没有做深究，简单理解 serial0 就是GPIO映射的串口，此时GPIO映射的串口是默认的/dev/ttyS0这个mini串口。
使用下面这条指令编辑 /boot/config.txt 文件
1 sudo nano /boot/config.txt 在该文件中增加一行代码
1 dtoverlay=pi3-miniuart-bt 然后保存文件，重启树莓派使之生效。
再通过 ls -l /dev 命令查看修改后的映射关系
对比修改前的关系，可以看出serial0和serial1 与 ttyAMA0和ttyS0的映射关系对换完成了，也就是ttyAMA0映射到了引出的GPIO Tx Rx上。
禁用串口的控制台功能 前面的步骤已经交换了硬件串口与mini串口的映射关系，但现在想使用树莓派外接串口模块进行通信还不行，因为树莓派IO引出的串口默认是用来做控制台使用的，它的初衷是为了在没有网络接口时，通过串口对树莓派进行相关的配置。因此需要禁用这个默认功能，使得串口为我们自由使用。
在树莓派命令窗口中分别通过如下两个命令停止和禁用串口的控制台功能
1 2 sudo systemctl stop serial-getty@ttyAMA0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a491a9b89c5a6bcf6485378293e6daa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ad2a5f5c9dbc3b9be4cd05c215052ad/" rel="bookmark">
			初学python：运行环境与第一行代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境：在Ubuntu16.10自带python2.7.X; 安装一个代码编辑器notepadqq, 安装方法如下：
三条指令：
sudo add-apt-repository ppa:notepadqq-team/notepadqq sudo apt-get update sudo apt-get install notepadqq 变成界面是这样的： 不喜欢了就卸载它：
sudo apt-get remove notepadqq sudo add-apt-repository --remove ppa:notepadqq-team/notepadqq 为什么在linux下学习，因为我们知道python的一个极大的好处就是可以利用第三方库，有其实在学习机器学习和深度学习的时候，它会让你很轻松的利用这些第三方库（不做介绍了，网上一抓一大把） 二、第一个Python程序
在notepadqq中写：print('hello world') 保存为test.py.
在终端打开相应文件夹下，运行python test.py
C ++需要5行，python一行搞定，但是其缺点为：运行速度慢，不做解释了，了解有语言的都知道。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e9418878e2fc65695092dc3ee93ab8b/" rel="bookmark">
			Android ScrollView中嵌套ListView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于ScrollView嵌套ListView的 1（自定义）ListView可以通过重写onMeasure方法，将ListView的高度重新设置实现
public class ListViewForScrollView extends ListView { public ListViewForScrollView(Context context) { super(context); } public ListViewForScrollView(Context context, AttributeSet attrs) { super(context, attrs); } public ListViewForScrollView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); } /** * 重写该方法，使ListView适应ScrollView的效果 */ @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { //mode共有三种情况，取值分别为MeasureSpec.UNSPECIFIED, MeasureSpec.EXACTLY, MeasureSpec.AT_MOST。 //MeasureSpec.EXACTLY是精确尺寸，当我们将控件的layout_width或layout_height指定为具体数值时如andorid:layout_width="50dip"，或者为FILL_PARENT是，都是控件大小已经确定的情况，都是精确尺寸。 //MeasureSpec.AT_MOST是最大尺寸，当控件的layout_width或layout_height指定为WRAP_CONTENT时，控件大小一般随着控件的子空间或内容进行变化，此时控件尺寸只要不超过父控件允许的最大尺寸即可。因此，此时的mode是AT_MOST，size给出了父控件允许的最大尺寸。 //MeasureSpec.UNSPECIFIED是未指定尺寸，这种情况不多，一般都是父控件是AdapterView，通过measure方法传入的模式。 int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2, MeasureSpec.AT_MOST); super.onMeasure(widthMeasureSpec, expandSpec); } } 2 动态计算ListView的高度
public void setListViewHeightBasedOnChildren(ListView listView) { if(listView == null){ return; } ListAdapter listAdapter = listView.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e9418878e2fc65695092dc3ee93ab8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d15fcc3c12e049ebf6d01b3cdc1d319f/" rel="bookmark">
			Unity3D 常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. error CS0103: The name `Analytics’ does not exist in the current context Result
2. 运行Editor模式下，频繁卡死 原因是在于运行Editor时Unity3D会频繁请求网络，而且还都是境外服务，所以会造成卡死。 Mac下使用Little snitch限制Unity3D的网络请求就可以了。
3. WWW Error: Cannot create FMOD::Sound instance for resource (null), (An invalid parameter was passed to this function. ) unable to determine the audio type from the url 在使用WWW时碰到如上问题，但是我的数据都是Json数据，并没有取AudioType等。
发生问题的原因是当GameObjec被SetActive(false)时，协程会被中断，进而导致WWW也被中断，从而出现异常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7652494413b5595226007dee5c7d3398/" rel="bookmark">
			方法体执行完，线程会释放吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class Application { public static void main(String[] args) throws Exception { //SpringApplication.run(Application.class, args); Application application = new Application(); for(int i=0; i&lt;10000; i++){ Application.Sub sub = application.new Sub(); boolean value = sub.test(); System.out.println("end="+value); } } class Sub{ public Boolean test() throws Exception{ ExecutorService service = Executors.newFixedThreadPool(2); CompletionService&lt;Boolean&gt; completionService = new ExecutorCompletionService&lt;Boolean&gt;(service); try { for(int i=0; i&lt;1; i++){ completionService.submit(new Callable&lt;Boolean&gt;() { @Override public Boolean call() throws Exception { Thread.sleep(100); //throw new NullPointerException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7652494413b5595226007dee5c7d3398/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcdd9eb076800e8715ee3a55e8a126b2/" rel="bookmark">
			《机器学习实战》学习笔记之k-近邻算法3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.3 手写识别系统
从os模块中导入listdir函数，用来读取给定目录中的文件名
from os import listdir关于zeros函数的使用， 代码及注释
#image convert to vector def img2vector(filename): returnVect = zeros((1,1024)) fr = open(filename) for i in range(32): lineStr=fr.readline() for j in range(32): returnVect[0,32*i+j] = int(lineStr[j]) return returnVect def handwritingClassTest(): hwLabels = [] trainingFileList = listdir('digits/trainingDigits') m = len(trainingFileList)#训练样本的个数 trainingMat = zeros((m,1024))#创建训练矩阵，每行有1024个元素，表示一个训练样本 for i in range(m): fileNameStr = trainingFileList[i]#第i个训练样本 fileStr = fileNameStr.split('.')[0] classNumStr = int(fileStr.split('_')[0])#样本命名的第一个数字表示实际的分类 hwLabels.append(classNumStr)#得到训练集的所有分类 trainingMat[i,:] = img2vector('digits/trainingDigits/%s'%fileNameStr)#将所有样本转换成矩阵,得到训练样本集 testFileList = listdir('digits/testDigits') errorCount = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcdd9eb076800e8715ee3a55e8a126b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94385e958bba0295b826ed3b527abdf3/" rel="bookmark">
			mapshaper系列之二 - mapshaper命令汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mapshaper的命令分为三类，下面简单介绍如下。
I/O命令 -i 输入一个或多个文件 -o 输出编辑后的内容 编辑命令 -clip &lt;裁剪&gt;移除裁剪范围外的要素或部分要素 -cluster &lt;聚类&gt;将多边形分成简洁的聚簇组 -dissolve &lt;合并&gt;合并多边形或点要素 -dissolve2 &lt;合并&gt;合并相邻或重叠的多边形（多多边形不想交且数据量大，可使用dissolve） -each 利用js表达式创建/更新/删除数据项 -erase &lt;擦除&gt;移除落在多边形范围内的要素或部分要素 -explode &lt;打散&gt;将图层中的每个多部件要素打散成几个独立部分的要素 -filter &lt;过滤要素&gt;通过条件过滤掉不满足条件的要素 -filter-fields &lt;过滤字段&gt;删除属性表中的字段（可指定保留的字段） -filter-islands &lt;过滤孤岛/环&gt;移除小的独立的环状多边形/孤岛 -filter-silvers &lt;过滤面积&gt; 通过面积过滤掉多边形小碎片 -graticule &lt;格网&gt;创建经度为0度、覆盖世界的网格图层 -linerlines &lt;共享边界&gt;创建由共享边界构成的线状图层（无属性） -join &lt;连接&gt; 将源图层或文件的属性数据连接到目标图层 -lines &lt;边界&gt; 将多边形转成有拓扑的边界 --merge-layers &lt;融合&gt; 将几个图层的多个要素融合到一个图层中 -point-grid 创建矩形网格点 -points &lt;点要素&gt; 从多边形或属性表创建点要素图层 -proj &lt;投影&gt; 利用proj4字符串或别名投影数据集 -rename-fields 重命名数据域 -rename-layers 重命名图层 -simplify &lt;简化&gt; 利用道格拉斯或其他两种方法对数据进行简化 -sort &lt;排序&gt; 利用js表达式对要素进行排序 -split &lt;拆分&gt; 基于属性值将目标层的数据拆分到多个输出层中，如果没有指定数据域，每个要素都将成为独立的图层 -slpit-on-grid &lt;切块&gt; 指定行列数将要素分割成独立的图层 -subdivide -svg-style 为svg格式输出和在web UI中的展现添加通用svg样式属性 -target 设置默认目标图层 -uniq &lt;唯一化&gt; 删除与前面要素id重复的要素 信息类命令 -calc &lt;统计&gt; 利用js表达式计算并展现数据表的基本描述性统计结果 -encodings 列出所有支持的文本编码格式 -help -h 帮助信息 -info 数据信息 -inspect 列出一条要素的属性信息 -projections 列出所有proj4支持的投影id和别名 -quiet 禁止控制台信息 -verbose 打印详细的信息，包括每个处理步骤的时间 -version 版本信息 以上是对命令的简单介绍，从中我们可以发现，Mapshaper基本上支持所有常用的数据处理操作。对于少量的数据处理，我们完全可以使用Mapshaper来代替大而全的ARCGIS Desktop。后面会陆续介绍每个命令的参数及使用示例。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60da03d0deb4a0b53005955126387d2f/" rel="bookmark">
			TreeMap实现原理深度分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尊重作者的成果，本文大部分内容转自：http://cmsblogs.com/?p=1013（原文）；为方便学习注释使用而转载，文章内容或含义可能会因为本人进行理解性加注后与原文有出入，如需阅读原文请跳转。
TreeMap的实现是红黑树算法的实现，所以要了解TreeMap就必须对红黑树有一定的了解,通过这篇博文你可以获得如下知识点：
红黑树的基本概念。 红黑树增加节点、删除节点的实现过程。红黑树左旋转、右旋转的复杂过程。 Java中TreeMap是如何通过put、deleteEntry两个来实现红黑树增加、删除节点的。 我想通过这篇博文你对TreeMap一定有了更深的认识。好了，下面先简单普及红黑树知识。
一、 红黑树简介 红黑树又称红-黑二叉树，它首先是一颗二叉树，它具体二叉树所有的特性。同时红黑树更是一颗自平衡的排序二叉树。 我们知道一颗基本的二叉树他们都需要满足一个基本性质–即树中的任何节点的值大于它的左子节点，且小于它的右子节点。按照这个基本性质使得树的检索效率大大提高。我们知道在生成二叉树的过程是非常容易失衡的，最坏的情况就是一边倒（只有右/左子树），这样势必会导致二叉树的检索效率大大降低（O(n)），所以为了维持二叉树的平衡，大牛们提出了各种实现的算法，如：AVL，SBT，伸展树，TREAP，红黑树等等。 平衡二叉树必须具备如下特性：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个等等子节点，其左右子树的高度都相近。 红黑树顾名思义就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持着二叉树的平衡。对于一棵有效的红黑树二叉树而言我们必须增加如下规则： 1、每个节点都只能是红色或者黑色 2、根节点是黑色 3、每个叶节点（NIL节点，空节点）是黑色的。 4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。 5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这棵树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。所以红黑树它是复杂而高效的，其检索效率O(logn)。下图为一颗典型的红黑二叉树。 对于红黑二叉树而言它主要包括三大基本操作：左旋、右旋、着色。 （图片来自： http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html） 本节参考文献：http://baike.baidu.com/view/133754.htm?fr=aladdin—–百度百科 注：由于本文主要是讲解Java中TreeMap，所以并没有对红黑树进行非常深入的了解和研究，如果诸位想对其进行更加深入的研究Lz提供几篇较好的博文： 1、红黑树系列集锦 2、红黑树数据结构剖析 3、红黑树 二、 TreeMap数据结构 TreeMap的定义如下：
public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable TreeMap继承AbstractMap，实现NavigableMap、Cloneable、Serializable三个接口。其中AbstractMap表明TreeMap为一个Map即支持key-value的集合， NavigableMap（更多）则意味着它支持一系列的导航方法，具备针对给定搜索目标返回最接近匹配项的导航方法 。 TreeMap中同时也包含了如下几个重要的属性： //比较器，因为TreeMap是有序的，通过comparator接口我们可以对TreeMap的内部排序进行精密的控制 private final Comparator&lt;? super K&gt; comparator; //TreeMap红-黑节点，为TreeMap的内部类 private transient Entry&lt;K,V&gt; root = null; //容器大小 private transient int size = 0; //TreeMap修改次数 private transient int modCount = 0; //红黑树的节点颜色--红色 private static final boolean RED = false; //红黑树的节点颜色--黑色 private static final boolean BLACK = true; 对于叶子节点Entry是TreeMap的内部类，它有几个重要的属性：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60da03d0deb4a0b53005955126387d2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad536b5f10b814cdaa7d22831cb03e80/" rel="bookmark">
			java创建Excel并下载至本地指定位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import org.apache.poi.hssf.usermodel.HSSFCell;
import org.apache.poi.hssf.usermodel.HSSFCellStyle;
import org.apache.poi.hssf.usermodel.HSSFFont;
import org.apache.poi.hssf.usermodel.HSSFRow;
import org.apache.poi.hssf.usermodel.HSSFSheet;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;
String[] tableHeader = { "列1", "列2"};//指定列名
short cellNumber = (short) tableHeader.length;// 表的列数 HSSFWorkbook workbook = new HSSFWorkbook(); // 创建一个excel HSSFCell cell = null; // Excel的列 HSSFRow row = null; // Excel的行 HSSFCellStyle style = workbook.createCellStyle(); // 设置表头的类型 style.setAlignment(HSSFCellStyle.ALIGN_CENTER); HSSFCellStyle style1 = workbook.createCellStyle(); // 设置数据类型 style1.setAlignment(HSSFCellStyle.ALIGN_CENTER); HSSFFont font = workbook.createFont(); // 设置字体 HSSFSheet sheet = workbook.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad536b5f10b814cdaa7d22831cb03e80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ed0e78693fd2a0dceb90ac52b984d15/" rel="bookmark">
			git 创建本地分支、提交到远程分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查看本地分支：
$ git branch master * mutilrecall 查看远程分支： $ git branch -a master * mutilrecall remotes/origin/master remotes/origin/mutilrecall 注：其中，remotes开头的代表是远程分支。 2、创建本地分支，并切换到分支：
$ git branch test kevinliu@TP-A1116-L MINGW64 /e/workspace_ttengine/ttengine (mutilrecall) $ git checkout test Switched to branch 'test' 3、本地分支关联远程分支： 在本地test分支上修改了代码后，需要提交到远程，这时就需要关联远程的某个远程分支，操作如下：
1）本地提交：
git gui 2）push到远程 $ git push origin test:test Counting objects: 15, done. Delta compression using up to 4 threads. Compressing objects: 100% (9/9), done. Writing objects: 100% (15/15), 927 bytes | 0 bytes/s, done.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ed0e78693fd2a0dceb90ac52b984d15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f57146b6a63de0809a716640fc85e7c8/" rel="bookmark">
			C#数据库查询结果赋值给对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类中的成员变量的定义 private int var{get;set;}&lt;param name="var_obj"&gt;需要赋值的对象&lt;/param&gt; &lt;param name="var_dt"&gt;需要赋值的数据表&lt;/param&gt;
public static object DBObject(object var_obj, DataTable var_dt) { object obj= var_obj; DataTable dt = var_dt; Type type = typeof(User); System.Reflection.PropertyInfo[] minfos = type.GetProperties(); foreach (PropertyInfo minfo in minfos) { Console.WriteLine("item" + minfo.Name); } for (int i = 0; i &lt; dt.Columns.Count; i++) { Console.WriteLine(dt.Columns[i].ColumnName.ToLower()); Console.WriteLine(dt.Rows[0][i].ToString()); var value = dt.Rows[0][i]; if (minfos[i].PropertyType == typeof(string)) { minfos[i].SetValue(obj,value.ToString()); string ttt = minfos[i].GetValue(obj).ToString(); } if (minfos[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f57146b6a63de0809a716640fc85e7c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7603b6c96bc73088504d25f5116b661/" rel="bookmark">
			Error:No service of type Factory&lt;LoggingManagerInternal&gt; available in ProjectScopeServices.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从github上clone了一个项目，却出现了Error:No service of type Factory&lt;LoggingManagerInternal&gt; available in ProjectScopeServices.的提示
clean一下项目，终于可以看到详细信息了。
接下来就继续搜错，could not create plugin of type 'androidmavenplugin'.的因为，说是meaven的原因，修改起来也特别简单，Project下的build.gradel，修改版本就好了。
将1.3的版本修改为1.4.1即可，如果还是不可以 ，就换一个别的版本号试一下，然后点击 Try Again，就搞定了。
dependencies{ classpath'com.android.tools.build:gradle:2.2.2'
classpath'com.github.dcendents:android-maven-gradle-plugin:1.4.1'
classpath'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.3.1'
// NOTE: Do not place your application dependencies here; they belong
// in the individual module build.gradle files
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/374d41189d6708c4e5469904b84b22cf/" rel="bookmark">
			wpf屏蔽快捷键alt&#43;space，alt&#43;F4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/// &lt;summary&gt;
/// 阻止 alt+f4和alt+space 按键
/// &lt;/summary&gt;
/// &lt;param name="e"&gt;&lt;/param&gt;
protected override void OnKeyDown(System.Windows.Input.KeyEventArgs e)
{
if (Keyboard.Modifiers == ModifierKeys.Alt &amp;&amp; e.SystemKey == Key.Space)
{
e.Handled = true;
}
else if (Keyboard.Modifiers == ModifierKeys.Alt &amp;&amp; e.SystemKey == Key.F4)
{
e.Handled = true;
}
else
{
base.OnKeyDown(e);
}
}
转载于:https://www.cnblogs.com/chlm/p/6382846.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ede3a2d6f05f51b167bc01966c71f822/" rel="bookmark">
			mapshaper系列之三 - I/O命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍Mapshaper的输入命令 -i（input）和输出命令-o（output）。
一、输入命令 -i
输入命令 -i 允许输入一个或多个shape、json、dbf或限定文本格式的文件。如果 mapshaper 后紧跟输入的文件名，命令 -i 可省略。JSON文件可以是geojson、topojson或数据记录的数组。mapshaper不完全支持shapefile中的Z值和M值，输入文件中的Z值和M值会丢失。默认情况下，输入的多个文件会分开单独处理，就像是同一个命令执行多次一样，但命令中出现参数 merge-files 和 combine-files 会改变这种情况。
可选择的参数如下：
&lt;files&gt; ：输入的单个或多个文件（以空格分割的列表），利用 "-" 从 "/dev/stdin"引进topojson或geojson；
merge-files： （不推荐使用）将输入多个文件中的要素合并到尽可能少的图层中；
推荐使用的方法：用"-i combine-files" 导入多个文件到分离的图层中，然后使用命令"-merge-layers"合并图层。
combine-files ： 以共享拓扑的方式导入多个文件到分离的图层中，这对生成一个包含多个几何对象的topojson文件很有价值。
snap： 将极小阈值范围内的顶点捕捉到一起，这个参数用于修复相邻多边形中极小的坐标偏差。每个平均分段长度的捕捉距离是0.0025。
auto-snap ： （不推荐使用）"snap"的别名。
snap-interval ： 指定以源数据为单位的捕捉距离。
precision ： （不推荐使用）将所有坐标四舍五入到指定的精度，如 0.001。强烈推荐在输出时使用 "-o precision="设置坐标的精度。
no-topology ： 在处理大数据量文件时，忽略拓扑标记以加快处理的速度，用于类似 "-filter"等不要求拓扑的命令。
encoding=： 指定读取 .dbf和限定格式文本文件的编码格式，如果不指定encoding参数，mapshaper会尝试检测 .dbf文件的编码方式，dbf的编码可以利用 .cpg 文件设置。
id-field=： 对于geojson和topojson文件，引入属性id的值到数据项中。
field-types： 属性的数据类型，字段名称与字段类型用 ":"连接，多个之间通过 “，”分隔，如 FIPS:str,zipcode:str。可识别的类型包括 :str，:string， :num 和 :number。对于没有指定类型的，类似数字的字段内容会被自动转成数字，如邮政编码。
name=： 重命名引入的图层。
示例：
#以latin1编码方式输入一个shapefile，同时查看包含的数据内容 mapshaper countries_wgs84.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ede3a2d6f05f51b167bc01966c71f822/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40cc5805140ce9f46b83f735524c07da/" rel="bookmark">
			MAC环境下安装SSH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 配置ssh 首先确认能够远程登录 系统偏好设置－共享 在终端执行
ssh-keygen -t rsa 一路回车就行 会在~/.ssh目录下生成两个文件 然后执行
cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 3、验证ssh ssh localhost 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40ee5a830069ba8dbc0965f1df998666/" rel="bookmark">
			javascript重点-表达式和运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、js表达式
定义：表达式是指能计算出值得任何可用程序单元。 ——wiki
表达式是js一种短语，可使js解释器用来产生一个值。 ——js《权威指南》
1.原始表达式。
常量/直接量： 3.14/ "test" 等
关键字： null，this，true，false 等
变量： i，k，j 等
复合表达式：原始表达式和原始表达式之间用运算符连接可以组成一个复合表达式。
例如： 10 * 20 这就是一个复合表达式
2.（数组、对象的）初始化表达式。
例如：
[1,2] 等价于 new Array（1,2）；[1，，，2] 等价于 new Array（1，undefined，undefined，2）；{x：1，y：2} 等价于 var obj = new Object（）；obj.x = 1;obj.y = 2;3.函数表达式。
var fn = function（）{}；
或者：
（function（）{ console.log("hello") }）()；
如果你不理解函数表达式后面还会有对应的介绍。
4.属性访问表达式。
var obj = {x：1}
我们可以通过 obj.x 或者 obj["x"]来访问它的属性，这一类表达式就称之为属性访问表达式。
5.调用表达式。
func（）； 来调用一个函数，这样的表达式就称之为调用表达式。
6.对象创建表达式。
例如：
new Func（1,2）；我们可以传参，如果没有参数我们也可以new Object；创建一个空的对象这样也是合法的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40ee5a830069ba8dbc0965f1df998666/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eead37e5334ec5d046844fdb65d037f/" rel="bookmark">
			4-10 二分查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4-10 二分查找
本题要求实现二分查找算法。
函数接口定义： Position BinarySearch( List Tbl, ElementType K );其中List结构定义如下：
typedef int Position;typedef struct LNode *List;struct LNode {ElementType Data[MAXSIZE];Position Last; /* 保存线性表中最后一个元素的位置 */};Tbl是用户传入的一个线性表，其中ElementType元素可以通过&gt;&gt;、====、&lt;&lt;进行比较，并且题目保证传入的数据是递增有序的。函数BinarySearch要查找K在Tbl中的位置，即数组下标（注意：元素从下标1开始存储）。找到则返回下标，否则返回一个特殊的失败标记NotFound。
输入样例1： 512 31 55 89 10131输出样例1： 2输入样例2： 326 78 23331输出样例2： 0
代码：
1 #include&lt;iostream&gt;2 #include&lt;stdio.h&gt;3 #include&lt;stdlib.h&gt;4 #include&lt;string.h&gt;5 using namespace std;6 #define MAXSIZE 107 #define NotFound 08 typedef int ElementType;9 10 typedef int Position;11 typedef struct LNode *List;12 struct LNode {13 ElementType Data[MAXSIZE];14 int Last; /* 保存线性表中最后一个元素的位置 */15 };16 17 List ReadInput(); /* 裁判实现，细节不表。元素从下标1开始存储 */18 Position BinarySearch( List Tbl, ElementType K );19 20 int main()21 {22 List Tbl;23 ElementType K;24 Position P;25 Tbl = ReadInput();26 scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eead37e5334ec5d046844fdb65d037f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8681b403463aa246a53e984647c2094/" rel="bookmark">
			前端javascript 错误 Uncaught SyntaxError: Unexpected token ILLEGAL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端控制台报Uncaught SyntaxError: Unexpected token ILLEGAL 错误时，就是非法字符错误，首先检查符号是否正确，不要出现中文标点！
然后检查参数之类的类型是否正确，有的是字符串，如果没有加引号也会爆这个错误。
最近写了两天前端，相对来说，错误都是些低级错误，但是莫名其妙不好判断，
主要还是检查类型、符号使用准确
转载于:https://www.cnblogs.com/music180/p/6375570.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfe0d3812f71c19949aca4866ec59d65/" rel="bookmark">
			根据经纬度，计算距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		private static final double EARTH_RADIUS = 6378137;//赤道半径(单位m) /** * 转化为弧度(rad) * */ private static double rad(double d) { return d * Math.PI / 180.0; } /** * 基于余弦定理求两经纬度距离 * @param lon1 第一点的精度 * @param lat1 第一点的纬度 * @param lon2 第二点的精度 * @param lat3 第二点的纬度 * @return 返回的距离，单位km * */ public static double LantitudeLongitudeDist(double lon1, double lat1,double lon2, double lat2) { double radLat1 = rad(lat1); double radLat2 = rad(lat2); double radLon1 = rad(lon1); double radLon2 = rad(lon2); if (radLat1 &lt; 0) radLat1 = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfe0d3812f71c19949aca4866ec59d65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9f5f0e89dd7bcface9d7ec30bfe0079/" rel="bookmark">
			编译安装Ambari
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.2 需要安装的工具 1.2.1 安装JDK 输入命令
[root@bigData-02 ~]# Java –version
java version "1.7.0_51"
Java(TM) SE Runtime Environment (build 1.7.0_51-b13)
Java HotSpot(TM) 64-Bit Server VM (build 24.51-b03, mixed mode)
如果出现以上数据，表明已经安装成功jdk。如果没有安装，使用yum安装jdk。
[root@bigData-02 ~]# yum install jdk
1.2.2 安装Apache Maven 3.0.5 官网下载apache maven，推荐版本3.0.5 [root@bigData-02 ~]# wget http://apache.fayea.com/apache-mirror/maven/maven-3/3.0.5/binaries/apache-maven-3.0.5-bin.tar.gz
解压 [root@bigData-02 ~]# tar -zxvf apache-maven-3.0.5-bin.tar.gz
设置环境变量 [root@bigData-02 ~]# vi /etc/profile
export MAVEN_HOME="/usr/local/apache-maven-3.0.5"
export path=$path: $MAVEN_HOME/bin
[root@bigData-02 ~]#source /etc/profile
4)检查是否安装成功
[root@bigData-02 ~]# mvn -v
Apache Maven 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9f5f0e89dd7bcface9d7ec30bfe0079/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a809e5f8b0eb6e3c69a6e00616057624/" rel="bookmark">
			C/C&#43;&#43;可变参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C/C++中会遇到需要定义使用可变参数的函数，例如printf就是，他的格式就是int printf(const char *format,...)，对于这样类型的函数，他的实现实际上就是从format格式的指针指向的空间中读取可变参数的类型，然后根据可变参数的首地址读取相应的可变参数值
他的具体实现需要借助于3个宏实现（为了方便理解，以函数声明方式显示）：
void va_start(va_list ap,last);//获取可变参数开始的首地址
type va_arg(va_list ap,type);//根据type参数类型获取实参值返回void va_end(va_list ap);//将可变参数指针归NULL 其中va_list实际就是void*类型：
#define va_list void * #define va_start(ap,last) (ap = ((va_list)&amp;last+sizeof(va_list))) #define va_arg(ap,type) (*(type*)((ap += sizeof(type)) - sizeof(type))) #define va_end(ap) (ap = (va_list)0) 具体流程如下：
1.定义变量ap，它用来指向可变参数的首地址
va_list ap; 2.获取可变参数的首地址并赋值给ap
va_start(ap,format); 3.从format中获取参数类型type
根据format中的特殊关键字符获取type，例如printf中的“%d”、“%x”、“%s”、“%02x”等。
4.根据获取到的参数类型从ap中获取实参
type arg; arg = va_arg(ap,type); 5.循环直到将format中的关于类型的特殊字符读取完结束
直到ap取完，例如printf中format == NULL表示字符串取完。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d24658e707e8b04afb7705e6f008eef/" rel="bookmark">
			Mybatis动态插入数据（使用trim标签）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis动态插入数据（使用trim标签） 有时我们控制同一张表，但传入的参数不固定，操作表的字段不固定，就要用到mybatis动态插入。.xml如下：
&lt;insert id="insertMessage" parameterType="com.sf.ccsp.member.client.request.MessageReq"&gt; insert cx_customer_message (ID,MEMBERID, &lt;if test='messageClassify != null and messageClassify != "" '&gt; MESSAGEE_CLASSIFY, &lt;/if&gt; &lt;if test='messageCode != null and messageCode != "" '&gt; MESSAGE_CODE, &lt;/if&gt; &lt;if test='messageContent != null and messageContent != "" '&gt; MESSAGE_CONTENT &lt;/if&gt; ) values ( #{id, jdbcType=VARCHAR}, #{memberId, jdbcType=VARCHAR}, &lt;if test='messageClassify != null and messageClassify != "" '&gt; #{messageClassify, jdbcType=VARCHAR}, &lt;/if&gt; &lt;if test='messageCode != null and messageCode != "" '&gt; #{messageCode, jdbcType=VARCHAR}, &lt;/if&gt; &lt;if test='messageContent !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d24658e707e8b04afb7705e6f008eef/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/288/">«</a>
	<span class="pagination__item pagination__item--current">289/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/290/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>