<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e1bcb6d5efb553d935eeed0bd02c058/" rel="bookmark">
			tpc系列(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 什么是TPC和tpmC? 1 TPC TPC(Transaction Processing Performance Council，事务处理性能委员会)是由数10家会员公司创建的非盈利组织，总部设在美国。该组织对全世界开放，但迄今为止，绝大多数会员都是美、日、西欧的大公司。TPC的成员主要是计算机软硬件厂家，而非计算机用户，它的功 能是制定商务应用基准程序(Benchmark)的标准规范、性能和价格度量，并管理测 试结果的发布。
TPC的出版物是开放的，可以通过网络获取(http://www.tpc.org)。TPC不给出基准程序的代码，而只给出基准程序的标准规范(Standard Specification)。任何厂家或其它测试者都可以根据规范，最优地构造出自己的系统(测试平台和测试程序)。为保证测试结果的客观性，被测试者(通常是厂家)必须提交给TPC一套完整的报告(Full Disclosure Report)，包括被测系统的详细配置、分类价格和包含五年维护费用在内的总价 格。该报告必须由TPC授权的审核员核实(TPC本身并不做审计)。现在全球只有几个审核员，全部在美国。
TPC已经推出了四套基准程序，被称为TPC－A、TPC－B、TPC－C和TPC－D。其中A和B已经过时，不再使用了。TPC－C是在线事务处理(OLTP)的基准程序，TPC－D是决策支持(Decision Support) 的基准程序。TPC即将推TPC－E，作为大型企业(Enterprise)信息服务的基准程序。
2 tpmC tpmC值在国内外被广 泛用于衡量计算机系统的事务处理能力。但究竟什么是tpmC值呢?作者曾向一些 用户、推销人员乃至某些国外大公司的技术人员问过这个问题，但回答的精确度 与tpmC值的流行程度远非相称。tpmC这一度量也常被误写为TPM或TPMC。
TPC-C模拟一个批发商的货物管理环境。该批发公司有N个仓库，每个仓库供应10个地区，其中每个地区为3000名顾客服务。在每个仓库中有10个终端，每一个终端用于一个地区。在运行时，10×N个终端操作员向公司的数据库发出5类请求。由于一个仓库中不可能存储公司所有的货物，有一些请求必须发往其它仓库，因此，数据库在逻辑上是 分布的。N是一个可变参数，测试者可以随意改变N，以获得最佳测试效果。
TPC-C使用三种性能和价格度量，其中性能由TPC-C吞吐率衡量，单位是tpmC。tpm是transactions per minute的简称；C指TPC中的C基准程序。它的定义是每分钟内系统处理的新订单个数。要注意的是，在处理新订单的同时，系统还要按表1的要求处理其它4类事务 请求。从表1可以看出，新订单请求不可能超出全部事务请求的45％，因此，当一个 系统的性能为1000tpmC时，它每分钟实际处理的请求数是2000多个。价格是指系 统的总价格，单位是美元，而价格性能比则定义为总价格÷性能，单位是＄/tpmC。
tpmC定义: TPC-C的吞吐量，按有效TPC-C配置期间每分钟处理的平均交易次数测量，至少要运行12分钟。
（吞吐量测试结果以比特/秒或字节/秒表示。）
第二章 TPCC 1 基准测试 TPCC值被广泛用于衡量C/S环境下,由服务器和客户端构筑的整体系统的性能,它由事物处理性能委员会（TPC，Transaction Processing Corp）制定,TPC为非赢利性国际组织。
TPCC值可以反映出系统的性能价格比。TPCC测试系统每分钟处理的任务数,单位为tpm,(transactions per minute)。系统的总体价格(单位为美元)除以TPCC值,就可以衡量出系统的性价比,系统的性价比值越大,系统的性价比越好。
需要注意的是,TPC-C值描述的是C/S整体系统的性能,它与系统的服务器和客户机的性能都有关系,也就是说,同样的服务器配置不同的客户端将会影响TPCC值,任何厂商和测试者都可以根据TPC提供的测试规范构造出自己最优的系统,当然测试的结果要经过TPC审核。
---------------------------------------------------------------------------------------------------------------
2 性能测试指标介绍 TPC-C
作为一家非盈利性机构，事务处理性能委员会（TPC）负责定义诸如TPC-C、TPC-H和TPC-W基准测试之类的事务处理与数据库性能基准测试，并依据这些基准测试项目发布客观性能数据。TPC基准测试采用极为严格的运行环境，并且必须在独立审计机构监督下进行。委员会成员包括大多数主要数据库产品厂商以及服务器硬件系统供应商。
相关企业参与TPC基准测试以期在规定运行环境中获得客观性能验证，并通过应用测试过程中所使用的技术开发出更加强健且更具伸缩性的软件产品及硬件设备。
TPC-C是一种旨在衡量联机事务处理（OLTP）系统性能与可伸缩性的行业标准基准测试项目。这种基准测试项目将对包括查询、更新及队列式小批量事务在内的广泛数据库功能进行测试。许多IT专业人员将TPC-C视为衡量“真实”OLTP系统性能的有效指示器。
TPC-C基准测试针对一种模拟订单录入与销售环境测量每分钟商业事务（tpmC）吞吐量。特别值得一提的是，它将专门测量系统在同时执行其它四种事务类型（如支付、订单状态更新、交付及证券级变更）时每分钟所生成的新增订单事务数量。独立审计机构将负责对基准测试结果进行公证，同时，TPC将出据一份全面彻底的测试报告。这份测试报告可以从TPC Web站点(http://www.tpc.org)上获得。
3 TPC-C规范概要 TPC-C是专门针对联机交易处理系统（OLTP系统）的，一般情况下我们也把这类系统称为业务处理系统。
TPC-C测试规范中模拟了一个比较复杂并具有代表意义的OLTP应用环境:假设有一个大型商品批发商，它拥有若干个分布在不同区域的商品库；每个仓库负责为10个销售点供货；每个销售点为3000个客户提供服务；每个客户平均一个订单有10项产品;所有订单中约1%的产品在其直接所属的仓库中没有存货，需要由其他区域的仓库来供货。
该系统需要处理的交易为以下几种：
New-Order：客户输入一笔新的订货交易；
Payment:更新客户账户余额以反映其支付状况;
Delivery:发货(模拟批处理交易);
Order-Status:查询客户最近交易的状态；
Stock-Level:查询仓库库存状况，以便能够及时补货。
对于前四种类型的交易，要求响应时间在5秒以内；对于库存状况查询交易，要求响应时间在20秒以内。
4评测指标 TPC-C测试规范经过两年的研制，于1992年7月发布。几乎所有在OLTP市场提供软硬件平台的厂商都发布了相应的TPC-C测试结果，随着计算机技术的不断发展，这些测试结果也在不断刷新。
TPC-C的测试结果主要有两个指标：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e1bcb6d5efb553d935eeed0bd02c058/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ab150d15ad8b7e69f4852f090d4795c/" rel="bookmark">
			Java基础 - 树堆（Treap = tree&#43;heap）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Treap是用来排序(Sort)的一种数据结构(Data Structure)。 reap是随机查找二叉平衡树。 Treap发音为tree+ Heap。顾名思义， Treap把 BST和 Heap结合了起来。它和 BST一样满足许多优美的性质，而引入堆目的就是为了维护平衡。 Treap在 BST的基础上，添加了一个修正值。在满足 BST性质的上，Treap节点的修正值还满足最小堆性质。最小堆性质可以被描述为每个子树根节点都小于等于其子节点。 (1) Treap的特点 1. Treap简明易懂。Treap只有两种调整方式，左旋和右旋。而且即使没有严密的数学证明和分析，Treap的构造方法啊，平衡原理也是不难理解的。只要能够理解 BST和堆的思想，理解 Treap当然不在话下。 2. Treap易于编写。Treap只需维护一个满足堆序的修正值，修正值一经生成无需修改。相 比较其他各种平衡树， Treap拥有最少的调整方式，仅仅两种相互对称的旋转。所以 Treap当之无愧是最易于编码调试的一种平衡树。 3. Treap稳定性佳。Treap的平衡性虽不如 AVL，红黑树， SBT等平衡树，但是 Treap也不会退化，可以保证期望 O(logN)的深度。Treap的稳定性取决于随机数发生器。 4. Treap具有严密的数学证明。Treap期望 O(logN)的深度，是有严密的数学证明的。但这不是介绍的重点，大多略去。 5. Treap具有良好的实践效果。各种实际应用中， Treap的稳定性表现得相当出色，没有因为任何的构造出的数据而退化。于是在信息学竞赛中，不少选手习惯于使用 Treap，均取得了不俗的表现。 一棵treap是一棵修改了结点顺序的二叉查找树，如图，显示一个例子，通常树内的每个结点x都有一个关键字值key[x]，另外，还要为结点分配priority[x]，它是一个独立选取的随机数。
假设所有的优先级是不同的，所有的关键字也是不同的。treap的结点排列成让关键字遵循二叉查找树性质，并且优先级(有的地方也叫修正值，是一个随机数)遵循最小堆顺序性质： 1.如果left是u的左孩子，则key[left] &lt; key[u]. 2.如果right是u的右孩子，则key[right] &gt; key[u]. 3.如果child是u的孩子，则priority[child] &gt; priority[u].
4.如果priority[vi] &lt; priority[vj].则vi相对于vj而言更接近根节点。
这两个性质的结合就是为什么这种树被称为“treap”的原因，因为它同时具有二叉查找树和堆的特征。（在关键字上它满足二叉排序树，在优先级上他满足小顶堆）。
用以下方式考虑treap会有帮助。假设插入关联关键字的结点x1，x2，...，xn到一棵treap内。结果的treap是将这些结点以它们的优先级(随机选取)的顺序插入一棵正常的二叉查找树形成的，亦即priority[xi] &lt; priority[xj]表示xi在xj之前被插入。
在算法导论的12.4节中，其证明了随机构造的二叉查找树的期望高度为O(lgn)，因而treap的期望高度亦是O(lgn)。
1.treap插入操作：
1.按照二叉树的插入方法，将结点插入到树中
2.根据堆的性质(我们这里为最小堆)和优先级的大小调整结点位置。
2.treap删除操作：
1.找到相应的结点
2.若该结点为叶子结点，则直接删除；
若该结点为只包含一个叶子结点的结点，则将其叶子结点赋值给它；
若该结点为其他情况下的节点，则进行相应的旋转，直到该结点为上述情况之一，然后进行删除。
3、如何使treap平衡 Treap中的节点不仅满足BST的性质，还满足最小堆的性质。因此需要通过旋转来调整二叉树的结构，在维护Treap的旋转操作有两种：左旋和右旋，（注意：无论怎么旋转二叉查找树的性质是不能改变的） 4.查找 和一般的二叉搜索树一样，但是由于Treap的随机化结构，可以证明Treap中查找的期望复杂度是O(log n)。 5.分离 要把一个Treap按大小分成两个Treap，只要在需要分开的位置加一个虚拟节点，然后旋至根节点删除，左右两个子树就是得出的两个Treap了。根据二叉搜索树的性质，这时左子树的所有节点都小于右子树的节点。时间相当于一次插入操作的复杂度，也就是O(log n)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ab150d15ad8b7e69f4852f090d4795c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/401df69ceef834b3d9adfe863227779c/" rel="bookmark">
			移动平均法又称滑动平均法、滑动平均模型法（Moving average，MA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自http://jingji.100xuexi.com/view/otdetail/20130625/230f09b0-6e36-473b-8830-7f2b873a5252.html
什么是移动平均法?
移动平均法是用一组最近的实际数据值来预测未来一期或几期内公司产品的需求量、公司产能等的一种常用方法。移动平均法适用于即期预测。当产品需求既不快速增长也不快速下降，且不存在季节性因素时，移动平均法能有效地消除预测中的随机波动，是非常有用的。移动平均法根据预测时使用的各元素的权重不同
移动平均法是一种简单平滑预测技术，它的基本思想是：根据时间序列资料、逐项推移，依次计算包含一定项数的序时平均值，以反映长期趋势的方法。因此，当时间序列的数值由于受周期变动和随机波动的影响，起伏较大，不易显示出事件的发展趋势时，使用移动平均法可以消除这些因素的影响，显示出事件的发展方向与趋势（即趋势线），然后依趋势线分析预测序列的长期趋势。
移动平均法的种类
移动平均法可以分为：简单移动平均和加权移动平均。
一、简单移动平均法
简单移动平均的各元素的权重都相等。简单的移动平均的计算公式如下： Ft＝（At-1＋At-2＋At-3＋…＋At-n）/n式中，
·Ft–对下一期的预测值；
·n–移动平均的时期个数；
·At-1–前期实际值；
·At-2，At-3和At-n分别表示前两期、前三期直至前n期的实际值。 二、加权移动平均法
加权移动平均给固定跨越期限内的每个变量值以不同的权重。其原理是：历史各期产品需求的数据信息对预测未来期内的需求量的作用是不一样的。除了以n为周期的周期性变化外，远离目标期的变量值的影响力相对较低，故应给予较低的权重。加权移动平均法的计算公式如下：
Ft＝w1At-1＋w2At-2＋w3At-3＋…＋wnAt-n式中，
·w1–第t-1期实际销售额的权重；
·w2–第t-2期实际销售额的权重；
·wn–第t-n期实际销售额的权
·n–预测的时期数；w1＋ w2＋…＋ wn＝1
在运用加权平均法时，权重的选择是一个应该注意的问题。经验法和试算法是选择权重的最简单的方法。一般而言，最近期的数据最能预示未来的情况，因而权重应大些。例如，根据前一个月的利润和生产能力比起根据前几个月能更好的估测下个月的利润和生产能力。但是，如果数据是季节性的，则权重也应是季节性的。
移动平均法的优缺点
使用移动平均法进行预测能平滑掉需求的突然波动对预测结果的影响。但移动平均法运用时也存在着如下问题：
1、加大移动平均法的期数（即加大n值）会使平滑波动效果更好，但会使预测值对数据实际变动更不敏感；
2、移动平均值并不能总是很好地反映出趋势。由于是平均值，预测值总是停留在过去的水平上而无法预计会导致将来更高或更低的波动；
3、移动平均法要由大量的过去数据的记录。
移动平均法案例分析 简单移动平均法在房地产中的运用 某类房地产2001年各月的价格如下表中第二列所示。由于各月的价格受某些不确定因素的影响，时高时低，变动较大。如果不予分析，不易显现其发展趋势。如果把每几个月的价格加起来计算其移动平均数，建立一个移动平均数时间序列，就可以从平滑的发展趋势中明显地看出其发展变动的方向和程度，进而可以预测未来的价格。
在计算移动平均数时，每次应采用几个月来计算，需要根据时间序列的序数和变动周期来决定。如果序数多，变动周期长，则可以采用每6个月甚至每12个月来计算；反之，可以采用每2个月或每5个月来计算。对本例房地产2001年的价格，采用每5个月的实际值计算其移动平均数。计算方法是：把1～5月的价格加起来除以5得684元/平方米，把2～6月的价格加起来除以5得694元/平方米，把3～7月的价格加起来除以5得704元/平方米，依此类推，见表中第三列。再根据每5个月的移动平均数计算其逐月的上涨额，见表中第四列。 假如需要预测该类房地产2002年1月的价格，则计算方法如下：由于最后一个移动平均数762与2002年1月相差3个月，所以预测该类房地产2002年1月的价格为：762 ＋ 12 × 3 =798（元/平方米）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f1ab1295eebc8ad0a1af1b5adcf3d63/" rel="bookmark">
			writeValueAsString
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		封装成工具类
public static String toJsonByObject(Object obj){ String jsonStr = null; try { jsonStr = mapper.writeValueAsString(obj); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } return jsonStr; } ================================================
如何把Java对象转化成json字符串并打印出来呢？
这里就用到了jackon的jar包，使用writeValuesAsString的方法就可以把对角转化成json字符串。
下面通过一个demo，来仔细体会下如何去转化！
1：先建一个javaBean。
[java] view plain copy package com.sino.objectmapperdemo; public class BaseObject { private String userName; private String userCode; private double weight; private int height; private boolean sex; private String[] array; private BaseObject innerBaseObject; public String getUserName() { return userName; } public void setUserName(String userName) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f1ab1295eebc8ad0a1af1b5adcf3d63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae06324159dba010fa805995ad3e106f/" rel="bookmark">
			推荐系统：技术、评估及高效算法 第1章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Recommender System Handbook Chapter 1 笔记下载地址 http://pan.baidu.com/s/1hsqNy6o 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d54c595ff5a75f8204a71230bba94e40/" rel="bookmark">
			如何统一解析JSON数据，使用Gson结合泛型类灵活，让您一劳永逸
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一名android 客户端开发人员，学会解决问题和总结问题的习惯是很重要的。。。那么我们app接口数据返回通常是以下格式：
{"code":"0000","data": {"code":"0002","resultData":null,"resultMsg":"用户Token过期,请重新登入","error":[],"msg":""}
把以上的json数据放在线JSON字符串转Java实体类(JavaBean)网址（http://www.bejson.com/json2javapojo/new/）上生成下面的Java实体类：
public class JsonRootBean { private String code; private Data data; private List&lt;String&gt; error; private String msg; public void setCode(String code) { this.code = code; } public String getCode() { return code; } public void setData(Data data) { this.data = data; } public Data getData() { return data; } public void setError(List&lt;String&gt; error) { this.error = error; } public List&lt;String&gt; getError() { return error; } public void setMsg(String msg) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d54c595ff5a75f8204a71230bba94e40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e2e09c44e6d4d56934c3d87ce8e6444/" rel="bookmark">
			matlab PCA-SVD简单地实现特征脸方法(Eigenface)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们要用一张图片跟大量图片对比寻找最相似（最小欧几里得距离等）时用本文的方法能减少内存使用量加快运算速度。
优化的欧几里得距离计算方法：
function d = EuclideanDistance(a,b) % DISTANCE - computes Euclidean distance matrix % % E = EuclideanDistance(A,B) % % A - (MxD) matrix % B - (NxD) matrix % % Returns: % E - (MxN) Euclidean distances between vectors in A and B % % % Description : % This fully vectorized (VERY FAST!) m-file computes the % Euclidean distance between two vectors by: % % ||A-B|| = sqrt ( ||A||^2 + ||B||^2 - 2*A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e2e09c44e6d4d56934c3d87ce8e6444/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f0a7caa66c83064a69c05f4a55a29a7/" rel="bookmark">
			PHP的instanceof关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 instanceof关键字是PHP5新增成员。 PHP手册中： 可以从上段代码中看出，instanceof的关键字可以确定一个对象是否是一个类的实例。
其实instanceof这个关键字可以确定一个对象是类的实例、类的子类，还是实现了某个特定接口，并进行相应的操作。
下面看看instanceof的具体用法(用PHP’三私一公’说明):
&lt;?php? class PDODB{ private static $_instance;//用来保存单例对象 private function __construct(){ } private function __clone(){ } public static function getInstance(){ if(!static::$_instance instanceof static){ //当$_instance不是PDOPB对象时,为true //static为本类 } } } &gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb06a387cdca18493b172a580c805cdd/" rel="bookmark">
			关于hibernate jpa 踩过的一个个坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置 multiselect 无效问题 xxxxDao.findAll(Specifications.where(new Specification&lt;XXBean&gt;() { @Override public Predicate toPredicate(Root&lt;XXBean&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) { query.multiselect(root.get("a"),root.get("b")); return null; } })); 上面的那段代码中multiselect的这是是无效的，这个问题当时很是困扰，到网上搜索很多人都遇到这个问题，但是也没有找到一个确切的答案，无奈只好自己debug代码了。终于找到了根源：
protected TypedQuery&lt;T&gt; getQuery(Specification&lt;T&gt; spec, Sort sort) { CriteriaBuilder builder = em.getCriteriaBuilder(); CriteriaQuery&lt;T&gt; query = builder.createQuery(getDomainClass()); Root&lt;T&gt; root = applySpecificationToCriteria(spec, query); query.select(root); if (sort != null) { query.orderBy(toOrders(sort, root, builder)); } return applyRepositoryMethodMetadata(em.createQuery(query)); } 上边这两句代码：
Root&lt;T&gt; root = applySpecificationToCriteria(spec, query);
query.select(root);
，第一句内部调用了toPredicate 接口执行了我们设置的multiselect ，然而第二句直接重置了查询的字段为表的所有字段.导致我们设置的查询字段无效。刚开始我认为这个hibernate的一个bug，但是后来想想他这样做也是为了预防另外一个bug的产生：分页查询的时候hibernate会自动生成一个count的sql，如果这时你设置了select字段，而且还有group by语句，group的字段为select的某一个字段。这时生成的count语句就有可能会出错了，select count(*) from table group by field ,这句sql可能会因为找不到field而出错。所以hibernate 这里直接不允许程序员在这里设置select字段也是有一定意义的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb06a387cdca18493b172a580c805cdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63c7ced7e8c3a3a1554a3b1e6669f849/" rel="bookmark">
			K-近邻算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习基础知识 监督学习：监督学习从给定的数据中（已经确定了数据的类别）学习模型，之后利用学习的模型，得到目标变量的结果。简单来说，监督学习用来学习的数据，已经给定了类别（标签）、类别数等。是一种预先知道学习后，可能产生的目标变量的结果的学习方式。（例如，已经知道了，学习后用来对猫狗分类，而不是对其他类别分类）。
目标变量的两种类型：标称型和数值型。标称型指：结果在有限目标集中取值，如真与假，｛婴儿、幼年、青年、成年、中年、老年｝。数值型值：目标变量从无限数值集合中取值，这种类型的目标变量主要用于回归分析。
何谓机器学习：简单地说，机器学习就是把无序的数据转换成有用的信息。
训练集：为了训练算法所输入的，大量已分类数据。训练集包含多个训练样本，每个样本包含一个或多个特征、一个目标变量（结果）。对于分类算法（监督学习），训练样本集必须知道目标变量的值，才可以通过机器学习算法发现样本特征与目标变量之间的关系。对于分类问题，目标变量称为类别。
训练数据和测试数据：当机器学习算法开始运行时，训练样本集输入，训练完成后输入测试样本集。给算法输入的测试样本集，去掉样本的目标变量，有算法判别每个样本的目标变量。比较测试样本通过算法预测的变量和实际样本类别间的差异，评估算法的精确度。
分类与回归：分类主要的任务为，将实例数据划分到合适的类别中。回归主要用于预测数值型数据，如：通过给定数据点的最有拟合曲线，即数据拟合曲线。分类和回归同属于监督学习，这类学习算法知道要预测什么，即知道目标变量的分类信息。
无监督学习：用来训练的数据没有类别信息，没有目标值。无监督学习中，将数据集合分成由类似的对象组成的多个类的过程称为聚类；将寻找描述数据统计值的过程称为密度估计。无监督学习还可以减少数据特征的维度。
监督学习无监督学习k近邻k均值朴素贝叶斯分类最大期望算法支持向量机决策树回归 开发机器学习应用程序步骤：（1）收集数据。（2）准备输入数据。（3）分析输入数据。（4）训练算法。（5）测试算法。（6）使用算法。
K-近邻算法 1.算法概述 简单的说，K-近邻算法采用测量不同特征值之间的距离方法进行分类。
优点：精度高、对异常值不敏感、无数据输入假定。
缺点：计算复杂度高、空间复杂度高。
实用数据范围：数值型和标称型。
工作原理：存在一个训练样本集，样本集中每个样本都有标签，已经事先知道每个样本的所属分类。输入新样本后（无标签），将新样本的每个特征与样本集中样本对应的特征进行比较，提取样本集中特征最相似（最近邻）的前K个分类标签，取出现次数最多的标签，作为新样本所属的分类。
2.k-近邻算法的一般流程 (1)收集数据：使用任意方法收集。
(2)准备数据：用于计算距离，数据格式最好结构化。
(3)分析数据：任意方法。
(4)训练算法：K-近邻不需要训练算法。
(5)测试算法：计算错误率。
(6)使用算法：输入样本数据，运行K-近邻算法判别输入数据所属分类。
3.K-近邻算法代码(Python) 3.1 整体代码 代码+样本集下载
# -*- coding: utf-8 -*- ''' Input: inX: vector to compare to existing dataset (1xN) dataSet: size m data set of known vectors (NxM) labels: data set labels (1xM vector) k: number of neighbors to use for comparison (should be an odd number) Output: the most popular class label ''' from numpy import * import operator from os import listdir def classify0(inX, dataSet, labels, k): dataSetSize = dataSet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63c7ced7e8c3a3a1554a3b1e6669f849/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/490a90a7300e7c6a8ea79cc2a887127c/" rel="bookmark">
			LPC2368学习笔记（一）——点亮LED
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LPC2368学习笔记（一）、点亮LED 前言 LPC2368是一款十分强大的单片机，其基于ARM7TDMI-S处理器，可在高达72MHz的工作频率下运行，高达512kB的片内Flash程序存储器，具有在系统编程（ISP）和在应用编程（IAP）功能，ARM局部总线上有高达32kB的SRAM，并且具备丰富的外设，如SD/MMC存储卡接口、10位A/D转换器、10位D/A转换器、UART接口、CAN接口、SPI接口、USB2.0（带有片内PHY和相关的DMA控制器）接口、I2C接口、I2S频接口、SSP控制器、Ethernet MAC、定时器、RTC等。
一、开发环境介绍 LPC2368支持多种开发环境，有 1. LPCXpresso IDE 2. ADS 3. MDK 4. IAR Embedded Workbench for ARM 5. SEGGER Embedded Studio
其中SEGGER Embedded Studio目前对个人用户免费，但是为了快速熟悉LPC2368的开发，我使用MDK进行程序开发工作。
二、新建工程 打开MDK，选择单片机型号为LPC2368，并向工程中添加启动文件LPC2300.s。界面如图所示：编写点亮LED程序。程序如图所示：配置工程。 output项配置如图所示：debug项配置如图所示：utilities项配置如图所示：下载程序。点击，开始下载程序，程序下载成功输出窗口显示如图所示：下载失败的话会有提示，请对照上述内容重新进行配置。观察实验现象。 当然也可以使用NXP的启动文件进行新建工程，步骤如下： 1. 在NXP官网上找到有关LPC2368的程序，可以在该网址找到,里面还有芯片资料、软件服务等信息。 2. 下载并打开LPC2368的例程 3. 打开以后是这样的，common是通用的配置文件，其他的是一些外设的驱动例程。common文件夹内有两个文件夹分别是inc文件夹和src文件夹，如下图所示：inc文件夹包含，src文件夹包含 4. 复制common文件夹到工程目录，将它添加到工程中，工程配置如下所示：c/c++项配置如下图所示linker项配置如下所示其他项的配置和上面配置相同。 5. 编译运行，观察实验现象。
三、程序介绍 3.1 程序源码 #include &lt;LPC23xx.H&gt; int main(void) { //配置P0.29 P0.30 为输出模式 IODIR0 |= 1 &lt;&lt; 29; IODIR0 |= 1 &lt;&lt; 30; while(1) { //配置P0.29 P0.30 输出低电平 //由于硬件原因LED在低电平时点亮 在高电平熄灭 IOCLR0 |= 1 &lt;&lt; 29; IOCLR0 |= 1 &lt;&lt; 30; } } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/490a90a7300e7c6a8ea79cc2a887127c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41bc94f5676e90e8dbc259a993ee584d/" rel="bookmark">
			HTML5 Canvas实现360度全景图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 很多购物网站现在都支持360实物全景图像，可以360度任意选择查看样品，这样
对购买者来说是一个很好的消费体验，网上有很多这样的插件都是基于jQuery实现的
有收费的也有免费的，其实很好用的一个叫3deye.js的插件。该插件支持桌面与移动终
端iOS与Android， 它的demo程序：http://www.voidcanvas.com/demo/28823deye/
自己玩了玩这个Demo以后，照着它的思路，用HTML5 Canvas也实现了类似的功能。
所以先说一下它的360度全景图的原理
1. 首先需要对实物拍照，间隔是每张照片旋转15度，所以需要23张照片。
2. 照片准备好了以后，尽量选择JPG格式，裁剪到适当大小。
3. JavaScript中预加载所有照片，可以配合进度条显示加载精度
4. 创建/获取Canvas对象，加上鼠标监听事件，当鼠标左右移动时候，适度的绘制不
同帧。大致的原理就是这样，简单吧！
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=utf-8"&gt; &lt;title&gt;Full 360 degree View&lt;/title&gt; &lt;script&gt; var ctx = null; // global variable 2d context var frame = 1; // 23 var width = 0; var height = 0; var started = false; var images = new Array(); var startedX = -1; window.onload = function() { var canvas = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41bc94f5676e90e8dbc259a993ee584d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03c93c8010fc45e908811a3909bf1f7d/" rel="bookmark">
			记录一些常用的git命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git作为一个极其强大的版本控制工具，其优势不言而喻，应该成为每个程序员的标配。如果你还在使用Svn,强烈建议体验一下Git，你一定会爱不释手的。初学Git，推荐一个不错的Git入门教程，廖雪峰的官方网站。这里仅记录一些常见Git命令，以供查阅。
创建版本库
git init 在当前目录创建版本库（repository），会自动在根目录生成.git文件夹
git clone https://github.com/lulululbj/JavaDesignPatterns.git
克隆版本库地址
本地修改
git add readme.md
将文件添加到版本库，仅仅只是添加到暂存区
git commit -m "commit message"
将add到暂存区的文件提交到版本库，可多次add，一次提交。-m后的参数为本次提交的备注，这是一个应该养成的好习惯。
git add . or git add -A
添加本地所有修改
git status
查看本地仓库当前状态，修改了哪些文件，哪些文件等待commit等等。
git diff
查看具体修改内容，后面可以添加文件名查看具体文件修改内容。当然，如果你刚刚commit了，这个命令就查看不到任何东西。
提交管理
git log
查看提交历史
git log --pretty=oneline
如果你觉得git log命令显示的内容过于冗余，这个命令仅仅显示commit_id和提交时的备注
git reset --hard HEAD^
回退到上个版本，HEAD^^,上上个版本，HEAD~10，上10个版本
git reset --hard commit_id
根据commit_id恢复到指定版本
git reflog
记录你每次对版本库的操作，并显示每一次的commit_id
git diff HEAD -- readme.md
查看文件在工作区和当前版本库里面最新版本的区别
git checkout -- readme.md
撤销工作区的修改，恢复到最近一次git commit或者git add的状态
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03c93c8010fc45e908811a3909bf1f7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a2e530090233fcd5488f3df9174b2a6/" rel="bookmark">
			哈理工OJ 1627 猪猪罐（完全背包）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接：http://acm.hrbust.edu.cn/index.php?m=ProblemSet&amp;a=showProblem&amp;problem_id=1627
猪猪罐 Time Limit: 1000 MS Memory Limit: 32768 K Total Submit: 39(21 users) Total Accepted: 23(21 users) Rating: Special Judge: No Description ikki有一个小金库，这是一个猪猪罐，猪猪罐里面放了一些硬币。ikki知道了每种硬币的价值和重量，并且还知道空猪猪罐的重量，现在ikki想知道这个猪猪罐里至少放了价值为多少的硬币，她只能称出整个猪猪罐的总重量，你能帮她计算一下么？
Input 多组测试数据，第一行给出一个整数T表示测试数据的组数。
对于每组数据：
第一行输入两个正整数E、V，其中E表示空猪猪罐的重量，V表示放了硬币之后猪猪罐的总重量。（1&lt;=E&lt;=V&lt;=10000）
第二行输入一个整数N表示硬币的种数。（1&lt;=N&lt;=50）
接下来的N行，每行两个整数v，w分别表示每种硬币的价值和重量。（1&lt;=v&lt;=50000,1&lt;=w&lt;=10000）
Output 对于每组数据输出猪猪罐中硬币价值可能的最小值，如果不存在则输出”Impossible”。
每组输出占一行。 Sample Input 3 10 110 2 1 1 30 50 10 110 2 1 1 50 30 1 6 2 10 3 20 4 Sample Output 60 100 Impossible
【题目分析】本题是一道完全背包的题目，一开始想了好久好久，因为这个背包和平常遇到的完全背包有区别，因为这个背包是知道了最终的重量，然后让你求是不是可以由某些硬币组成，假如可以由某些硬币组成的话，找出价值和最小的那一组硬币。可以一开始给dp数组置一个很大的数。 【AC代码】
#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; #define INF 1000005 struct node { int val,cost; }a[55]; int dp[10005]; int main() { int t,e,v,n; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a2e530090233fcd5488f3df9174b2a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f61d3cb315415d4e1f26080529f59e7f/" rel="bookmark">
			java实现热敏打印机打印小票
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 以下是热敏打印机的开发步骤（只适用于IE浏览器） 1.下载BTP-2002CPV2.22.zip和POSOCX-V1.23.zip 2.安装 POSOCX-V1.23.zip 是安装打印机 BTP-2002CPV2.22.zip 是注册
3.jsp页面： 3.1 引入js文件(xxx.js指自己的posocx的js文件)
&lt;script type="text/javascript" src="&lt;%=basePath%&gt;/xxx.js" charset="utf-8"&gt;&lt;/script&gt; 3.2 在页面的最大的div的最后引入posocx对象（注册表中搜索posocx，clsid是注册号）
&lt;div&gt; &lt;!-- 页面的内容 --&gt; &lt;object id="POSOCX" classid="clsid:自己的注册码" width="0" height="0" align="center" hspace="0"&gt; &lt;/object&gt; &lt;/div&gt; 3.3 调用方法：(打印上下联)
var posObj = document.getElementById("POSOCX"); //调用自己js文件中的打印方法// 这是***.js中的方法 结合dwz实现打印小票，则稍微复杂一些。 情境描述： form表单提交，后台操作成功后，dwz弹框操作成功，我们点击确定则退出。现在想要修改弹框信息（提示是否打印小票），并且弹框上有两个按钮，确定和取消。点击确定我们打印，取消不打印。 jsp页面： &lt;div class="pageContent"&gt; &lt;form method="post" action="test.action?flag=${flag }" class="pageForm required-validate" onsubmit="return validateCallback1(this, test1);"&gt; &lt;!-- 页面的内容 --&gt; &lt;/form&gt; &lt;!-- 页面的内容 --&gt; &lt;object id="POSOCX" classid="clsid:自己的注册码" width="0" height="0" align="center" hspace="0"&gt; &lt;/object&gt; &lt;/div&gt; js开发过程如下： 我们常用场景： 如form标签中加上属性：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f61d3cb315415d4e1f26080529f59e7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8323712267d249c298cfaeb04680d73f/" rel="bookmark">
			全局变量与命名规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 （1）全局变量 全局变量虽然用起来方便，但变量多了会很乱容易混淆
而且要注意局部变量不要和全局变量同名，否则局部变量会覆盖全局变量的值
所以应该尽量减少全局变量的使用，尽量用函数返回值得到要接受的变量
（2）命名规范 再提一次变量的命名，一定得规范，否则变量一不小心变量同名了会改的心碎的
不可取的变量命名：
x=0.002; y=0.002; m=0.002; n=0.002; q=0.002; w=0.002; e=0.002; r=0.002; t=0.002; p=0.002; f=0.002; g=0.002; h=0.002; j=0.002; k=0.002; l=0.002; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25aa3508ed473dafda0886940f0da921/" rel="bookmark">
			mysql主从  1.一台电脑上安装俩个mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近正在做mysql主从，积累一点经验，把他记录下来。
我的环境是Windows7，mysql5.5.第一步就是在我的机器里装了俩个mysql服务（其实就是端口号不同）。
第一步：
1.从mysql官网上下载mysql Server，我的下载的是5.5，现在好像都有5.7了，官网为http://dev.mysql.com/downloads/mysql/；选择后缀为.msi的文件进行下载
2.然后直接双击安装就好了，一直下一步（记住你的mysql安装目录）：中间会有选择端口号和输入密码的地方，端口号默认的3306就可以，密码你可以随意输入。
3.安装好后，进入windows 服务（右键我的电脑-管理-服务和应用程序-服务）在右边的列表里就可以看到你的服务名为MySql的服务。
第二步：（重点来了）
1.将你的mysql程序直接拷贝到另一个目录。如我的拷贝到了e:\mysql_1（拷贝的时候把MySQL Server 5.5下的所有文件都拷到该目录下）
2.配置修改e:\mysql_1下的my.ini文件，修改以下参数
a：修改端口号
[client] port=3306 [mysql] （将此处端口号改为3307） [mysqld]
# The TCP/IP Port the MySQL Server will listen on
port=3306（将此处端口号改为3307） b：修改安装路径和数据来源 basedir=e:/mysql_1/
datadir=e:/mysql_1/data/ 3:将第二个mysql设置成服务 进入cmd 进入到你安装第二个服务器的路径（bin目录下 我的是e:\mysql_1\bin），输入写下命令 mysqld --install mysql_cy --defaults-file=e:\mysql_1\my.ini 回车执行后出现 Service successfully installed即安装成功，mysql_cy即第二个服务器的服务名 可以在到Windows服务的右边列表里进行查看在MySQL 下多了一个mysql_cy的服务器名。 好了，配置成功，接下来就开始真正的主从配置了！！！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e812a437e8bf576d55258d2848f6c35/" rel="bookmark">
			windows下使用cmake&#43;mingw配置makefile(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载Cmake，并配置环境变量 下载链接：https://cmake.org/download/ 环境变量略
2. 生成Makefile 1)新建 hello 文件夹，在hello中创建hello.c测试程序 mkdir hello cd C:\Users\Administrator\Desktop\hello2)在hello中编写hello.cpp如下: #include &lt;iostream&gt; using namespace std; int main(){ cout &lt;&lt; "hello word cmake!!!" &lt;&lt; endl; return 0; }3)在hello文件夹中创建CMakeLists.txt，编辑如下： &lt;pre name="code" class="cpp"&gt;&lt;pre name="code" class="cpp"&gt;set(CMAKE_C_COMPILER "gcc")#设置C编译器 set(CMAKE_C_FLAGS "-g -Wall -I C:\\mingw-4.81\\mingw\\include -L C:\\mingw-4.81\\mingw\\lib")# set(CMAKE_CXX_COMPILER "g++")#设置C++编译器 set(CMAKE_CXX_FLAGS "-g -Wall -I C:\\mingw-4.81\\mingw\\include -L C:\\mingw-4.81\\mingw\\lib") PROJECT (HELLO CXX) SET(SRC_LIST hello.cpp) ADD_EXECUTABLE(hello ${SRC_LIST}) MESSAGE(STATUS "This is BINARY dir " ${HELLO_BINARY_DIR}) MESSAGE(STATUS "This is SOURCE dir "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e812a437e8bf576d55258d2848f6c35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/400adf1a784f5a25937fef6118ab7682/" rel="bookmark">
			Java基础 - 树的实现（一）父节点表示法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		父节点表示法： 通过前面的介绍可以发现,树中除根节点之外的每个节点都有一个父节点。为了记录树中节点与节点之间的父子关系，可以为每个节点增加一个parent域，用来记录该节点的父节点。对于如下图所示的数，可以用一个表（数组）来保存它。 下表记录示范树
数组索引dataparent0A-11B02C03D04E15F36G37H48I49J410K6......... 由此可见，只要用一个数组节点来保存树里的每个节点，并让每个节点都记录它的父节点在数组中的索引位置即可。下面的程序实现了父节点表示法的树：
import java.util.ArrayList; import java.util.List; /** * @see 父节点表示法 * @author wb * * @param &lt;E&gt; */ public class TreeParent &lt;E&gt; { public class Node &lt;T&gt;{ T data; int parent; Node(){ } Node(T data){ this.data = data; } Node(T data, int parent){ this(data); this.parent = parent; } public String toString(){ return "TreeParent$Node[data = " + data + ", parent = " + parent + "]"; } } private final int DEFAULT_TREE_SIZE = 100; private int treeSize = 0; //相当于容量吧 //用来记录树中所有的节点 private Node&lt;E&gt;[] nodes; //用来记录树中节点的个数 private int nodeNums; /** * 三种构造方法 */ @SuppressWarnings("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/400adf1a784f5a25937fef6118ab7682/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22d404fd5ee249542c748a1a28a5577a/" rel="bookmark">
			Nodejs进阶：基于express&#43;multer的文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文摘录自《Nodejs学习笔记》，更多章节及更新，请访问 github主页地址。欢迎加群交流，群号 197339705。
概览 图片上传是web开发中经常用到的功能，node社区在这方面也有了相对完善的支持。
常用的开源组件有multer、formidable等，借助这两个开源组件，可以轻松搞定图片上传。
本文主要讲解以下内容，后续章节会对技术实现细节进行深入挖掘。本文所有例子均有代码示例，可在这里查看。
基础例子：借助express、multer实现单图、多图上传。
常用API：获取上传的图片的信息。
进阶使用：自定义保存的图片路径、名称。
关于作者 程序猿小卡，前腾讯IMWEB团队成员，阿里云栖社区专家博主。欢迎加入 Express前端交流群(197339705)。
正在填坑：《Nodejs学习笔记》 / 《Express学习笔记》 社区链接：云栖社区 / github / 新浪微博 / 知乎 / Segmentfault / 博客园 / 站酷
环境初始化 非常简单，一行命令。
npm install express multer multer --save 每个示例下面，都有下面两个文件
➜ upload-custom-filename git:(master) ✗ tree -L 1 . ├── app.js # 服务端代码，用来处理文件上传请求 ├── form.html # 前端页面，用来上传文件 基础例子：单图上传 完整示例代码请参考这里。
app.js。
var fs = require('fs'); var express = require('express'); var multer = require('multer') var app = express(); var upload = multer({ dest: 'upload/' }); // 单图上传 app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22d404fd5ee249542c748a1a28a5577a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15de46c603e16a6450e791a4db836224/" rel="bookmark">
			Xilinx ISE 开发过程中生成的各种文件(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电路设计与输入--&gt;功能仿真--&gt;综合优化--&gt;实现过程（翻译、映射、布局布线3个小步骤）--&gt;烧写芯片，在线调试
综合优化：
XST：全称为XilinxSynthesis Technology，这是Xilinx ISE里面附带的一个免费的综合工具。
Synplify生成文件：netlist网表文件 标准edif文件*.edf; 综合约束传递文件*.ncf;
结构级视图文件*.srs; 有限状态机编码文件*.fse;
生成文件：NGC网表文件 *.ngc（XST输出） *.edn *.ngo
edif和ngc区别​
SynplifyPro默认生成的网表文件（EDIF）、Xilinx IP Core和XST生成的网表文件（NGC/NGO）​
ngc里都是Xilinx fpga的原语； 第三方综合工具综合后是EDIF文件​
综合产生的网表文件，包含网络表和约束，是Xilinx自有文件格式，为二进制文件，且被加密了；可以用来进行知识产权保护，例如许多第三方的AllianceCORE就是这样来实现的；（Xilinx自己的LogiCORE有部分是网表，有部分是加密的vhd源程序）​
约束文件： 3种：用户约束文件UCF,网表约束文件NCF,物理约束文件PCF。
UCF由用户输入，NCF由综合工具产生。UCF优先级高。
翻译Translate：
把多个设计文件merge成一个网表文件。
（输入：网表文件EDF(或ngc，ngo)+NCF文件）
NGDBuild:
这个命令，其实就是translate啦。这是implementation的第一步。它会把所有的netlist和design constraint合并到一起，生成一个ngd文 件供map工具使用。
生成文件：*.ngd
映射Map：
把网表中的逻辑符号(gates)分组到物理组件(slices and IOBS)中。
MAP:
MAP命令是将NGDBuild命令所生成的ngd文件，映射到具体的FPGA器件里面去。MAP将产生一个NCD文件供PAR使用。
生成文件：*.ncd
布局布线Place &amp; Route：
把组件放置于芯片中，连接组件，并提取时序数据到报告文件。
PAR:
Place &amp; Route。将逻辑网表适配到FPGA的底层硬件结构上的操作，输出为FPGA配置文件。
时序分析报告：
TRCE:
这个是用来产生偶们最最关心的timingreport的。TRCE会分析你的FPGA的设计并且产生一个后缀名为“.twr”的时序报告。你可以用任何文 本工具打开它，也可以用xilinx的Timing Analyzer。Timing Analyzer比较直观，推荐新手使用。
生成下载文件：
Bitgen：
顾名思义，这个Bitgen就是用来generate programming file啦。
生成文件：*.bit
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22681d5b91e4f68c6ee6505d95403553/" rel="bookmark">
			数据可视化QQ群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 你会遇到一群最早的D3研究者、布道者和实践者。阿里长期招聘前端、可视化岗位有兴趣可以发送简历至tianxu.ztx@alibaba-inc.com
加群讨论 -新手群专业群研究群说明免费（暂时）付费免费（新手别加）群名D3.jsD3数据可视化大数据可视化群号437278817205076374436442115二维码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d3cf0dad619adc3e340adae840dfb46/" rel="bookmark">
			new HashMap(){{put(&#34;id&#34;, &#34;001&#34;);}}的解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、HashMap的初始化 1、HashMap 初始化的文艺写法 HashMap 是一种常用的数据结构，一般用来做数据字典或者 Hash 查找的容器。普通青年一般会这么初始化：
HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put("Name", "June"); map.put("QQ", "2572073701"); 看完这段代码，很多人都会觉得这么写太啰嗦了，对此，文艺青年一般这么来了： HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;() { { put("Name", "June"); put("QQ", "2572073701"); } }; 嗯，看起来优雅了不少，一步到位，一气呵成的赶脚。然后问题来了，有童鞋会问：纳尼？这里的双括号到底什么意思，什么用法呢？哈哈，其实很简单，看看下面的代码你就知道啥意思了。 public class Test { /*private static HashMap&lt; String, String&gt; map = new HashMap&lt; String, String&gt;() { { put("Name", "June"); put("QQ", "2572073701"); } };*/ public Test() { System.out.println("Constructor called：构造器被调用"); } static { System.out.println("Static block called：静态块被调用"); } { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d3cf0dad619adc3e340adae840dfb46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4419248031b9a84ec5b003ced34695a/" rel="bookmark">
			POI 解决写入excel内存溢出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		POI写入excel表 下面是结构图
大批量数据读取写入的问题 在项目中遇到二十万行数据要写入到excel中时会内存溢出，一般方法是调大tomcat的内存，但是调到2048M还是会内存溢出报错
poi官网给了一种大批量数据写入的方法
使用SXXFWorkbook 类进行大批量写入操作解决了这个问题
import junit.framework.Assert; import org.apache.poi.ss.usermodel.Cell; import org.apache.poi.ss.usermodel.Row; import org.apache.poi.ss.usermodel.Sheet; import org.apache.poi.ss.usermodel.Workbook; import org.apache.poi.ss.util.CellReference; import org.apache.poi.xssf.streaming.SXSSFWorkbook; public static void main(String[] args) throws Throwable { SXSSFWorkbook wb = new SXSSFWorkbook(100); // keep 100 rows in memory, exceeding rows will be flushed to disk Sheet sh = wb.createSheet(); for(int rownum = 0; rownum &lt; 1000; rownum++){ Row row = sh.createRow(rownum); for(int cellnum = 0; cellnum &lt; 10; cellnum++){ Cell cell = row.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4419248031b9a84ec5b003ced34695a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/591051c9ea824b8b0fc766570f291633/" rel="bookmark">
			Unity使用Random对数组随机排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明： 本文简单实现一个在Unity使用Random对数组随机排序的小功能。
代码如下所示： using UnityEngine;using System.Collections;public class random : MonoBehaviour{//初始化N个整形数组int []numArray = new int[6];//随机的次数int numCount = 0;void Start(){for (int i = 0; i &lt; numArray.Length; i++){numArray[i] = i;}}void Update(){if (Input.GetMouseButtonDown(0)){numCount++;Debug.Log("第"+numCount.ToString()+"次随机如下所示：******************************");Shuffle(numArray,numCount);}}void Shuffle(int[] intArray,int num){for (int i = 0; i &lt; intArray.Length; i++){int temp = intArray[i];int randomIndex = Random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/591051c9ea824b8b0fc766570f291633/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e43e1abd193dc04d84148ca5910e8bb8/" rel="bookmark">
			在modelsim中添加altera仿真库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在modelsim中添加altera仿真库 转载▼ 我们要建四种库：（1）lpm，调用了lpm 元件的设计仿真时需要；（2）altera_mf，调用了Altera 的MegaFunction 的设计的仿真时需要；（ 3 ）altera_primitive,调用了Altera 的原语（primitive）的设计的仿真时需要；（4）元件库,例如cyclone. 在仿真中必用的特定型号的FPGA/CPLD 的库。前三种库是调用了相应的ALTERA 设计模块的设计进行仿真时必备的库。第四种库是进行综合后功能仿真和布线后时序仿真必备的库。
上面是资料中说的，但真正添加后，编译时提示没有sgate库，也不知道这个库具体有什么功能（明天上班后问问），于是又添加了这个库。（先编译的这个库）
在编译元件库时又提示找不到altera库，于是又把lmp、altera_mf、primitive中的文件都添加到altera的文件夹内编译，编译通过建立了altera库后再编译元件库时不再提示错误。
在modelsim的安装目录下新建了一个altera_lib的文件夹，文件夹内又新建了lmp、sgate、altera_mf、altera、primitive、arriaii（我用的是arriaii的器件）五个文件夹，如下图
然后打开modelsim软件，在file》new中新建立一个project，如下图，注意project nanme和project location的命名和路径选择。
点OK后，在工程中添加源文件。源文件都在Quartus II的安装目录的\eda\sim_lib里，比如我的 D:\altera\91\quartus\eda\sim_lib
lmp库源文件：对 Verilog 和VHDL，分别选以下的文件：
■ 220model.v (Verilog HDL)
■ 220pack.vhd and 220model.vhd (VHDL)
sgate源文件：
■ sgate.v (for Verilog HDL)
■sgate.vhd和sgate_pack.vhd (for VHDL)
altera_mf库源文件：
■ altera_mf.v (for Verilog HDL)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e05898c7b65545350b2f8fb07b059023/" rel="bookmark">
			启动SQL Server 2008 配置管理器时，出现以下提示错误:无法连接到WMI提供程序。您没有权限或者该服务器无法访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以管理员身份运行“命令提示符”，进入后执行以下命令
1)cd /d C:\Program Files\Microsoft SQL Server\100\Shared
2)mofcomp "C:\Program Files\Microsoft SQL Server\100\Shared\sqlmgmproviderxpsp2up.mof"
当看到有如下信息时表明操作成功
MOF file has been successfully parsed
Storing data in the repository...
Done!
注意路径，可能是：C:\Program Files (x86)\Microsoft SQL Server\100\Shared
其他方法：
在网上继续搜，这时看到有人说是管理员（administrator）没有 network service的权限，所以 WMI无法打开。 设置的方法很简单，网络上都有： 1 右击“我的电脑”--&gt;“管理” 2 在“本地用户和组”内的Administrators组上双击，出现添加属性对话框。 3 单击“添加”按钮，出现添加用户对话框 4 单击“高级”按钮，再单击“搜索”（或是“立即查找”）按钮。注：此'NT AUTHORITY\NETWORK SERVICE'用户为系统内置帐户，无法直接添加。 5 在“搜索结果”内选择“Network Service”用户后，单击“确定” 按照以上的步骤设置之后，进入配置管理器，问题依旧出现……到了这里实在让人郁闷的不行。 这时又看到一个新方法：检查一下 windows下的system32 中是否有framedyn.dll这个系统文件，如果没有到system32 下的wbem文件中拷贝framedyn.dll到system32 目录下。 我进到system32目录找framedyn.dll文件，果然没有找到，再进入system32\wbem目录，找framedyn.dll，拷贝到system32目下。再次进入配置管理器，这次终于成功了！！！问题终于解决了！！！这主要是通过Java 或者vc连接数据库遇到的问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e75d20d49a6b8258bddad69fb9c46b82/" rel="bookmark">
			MFC 对话框程序返回值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		控制台程序可以很方便的获取到程序的返回值，MFC对话框程序返回值的获取就没有控制台程序获取那么方便了。
在MFC对话框程序中有两个大类，一个是应用程序类，一个是用于显示见面的对话框类。由于人和程序的交互是通过
对话框类实现，而操作系统获取程序返回值却只能从应用程序类获取返回值。
因此为了获取对话框程序的返回值，可以通过以下步骤实现。
1.在应用程序类中定义一个整型类型的返回值变量，m_iRetCode，在应用程序类的构造函数中初始化为零。
2.在对话框类中通过应用程序的全局变量theApp.m_iRetCode实现对返回值的设置。
3.在应用程序类中通过类向导，重载ExitInstance()函数，并在实现中添加return m_iRetCode;语句。
4.如此在DOS命令窗口中通过start /wait 程序名.exe ，和echo %errorlevel%即可获取到程序的实际返回值。
注意：由于DOS中变量存在延迟，所有需要通过/WAIT参数获取程序实际的返回值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45026f1bf804fb43289a9ef9ab500292/" rel="bookmark">
			Spark连接外部数据源解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主历时三年倾注大量心血创作的《大数据平台架构与原型实现：数据中台建设实战》一书已由知名IT图书品牌电子工业出版社博文视点出版发行，真诚推荐给每一位读者！点击《重磅推荐：建大数据平台太难了！给我发个工程原型吧！》了解图书详情，扫码进入京东手机购书页面！ 本文以连接HBase数据库为例，介绍Spark DataSource API的结构。项目源码：https://github.com/hortonworks-spark/shc 注：由于某些原因，尚无充裕时间进行更深入的解读，本文先着重数据源注册和写入两个流程，后续文章会继续跟进。本文原文出处: http://blog.csdn.net/bluishglc/article/details/52882250 严禁任何形式的转载，否则将委托CSDN官方维护权益！
注册流程 位置：org.apache.spark.sql.execution.datasources.hbase.examples.HBaseSource,Line：75
def withCatalog(cat: String): DataFrame = { sqlContext .read .options(Map(HBaseTableCatalog.tableCatalog-&gt;cat)) .format("org.apache.spark.sql.execution.datasources.hbase") .load() } read方法会创建一个DataFrameReader实例并返回，后续的options和format是在为新创建的DataFrameReader实例注册相关信息，最终是通过load方法，在基于options和format传入的信息基础之上，初始化了一个DataFrame.
位置： org.apache.spark.sql.DataFrameReader#load， Line： 118
def load(): DataFrame = { val resolved = ResolvedDataSource( sqlContext, userSpecifiedSchema = userSpecifiedSchema, partitionColumns = Array.empty[String], provider = source, options = extraOptions.toMap) DataFrame(sqlContext, LogicalRelation(resolved.relation)) } 在创建DataFrame实例时，最重要的是需要传入一个LogicalRelation, 而LogicalRelation需要一个BaseRelation（对BaseRelation进行包裹），BaseRelation的主要用途是描述数据的Schema，这里的我们要传入的BaseRelation实例是通过ResolvedDataSource的apply方法创建的字段：relation, 这个relation的创建发生在：org.apache.spark.sql.execution.datasources.ResolvedDataSource#apply Line 153 - 158
case None =&gt; clazz.newInstance() match { case dataSource: RelationProvider =&gt; val caseInsensitiveOptions = new CaseInsensitiveMap(options) if (caseInsensitiveOptions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45026f1bf804fb43289a9ef9ab500292/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c518da3aff6ff012616b49146506902e/" rel="bookmark">
			文件对比工具Beyond Compare使用方法(BCompare)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eyond Compare是一个很不错的文件/文件夹比较软件，第三版的Beyond Compare是在第二版之上的完全重构。类似从第一版到第二版的过渡，第三版重新考虑了用户界面，重新设计了内部基本结构并增加了显著的新功能。Beyond Compare 可以对文本、mp3、图片、数据、注册表等进行比较分析。对于程序员，你可以用它来对比两份代码的变化，甚至可以用它来比较文件版本和文件夹。在进行文件比较的使用界面中，软件提供了全部显示、差异显示、相同行显示、逐段比较、交换两侧等极其方便的按钮，使用文本差异一目了然，显而易见。与其它同类软件相比，Beyond Compare 3 除了具体以上全面的比较功能外，还附带了文件合并和文件夹同步两种实用工具。
全面启用unicode，不仅支持Unicode文件内容，而且支持Unicode文件名，下载完成后，解压缩，双击目录中的“BCompare.exe”即可使用工具了。
工具的使用
2.1 文件对比
1. 打开工具后，工具的主界面如下图所示。可以看到我们可以选择多种对比方式，这里先介绍文件对比。
2. 在左侧的目录中选择文本比较，会弹出比较界面。界面分为左右两个部分，分别用于显示我们需要进行的对比两个文件的具体内容
3. 在左右两边的下拉框中输入我们需要对比的文件的目录，并按回车，下方即可显示文件的具体内容。我在下拉框中可以输入本地文件路径，网络路径，FTP路径等多。下图左侧为FTP文件（访问FTP时需要输入用户名和密码），右侧为本地文件。
4. 文件对比结果大家已经看见了，不同的部分，工具可以自动以红色字体显示，而相同的部分则不会着重显示。如果文件内容较多，我们无法方便的浏览所有内容，查找出文件中不同内容或相同的内容。可以点击工具栏上的“≠”或“=”，“≠”表示显示所有不同的内容，“=”表示显示所有相同的内容。这样就可以一目了然的查看我们需要的信息了
2.2 文件夹对比
1. 如果需要对比大量文件那又该如何处理呢，这里我们就需要用到文件夹对比了。新建会话“文件夹比较”
2. 在左右两边的下拉框中输入文件夹路径，下方将显示路径目录下所有文件夹和文件
3. 选中一个文件夹，点击工具栏上的“比较内容”按钮 弹出“比较内容”对话框，这里我们选择“二进制比较”，点击“开始”
4. 工具将会对文件夹中所有文件进行逐个对比，相同的文件会在中间显示“=”，不同的文件会在中间显示“≠”
文件对比的速度较快，可以快速完成大批量文件的对比。
2.3 版本对比
本人对于工具的“版本对比”功能也很喜欢，通过该功能我们可以一目了然看到不同程序的版本情况。对比方法与文件对比方法一致。
2.4 其他功能
Beyond Compare还有很多实用的对比功能，如：MP3比较，数据比较，图片比较，注册表比较等。甚至还有文件同步，文本合并这些功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a20a3760e53493ca5ee094a0c7adb19/" rel="bookmark">
			ArcGIS中去除Z或M值的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在处理海绵城市的数据，拿到的dwg数据中，基本都含有标高，在ARCGIS中将线要素转成Polyline，进行 线转面 操作的过程中，出现Z值超出范围的错误。经过长时间的探寻，发现是由于转出的Polyline的数据类型为 折线 ZM造成的，也就是说点坐标中含有 Z和M值，如下图所示：
那么如何去除坐标中包含的Z和M值呢？将Z和M值设置成Disabled，然后进行复制要素的操作即可。具体的设置方式有以下两种：
1. 进行全局性的设置：在 地理处理 → 环境中，将M值和Z值的输出均设置成 Disabled，此种设置对之后的所有操作均有效；
2. 进行布局的设置：在进行复制要素的操作时，在环境中，将Z和M值设置成Disabled，此种操作只对本次操作有效。
进行上述设置后，再进行要素转换的操作（即重新导出成Shapefile或Feature Class），工具位置如下：
ArcToolbox -&gt; Conversion Tool -&gt; To Geodatabase -&gt; Feature class to Feature Class
ArcToolbox -&gt; Conversion Tool -&gt; To Shapefile-&gt; Feature Class To Shapefile (multiple)
进行转换后，得到的要素类的数据如下：
如图所示，点坐标中的Z和M值已被去掉，再进行如线转面等操作，就没有任何问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04a7ec4a02e532874cf36dfcbc0f7162/" rel="bookmark">
			armcc/armlink初探
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RealView编译工具armcc可以将c/c++ source code编译成arm target的object文件。
关于armcc的指导文档可以参照
http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0206ic/Chdefbgg.html
同样可以在上面查找关于ARM体系结构，ARM软件开发工具，RealView链接工具等主题的参考文档。上面的文档构成一个系列，在开始正式面向硬件开始C coding之前，这些基础知识是要熟悉的。不然写出的程序在SOC上怎么跑的都不甚了了，总是个欠缺。
1. 关于armcc
在我用的Keil [miu]Version3中，对于STM32f103 soc的工程，Options for Target '$project_name'-&gt;C/C++中Complier control string如下：
-c --device DARMSTM -D__MICROLIB -g -O0 --apcs=interwork -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\HARDWARE\LED -I..\HARDWARE\KEY -I "d:\Keil\ARM\INC\ST\STM32F10x" -o "*.o" --omf_browse "*.crf" --depend "*.d"
参照上面的RealView编译工具指南，逐个探究其含义。
-c:：此选项指示armcc只编译不连接。注意此处是小写字母c。
--device：指示为哪个微控制器或者SoC生成目标代码。
-D：在命令行中定义宏。例如，-D__MICROLIB等效于C语句#define __MICROLIB 1。-D后可以接多个宏，以逗号隔开。注意逗号和宏名称之间不能含有空格。
-g：提示编译过程中生成调试用的符号表。
-O0：-O之后接数字（可取[0-3]）表示编译器对source code的优化等级。
--apcs：这些字母是《ARM 体系结构的过程调用标准》的英文首字母缩写。以下是摘录自《RealView编译工具-编译器指南》
“语法
--apcs=qualifer...qualifier
其中，qualifier...qualifier 表示限定符的列表。该列表必须符合下列条件：
• 至少包含一个限定符
• 其中的各限定符之间没有空格分隔。
qualifier 的每个实例必须为下列值之一：
/interwork、/nointerwork
在支持或不支持 ARM/Thumb™ 交互操作的情况下生成代码。缺省值为 /nointerwork（缺省值为 /interwork 的 ARMv6 及更高版本除外）。
/ropi、/noropi 允许或禁止生成只读位置无关 (ROPI) 代码。缺省为 /noropi。/[no]pic 是 /[no]ropi 的别名。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04a7ec4a02e532874cf36dfcbc0f7162/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eefb776870fe119366598a2a82bcbde7/" rel="bookmark">
			把request对象中的请求参数封装到bean中/生成UUID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package me.gacl.util; import java.util.Enumeration; import java.util.UUID; import javax.servlet.http.HttpServletRequest; import org.apache.commons.beanutils.BeanUtils; /** * @author gacl * 把request对象中的请求参数封装到bean中 */ public class WebUtils { /** * 将request对象转换成T对象 * @param request * @param clazz * @return */ public static &lt;T&gt; T request2Bean(HttpServletRequest request,Class&lt;T&gt; clazz){ try{ T bean = clazz.newInstance(); Enumeration&lt;String&gt; e = request.getParameterNames(); while(e.hasMoreElements()){ String name = (String) e.nextElement(); String value = request.getParameter(name); BeanUtils.setProperty(bean, name, value); } return bean; }catch (Exception e) { throw new RuntimeException(e); } } /** * 生成UUID * @return */ public static String makeId(){ return UUID.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eefb776870fe119366598a2a82bcbde7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb8d07edccc51e7b5f7291efb772c003/" rel="bookmark">
			蓝牙 穿戴手环通信原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 前言 当前有越来越多的可穿戴设备使用了蓝牙4.0 BLE（Bluetooth Low Energy)。对于iOS开发而言，Apple之前专门推出CoreBluetooth的Framework来支持BLE的开发。对于硬件开发有了解的朋友应该知道，在之前使用低版本的蓝牙的设备，要连接到iOS设备上，需要注册MFI，拥有MFI协议才能进行相应的开发。如果大家关注我之前对LEGO EV3的研究，就可以发现，EV3是使用了蓝牙2.1，因此需要MFI协议来进行开发。
本文将一步一步讲解如何使用CoreBluetooth框架来与各种可穿戴设备进行通信，使用 小米手环 来进行基本的测试。 2 开发环境 1 Macbook Pro Mac OS X 10.10 2 Xcode 6.3.2 3 iPhone 5s v8.1 4 小米手环
3 基本流程 要开发蓝牙，需要对整个通讯过程有个基本了解。这里我摘录一些Apple官方的文档Core Bluetooth Programming Guide的图片来加以说明。这个文档其实对于开发的流程写的是非常的清楚，大家最好可以看一下。
3.1 可穿戴设备与iOS互联方式 从上面这幅图可以看到，我们的iOS设备是Central，用来接收数据和发送命令，而外设比如小米手环是Peripheral，向外传输数据和接收命令。我们要做的就是通过Central来连接Peripheral，然后实现数据的接收和控制指令的发送。在做到这一步之后，再根据具体的硬件，对接收到的数据进行parse解析。
3.2 可穿戴设备蓝牙的数据结构 这里用的是心率设备来做说明，每个外设Peripheral都有对应的服务Service，比如这里是心率Service。一个外设可以有不止一个s、Service。每个service里面可以有多个属性Characteristic，比如这里有两个Characteristic，一个是用来测量心率，一个是用来定位位置。
那么很关键的一点是每个Service，每个Characteristic都是用UUID来确定的。UUID就是每个Service或Characteristic的identifier。
大家可以在iPhone上下载LightBlue这个应用。可以在这里查看一些设备的UUID。 在实际使用中，我们都是要通过UUID来获取数据。这点非常重要。 在CoreBluetooth中，其具体的数据结构图如下： 4 Step-By-Step 上手BLE开发 4.1 Step 1 创建CBCentralManager 从名字上大家可以很清楚的知道，这个类是用来管理BLE的。我们也就是通过这个类来实现连接。
先创建一个：
&lt;code class="hljs objectivec has-numbering" style="display: block; padding: 0px; background-color: transparent; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px; border-bottom-left-radius: 0px; word-wrap: normal; background-position: initial initial; background-repeat: initial initial;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb8d07edccc51e7b5f7291efb772c003/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1764f5ef01463a616b063d78feb8486a/" rel="bookmark">
			转发 VS 重定向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转发：JSP容器将使用一个内部的方法来调用目标页面，新的页面继续处理同一个请求，而浏览器将不会知道这个过程.以前的request中存放的变量全部失效，并进入一个新的request作用域。
重定向：第一个页面通知浏览器发送一个新的页面请求.以前的request中存放的变量不会失效，就像把两个页面拼到了一起。
VS
使用重定向时，浏览器中所显示的URL会变成新页面的URL, 而当使用转发时，该URL会保持不变。重定向的速度比转发慢，因为浏览器还得发出一个新的请求。同时，由于重定向方式产生了一个新的请求，所以经过一次重 定向后，request内的对象将无法使用。
通常情况下转发更快，而且能保持request内的对象，所以他是第一选择。但是由于在转发之后，浏览器中URL仍然指向开始页面，此时如果重载当前页面，开始页面将会被重新调用。如果你不想看到这样的情况，则选择转发。
他们的调用分别如下：
request.getRequestDispatcher("apage.jsp").forward(request, response);//转发到apage.jsp
response.sendRedirect("apage.jsp");//重定向到apage.jsp
在jsp页面中你也会看到通过下面的方式实现转发：
&lt;jsp:forward page="apage.jsp" /&gt;
（1）RequestDispatcher.forward 方法只能将请求转发给同一个WEB应用中的组件；而HttpServletResponse.sendRedirect 方法不仅可以重定向到当前应用程序中的其他资源，还可以重定向到同一个站点上的其他应用程序中的资源，甚至是使用绝对URL重定向到其他站点的资源。如果 传递给HttpServletResponse.sendRedirect 方法的相对URL以“/”开头，它是相对于整个WEB站点的根目录；如果创建RequestDispatcher 对象时指定的相对URL以“/”开头，它是相对于当前WEB应用程序的根目录。
（2）调用HttpServletResponse.sendRedirect 方法重定向的访问过程结束后，浏览器地址栏中显示的URL会发生改变，由初始的URL地址变成重定向的目标URL；而调用 RequestDispatcher.forward 方法的请求转发过程结束后，浏览器地址栏保持初始的URL地址不变。
（3）HttpServletResponse.sendRedirect 方法对浏览器的请求直接作出响应，响应的结果就是告诉浏览器去重新发出对另外一个URL的访问请求。
（4）RequestDispatcher.forward 方法的调用者与被调用者之间共享相同的request 对象和response 对象，它们属于同一个访问请求和响应过程；而HttpServletResponse.sendRedirect 方法调用者与被调用者使用各自的request 对象和response 对象，它们属于两个独立的访问请求和响应过程。
对于同一个WEB应用程序的内部资源之间的跳转，特别是跳转之前要对请求进行一些前期预处理，并要使用 HttpServletRequest.setAttribute 方法传递预处理结果，那就应该使用RequestDispatcher.forward 方法。
不同WEB应用程序之间的重定向，特别是要重定向到另外一个WEB站点上的资源的情况，都应该使HttpServletResponse.sendRedirect 方法。
（5）无论是RequestDispatcher.forward 方法，还是HttpServletResponse.sendRedirect 方法，在调用它们之前，都不能有内容已经被实际输出到了客户端。如果缓冲区中已经有了一些内容，这些内容将被从缓冲区中清除。
转载于:https://www.cnblogs.com/yangfei-beijing/p/5957103.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3afd672c468ef3bef252ecfe1e99c1c/" rel="bookmark">
			Unity和Arduino交互系列——点亮LED
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这次主要讲一个韩国团队开发的Unity开发包，这个开发包所使用的其实和之前我写过的Unity和Arduino串口通信使用的方法是一样的，只是他们将其进行了封装，并且在上层进行了普通功能的简单操作，形成了一个可扩展的编辑器。
之所以选择并推荐这个开发包，是因为除了基础的通信功能，其他的都是开源的，我们可以根据需求各个模块进行再次封装编辑。
第一步：新建Unity工程，找到Window-&gt;Asset Store，搜索ARDunity，选择ARDUnity Basis 就可以了
点击导入，等到完全导入之后，就可以看到
简单介绍一下几个特殊的文件夹：
ARDUnity/Arduino这个里面是Arduino相关的文件，是C++形式的，在后面你会了解到，这些文件在你导出Arduino的Sketch时候会被导出，当然是根据你用到的来进行导出的。
ARDUnity/Examples这里面都是相关的例子，包括Digital控制LED，Analog控制LED，控制电机，以及一些传感器。
ARDUnity/Plugins这里面是对移动平台的封装，通过OTG连接Arduino也是可以直接进行控制的
ARDUnity/Scripts这个文件夹是用来放置Unity端和Arduino进行交互的脚本，是一个桥梁的作用
文件夹大致就是这些，下面我们来看简单的点亮LED的案例
第二步：
1、打开ARDUnity/Examples/LED/Analog/CircuitTest(Analog LED)
2、找到Unity左上方工具栏，找到ARDUnity-&gt;Wire Editor，这时会出现一个弹出界面，如果你之前玩过类似PlayeMaker，那对于这个就轻车熟路了。
3、界面及内容：下图已经注解了，具体的等我们实践时候再讲，不过要说一下的是AnalogOutput其中ID是这个输出模块的序号，Pin~3是具有PWM输出的3号端口
4、导出Arduino的Sketch，在上图的右侧可以看到，点击之后，选择导出的位置和文件名字，我导出的是桌面/L edTest，下面来看里面的内容
第三步：
1、我们用Arduino编辑器来打开刚刚导出的Sketch
2、插上Arduino，选择号端口号以及使用的板子，我的端口号是4板子是Arduino Uno，点击烧录，将Sketch烧录进去
烧录完成后不要拔掉Arduino，毕竟我们需要它和电脑通信，现在可以先将电路连接好
第四步：
1、打开刚才的Unity编辑器，点击Search，选择你的Arduino端口我的是Com4
2、现在可以点击Unity的Play按钮了，运行之后会发现，右侧原本是Export Sketch现在变成了Connect
点击进行连接，连接Arduino
3、找到Hierarchy面板下Ardunity/LED可以看到由此Imspector面板
4、用鼠标拖动Value滑动，看看LED的变化吧
视频不好弄，就不上传了，以后准备录一些视频教程，到时候再说吧，如果有什么问题，以及建议，欢迎和我进行交流
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7deea276ad61d256a001f2b173ec346/" rel="bookmark">
			notepad&#43;&#43;快速在每行头尾都加上指定的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用快捷键Ctrl+H打开“替换对话框”，在每行的开头添加内容。
勾选左下角的“正则表达式”选项（注意一定要记得勾选）
在“查找目标”里输入上尖号“^”，上尖号代表每行的开头
在“替换为”里输入“（需要添加的内容）”
然后点"全部替换"按钮，这样每行的前面就全部添加了（需要添加的内容）
在“查找目标”里输入美元符号“$”，美元符号代表每行的结尾
在“替换为”里输入“（需要添加的内容）”
然后点"全部替换"按钮，这样每行的结尾就全部添加了（需要添加的内容）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ec349b689620ec744b18e7eb18a41ad/" rel="bookmark">
			Java内存模型（JMM）以及 垃圾回收机制 小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内存模型：
内存模型描述了程序中各个变量（实例域、静态域和数组元素）之间的关系，以及在实际计算机系统中将变量存储到内存和从内存中取出变量这样的底层细节，对象最终是存储在内存里面的，这点没有错，但是编译器、运行库、处理器或者系统缓存可以有特权在变量指定内存位置存储或者取出变量的值。【JMM】（Java Memory Model的缩写）允许编译器和缓存以数据在处理器特定的缓存（或寄存器）和主存之间移动的次序拥有重要的特权，除非程序员使用了final或synchronized明确请求了某些可见性的保证。
1、主内存和工作内存
Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。此处的变量与Java编程时所说的变量不一样，指包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享。
Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存（可以与前面将的处理器的高速缓存类比），线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如下图所示。
2、内存间的交互操作
关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：
lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。 如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。
Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：
不允许read和load、store和write操作之一单独出现不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。 3、JVM逻辑内存模型（以下部分参考“《深入理解java虚拟机》”）
如图为JVM的逻辑内存模型：
依次对内存中名词进行解释：
1.方法区
也称"永久代” 、“非堆”， 它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB（未验证），可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。
运行时常量池：是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。
2.虚拟机栈
描述的是java 方法执行的内存模型：每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。声明周期与线程相同，是线程私有的。
局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、 double)、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部 变量表的大小空间。
3.本地方法栈
与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。
4.堆 也叫做java 堆、GC堆，是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建。该内存区域存放了对象实例及数组(所有new的对象)。其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，-Xmx为JVM可申请的最大内存。在JVM启动时，最大内存会被保留下来。为对象内存而保留的地址空间可以被分成年轻代和老年代。
默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。
Parameter
Default Value
MinHeapFreeRatio
40
MaxHeapFreeRatio
70
-Xms
3670k
-Xmx
64m
注：如果是64位系统，这些值一般需要扩张30％，来容纳在64位系统下变大的对象。
从J2SE 1.2开始，JVM使用分代收集算法，在不同年代的区域里使用不同的算法。堆被划分为新生代和老年代。新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代GC(MinorGC)任然存活的对象。
注1：图中的Perm不是堆内存，是永久代
注2：图中的Virtaul则是各区域还未被分配的内存，即最大内存-当前分配的内存
新生代：
新生代包括一块eden（伊甸园）和2块survivor(通常又称S0和S1或From和To)。大多数对象都是在eden中初始化。而对于2块survivor来说，总有一块是空的，它会在下一个复制收集过程中作为eden中的活跃对象和另一块survivor的目的地。在对象衰老之前（也就是被复制到tenured之前），它们会在两块survivor区域之间以这样的方式复制。可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及Survivor Space的大小。
老年代：
用于存放经过多次新生代Minor GC依然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：①.大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。②.大的数组对象，即数组中无引用外部对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ec349b689620ec744b18e7eb18a41ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78dd0e9f6b16ac1f00cbc909082ab3da/" rel="bookmark">
			awk &#39;{print $2}&#39; 这个命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 $2：表示第二个字段 print $2 ： 打印第二个字段 awk '{print $2}' $fileName : 一行一行的读取指定的文件， 以空格作为分隔符，打印第二个字段 比如有这样一个文件 a1 b1 c1 d1 a2 b2 c2 d2 执行的结果是,输出 b1 b2 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00dc24adba762049cf40896ebc35f57f/" rel="bookmark">
			用树莓派学编程系列2——环境温湿度测量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树莓派用DHT11读取环境温湿度
树莓派系列2——环境温湿度测量 前期准备 环境要求 DHT11，树莓派系统，Python，rpi.gpio等组件 相关软件安装方式见上章： http://blog.csdn.net/weixiazailaide/article/details/52740167 环境温湿度测量 创建temhum应用 具体方法见上章修改地方 helloworld/settings.py INSTALLED_APPS = [ 'raspberrypistate.apps.RaspberrypistateConfig', 'temhum.apps.TemhumConfig', 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', ] helloworld/urls.py
urlpatterns = [ url(r'^raspberrypistate/', include('raspberrypistate.urls',namespace="raspberrypistate")), url(r'^temhum/', include('temhum.urls',namespace="temhum")), url(r'^admin/', admin.site.urls), ] DHT11与树莓派连接 DHT11简介 DHT11是一款有已校准数字信号输出的温湿度传感器。 精度湿度+-5%RH， 温度+-2℃，量程湿度20-90%RH， 温度0~50℃。
DHT11厂家说明书
产品参数 相对湿度 分 辨 率：16Bit 重 复 性：±1%RH 精 度：25℃ ±5%RH 互 换 性：可完全互换 响应时间：1/e(63%)25℃ 6s 1m/s 空气 6s 迟 滞：&lt;±0.3%RH 长期稳定性：&lt;±0.5%RH/yr温度 分 辨 率：16Bit 重 复 性：±1℃ 精 度：25℃ ±2℃ 响应时间：1/e(63%) 10S电气特性 供 电：DC 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00dc24adba762049cf40896ebc35f57f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcd3f7386dda27f396d2e1c180f54b65/" rel="bookmark">
			s5pv210启动debian出错提示bash: cannot set terminal process group (-1): Inappropriate ioctl for device...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.启动参数如下：
bootargs=root=/dev/nfs nfsroot=192.168.1.8:/opt/wheezy_fs ip=192.168.1.9:192.168.1.8:192.168.1.1:255.255.255.0::eth0:on init=/bin/bash console=ttySAC0,115200
1.1错误信息如下:
bash: cannot set terminal process group (-1): Inappropriate ioctl for device
bash: no job control in this shell
2.修改启动参数:
bootargs=root=/dev/nfs nfsroot=192.168.1.8:/opt/wheezy_fs ip=192.168.1.9:192.168.1.8:192.168.1.1:255.255.255.0::eth0:on init=/sbin/init console=ttySAC0,115200
3.再次出现新的错误:
udevd[178]:unable to ctrl connection :function not implemented
对策:为内核打补丁,补丁地址如下:
https://github.com/genesi/linux-legacy/commit/a84fac75f38de592e530a2f9f982d7aafec6c288
转载于:https://www.cnblogs.com/dakewei/p/5933515.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92417a3ff4457472d65ff796de578b28/" rel="bookmark">
			常见文件文件头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各类文件的文件头标志
1、从Ultra－edit-32中提取出来的
附件:文件格式分析器
JPEG (jpg)，文件头：FFD8FF
PNG (png)，文件头：89504E47
GIF (gif)，文件头：47494638
TIFF (tif)，文件头：49492A00
Windows Bitmap (bmp)，文件头：424D
CAD (dwg)，文件头：41433130
Adobe Photoshop (psd)，文件头：38425053
Rich Text Format (rtf)，文件头：7B5C727466
XML (xml)，文件头：3C3F786D6C
HTML (html)，文件头：68746D6C3E
Email [thorough only] (eml)，文件头：44656C69766572792D646174653A
Outlook Express (dbx)，文件头：CFAD12FEC5FD746F
Outlook (pst)，文件头：2142444E
MS Word/Excel (xls.or.doc)，文件头：D0CF11E0
MS Access (mdb)，文件头：5374616E64617264204A
WordPerfect (wpd)，文件头：FF575043
Postscript (eps.or.ps)，文件头：252150532D41646F6265
Adobe Acrobat (pdf)，文件头：255044462D312E
Quicken (qdf)，文件头：AC9EBD8F
Windows Password (pwl)，文件头：E3828596
ZIP Archive (zip)，文件头：504B0304
RAR Archive (rar)，文件头：52617221
Wave (wav)，文件头：57415645
AVI (avi)，文件头：41564920
Real Audio (ram)，文件头：2E7261FD
Real Media (rm)，文件头：2E524D46
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92417a3ff4457472d65ff796de578b28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8fd80d3c2fb9511001c1f6e82e274ac/" rel="bookmark">
			Android studio 升级2.2 之后 Maven插件不能使用解决(No service of type Factory available in ProjectScopeServices)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		compile报下面的错误
&lt;code class="hljs fsharp has-numbering" style="display: block; padding: 0px; color: inherit; box-sizing: border-box; font-family: 'Source Code Pro', monospace;font-size:undefined; white-space: pre; border-radius: 0px; word-wrap: normal; background: transparent;"&gt;Error:(&lt;span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;"&gt;2&lt;/span&gt;, &lt;span class="hljs-number" style="color: rgb(0, 102, 102); box-sizing: border-box;"&gt;0&lt;/span&gt;) No service &lt;span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;"&gt;of&lt;/span&gt; &lt;span class="hljs-class" style="box-sizing: border-box;"&gt;&lt;span class="hljs-keyword" style="color: rgb(0, 0, 136); box-sizing: border-box;"&gt;type&lt;/span&gt; &lt;span class="hljs-title" style="box-sizing: border-box; color: rgb(102, 0, 102);"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8fd80d3c2fb9511001c1f6e82e274ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e2f3b5bc4b2b30ea7e06d346578eeaf/" rel="bookmark">
			Servlet API 中文版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本类和接口 一、javax.servlet.Servlet接口 servlet抽象集是javax.servlet.Servlet接口，它规定了必须由Servlet类实现由servlet引擎识别和管理的方法集。 Servlet接口的基本目标是提供生命期方法init()、service()和destroy()方法。 servlet接口中的方法 void init(ServletConfit config)throws ServletException 在servlet被载入后和实施服务前由servlet引擎进行?次性调用。如果init()产生溢出UnavailableException，则 servle退出服务。 ServletConfig getServletConfig() 返回传递到servlet的init()方法的ServletConfig对象 void service(ServletRequest request, ServletResponse response)throws ServletException,IOException 处理request对象中描述的请求，使用response对象返回请求结果 String getServletInfo() 返回描述servlet的一个字符串 void destory() 当servlet将要卸载时由servlet引擎调用 二、javax.servlet.GenericServlet类（协议无关版本） GenericServlet是一种与协议无关的servlet，是一种跟本不对请求提供服务的servlet，而是简单地从init()方法启动后台线程并在destory()中杀死。它可以用于模拟操作系统的端口监控进程。 servlet API提供了Servlet接口的直接实现，称为GenericServlet。此类提供除了service()方法外所有接口中方法的缺省实现。这意味着通过简单地扩展GenericServlte可以编写一个基本的servlet。 除了Servlet接口外，GenericServlet也实现了ServletConfig接口，处理初始化参数和servlet上下文，提供对授权传递到init()方法中的ServletConfig对象的方法。 GenericServlet类中的方法 void destory() 编飞组成单词“destory”的一个注册入口 String getInitParameter(String name) 返回具有指定名称的初始化参数值。通过凋用config.getInitParameter(name)实现。 Enumeration getInitParameterNames() 返回此serv]et已编码的所有初始化参数的?个枚举类型值。调用config.getInitParameterNames()获得列表。如果未提供初始化参数，则返回?个空的枚举类型值（但不是null） ServletConfig getServletConfig() 返回传递到init()方法的ServletConfig对象 ServletContext getServletContext() 返回在config对象中引用的ServletContext String getServletInfo() 返回空字符串 void init(ServletConfig config)throws ServletException 在一实例变量中保存config对象。编写组成单词“init”的注册入口,然后调用方法init() void init()throws ServletException 可以被跳过以处理servlet初始化.在config对象被保存后init(ServletConfig config)的结尾处自动被调用.servlet作者经常会忘记调用super.init(config) void log(String msg) 编写注册servlet的入口.为此调用servlet上下文的log()方法.servlet的名字被加到消息文本的开头。 void log(String msg,Throwable t) 编写一个入口和servlet注册的栈轨迹。此方法也是ServletContext中相应方法的一个副本。 abstract void service(Request request,Response response)throws ServletException,IOException 由servlet引擎调用为请求对象描述的请求提供服务。这是GenericServlet中唯一的抽象方法。因此它也是唯一必须被子类所覆盖的方法。 String getServletName() 返回在Web应用发布描述器（web.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e2f3b5bc4b2b30ea7e06d346578eeaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cdf8f2cef213fd23535b132cab7ba6f/" rel="bookmark">
			CSS3 3D旋转魔方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图：
注释：
ul * 表示ul下的所有样式都是这些。
改变代码中的ul *中的
&lt;span style="font-size:18px;color:#cc33cc;"&gt;background-color: rgba(255, 100, 100, 0.5);&lt;/span&gt; 即可改变魔方的颜色。
可以尝试通过改变perspective的值可以看下有什么效果。
代码：
&lt;span style="font-size:18px;color:#3333ff;"&gt;&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;3D魔方&lt;/title&gt; &lt;style type="text/css"&gt; * { margin:0; padding:0; } html { background: -webkit-radial-gradient(center, ellipse, #40E0D0 0%, #000000 100%); background: radial-gradient(ellipse at center, #40E0D0 0%, #000000 100%); height: 100%; } body { position: absolute; width: 400px; height: 400px; left:40%; top:20%; -webkit-perspective: 1000px; -ms-perspective: 1000px; perspective: 1000px; } ul { -webkit-animation:run 6s linear infinite; animation:run 6s linear infinite; height: 100%; position: absolute; -webkit-transform-style: preserve-3d; -ms-transform-style: preserve-3d; transform-style: preserve-3d; width: 100%; } ul * { background: -webkit-linear-gradient(180deg, rgba(0, 0, 0, 0) 0px, rgba(54, 226, 248, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cdf8f2cef213fd23535b132cab7ba6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f6b72cc6b709579cebc213437ea5fe4/" rel="bookmark">
			CentOS 6.5 hadoop 2.7.3 集群环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 6.5 hadoop 2.7.3 集群环境搭建 所需硬件，软件要求 使用 virtualbox 构建三台虚拟机模拟真实物理环境
操作系统：CentOS6.5
主机列表：
master ip: 192.168.3.171 slave1 ip: 192.168.3.135 slave2 ip: 192.168.3.136 为三台主机添加同一用户，设置密码：
# 添加用户 useradd hadoop # 修改密码 passwd hadoop SSH 免密码登录安装，配置 保证由master主机能够免密码登录到datanodes节点机上
# master 生成公钥 $ ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsa $ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys $ chmod 0600 ~/.ssh/authorized_keys 复制 master 公钥到 datanodes节点机
# 复制 master 主机公钥到 datanode 节点机的 /tmp 目录 scp ~/.ssh/id_rsa.pub hadoop@192.168.3.135:/tmp/authorized_keys scp ~/.ssh/id_rsa.pub hadoop@192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f6b72cc6b709579cebc213437ea5fe4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54936c444758923551db12ef9befd6ef/" rel="bookmark">
			Spring结合hibernate和jdbcTemplate多数据源事物问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先说明我的环境Spring3.2.8+hibernate3.6.10.Final+tomcat7
在写这篇博客前在网上查询了相关资料 ，网上给出的结论是：如果有多个相同的数据源,开启了多个事务，使用spring的声明式事务(AOP配置：1、xml配置 2、注解Transaction 两者都是。关于编程式事务就自行百度)管理事务，一旦发生RunTimeException异常，那么多个事务都会回滚。 如果是多个不相同的数据源(比如oracle不同用户、oracle数据源和SqlServer数据源这样的)，开启了多个事务， 使用使用spring的声明式事务管理事务，一旦发生RunTimeException异常，多个事务不能同时回滚
上面就是网上给出的结论，在Tomcat中如果让spring支持不同数据源事务一致性，必须用第三方工具 比如 Atomikos 和Jotm(或者换一个应用服务器 比如JBOSS)。下面给出我的测试结果
配置多个数据 我配置了三个数据源(每单个数据源又分为hibernate和jdbcTemplate)
数据源1、 dataSourceZhw： 数据库是oracle，用户是zhw 构建的hibernate和jdbcTemplate模板是 hibernateTemplate_zhw和jdbcTemplate_zhw 构建的两个事务管理器是:hiernateTx_zhw和jdbcTx_zhw
&lt;bean id="dataSourceZhw" destroy-method="close" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="${jdbc.oracle_driverClassName}" /&gt; &lt;property name="url" value="${jdbc.oracle_url}" /&gt; &lt;property name="username" value="${jdbc.oracle_username}" /&gt; &lt;property name="password" value="${jdbc.oracle_password}" /&gt; &lt;/bean&gt; &lt;!-- 定义hibernate模板和事务管理 --&gt; &lt;bean id="hibernateTemplate_zhw" class="org.springframework.orm.hibernate3.HibernateTemplate"&gt; &lt;property name="sessionFactory" ref="sessionFactoryZhw"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="txManager_zhw_hibernate" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactoryZhw" /&gt; &lt;qualifier value="hiernateTx_zhw"&gt;&lt;/qualifier&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager="txManager_zhw_hibernate" /&gt; &lt;!-- 定义jdbcTemplate模板和事务管理 --&gt; &lt;bean id="jdbcTemplate_zhw" class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54936c444758923551db12ef9befd6ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e151aa98f6e824fcaa60f7deefb0d205/" rel="bookmark">
			JavaWeb网上商城
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web项目 1.关于web项目目的: 将web阶段所有学过的知识点复习总结. 2.关于web项目功能: 功能： 1、用户注册 2、用户登录 3、添加商品（上传） 4、商品查看-- 列表查询 5、商品详情页面 6、将商品添加购物车 7、查看购物车 8、修改购物车 9、生成订单 10、订单查看（取消） 11、在线支付 12、销售榜单查看 会对项目进行重构. 会使用注解+动态代理实现细粒度权限控制. 添加关于ajax操作 对于订单操作时，使用ajax 在线支付功能	3.系统分析 1.通过UML用例图来确定当前用户以及所具有的功能 游客（未登录）： 注册、登陆、商品查看 商城注册用户 ： 商品查看、添加商品到购物车、购物车管理、生成订单、订单管理、在线支付 管理员 ： 添加商品、商品管理、查看订单 、榜单查看（导出） 2.系统设计 1.技术选型 JSTL + JSP + Servlet + JavaBean + BeanUtils + FileUpload + JavaMail + DBUtils(JDBC) + C3P0 + MySQL + MyEclipse10+ Tomcat7.0 + JDK6 + Windows MVC 模式 JavaEE 三层结构 DAO 模式 2.数据库设计 E-R图 实体关系图.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e151aa98f6e824fcaa60f7deefb0d205/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae616b06e26e936ed1c0d6028dda4601/" rel="bookmark">
			关于UEFI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是UEFI 简单来讲，是在硬件及操作系统之间的接口，如下图： UEFI的优点 开发效率高 采用C/C++语言编写软件分层结可扩展性 以module的形式，如Driver的模型驱动、表、protocol有版本控制性能 提供的异步操作，event事件，减少CPU等待时间舍弃了中断这种耗时的操作启动时可仅仅遍历启动所需设备安全 在执行应用及驱动前会检测程序和驱动的证书 UEFI核心概念 启动过程 重点关注以下几个入口文件：
PeiMain.cDxeMain.cBdsEntry.c Module Module有统一的格式要求，一般是源文件+inf（类似于makefile）+uni（资源文件），每一种Moudle的格式稍稍有些不同，大概有以下几种类型： Protocol 可以说Protocol是UEFI中最重要的概念。可以理解为server与client间通信的信使。
从使用者的角度来看：
从提供者的角度来看：
搞清楚以下几个问题： 1. protocol是什么？ - 从语言角度讲，是包含了属性和函数指针的结构体； - 从功能上讲，是server与client对服务方式上的一种约定； 2. protocol安装到什么地方？ - 在image对象中的句柄中；image对象是指DXE型驱动； 3. 怎样安装protocol？ - 通过InstallprotocolInterface; 4. 什么时候安装？ - 在image初始化时（在执行模块入口函数时）
EFI_HANDLE 指向某种对象的指针，包括controller及Image对象。每个HANDLE都有一个Protocols链表用来存放属于自己的Protocol。 Controller UEFI扫描总线后，会为每个设备建立一个Controller对象，用于控制设备。 什么时候扫描总线？PCI Scan的时候？
Image SystemTable 用户空间通往内核空间的通道，在DXE阶段被初始化。 两个核心成员： - BootServices - RuntimeServices Event 从生产者和消费者的角度理解，一个产生事件：
CreateEvent 一个消费事件
WaitForEvent 触发事件
SignalEvent时钟中断 Driver 服务型驱动（DXE驱动） 三个部分&gt;
protocol服务接口设计 定义有哪些函数及变量、GUID。
接口的实现 实现这些函数。
驱动框架
定义inf文件入口函数中安装驱动（gBS-&gt;InstallProtocolInterface） UEFI驱动 一个设备/总线驱动程序在安装时首先要找到对应的硬件设备（在UEFI中是要找到对应的控制器），然后执行安装操作，将驱动程序安装到硬件设备的控制器上。核心是通过EFI Driver Binding Protocol管理驱动程序，在驱动的入口函数中安装EDBP到自身的Handle上，在以下三个函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae616b06e26e936ed1c0d6028dda4601/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7578f7682d712bdda32c75074c62791/" rel="bookmark">
			部署公文时要注意的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 receive_config_index.jsp,send_config_index.jsp, processEngineHostmin:Url命名空间对象,本地测试时应当置空 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/290/">«</a>
	<span class="pagination__item pagination__item--current">291/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/292/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>