<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b385581ab4ea573010a853c71a5d5a9/" rel="bookmark">
			补全数据 2种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数据库构造一个连续日期的表作为主表关联数据表查询 最近7天的数据，没有数据自动补0
创建表结构:
DROP TABLE IF EXISTS `person_num_day`; CREATE TABLE `person_num_day` ( `date` date NULL DEFAULT NULL, `person_num` int(11) NULL DEFAULT NULL ) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci; sql如下: 如果项目中 有连续的日期表, 就不用写 INTERVAL 1 day , INTERVAL 2 day, INTERVAL 3 day了, 我们拿来即用
SELECT a.*, ifnull(b.person_num, 0) FROM ( SELECT curdate() as date UNION ALL SELECT date_sub(curdate(), INTERVAL 1 day) UNION ALL SELECT date_sub(curdate(), INTERVAL 2 day) UNION ALL SELECT date_sub(curdate(), INTERVAL 3 day) UNION ALL SELECT date_sub(curdate(), INTERVAL 4 day) UNION ALL SELECT date_sub(curdate(), INTERVAL 5 day) UNION ALL SELECT date_sub(curdate(), INTERVAL 6 day) ) a LEFT JOIN ( SELECT date, person_num FROM person_num_day GROUP BY date ) b on a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b385581ab4ea573010a853c71a5d5a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b982fcd228d5cb4c1ca9e909ef6f2533/" rel="bookmark">
			深度学习｜2.4 梯度下降
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如上图， J ( w , b ) J(w,b) J(w,b)是由w和b两个参数共同控制的损失函数，损失是不好的东西，所以应该求取合适的w和b使得损失最小化。
为了简单考虑，可以先忽略参数b。
斜率可以理解成在朝着x正方向移动单位距离所形成的损失值的变化，如果损失值变大，那么x往负方向移动；如果斜率为负，损失值变小，说明可以继续往正方向移动，应该要加上一个正值。（负负得正）
其中学习率用于控制变化的过程。
学习率越小，参数变化就越小，越容易收缩到一个定值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e060226fa632221b4cae62bfed66d33/" rel="bookmark">
			iperf2和iperf3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、iperf2和iperf3比较 https://iperf2.sourceforge.io/IperfCompare.html
Feature
Iperf 2
Iperf 3
Traffic types
TCP traffic
Y
Y
UDP traffic
Y
Y
SCTP traffic
N
Y
IPv4
Y
Y
IPv6
Y
Y
Multicast traffic (including SSM)
Y
N
TCP connect only
Y
N
Layer 2 checks
Y
N
TCP near congestion (experimental)
Y
N
Output options
Human format
Y
Y
JSON output
N
Y
CSV (basic only)
Y
N
Client side server reports
N
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e060226fa632221b4cae62bfed66d33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f6ca543add8cdc05d783db71efb4225/" rel="bookmark">
			Http状态：net::ERR_INCOMPLETE_CHUNKED_ENCODING
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述： 今天前端的小伙伴遇到一个js文件加载报错：net::ERR_INCOMPLETE_CHUNKED_ENCODING，不论如何刷新页面始终只有该文件加载失败，Chrome开发者工具中响应内容显示此请求没有可用的响应数据。
二、原因调查 排除非前端发布问题，直接查看ngnix日志，发现有异常日志：
2024/01/02 14:23:43 open() "/usr/local/nginx/proxy_temp/4/86/0000000864" failed (13: Permission denied) while reading upstream 首先，先了解一下有关ngnix 临时文件存储：
/usr/local/nginx/proxy_temp 是Nginx代理临时文件存储路径的默认位置。在 Nginx 服务器中，当使用代理模块时，会将代理的临时文件存储在这个proxy_temp目录中。这些临时文件通常是代理请求的响应内容，用于临时存储代理请求的数据。
proxy_temp_file_write_size是用于控制在向磁盘写入临时文件时的文件大小阈值。如果一个代理请求的响应内容超过了这个阈值，Nginx会将响应内容写入临时文件而不是存储在内存中。这有助于避免内存溢出，特别是在处理大型响应时。
因此，proxy_temp_file_write_size 和 /usr/local/nginx/proxy_temp目录都与代理请求的临时文件存储有关。proxy_temp_file_write_size控制着何时将响应内容写入临时文件，而/usr/local/nginx/proxy_temp 是实际存储这些临时文件的默认位置。
据上所述，open() "/usr/local/nginx/proxy_temp/4/86/0000000864" failed (13: Permission denied)的原因，应该就是/usr/local/nginx/proxy_temp目录过大或者没有写入权限。
如果确认目录权限没有问题，那么只要清空/usr/local/nginx/proxy_temp目录即可：
执行如下命令：
rm -rf /usr/local/nginx/proxy_temp/* 最后刷新页面，已能正常加载该js文件：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56adecdd6a8720176a8edf4024c99997/" rel="bookmark">
			Web自动化测试框架总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实施过了web系统的UI自动化，回顾梳理下，想到什么写什么，随时补充。 首先，自动化测试不是手动测试的替代品，是比较好的补充，而且不是占大比重的补充。 70%的测试工作集中在底层接口测试和单元测试，20%的测试工作为集成测试，其他10%的测试即为界面测试。开发方向：
尽可能的相通的模块，通用的封装开发约定好，便于定位适用兼容测试无界面运行快速定位问题：报错信息、错误截图多环境 收益点 脚本开发时间和复用次数快速验证，第一时间响应问题 还可以做哪些？
兼容性多环境便于快速定位提炼更多通用模块。调研更优解决方案，比如：cypress等case依赖优化深度校验 什么样的项目适合web自动化 系统稳定，太多的阻止程序或更改。准备之前，先手工测试，确认自动测试可以涵盖的系统功能。需要多系统，多浏览器兼容性测试 什么样的功能点需要web自动化 主业务流程易于实现自动化的web元素、页面重复量大的功能 同时，在这我为大家准备了一份软件测试视频教程（含面试、接口、自动化、性能测试等），就在下方，需要的可以直接去观看，也可以直接【点击文末小卡片免费领取资料文档】
软件测试视频教程观看处：
2024年Python自动化测试全套保姆级教程，70个项目实战，3天练完，永久白嫖...
web自动化常见的验证点 页面元素验证页面列表数据验证页面元素属性？UI的文本，图片显示正确性UI的交互逻辑正确性测试UI上的用户行为正确性测试 对于web自动化框架常见的需求点 分布式执行，可以多机器，多浏览器同步执行脚本适用于不同环境运行分层设计，方便维护生成测试报告模块的复用必要的日志搜集 UI自动化收益点的采集 回归测试需要定期运行，在自动化时，它们可以节省测试人员的时间，我们可以更专注于其他场景和探索性测试。脚本开发时间和复用次数误报频率 UI自动化缺点or局限 不能快速反馈（相对于单元测试和API测试）只会对于case已确定的内容进行校验运行的稳定性发现的错误不多，大多数错误似乎是通过“意外”或进行探索性测试而发现的。这可能是因为在每个探索性测试会话期间，我们可能以不同的方式测试应用程序，从而通过应用程序找到新的漏洞。编写优秀且稳定的XPath / CSS定位器所花费的时间，并在底层HTML标记发生变化时更新它们。UI本身的变化性，要想达到和手工测试相同的覆盖率，投入比较大。 如何进行CI（Continuous Integration），也就是持续集成 ● 持续提交代码 (Check-in)
○ 一天之中多次提交
● 持续构建代码 (Build)
○ 保证在任何时刻代码是可以继续开发的
● 持续部署代码 (Deploy)
○ 保证始终有一个可以部署的版本
● 持续测试代码 (Test)
○ 每次提交均执行单元测试
○ 每天一次或数次集成测试
○ 每天一次或数次系统测试 复制代码 不过，高频的集成，还是用接口更加合适，后面的工作会把系统的交互接口自动化，届时分享。
最后感谢每一个认真阅读我文章的人，礼尚往来总是要有的，虽然不是什么很值钱的东西，如果你用得到的话可以直接拿走：
这些资料，对于做【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴我走过了最艰难的路程，希望也能帮助到你！凡事要趁早，特别是技术行业，一定要提升技术功底。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff6eb0b9377e1f1e032d7c6b7f146892/" rel="bookmark">
			将Qt窗口停靠在Maya界面中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述： 将PySide2/PyQt工具的窗口停靠在Maya的界面中
解决方法： from PySide2 import QtCore, QtGui, QtWidgets from maya.app.general.mayaMixin import MayaQWidgetDockableMixin class MainWindow(MayaQWidgetDockableMixin, QtWidgets.QMainWindow): def __init__(self, parent=None): super(MainWindow, self).__init__(parent=parent) self.setWindowTitle("test") # Main widget main_widget = QtWidgets.QWidget() main_layout = QtWidgets.QVBoxLayout() # Create UI widgets self.test_btn = QtWidgets.QPushButton('Test') # Attach widgets to the main layout main_layout.addWidget(self.test_btn) # Set main layout main_widget.setLayout(main_layout) self.setCentralWidget(main_widget) # Connect buttons signals self.test_btn.clicked.connect(self.on_test_btn_click) def on_test_btn_click(self): print('Test button was clicked') w = MainWindow() w.show(dockable=True, floating=False, area='left') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da17030f72d0dac13467cf9e4973c462/" rel="bookmark">
			华为Could API人工智能系列——关键词抽取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为Could API人工智能系列——关键词抽取 前言 云原生时代，开发者们的编程方式、编程习惯都发生了天翻地覆的变化，大家逐渐地习惯在云端构建自己的应用。作为新一代的开发者们，如何更快速了解云，学习云，使用云，更便捷、更智能的开发代码，从而提升我们的开发效率，是当前最热门的话题之一，而Huawei Cloud Toolkit,作为连接华为云的百宝箱，是集成在各大IDE平台上的插件集合，会在方方面面提升着开发者的效率。
华为云API开发套件助力开发者快速集成华为云，可做到便捷连接200+的华为云服务，引用7000+的华为云API服务，在IDE中集成华为云的功能，让开发者与云端华为云建立连接。
智能编码方面集成了华为云自主研发的代码大模型和软件分析技术，全场景函数级、行级代码生成，同规模算力一次通过业界第一，这会帮助开发者更为高效的使用自动语义生成，达到快速开发的目的，使整个过程更智能。
环境准备 开发语言：Python
开发工具：PyCharm Community Edition 2023.1.4
PyCharm插件：
1、Chinese (Simplified) Language Pack /中文语言包
2、Huawei Cloud API：华为云API插件提供华为云服务全量API检索、调试、SDK代码自动补全、集成华为云CLI、示例代码等功能
3、Huawei Cloud CodeArts Check：华为云代码检查插件提供业界规范（含华为云）检查，支持一键格式化和代码自动修复，当前支持Java、C++、C，这个使您使用的环境操作即可，我这里用的python没有提示。
4、Huawei Cloud CodeArts Snap：华为云 CodeArt Snap 智能编程助手致力于打造现代化开发新范式，通过将自然语言转化为规范可阅读、无开源漏洞的编程语言，提升开发者编码效率，助力企业快速响应市场不确定性；
5、Huawei Cloud Toolkit Platform：华为云底座插件为华为云各类云服务插件提供公共能力，比如单点登录、UI集成、API访问等功能；
PyCharm环境的搭建：https://laoshifu.blog.csdn.net/article/details/135279145
API接口开通地址：https://console.huaweicloud.com/nlp/#/nlp/overview 关键词抽取 给定一段文本,抽取其中最能够反映文本主题或者意思的词汇。
开通地址：https://console.huaweicloud.com/nlp/#/nlp/overview
开通效果：
请求参数 名称类型IN必选描述X-Auth-Tokenstringheadertrue 用户Token。 通过调用IAM服务获取用户Token接口获取(响应消息头中X-Subject-Token的值)。
project_idstringpathtrue 来自公有云的Project ID,用于资源隔离。
Body 参数 名称类型必选描述textstringtrue 待分析文本,长度为1~512,文本编码为UTF-8。
limitintegerfalse 返回关键词的最大数量,默认为5。
langstringfalse 支持的文本语言类型,目前只支持中文,默认为zh。
返回参数 名称类型必选描述wordsArray of stringsfalse 关键词列表。调用失败时无此字段。
error_codestringfalse 调用失败时的错误码,具体请参见错误码。调用成功时无此字段。
error_msgstringfalse 调用失败时的错误信息。调用成功时无此字段。
API调试 测试词语：【
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da17030f72d0dac13467cf9e4973c462/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4015cd2f30ca0a6710bff67016445b7b/" rel="bookmark">
			nginx 配置代理ip访问https的域名配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 代理服务器是一种中间服务器，用于转发客户端请求到目标服务器。Nginx是一款高性能的Web服务器和反向代理服务器，可以用于配置代理IP访问HTTPS的域名。在本篇文章中，我们将介绍如何使用Nginx配置代理IP访问HTTPS域名，并提供相关代码示例。
1. 安装Nginx 首先，我们需要安装Nginx。在Ubuntu系统上，可以使用以下命令进行安装：
sudo apt-get update sudo apt-get install nginx 在CentOS系统上，可以使用以下命令进行安装：
sudo yum install epel-release sudo yum install nginx 2. 配置Nginx代理 完成Nginx的安装后，我们可以开始配置代理。在Nginx的配置文件中，我们可以使用`proxy_pass`指令配置代理IP访问HTTPS域名。
首先，打开Nginx的配置文件`/etc/nginx/nginx.conf`：
sudo nano /etc/nginx/nginx.conf 在配置文件中找到`http`部分，然后在其中添加以下配置：
http { ... server { listen 80; server_name example.com; location / { proxy_pass https://your_ip; } } } 其中，`example.com`是要代理的域名，`your_ip`是要代理的IP地址。请根据实际情况进行替换。
保存并退出配置文件。
3. 重启Nginx 完成配置后，我们需要重新启动Nginx服务器使其生效。可以使用以下命令：
sudo service nginx restart 4. 验证代理 现在，您可以尝试访问`http://example.com`来验证代理是否配置成功。Nginx会将请求转发到`https://your_ip`，并将响应返回给客户端。
可以使用`curl`命令来测试代理，例如：
curl http://example.com 如果一切正常，您将会看到来自`https://your_ip`的响应。
结论 本文介绍了如何使用Nginx配置代理IP访问HTTPS的域名。首先，我们安装了Nginx，并修改了配置文件以添加代理配置。然后，我们重新启动了Nginx服务器，并使用`curl`命令进行了验证。
希望本文对您有所帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e79c4e8e28a0b302d5a4e406d1d34b9/" rel="bookmark">
			[linux c/c&#43;&#43;] 通过读取 /proc 路径获取指定进程名的信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;dirent.h&gt; #include &lt;string.h&gt; static bool checkServiceRunning(const char *servicename){ constexpr int BUF_SIZE = 4096; bool ret = false; DIR *dir; struct dirent *ptr; FILE *fp; char filePath[512] = {0}; char buf[BUF_SIZE] = {0}; char key[128] = {0}; char value[512] = {0}; dir = opendir("/proc"); if(dir!=NULL){ while((ptr = readdir(dir)) != NULL){ if(strcmp(ptr-&gt;d_name, ".") == 0 || (strcmp(ptr-&gt;d_name, "..") == 0)) continue; if(ptr-&gt;d_type != DT_DIR) continue; sprintf(filePath, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e79c4e8e28a0b302d5a4e406d1d34b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1458943f8dde1456d9b348c9a8d91cc/" rel="bookmark">
			SpringBoot之注册Web组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 提示：这里可以添加系列文章的所有文章的目录，目录需要自己手动添加
SpringBoot之注册Web组件
提示：写完文章后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 系列文章目录前言一、注册Servlet注册方式一注册方式二 二、注册Filter注册方式一注册方式二 注册Listener注册方式一注册方式二 总结 前言 提示：这里可以添加本文要记录的大概内容：
在当今的互联网时代，Web 应用程序已经成为了人们日常生活和工作中不可或缺的一部分。而SpringBoot 作为一个基于 Java 的轻量级框架，因其简单易用、快速开发和高效运行的特点，受到了越来越多开发者的青睐。
在SpringBoot 应用程序中，注册 Web 组件是一个非常重要的环节。它可以帮助我们将应用程序的各个部分（如控制器、服务、过滤器等）整合到一起，形成一个完整的 Web 应用程序。
通过阅读这篇博客文章，读者将不仅可以掌握SpringBoot 注册 Web 组件的基本概念和方法，还能够了解一些高级技巧和最佳实践。无论是刚开始学习SpringBoot 的新手，还是已经有一定经验的开发者，都可以从中受益。
让我们一起开始探索SpringBoot 之注册 Web 组件的世界吧！
一、注册Servlet 由于SpringBoot项目没有web.xml文件，所以无法在web.xml中注册web组件，SpringBoot有自己的方式注册web组件。
注册方式一 1.编写servlet
@WebServlet("/first") public class FirstServlet extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response){ System.out.println("First Servlet........"); } } 2.启动类扫描web组件
@SpringBootApplication //SpringBoot启动时扫描注册注解标注的Web组件 @ServletComponentScan public class Springbootdemo2Application { public static void main(String[] args) { SpringApplication.run(Springbootdemo2Application.class, args); } } 注册方式二 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1458943f8dde1456d9b348c9a8d91cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c7242b398d59beb59edbdd20bd075c/" rel="bookmark">
			nextTick的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 场景： 左边的树有被选中项，则显示右边的内容，且清除右边表格的被选中项
代码大概就是 选中左边的树然后执行 this.$refs.treeRef.setCurrentRow(); // 取消表格高亮行
然后报错：
解决： 在外面包一层this.$nextTick就可
this.$nextTick(()=&gt;{ this.$refs.treeRef.setCurrentRow(); // 取消表格高亮行 }) 原因： 在执行this.$refs.treeRef.setCurrentRow(); // 取消表格高亮行时，右边的表格还没显示出来，所以取不到右边的表格，右边的表格为undefined。
加上 this.$nextTick，this.$refs.treeRef.setCurrentRow();就会在页面的dom更新后（也就是右边的表格显示出来之后）再执行了
补充 场景2： 点击按钮弹出对话框，对话框中有一个可以单选的表格，我需要在点击按钮弹出对话框时清除对话框中表格的单选选中项，使用了this.$nextTicky 依旧提示this.$ref.addForm为undefined，
写法如下：
// 添加 打开对话框 addOpen() { this.$nextTick(() =&gt; { // this.$nextTick(()=&gt;{ // this.$refs.addForm.setCurrentRow(); // }) this.$refs.addForm.setCurrentRow(); }); this.dialogVisible_add = true; }, 报错如下：
解决： 包两层this.$nextTick
// 添加 打开对话框 addOpen() { this.$nextTick(() =&gt; { this.$nextTick(()=&gt;{ this.$refs.addForm.setCurrentRow(); // 取消表格高亮行 }) }); this.dialogVisible_add = true; }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b08ddf006ce54195be206b765a346b0/" rel="bookmark">
			HCIE云计算备考知识点记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仅针对个人觉得需要记录的知识点记录，可能会有错误
kubernetes由master节点与node节点组
Dockerfile基础镜像中有一个特殊镜像scratch，表示一个空白镜像
kubernetes组件功能：
kube-apiserver——暴露kubernetes的API接口，负责接收所有请求
kube-proxy——kubernetes的数据库
kube-schedule——kubernetes集群调度器，用于为新pod选择node
Eggo是openEuler21.09推出的kubernetes集群部署工具
CCE服务的pod访问类型不需要配置为负载均衡
创建pod的yaml文件，但不真正创建pod：kubectl run nginx-image=xxxx -o yaml —dry-run=client &gt;test.yaml
dockerfile中ADD命令可以用于将文件、目录从构建上下文或远程URL复制到容器中，与COPY指令类似，可以多次使用ADD指令，实现多个文件和目录的复制操作
创建Cronjob和job时，kind参数应该设置为不同的Cronjob和job两种
kubectl get deployment命令回显的字段含义：
NAME：部署的名称。
READY：展示有多少个副本已经就绪（Ready）。
UP-TO-DATE：展示有多少个副本与部署期望的副本数一致。
AVAILABLE：展示有多少个副本可以提供服务（Available）。
AGE：展示部署对象创建的时间长度。
安全容器指的是每一个pod都运行在独立的微型虚拟机中，拥有独立的操作系统和内核，以及虚拟化层的安全隔离
kubernetes中image pull policy用于设置镜像拉取策略，支持三种拉取策略：
Always——总是从从远端仓库拉取镜像
IfNotPresent——本地有则使用本地镜像，本地没有则从从远端仓库拉取镜像
Never——只使用本地镜像，如果本地没有就会报错
调度pod运行节点的两种方式node selector和node affinity：
node affinity支持更为复杂的pod调度策略，
node selector相对简单，只能使用基于集合的标签选择器匹配节点
docker run 命令指定了参数会把CMD里的参数覆盖，但如果使用ENTRYPOINT就不会被覆盖
K8s启动pod容器时，会按照配置文件中顺序启动，如果其中一个容器没有启动成功，会影响其他容器，为了避免这种情况建议在编写yaml时规定容器启动顺序
k8s中通过yaml创建的对象可以通过yaml文件或者指定对象名称删除
k8s中的Cronjob在完成一次任务后，pod是running状态
pod中的容器都被成功终止之后，pod会处于conpleted状态
dockerfile在容器构建时，可以使用entrypoint指定镜像启动时执行的命令，且不会像CMD一样被覆盖，一般是一些脚本，用以启动时进行初始化配置
docker run如果指定了参数会把dockerflie制作时的CMD参数覆盖
docker中docker daemon负责接收客户端对容器的操作请求
HCS的CCE服务在架构上分为管理面、控制面和数据面，进行一站式kubernetes创建的是“云容器引擎”
HCS的SWR服务是一个容器镜像存储和管理服务。SWR提供了一个集中的、安全的容器镜像仓库，用于存储、分享和管理容器镜像。
eReplication与IAM需要部署在Global区
bind mounts与volumes的区别在于bind mounts是将宿主机的任意文件和文件夹挂载到容器，而volumes本质是将docker服务管理的一块区域挂载到容器
pod的污点类型：
preferNoSchedule：尽可能不调度到该节点
NoSchedule：新创建的pod不调度到该节点，已运行的pod不受影响
NoExecute：完全不调度到该节点
kubernetes管理层面的组件在本质上属于静态容器
在测试阶段使用kubernetes部署测试应用，可以使用容器默认权限级别
Kubernetes生态系统中有许多常用的插件和工具，用于增强和扩展Kubernetes的功能。以下是一些常见的Kubernetes插件：
Ingress Controllers：用于实现HTTP和HTTPS流量的入口控制和路由。常见的Ingress Controllers包括Nginx Ingress Controller、Traefik、HAProxy Ingress等。Prometheus：用于监控和度量Kubernetes集群的开源监控系统。它可以采集指标数据并提供强大的查询和报警功能。Grafana：一个可视化和监控仪表盘工具，可与Prometheus等数据源集成，用于展示和分析监控数据。Helm：一个Kubernetes包管理器，用于简化应用程序的部署、升级和管理。它允许用户定义和分享应用程序的Chart，以便轻松部署到Kubernetes集群。Istio：一个用于微服务架构的服务网格平台，提供流量管理、安全性、可观察性和策略执行等功能。Calico：一个网络和安全插件，用于提供高性能的网络功能和网络策略。它支持Kubernetes集群的网络隔离和安全性。Flannel：一个网络插件，用于创建覆盖整个Kubernetes集群的容器网络。它提供IP地址管理和网络通信功能。CoreDNS：一个用于Kubernetes集群的DNS插件，提供服务发现和DNS解析功能，简化了对服务的访问和管理。Velero：一个备份和恢复工具，用于保护和迁移Kubernetes集群中的应用程序和数据。MetalLB：一个用于在裸金属（Bare Metal）环境中提供负载均衡服务的插件。 docker run的参数 —cpu-period 10000 —cpu-quota 2500的数字以纳秒为单位
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b08ddf006ce54195be206b765a346b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d44bdb264384a3cb521512cf84dada6/" rel="bookmark">
			如何在 Ubuntu 20.04 上以独立模式设置 MinIO 对象存储服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个人工智能学习网站，通俗易懂，风趣幽默，最重要的屌图甚多，忍不住分享一下给大家。点击跳转到网站。
如何在 Ubuntu 20.04 上以独立模式设置 MinIO 对象存储服务器 介绍 存储非结构化对象数据 blob 并使其可通过 HTTP API（称为对象存储）进行访问的能力是现代技术领域不可或缺的一部分，尤其是基于云的备份解决方案和高可用性内容交付网络 (CDN)。
MinIO是一款与Amazon S3云存储服务兼容的开源对象存储服务器。配置为与 Amazon S3 交互的应用程序也可以配置为与 MinIO 交互，这意味着您可以使用 MinIO 作为 S3 的可行替代方案，以更好地控制对象存储服务器。该服务存储非结构化数据，例如照片、视频、日志文件、备份和容器/虚拟机映像，并可以提供单个对象存储服务器，该服务器可以池化分布在许多服务器上的多个驱动器。
MinIO用Go编写，带有命令行客户端和图形界面（MinIO 控制台），同时支持高级消息队列协议 (AMQP)、Elasticsearch、Redis、NATS和PostgreSQL目标的简单队列服务。出于所有这些原因，设置 MinIO 对象存储服务器可以为您的项目添加广泛的灵活性和实用性。
MinIO 可以以独立模式安装在单个服务器上，也可以以分布式模式安装在两台或多台服务器（总共至少有四个驱动器或存储卷）上。MinIO 的独立部署缺乏分布式部署默认的一些高级功能，例如版本控制、扩展、冗余和可用性。独立部署可用于评估和小型开发目的，而强烈建议使用分布式部署以满足生产或重大开发需求。
在本教程中，将通过以下方式设置 MinIO 的独立部署：
在运行 Ubuntu 20.04 的服务器上安装 MinIO 服务器。个人计算机上安装 MinIO 客户端并将其配置为与 MinIO 服务器通信。设置数字证书以保护服务器和客户端之间的通信（包括通过 MinIO 控制台）。 先决条件 需要：
一台 Ubuntu 20.04 服务器，包括 sudo 非 root 用户和防火墙。 或者，要通过域名访问 MinIO 控制台而不是通过服务器的 IP 地址访问它，或者除了通过服务器的 IP 地址访问它之外，还需要：
已注册的域名。 第 1 步 — 下载并安装 MinIO 服务器 MinIO 服务器可以从二进制文件.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d44bdb264384a3cb521512cf84dada6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/095e02b49c525474c6bc2f00377577f9/" rel="bookmark">
			如何在 Ubuntu 18.04 上使用 Minio 设置对象存储服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个人工智能学习网站，通俗易懂，风趣幽默，最重要的屌图甚多，忍不住分享一下给大家。点击跳转到网站。
介绍 从基于云的备份解决方案到高可用性内容交付网络 (CDN)，存储非结构化对象数据 blob 并使其可通过 HTTP API 访问的能力（称为对象存储）已成为现代技术领域不可或缺的一部分。
Minio是一款流行的开源对象存储服务器，与Amazon S3云存储服务兼容。已配置为与 Amazon S3 通信的应用程序也可以配置为与 Minio 通信，如果希望对对象存储服务器进行更多控制，则 Minio 可以成为 S3 的可行替代方案。该服务存储非结构化数据，例如照片、视频、日志文件、备份和容器/虚拟机映像，甚至可以提供单个对象存储服务器，该服务器可以池化分布在许多服务器上的多个驱动器。
Minio 用 Go 编写，附带命令行客户端和浏览器界面，并支持高级消息队列协议 (AMQP)、Elasticsearch、Redis、NATS和PostgreSQL目标的简单队列服务。学习设置 Minio 对象存储服务器可以为项目添加广泛的灵活性和实用性。
在教程主要说明：
在 Ubuntu 18.04 服务器上安装 Minio 服务器并将其配置为systemd服务。使用Let’s Encrypt设置 SSL/TLS 证书以保护服务器和客户端之间的通信。通过HTTPS访问Minio的浏览器界面来使用和管理服务器。 先决条件 要完成本教程，将需要：
一台 Ubuntu 18.04服务器，包括 sudo 非 root 用户和防火墙。完全注册的域名，或可访问的IP地址。 第 1 步 — 安装和配置 Minio 服务器 可以通过编译源代码或通过二进制文件来安装Minio服务器。要从源安装它，服务器系统上至少需要安装Go 1.12。
在此步骤中，通过预编译的二进制文件安装服务器，然后配置 Minio 服务器。
首先，登录服务器，替换sammy为用户名和your_server_ipUbuntu 18.04 服务器的 IP 地址：
ssh sammy@your_server_ip 更新软件包数据库：
sudo apt update 接下来，从官网下载Minio服务器的二进制文件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/095e02b49c525474c6bc2f00377577f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b03240af7ecf2a4ffc799a5e8f2eab21/" rel="bookmark">
			深度理解Flutter：有状态Widget与无状态Widget的详细对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有状态Widget 什么是有状态Widget (StatefulWidget) 官方解释： 如果用户与 widget 交互，widget 会发生变化，那么它就是 有状态的。
有状态的 widget 自身是可动态改变的（基于State）。 例如用户交互而改变 Widget 的 state。
Checkbox、Radio、Slider class - material library - Dart API、 InkWell、Form 和 TextField 都是有状态 widget，它们都是 StatefulWidget 的子类。
Widget 的 状态（state ）保存在一个 State 的对象中。 State和Widget 是分离的，当 Widget状态变化时，State 对象调用 setState() 来通知框架去重绘 Widget
如何创建一个有状态Widget 实现一个有状态Widget需要创建两个类：
一个 StatefulWidget 的子类，用来定义一个 widget 类。一个 State 的子类，包含该widget状态并定义该 widget 的 build() 方法。 我们可以通过 VSCode Flutter 命令补全来快速场景一个 有状态组件:
fstful import 'package:flutter/material.dart'; class FulStatePage extends StatefulWidget { const FulStatePage({super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b03240af7ecf2a4ffc799a5e8f2eab21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93f405684bdafc9f9ee7ab7643d9d2bc/" rel="bookmark">
			Sectigo怎么把多个网站地址改为https
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着电脑以及手机的普及，全世界的人都已经习惯在互联网提问、购物、浏览资讯等，越来越多的用户开始担心自己的信息(银行卡号、电话、支付密码等)被窃取以及篡改。SSL数字证书将http明文传输协议改为https加密传输协议，可以对网站传输信息加密，以此来保护用户上网安全，Sectigo是国际知名的CA认证机构，颁发了众多数字证书。今天就随SSL盾小编了解Sectigo怎么看将多个网站地址改为https。
第一步：获取SSL证书
Sectigo旗下的SSL证书的产品有很多，能够同时将多个网站地址改为https的SSL证书产品有通配符SSL证书和多域名SSL证书两种，但这两种SSL证书也有不同之处。多域名SSL证书默认包含3-5个域名网站，还可以付费添加至250个域名网站，通配符SSL证书默认包含主域名以及主域名下所有子域名。根据自己的需求选择Sectigo旗下的SSL证书。
第二步：安装SSL证书
生成CSR并提交，Sectigo旗下的DV数字证书验证域名所有权，OV数字证书验证域名所有权以及企事业单位的真实性，EV数字证书验证域名所有权以及企事业单位的真实性之后还需要企业提供第三方证明文件。一旦验证成功获得了SSL证书，就可以在网站服务器上安装。安装证书的具体步骤会因服务器类型的不同而有所差异。常见的服务器类型包括Apache、Nginx、IIS等。只要按照服务器类型和证书类型的指示进行安装就可以。
第三步：配置服务器
安装完SSL证书后，需要配置你的服务器以使用https协议来传输数据。这通常涉及到修改服务器的配置文件，以便将特定的域名或通配符域名与SSL证书关联起来。具体的配置步骤也会因服务器类型的不同而有所差异。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e754656bc120ad5866c4846efa0c35a1/" rel="bookmark">
			sqoop（DataX）-MySQL导入HIVE时间格问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 问题1：测试MySQL 数据信息HIVE数据信息hive中用 parquet（orc） 列式文件格式存储 解决方法问题2：解决方法 问题1： 用公司的大数据平台（DataX）导数，已经开发上线一个多月的一批报表，突然有同事说有个报表数据不准。出在时间字段上。
分析:
1、先看了原数据MySQL字段类型为datetime,目标字段为timestamp类型；
2、经发现所有时间的差距都是8小时，怀疑是因为时区转换的原因；
3、对比其他表，看看是大范围现象还是特殊情况，发现其他的同样情况字段的一样没有问题，也有改变为string字段类型的也没有问题；
测试 MySQL 数据信息 MySQL表名：test
MySQL字段类型如下：
field_nametypeidintnamevarcharcreat_day_timedatetimecreate_daydatecreate_timetimecreate_time_stamptimestamp -----测试数据如下 id name create_day_time create_day create_time create_time_stamp 1	xiaoming 2023-04-10 14:20:42 2023-04-10 14:20:42 2023-04-10 14:20:42 2 xiaohong 2023-04-21 14:21:02 2023-04-21 14:21:02 2023-04-21 14:21:02 HIVE数据信息 hive中用 text 文件格式存储
hive 表名：test_text
field_nametypeidintnamestringcreat_day_timestringcreate_daystringcreate_timestringcreate_time_stampstring -----hive 表中的数据： id name create_day_time create_day create_time create_time_stamp 1	xiaoming 2023-04-10 14:20:42 2023-04-10 14:20:42 2023-04-10 14:20:42 2 xiaohong 2023-04-21 14:21:02 2023-04-21 14:21:02 2023-04-21 14:21:02 与mysql表里面数据一致；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e754656bc120ad5866c4846efa0c35a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6229d9ccee78018dc2b20fbbdc8954f1/" rel="bookmark">
			深入了解隧道代理HTTP的协议与技术细节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		隧道代理HTTP，作为一种网络通信的桥梁技术，其背后的协议与技术细节承载着网络世界的无尽奥秘。对于技术人员而言，深入了解这些细节，不仅有助于优化网络性能，还能为网络安全提供坚实的保障。
一、隧道代理HTTP的协议基础
隧道代理HTTP主要基于HTTP协议进行通信。HTTP协议，即超文本传输协议，是互联网上应用最为广泛的一种网络协议。它定义了客户端与服务器之间的请求-响应模式，使得网页浏览、文件下载等网络活动得以顺利进行。
在隧道代理HTTP中，客户端首先通过HTTP协议与代理服务器建立连接，然后将请求数据封装在HTTP请求中发送给代理服务器。代理服务器接收到请求后，解析出真实的目标服务器地址，再通过自身的网络连接将请求转发给目标服务器。目标服务器处理完请求后，将响应数据返回给代理服务器，代理服务器再将其转发给客户端。
二、隧道代理HTTP的技术细节
连接管理：隧道代理HTTP需要管理客户端与代理服务器、代理服务器与目标服务器之间的连接。这包括连接的建立、保持和关闭等操作。为了提高性能，隧道代理HTTP通常会采用长连接技术，即在一次TCP连接中传输多个HTTP请求和响应。数据加密与解密：为了保障数据安全，隧道代理HTTP在传输过程中可能会对数据进行加密。常见的加密方式有SSL/TLS等。加密后的数据在传输过程中即使被截获，也难以被破解，从而保护了用户的隐私和数据安全。负载均衡：当有多个代理服务器可用时，隧道代理HTTP可以通过负载均衡技术将请求分发给不同的代理服务器处理，以提高整体的处理能力和容错性。协议转换：在某些情况下，客户端和目标服务器可能使用不同的协议进行通信。此时，隧道代理HTTP需要承担协议转换的任务，将客户端的请求转换为目标服务器能理解的格式，并将目标服务器的响应转换回客户端能理解的格式。 总之，隧道代理HTTP的协议与技术细节是构建稳定、高效、安全网络环境的重要基石。只有深入了解这些细节，才能更好地应用和优化隧道代理HTTP技术，为互联网的发展贡献力量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab401faae052390d2371701fb329861e/" rel="bookmark">
			python 深度学习 记录遇到的报错问题11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇继python 深度学习 记录遇到的报错问题10-CSDN博客
六、ValueError: cannot convert float NaN to integer 报错：
原因：这个错误通常是因为在尝试将NaN值转换为整数时发生的。NaN表示“非数字”，它无法转换为整数。在 Python 中，NaN 表示 Not a Number，表示数据集中缺失的条目。 它是一种特殊的 float 值，不能转换为 float 以外的其他类型。
解决方法：先检查代码是否有不合理的地方，如果代码没有逻辑错误。
（1）然后检查输入数据，确保没有NaN值。例如，使用Pandas DataFrame时，可以使用.isna()方法检查数据中是否有NaN值。
（2）在转换之前检查数据类型，确保它们是可以转换为整数的数据类型。例如，在Python中，可以使用内置的isinstance()函数来检查数据类型。
（3）也可以使用 fillna() 方法修复python错误 ValueError: cannot convert float NaN to integer
fillna() 方法用 Python 中的给定值替换 NaN 值， 它检查列中的 NaN 值并用指定值填充它们。
df_new = df.fillna(0) print(df_new) （4）更新matplotlib_venn包，
pip install --upgrade matplotlib_venn 七、AttributeError: module 'tensorflow' has no attribute 'reset_default_graph' 报错：
原因：这个错误是因为在TensorFlow 2.0及更高版本中，reset_default_graph函数已经被移除了。在TensorFlow 1.x版本中，reset_default_graph函数用于清除默认图形堆栈并重置全局默认图形。但在TensorFlow 2.0及更高版本中，由于引入了急切执行（Eager Execution）模式，不再需要使用此函数。
解决方法：如果你需要在TensorFlow 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab401faae052390d2371701fb329861e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bc5da901986e5ab872ed39d28cee2ff/" rel="bookmark">
			Flutter基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、关键字 class：用于定义一个新的类；
extends: 用于指定一个类继承另一个类；
mixin: 用于将一个类的代码片段添加到另一个类中，实现代码复用；
abstract: 用于声明一个抽象类或抽象方法，不能直接实例化；
implements: 用于实现一个接口，并继承接口中定义的方法和属性；
super: 用于在子类中调用父类的方法或属性；
const: 用于声明一个不可变的变量或对象；
null: 表示空值或不存在的值；
final: 用于声明一个常量或不可被重写的属性或方法；
abstract class: 声明一个抽象类，不能直接实例化，但可以作为其他类的基类；
interface: 声明一个接口，定义一组方法，但不带实现。
二、修饰符 const: 用于修饰变量或对象，表示该变量或对象是编译时常量，即其值在编译时是已知的，并且不会被改变；
final: 用于修饰变量或方法，表示该变量或方法不能被重写或修改；
late: 用于修饰变量，表示该变量是延迟初始化的，即在第一次使用之前不会进行初始化；
override: 用于修饰方法，表示该方法重写了父类中的方法；
external: 用于修饰方法或类，表示该方法或类的实现由其他代码库提供，不能被Flutter代码访问；
null: 用于修饰参数，表示该参数可以为null；
required: 用于修饰参数，表示该参数是必需的，调用函数时必须提供该参数。
三、可选参数 命名可选参数：通过在参数名称前面加上大括号“{}”来定义，在函数调用时，可以选择性地传入一个或多个参数；
位置可选参数：通过在参数名称前面加上中括号“[]”来定义，在函数调用时，必须按照从左到右的顺序传入参数，可以选择性地跳过某些参数；
可选参数必须是函数定义中最后一个参数，因为在Flutter中不支持链式调用语法；
如果函数定义中既有命名可选参数又有位置可选参数，那么位置可选参数必须放在命名可选参数之前。
四、异步编程 通常可以使用Future、async/await和Streams（数据流）。
五、路由 Route：在Flutter中，Route表示一个屏幕或页面的抽象；
当你想在应用中导航到一个新的页面时，你实际上是创建了一个新的Route并将其推送到Navigator中；
Navigator：Navigator是一个负责管理Route的Widget；
它内部维护了一个路由栈，这个栈结构允许用户在不同的页面之间进行切换；
当你调用Navigator的push方法时，一个新的Route会被添加到栈顶，表示当前显示的页面；相应地，当你调用pop方法时，栈顶的Route会被移除，显示前一个页面。
六、Channel 通常，在原生与Flutter进行混编时，两端可以通过监听Channel接收传递来的消息，通过invokeMethod或sendEvent等方法来发送消息，这叫做Platform Channels机制；
Channel共有三类，分别是BasicMessageChannel（传递字符串和半结构化信息）、MethodChannel（方法调用）和EventChannel（数据流通信）；
Channel有三个重要的成员变量，分别是String类型的name，代表Channel的唯一标识符；
BinaryMessenger类型的messager，代表消息的发送与接收工具，使用二进制格式的数据进行通信，BinaryMessenger会根据Channel的名称找到对应的Handler，并将消息交由其处理；
MessageCodec类型或MethodCodec类型的Codec，代表消息的编解码器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6befc92319fc98525272fac51b55a555/" rel="bookmark">
			hive多分隔符外表支持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在hive 外表关联文本的时候 有时会遇到不是一个长度的分割符比如"~@" 这种。这个时候使用shell命令多处理一步处理成单分隔符也可以，但是会有出错的风险。我们可以通过hive中指定的序列类来完成多分隔符的识别。
CREATE EXTERNAL TABLE text_mid1( id STRING ,name STRING ) ROW FORMAT SERDE 'org.apache.hadoop.hive.contrib.serde2.MultiDelimitSerDe' WITH SERDEPROPERTIES('input.delimited'='~@' ) -- 指定分隔符s LOCATION '/tmp/multidelimit_txt' ; 需要在 SERDE中指定 ‘org.apache.hadoop.hive.contrib.serde2.MultiDelimitSerDe 类
然后在WITH SERDEPROPERTIES 指定’input.delimited’=‘@’
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46c7ac8d9c48ca5468bd049644f94ed5/" rel="bookmark">
			记事本在手机桌面上怎么找？手机里的记事本怎么找？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常生活、工作和学习中，我们时常需要随手记录一些重要的事项、灵感闪现的瞬间或者是待办的任务。比如，在超市购物前，列出购物清单；在开会时，记下重要的讨论点；在学习时，捕捉那一刹那的灵感。这时候在手机上使用一款记事本软件就是非常便捷的，但是很多人不知道手机里的记事本在哪里找？记事本在手机桌面上怎么找？
其实，大多数手机系统中都会自带记事类软件，例如笔记、便签、备忘录等，这些应用通常可以在手机桌面的“实用工具”文件夹中找到。但是，如果你想要一款不仅功能强大，而且颜值高的手机桌面记事本，那么敬业签也是不错的选择。
这款记事本软件拥有强大的记事功能。我们可以创建多个不同的便签分类来记录各种事项，无论是工作、学习还是生活，都能轻松应对。同时，每条便签中不仅支持添加文字，还可以上传多张图片、视频、音频、文档等多种格式的内容，让记事更加丰富多彩。另外，每条便签中还支持实时统计字数、修改字体颜色、录音转文字、提取图片中的文字等高级功能，满足大家更多的记事需求。
更为独特的是，这款记事本工具适用于安卓、苹果、鸿蒙等多个手机系统，并且都支持以添加窗口小工具或桌面小组件的形式，将便签和待办中的记事、提醒内容直接展示在手机桌面上。这样一来，你我们无需打开这款记事本软件，就能随时在手机桌面上查看记事内容，不仅实用而且美观。
如果你正在寻找一款功能强大、操作便捷且颜值高的手机记事本软件，敬业签将帮助你更好地管理生活、工作和学习中的各项事务，让你的记事体验更加轻松、有趣且高效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f73f6c6f090adcf984ad6f17d8fe172d/" rel="bookmark">
			【Java EE初阶六】多线程案例（单例模式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 单例模式 单例模式是一种设计模式，设计模式是我们必须要掌握的一个技能；
1.1 关于框架和设计模式 设计模式是软性的规定，且框架是硬性的规定，这些都是技术大佬已经设计好的；
一般来说设计模式有很多种，且不同的语言会有不同的设计模式，（同时设计模式也可以理解为对编程语言的一种补充）
1.2 细说单例模式 单例 = 单个实例（对象）；
某个类，在一个线程中，只应该创建一个实例化对象（原则上不应该有多个），这时就使用单例模式，如此可以对我们的代码进行一个更严格的校验和检查。
保证对象唯一性的方法：
方法一，可以通过“协议约束”，写一个文档，规定这个类只能有唯一的实例，程序员在接手这个代码时，就会发现这个文档已经进行约定，其中的规定约束着程序员在创建对象时，时刻注意只能创建一个对象。
方法二：从机器入手；让机器帮我们检查，我们期望让机器帮我们对代码中指定的类，创建类的实例个数进行检查、校验，当创建的实例个数超过我们期望个数，就编译报错。其中单例模式就是已经设计好的套路，可以实现这种预期效果。
关于单例模式代码实现的基本方式有两种：饿汉模式和懒汉模式；
2. 饿汉模式 饿汉模式是指创建实例的时期非常早；在类加载的时候，程序一启动，就已经创建好实例了，使用 “饿汉”这个词，就是形容创建实例非常迫切，非常早。单例模式代码如下：
class Singleton { private static Singleton instance = new Singleton(); public static Singleton getInstance() { return instance; } private Singleton(){ } } public class TestDemo4 { public static void main(String[] args) { Singleton singleton = new Singleton(); } } 当我们运行该代码时，系统就会报错，接下来我们详细的分析一下此处的代码； 这样，如果我们想new一个Singleton对象，也new不了，同时不管我们用getInstance获取多少次实例，获取的对象都是同一个对象，代码如下：
package thread; // 就期望这个类只能有唯一的实例 (一个进程中) class Singleton { private static Singleton instance = new Singleton(); public static Singleton getInstance() { return instance; } private Singleton() {} } public class ThreadDemo26 { public static void main(String[] args) { // Singleton s = new Singleton(); Singleton s = Singleton.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f73f6c6f090adcf984ad6f17d8fe172d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/349449d84680f37247dd4615fd76212a/" rel="bookmark">
			Flutter 混合开发 - 动态下发 libflutter.so &amp; libapp.so
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 最近在做包体积优化，在完成代码混淆、压缩，裁剪ndk支持架构，以及资源压缩（如图片转webp、mp3压缩等）后发现安装包的中占比较大的仍是 so 动态库依赖。
具体查看发现 libflutter.so 和 libapp.so 的体积是最大的，这两个动态库都是 flutter 集成进来的。结合项目中 Flutter 的应用，Flutter 页面都是作为二级页面使用，而且页面使用频率很低，所以是不是可以把这两个 so 从 apk 中剔除，在应用启动后再动态下发呢？
如果可以实现，那么包体积又可以缩减 13.8 M，包体积在原基础上立减一半，收益非常可观！开搞！
实战 libflutter.so &amp; libapp.so 如何引入项目的？ 项目是以远程依赖方式引入 flutter，即 flutter 开发完成后打包 aar 发布到公司 maven。通过解压已打包的 aar 发现，aar 中仅有 libapp.so，并没有 libflutter.so。而唯一提到 libflutter.so 的只有打包时生成的 pom 文件。
那么就从宿主项目入手。要远程依赖 flutter，需要指定 repositories{} 。通过配置发现，除了公司 maven 仓库地址，还需要额外配置一个 "https://storage.flutter-io.cn/download.flutter.io"，结合打包时生成的 pom 文件，可以猜测 libflutter.so 是在依赖解析过程中引入到项目中的。
allprojects { repositories { google() mavenCentral() //flutter 需要的仓库配置： maven { url '******' //公司 maven 仓库地址 } maven { url 'https://storage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/349449d84680f37247dd4615fd76212a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ff90be9337059d96e78f89aac5eb56f/" rel="bookmark">
			编程笔记 html5&amp;css&amp;js 019 HTML实体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程笔记 html5&amp;css&amp;js 019 HTML实体 一、HTML 字符实体二、HTML 符号实体小结 在HTML文档中，用一些标记表示特定的格式，那我们想使用这些标记字符本身时就出了问题，直接使用时，会被浏览器解析为标记的，要想显示这些字符本身，要使用“实体”，在其他语言中，一般称为转义字符。 一、HTML 字符实体 HTML 中的预留字符必须被替换为字符实体。
在 HTML 中，某些字符是预留的。
在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。
如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。
字符实体类似这样：
&amp;entity_name;
或者
&amp;#entity_number;
如需显示小于号，我们必须这样写：&amp;lt; 或 &amp;#60;
提示：使用实体名而不是数字的好处是，名称易于记忆。不过坏处是，浏览器也许并不支持所有实体名称（对实体数字的支持却很好）。
不间断空格（non-breaking space）
HTML 中的常用字符实体是不间断空格(&amp;nbsp;)。
浏览器总是会截短 HTML 页面中的空格。如果您在文本中写 10 个空格，在显示该页面之前，浏览器会删除它们中的 9 个。如需在页面中增加空格的数量，您需要使用 &amp;nbsp; 字符实体。
HTML 中有用的字符实体
注释：实体名称对大小写敏感！
显示结果 描述 实体名称 实体编号
空格	&amp;nbsp;	&amp;#160; &lt;	小于号	&amp;lt;	&amp;#60; &gt;	大于号	&amp;gt;	&amp;#62; &amp;	和号	&amp;amp;	&amp;#38; "	引号	&amp;quot;	&amp;#34; '	撇号 &amp;apos; (IE不支持)	&amp;#39; ￠	分（cent）	&amp;cent;	&amp;#162; £	镑（pound）	&amp;pound;	&amp;#163; ¥	元（yen）	&amp;yen;	&amp;#165; €	欧元（euro）	&amp;euro;	&amp;#8364; §	小节	&amp;sect;	&amp;#167; ©	版权（copyright）	&amp;copy;	&amp;#169; ®	注册商标	&amp;reg;	&amp;#174; ™	商标	&amp;trade;	&amp;#8482; ×	乘号	&amp;times;	&amp;#215; ÷	除号	&amp;divide;	&amp;#247; 键盘上不存在的字符也可以由实体代替。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ff90be9337059d96e78f89aac5eb56f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ba8f083c2d30e02b9b22a75b0228918/" rel="bookmark">
			总结2023，展望2024
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年是一个充满挑战和机遇的一年。全球范围内，人们继续努力应对新冠疫情的影响，各行各业都面临着巨大的变革和调整。在这个动荡的环境下，技术行业也经历了许多重要的发展和变革。
首先，人工智能在2023年取得了巨大的突破和应用。在各个领域，人们开始充分利用人工智能技术来解决实际问题，提高效率和创造价值。从自动驾驶汽车到智能助理，从智能城市到医疗诊断，人工智能正逐渐渗透到我们生活的方方面面。同时，人们也更加重视人工智能伦理和安全的问题，对于人工智能的发展和应用提出了更高的要求。
其次，区块链技术在2023年得到了广泛的认可和应用。随着数字货币的兴起和区块链技术的成熟，越来越多的企业和组织开始探索和应用区块链技术，改变传统的商业模式和交易方式。区块链不仅能够提供更高效、安全和透明的交易方式，还可以为供应链管理、版权保护等领域带来创新和变革。
另外，网络安全成为了2023年的重要议题。随着数字化的深入和网络攻击的增加，保护网络安全成为了各个领域的首要任务。企业和组织纷纷加强网络安全的投入和建设，提高网络防御和应急响应能力。同时，法规和政策也在不断完善，加强网络安全的监管和保护，维护公民和企业的合法权益。
展望2024年，我相信技术行业将继续迎来新的发展和挑战。随着人工智能、区块链、物联网等技术的不断成熟和普及，我们将看到更多创新和应用的出现。同时，随着数字化的深入和数据的爆炸式增长，数据科学和数据隐私保护也将成为重要的议题。
此外，随着全球经济的复苏和科技产业的持续发展，我们可以预见到更多创新企业和初创公司的涌现。在这个竞争激烈的环境下，不断学习和提升自己的技术能力将变得更加重要。同时，跨学科的合作和协同也将成为趋势，技术人才需要具备广泛的知识和能力来应对不断变化的挑战。
总而言之，2023年是一个充满变革和发展的一年，而2024年将继续延续这个趋势。作为技术人员，我们应该不断学习和适应，把握机遇，迎接挑战，为技术行业的发展和进步做出贡献。
让我们一起告别2023，迎接2024的到来吧！就让那些昨日的辉煌成为我们美好的回忆，为了让未来有更多美好的回忆一起奋斗吧！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7c29da86c20e986335848943920e971/" rel="bookmark">
			一文掌握Python3 基础语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、编码 默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码：
# -*- coding: cp-1252 -*- 上述定义允许在源文件中使用 Windows-1252 字符集中的字符编码，对应适合语言为保加利亚语、白俄罗斯语、马其顿语、俄语、塞尔维亚语。
二、标识符 第一个字符必须是字母表中字母或下划线 _ 。标识符的其他的部分由字母、数字和下划线组成。标识符对大小写敏感。 在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。
三、python保留字 保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：
&gt;&gt;&gt; import keyword &gt;&gt;&gt; keyword.kwlist ['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 四、注释 Python中单行注释以 # 开头，实例如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7c29da86c20e986335848943920e971/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a46c89ca02a7b9594ca97328a14085d3/" rel="bookmark">
			华为Could API人工智能系列——事件抽取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为Could API人工智能系列——事件抽取 前言 云原生时代，开发者们的编程方式、编程习惯都发生了天翻地覆的变化，大家逐渐地习惯在云端构建自己的应用。作为新一代的开发者们，如何更快速了解云，学习云，使用云，更便捷、更智能的开发代码，从而提升我们的开发效率，是当前最热门的话题之一，而Huawei Cloud Toolkit,作为连接华为云的百宝箱，是集成在各大IDE平台上的插件集合，会在方方面面提升着开发者的效率。
华为云API开发套件助力开发者快速集成华为云，可做到便捷连接200+的华为云服务，引用7000+的华为云API服务，在IDE中集成华为云的功能，让开发者与云端华为云建立连接。
智能编码方面集成了华为云自主研发的代码大模型和软件分析技术，全场景函数级、行级代码生成，同规模算力一次通过业界第一，这会帮助开发者更为高效的使用自动语义生成，达到快速开发的目的，使整个过程更智能。
环境准备 开发语言：Python
开发工具：PyCharm Community Edition 2023.1.4
PyCharm插件：
1、Chinese (Simplified) Language Pack /中文语言包
2、Huawei Cloud API：华为云API插件提供华为云服务全量API检索、调试、SDK代码自动补全、集成华为云CLI、示例代码等功能
3、Huawei Cloud CodeArts Check：华为云代码检查插件提供业界规范（含华为云）检查，支持一键格式化和代码自动修复，当前支持Java、C++、C，这个使您使用的环境操作即可，我这里用的python没有提示。
4、Huawei Cloud CodeArts Snap：华为云 CodeArt Snap 智能编程助手致力于打造现代化开发新范式，通过将自然语言转化为规范可阅读、无开源漏洞的编程语言，提升开发者编码效率，助力企业快速响应市场不确定性；
5、Huawei Cloud Toolkit Platform：华为云底座插件为华为云各类云服务插件提供公共能力，比如单点登录、UI集成、API访问等功能；
PyCharm环境的搭建：https://laoshifu.blog.csdn.net/article/details/135279145
API接口开通地址：https://console.huaweicloud.com/nlp/#/nlp/overview 事件抽取 事件抽取是指从自然语言文本中抽取指定类型的事件以及相关实体信息,并形成结构化数据输出的文本处理技术。 目前只支持金融公告中会议召开、聘任、辞职、股票增持、股票减持5类事件以及相关要素的抽取。
开通地址：https://console.huaweicloud.com/nlp/#/nlp/overview
开通完毕：
请求参数 名称类型IN必选描述X-Auth-Tokenstringheadertrue 用户Token。 通过调用IAM服务获取用户Token接口获取(响应消息头中X-Subject-Token的值)。
project_idstringpathtrue 来自公有云的Project ID,用于资源隔离。
Body 参数 名称类型必选描述textstringtrue 待分析文本,长度为1~256,文本编码为UTF-8。
返回参数 名称类型必选描述rolestringtrue 元素角色。元素角色指的是事件元素在事件中扮演的角色,是事件元素与事件的语义关系。
spanArray of integerstrue 实体文本在待分析文本中的起始和终止位置。
wordstringtrue 实体文本。
API调试 测试文本：【亲爱的博客群小伙伴们， 新年快乐！我是红目香薰，在这个充满希望与梦想的新年之际，我想对你们说一声：谢谢你们一直以来的陪伴和支持。 愿新的一年里，我们都能在生活的每一个角落里，找到属于自己的幸福与快乐。愿我们的友情如同这新年的烟火，照亮我们的生活，温暖我们的心灵。 愿新的一年里，你们每一个梦想都能实现，每一个努力都能得到回报。愿我们都能拥有一个美好的未来，一个充满爱与和平的世界。 再次感谢你们的陪伴，愿新年的钟声带给我们新的开始，新的希望，新的力量。让我们一起，迎接新的一年，迎接新的挑战，迎接新的机遇！ 】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a46c89ca02a7b9594ca97328a14085d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a010d1bd7285fdec549b62a0d3f8cb2/" rel="bookmark">
			华为Could API人工智能系列——实体链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为Could API人工智能系列——实体链接 前言 云原生时代，开发者们的编程方式、编程习惯都发生了天翻地覆的变化，大家逐渐地习惯在云端构建自己的应用。作为新一代的开发者们，如何更快速了解云，学习云，使用云，更便捷、更智能的开发代码，从而提升我们的开发效率，是当前最热门的话题之一，而Huawei Cloud Toolkit,作为连接华为云的百宝箱，是集成在各大IDE平台上的插件集合，会在方方面面提升着开发者的效率。
华为云API开发套件助力开发者快速集成华为云，可做到便捷连接200+的华为云服务，引用7000+的华为云API服务，在IDE中集成华为云的功能，让开发者与云端华为云建立连接。
智能编码方面集成了华为云自主研发的代码大模型和软件分析技术，全场景函数级、行级代码生成，同规模算力一次通过业界第一，这会帮助开发者更为高效的使用自动语义生成，达到快速开发的目的，使整个过程更智能。
环境准备 开发语言：Python
开发工具：PyCharm Community Edition 2023.1.4
PyCharm插件：
1、Chinese (Simplified) Language Pack /中文语言包
2、Huawei Cloud API：华为云API插件提供华为云服务全量API检索、调试、SDK代码自动补全、集成华为云CLI、示例代码等功能
3、Huawei Cloud CodeArts Check：华为云代码检查插件提供业界规范（含华为云）检查，支持一键格式化和代码自动修复，当前支持Java、C++、C，这个使您使用的环境操作即可，我这里用的python没有提示。
4、Huawei Cloud CodeArts Snap：华为云 CodeArt Snap 智能编程助手致力于打造现代化开发新范式，通过将自然语言转化为规范可阅读、无开源漏洞的编程语言，提升开发者编码效率，助力企业快速响应市场不确定性；
5、Huawei Cloud Toolkit Platform：华为云底座插件为华为云各类云服务插件提供公共能力，比如单点登录、UI集成、API访问等功能；
PyCharm环境的搭建：https://laoshifu.blog.csdn.net/article/details/135279145
API接口开通地址：https://console.huaweicloud.com/nlp/#/nlp/overview 实体链接 针对通用领域的文本进行实体链接分析,识别出其中的实体,并返回实体相关信息。 开通地址：https://console.huaweicloud.com/nlp/#/nlp/overview
开通效果：
请求参数 名称类型IN必选描述X-Auth-Tokenstringheadertrue 用户Token。 通过调用IAM服务获取用户Token接口获取(响应消息头中X-Subject-Token的值)。
project_idstringpathtrue 来自公有云的Project ID,用于资源隔离。
Body 参数 名称类型必选描述textstringtrue 待分析文本,长度为1~50,文本编码为UTF-8。
langstringfalse 支持的文本语言类型,目前只支持中文,默认为zh。
返回参数 名称类型必选描述mentionstringtrue 实体指称
offsetintegertrue 偏移量
entity_titlestringtrue 实体名称
API调试 测试文本：【周杰伦拿着他的双节棍，打着他的龙拳，向着七里香怀着不能说的秘密过去了。】
返回结果：
{ "entities": [ { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a010d1bd7285fdec549b62a0d3f8cb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be9b4c5724003fbfdb15132cca358011/" rel="bookmark">
			nginx,ssl,证书和校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是 HTTPS# 要保证 Web 浏览器到服务器的安全连接，HTTPS 几乎是唯一选择。HTTPS 其实就是 HTTP over SSL，也就是让 HTTP 连接建立在 SSL 安全连接之上。SSL 使用证书来创建安全连接，有两种验证模式:
仅客户端验证服务器的证书，客户端自己不提供证书；
客户端和服务器都互相验证对方的证书。
普通的 Web 网站只采用第一种方式，第二种方式用于网上银行等安全性要求较高的网站。
在第二种方式中，客户端采用这种方式验证证书：服务器自己的证书必须经过某“权威”证书的签名，而这个“权威”证书又可能经过更权威的证书签名，这么一级一级追溯上去，最顶层那个最权威的证书就称为根证书。根证书直接内置在浏览器中，这样，浏览器就可以利用自己自带的根证书去验证某个服务器的证书是否有效。如果要提供一个有效的证书，服务器的证书必须从VeriSign这样的证书颁发机构签名。这样，浏览器就可以验证通过，否则，浏览器给出一个证书无效的警告。一般安全要求较高的内网环境，可以通过创建自签名 SSL 证书来加密通信。
2. 什么是数字证书# 在 HTTPS 的传输过程中，有一个非常关键的角色--数字证书，那什么是数字证书？它有什么作用呢？
所谓数字证书，是一种用于电脑的身份识别机制。由数字证书颁发机构(CA)对使用私钥创建的签名请求文件做的签名(盖章)，表示 CA 结构对证书持有者的认可。
2.1. 优点# 数字证书拥有以下几个优点:
使用数字证书能够提高用户的可信度；数字证书中的公钥，能够与服务端的私钥配对使用，实现数据传输过程中的加密和解密；在证认使用者身份期间，使用者的敏感个人数据并不会被传输至证书持有者的网络系统上。 2.2. 数字证书类型# x509 的证书编码格式有两种:
PEM(Privacy-enhanced Electronic Mail)是明文格式的，以 -----BEGIN CERTIFICATE-----开头，以-----END CERTIFICATE-----结尾。中间是经过 base64 编码的内容，apache 需要的证书就是这类编码的证书.查看这类证书的信息的命令为：openssl x509 -noout -text -in server.pem。
DER 是二进制格式的证书，查看这类证书的信息的命令为: openssl x509 -noout -text -inform der -in server.der
2.3. 扩展名# .crt 证书文件,可以是 DER(二进制)编码的，也可以是 PEM(ASCII (Base64))编码的),在类 unix 系统中比较常见；.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be9b4c5724003fbfdb15132cca358011/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3898226ef0c7cdca0177f984f7fb51d/" rel="bookmark">
			Ef Core花里胡哨系列(4) 多租户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ef Core花里胡哨系列(4) 多租户 当然，我们要考虑设计问题，例如，切换Schema或者改变数据库时，Ef Core同样也会刷新改实体的缓存，所以，首次查询将会很慢，不适合大表。
基于Schema实现多租户 在我的上一篇博客中 [Ef Core花里胡哨系列(3) 动态修改实体对应的表(分表)、多租户] 中我们实现了如何分表，同理，我们可以用近似的方法来切换表的Schema，只需要一点很小的改动。
public class SampleDbContext(DbContextOptions&lt;SampleDbContext&gt; options) : DbContext(options) { protected override void OnModelCreating(ModelBuilder modelBuilder) { modelBuilder.Entity&lt;User&gt;().ToTable($"User{DateTime.Now.ToString("yyyyMM")}", YourSchema); base.OnModelCreating(modelBuilder); } } 基于多库实现多租户 实现切换数据库我们将会采用的是Interceptor拦截器来实现。
建议租户相关的操作采用单独的DbContext和系统表区分开。
public class TenantDbConnectionInterceptor&lt;T&gt; : DbConnectionInterceptor { public TenantDbConnectionInterceptor() { } public override InterceptionResult ConnectionOpening(DbConnection connection, ConnectionEventData eventData, InterceptionResult result) { connection.ConnectionString = "对应租户的连接字符串"; return base.ConnectionOpening(connection, eventData, result); } public override ValueTask&lt;InterceptionResult&gt; ConnectionOpeningAsync(DbConnection connection, ConnectionEventData eventData, InterceptionResult result, CancellationToken cancellationToken = default) { connection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3898226ef0c7cdca0177f984f7fb51d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b45f5a843d4f6983cd6726d85b4ec24/" rel="bookmark">
			服务器的固件和OS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器的固件和OS
服务器的固件主要包括BIOS或UEFI、BMC、CMOS，OS包括32位和64位。
1）BIOS
（Basic input/ Output System）
即基本输入输出系统，是服务器启动后最先运行的软件。它包括基本输入输出控制程序、上电自检程序、系统启动自检程序、系统设置信息。BIOS是服务器硬件和OS之间的抽象层，用来设置硬件，为OS运行做准备。BIOS设置程序是储存在BIOS芯片中的。BIOS的进化版本是UEFI（Unified Extensible FirmwareInterface），即统一的可扩展固定接口。这种接口用于操作系统自动从预启动的操作环境，加载到一种操作系统上，从而使开机程序化繁为简，节省时间。
2）BMC
（Baseboard Management Montroller）
即基板管理控制器，主要是对服务器进行监控和管理。BMC可以在服务器未开机的状态下，对机器进行固件升级、查看机器设备等。
3）CMOS
（Complementary metal-oxide-semiconductor）
是电脑主机板上一块特殊的RAM芯片，是系统参数存放的地方。CMOS存储器用来存储BIOS设定后的相关参数。
4）OS
（Operating system）
即操作系统，对服务器软硬件及数据资源进行管理调度。OS主要分为32位和64位，OS的位数版本决定了计算机处理器在RAM（随机存取储存器）处理信息的效率，64位版本比32位的可以处理更多的内存和应用程序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60b718e67cffd272819e03770003ee02/" rel="bookmark">
			[linux c/c&#43;&#43;] 字符串分割函数 sscanf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考： sscanf函数详细介绍及使用方法解析-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d3a2941311b4ddf3ed5c1b1628fc889/" rel="bookmark">
			AI加持，openEuler打造数字基础设施全场景操作系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大模型的东风席卷全球，一些行业已开始基于大模型重构。在数智未来的世界里，AI无疑将扮演重要角色。通过与不同基础技术及产品的结合，AI将促进各领域技术的持续创新，作为核心基础软件的操作系统也不例外。“崛起数字时代，引领数智未来。”在操作系统大会 &amp; openEuler Summit 2023 上，我们发现面向数智未来，openEuler 已提前进行布局。
一直以来，openEuler聚焦根技术的投入，为千行百业构建坚实的软件根基。目前openEuler系累计装机量已超过610万套，成为首个改变软件操作系统格局的开源操作系统。据IDC预测，2023年openEuler系在中国服务器操作系统市场份额第一，达到 36.8%。面向数智未来，openEuler与AI全面结合，打造面向数字基础设施全场景操作系统，为更多用户提供技术便捷。
01
面向智能新时代
openEuler使能AI更高效
在过去的四年里，openEuler社区快速发展。据开放原子开源基金会TOC副主席、openEuler委员会执行总监熊伟回顾，openEuler 社区建立之初，每天活跃的开发者仅两三百人，但如今已汇聚16800+名开源贡献者，日活用户超4259人。开发者在系统特性、创新及漏洞修复方面提供了大量的帮助。此外，openEuler社区积累超过1300+的企业和合作伙伴。
开放原子开源基金会TOC副主席、openEuler委员会执行总监熊伟
当诸多的用户和合作伙伴加入openEuler社区，那么未来的openEuler将会走向何方呢？在过去，openEuler有两个技术支柱，全场景和多样性算力。伴随大模型等新技术的不断发展，openEuler 增加第三个技术支柱——智能化，数字openEuler将逐步演化为智慧openEuler，成长为面向多样性算力和智能时代的下一代OS。
智能的边界在持续拓展，作为连接硬件和应用之间的桥梁，操作系统拥抱数智未来，与AI结合是一种必然趋势。
openEuler技术委员会主席胡欣蔚表示，在当前硬件趋势下，有越来越多智能的多样性算力需要做高效协同，也有越来越多泛在智能应用需要快速介入。为了实现这样的愿景，openEuler希望做到0门槛、0损耗和0介入的效果。对于普通用户部署和安装智能应用，帮助用户做到“0”门槛；对于智能应用在多样性算力上运行，操作系统让智能算力“0”损耗；在智能应用日常运维过程中，系统管理员对系统日常工作“0”介入。
因此，openEuler通过“openEuler for AI”和“AI for openEuler”两点，实现AI全栈使能，打造容器化的、开箱即得即用的方案。
“openEuler for AI”是一种对于生态边界的拓展，未来openEuler全面增强对于AI的契合度，支持更多主流的智能应用和语言大模型，实现智能能力升级。AI的生态构建并不容易，当下我们可以看到一些 AI 产品、技术生态、基础设施等各自为战，但随着市场的逐渐成熟，AI全栈使能是未来发展的一种必然结果。
全栈使能将让openEuler的用户在未来使用智能应用时，通过openEuler提供的容器化方案开箱即用，同时也可以自动适配硬件环境，达到性能最优。openEuler的全栈使能还包括两层含义。首先是对各类应用、模型、工具、框架的支持优化，如AquilaDB等向量数据库，Llama、ChatGLM等业内流行的大模型，cuda、rocm、openvino等工具链，以及PyTorch、TensorFlow等AI框架。此外，由于AI硬件的复杂性，openEuler也针对AI硬件亲和等提供了广泛支持，一系列的升级将会极大地提升用户的AI开发使用效率。
其次是对于开发者的支持，openEuler在AI可用性、适配性方面不断优化，并对训练及推理推环境的容器化封装、镜像一键拉取等进行了升级，为开发者提供了即得即用的能力，实现AI环境部署的“0”门槛。
当前，我们进入多样性算力的时代，软硬件的共同发展给操作系统调度重新设计的空间。通过 CPU 的SMT架构，给操作系统预先部署任务的机会，而GPU也可通过硬件warp切换来避免暂停等问题。因此，如何将独立的异构设备汇聚在一起，统一调配资源，解决算力浪费和异构内存编程的复杂性是个重要课题。
在传统意义上，不同的异构算力对于内存的管理是完全割裂的，相互之间也很难形成共享。而“openEuler for AI”的另一个重要价值就是异构融合，其核心思路是将独立的异构设备汇聚在一起，统一调配资源，解决算力浪费严重和异构内存编程复杂两个问题。通过在openEuler中引入的异构内核管理，可以在CPU和NPU通过共享页表的方式实现统一编址，使得双方可以互用内存，达成内存“透明”扩容、超分，这样可以提升推理场景吞吐量提升50%，并极大的简化内存管理的需求成本，以往多套内存接口简化为一套，异构驱动代码也能从万行下降到百行。
02
大模型与OS协同成趋势
AI 赋能openEuler更智能
从今年的技术发展来看，大模型让更多人看到操作系统新的可能。举例来看，2023年，微软宣布将GPT-4大模型嵌入到Windows里，实现操作系统从图形交互升级到自然语言交互，这将有望改变沿用近三十年的系统交互方式。Windows Copilot 将登陆 Windows 11 中的任务栏，帮助用户更加轻松的查找和变更设置，避免繁琐选项和操作流程桎梏。
在云上，传统复杂的运维工作也有望被大模型改变。基于大模型实现的云上故障根因分析和消减措施制定表现出色，得到超过7成运维人员的认可；在任务协同方面，将软件开放API提供给AI来控制完成复杂任务，实现超出助手和工具的出色表现，这可以让整体系统价值实现提升。
当大模型、大算力为代表的人工智能创新技术不断发展，AI持续加速进入千行百业，操作系统也需要不断向AI演进。在这一背景下，大模型与OS协同优化已成趋势，操作系统将出现大变局，数字openEuler将演化为智慧openEuler。
智慧openEuler带来了系统交互的变革。例如，开发者在日常工作中，可能会使用各种编程语言，但无论哪种都很难像我们的母语一样自然、便捷。那么，是否有可能通过工具实现自然语言和操作系统交互，进而减轻写脚本、配置参数或者调试等方面的工作强度呢？openEuler使用ChatGLM基础模型，基于大量openEuler的代码和数据，训练出EulerCopilot，初步实现代码辅助生成、问题智能分析、系统辅助运维等功能，让openEuler更智能。EulerCopilot将会使得人和机器之间的交互发生巨大变化，而这也是“AI for openEuler”的一项重要改变。
如果说“openEuler for AI”带来了新的生命力，那么“AI for openEuler”注入了新的活力。基于openEuler社区已积累的技术，EulerCopilot为用户提供更便捷的人工智能能力和丰富的作业入口，用户可以通过公众号、WEB界面、SHELL、IDE等方式进行互动。EulerCopilot集成OS领域的海量知识，可以回答开发者的各类专业问题，自动补齐未完成的代码段，甚至能够完成“系统性能诊断”等诉求，并自动生成诊断报告和调优意见。
03
值得想象的广袤空间
在数智未来里，openEuler将会作为一个载体，把AI的能力不断的输入到服务器、云、边缘计算、嵌入式等多应用场景之中，推动千行百业实现数字化升级。当然，数智未来需要有不一样的基础设施，openEuler开源社区技术委员会委员吴峰光表示：“在AI的时代，社区在迈向智能化协作，我们正在探索用AI赋能社区的协作。”openEuler打造了基础设施2.0，支持全球化开发，全场景构建，全链路协作，以帮助更多人获取AI能力。
此外，openEuler的重要发展方向是出海和全球化。吴峰光表示，openEuler建立之初就决定全面全球化，在立足国内做好自主创新之后，就要走向海外汇聚全球开发者，来openEuler社区做原生开发。因此，开放原子基金会和很多基金会组织及上游社区项目等形成了连接，互相进行版本认证，互相完成项目工作。这样才能持续汇聚全球开源力量，为世界开源贡献中国智慧。
由于OS源代码采用了新的架构，因此需要从SPEC转为YAML，这将会有助于全场景能力构建。YAML的优点是通用性好且门槛低。这意味着其开发者基础更好，几乎人人会用，可以快速获取群众基础。通用的配置语言，也可以用于打造开箱即用的定制能力，支持任意YAML字段定制，适配众多格式的上游软件，而且OS支持分层定制，通过EulerMaker和EulerTest构建面向多场景的软件。
为解决上游软件推广给用户困难以及用户声音传递给上游不畅的问题，openEuler在基础设施方面通过应用软件平台，打通了从上游到用户的链路，实现了真正意义上的全链路协作。这显然不是openEuler的终极形态，预计在2024年5月，openEuler还将会发布全新内核的24.03LTS版本，进一步提升全场景能力。以Linux6.6作为内核，实现生态统一。打造全新的EEVDF调度器和folio内存管理机制，进一步提升调度和内存使用效率，在IO管理、新网络标准支持以及对CXL的支持上有着全面的提升。
面向不同的使用场景，24.03LTS版本也将提供不同的优化升级。在云计算场景下，通过CPU聚合调度，将低负载算力智能聚合，实现负载与算力协同；提供openEuler配套的云原生最小集发行版，支持一键部署；在嵌入式场景将发布面向服务器BMC的原创开源项目MetaBMC，提供原生内置openEuler的标准化开发板“openEuler派”及工业机器人框架“openEuler臂”。
当然，在AI方面，openEuler还将继续进化。除了EulerCopilot，还将实现操作系统“自优化”的智能调优，这对于开发者而言将提供巨大帮助，在应用运行中通过感知业务特征，动态调整调度优先级、配置参数等优化策略，可实现场景化性能15%以上的提升。
极目登高处，有朋远方来。AI的发展从来不是一家企业、一个社区就能推动的。而openEuler将通过成立学习小组、制定新的规格等举措推进行业发展，致力于成为AI领域的领导者。当AI与OS互相成就，未来的开发者将有望创造更大的价值，完成更多的技术创新。
推荐阅读
↑限时五折优惠↑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b1c87ef8d0d484ba5d1d639604ee3d4/" rel="bookmark">
			【C语言】隐式类型转换和强制类型转换详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言隐式类型转换整型提升算数转换 强制类型转换总结 前言 提示：这里可以添加本文要记录的大概内容：
C语言中的数据类型是编程中一个至关重要的概念。在处理不同数据类型的操作时，我们经常需要考虑类型之间的转换。C语言提供了两种主要的类型转换方式：隐式类型转换（也称自动类型转换）和强制类型转换（也称显式类型转换）。本博客将深入讨论这两种转换方式的概念、用法以及注意事项，帮助读者更好地理解C语言中的类型转换机制。
提示：以下是本篇文章正文内容，下面案例可供参考
隐式类型转换 隐式类型转换主要包括两个方面：整型提升和算数转换
整型提升 C语言中整型算数运算总是至少以缺省（默认）整型类型的精度来进行的。
为了获得这个精度，表达式中的字符和短整型操作数在使用之前被替换成普通整型，这种转换就称为整型提升。
整形提升前提条件：只有当表达式中出现长度可能小于int型的整形值时，才须要对该值进行整型提升转换为int或unsigned int型，然后再送入CPU去执行运算。
整形提升的规则：对于有符号的整形变量来说，整型提升是在高位补变量的符号位；而对于无符号的整形变量来说，整形提升是直接高位补0来实现的。
整型提升的意义 表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度⼀般就是int的字节长度，同时也是CPU的通用寄存器的长度。
因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。
通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算
如何进行整型提升 有符号整数的整型提升是按照变量的数据类型的符号位来提升的无符号整数的整型提升，高位补0 示例：
通过代码来证明，上述结果的正确性
#include &lt;stdio.h&gt; int main() { char c1 = -1; char c2 = 1; unsigned char c3 = -1; unsigned char c4 = 1; printf("%d\n", c1); printf("%d\n", c2); printf("%d\n", c3); printf("%d\n", c4); return 0; } 运行结果
从结果可以看出，程序的输出完全符合我们的预期
算数转换 我们刚刚讨论的是类型小于整形的情况，而算数转换是用来处理这些大于等于整形的情况。如果某个操作符的各个操作数属于不同的类型，那么计算是无法进行下去的，除非将这些操作数全都转化为同一类型。寻常算数转换的方向：int→unsigned int→long int→unsigned long int→float→double→long double。
图解
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b1c87ef8d0d484ba5d1d639604ee3d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65d1da92327ec258f4e364a327691e55/" rel="bookmark">
			OS 7--DNS配置&#43;Apache发布网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境准备
centOS 7
1.配置DNS 1.1 域名为lianxi.com 1.2 为WWW服务器、FTP服务器、NEWS服务器做域名解析 1)安装DNS
yum -y install bind bind-utils
(如果安装不上，就把磁盘在重洗挂载一下）
2）修改DNS配置文件
vim /etc/resolv.conf
本地解析（本地dns就是虚拟机的IP地址，把现有nameserver都注释掉）
vim /etc/named.com/
在全局配置文件中添加两个any
检查配置文件/etc/named.conf有没有错误
named- checkconf /etc/named.conf
3)在区域声明文件中添加两个区域（正向区域和反向区域）
[root@ljy named]# vim /etc/named.rfc1912.zones
4)创建正向解析文件和反向解析文件
[root@ljy ~]# named-checkconf /etc/named.conf
[root@ljy ~]# cd /var/named/
[root@ljy named]# ls
abc.fx data lianxi.com.zone lianxi.zx named.empty
named.loopback abc.zx dynamic lianxi.fx named.ca named.localhost slaves
[root@ljy named]# vim named.localhost
[root@ljy named]#cp named.loopback lianxi..fx
[root@ljy named]# vim lianxi.fx
[root@ljy named]#cp named.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65d1da92327ec258f4e364a327691e55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb4a08fca37632c2f5ad526c7953244d/" rel="bookmark">
			编程语言的进化：智能化与多样化的未来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为沟通人类与机器的桥梁，编程语言的发展一直是技术进步的重要推动力。在技术的金字塔上，编程语言作为软件开发的基石，其每一次革新都将引领着信息时代的下一个潮流。从早期的机器码，到现代的高级语言，编程语言的进化不仅加速了软件的生产，还不断地拓宽着人类与计算机世界的互动界限。未来，随着人工智能和高级抽象的兴起，编程语言的面貌将会怎样变革呢？在科技快速前行的未来，编程语言会向何方航行？
一、编程语言的发展趋势 当前，编程语言正在变得更加「人性化」和「智能化」。随着人工智能和机器学习的融入，新的编程范式将不再仅是程序员的指令集合，而是能够主动推理、学习和适应。语言简洁性、代码可复用性及更强大的类型系统等特性，将使得新语言更加易于开发和维护。然而，这也带来了新的挑战：程序员需要不断学习新的概念和技术来适应这一变化。
在未来的发展中，编程语言可能朝着更加高效、直观和智能化的方向发展。随着量子计算的兴起，我们可能会看到专为量子计算机设计的新编程语言，这些语言将原生支持量子逻辑和量子算法。另一方面，领域特定的编程语言（Domain-Specific Languages, DSLs）将更加普及，这些语言更精细地针对特定行业或任务提供优化，增强开发效率和性能。
二、编程语言的多样性 编程语言的多样性是其生命力的关键。未来的语言不仅需要在语法上更加清晰，还应该在跨平台性和互操作性上进行革新。一种可能的情景是，各种编程语言将通过统一的标准或协议实现更顺畅的交互和集成，这将允许开发者根据实际需要选择最适合的工具。
多样性是编程领域的一大特色，不同的语言针对不同的应用场景。随着计算设备的日益普及，未来的编程语言预计会诞生更多专门化的分支，满足物联网、边缘计算、量子计算等新兴领域的特定需求。同时，互操作性、可移植性和跨平台性将成为衡量编程语言成功与否的重要标准。多语言运行时和语言桥梁技术的发展，将使得不同语言之间的界限越来越模糊。
三、编程语言与人工智能的融合 自然语言处理、机器学习、深度学习正成为编程语言不能忽视的组成部分。未来的编程语言可能内建更多智能化的特性，比如自动代码优化和错误预防，甚至直接支持机器学习模型的训练和部署。程序员将能够利用这些语言更加高效地开发复杂的AI系统，并将智能应用于传统的软件开发流程中。
编程语言与人工智能的深度融合将推动未来编程的智能化。编程语言可能将内置更多支持机器学习和自然语言处理的库和框架，从而简化人工智能应用的开发过程。此外，未来的编程语言可能提供更高水平的抽象，允许开发人员用接近自然语言的方式来描述复杂算法和数据流。
四、编程语言的教育和普及 随着编程的重要性日益凸显，未来编程教育将更加注重逻辑思维和创造力的培养。不仅是计算机专业，编程也将成为通识教育的一部分。在线教育平台和交互式学习工具的发展，将使得编程学习更加容易和普及。此外，从游戏化教学到虚拟现实编程环境，未来的编程教育将变得更加直观和吸引人。
五、编程语言的生态系统和工具 良好的生态系统和强大的工具集是编程语言成功的关键。在未来，随着云计算和DevOps文化的普及，便捷的云端开发环境、自动化的测试框架、智能化的代码审查工具和更加先进的版本控制系统将成为标配。编程语言的生态系统将不断丰富，以支持更快的迭代和更高质量的软件开发。同时，随着开源文化的发展，社区驱动的项目将成为编程语言生态发展不可或缺的一部分。
结论 编程语言未来的发展将是一个多元化、智能化并且紧密结合教育及社区力量的过程。它们将更加人性化，随着新技术的涌现，新语言和范式将不断出现并满足人们不断变化的需求。最重要的是，未来的编程语言和环境将更好地支撑人类创造力的展现，无论对于专业的软件工程师，还是对于学生和业余爱好者。
未来的编程语言将会更加强大、智能和多样化，它们将更紧密地与人工智能技术结合，同时也将变得更加易于学习和使用。它们的发展将推动整个软件行业的进步，促进人类与计算机的更深层次互动。如此一来，我们可以期待，编程语言将继续作为技术创新的引擎，驱动着整个数字世界的演化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc08f7b61e8540e70453fe87e59d8826/" rel="bookmark">
			克服幻觉：提升语言模型在自然语言处理中的准确性与可靠性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 随着语言模型（LLM）在自然语言处理（NLP）中的应用日益普及，它们在文本生成、机器翻译、情感分析等许多任务中展现出惊人的能力。然而，这些模型也常常显示出一个被称作“幻觉”（hallucination）的现象，即模型生成不切实际或与事实不符的内容。这不仅影响用户对结果的信任度，也可能在特定应用中造成严重的后果。因此，理解幻觉现象的起因和寻找有效的解决策略是至关重要的。
产生幻觉的原因 1. 数据偏差： LLM的训练依赖于大量的文本数据。如果训练数据包含偏见、错误或不精确的信息，模型就可能学会并复制这些问题。
2. 过度泛化： 模型可能过分泛化训练数据中的模式，导致在特定情况下产生错误的关联或假设。
3. 上下文无关性： LLM可能不足够理解或利用上下文信息，产生的句子虽然在语法上正确，但在实际上下文中不合适或不准确。
4. 缺乏世界知识： 语言模型通常不具备现实世界的常识知识，这可能导致它们生成不符合现实的叙述。
5. 编码限制： 模型的内部编码机制可能无法准确捕捉和代表复杂的人类语言和思维模式。
6. 过度自信： 现有的模型往往缺乏对自身不确定性的评估，从而过度自信地输出错误的信息。
解决策略 1. 数据清洗与均衡： 通过筛选和校正训练数据来减少偏差，确保数据集的多样性和质量控制。
2. 增量学习和适应性： 采用增量学习方法，不断更新模型以适应新的数据和反馈，从而改进它们的表现。
3. 上下文增强模型： 设计和采用更加复杂的模型架构，以便更好地利用和理解上下文信息。
4. 知识融入： 整合外部知识库，使模型在生成内容前能参考现实世界的常识和事实。
5. 交互式学习： 允许模型通过与人类用户的交互来学习和调整输出，使模型更加适应实际使用场景。
6. 输出审查与验证： 在模型输出前实施自动或人工检查流程，验证内容的准确性和适用性。
7. 责任明确与用户教育： 清晰地界定模型的使用限制，并教育用户理解模型输出的潜在偏差，并具备批判性的使用模式。
8. 不确定性建模： 使模型能够评估其自身的不确定性，并在不确定或可能出现错误的情况下表明自己的置信度较低。
尽管幻觉现象是LLM当前需要面对的挑战之一，通过以上策略的实施和技术的持续进步，我们可以逐步减少幻觉的发生，进而提升语言模型的准确性与可靠性，使其在多种应用中都能提供更为真实和有用的信息。
大模型技术的未来 展望未来，大模型技术将可能持续朝着更高的语言理解和生成能力发展。随着算法的进步、计算资源的增加和更高质量数据集的可用性提升，我们可以预见更加精准、更少‘幻觉’现象的模型将会出现。这些模型不仅会提高自然语言处理的准确度，还将引领智能对话系统、自动化写作助手和变革性的知识发现工具的未来。此外，随着对大模型可解释性和责任性的追求加深，我们可能会看到更加透明和可信赖的AI系统出现，这些系统不但能够和用户更好地交互，同时也能在道德和法律框架内有效运作。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2942821760449a18521667cb70b9fa52/" rel="bookmark">
			互联网加竞赛 基于GRU的 电影评论情感分析 - python 深度学习 情感分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 前言1.1 项目介绍 2 情感分类介绍3 数据集4 实现4.1 数据预处理4.2 构建网络4.3 训练模型4.4 模型评估4.5 模型预测 5 最后 1 前言 🔥 优质竞赛项目系列，今天要分享的是
基于GRU的 电影评论情感分析
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1.1 项目介绍 其实，很明显这个项目和微博谣言检测是一样的，也是个二分类的问题，因此，我们可以用到学长之前提到的各种方法，即：
朴素贝叶斯或者逻辑回归以及支持向量机都可以解决这个问题。
另外在深度学习中，我们可以用CNN-Text或者RNN以及LSTM等模型最好。
当然在构建网络中也相对简单，相对而言，LSTM就比较复杂了，为了让不同层次的同学们可以接受，学长就用了相对简单的GRU模型。
如果大家想了解LSTM。以后，学长会给大家详细介绍。
2 情感分类介绍 其实情感分析在自然语言处理中，情感分析一般指判断一段文本所表达的情绪状态，属于文本分类问题。一般而言：情绪类别：正面/负面。当然，这就是为什么本人在前面提到情感分析实际上也是二分类问题的原因。
3 数据集 学长本次使用的是非常典型的IMDB数据集。
该数据集包含来自互联网的50000条严重两极分化的评论，该数据被分为用于训练的25000条评论和用于测试的25000条评论，训练集和测试集都包含50%的正面评价和50%的负面评价。该数据集已经经过预处理：评论（单词序列）已经被转换为整数序列，其中每个整数代表字典中的某个单词。
查看其数据集的文件夹：这是train和test文件夹。
接下来就是以train文件夹介绍里面的内容
然后就是以neg文件夹介绍里面的内容，里面会有若干的text文件：
4 实现 4.1 数据预处理 ​
#导入必要的包 import zipfile import os import io import random import json import matplotlib.pyplot as plt import numpy as np import paddle import paddle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2942821760449a18521667cb70b9fa52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12f378707dd75fc2a30bbebd8b500d75/" rel="bookmark">
			2023湾区产城创新大会：培育数字化供应链金融新时代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年12月26日，由南方报业传媒集团指导，南方报业传媒集团深圳分社主办的“新质·新力——2023湾区产城创新大会”在深圳举行。大会聚集里国内产城研究领域的专家学者以及来自产业园区、金融机构、企业的代表，以新兴产业发展为议题，围绕科技能力、金融服务、空间规划、产业链等要素，共同探讨大湾区产城高质量发展，为产城创新和融合发展建言献策。
与此同时，大会还对过去一年里在科技创新和服务模式转型领域有卓越表现和突出贡献的深圳企业进行表彰。在本次评选中，联易融通过前沿的技术实力和成熟的数字化解决方案荣获“行业发展创新奖”。
深圳向“新”而行，科技培育供应链创新力
深圳从蛇口工业区起家，发展为产城生态效率最高、营商环境最好的中国现代化超大城市之一。当前，深圳统筹推进以先进制造业为骨干的20大战略性新兴产业集群和8大未来产业的发展，始终向“新”而行，在发展新质生产力上，蓄势赋能，引领大湾区乃至世界之“先”。
粤港澳大湾区产园联盟理事长、深圳市创新企业育成研究院院长郭宏伟在大会期间表示，“产业园区聚集领先的科技企业和高质量产业，现代信息网络、交通网络将园区和城市紧密相连，形成了一个相互融合、协同发展的产城格局。”
在过去40多年的发展中，深圳通过制造业、高科技产业、金融服务业等多元化产业布局，支撑着城市的健康发展，凭借着创新的产业政策、优越的营商环境和强大的科技实力，在全球范围内展现出强大的竞争力。依托湾区，毗邻港澳，深圳是国际贸易的重要门户城市，这里也形成了全国最大的供应链服务集群。
作为首批全国供应链创新与应用示范城市之一，深圳在今年发布《深圳市加快推进供应链创新与发展三年行动计划（2023-2025年）》，围绕供应链的创新发展进行了全面细致的规划，并指出：“到2025年，供应链能力明显增强，供应链技术应用水平居全国前列，培育一批供应链创新标杆企业，把深圳打造成为供应链创新与应用的示范高地。”
产业集群离不开供应链服务生态的创新支撑
深圳作为全国的创新高地，亦深刻意识到先进制造离不开通过产业集群的形成，离不开供应链服务生态的创新完善。目前深圳拥有全国80%以上供应链管理服务企业的总部，并有大批积极开展供应链金融的金融机构。各类供应链金融相关市场主体在深圳已经形成生态集聚，具备供应链金融发展的产业基础和强劲需求。
今年7月，国家金融监督管理总局深圳监管局、深圳市发改委、深圳市工业和信息化局、深圳市地方金融监督管理局发布《关于银行业保险业支持深圳制造强市建设的指导意见》，要求增强金融服务的科技支撑，积极发展产业数字金融，推动“科技-产业-金融”良性循环。
以联易融为代表的供应链金融科技企业为例，公司专注于推动供应链金融全流程的数字化发展，聚焦于人工智能、区块链、云计算、大数据等先进技术在供应链生态的应用，提升整个供应链金融生态系统的透明度和连通性。今年以来，联易融成功中标多家央国企及头部民企供应链金融综合平台项目，并全面启动“智慧产融司库平台”布局；并在海外多个国家和地区实现市场拓展和跨境业务突破，依托公司成熟的海外供应链金融科技系统实施及运营经验，助力出海企业建设高效全面的全球供应链管理体系。
截至2023年上半年，联易融与1548家核心企业及金融机构达成合作，覆盖中国百强企业中的41家及全部中国前20大商业银行，其供应链金融科技解决方案覆盖了申万行业分类中全部31个行业。在本次评选中，联易融凭借自身的科技优势和服务创新经验荣获“行业发展创新奖”，公司实力再度彰显。
把握数字化机遇，依托粤港澳大湾区优质的营商环境和深圳的区域优势，联易融将持续深耕供应链金融科技这一领域，专注于更有质量的增长，以科技优势不断为供应链生态注入活力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d17e92af19eed94b98f6f9132688181b/" rel="bookmark">
			Ef Core花里胡哨系列(1) SafeDelete、ReadOnly、Audit 安全删除、只读、审计等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ef Core花里胡哨系列(1) SafeDelete、ReadOnly、Audit 安全删除、只读、审计等 在软件设计中，软删除是一种常见的数据管理技术，用于标记和隐藏被删除的数据，而不是永久地从数据库中删除它们。软删除通常通过在数据表中添加一个额外的标志列（例如"IsDeleted"）来实现。当数据被删除时，该标志列被设置为指示删除状态的值（通常是true或1），而不是直接从数据库中删除数据记录。
使用软删除的主要原因是保留数据的完整性和可追溯性。通过软删除，我们可以避免永久删除数据，从而避免意外或不可逆的数据丢失。软删除还可以帮助我们满足法律、合规性或审计要求，因为我们可以跟踪和记录数据的删除历史。
另一个重要的原因是软删除可以提供更好的用户体验。软删除允许用户恢复被删除的数据，而不必联系管理员或支持团队。这对于误删除或需要恢复数据的情况非常有用。
然而，软删除也有一些潜在的缺点。首先，软删除会增加数据库的存储需求，因为被删除的数据仍然存在于数据库中。其次，软删除可能会导致查询和性能方面的复杂性，因为我们需要在查询中过滤掉已删除的数据。
总之，软删除是一种在软件设计中常见的数据管理技术，它通过标记和隐藏被删除的数据来保留数据的完整性和可追溯性。它提供了更好的用户体验，并满足法律和合规性要求。然而，软删除也有一些潜在的缺点，需要在设计和实现时加以考虑。
定义约束 我们先定义一个安全删除的接口，用于约束对应的实体类。
public interface ISoftDelete { public bool IsDeleted{get; set;} } 通过重写ef core来实现对实现了该接口的成员进行自动处理 通过读取ef core上下文中追踪的实体，如果是继承自ISoftDelete接口，说明便不是直接删除数据，而是软删除即更新数据，将实体对应的IsDeleted标记更改为true，随后将状态改为EntityState.Modified即进行更新操作。
public class SampleDbContext(DbContextOptions&lt;SampleDbContext&gt; options, IServiceProvider serviceProvider) : DbContext(options) { public override async Task&lt;int&gt; SaveChangesAsync(CancellationToken cancellationToken = new CancellationToken()) { foreach (var entityEntry in ChangeTracker.Entries&lt;IEntity&gt;()) { if (entityEntry is { Entity: ISafeDelete safeDelete, State: EntityState.Deleted }) { safeDelete.IsDeleted = true; entityEntry.State = EntityState.Modified; } } return await base.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d17e92af19eed94b98f6f9132688181b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d5417aa1515fe67e602c592592305ca/" rel="bookmark">
			Django发送QQ邮件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建一个表单，供用户填写他们的姓名和电子邮件、电子邮件收件人和可选的注释
创建blog/forms.py
from django import forms class EmailPostForm(forms.Form): name = forms.CharField(max_length=25) email = forms.EmailField() to = forms.EmailField() comments = forms.CharField(required=False,widget=forms.Textarea) name会出现在邮件标题和正文中，是发起分享的人qli➊email是发起分享的人的邮件地址，不是系统发送邮件的地址，只是展示在邮件标题分享人括号中。系统发送邮件地址是写到setting.py中的EMAIL_HOST_USER➋to 是收件人地址➌comments是分享的备注信息，会出现在邮件正文➍ 通过继承form基类创建了一个表单。Django使用不同的字段类型来验证字段。
每个字段类型都有一个默认的HTML小部件，name字段为CharField，使用&lt;input type="text"&gt; HTML标签呈现。
使用widget属性可以覆盖默认HTML部件。在comments字段中，使用Textarea部件将用&lt;textarea&gt;标签，而不是默认的&lt;input&gt;标签。
required将comments字段定义为可选字段。
表单字段 | Django 文档 | Django (djangoproject.com)
📌表单可以驻留在Django项目的任何地方。惯例是将它们放在每个应用程序的forms.py文件中。
创建一个视图，用于处理提交的数据并发送电子邮件
from .forms import EmailPostForm from django.core.mail import send_mail def post_share(request, post_id): post = get_object_or_404(Post, id=post_id, status='published') sent = False if request.method == 'POST': form = EmailPostForm(request.POST) if form.is_valid(): cd = form.cleaned_data post_url = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d5417aa1515fe67e602c592592305ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20f69948343c0d026eea68ed8c147f9b/" rel="bookmark">
			【网络技术】【Kali Linux】Wireshark嗅探（四）域名系统（DNS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的 本次实验使用wireshark流量分析工具进行网络嗅探，旨在了解域名系统（DNS）的工作原理。
二、域名系统概述 简单来说，域名系统（Domain Name System, DNS）将域名（可以理解为“网址”，例如www.google.com）转换为计算机更容易处理的IP地址。该过程被称为“解析”，简化的过程如下图所示：
三、实验网络环境设置 本次实验使用Kali Linux虚拟机完成，主机操作系统为Windows 11，虚拟化平台选择Oracle VM VirtualBox，组网模式选择“NAT网络”，如下图所示：
四、DNS协议报文抓取 1、实验组网
本次实验只需要1台Kali Linux虚拟机即可完成，网络模式选择NAT网络，保证其与外网的连通。本次实验的组网如下图所示：
（Kali Linux 的网卡IP地址为10.0.2.5）
2、DNS协议报文捕获及分析
（1） 使用Kali自带的火狐浏览器访问百度 （www.baidu.com）：
（2） 与此同时，启动Kali自带的Wireshark流量分析工具，在“过滤条件（filter）”框中，填写“dns”，抓取DNS协议报文：
（3） 重点关注序号为1和4的报文 （报文序号前的→和←代表对应的一组请求（query）和应答（response）报文）：
1号报文DNS（协议）部分的内容：
4号报文DNS（协议）部分的内容：
（4） 我们注意到，第2个应答的IP地址值为110.242.68.66，我们在终端中输入
ping www.baidu.com，解析出的IP地址为110.242.68.3，即位于同一网段下。
至此，本次实验结束。
五、参考文献 《计算机网络（第7版）》，谢希仁 编著，北京，电子工业出版社，2017年1月。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75ea1d0acfd8bc22b4d9bc4999635101/" rel="bookmark">
			电脑C盘满了格式化清理的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在电脑操作过程中，用户发现C盘已经满了，导致电脑运作变得卡顿，所以想格式化清理C盘的内容，但不知道具体的清理操作步骤，接下来小编给大家详细介绍格式化电脑C盘的方法步骤，帮助大家轻松格式化C盘，腾出更多的运作空间，电脑运行更快速。
电脑C盘满了格式化清理的方法：
方法一：通过单击鼠标右键点击格式化
1. 打开“我的电脑”，选择本地磁盘C盘，鼠标右键点击“格式化”。
2. 此时可能会弹出“无法格式化该卷”的提示。
3. 再次鼠标右键点击C盘，选择“属性”。
4. 在弹出的对话框中，点击“磁盘清理”。
5. 选择“系统文件”，点击“确定”按钮。
6. 等待系统分析磁盘后，勾选需要清理的文件类型，例如Windows更新等。
7. 点击“确定”按钮，系统将会帮助清理需要清理的文件。
8. 清理完毕后，可以再次点击C盘右键，选择“格式化”进行格式化操作。
方法二：dos命令格式化C盘
1. 在开始菜单栏界面中输入cmd，并以管理员身份运行。
2. 输入diskpart进入磁盘分区工具。
3. 使用listdisk命令查看可用磁盘信息。
4. 慎重选择需要格式化的磁盘编号，0通常为系统盘。
5. 使用clean命令清空磁盘数据。
6. 使用creatpartitionprimary命令创建主分区，随后使用formatfs命令指定格式化方式和分区标签，例如格式化为NTFS文件系统并为磁盘分区标签设为“E：”。这样就成功格式化了该磁盘。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ab477c370238f8bfae52ae3d764f741/" rel="bookmark">
			线性代数_对角矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对角矩阵是线性代数中一种特殊的矩阵类型，它在数学理论和实际应用中都有着重要的地位。对角矩阵的定义如下：
设 \( A \) 是一个 \( n \times n \) 的方阵，如果满足除主对角线上的元素外，其他元素都为零，即 \( A_{ij} = 0 \) 当 \( i \neq j \)，那么矩阵 \( A \) 称为对角矩阵。
对角矩阵具有以下几个重要的性质：
1. **主对角线**：对角矩阵的所有非零元素都位于主对角线上，即 \( A_{ii} \neq 0 \)。
2. **对称性**：对角矩阵是关于主对角线对称的，即 \( A_{ij} = A_{ji} \)。
3. **行列式**：对角矩阵的行列式 \( \det(A) \) 等于主对角线上元素的乘积，即 \( \det(A) = \prod_{i=1}^{n} A_{ii} \)。
4. **特征值和特征向量**：对角矩阵的特征值就是主对角线上的元素，特征向量是单位向量。
5. **可对角化**：任何方阵都可以通过相似变换转化为对角矩阵，这个过程中涉及到的矩阵称为对角化矩阵。
6. **乘积**：两个对角矩阵的乘积仍然是对角矩阵。
对角矩阵在数学中有着广泛的应用，例如在求解线性方程组、特征值问题、矩阵分解等领域。此外，对角矩阵在物理学、工程学、经济学等学科中也有着重要的应用。对角矩阵的乘法运算相对简单，因此在某些计算中可以简化运算过程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48f148bd0ab809757ee6e4184480990a/" rel="bookmark">
			离散点过滤算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		离散点过滤算法是数据处理中常用的一种算法，主要用于去除数据中的离群点或噪声点。这些离群点可能是由于测量误差、异常事件或其他原因产生的。以下是一些常见的离散点过滤算法：
Z-score过滤算法：该算法通过计算每个数据点的Z-score（标准分数）来判断其是否为离群点。如果Z-score的值大于某个设定的阈值（如3.0或3.5），则认为该点为离群点并予以去除。IQR过滤算法：该算法通过计算数据点的四分位距（IQR）来识别离群点。如果一个数据点小于Q1 - k * IQR或大于Q3 + k * IQR，其中Q1和Q3分别为数据的下四分位数和上四分位数，k是一个常数（通常取3.0或1.5），则认为该点为离群点并去除。基于距离的过滤算法：该算法通过计算数据点与其邻居的距离来判断是否为离群点。如果一个数据点与其邻居的距离大于某个设定的阈值，则认为该点为离群点并去除。密度过滤算法：该算法通过计算数据点的密度来判断是否为离群点。如果一个数据点的密度低于某个设定的阈值，则认为该点为离群点并去除。 这些算法各有优缺点，可以根据实际的数据分布和需求选择适合的算法。同时，为了确保数据的准确性和可靠性，通常会结合多种过滤算法进行离散点的去除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30c08983b69661e8fcbae7f0d61148a9/" rel="bookmark">
			MyBatis学习一：快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 公司要求没办法，前端也要了解一下后端知识，这里记录一下自己的学习
学习教程：黑马mybatis教程全套视频教程，2天Mybatis框架从入门到精通
文档：
https://mybatis.net.cn/index.html
MyBatis 快速入门：查询user表中所有数据
创建user表，添加数据创建模块，导入坐标编写mybatis核心配置文件 ----&gt;替换连接信息，解决硬编码问题编写sql映射文件—&gt; 统一管理sql语句，解决硬编码问题编码 定义POJO类，对应数据库的表加载核心配置文件，获取SqlSessionFactory对象获取SQLSession对象，执行sql语句释放资源 创建模块 创建模块
File - &gt; New -&gt; Module
导入坐标
pom.xml
&lt;dependencies&gt; &lt;!--mybatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.31&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- slf4j 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt; &lt;/dependency&gt; &lt;!-- logback 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; src/main/resources/logback.xml
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30c08983b69661e8fcbae7f0d61148a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79d2b3c62329ab7471ce19b30202c156/" rel="bookmark">
			php安装扩展event 提示 No package ‘openssl‘ found 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用pecl编译安装最新版event模块的时候提示 No package 'openssl' found , 可是本机是安装了openssl的, 编译时找不到, 大概率就是环境配置的问题了, 增加 OPENSSL_CFLAGS OPENSSL_LIBS环境变量即可解决. 异常提示信息:
checking for openssl &gt;= 1.0.2... no configure: error: Package requirements (openssl &gt;= 1.0.2) were not met: No package 'openssl' found Consider adjusting the PKG_CONFIG_PATH environment variable if you installed software in a non-standard prefix. Alternatively, you may set the environment variables OPENSSL_CFLAGS and OPENSSL_LIBS to avoid the need to call pkg-config. See the pkg-config man page for more details.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79d2b3c62329ab7471ce19b30202c156/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca545e128a2d506771516cabee29e2f0/" rel="bookmark">
			HTTPS 存在哪些安全问题，有什么应对方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTPS 是 HTTP 的安全版本，通过使用 SSL/TLS 协议对通信内容进行加密，提供了以下几个关键的安全特性：数据加密、身份认证和完整性保护。尽管 HTTPS 在很大程度上提高了安全性和数据传输的安全性，但仍然存在一些潜在的安全问题。德迅云安全今天给大家简单分享下一些可能的问题以及相应的应对方案：
1、证书信任链问题：当客户端验证服务器的证书时，需要一个可靠的证书颁发机构（CA）来建立信任链。然而，在实际应用中，存在证书信任链被破坏或被攻击者伪造的风险，这将对数据传输的安全性造成威胁。如果攻击者能够伪造证书或破坏证书信任链，他们可能会冒充合法服务器并窃取或篡改数据。
应对方案：建议使用受信任的（CA）颁发的证书，确保证书的真实性和合法性。对于需要更高安全性的场景，可以实施私有证书颁发机构。
2、弱加密算法和协议问题：尽管 SSL/TLS 支持多种加密算法和协议，但一些算法可能由于已知的安全漏洞而被弱化或废弃。此外，HTTPS 协议本身可能存在一些弱点，这些弱点可能会使其容易受到各种攻击。
例如 BEAST 攻击和 POODLE 攻击等。这些攻击方式利用了 HTTPS 协议中的一些漏洞，使得攻击者能够窃取会话密钥或者加密的敏感信息。因此，为了提高网络通信的安全性，我们需要采取一些措施来解决这些问题。
应对方案：为了解决 HTTPS 协议存在的弱点问题，我们可以持续关注最新的加密算法和协议的安全性，确保使用最新的、经过广泛审查和认可的加密算法和协议，如 TLS 1.3。
3、重放攻击：如果攻击者截获到之前通信的记录，他们可能会重新播放这些记录来攻击系统。
应对方案：使用时间戳、Nonce 或其他机制来确保每个通信请求都是唯一的。
4、客户端支持问题：一些老旧或过时的客户端可能不支持 HTTPS，或者其加密库可能存在已知的安全漏洞。
应对方案：尽可能使用最新的客户端，并确保其支持最新的加密算法和协议。对于必须支持老旧客户端的情况，应确保这些客户端的安全更新和补丁是最新的。
5、配置和管理问题：错误的 HTTPS 配置（如错误的证书、错误配置安全头等）可能会导致安全漏洞。
安全头是一组非常重要的 HTTP 响应头，它们提供了关于网站安全性的关键信息。这些安全头包括 Strict-Transport-Security（HSTS）、Content-Security-Policy（CSP）、X-XSS-Protection 等。这些安全头能够有效地保护网站免受各种网络攻击，如跨站脚本攻击（XSS）和中间人攻击等。
缺少这些安全头可能会给网站带来严重的安全漏洞，使攻击者能够轻松地渗透到网站中，窃取敏感信息或执行恶意代码。例如，缺乏 HSTS 安全头可能会导致攻击者通过 HTTP 协议而不是 HTTPS 进行通信，从而绕过 SSL/TLS 加密，使得通信内容容易被截获和窃听。
应对方案：建议在网站配置中正确使用和配置，确保所有 HTTPS 配置都是正确的，这包括在 HTTP 响应中设置正确的安全头，并确保它们具有正确的值以防止各种类型的攻击。同时，也需要定期检查和更新配置，定期进行安全审计和渗透测试，以应对新的安全威胁和攻击手段，以确保系统的安全性。
6、私有密钥泄露风险：如果服务器的私有密钥泄露，攻击者可能会利用它来解密通信内容或冒充服务器。
应对方案：实施严格的访问控制和权限管理，确保只有授权的人员能够访问服务器的私有密钥。此外，应定期审计和监控系统的安全性，以确保没有未授权的访问或异常行为。
7、中间人攻击：中间人攻击是一种严重的网络安全威胁，通常发生在不安全的网络通信中。尽管 HTTPS 提供了对等实体认证，但中间人攻击仍然可能发生。
在这种攻击中，攻击者会巧妙地插入自己，位于通信的两端之间，从而能够拦截和窃听机密的通信内容。这种攻击方式不仅侵犯了用户的隐私，还可能导致身份盗窃、欺诈等进一步的问题。例如，如果攻击者能够篡改客户端或服务器的 DNS 记录，从而将用户流量重定向到恶意网站。用户在访问这些网站时，可能会被要求提供个人信息或下载恶意软件，从而造成安全威胁。
应对方案：
1、使用 DNSSEC（DNS 安全性扩展）来保护 DNS 记录不被篡改，并确保客户端使用安全的 DNS 解析器。此外，实施双向认证可以进一步增加对等实体认证的安全性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca545e128a2d506771516cabee29e2f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4741669b7e5bdc6ef14df8b115b606b/" rel="bookmark">
			国产服务器操作系统PXE安装脚本 可重复执行（rc08版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行效果如下：
#!/bin/bash #Date:2023/12/25 #Func:一键部署pxe服务器 #Author:Zhanghaodong #Version:2023.12.25.05 #Note:仅适用x86架构uefi安装 # 1.此脚本可多次重复执行。 # 2.如遇到某个服务异常退出，检查响应状态码排错后，再次执行脚本即可。 # 3.此脚本仅仅适用于CRITC-HongAn-Server-x86_64-V1.0-rc08.iso或CRITC-HongAn-Server-aarch-V1.0-rc08.iso # 4.在填写以下参数时，请注意：x86架构可用uefi或leagcy引导，其对应的filename分别是grubx64.efi和pxelinux.0 # arm只能用uefi引导且filename只能是grubaa64.efi #Manually Writing Basic Information PXE_SERVER="11.0.1.181" ISO="/root/CRITC-HongAn-Server-x86_64-V1.0-rc08.iso" CLIENT_ARCH="x86" #x86 or arm CLIENT_BOOT_MODE="uefi" #uefi or leagcy #PXE_FILE_NAME="pxelinux.0" #x86下uefi对应的grubx64.efi,leagcy对应pxelinux.0；arm对应的只有grubaa64.efi ROOT_PASSWORD="qwer1234!@#$" #Dhcp Config Information SUBNET="11.0.1.0" #子网 NETMASK="255.255.255.0" #掩码 GATEWAY="11.0.1.1" #网关 RANGE_IP_LOW="11.0.1.200" #ip范围 RANGE_IP_HIGH="11.0.1.230" #ip范围 function Log { local log_level=$1 local log_info=$2 local line=$3 local script_name=$(basename $0) case ${log_level} in "INFO") echo -e "\033[32m$(date "+%Y-%m-%d %T.%N") [INFO]: ${log_info}\033[0m"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4741669b7e5bdc6ef14df8b115b606b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/2/">«</a>
	<span class="pagination__item pagination__item--current">3/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/4/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>