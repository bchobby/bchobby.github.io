<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6006ba7e3c6e26aa4577a916a6c2808e/" rel="bookmark">
			DoModal 函数的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 DoModal 函数的用法 使用有模式对话框时在对话框弹出后调用函数不会立即返回，而是等到对话框销毁后才会返回（请注意在对话框弹出后其他窗口的消息依然会被传递）。所以在使用对话框时其他窗口都不能接收用户输入。创建有模式对话框的方法是调用CDialog::DoModal()。下面的代码演示了这种用法： CYourView::OnOpenDlg() { CYourDlg dlg; int iRet=dlg.DoModal(); } CDialog::DoModal()的返回值为IDOK，IDCANCEL。表明操作者在对话框上选择“确认”或是“取消”。由于在对话框销毁前DoModal不会返回，所以可以使用局部变量来引用对象。在退出函数体后对象同时也会被销毁。而对于无模式对话框则不能这样使用，下节5.3 创建无模式对话框中会详细讲解。 你需要根据DoModal()的返回值来决定你下一步的动作，而得到返回值也是使用有模式对话框的一个很大原因。 使用有模式对话框需要注意一些问题，比如说不要在一些反复出现的事件处理过程中生成有模式对话框，比如说在定时器中产生有模式对话框，因为在上一个对话框还未退出时，定时器消息又会引起下一个对话框的弹出。 同样的在你的对话框类中为了向调用者返回不同的值可以调用CDialog::OnOK()或是CDialog::OnCancel()以返回IDOK或IDCANCEL，如果你希望返回其他的值，你需要调用 CDialog::EndDialog( int nResult ); 其中nResult会作为DoModal()调用的返回值
virtual INT_PTR CDialog::DoModal(); 当dlg.DoModal()后，显示一个模态对话框，此时DoModal()函数并不返回，直到用户关闭此对话框时，DoModal才返回。如果用户点击了确定按钮，那么DoModal()函数就返回IDOK。IDOK是一个宏。
当你CMyDlg dlg;时，对话框并没有显示，只要构造了一个CMyDlg类型的对象而已，直到用户调用DoModal()，对话框才会显示出来。
posted @ 2012-11-05 16:25 xingoo 阅读( ...) 评论( ...) 编辑 收藏 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7ec6d2d8aa32e59ac93cacdbc4c6d59/" rel="bookmark">
			用Python实现的&#34;石头,剪刀,布&#34;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求:设计一个"石头,剪子,布"游戏,有时又叫"Rochambeau",你小时候可能玩过,下面是规则.你和你的对手,在同一时间做出特定的手势,必须是下面一种手势:石头,剪子,布.胜利者从
下面的规则中产生,这个规则本身是个悖论. (a) 布包石头. (b)石头砸剪子, (c)剪子剪破布.在你的计算机版本中,用户输入她/他的选项,计算机找一个随机选项,然后由你
的程序来决定一个胜利者或者平手.注意:最好的算法是尽量少的使用 if 语句.
曾经实现过一个java版本的,用的思路是通过Enum分发的方式来实现,那种实现方式灵活性相对较强,但是代码量还是较多.现在正在学习python,所以用python实现了一个简单的版本,代码的数量上还是有明显的减少[本人是新手,不足请指教]:
''' demonstrate Stone, Stainless, Paper game Created on 2012-11-1 @author: Eric ''' import random; #elementA--&gt;DRAW WIN LOST COMPETE_RESULT = {"Stone":["Stone", "Stainless", "Paper"], "Stainless":["Stainless", "Paper", "Stone"], "Paper":["Paper", "Stone", "Stainless"]}; SIGN = {0:"Stone", 1:"Stainless", 2:"Paper"} RESULTS = {0:"DRAW", 1:"WIN", 2:"LOST"}; def rochambeauGame(): print('''0:STONE 1:STAINLESS 2:Paper 3:quit '''); while True: userSign = input("please input your userSign number:"); if int(userSign) in (1, 2, 3, 0): if userSign == 0: exit(); else: userSignResults = COMPETE_RESULT[SIGN[int(userSign)]]; pcSign = SIGN[int(genereteRandomPCSign())]; print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7ec6d2d8aa32e59ac93cacdbc4c6d59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de02d939176a910c945660c20f64dc04/" rel="bookmark">
			CentOS安装wireshark
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS的发行光盘里本身是有wireshark的rpm的，如果安装系统时组件没选上，那么可以从安装光盘里找。如能连网，那么用yum是最简单的：
# yum install wireshark
# yum install wireshark-gnome
注意wireshark包本身只包含文本工具，这样并无法使用wireshark和图形界面。但提供了抓包基本功能。wireshark-gnome才提供wireshark（UI)工具，它依赖wireshark RPM。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/711551a891b3ddca8c84c00d2296edd1/" rel="bookmark">
			ortp 编译测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.获得原码包
我是从csdn获得 ortp-0.20.0.zip
2.编译安装
解压并进入主目录：cd /opt/ortp-0.20.0
执行如下命令：
a）./configure
b）make
c）sudo make install
装好以后系统环境如下，静态动态库安装到了/usr/local/lib目录下，包括libortp.la、libortp.so libortp.so.8 libortp.so.8.0.0。
头文件在/usr/local/include目录ortp目录下。
库文件复制到/usr/lib文件夹下，头文件复制到/usr/include下。
3. 程序编译与测试
测试源码在 src/test 路径下。
1） 接收
gcc rtprecv.c -o rtprecv -lortp编译接收端程序
2） 发送
gcc rtpsend.c -o rtpsend -lortp 编译发送程序
3） 测试
在终端运行./rtprecv test 5000
在另一终端运行 ./rtpsend test 192.168.1.104 5000
完成文件传送。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf1ebaf4f2411b713c4fe4ade57eed3e/" rel="bookmark">
			IIS写权限的利用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源地址：http://netsecurity.51cto.com/art/200812/101015.htm
IIS写权限对网站系统的安全是致命的，拥有写权限可以直接往网站目录写文件，在拥有写权限的服务器上，其安全相对设置薄弱，因此比较容易被入侵者控制，本文就IIS写权限方面进行了研究。
一、IIS写权限原理
测试一个目录对于web用户是否具有写权限，采用如下方法：
1．telnet服务器并发送传送文件请求
首先使用Telnet连接到服务器的web端口即80端口，并发送一个如下请求：
PUT /dir/my_file.txt HTTP/1.1 Host: IIS-server Content-Length: 10 2.查看服务器返回信息
正常情况下服务器会返回一个100的信息，如下所示：
HTTP/1.1 100 Continue Server: Microsoft-IIS/5.0 Date: Thu, 28 Num 2008 15:56:00 GMT 3.测试是否可以输入
接着，我们输入10个字母：AAAAAAAAAA，送出这个请求后，看服务器的返回信息，如果是一个 201 Created响应，如下所示：
HTTP/1.1 201 Created Server: Microsoft-IIS/5.0 Date: Thu, 28 Num 2008 15:56:08 GMT Location:http://IIS-server/dir/my_file.txt Content-Length: 0 Allow: OPTIONS, TRACE, GET, HEAD, DELETE, PUT,COPY, MOVE, PROPFIND, PROPPATCH, SEARCH, LOCK, UNLOCK 那么就说明这个目录的写权限是开着的，反之，如果返回的是一个403错误，那么写权限就是没有开起来，如果需要你认证，并且返回一个 401（权限禁止） 的响应的话，说明是开了写权限，但是匿名用户不允许。如果一个目录同时开了“写”和“脚本和可执行程序”的话，那么Web用户就可以上传一个程序并且执行它。
二、实际渗透测试
1.IIS写权限漏洞探测
以某高校的OA系统为例，其IP地址为202.115.*.*。通过上面的测试，发现该IIS目录可以进行读写操作，直接打开该IP地址可以正常访问Web页面，如图1所示。
说明：
该IP地址对外仅仅开放80和1433端口，由于所有业务系统是在登录后才能使用，使用明小子的Domain3.5、教主的HDSI3.0以及Zwell对Jsky等SQL注入工具均无漏洞利用点，无法通过SQL注入来获得突破。
2.直接提交文件
由于该IIS目录可以读写，最简单的办法就是提交一个asp的Webshell上去，但在实际提交asp文件时，IIS提示：“HTTP/1.1 403 Forbidden”错误，直接提交asp文件失败，所以直接用Post方式写asp不行了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf1ebaf4f2411b713c4fe4ade57eed3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26d850ef169db1ddf3fa4231f9910f1d/" rel="bookmark">
			关于C/C&#43;&#43;中全局变量的初始化问题的深入思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
前日，在一次C++课程上，刘老师在举例说明构造函数和析构函数的功能时，提到了全局变量初始化时的构造函数的行为。构造函数在main函数之前初始化全局变量。当然在C++下我是深信不疑的。但随后老师声称C语言下的全局变量也是如此，因为C没有构造和析构函数，所以我们无法看到这一过程，在C++下可以在构造和析构函数中向屏幕打印信息，进而可以观察全局变量的初始化和生存期。
这个观点无疑使我心头一震，作为C的痴迷者，长期以来在我头脑中的印象是，全局变量在编译期就完成初始化了。难道我的观念是错误的？！难道C真的也是在main函数之前，在程序运行初期才初始化？！
于是我翻看了《C语言参考手册》这本书上没有明确的答案，再翻看著名的K&amp;R的《C程序设计语言》中只有括号里面的一句话“在概念上.......”也是含糊其辞。（现在想想这个问题可能和编译器有关，所以丹爷爷也没说明太多）
在网上查询了一下，关于这个问题，持什么观点的都有，没有一个权威的答案。
只能靠自己了，动手实验！
先给出我的结论：
C和C++中的一般全局变量（不包括类class）是在编译期确定的初始值，而不是在程序运行时，在main函数之前初始化的。
C++中的类的全局变量是在程序运行时，在main函数之前初始化的。
预热知识：
C或者C++语言，明面上的入口函数是main(argc,argv)，或者tmain、wmain、WinMain等等。但实际上，是C Runtime的startup代码中的void mainCRTStartup(void)函数，调用了编程者写的main函数。这个函数定义在VisualC++安装目录的crt\src\目录下的某个.c文件中（视VC++的版本不同，存放的文件也不同）。它在执行一些初始化操作，如获取命令行参数、获取环境变量值、初始化全局变量、初始化io的所需各项准备之后，调用main(argc,argv)。main函数返回后，mainCRTStartup还需要调用全局变量的析构函数或者atexit()所登记的一些函数。往深里说，是在链接生成可执行文件时，告诉链接器这个可执行文件的entry就是mainCRTStartup。当然，我们也可以对编译器进行设置，使其不插入mainCRTStartup函数代码
以VC++6.0为例设置：Project-&gt;Settings-&gt;Link 在Category中选择Output，在Entry-point symbol中填上main 即可。
-------------------------
实验一：
1， C语言环境下：
实验准备：
int a ; int main(void) { return a+3 ; } 在编译器中设置入口函数为main（具体方法见上面）
这样，我们让编译器生成的程序，直接从main函数中进入，而不是先执行mainCRTStartup函数做一些准备工作。
结果预测：
这样，如果函数返回的是3，则说明此全局变量是在编译期就被初始化为0了，如果函数返回的是其它数字，则说明此全局变量是在程序运行时，main函数运行前进行的初始化。
实验结果：
进入控制台（运行cmd命令），运行编译后的程序（因为程序没有向屏幕输出结果，我们看不到任何现象），继续输入命令：echo %ERRORLEVEL% 则显示3，此即为函数的返回值。
（echo是显示其后的值，系统把前面运行的程序的返回值放在%ERRORLEVEL%中，故我们可以通过此方法获得主函数的返回值）
同理：对于结构体全局变量
struct A { int a ; } sTest; int main(void) { return sTest.a+3 ; } 函数也返回3.
实验结论：
在C语言中，全局变量是在编译期完成初始化的。
（在本实验中我们没有使用I/O函数把结果打印出来，因为I/O函数的调用之前必须要初始化内存中的某堆空间，而这个工作是由main函数之前的mainCRTStartup函数来做的。而我们设置让编译器跳过这个函数，故会在运行时出错。）
实验二：
C++语言环境下
实验准备：
class A { public: int a ; A(){a=10;} ~A(){} } ; A cTest ; int main(void) { return cTest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26d850ef169db1ddf3fa4231f9910f1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f2e0300c068098e050ccdea65b7c5f7/" rel="bookmark">
			java异常中Exception捕获不到的异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 概念
众所周知java提供了丰富的异常类，这些异常类之间有严格的集成关系，分类为
父类Throwable
Throwable的两个子类Error和Exception
Exception的两个子类CheckedException和RuntimeException
二 发现问题
通常捕获异常catch的时候最大catch到Exception这个类就为止了，当然这能够处理大部分的异常情况。
但是值得注意的是，Exception不能捕捉到所有的异常。比如InvocationTargetException。
三 解决办法
catch(Throwable t)
{ }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34594a3177df731c57ae0298c951bd46/" rel="bookmark">
			C#使用Chart示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一个简单的chart： spline// Create new data series and set it's visual attributes
Series series = new Series("Spline");
series.ChartType = SeriesChartType.Spline;
series.BorderWidth = 3;
series.ShadowOffset = 2;
// Populate new series with data
series.Points.AddY(67);
series.Points.AddY(57);
series.Points.AddY(83);
series.Points.AddY(23);
series.Points.AddY(70);
series.Points.AddY(60);
series.Points.AddY(90);
series.Points.AddY(20);
// Add series into the chart's series collection
Chart1.Series.Add(series);
同时显示2条曲线
// Populate series with random data
Random random = new Random();
for (int pointIndex = 0; pointIndex &lt; 10; pointIndex++)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34594a3177df731c57ae0298c951bd46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17c0f3168fd7e3d52848190b0103b406/" rel="bookmark">
			开关、断路器、隔离器的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在读几个光伏领域的IEC标准，里面涉及到了几个开关类的设备，一时有点分不清。花了点时间查了查，这里做个总结。
开关电器 switching device 用于接通或分断一个或几个电路中电流的电器。（GB 14048.1-2006）
(机械的)开关 switch (mechanical) 在正常的电路条件下（包括过载工作条件）下能接通、承载和分断电流，也能在规定的非正常条件（例如短路条件）下承载电流一定时间的一种机械开关电器。 （GB 14048.1-2006）
隔离器 disconnector 在断开位置上能符合规定隔离功能要求的一种机械开关电器。（GB 14048.1-2006）
隔离器 vs 开关：隔离器与开关的区别在于通常意义下的开关要能在工作状态下（包括过载条件下）接通和分断电流，而隔离器无灭弧能力，只能在没有负荷电流的情况下分、合电路。由于隔离器结构简单，所以也便宜得多。多说一句，IEC标准不要求开关能在短路条件下分断电流。
隔离开关 switch disconnector Mechanical switching device capable of making, carrying and breaking currents in normal circuit conditions and, when specified, in given operating overload conditions. In addition, it is able to carry, for a specified time, currents under specified abnormal circuit conditions, such as short-circuit conditions. Moreover, it complies with the requirements for a disconnector .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17c0f3168fd7e3d52848190b0103b406/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f48118464b5f2bf3710af3896b05afbb/" rel="bookmark">
			简单破解教程 笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一课简单爆破收费外挂
（无壳情况）
1,载入OD(小生我怕版比较好用)
2，点击&gt;&gt; 让程序运行起来
3，点击要破解软件的开始注册按钮（会弹出失败字样提示框，先不用管它）
4，点“调试”--&gt;"执行用户代码"
5，点击第3步中弹出的错误提示框（确定按钮）
6，点工具栏的“K”按钮
7，找到前两个“包含”字样中间的行，双击之
8，右键--&gt;虫文搜索引擎--&gt;ASIIC
9,找到“登录错误”提示--&gt;找到其下的第一个CALL，复制该行代码，记录下来
10，找到“登录成功”提示--&gt;找到其上的Push语句的第一行，复制该行代码，记录下来
11，转到“登录错误”提示下的CALL语句行，汇编--&gt;call 10中记录的push语句地址
12，右键--&gt;复制到可执行文件--&gt;复制全部（所有修改）--&gt;右键--&gt;保存--&gt;ok
第二课简单的追出注册码 （无壳情况）
1,载入OD(小生我怕版比较好用)
2，点击&gt;&gt; 让程序运行起来
3，点击要破解软件的开始注册按钮（会弹出失败字样提示框，先不用管它）
4，点“调试”--&gt;"执行用户代码"
5，点击第3步中弹出的错误提示框（确定按钮）
6，点工具栏的“K”按钮
7，找到前两个“包含”字样中间的行，双击之
8，右键--&gt;虫文搜索引擎--&gt;ASIIC
9，找到“登录成功”提示--&gt;找到其上第一个“Hex数据”为55 的那行，点F2下断点
10，点击&gt;&gt; 让程序运行起来
11，输入随意注册码--&gt;点击待破解程序上的开始
12，F8 单步走
13,记录其中出现的ASCII码字串（其中包含自己输入的假码，正确的注册码）
第三课中等爆破收费外挂
1,载入OD(小生我怕版比较好用),会弹出错提示，先择“ 取消”。
2，点击&gt;&gt; 让程序运行起来
3，点击要破解软件的开始注册按钮（会弹出失败字样提示框，先不用管它）
4，点“调试”--&gt;"执行用户代码"，),会弹出错提示，先择“ 取消”。（不知道是不是应该把OD设为默认的“应用程序出错”，调试工具）
5，右键--&gt;“脱壳调试进程”--&gt;"脱壳"--&gt;保存
6，OD载入第5步中脱出来的程序,会弹出错提示，先择“ 取消”。
7，右键--&gt;虫文搜索引擎--&gt;ASIIC
8，开始，改call吧孩子
樱花补丁制作工具的使用：
1，点浏览，找到没破解的程序
2，举例：
内存地址：00406F1E
原始指令：E8 033E0100
修改指令：E8 9F150000 （1）00406F1E E8 033E0100 call 下壳.0041AD26（例：此为登录框下面弟一个CALL）
（2）004084C2 6A 00 push 0x0 （例：此为登录成功上面第一个PUSH (0x..)）
（3）00406F1E E8 9F150000 call 下壳.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f48118464b5f2bf3710af3896b05afbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07612ce1a8e6e3975e03ec5f699a2561/" rel="bookmark">
			系统出现cursor: mutex X等待导致实例HANG死
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		客户数据库出现明显的cursor: mutex X等待，尝试通过ALTER SYSTEM KILL SESSION的方式释放等待的会话，结果导致整个实例出现HANG死的情况。
数据库版本为10.2.0.4，检查数据库问题发生时刻的AWR报告，发现cursor: mutex X等待在AWR报告中并不明显，不但没有出现在TOP 5里，而在整个等待事件的排名中也排在非常靠后的位置，且该事件的总等待时间为0，这与客户反馈的大约70多个会话持续等待cursor: mutex X事件的描述极为不符。
导致这个现象的原因可能有两种，一种是虽然从V$SESSION中看到当前的等待是cursor :mutex X事件，但是该事件已经结束，因此会话的等待时间并未记录并汇总到这个事件的等待时间中；另外一种情况是Oracle对于这个事件的统计值存在错误。
继续分析AWR报告，可以发现VERSION COUNT报告中，最高的两个SQL已经远远超过了正常的范围，达到了13W以上，毫无疑问这肯定不正常的情况所致：
Version Count Executions SQL Id
SQL Module
SQL Text
150,649
7q1tdx7ysmg6f
** SQL Text Not Available **
134,787
fa3vfvs859n5n
** SQL Text Not Available **
10,732
gr0wk1tf0npm4
select count(:"SYS_B_0") as ro...
6,547
6r91qu3knm3vz
** SQL Text Not Available **
5,888
36ft4hmuru5d2
** SQL Text Not Available **
排在第3和第4位的VERSION COUNT达到5000以上就已经不太正常了，何况最高的两条语句的值已经超过了13W，不用说这两条语句会占用大量的共享池空间：
Sharable Mem (b)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07612ce1a8e6e3975e03ec5f699a2561/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/381702fd637daa17d73ef42e11784fa6/" rel="bookmark">
			viewDidUnload，viewDidLoad,viewWillAppear,viewWillDisappear的作用以及区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		viewDidLoad:在视图加载后被调用 viewWillAppear:视图即将可见时调用。默认情况下不执行任何操作 viewDidAppear: 视图已完全过渡到屏幕上时调用 viewWillDisappear:视图被驳回时调用，覆盖或以其他方式隐藏。默认情况下不执行任何操作 viewDidDisappear:视图被驳回后调用，覆盖或以其他方式隐藏。默认情况下不执行任何操作 Ps：-viewWillAppear:和-viewDidAppear:的区别是什么呢？ 答：设置一个uitextfield 然后让视图出现的时候 显示键盘
在viewwillappear无法实现的但是在viewdidappear能实现改功能。 字面就看的出来区别了viewwillappear是说界面还没有显示，可以做一些界面相关的数据准备。viewdidappear是界面已经显示完成了，如果这个时候再调整一些稍微耗时的界面设置操作就不是很合适吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b24a8138605cc9a715c20cdce6d17507/" rel="bookmark">
			SDP介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		会话描述协议（Session Description Protocol，SDP)
（1）SDP 是 传 送 会 话 信 息 的 协 议， 包 括 会 话 的 地 址、 时 间、 媒 体 和 建 立 等 信 息。 它 定 义 了 会 话 描 述 的 统 一 格 式。 （2）SDP 描 述 的 内 容 应 包 括： 会 话 名 和 目 的
会 话 激 活 的 时 间 段
构 成 会 话 的 媒 体
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b24a8138605cc9a715c20cdce6d17507/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61e84d135fa5af8b9039204a65a538ca/" rel="bookmark">
			boost graph lib 小试牛刀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近要做社会网络的社区发现，发现用BGL能减少不少代码量。经过一番调研发现BGL封装的很牛叉，Dijkstra等算法统统具备，奈何自己对泛型编程不太熟，
遇到问题还是很纠结。Primer泛型编程、算法部分和STL源码分析接下来有时间一定要读下。
下面仅以邻接链表和自定义节点为例
typedef adjacency_list&lt;listS,vecS,undirectedS,Node,property&lt;edge_weight_t,int&gt; &gt; Graph; typedef graph_traits&lt;Graph&gt;::vertex_descriptor VertexDescriptor; typedef graph_traits&lt;Graph&gt;::edge_descriptor EdgeDescriptor; typedef graph_traits&lt;Graph&gt;::edge_iterator EdgeIterator; typedef graph_traits&lt;Graph&gt;::vertex_iterator VertexIterator; typedef std::pair&lt;Node,Node&gt; Edge; 类型声明。其中Node为自定义类型，property分为内部属性和外部属性，这样声明是内部属性，将随着Graph的生命周期存在，在做社区发现时基本不需要边的权重。
添加边和顶点分两种方式：
1.先添加点，再添加边
Graph g; for (int i=0; i&lt;vertice_num; ++i) { Node onenode; add_vertex(onenode,g); } // 索引属性映射, 可获得顶点的索引属性 property_map&lt;Graph,vertex_index_t&gt;::type index = get(vertex_bundle,g); // 遍历顶点 pair&lt;VertexIterator,VertexIterator&gt; vrange = vertices(g); for (VertexIterator Iter=vrange.first; Iter!=vrange.second; ++Iter) { cout &lt;&lt; index[*Iter] &lt;&lt; ". " &lt;&lt; g[*Iter].m_sName &lt;&lt; endl; } // 添加边 VertexIterator Iter=vrange.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61e84d135fa5af8b9039204a65a538ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a12839438fe7aad6185437be05b29c20/" rel="bookmark">
			Apache james 安装配置手册（稍有改动）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.前期的准备工作
1.操作系统
linux CentOS5.8（其他的版本应该也可以这样操作）
2.搭建工具
jdk 1.7(需要1.4以上的版本)
Mysql 4.1
3.邮件服务器
Apache-James2.3.2
4.中间件
Tomcat5.0.28 如果是CS结构的就不需要中间件了，如果需要中间件的话就是BS结构的,这里我只介绍cs结构的,因为bs结构的还没有试过,时间太短,一个人研究总是花很长时间
5.邮件系统客户端
CS结构：Outlook、Foxmail
BS结构：claros-intouch
6.数据库
Mysql(如果希望邮件服务器的数据以数据库表的的形式存在就需要数据库了,如果以文件的形式存在就不需要数据库了)
二.linux的前期配置
A.&gt;查看域名：
[root@baidu ~]# cat /etc/hosts
# Do not remove the following line, or various programs
# that require network functionality will fail.
127.0.0.1 localhost
192.168.0.8 baidu.com baidu(这是个例子,具体的要看自己去配置)/*因为没有dns域名，我用的是ip地址，10.96.92.94*/
内容格式： 本机的IP地址 域名 主机名
B.&gt;如果没有配置linux系统的主机名和域名就需要配置下，内容如下：/*这一环节之前设定好可不用配置*/
查看network主机名：[root@baidu ~]# cat /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=（localhost）
如果没有配合就用vi命令配置下主机名：
[root@timesafer ~]# vi /etc/sysconfig/network
NETWORKING=yes
HOSTNAME=（localhost）
修改完毕，保存退出 :wq
修改域名hosts： [root@baidu~]# cat /etc/hosts
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a12839438fe7aad6185437be05b29c20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebfa46cbeadc00e82ba41e02eca74079/" rel="bookmark">
			iphone版手机如何安装apk包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前用安卓版的手机测试，了解到可以用数据线连接电脑，再使用360手机卫士就可以连接手机和电脑下载apk包了，还有其他工具，如豌豆荚等。或者是用二维码就可以拿到下载地址，直接去安装了
后来需要测试iphone版的应用，每次都需要开发帮我们安装。今天过去问了一下，原来他们是用Xcode工具，下载回来包。有时间的话，可以学学如何去下载安装ipod机的apk包
转载于:https://blog.51cto.com/chengying/984222
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d97ee89dc48e02d97ee1cef942482ad/" rel="bookmark">
			linux内核空间和用户空间的是怎样区别的，如何交互，如何从用户空间进入内核空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux驱动程序一般工作在内核空间，但也可以工作在用户空间。下面我们将详细解析，什么是内核空间，什么是用户空间，以及如何判断他们。
Linux简化了分段机制，使得虚拟地址与线性地址总是一致，因此，Linux的虚拟地址空间也为0~4G.Linux内核将这4G字节的空间分为两部分。将最高的1G字节(从虚拟地址0xC0000000到0xFFFFFFFF)，供内核使用，称为"内核空间".而将较低的3G字节(从虚拟地址 0x00000000到0xBFFFFFFF)，供各个进程使用，称为"用户空间)。因为每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。
Linux使用两级保护机制：0级供内核使用，3级供用户程序使用。从图中可以看出(这里无法表示图)，每个进程有各自的私有用户空间(0~3G)，这个空间对系统中的其他进程是不可见的。最高的1GB字节虚拟内核空间则为所有进程以及内核所共享。
内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中。
虽然内核空间占据了每个虚拟空间中的最高1GB字节，但映射到物理内存却总是从最低地址(0x00000000)开始。对内核空间来说，其地址映射是很简单的线性映射，0xC0000000就是物理地址与线性地址之间的位移量，在Linux代码中就叫做PAGE_OFFSET.
内核空间和用户空间之间如何进行通讯？
内核空间和用户空间一般通过系统调用进行通信。
如何判断一个驱动是用户模式驱动还是内核模式驱动？ 判断的标准是什么？
用户空间模式的驱动一般通过系统调用来完成对硬件的访问，如通过系统调用将驱动的io空间映射到用户空间等。因此，主要的判断依据就是系统调用。
内核空间和用户空间上不同太多了，说不完，比如用户态的链表和内核链表不一样;用户态用printf,内核态用printk;用户态每个应用程序空间是虚拟的，相对独立的，内核态中却不是独立的，所以编程要非常小心。等等。
还有用户态和内核态程序通讯的方法很多，不单单是系统调用，实际上系统调用是个不好的选择，因为需要系统调用号，这个需要统一分配。
可以通过ioctl、sysfs、proc等来完成。
在进行设备驱动程序，内核功能模块等系统级开发时，通常需要在内核和用户程序之间交换信息。Linux提供了多种方法可以用来完成这些任务。本文总结了各种常用的信息交换方法，并用简单的例子演示这些方法各自的特点及用法。其中有大家非常熟悉的方法，也有特殊条件下方可使用的手段。通过对比明确这些方法，可以加深我们对Linux内核的认识，更重要的是，可以让我们更熟练驾御linux内核级的应用开发技术。
内核空间 (kernel-space) VS 用户空间 (user-space) 作为一个Linux开发者，首先应该清楚内核空间和用户空间的区别。关于这个话题，已经有很多相关资料，我们在这里简单描述如下：
现代的计算机体系结构中存储管理通常都包含保护机制。提供保护的目的，是要避免系统中的一个任务访问属于另外的或属于操作系统的存储区域。如在IntelX86体系中，就提供了特权级这种保护机制，通过特权级别的区别来限制对存储区域的访问。 基于这种构架，Linux操作系统对自身进行了划分：一部分核心软件独立于普通应用程序，运行在较高的特权级别上，（Linux使用Intel体系的特权级3来运行内核。）它们驻留在被保护的内存空间上，拥有访问硬件设备的所有权限，Linux将此称为内核空间。
相对的，其它部分被作为应用程序在用户空间执行。它们只能看到允许它们使用的部分系统资源，并且不能使用某些特定的系统功能，不能直接访问硬件，不能直接访问内核空间，当然还有其他一些具体的使用限制。（Linux使用Intel体系的特权级0来运行用户程序。）
从安全角度讲将用户空间和内核空间置于这种非对称访问机制下是很有效的，它能抵御恶意用户的窥探，也能防止质量低劣的用户程序的侵害，从而使系统运行得更稳定可靠。但是，如果像这样完全不允许用户程序访问和使用内核空间的资源，那么我们的系统就无法提供任何有意义的功能了。为了方便用户程序使用在内核空间才能完全控制的资源，而又不违反上述的特权规定，从硬件体系结构本身到操作系统，都定义了标准的访问界面。关于X86系统的细节，请查阅参考资料1
一般的硬件体系机构都提供一种“门”机制。“门”的含义是指在发生了特定事件的时候低特权的应用程序可以通过这些“门”进入高特权的内核空间。对于IntelX86体系来说，Linux操作系统正是利用了“系统门”这个硬件界面（通过调用int $0x80机器指令)，构造了形形色色的系统调用作为软件界面，为应用程序从用户态陷入到内核态提供了通道。通过“系统调用”使用“系统门”并不需要特别的权限，但陷入到内核的具体位置却不是随意的，这个位置由“系统调用”来指定，有这样的限制才能保证内核安全无虞。我们可以形象地描述这种机制：作为一个游客，你可以买票要求进入野生动物园，但你必须老老实实的坐在观光车上，按照规定的路线观光游览。当然，不准下车，因为那样太危险，不是让你丢掉小命，就是让你吓坏了野生动物。
出于效率和代码大小的考虑，内核程序不能使用标准库函数（当然还有其它的顾虑，详细原因请查阅参考资料2）因此内核开发不如用户程序开发那么方便。
内核空间和用户空间的相互作用 现在，越来越多的应用程序需要编写内核级和用户级的程序来一起完成具体的任务，通常采用以下模式：首先，编写内核服务程序利用内核空间提供的权限和服务来接收、处理和缓存数据；然后编写用户程序来和先前完成的内核服务程序交互，具体来说，可以利用用户程序来配置内核服务程序的参数，提取内核服务程序提供的数据，当然，也可以向内核服务程序输入待处理数据。
比较典型的应用包括: Netfilter(内核服务程序：防火墙)VS Iptable（用户级程序：规则设置程序）；IPSEC(内核服务程序：VPN协议部分)VS IKE(用户级程序：vpn密钥协商处理)；当然还包括大量的设备驱动程序及相应的应用软件。这些应用都是由内核级和用户级程序通过相互交换信息来一起完成特定任务的。
信息交互方法 用户程序和内核的信息交换是双向的，也就是说既可以主动从用户空间向内核空间发送信息，也可以从内核空间向用户空间提交数据。当然，用户程序也可以主动地从内核提取数据。下面我们就针对内核和用户交互数据的方法做一总结、归纳。
信息交互按信息传输发起方可以分为用户向内核传送/提取数据和内核向用户空间提交请求两大类，先来说说：
由用户级程序主动发起的信息交互。
（1）编写自己的系统调用 从前文可以看出，系统调用是用户级程序访问内核最基本的方法。目前linux大致提供了二百多个标准的系统调用，并且允许我们添加自己的系统调用来实现和内核的信息交换。比如我们希望建立一个系统调用日志系统，将所有的系统调用动作记录下来，以便进行入侵检测。此时，我们可以编写一个内核服务程序。该程序负责收集所有的系统调用请求，并将这些调用信息记录到在内核中自建的缓冲里。我们无法在内核里实现复杂的入侵检测程序，因此必须将该缓冲里的记录提取到用户空间。最直截了当的方法是自己编写一个新系统调用实现这种提取缓冲数据的功能。当内核服务程序和新系统调用都实现后，我们就可以在用户空间里编写用户程序进行入侵检测任务了，入侵检测程序可以定时、轮训或在需要的时候调用新系统调用从内核提取数据，然后进行入侵检测(具体步骤和代码参见Linux内核之旅网站电子杂志第四期)。
（2）编写驱动程序 Linux/UNIX的一个特点就是把所有的东西都看作是文件(every thing is a file)。系统定义了简洁完善的驱动程序界面，客户程序可以用统一的方法透过这个界面和内核驱动程序交互。而大部分系统的使用者和开发者已经非常熟悉这种界面以及相应的开发流程了。
驱动程序运行于内核空间，用户空间的应用程序通过文件系统中/dev/目录下的一个文件来和它交互。这就是我们熟悉的那个文件操作流程：open() —— read() —— write() —— ioctl() ——close()。（需要注意的是也不是所有的内核驱动程序都是这个界面，网络驱动程序和各种协议栈的使用就不大一致，比如说套接口编程虽然也有open()和close()等概念，但它的内核实现以及外部使用方式都和普通驱动程序有很大差异。）关于这部分的编程细节，请查阅参考资料3、4。
设备驱动程序在内核中要做的中断响应、设备管理、数据处理等等各种工作这篇文章不去关心，我们把注意力集中在它与用户级程序交互这一部分。操作系统为此定义了一种统一的交互界面，就是前面所说的open(), read(), write(), ioctl()和close()等等。每个驱动程序按照自己的需要做独立实现，把自己提供的功能和服务隐藏在这个统一界面下。客户级程序选择需要的驱动程序或服务（其实就是选择/dev/目录下的文件），按照上述界面和文件操作流程，就可以跟内核中的驱动交互了。其实用面向对象的概念会更容易解释，系统定义了一个抽象的界面（abstract interface），每个具体的驱动程序都是这个界面的实现（implementation）。
所以驱动程序也是用户空间和内核信息交互的重要方式之一。其实ioctl, read, write本质上讲也是通过系统调用去完成的，只是这些调用已被内核进行了标准封装，统一定义。因此用户不必像填加新系统调用那样必须修改内核代码，重新编译新内核，使用虚拟设备只需要通过模块方法将新的虚拟设备安装到内核中（insmod上）就能方便使用。关于此方面设计细节请查阅参考资料5，编程细节请查阅参考资料6。
在linux中，设备大致可分为：字符设备，块设备，和网络接口（字符设备包括那些必须以顺序方式，像字节流一样被访问的设备；如字符终端，串口等。块设备是指那些可以用随机方式，以整块数据为单位来访问的设备，如硬盘等；网络接口，就指通常网卡和协议栈等复杂的网络输入输出服务）。如果将我们的系统调用日志系统用字符型驱动程序的方式实现，也是一件轻松惬意地工作。我们可以将内核中收集和记录信息的那一部分编写成一个字符设备驱动程序。虽然没有实际对应的物理设备，但这并没什么问题：Linux的设备驱动程序本来就是一个软件抽象，它可以结合硬件提供服务，也完全可以作为纯软件提供服务（当然，内存的使用我们是无法避免的）。在驱动程序中，我们可以用open来启动服务，用read()返回处理好的记录，用ioctl()设置记录格式等，用close()停止服务，write()没有用到，那么我们可以不去实现它。然后在/dev/目录下建立一个设备文件对应我们新加入内核的系统调用日志系统驱动程序。
（3） 使用 proc 文件系统 proc是Linux提供的一种特殊的文件系统，推出它的目的就是提供一种便捷的用户和内核间的交互方式。它以文件系统作为使用界面，使应用程序可以以文件操作的方式安全、方便的获取系统当前运行的状态和其它一些内核数据信息。
proc文件系统多用于监视、管理和调试系统，我们使用的很多管理工具如ps,top等，都是利用proc来读取内核信息的。除了读取内核信息，proc文件系统还提供了写入功能。所以我们也就可以利用它来向内核输入信息。比如，通过修改proc文件系统下的系统参数配置文件（/proc/sys），我们可以直接在运行时动态更改内核参数；再如，通过下面这条指令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d97ee89dc48e02d97ee1cef942482ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76d23b06abf3185de67eebd40b54f6b5/" rel="bookmark">
			Shell读文件的几种方法总结（b shell)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文转自：http://www.blogabc.net/i4458_Shell%E8%AF%BB%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88b_shell).html
读文件的方法：
第一步： 将文件的内容通过管道（|）或重定向（&lt;）的方式传给while 第二步： while中调用read将文件内容一行一行的读出来，并付值给read后跟随的变量。变量中就保存了当前行中的内容。 例如读取文件/sites/linuxpig.com.txt 1）管道的方式： cat /sites/linuxpig.com.txt |while read LINE do echo $LINE done 当然也可以将cat /sites/linuxpig.com.txt 写成一些复杂一些的，比如： 示例1： find -type f -name "*.txt" -exec cat |while read LINE do echo $LINE done 可以将当前目录所有以 .txt 结尾的文件读出 示例2： grep -r "linuxpig.com" ./ | awk -F":" '{print $1}' | cat |while read LINE do echo $LINE done 可以将含有 "linuxpig.com" 字符串的所有文件打开并读取。。 示例没有实际测试，如果使用请先测试。。。。。:-) 2）重定向的方式： 2.1 利用重定向符&lt; while read LINE do echo $LINE done &lt; /sites/linuxpig.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76d23b06abf3185de67eebd40b54f6b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8ecfe3726fb0dcfa35b887266f54ecd/" rel="bookmark">
			在开始运行输入CMD回车后，CMD命令黑框框出来闪一下就消失不见了--解决方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何 让 批处理文件 打开后 就进入 当前目录？
在 当前 目录 下 创建 一个 xxx.bat 文件，内容为 cmd，就ok了。
一、首先查看C:\WINDOWS\SYSTEM32下的CMD.EXE是否存在，文件日期是否正常；
检测结果为正常，与其他系统文件日期相同，应该不是这个问题。
二、再查看系统的环境变量，path是否包含如下路径：%SystemRoot%\system32;%SystemRoot%;
查看后发现存在（如果不存在就需加上）
三、看来还不是在上面的两个常见问题，应该是注册表被修改过。最后终于找到了解决办法：
注册表：
HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\AutoRun里的值清空，不能是空格哦!（就是没有数值，而一闪而过可能是EXIST，把他清除即可。）
点击 这里，介绍 批处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1181934fc776ef01d325dafe7ef2c5d6/" rel="bookmark">
			WPF 入门（1）—自定义关闭按钮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标：由于需求界面美观，圆角边距等等，所以整个界面使用背景图，去除自带边框及按钮。
1.去除系统自带边框、按钮。
2.自定义退出按钮，并对退出进行提示框提示，同时解决了Alt+F4退出的不提示的问题。
操作：
设置Window属性 AllowsTransparency="True" 透明
WindowStyle="None" 去除边框
MouseDown="Window_MouseDown" 由于没有边框无法鼠标拖动，所以定义拖动方法
Closing="Window_Closing"&gt; 设置页面关闭触发方法
&lt;Window x:Class="QfpayPC.MainWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" Title="MainWindow" Height="740" Width="936" AllowsTransparency="True" WindowStyle="None" MouseDown="Window_MouseDown" Closing="Window_Closing"&gt; Window_MouseDown：
//界面可以拖动 private void Window_MouseDown(object sender, MouseButtonEventArgs e) { if (e.LeftButton == MouseButtonState.Pressed) { DragMove(); } } Window_Closing：
//退出提示程序 private void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e) { MessageBoxResult result = MessageBox.Show("正在交易中,您真的要退出吗？", "提示", MessageBoxButton.YesNo, MessageBoxImage.Question); if (result == MessageBoxResult.Yes) { Application.Current.Shutdown(); } else { e.Cancel = true; } } 自定义关闭按钮、最小化按钮
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1181934fc776ef01d325dafe7ef2c5d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54b428d12a6bd3a247d1e42f7f03da30/" rel="bookmark">
			解决ssh登录等待时间长的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://hi.baidu.com/curioz/item/278c2e32fdb8bb149dc65ed7
通过ssh远程登录时，有时很快就提示输密码，有时却要等上快一分钟。Google一番后经实践发现主要有两个关键地方，小结一下：
1. DNS (name server) 检查服务器端的 /etc/resolv.conf，看有没有连接不上的地址。如果是内网，可以全部删除。 这个症状是：用ssh -v 登录发现停在debug1: Offering public key: 处。 2. GSSAPIAuthentication 貌似是个 安全性更好 的认证方式，openssh默认在服务器和客户端都会启用。要加快速度可注释掉或改为no 建议在客户端修改 /etc/ssh/ssh_config 当然也可以修改服务器端的 /etc/ssh/sshd_config，并重新载入设置：service sshd reload 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a12266cd084d434538b12d1d56c61a0/" rel="bookmark">
			中文在unicode中的编码范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		喜欢古典小说的 可以关注 头条号 古典小说 公众号 古典小说网
喜欢编程的 可以关注 头条号 讨厌编程
以前写过一篇贴子是写中文在unicode中的编码范围unicode中文范围，但写的不是很详细，今天再次研究了下unicode，并给出详细的unicode取值范围。
本次研究的unicode对象是unicode 5.2.0版本。现在最新的是6.0版
对于这次研究的unicode把编码分为以下几个平面(英文中是plane，可以认为就是不同的区位)
Unicode可以逻辑分为17平面（Plane），每个平面拥有65536（ = 216）个代码点，虽然目前只有少数平面被使用。
平面0 (0000–FFFF): 基本多文种平面（Basic Multilingual Plane, BMP）.
平面1 (10000–1FFFF): 多文种补充平面（Supplementary Multilingual Plane, SMP）.
平面2 (20000–2FFFF): 表意文字补充平面（Supplementary Ideographic Plane, SIP）.
平面3 (30000–3FFFF): 表意文字第三平面（Tertiary Ideographic Plane, TIP）.
平面4 to 13 (40000–DFFFF)尚未使用
平面14 (E0000–EFFFF): 特别用途补充平面（Supplementary Special-purpose Plane, SSP）
平面15 (F0000–FFFFF)保留作为私人使用区（Private Use Area, PUA）
平面16 (100000–10FFFF)，保留作为私人使用区（Private Use Area, PUA）
最有用的当然就是BMP平面０了编码从U+0000至U+FFFF。那里包含了几乎全部的常用字符。
unicode基本平面区的编码区间含义
为鉴于Unicode原有的16位空间不足以应用，于是从Unicode 3.1版本开始，设立了16个扩展字码空间，称为辅助平面，
使 Unicode 的可使用空间由6万多字增至约100万字。辅助平面字符要用上4字节来存储。
unicode中的几大区间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a12266cd084d434538b12d1d56c61a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02350a6777dd884a85d112586bffa962/" rel="bookmark">
			JGit的常用功能（提交、回滚，日志查询）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目中要做一个回滚功能，目的是如果这次发布出现了问题，立马回滚到上一次发布的版本，用jgit实现的，具体方法如下：
public class GitUtil { private final static String GIT = ".git"; /** * 将文件列表提交到git仓库中 * @param gitRoot git仓库目录 * @param files 需要提交的文件列表 * @return 返回本次提交的版本号 * @throws IOException */ public static String commitToGitRepository(String gitRoot, List&lt;String&gt; files) throws Exception { if (StringUtils.isNotBlank(gitRoot) &amp;&amp; files != null &amp;&amp; files.size() &gt; 0) { File rootDir = new File(gitRoot); //初始化git仓库 if (new File(gitRoot + File.separator + GIT).exists() == false) { Git.init().setDirectory(rootDir).call(); } //打开git仓库 Git git = Git.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02350a6777dd884a85d112586bffa962/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4ab82a99185004381bb6a22e61241c7/" rel="bookmark">
			Javascript获取Html界面元素的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Javascript，可以通过多种方式获取Html元素对象。以下是一个Html页面示例。
如果我们需要在javascript中获取输入框age对象。主要的方法有以下几种：
all方法：document.all("age") getElementById方法：document.getElementByIdx_x("age") getElementsByName方法：document.getElementsByName("age") getElementsByTagName方法：document.getElementsByTagName_r("input") form1方法：document.form1.age eval方法：eval_r("document.form1.age") 我们在具体使用时，需要特别注意：all和getElementsByName方法，在界面上没有指定元素时，仍可能会得到object对象。经过分析和验证，主要有以下注意事项：
W3标准下可以通过getElementById、getElementsByName、getElementsByTagName、form1访问Document中的任一个标签。 all：建议尽量不要采用all方法来获取元素, 这种方法不符合W3标准，而且只能在IE或IE内核的浏览器中有效。当界面中没有指定元素时，all方法有时返回null，有的情况下返回object。 getElementById：通过ID来取得Document中的某一特定元素，所以只能访问设置了ID的元素。如果界面中存在多个相同ID的元素，则只取第1个。 getElementsByName：通过Name来获得元素数组，文档中只有一个指定Name的标签时，也返回数组。Document中每一个元素的ID是唯一的，但Name却可以重复。打个比喻就像人的身份证号是唯一的，但名字重复的却很多。 getElementsByTagName：通过TagName（标签名称）来获得元素，一个Document中当然会有相同的标签，所以这个方法也是取得一个数组。 form1：如果文档中只有一个指定Name的标签时，返回该对象；如果文档中有多个指定Name的标签时，返回对象数组。 eval：eval是计算某个字符串，并执行其中的javascript。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e60685843e649ff0d3e20017d0036f69/" rel="bookmark">
			【转】gcc编译错误表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		conversion from %s to %s not supported by iconv”
iconv 不支持从 %s 到 %s 的转换”
iconv_open”
iconv_open”
no iconv implementation, cannot convert from %s to %s”
没有 iconv 的实现，无法从 %s 转换到 %s”
character 0x%lx is not in the basic source character set\n”
字符 0x%lx 不在基本源字符集中\n”
converting to execution character set”
转换到可执行文件的字符集”
character 0x%lx is not unibyte in execution character set”
字符 0x%lx 在执行字符集中不是单字节的”
Character %x might not be NFKC”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e60685843e649ff0d3e20017d0036f69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7cbeb45855381e0cca73c7345b7381f/" rel="bookmark">
			lds 链接脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 笔记1 OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/OUTPUT_ARCH(arm)ENTRY(_start)SECTIONS{. = 0x20008000; #. = ALIGN(4); #四字节对齐 .text :{start/start.o(.text) #取start.o的所有代码段放到 .text段中*(.text) #取所有.o文件的所有代码段放到.text段中}. = ALIGN(4); #字对齐.rodata : { *(.rodata) } #取只读变量放到.rodata段中. = ALIGN(4); #字对齐.data : { *(.data) } #将读写数据放到.data段中. = ALIGN(4); #字对齐.bss :{ *(.bss) } #　BSS（Block Started by Symbol）通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aef15b90136406773e904364643d6b6/" rel="bookmark">
			led 工程 makefile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# CORTEX-A8 PERI DRIVER CODE# VERSION 1.0# ATHUOR lapset (klapset@gmail.com)# MODIFY DATE #	2012.2.22 by lapset ,to change the format of Makefile#NOTE :please fix the following info to adpat to your environmentCROSS_COMPILE=arm-none-eabi-LDPATH="C:\Program Files\yagarto\lib\gcc\arm-none-eabi\4.6.2\include"OUTPATH=/mnt/hgfs/shareNAME=ledCOMMONPATH = "D:\eclipse_projects\LED\common\include"#=============================================================================##DO NOT TO CHANG THE CODE AFTER THIS !!!export CFLAGS LD CC STRIP OBJCOPY OBJDUMP COMMONPATHCFLAGS += -g -O0 -fno-strict-aliasing -mabi=apcs-gnu -mfpu=vfpv3 -mfloat-abi=softfp -fno-builtin -nostdinc -isystem $(LDPATH) -I $(COMMONPATH) LD	= $(CROSS_COMPILE)ldCC	= $(CROSS_COMPILE)gcc-4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aef15b90136406773e904364643d6b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d51d6d6f7aba13b4cffa34af7cdc9b58/" rel="bookmark">
			----Dell power adaptor 问题！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://techmonks.net/bypassing-the-dell-unrecognized-adapter-issue/
戴尔原来有这样的问题，我侄子的 Inspiron 640m，根据这个帖子解决了！
Under Linux:
processor.ignore_ppc=1 kernel parameter cmd line
Under Window:
rmclock[gui] 用了一下，界面比较复杂的工具，整了半天反正可以了，不知自己都干了些什么！
转载于:https://www.cnblogs.com/bzhao/archive/2012/07/21/2602397.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d7d42846cac794161a2344ff2e9b290/" rel="bookmark">
			50Hz工频干扰消除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天整理工频干扰消除算法。
我们知道，设计数字滤波器，和模拟滤波器的实质，其实就是求一组系数，逼近要求的频率响应。
模拟滤波器已经很成熟，因此，数字滤波器的设计，将S平面映射到Z平面就型。采用双线性变化法映射，可以避免多值映射产生的混叠现象。但这有个问题就，模拟域和数字域两者的角频率是非线性的。
1.平滑滤波器是数字滤波中较早使用的方法，该算法简单，处理速度快，滤波效果较好，但存在明显不足，通带较窄，影响有用信号的分析，有严重削峰，设计方法略。
然后，我们根据IIR和FIR分两大类。FIR滤波器，可以得到严格的线性相位，但它的转移函数的极点固定在原点，只能通过改变零点位置来改变性能。为了达到高的选择性，必须使用高阶。相同设计指标下，FIR滤波器的阶数是IIR滤波器的5~10倍。而IIR滤波器可以根据模拟滤波器的设计公式，数据和表格，计算量小。
首先介绍IIR类，即两种形式的notch滤波器。
2.陷波器 notch 滤波器
陷波器，是IIR数字滤波器，有signal notch 滤波器，即单一频率陷波器，以及comb notch滤波器，即梳妆滤波器。
陷波器是无限冲击响应(IIR)数字滤波器，该滤波器可以用以下常系数线性差分方程表示：
式中： x(n)和y(n)分别为输人和输出信号序列； ai和bi为滤波器系数。
对式(1)两边进行z变换，得到数字滤波器的传递函数为：
式中： zi和pi分别为传递函数的零点和极点。
由传递函数的零点和极点可以大致绘出频率响应图。在零点处，频率响应出现极小值；在极点处，频率响应出现极大值。因此可以根据所需频率响应配置零点和极点，然后反向设计带陷数字滤波器。
2.1 signal notch 滤波器
考虑一种特殊情况，若零点 在第1象限单位圆上，极点在单位圆内靠近零点的径向上。为了防止滤波器系数出现复数，必须在z平面第4象限对称位置配置相应的共轭零点 、共轭极点 。其极零图如下所示：
这样零点、极点配置的滤波器称为单一频率陷波器，在频率ωo处出现凹陷。而把极点设置在零的的径向上距圆点的距离为l-μ处，陷波器的传递函数为：
式(3)中μ越小，极点越靠近单位圆，则频率响应曲线凹陷越深，凹陷的宽度也越窄。当需要消除窄带干扰而不能对其他频率有衰减时，陷波器是一种去除窄带干扰的理想数字滤波器。
当要对几个频率同时进行带陷滤波时，可以按(2)式把几个单独频率的带陷滤波器(3)式串接在一起。
假设有一个输入，它由50Hz信号和100Hz信号组成。50Hz是一个干扰信号，要设计一个50 Hz的带陷滤波器，采样频率为500Hz。
转移函数：
根据极零关系，取μ = 0.001，则得到z = 0.809 + j * 0.588，z* = 0.809 - j * 0.588，p = 0.8082 + j * 0.5872，p* = 0.8082 - j * 0.5872
代入转移函数，得到分子系数[1, 1.618, 1],分母系数[1,1.6164,0.999] 相应的差分方程：
2.2 comb notch 滤波器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d7d42846cac794161a2344ff2e9b290/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/368e4306300c7d3253ba5d3dfbb4174e/" rel="bookmark">
			在C/C&#43;&#43;程序里打印调用栈信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们知道，GDB的backtrace命令可以查看堆栈信息。但很多时候，GDB根本用不上。比如说，在线上环境中可能没有GDB，即使有，也不太可能让我们直接在上面调试。如果能让程序自己输出调用栈，那是最好不过了。本文介绍和调用椎栈相关的几个函数。
NAME
backtrace, backtrace_symbols, backtrace_symbols_fd - support for application self-debugging
SYNOPSIS
#include &lt;execinfo.h&gt;
int backtrace(void **buffer, int size);
char **backtrace_symbols(void *const *buffer, int size);
void backtrace_symbols_fd(void *const *buffer, int size, int fd);
以上内容源自这几个函数的man手册。
先简单介绍一下这几个函数的功能：
l backtrace：获取当前的调用栈信息，结果存储在buffer中，返回值为栈的深度，参数size限制栈的最大深度，即最大取size步的栈信息。
l backtrace_symbols：把backtrace获取的栈信息转化为字符串，以字符指针数组的形式返回，参数size限定转换的深度，一般用backtrace调用的返回值。
l backtrace_symbols_fd：它的功能和backtrace_symbols差不多，只不过它不把转换结果返回给调用方，而是写入fd指定的文件描述符。
Man手册里，给出了一个简单的实例，我们看一下：
#include&lt;execinfo.h&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;unistd.h&gt;
void
myfunc3(void)
{
int j, nptrs;
#define SIZE 100
void *buffer[100];
char **strings;
nptrs = backtrace(buffer, SIZE);
printf("backtrace() returned %d addresses\n", nptrs);
/* The call backtrace_symbols_fd(buffer, nptrs, STDOUT_FILENO)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/368e4306300c7d3253ba5d3dfbb4174e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dff0e85e7e32c45eab572f38d4e3eb2/" rel="bookmark">
			SOCKS5 Server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Socks5。Socks是个电路级网关，由David
Koblas在1990年开发。此后，就一直作为Internet RFC（Request for
Comments）中的开放标准。Socks在协议栈的TCP层上运行。Socks代理只是简单地传递数据包，而不必关心是何种应用协议（比如FTP、HTTP和NNTP请求）。
Socks5代理支持TCP和UDP协议，而且还支持各种身份验证机制、服务器端域名解析等，socks5通过配置可以支持socks4。我们平时使用的Internet
Explorer、QQ等软件都支持socks代理设置。
Red Hat Linux本身并不带socks5的rpm软件包，但可以从网上下载：
http://ftp.falsehope.com/home/gomez/socks5/socks5-1.0r11-3.i386.rpm
我们主要通过socks5.conf
文件来配置socks5服务器。缺省路径为：/etc/socks5.conf。在/usr/doc/socks5-1.0r11/examples目录
下有socks5的配置示例（注意是/usr/doc/而不是/usr/share/doc/）。
§§　socks5.conf的配置选项
socks5.conf通常由以下几个方面的内容构成：
－ban host：定义拒绝服务的客户列表
－authentication：定义Socks5服务器使用的用户认证方法
－interface：定义Socks5服务器绊定的ip地址和服务端口
－variables and flags：定义Socks5服务器运行的环境
－proxies：定义客户可以通过Socks5服务器访问的地址列表以及Socks5服务器访问这些地址的方法
－access control：定义Socks5服务器接受或拒绝客户连接的规则
下面我们分别来讲述这些条目对应的语法：
ban host
语法：ban source-host source-port
说明：Socks5服务器将拒绝接受来自source-host:source-port的客户连接。
authentication
语法：auth source-host source-port auth-methods
说明：对于来自source-host:source-port的客户连接，Socks5服务器将使用
auth-methods所定义的用户认证方法。对于没有定义认证方法的客户将使用任何可以使用的认证方法。
interface
语法：interface hostpatern portpattern interface-address
说明：来自source-host:source-port的客户连接由interface-address处理；目的地址为source-host:source-port的客户连接由Socks5
代理服务器从 interface-address发出连接请求。
variables
语法：set variable value
说明：定义Socks5运行参数，Socks5有以下一些常用的运行参数：
SOCKS5_BINDINTFC host:port
host:port
指定socks5运行的主机和端口号，用于代替缺省的端口。忽略时，socks5用0.0.0.0作为主机值。
SOCKS5_CONFFILE filename
Filename
指定配置文件。在许多系统中，缺省是/etc/socks5.conf。在运行socks5之前，设置这个变量。如果有多个socks5
daemon运行，为每个daemon使用不同的配置文件。
SOCKS5_DEMAND_IDENT
当客户没有响应ident
请求时，认证失败。使用SOCKS5_DEMAND_IDENT确认每个连接有一个关联的用户名。
SOCKS_ENCRYPT
如果可能的话，请求下一个socks5进程加密数据。SOCKS5_ENCRYPT
仅仅在编译socks5时包括了GSS-API认证时，才有意义。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dff0e85e7e32c45eab572f38d4e3eb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4e8ee246f218a4df4760b9953fced4d/" rel="bookmark">
			网络 进程 socket
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		共享内存：（最快） 常用的命令 ipcs ipcrm ipcmk include &lt;errno.h&gt;用以下面判断是否key已经先建立 if(errno == EEXIST){说明已经被对方建好，这里加上处理函数，比如shmat....} 一般先用ftok建立key 创建/打开共享内存shmget(key_t key, size_t size, int shmflg);注意读写者的第三个参数0666| IPC_CREAT | IPC_EXCL /*fail if key exists*/0666是ipcs 中的perms 属性 映射共享内存 shmat (p = (SHM *)shmat(shmid, NULL, 0)) == (SHM *)-1 获取对象的属性struct shmid_ds buf (shmctl(shmid, IPC_STAT, &amp;buf) == -1) 撤销共享内存映射 shmat 删除对象shmctl(shmid, IPC_RMID, NULL) == -1 脱离共享内存 deattch shmdt 当有多个读写者连上 共享内存时，struct shmid_ds buf。if（Buf.shm_nattch==0） 判断连接数目当没有了再删除对象 (shmctl(shmid, IPC_RMID, NULL) == -1) 当有几个读者的时候，能几个读者共同读到呢？？ 信号灯： 常与共享内存一起用,可以实现P V的强大操作。对多种资源进行操作多个可以利用 int semop(int semid, struct sembuf *sops, unsigned nsops); 没有mask命令 只有umask 这个是屏蔽码。哪位为1则屏蔽哪位 大端：高字节存在低位 （刚开始的端口是大的）同下为78563412 小端：低字节存在低位 （端口是小的）若 i=0x78563412 则利用p++输出为12345678 我们的电脑经常是小端：所以需要转化成网络字节序（网络字节序是大段） 小端上192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4e8ee246f218a4df4760b9953fced4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/854830c6e10388d06e1d34c96401ad1b/" rel="bookmark">
			Javascript实现单链表简单操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述：
试用传引用方法，实现链表增加，移除，查找操作。
知识点：
javascript的function实现了类的封装
代码：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script type = "text/javascript"&gt; var array = new Array(1,2,3,4,5,6); var Node = function(newData){ this.next = null; this.data = null; this.Init = function(){ this.data = newData; }; this.Init(); } //definition of List class var List = function(){ this.head = null; this.size = 0; this.Init = function(){ this.head = null; this.size = 0; } this.Init(); this.Insert = function(newData){ this.size += 1; var newNode = new Node(newData); if(this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/854830c6e10388d06e1d34c96401ad1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40b990f5e48d9605d61c185d7cb83212/" rel="bookmark">
			ubuntu进不了图形界面 一种恢复方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开虚拟机的时候因为compiz老是和系统冲突 就用了几次 compiz --replace 和 compiz --replace --display :0.0 甚至用上了nvidia重新配置的命令
查看了系统的日志文件Xorg.0.log 发现一个Screen(s) found, but none have a usable configuration的错误于是乎 重新生成了 nvidia -config (xorg.conf 文件)(在./etc/X11下面)相比较只是少了个Modes "1366*768"其他一模一样
在一个设置允许客户访问账户的文件里（/etc/lightdm/lightdm.conf）发现多了个没有赋值的自动登录界面。于是删除之（怀疑是tweak中设置造成的）
将以～/。命名的文件先备份然后删除发现，可以进入图形界面于是开始一个一个的排除到底是哪个文件惹的货。最后发现
一个叫./.Xauthority（ startx脚本记录文件）的文件属性组全变成root，导致进不了图形界面的系统，改回来就对了
将其改成普通用户后能进入图形界面，我猜是前面用超级用户运行 ...-display :0.0导致这个文件的属性的改变 现在唯一不一样的就是登录帐号后屏幕先淡白一下再进入界面
多重启几下用低配置的图形界面进入一次，再次发现Screen(s) found, but none have a usable configuration这个错误，不管.再次登录发现原来ccsm的配置全部回来了，效果正常恢复 先前出现的淡白色已经消失，再次重启发现看似一切正常恢复。辛苦2天终于避免删除账户的困扰 最后总结：可能前面有在tty1使用compiz --replace --display :0.0不小心引起文件属性组的改变
日志文件越来越多于是删除了后缀为log.1的文件，清空了些.log的日志文件，常用到的命令是 du -ah | sort -r -n -k 1 | less查看文件大小的排列
chown user:dir_or_file -R 用以将另一个帐号的一些配置文件移过来用
在~/.nv 下发现GLCache有14M与另一个用户的几百k有太大差距，这个是否应该删除呢？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a43f20e69484ccf15c3f84baeeab9b5/" rel="bookmark">
			String.valueOf() 方法的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 由 基本数据型态转换成 String String 类别中已经提供了将基本数据型态转换成 String 的 static 方法 也就是 String.valueOf() 这个参数多载的方法 有下列几种 String.valueOf(boolean b) : 将 boolean 变量 b 转换成字符串 String.valueOf(char c) : 将 char 变量 c 转换成字符串 String.valueOf(char[] data) : 将 char 数组 data 转换成字符串 String.valueOf(char[] data, int offset, int count) : 将 char 数组 data 中 由 data[offset] 开始取 count 个元素 转换成字符串 String.valueOf(double d) : 将 double 变量 d 转换成字符串 String.valueOf(float f) : 将 float 变量 f 转换成字符串 String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a43f20e69484ccf15c3f84baeeab9b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cffb1ea0d241100d086a333553db452/" rel="bookmark">
			打开【SQL Server 配置管理器】提示：无法连接到 WMI 提供程序。您没有权限或者该服......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 打开【SQL Server 配置管理器】提示：无法连接到 WMI 提供程序。您没有权限或者该服务器无法访问。请注意，您只能使用 SQL Server 配置管理器来管理 SQL Server 2005 服务器。 ---------------------------
SQL Server 配置管理器
---------------------------
无法连接到 WMI 提供程序。您没有权限或者该服务器无法访问。请注意，您只能使用 SQL Server 配置管理器来管理 SQL Server 2005 服务器。 找不到指定的模块。 [0x8007007e]
---------------------------
确定 ---------------------------
今天发现这个问题，能及时解决心情很高兴，解决方法也是从网上Google的。整理分享一下。呵呵
方法1.在C:\WINDOWS\system32中搜索是否有framedyn.dll这个系统文件，如果没有，到system32 下的wbem文件中拷贝framedyn.dll到system32 目录下。再次进入配置管理器。
不行，就进行第二方法
方法2.以管理员身份运行“命令提示符”（在附件下面），进入后执行以下命令
1)cd /d C:\Program Files\Microsoft SQL Server\90\Shared
2)mofcomp "C:\Program Files\Microsoft SQL Server\90\Shared\sqlmgmproviderxpsp2up.mof"
提示：
正在分析 MOF 文件: C:\Program Files\Microsoft SQL Server\90\Shared\sqlmgmprovide
rxpsp2up.mof
MOF 文件分析成功
将数据储存到储存库中...
完毕！
注意，如果在执行第二条命令时提示，'mofcomp'不是内部或外部命令，也不是可运行的程序或批处理文件。
在桌面上右击我的电脑-属性-高级选项-环境变量-系统变量中path中编辑在后面加：;%SystemRoot%\System32\Wbem;就OK了。
方法3：1 右击“我的电脑”--&gt;“管理” 2 在“本地用户和组”内的Administrators组上双击，出现添加属性对话框。 3 单击“添加”按钮，出现添加用户对话框 4 单击“高级”按钮，再单击“搜索”（或是“立即查找”）按钮。注：此'NT AUTHORITY\NETWORK SERVICE'用户为系统内置帐户，无法直接添加。 5 在“搜索结果”内选择“Network Service”用户后，单击“确定” 转载于:https://my.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cffb1ea0d241100d086a333553db452/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9d798c28a615a974557412e55fbd0e5/" rel="bookmark">
			父进程结束后，子进程自动结束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5三/12 27 Linux下让父进程结束后，子进程自动结束 在多进程编程的时候，经常会遇到这样的情况。父进程创建了一堆子进程，当遇到错误或者操作失误的时候把父进程关闭了，但是子进程还在跑，不得不一个一个地杀死子进程，或者使用ps,grep,awk,kill来配合批量杀死。
之前在写 xxfpm（一个PHP-CGI的进程管理） 的时候，在Linux下使用父进程给子进程信号通知的方式来达到用户杀死父进程时，子进程也随即关闭。但是这种方法不太完美。例如，如果父进程被KILL信号杀死，完全没有机会给子进程发送信号了。
在网上搜了一下，用Linux下libc的prctl设置PR_SET_PDEATHSIG属性，似乎可以让子进程在父进程自动结束后接收到信号。这个方法似乎很完美！！！
PR_SET_PDEATHSIG (since Linux 2.1.57) Set the parent process death signal of the calling process to arg2 (either a signal value in the range 1..maxsig, or 0 to clear). This is the signal that the calling process will get when its parent dies. This value is cleared for the child of a fork(2). 测试代码：
view plain copy to clipboard print ? #!/usr/bin/env python import os import ctypes import time libc = ctypes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9d798c28a615a974557412e55fbd0e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/656de0b1b144104c5053ec1ed1c1a1fe/" rel="bookmark">
			特殊符号大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		特殊符号
! " # $ % &amp; ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; &lt; = &gt; @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ ￠ ￡ ¤ ￥ | § ¨ a - ˉ ° ± 2 3 ′ μ · 1 o à á è é ê ì í D ò ó × ù ú ü Y T à á a è é ê ì í e ò ó ÷ ù ú ü y t ā ā ē ē ě ě ī ī ń ň ō ō ū ū ∥ ǎ ǎ ǐ ǐ ǒ ǒ ǔ ǔ ǖ ǖ ǘ ǘ ǚ ǚ ǜ ǜ ɑ ɡ ˇ ˉ ˊ ˋ ˙ Α Β Γ Δ Ε Ζ Η Θ Ι Κ Λ Μ Ν Ξ Ο Π Ρ Σ Τ Υ Φ Χ Ψ Ω α β γ δ ε ζ η θ ι κ λ μ ν ξ ο π ρ σ τ υ φ χ ψ ω Ё А Б В Г Д Е Ж З И Й К Л М Н О П Р С Т У Ф Х Ц Ч Ш Щ Ъ Ы Ь Э Ю Я а б в г д е ж з и й к л м н о п р с т у ф х ц ч ш щ ъ ы ь э ю я ё‐ – — ― ‖ ‘ ’ “ ” ‥ … ‰ ′ ″ ‵ ※ ￣ € ℃ ℅ ℉ № ℡ Ⅰ Ⅱ Ⅲ Ⅳ Ⅴ Ⅵ Ⅶ Ⅷ Ⅸ Ⅹ Ⅺ Ⅻ ⅰ ⅱ ⅲ ⅳ ⅴ ⅵ ⅶ ⅷ ⅸ ⅹ ← ↑ → ↓ ↖ ↗ ↘ ↙ ∈ ∏ ∑ ∕ ° √ ∝ ∞ ∟ ∠ ∣ ∥ ∧ ∨ ∩ ∪ ∫ ∮ ∴ ∵ ∶ ∷ ～ ∽ ≈ ≌ ≒ ≠ ≡ ≤ ≥ ≦ ≧ ≮ ≯ ⊕ ⊙ ⊥ ⊿ ⌒ ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ─ ━ │ ┃ ┄ ┅ ┆ ┇ ┈ ┉ ┊ ┋ ┌ ┍ ┎ ┏ ┐ ┑ ┒ ┓ └ ┕ ┖ ┗ ┘ ┙ ┚ ┛ ├ ┝ ┞ ┟ ┠ ┡ ┢ ┣ ┤ ┥ ┦ ┧ ┨ ┩ ┪ ┫ ┬ ┭ ┮ ┯ ┰ ┱ ┲ ┳ ┴ ┵ ┶ ┷ ┸ ┹ ┺ ┻ ┼ ┽ ┾ ┿ ╀ ╁ ╂ ╃ ╄ ╅ ╆ ╇ ╈ ╉ ╊ ╋ ═ ║ ╒ ╓ ╔ ╕ ╖ ╗ ╘ ╙ ╚ ╛ ╜ ╝ ╞ ╟ ╠ ╡ ╢ ╣ ╤ ╥ ╦ ╧ ╨ ╩ ╪ ╫ ╬ ╭ ╮ ╯ ╰ ╱ ╲ ╳ ▁ ▂ ▃ ▄ ▅ ▆ ▇ █ ▉ ▊ ▋ ▌ ▍ ▎ ▏ ▓ ▔ ▕■ □ ▲ △ ▼ ▽ ◆ ◇ ○ ◎ ● ◢ ◣ ◤ ◥ ★ ☆ ☉ ♀ ♂、 。 〃 々 〆 〇 〈 〉 《 》 「 」 『 』 【 】 〒 〓 〔 〕 〖 〗 〝 〞 〡 〢 〣 〤 〥 〦 〧 〨 〩 ぁ あ ぃ い ぅ う ぇ え ぉ お か が き ぎ く ぐ け げ こ ご さ ざ し じ す ず せ ぜ そ ぞ た だ ち ぢ っ つ づ て で と ど な に ぬ ね の は ば ぱ ひ び ぴ ふ ぶ ぷ へ べ ぺ ほ ぼ ぽ ま み む め も ゃ や ゅ ゆ ょ よ ら り る れ ろ ゎ わ ゐ ゑ を ん ゛ ゜ ゝ ゞ ァ ア ィ イ ゥ ウ ェ エ ォ オ カ ガ キ ギ ク グ ケ ゲ コ ゴ サ ザ シ ジ ス ズ セ ゼ ソ ゾ タ ダ チ ヂ ッ ツ ヅ テ デ ト ド ナ ニ ヌ ネ ノ ハ バ パ ヒ ビ ピ フ ブ プ ヘ ベ ペ ホ ボ ポ マ ミ ム メ モ ャ ヤ ュ ユ ョ ヨ ラ リ ル レ ロ ヮ ワ ヰ ヱ ヲ ン ヴ ヵ ヶ ー ヽ ヾ ㄅ ㄆ ㄇ ㄈ ㄉ ㄊ ㄋ ㄌ ㄍ ㄎ ㄏ ㄐ ㄑ ㄒ ㄓ ㄔ ㄕ ㄖ ㄗ ㄘ ㄙ ㄚ ㄛ ㄜ ㄝ ㄞ ㄟ ㄠ ㄡ ㄢ ㄣ ㄤ ㄥ ㄦ ㄧ ㄨ ㄩ ㈠ ㈡ ㈢ ㈣ ㈤ ㈥ ㈦ ㈧ ㈨ ㈩ ㈱ ㊣ ㎎ ㎏ ㎜ ㎝ ㎞ ㎡ ㏄ ㏎ ㏑ ㏒ ㏕                                        ︰ ︱ ︳ ︴ ︵ ︶ ︷ ︸ ︹ ︺ ︻ ︼ ︽ ︾ ︿ ﹀ ﹁ ﹂ ﹃ ﹄ ﹉ ﹊ ﹋ ﹌ ﹍ ﹎ ﹏ ﹐ ﹑ ﹒ ﹔ ﹕ ﹖ ﹗ ﹙ ﹚ ﹛ ﹜ ﹝ ﹞ ﹟ ﹠ ﹡ ﹢ ﹣ ﹤ ﹥ ﹦ ﹨ ﹩ ﹪ ﹫ ！ ＂ ＃ ＄ ％ ＆ ＇ （ ） ＊ ＋ ， － ． ／ ０ １ ２ ３ ４ ５ ６ ７ ８ ９ ： ； ＜ ＝ ＞ ？ ＠ Ａ Ｂ Ｃ Ｄ Ｅ Ｆ Ｇ Ｈ Ｉ Ｊ Ｋ Ｌ Ｍ Ｎ Ｏ Ｐ Ｑ Ｒ Ｓ Ｔ Ｕ Ｖ Ｗ Ｘ Ｙ Ｚ ［ ＼ ］ ＾ ＿ ｀ ａ ｂ ｃ ｄ ｅ ｆ ｇ ｈ ｉ ｊ ｋ ｌ ｍ ｎ ｏ ｐ ｑ ｒ ｓ ｔ ｕ ｖ ｗ ｘ ｙ ｚ ｛ ｜ ｝ ～ ￠ ￡ ￢ ￣ ￤ ￥ 特殊文字
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/656de0b1b144104c5053ec1ed1c1a1fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff01c49a090eee24ea37879065a592ff/" rel="bookmark">
			OnContextMenu 响应鼠标右键菜单消息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 WM_CONTEXTMENU消息 用来响应鼠标右键消息， 它响应的不是鼠标右键按下消息，也不是鼠标右键弹起消息
而是鼠标右键 依次按下弹起后触发的消息。
因此，若程序还响应了鼠标右键按下的消息OnRButtonDown，且在此响应函数中有模特对话框出现的话，则不会响应WM_CONTEXTMENU消息。
比如，有AfxMessageBox(L"Right Down"); 模特对话框出现在右键按下响应函数中， 则关闭此模特对话框后，不在响应右键菜单消息。
原因在于：
右键菜单 是在右键依次按下弹起时才被触发的。
右键按下， 模特对话框产生时，消息只被发送到了模特对话框，因此，鼠标弹起消息未被发送到主窗口，因此，不会响应右键菜单消息。
但是，如果在右键弹起响应函数OnRButtonUp中响应模特对话框消息的话， 右键菜单消息 不会被影响。
原因是： 此时鼠标按下、弹起消息均已被发送到了主窗口，因此程序在关闭模特对话框后，仍会响应右键菜单消息。
OnContextMenu(CWnd* pWnd, CPoint point){CPoint pt=point;CMenu menu;CMenu* PopupMenu=NULL;ScreenToClient(&amp;pt);//加载菜单menu.LoadMenu(IDR_IMAGEVIEW);//子菜单项//右键点击 弹出此子菜单项PopupMenu=menu.GetSubMenu(3);PopupMenu-&gt;TrackPopupMenu(TPM_RIGHTBUTTON | TPM_LEFTALIGN,point.x,point.y,this);} 参考资料：
http://topic.csdn.net/t/20061114/18/5157800.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adbfca66ec5100439ed0e22297a8df4d/" rel="bookmark">
			pthread_create线程创建的过程剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述
在Linux环境下，pthread库提供的pthread_create()API函数，用于创建一个线程。线程创建失败时，它可能会返回ENOMEM或EAGAIN。这篇文章主要讨论线程创建过程中碰到的一些问题和解决方法。
创建线程
首先，本文用的实例代码example.c:
/* example.c*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
void thread(void)
{
int i;
for(i=0;i&lt;3;i++)
printf("This is a pthread.\n");
sleep(30);
}
int main(int argc,char **argv)
{
pthread_t id;
int i,ret;
ret=pthread_create(&amp;id,NULL,(void *) thread,NULL);
if(ret!=0){
printf ("Create pthread error!\n");
exit (1);
}
for(i=0;i&lt;3;i++)
printf("This is the main process.\n");
pthread_join(id,NULL);
return 0;
}
编译，执行下面命令：
# example.c -lpthread -o example -g
用strace工具跟踪线程创建的过程：
# strace ./example
Strace工具输出：
getrlimit(RLIMIT_STACK, {rlim_cur=10240*1024, rlim_max=RLIM_INFINITY}) = 0 uname({sys="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adbfca66ec5100439ed0e22297a8df4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7c217f13df3d254e61b0b58c04ae51a/" rel="bookmark">
			Regular DLL(MFC规则DLL)、MFC...Extension DLL(MFC扩展DLL 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 、Non-MFC DLL:指的是不用MFC的类库结构，直接用C语言写的DLL，其输出的函数一般用的是标准C接口，并能被非MFC或MFC编写的应用程序所调用。 b、Regular DLL:和下述的Extension Dlls一样，是用MFC类库编写的。明显的特点是在源文件里有一个继承CWinApp的类。其又可细分成静态连接到MFC和动态连接到MFC上的。 静态连接到MFC的动态连接库只被VC的专业般和企业版所支持。该类DLL应用程序里头的输出函数可以被任意Win32程序使用，包括使用MFC的应用程序。输入函数有如下形式： extern "C " EXPORT YourExportedFunction( ); 如果没有extern “C”修饰，输出函数仅仅能从C++代码中调用。 DLL应用程序从CWinApp派生，但没有消息循环。 动态链接到MFC的规则DLL应用程序里头的输出函数可以被任意Win32程序使用，包括使用MFC的应用程序。但是，所有从DLL输出的函数应该以如下语句开始： AFX_MANAGE_STATE(AfxGetStaticModuleState( )) 此语句用来正确地切换MFC模块状态。 Regular DLL能够被所有支持DLL技术的语言所编写的应用程序所调用。在这种动态连接库中，它必须有一个从CWinApp继承下来的类，DllMain函数被MFC所提供，不用自己显式的写出来。 c、Extension DLL:用来实现从MFC所继承下来的类的重新利用，也就是说，用这种类型的动态连接库，可以用来输出一个从MFC所继承下来的类。它输出的函数仅可以被使用MFC且动态链接到MFC的应用程序使用。可以从MFC继承你所想要的、更适于你自己用的类，并把它提供给你的应用程序。你也可随意的给你的应用程序提供MFC或MFC继承类的对象指针。Extension DLL使用MFC的动态连接版本所创建的，并且它只被用MFC类库所编写的应用程序所调用。Extension DLLs 和Regular DLLs不一样，它没有一个从CWinApp继承而来的类的对象，所以，你必须为自己DllMain函数添加初始化代码和结束代码。 和规则DLL相比，有以下不同： 1、它没有一个从CWinApp派生的对象； 2、它必须有一个DllMain函数； 3、DllMain调用AfxInitExtensionModule函数，必须检查该函数的返回值，如果返回0，DllMmain也返回0； 4、如果它希望输出CRuntimeClass类型的对象或者资源(Resources)，则需要提供一个初始化函数来创建一个CDynLinkLibrary对象。并且，有必要把初始化函数输出； 5、使用扩展DLL的MFC应用程序必须有一个从CWinApp派生的类，而且，一般在InitInstance里调用扩展DLL的初始化函数。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56a4c9ff2eadaadc9df41e7eb89f973e/" rel="bookmark">
			CSS 元素垂直居中的 6种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://blog.zhourunsheng.com/2012/03/css-%E5%85%83%E7%B4%A0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84-6%E7%A7%8D%E6%96%B9%E6%B3%95/ 利用CSS进行元素的水平居中，比较简单，行级元素设置其父元素的text-align center，块级元素设置其本身的left 和 right margins为auto即可。本文收集了六种利用css进行元素的垂直居中的方法，每一种适用于不同的情况，在实际的使用过程中选择某一种方法即可。 Line-Height Method 试用：单行文本垂直居中，demo
代码：
html
&lt;div id="parent"&gt; &lt;div id="child"&gt;Text here&lt;/div&gt; &lt;/div&gt; css
#child { line-height: 200px; }垂直居中一张图片，代码如下 html
&lt;div id="parent"&gt; &lt;img src="image.png" alt="" /&gt; &lt;/div&gt;css #parent { line-height: 200px; } #parent img { vertical-align: middle; } CSS Table Method 适用：通用，demo
代码：
html
&lt;div id="parent"&gt; &lt;div id="child"&gt;Content here&lt;/div&gt; &lt;/div&gt; css
#parent {display: table;} #child { display: table-cell; vertical-align: middle; } 低版本 IE fix bug： #child { display: inline-block; } Absolute Positioning and Negative Margin 适用：块级元素，demo
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56a4c9ff2eadaadc9df41e7eb89f973e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb99914192d1b725bd78dfe504431649/" rel="bookmark">
			命令后台执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后台执行命令： ctrl+z 把命令发到后台执行： 命令 &amp; (就是命令后面加上空格和“&amp;”） 将后台命令放到前台执行： fg + 数字（这个数字就是后台运行的数字，使用jobs可以查看） nohup(不挂断的运行命令） 如果终端断掉，需要命令仍然在后台运行则需要加上nohup nohup /root/test.php&amp; jobs查看后台运行程序 来自 “ ITPUB博客 ” ，链接：http://blog.itpub.net/22934571/viewspace-731392/，如需转载，请注明出处，否则将追究法律责任。 转载于:http://blog.itpub.net/22934571/viewspace-731392/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a787f6ad607d4eec21e7da5baf4adf65/" rel="bookmark">
			查看ASM_diskgroup ,asm_disk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看ASM_DISKGROUP select * from v$asm_diskgroup 查看 asm_disk 查看asm_disk SQL&gt; select group_number, disk_number, mount_status, header_status, name, path from v$asm_disk; GROUP_NUMBER DISK_NUMBER MOUNT_STATUS HEADER_STATUS NAME PATH ------------ ----------- --------------- --------------- ---------- -------------------- 0 0 CLOSED CANDIDATE /dev/rdsk/c2t0d3s0 0 3 CLOSED CANDIDATE /dev/rdsk/c2t0d3 0 2 CLOSED CANDIDATE /dev/rdsk/c2t0d3s6 0 1 CLOSED CANDIDATE /dev/rdsk/c2t0d3s1 来自 “ ITPUB博客 ” ，链接：http://blog.itpub.net/22934571/viewspace-731377/，如需转载，请注明出处，否则将追究法律责任。 转载于:http://blog.itpub.net/22934571/viewspace-731377/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fafc647cc22066802ddeae5dd8ca9485/" rel="bookmark">
			lucene、lucene.NET详细使用与优化详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 1 lucene简介ITPUB个人空间 f F M A \5M S&amp;f3d ~
1.1 什么是luceneITPUB个人空间9^ T d1h m
Lucene是一个全文搜索框架，而不是应用产品。因此它并不像www.baidu.com 或者google Desktop那么拿来就能用，它只是提供了一种工具让你能实现这些产品。ITPUB个人空间Z i \ E8o
ITPUB个人空间&amp;v y X X L:Q
1.2 lucene能做什么ITPUB个人空间 ~&amp;s1n7e ?:g%a
要回答这个问题，先要了解lucene的本质。实际上lucene的功能很单一，说到底，就是你给它若干个字符串，然后它为你提供一个全文搜索服务，告诉你你要搜索的关键词出现在哪里。知道了这个本质，你就可以发挥想象做任何符合这个条件的事情了。你可以把站内新闻都索引了，做个资料库；你可以把一个数据库 表的若干个字段索引起来，那就不用再担心因为“%like%”而锁表了；你也可以写个自己的搜索引擎……
[ [ P.A2y#J'|*n0
3b ^ f6J%J:G l/g01.3 你该不该选择lucene
-V ^ \ { N0下面给出一些测试数据，如果你觉得可以接受，那么可以选择。ITPUB个人空间,P rZ1o o o9M @9|1o:G
测试一：250万记录，300M左右文本，生成索引380M左右，800线程下平均处理时间300ms。
.? A Z w T e W0测试二：37000记录，索引数据库中的两个varchar字段，索引文件2.6M，800线程下平均处理时间1.5ms。
#w,N+H0d'H} J A g.B&amp;M0
+Q%T x)E Q1A ] t02 lucene的工作方式ITPUB个人空间 D o [3B w&amp;C5J C%p c
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fafc647cc22066802ddeae5dd8ca9485/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92debfd9e05642be401c52456acf7a78/" rel="bookmark">
			lsnrctl start 出现错误Failed to start service, error 0.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天想启动数据库, 发生如题的错误. 为什么? Google一下, 从
https://forums.oracle.com/forums/thread.jspa?threadID=885033
这个地址得到启发.
原来, 我这几天做PRO*C将环境变量ORACLE_HOME做了修改. 开始我也是认为在Console做一下修改就可以了, 但是还要发生同样的错误. 一定要在"我的电脑"的"属性"中做修改才可以. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/338501d0625f53a88a86b0baa0f3ed05/" rel="bookmark">
			TMS320F28335 DMA配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DMA（Direct Memory Access），即直接存储器存取，是一种快速传送数据的机制。它的优点在于一旦控制器初始化完成，数据开始传送，DMA就可以脱离CPU，独立完成数据传送。不需要依于CPU的大量中断负载，从而节省大量的CPU资源。
TMS320F28335具有6通道DMA，而且每个通道具有独立的PIE中断。DMA的触发源种类有很多，可以配置为ADC、MCBSPs、外部中断、CPU定时器、ePWM1-6 ADCSOCA and ADSOCB和软件等出发方式。DMA可以对L4-L7 16Kx16 SARAM、XINTF外部接口、ADC、MCBSPs、ePWM1-6/HRPWM1-6映射到Peripheral Frame 3空间的寄存器进行数据操作。工作方式可以配置为32位或者16位。吞吐量最高为4时钟/字。需要注意的是，当DMA对MCBSPs进行数据操作时，只能配置为16位工作模式，而且最大的吞吐量为5时钟/字。具体原因参考一下TI的数据手册。下面以TI的例程为例详细讲解一下DMA配置。
28335 DMA的配置主要是一下几个函数，可以在DSP2833x_DMA.c找到。
函数及配置详解：
void DMACHxAddrConfig(volatile Uint16 *DMA_Dest,volatile Uint16 *DMA_Source) 参数解析：配置DMA的数据目的地址和源地址(跟函数中参数的排序相同，下同)。
void DMACHxBurstConfig(Uint16 bsize, int16 srcbstep, int16 desbstep) 参数解析：配置每帧大小、帧内源地址增加偏移和帧内源地址增加偏移。地址增加偏移就是指传输一个字(或帧)之后地址增量。
void DMACHxTransferConfig(Uint16 tsize, int16 srctstep, int16 deststep) 参数解析：配置每次触发DMA转移多少帧、帧间源地址增加偏移和帧间源地址增加偏移。
void DMACHxWrapConfig(Uint16 srcwsize, int16 srcwstep, Uint16 deswsize, int16 deswstep) 参数解析：配置源地址偏移总量、重载的源地址、目的地址偏移总量、重载的目的地址。也就是说在源地址（或者目的地址）偏移量超过所设置的偏移总量的时候重载所设置的新的源地址（或者目的地址）。我是这么理解的。
void DMACHxModeConfig(Uint16 persel, Uint16 perinte, Uint16 oneshot, Uint16 cont, Uint16 synce, Uint16 syncsel, Uint16 ovrinte, Uint16 datasize, Uint16 chintmode, Uint16 chinte) 参数解析：配置触发源选择、触发源使能、ONESHOT使能、继续模式使能、外设同步使能、同步对象选择(源同步还是目的同步)、溢出中断使能、工作方式选择(16位还是32位)、产生中断模式选择(开始还是结束)、产生中断使能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/338501d0625f53a88a86b0baa0f3ed05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2dd1ef7fe8adea6204c96628c134a5b/" rel="bookmark">
			Google的技术构架 (精心整理版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上看到的一篇关于GOOGLE技术架构的详细介绍。
了解云计算标杆Google的技术构架 一、前言 计算无疑是今年IT 技术界最热点的关键词之一。从谷歌趋势分析来看，国际上Cloud computing 是从2007 年中期开始成为整个业界关注的重点，在中国云计算是从2008 年开始 成为中国IT 界和通信界关注的核心。特别是，当中国移动2008 年开始关注 计算，并推动 中国移动相关的业务支撑系统、业务软件平台开始向 计算的平台迁移。使得整个中国IT 界、通信界的相关产业力量更加关注 计算，同时大家也开始意识到了 计算确实可以大大 的节省海量计算的总体拥有成本。 cloud computing 云计算 当业界谈到 计算的时候，都会第一个想到谷歌 Google。我们日常在使用的Google Search，Google Earth，Goolge Map，Google Gmail，Google Doc 等等业务都是Google 基于自 己 计算平台来提供的。Google 也是通过云计算的方式，大量的降低计算成本，使之业务 更具有竞争力。 Google 原先企业初期阶段，获得的投资有限，只能自己攒机，但是很差的机器不可能 发挥服务器的性能和稳定性，于是只有去想该如何提高可靠性，如何利用很多"破烂"机器获 得更高的性能。这就有了云计算的雏形。 今天我们都知道Google 的规模，而如果我们不去认清 计算的强大，我们就不知道互 联网的未来和规则。Google 在98 年的时候被迫发现了这一规则，然后我们看到了聚合的力 量，今天微软、IBM、雅虎、百度、亚马逊这些企业看到了规则，于是开始进入 计算领域。 所以我们研究 计算，可以系统剖析一下Google 的技术构架，这对于我们搭建自己自身的 计算平台有比较好的借鉴意义和标杆意义！ 二、Google 的整体技术构架说明 由于Google 没有官方发布一个自身的技术构架说明。本文主要的信息都来自互联网中 对于Google 网络技术构架的分析，大量信息来自labs.google.com 。 Google 最大的IT 优势在于它能建造出既富于性价比(并非廉价)又能承受极高负载的高 性能系统。因此Google 认为自己与竞争对手，如亚马逊网站(Amazon)、电子港湾(eBay)、微 软(Microsoft)和雅虎 (Yahoo)等公司相比，具有更大的成本优势。其IT 系统运营约为其他互 联网公司的60%左右。 同时Google 程序员的效率比其他Web 公司同行们高出50%～100%，原因是Google 已 经开发出了一整套专用于支持大规模并行系统编程的定制软件库。 从整体来看，Google 的 计算平台包括了如下的技术层次。 1）网络系统：包括外部网络(Exterior Network) ，这个外部网络并不是指运营商自己的 骨干网，也是指在Google 计算服务器中心以外，由Google 自己搭建的由于不同地区/ 国 家，不同应用之间的负载平衡的数据交换网络。内部网络（Interior Network），连接各个Google 自建的数据中心之间的网络系统。 2）硬件系统：从层次上来看，包括单个服务器、整合了多服务器机架和存放、连接各 个服务器机架的数据中心（IDC）。 3）软件系统：包括每个服务器上面的安装的单机的操作系统经过修改过的Redhat Linux。 Google 计算底层软件系统 （文件系统GFS、并行计算处理算法 Mapreduce、并行数据库 Bigtable，并行锁服务Chubby Lock， 计算消息队列GWQ ） 4）Google 内部使用的软件开发工具 Python、Java、C++ 等 5）Google 自己开发的应用软件Google Search 、Google Email 、Google Earth 三、Google 各个层次技术介绍 1、Google 外部网络系统介绍 当一个互联网用户输入www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2dd1ef7fe8adea6204c96628c134a5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22fe062fc2e503cc2a5fa225679f3bb1/" rel="bookmark">
			oRTP移植到DM6446
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 移植到DM6446开发板
1）下载oRTP源码: http://download.savannah.gnu.org.sixxs.org/releases/linphone/ortp/sources/
我们用最新的版本ortp-0.20.0.tar.gz
22-Feb-2012 16:22
503K
2）库文件编译
解压到 /opt/ortp-0.20.0
进入主目录：cd /opt/ortp-0.20.0
执行如下命令：
a ) ./configure --prefix=/opt/ortp --host= arm-montavista-linux --disable-staticCC=arm_v5t_le-gcc
b）make
c）make install
注：执行make时程序报错我们把文件/ortp-0.20.0/src/b64.c 中209-212行注释掉即可
#ifndef__WATCOMC__
// assert(characters[0] &gt;= 0&amp;&amp; characters[0] &lt; 64);
// assert(characters[1] &gt;= 0&amp;&amp; characters[1] &lt; 64);
// assert(characters[2] &gt;= 0 &amp;&amp;characters[2] &lt; 64);
// assert(characters[3] &gt;= 0 &amp;&amp;characters[3] &lt; 64);
#endif /*__WATCOMC__ */
完成后在/opt/ortp目录下生成如下文件夹：
3）复制头文件和库文件
a) 把 include下的ortp文件夹拷贝到
/mv_pro_4.0/montavista/pro/devkit/arm/v5t_le/lib/gcc/armv5tl-montavista-linuxeabi/3.4.3/include文件夹下，注意：是将整个ortp文件下一起拷贝，如果只拷贝里面的.h文件，在程序编译时会报错。
b) 把lib文件夹里边的除文件夹pkgconfig以外的文件拷贝到
/opt/mv_pro_4.0/montavista/pro/devkit/arm/v5t_le/armv5tl-montavista-linuxeabi/lib
c) 为了能在DM6446平台上运行程序，需要把库文件和头文件拷贝到嵌入式文件系统中。分别拷贝到\usr\lib和\usr\include中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22fe062fc2e503cc2a5fa225679f3bb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff2be913e32fc8582199ee459ab09aca/" rel="bookmark">
			js阻止事件冒泡的DEMO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" " http://www.w3.org/TR/html4/loose.dtd"&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=GBK"&gt; &lt;title&gt;js阻止事件冒泡的DEMO&lt;/title&gt; &lt;script type="text/javascript"&gt; //阻止冒泡的方法 function stopPP(e) { var evt = e || window.event; //IE用cancelBubble=true来阻止而FF下需要用stopPropagation方法 evt.stopPropagation ? evt.stopPropagation() : (evt.cancelBubble=true); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div style="margin: 150px 400px;width: 700px; height: 550px; background-color: #878788;" οnclick="alert('最外层div上的onclick事件');"&gt; &lt;h2&gt;最外层div上的onclick事件&lt;/h2&gt; &lt;div style="margin: 100px; width: 500px; height: 300px; background-color: #545444;" οnclick="stopPP(arguments[0]);alert('中间层div上的onclick事件');"&gt; &lt;h3&gt;中间层div上的onclick事件&lt;/h3&gt; &lt;div style="margin: 60px 100px; height: 100px; width: 300px; background-color: red;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff2be913e32fc8582199ee459ab09aca/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/301/">«</a>
	<span class="pagination__item pagination__item--current">302/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/303/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>