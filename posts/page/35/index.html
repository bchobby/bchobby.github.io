<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/904d957613afad1d62fa538854771af7/" rel="bookmark">
			利用虚拟机做Web服务器，使用物理机通过在浏览器输入IP和域名来访问自己做的网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 学了将近半个月的网页开发了，一直是在本地预览，也想搞个服务器能在浏览器直接输入ip或者域名访问，刚才去作了一番功课，好像大佬们都倾向于视频讲解，动辄一个小时长的视频我都替你们看完了，有几个博主写的倒是文章，看了一半了提示要米，难受，所以自己写一篇吧。
二、准备 我们首先要有：
1、你做的网站文件；
2、一个虚拟机在你的物理机上（我这里用的是vmware，操作系统是WServer2012 R2）
免费下载镜像文件的网站推荐
https://msdn.itellyou.cn/
三、正式开始 1、检查网络通信是否正常
（1）检查你物理机和虚拟机之间能不能ping通，先cmd用ipconfig查看虚拟机的ip地址；
（2）在物理机ping这个地址，有这样就是可以，如果不行的建议去先学一下“虚拟机和物理机如何ping通”
2、接下来是虚拟机的操作
嘿嘿嘿你要是问我都安装哪些web功能，我也不知道其实，但是多多益善嘛，毕竟你只是想跑起来你的网站看看效果不会在乎这些....细节的吧...!!!!（手动狗头保命）
诶嘿嘿这个功能嘛，嘿嘿大家参考一下我的吧，糊弄完..哦不是，咳咳勾选完之后就点击安装就行了
此时你再看
强制弹窗不怕怕，选中永远滚蛋蛋
好，咱也摸了网站一把，现在到虚拟机C盘下，咱爸网页文件放里。我就随便建了两个文件夹把网页放里了。
接下来回到IIS管理器，右击“网站”，选择“添加网站”：
我的参考：
到了这一步，好了，你再点你建的网站然后预览看看
想也不用想，肯定不行！因为本地DNS的生死簿上可没你刚才输入的三W，哈哈，不过你想尝尝鲜的话还是可以通过输入刚才的ip地址来访问的。
然后咱们再用物理机也尝尝鲜！！！IP访问肯定没问题，域名肯定没可能！！
好，来再回到虚拟机，咱们配置本地DNS，打开C盘，打开如下目录，右击“hosts”选择打开方式为记事本或者其他的玩意
我们在最后一行加上我们刚才的IP和域名，然后点保存。
如果保存就提示“无访问权限”就打开下面网站跟着做
http://t.csdnimg.cn/7lvTK
欢迎回来，此时你就发现再点击预览域名就生效了
ok，回到物理机你会发现还不行（用域名不行），那咱再配置物理机的本地DNS，接下来的操作一样了，在文件末尾添加一行，点击保存，没权限就改，有权限ok
其实这两台电脑的hosts修改和咱刚才配置的那玩意好像关系不大，你在这里随便写个域名，他也和这个IP对应，都能打开这个IP地址，我也懵逼，现在还有点菜等我再大一些就会了！一定，接下来，拜拜~~
诶等等，要注意的是，这个东西他能识别你的网站文件的名字也有要求！当然你也可以自定义名字，记得加上后缀哦~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce409ab262609915045b67afa632759d/" rel="bookmark">
			MOV导出序列帧并在Unity中播放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MOV导出序列帧并在Unity中播放 前言项目将MOV变成序列帧使用TexturePacker打成一个图集将Json格式精灵表转换为tpsheet格式精灵表导入Unity并播放总结 鸣谢 前言 收集到一批还不错的MG动画，想要在Unity中当特效播放出来，那首先就得把MOV变成序列帧，然后使用TexturePacker打成一个图集，最后再导入Unity中制作Animation Clip播放。
项目 将MOV变成序列帧 需要提前安装FFmpeg
创建一个Cut.txt文本文件，将下面内容复制到文本文件中，把Cut.txt改成Cut.bat，就可以将代码中设置的mov视频导出成序列帧并存储在同级目录下。
@echo off setlocal enabledelayedexpansion :: 设置输入视频文件和输出图片文件夹路径 set input_video=Ele.mov set output_folder=output_images :: 创建输出文件夹 mkdir %output_folder% :: 使用FFmpeg抓取视频帧并保存为透明图片 ffmpeg -i %input_video% -vf "select=eq(n\,0)+eq(pict_type\,I)" -vsync vfr -q:v 2 %output_folder%\frame%%04d.png :: 完成后的消息 echo 透明图片已经生成到 %output_folder% 文件夹中。 :: 按任意键退出 pause 使用TexturePacker打成一个图集 这里我只找到了TexturePacker3.0.9的版本(pj方法就是用里面带的两个exe替换原始的两个exe)
链接：https://pan.baidu.com/s/1C04rikUgbdlstwBJV_Ch7g?pwd=upvu
提取码：upvu
但是这里有一个问题，3.0.9版本只能导出json格式的图集表，Unity2021以上只能使用tpsheet格式的精灵表
所以需要下面的步骤
将Json格式精灵表转换为tpsheet格式精灵表 创建一个Python脚本，写入以下内容
import json import os def convert_texture_packer_to_unity(json_file, output_file): with open(json_file, 'r') as f: data = json.load(f) frames = data['frames'] meta = data['meta'] texture_size = meta['size'] with open(output_file, 'w') as f: f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce409ab262609915045b67afa632759d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d82c8729b00222b6143ab888c38d78b/" rel="bookmark">
			05_常用API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 常用 API string 创建字符串对象 public class HelloWorld { public static void main(String[] args) { // 1. 直接使用双引号得到字符串对象，封装字符串数据 (推荐使用) String name = "tomato"; System.out.println(name); // tomato // 2. new String创建字符串对象，并调用构造器初始化 String gender = new String(); System.out.println(gender); // "" String hobby = new String("coding"); System.out.println(hobby); // coding // 3. 数组 char[] arr = {'G', 'o', 'o', 'd'}; String res = new String(arr); System.out.println(res); // Good // 3. 数组 byte[] arr2 = {97, 98, 99}; String res2 = new String(arr2); // ASCII码 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d82c8729b00222b6143ab888c38d78b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0c025ff1e0a4b8e4710375be06f44cb/" rel="bookmark">
			周总结2023-11-17
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言：工作：学习：生活： 前言： 今天周五，是做本周总结和下周安排的记录博客。有条不紊，循序渐进。
工作： 本周的工作计划：
完成单轴测试板的测试与代码解析stm32HAL库的开发与学习。1121芯片的通信格式分析
细分的话完成了以下工作：单轴测试板的分析与调试HAL库开发初步学习，跑马灯，环境搭建基础知识的学习，时钟树解析，寄存器映射等发布博客1121芯片spi通信分析问题汇总代码整理，注释，结构整理
未完成的本周工作：数模转换模块的数据处理HAL库的学习IMU知识点汇总
下周的工作安排：Stm32的hal库开发持续学习三轴测试板代码的解析Arduino开发与学习Atmega328p最小系统版的驱动学习上周未完成工作的补漏记得买开发外设 学习： 下周学习安排：
Stm32单片机的HAL库学习物联网通信模块的初步了解电机知识基础了解尤克里里的学习
一般学习上的安排我不会安排特别多，因为学习安排属于工作时间外的学习，时间有限精力有限，但是一直是学习进步的状态就让我感觉会很安心，现在生活上基本安定了，所以准备重新拾起尤克里里的学习啦，就是会有点累，因为专业知识也在寻求提高，我现在最大的学习方面的期望就是，能够在目前自己学习工作的领域能有质的提高，其实包括我的博客大部分知识都是基础型的，一方面是我的知识不能够总结很绝对性的高质博客，另一方面是越基础的博客流量越好，之前我写博客是为了记录，后面是为了记笔记，再后面是为了科普，现在变成技术总结了，也算是有所进步。 生活： 首先是双十一大大下单，花了1400来买家用物品，毕竟是新环境，很多东西都没有，我之前关注的小杜的日记的博主给我寄了两个锅省了一大笔钱，但是还没到，所以目前吃饭还是吃食堂，锅到了，下个阶段的减肥计划就要提上日程了。
另外就是这几天很想入手ipad，不过钱不够哈哈哈，先搁置吧，自己的笔记本和纸质记录也能用，只是有很多资料是电子版，笔记本不能每天都带回去学习，不太方便，在公司的工作时间也是有限的。
很久没写这样的总结博客了，一方面是觉得有点水，另一方面是因为很久不写了，以前觉得技术博客比记录博客难写，现在觉得记录博客更难，因为要复盘和安排接下来要做的事情，因为我这个人自律性特别不好，只能用计划来约束自己，就这还很多工作超时，不过跟之前没有计划来比的，学习工作效率提高了不少。
还有一件事想记录一下，突然想起来的，我大学在校报待了3年，第一年任职干事，在信息部做微信公众号排版，第二年做副部长，时而会出现在责编一栏，第三年是副社长，统筹规划校报人员的工作安排，我之前一直觉得，我只是为了充盈自己的生活而参加的，即使干了3年好像也没有什么收获。但是！其实不是这样的，前段时间同学也在找工作，我看了他的简历觉得排版特别乱，我会跟他说用什么字体手机和pc端查看的时候更加清晰，什么字体打印出来会更好看，包括对齐，字体大小，结构排版，当时我就一下子意识到，有的东西你坚持学习，坚持做，总有一天会派上用场，他还问我怎么知道这些，我当时也纳闷，我怎么对排版结构很敏感的？后来才反应过来是之前锻炼的。现在写工作计划也是大三的时候对校报六个部门做工作安排的时候锻炼的，之前一直觉得自己去校报和室友或者朋友不去参加学校组织的人更忙，而且没用，除了加点分。现在才意识到，学习的过程，是进步的过程，也是锻炼的过程。
最后就是给自己的寄语：有条不紊，循序渐进。所有东西都有规划，有序的进行，一直处于学习的状态就会有进步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0776a8ae006ea3b95eb0bfb5bd6065c/" rel="bookmark">
			mysqldump常用操作示例/命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是一些常用的mysqldump操作示例，以备份和还原MySQL数据库为例：
1. 备份单个数据库： mysqldump -u your_username -p your_password your_database &gt; backup.sql 将 your_username 替换为你的MySQL用户名，your_password 替换为你的MySQL密码，your_database 替换为要备份的数据库名称。备份的内容将写入 backup.sql 文件中。
2. 备份多个数据库： mysqldump -u your_username -p your_password --databases db1 db2 db3 &gt; multi_db_backup.sql 用 --databases 选项指定多个数据库，以空格分隔。
3. 备份所有数据库： mysqldump -u your_username -p your_password --all-databases &gt; all_databases_backup.sql 使用 --all-databases 选项备份所有数据库。
4. 备份时添加创建数据库语句： mysqldump -u your_username -p your_password --databases your_database --add-drop-database &gt; backup_with_create.sql 使用 --add-drop-database 选项，生成包含创建数据库语句的备份文件。
5. 备份时添加创建表语句： mysqldump -u your_username -p your_password --databases your_database --add-drop-table &gt; backup_with_create_table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0776a8ae006ea3b95eb0bfb5bd6065c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54f44acd4f8f02783d9e012c3da732f1/" rel="bookmark">
			MessageSourceUtil读取资源文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在处理返回值提示的时候，需要根据local返回中文或者英文，因此要使用到国际化内容
操作 1，新建资源文件 在src/main/resources源文件夹下创建一个i18n的子目录， 然后创建中文和英文对应properties文件，然后输入自己的提示信息
输入内容：
result.success=执行成功 result.failure=执行失败 flow.toDo=有“{0}”待办“{1}”正等待您的审批！ flow.toDo=有“{0}”待办“{1}”正等待您的审批！ 如果有其它参数用{0} 这种进行标记。
如果中文里面显示的值是乱码，打开setting 搜索 encoding
选择右下角的 Transparent native-to-ascii conversion 然后点击OK
2，MessageSourceUtils import org.springframework.context.MessageSource; import org.springframework.context.MessageSourceResolvable; import org.springframework.context.i18n.LocaleContextHolder; import java.util.Locale; public class MessageSourceUtils { public static MessageSource getMessageSource() { try { return (MessageSource) SpringUtils.getBean("messageSource"); } catch (Exception e) { return SpringUtil.getBean(MessageSource.class); } } public static String getMessage(String code) { Locale locale = LocaleContextHolder.getLocale(); return getMessageSource().getMessage(code, null, locale); } public static String getMessage(String code, Object[] args) { Locale locale = LocaleContextHolder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54f44acd4f8f02783d9e012c3da732f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/058ebca31816fc8a95a3df087bebffe5/" rel="bookmark">
			PyQt制作【小红书图片抓取】神器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 📢闲言碎语🐾窗口设计🐾功能设计📚资源领取 📢闲言碎语 最近写一个系统，被一个Bug折腾了两天，至今还未解决。由于解决Bug弄得我有点心力憔悴，于是想着写其他小项目玩玩（爬取小红书图片），放松放松，在构思这个小项目的时候想着弄得稍微复杂点，弄着弄着花了大概三个小时时间（屁股要坐烂了），以为要准备结束了，结果又遇到Bug……😵
前前后后解决大大小小的Bug又花了大概一个小时……😊
好在最终将Bug解决了，项目也成功的启动咯~
具体实现，请往下看👇
🐾窗口设计 如下图所示，主窗口主要有窗口图标、自动的鼠标图标、“小红书图片抓取”标签、带有frame窗口的QLineEdit和两个QPushButton，虽然看起来简单，但其背后逻辑功能的实现也不是很难。
首先需要定义一个子类Frame，并通过继承QFrame类来进行一些窗口的基本设置，设置其窗口的样式和背景颜色。
class Frame(QFrame): def __init__(self, parent=None): super().__init__(parent) self.setFrameStyle(QFrame.Box | QFrame.Plain) self.setLineWidth(3)	# 外线宽 self.setMidLineWidth(3)	# 中线宽 self.setStyleSheet("QFrame {border: 3px solid #ff2442;}") # 设置边框颜色 接着设计主窗口，设置窗口和鼠标的图标，再设置基本的控件，其中setFrameWidget方法主要是将控件放在Frame窗口中，并通过传入的参数，计算控件的大小和移动的位置，让控件与Frame窗口贴合，达到一个美化的效果。
然后重写mousePressEvent、mouseMoveEvent和mouseReleaseEvent事件，实现鼠标在窗口中按下可移动的功能，其中还会带动processWindow（显示过程信息的窗口）的移动。
class MainWindow(QMainWindow): def __init__(self, parent=None): super().__init__(parent) # 设置窗口 self.setWindowTitle('小红书图片抓取') self.resize(400, 250) self.setWindowIcon(QIcon('window.png')) self.setStyleSheet('background-color: white;') # 设置鼠标 self.setCursor(QCursor(QPixmap('mouse.png').scaled(30, 30), 0, 0)) # 设置frame窗口宽度 self.frameWidth = 3 self.mouseFlag = False self.setup_ui() # 设置组件 def setup_ui(self): # 设置窗口大标题 label_title = QLabel(self) label_title.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/058ebca31816fc8a95a3df087bebffe5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d6052c83c5c657d157234d71874b0e2/" rel="bookmark">
			【C&#43;&#43;】plog
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub地址：Plog - portable, simple and extensible C++ logging library
介绍 Plog is一个C++日志库，旨在保持尽可能的简单、小巧和灵活。它被创建作为现有大型库的替代品，并提供了一些独特的功能，如CSV日志格式和宽字符串支持。
主打一个小，灵活吗？
先来一段Demo
#include &lt;plog/Log.h&gt; // Step1: include the headers #include "plog/Initializers/RollingFileInitializer.h" int main() { plog::init(plog::debug, "Hello.txt"); // Step2: initialize the logger // Step3: write log messages using a special macro // There are several log macros, use the macro you liked the most PLOGD &lt;&lt; "Hello log!"; // short macro PLOG_DEBUG &lt;&lt; "Hello log!"; // long macro PLOG(plog::debug) &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d6052c83c5c657d157234d71874b0e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c35af30a3633e77a31a7d322221b8a9/" rel="bookmark">
			Node.js中npm和pnpm常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、NPM基本配置 1.查看Node安装版本
node -v
2.查看npm镜像地址
(下面的xxxxx用taobao代替）
淘宝镜像：http://registry.npm.taobao.org/
npm config set registry https://registry.npm.taobao.org/
npm config set registry https://registry.npmjs.org/
C:\Users\Jason&gt;npm get registry http://registry.npm.xxxxx.org/ 3.修改npm镜像地址
C:\Users\Jason&gt;npm config set registry http://registry.npm.xxxxx.org/ 4.查看安装包的历史版本：
例如查看VUE有哪些版本
npm view vue versions 5.安装指定版本：
npm -g install npm@x.x.x 6.查看已安装依赖包
npm list
PS D:\SVNfiles\Ajax\vuerender&gt; npm view vuex version 4.0.2 PS D:\SVNfiles\Ajax\vuerender&gt; npm list ├── @babel/core@7.17.9 ├── @babel/eslint-parser@7.17.0 ├── @vue/cli-plugin-babel@5.0.4 ├── @vue/cli-plugin-eslint@5.0.4 ├── @vue/cli-service@5.0.4 ├── axios@0.27.2 ├── babel-plugin-component@1.1.1 ├── core-js@3.21.1 ├── element-ui@2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c35af30a3633e77a31a7d322221b8a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/781963c333d62029ee222b472b8b1bc8/" rel="bookmark">
			COCO格式转化为YOLOv8格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		COCO格式转化为YOLOv8格式 目录格式代码 目录格式 yolov8仅支持YOLO格式的标签，COCO的默认标签为JSON格式，所以需要将COCO格式转换为YOLO格式。
如果训练COCO数据集的话一定要按照这个格式，摆放目录images，labels这两个目录名不可以改变
因为在内部已经写好了就这么去找数据，如果不按照这个规则写就会报错：No labels found in
datasets | coco | images | train2017 val2017 labels | train2017 val2017 代码 该代码可将COCO格式转换为YOLO格式并保存在labels/下。这里需要运行两次，train和val都需要转换。
import os import json from tqdm import tqdm import argparse parser = argparse.ArgumentParser() parser.add_argument('--json_path', default='/home/ubuntu/data/coco2017/annotations/instances_train2017.json',type=str, help="input: coco format(json)") parser.add_argument('--save_path', default='/home/ubuntu/data/coco2017/labels/train2017', type=str, help="specify where to save the output dir of labels") arg = parser.parse_args() def convert(size, box): dw = 1. / (size[0]) dh = 1. / (size[1]) x = box[0] + box[2] / 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/781963c333d62029ee222b472b8b1bc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b2602d583a66a197a9e35a23006f7ba/" rel="bookmark">
			hugo使用经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		title: “Hugo博客搭建经验”
date: 2021-07-26T16:47:18+08:00
draft: false
description: “《别用》”
featured_image: “https://img-blog.csdnimg.cn/c0b511f31c864b22b873b6aee915dfd5.png”
写在前面 ​ hugo最强使用技巧：别用hugo (狗头)
​ 这个世界上的静态网站生成器至少有333个，先从我的角度说说其他静态网站生成器的优点：
VitePress：基于vue技术栈构建(代替了VuePress)，可以顺便练习vue和vite，减小vue开发者的学习成本;
中文文档 国人开发者 主题丰富（在github主页有）插件挺丰富，不知道常用的有没，但是大丈夫！因为是Vue，对Vue开发者集成功能很方便！文档说是单页应用，解决路由时音乐播放器重新加载播放的问题应该简单一些； Hexo：由咱台湾老乡创建，中文用户很多教程也丰富；
[√]中文文档[√]主题丰富[√]插件齐全（几乎不用敲代码，npm上都一堆插件）多个静态页面 做网站生成器是方便了，不过像练习编写项目的空间少了，可能一不小心沉迷于集合插件 WordPress:嗯。。和hugo都是老外搞的，风格半斤八两，都用了"shortcode"这种奇怪的东西（类似模板引擎的语法，但还需要额外的学习成本），支持OneNote上传笔记（鸡肋）；可以和PHP配套使用；
然后。。。hugo的优点可能是快？我不知道。。。可我是男人可如果开发速度慢、学习成本高不还相当于慢了。。中文文档还相当于没有！要是go语言开发者可能研究研究原理有意思？
如果重命名content下的md文件，hugo编译时不会把删掉该替换的文件。不知道其他工具怎么样。
当然所有工具都是没有上限的！只是碰壁次数与资料多少、学习成本之类的区别！
快速开始 中文文档少有的中文233：
快速入门 | Hugo 中文网 (gohugo.cn)
其中下载主题这步可以自己选，主题商城也在这个网站中↑；
我所用的主题是Diary，可以在博客左下↙版权那里找到github仓库。自己魔改了一部分，为了添加功能。
常用命令、脚本 ​ 获取QQ头像的url: https://q1.qlogo.cn/g?b=qq&amp;nk=QQ号码&amp;s=640。
用edge浏览器时发现，如果用https访问博客，而头像url用http访问的话，会被拦截。
​ 每次输入这么多命令太麻烦了，hugo似乎没有把自己提交到github的命令，索性写了一个极简的windows批处理脚本上传博客。提前在path环境变量中配置hugo命令所在目录，以在任意位置执行hugo命令。
​ 还是第一次主动写windows脚本，上一次写还是上一次（呸，上次是改U盘图标，照网上抄的）。文件后缀名为.bat，直接在里面写命令即可。
hugo -D hugo cd ./public git add -A git commit -m "脚本提交" git push -u origin master ​ 先执行一遍hugo -D是为了将草稿也编译一下；再不带-D，这样主页不会显示草稿；
​ 还有一个博客生成测试脚本，执行hugo server命令，用于在本地实时查看页面；
​ 也可以使用github Actions来完成持续集成（CI）,顺道学习Devops；难得有个项目有提供hugo的插件，我却还是觉得脚本成本低，，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b2602d583a66a197a9e35a23006f7ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b7965ce9f35202fa3b982b169eaf14f/" rel="bookmark">
			NoSQL 与传统数据库的集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库集成势在必行 随着数据格局以前所未有的复杂性和规模发展，围绕数据库的叙述已经发生了巨大的变化。NoSQL 数据库已成为传统关系数据库的引人注目的替代品，在可扩展性、灵活性和数据模型多样性方面提供了显着的优势。然而，由于其 ACID 属性和 SQL 查询功能的增强，传统数据库远未过时。那么问题来了：这两种类型的数据库如何才能既共存又有效地整合呢？NoSQL 与传统数据库的集成不仅仅是一项技术工作；更是一项技术工作。这是实现全面数据管理的战略，可释放新功能并为创新奠定基础。
整合的必要性 在以实时分析、大数据和物联网 (IoT) 为标志的时代，在现代数据架构中维护 NoSQL 和传统数据库的理由非常充分。NoSQL 数据库擅长于需要水平可扩展性和灵活性的场景，提供处理半结构化或非结构化数据、无模式设计和高写入量等功能。另一方面，对于需要遵守 ACID（原子性、一致性、隔离性、持久性）属性的复杂查询、联接和事务的应用程序来说，传统数据库仍然是不可替代的。但这不是零和游戏。在各种现实场景中，NoSQL 和传统数据库的集成方法不仅仅是其各个部分的总和。想象这样一个场景：金融机构使用 RDBMS 处理交易数据，但利用 NoSQL 数据库通过实时分析大量用户行为来进行欺诈检测。通过集成这些数据库，该组织可以释放前所未有的功能，例如实时分析和预测建模。
整合方法 数据联合 数据联合类似于在两个不同的世界之间建立一座桥梁。它允许查询跨越多个数据库，实时混合来自传统 RDBMS 和 NoSQL 数据库的数据。但它并非没有缺点。虽然数据联合提供了虚拟的统一数据层，但它在事务支持方面存在局限性。符合 ACID 属性的传统数据库可能与许多 NoSQL 数据库的 BASE（基本可用、软状态、最终一致）模型发生冲突。从多个源实时提取数据时，可能会出现数据一致性和完整性问题。此外，联合查询可能存在性能瓶颈。它们通常需要大量元数据信息才能正确执行，在处理大型数据集时，这可能会导致延迟增加。人们必须权衡使用单一查询语言查询不同数据库的便利性与这些性能和一致性的权衡。
仔细观察数据虚拟化 数据虚拟化通过提供统一的数据访问层作为敏捷、实时的解决方案。它创建了一个抽象层，使用户能够通过单个虚拟数据库访问多个源的数据。数据虚拟化解决方案通常提供缓存机制来缓解性能问题，但它们也会以附加软件层的形式引入复杂性，这可能成为故障点。正如 Martin Fowler 指出的那样，数据虚拟化可以作为跨不同数据库的“提供实时访问的敏捷方式”。然而，敏捷性是有代价的。实时转换和聚合可能会占用大量资源，可能会造成性能瓶颈，尤其是在处理高速或大容量数据时。
对数据同步的深入见解 数据同步的概念很简单，但在实际场景中实施时会很快变得复杂。数据同步可以是单向的或双向的，具体取决于用例。单向同步（数据从一个源流向另一个源而没有互惠性）实现起来更简单，但可能会导致数据一致性问题。双向同步虽然更复杂，但可确保两个数据库都根据对方的更改进行更新，从而保持更高级别的数据一致性。然而，这个过程可能会占用大量资源，并且容易发生冲突，需要复杂的冲突解决策略。必须考虑数据重复、一致性检查以及处理更新或删除等问题。
中间件解决方案：超越基础 中间件解决方案，特别是集成平台即服务 (iPaaS)，提供了更加集中的集成方法。这些平台通常附带用于各种数据库的预构建连接器，以及数据映射和转换工具。iPaaS 解决方案通常提供强大的监控和错误处理机制，并且可以扩展以适应不断增长的数据量和复杂性。
新出现：API 主导的连接 另一种新兴方法是 API 主导的连接，它利用 API 来连接和公开来自各种数据库的数据。这种方法允许模块化、可重用且可维护的集成架构。在微服务世界中，API 主导的连接可以成为数据库集成的支柱，提供灵活性和控制力。总之，每种集成方法都提供了一系列独特的好处和挑战。根据特定的需求、约束和预期结果，可以选择用于实时查询的数据联合、用于敏捷和统一数据访问层的数据虚拟化、用于维护数据一致性的数据同步、用于集中和托管集成的中间件解决方案，或 API 主导的连接，以实现模块化和灵活的方法。
性能考虑因素 在考虑性能时，通常首先想到的就是查询速度。多年来，传统数据库凭借其 ACID 合规性，针对复杂查询功能进行了优化。它们可以相对高效地执行连接、聚合和子查询，但通常难以处理大容量、高速数据。另一方面，NoSQL 数据库专为处理大量数据时提供高性能而设计，但在处理复杂查询时可能会遇到困难。当集成两者时，查询性能成为一个问题，特别是在联合或虚拟化系统中。由于每个系统的限制，跨数据库查询的性能可能会受到严重影响。
一致性和延迟：找到平衡点 传统数据库遵循ACID属性，确保事务前后数据保持一致。NoSQL 数据库通常遵循 BASE 模型，优先考虑可用性和分区容错性，而不是强一致性。这种根本差异给两者之间的数据同步带来了挑战。确保强一致性，同时最大限度地减少延迟就像走钢丝。在联合系统中，维护数据库之间的一致性成为一项艰巨的任务。它涉及处理 ACID 和 BASE 属性之间的差异，特别是在处理实时数据时。这可能会显着影响依赖强一致性的应用程序的性能，例如金融或医疗保健系统。
吞吐量：可扩展性挑战 NoSQL 和传统数据库都有不同的吞吐量能力，主要是因为它们的底层架构不同。NoSQL 数据库通常是为水平扩展而设计的，允许它们处理大量的读写操作。传统数据库往往针对垂直扩展进行优化，更注重增加单个节点的容量。当这两种数据库类型集成时，吞吐量可能成为瓶颈。使用 NoSQL 数据库的具有高写入吞吐量要求的应用程序可能会压垮配置为较低吞吐量但较高一致性的传统数据库。规划这种能力不匹配对于保持最佳性能至关重要。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b7965ce9f35202fa3b982b169eaf14f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbe2475f62f6766097555e68272119fe/" rel="bookmark">
			Vue2&#43;echarts横向进度条类型颜色渐变柱形图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近遇到个需求，用图表横向显示数据并且文字要在两边柱形上面，而且柱形要颜色渐变也就是下图所示:
分析一下这个图表的需求，大概为几点:
1.横向柱形图。其实这点不难，x与y轴数据互换一下就可以了。
2.背景有个黑色的总进度条。
3.柱形图两边文字在柱子上方。
4.柱子颜色渐变。
分析完需求，代码如下，每一行都做了注释
drawPowerCharts() { let myChart10 = this.$echarts.init(document.getElementById("myCharts")); myChart.setOption({ // 设置图表的选项 grid: { x: 20, // 距离容器左边的距离 y: 40, // 距离容器上边的距离 x2: 30, // 距离容器右边的距离 y2: 20, // 距离容器下边的距离 }, // 设置图表的网格样式，即图表距禒容器四边的距禒 xAxis: { type: "value", // x 轴类型为数值型 show: false, // 不显示 x 轴 }, // 设置图表的 x 轴的类型为数值型，并且不显示 x 轴 tooltip: { trigger: "axis", // 触发类型为坐标轴触发 axisPointer: { type: "shadow", // 指示器类型为阴影 }, }, // 配置图表的提示框，当鼠标悬浮在数据点上时显示信息 yAxis: { type: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbe2475f62f6766097555e68272119fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d25d0834f2f5388d4e57f43a6c1490f/" rel="bookmark">
			sql命令查询mysql数据使用磁盘空间大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 登录mysql mysql -uroot -p; 进入information_schema数据库 use information_schema; 查询mysql使用空间 select concat(round(sum(data_length/1024/1024),2),'MB') as data from tables; 查询所有数据库占用磁盘空间大小 select TABLE_SCHEMA, concat(truncate(sum(data_length)/1024/1024,2),' MB') as data_size, concat(truncate(sum(index_length)/1024/1024,2),'MB') as index_size from information_schema.tables group by TABLE_SCHEMA order by data_length desc; 查询某个库所使用的磁盘空间大小 select concat(round(sum(data_length/1024/1024),2),'MB') as data from tables where table_schema='某个库'; 查询某个库下表使用空间 select TABLE_NAME, concat(truncate(data_length/1024/1024,2),' MB') as data_size, concat(truncate(index_length/1024/1024,2),' MB') as index_size from information_schema.tables where TABLE_SCHEMA = '某个库' group by TABLE_NAME order by data_length desc; 查看指定数据库的某个表的大小 select concat(round(sum(data_length/1024/1024),2),'MB') as data from tables where table_schema='某个库' and table_name='某个表'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/941d815352a04377254a11ce3f05a9d9/" rel="bookmark">
			勒索病毒及防护
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 木马与病毒概述 计算机木马 向受害者系统中植入木马程序，用户很可能不知情 窃取敏感信息（如网游账号、银行账号、机密文件等） 夺取计算机的控制权 计算机病毒 与木马程序不同的是，计算机病毒（Virus）的主要目的是破坏（如删除文件、 破坏分区等），而不是窃取信息病毒程序具有自我复制和传染能力，可以通过电 子邮件、图片和视频、下载的软件、光盘等途径进行传播 勒索病毒 安全事件 2017年 5 月，腾讯御见威胁情报中心接到某公司反馈，公司里数台Windows服 务器中了勒索病毒，电脑除了C盘，其他磁盘分区都被整个加密，公司业务已接 近停摆。此外，该勒索病毒勒索索要的赎金高达9.5比特币（约40万人民币） 利用系统防火墙高级设置阻止向445端口进行连接 1、打开控制面板，点击“系统和安全” 2、点击“Windows 防火墙” 3、首先保证防火墙是开启的，然后点击“高级设置“ 4、点击”入站规则“ 5、点击”新建规则“ 6、选择”端口“，点击”下一步“ 7、写入特定本地端口：445，点击”下一步“ 8、选择”阻止连接“，点击“下一步” 9、保持默认，点击“下一步“ 10、给规则命名。点击”完成“ 11、此时在入站规则中显示了，刚才创建的规则。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1a550799addca520b3501251e1d10b5/" rel="bookmark">
			配置DHCP服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 DHCP(Dynamic Hast Configuration Protocal)就是动态主机配置协议，可以自动配置主机的IP地址、子网掩码、网关及DNS等TCP/IP信息。以DHCP可以有效地降低客户端IP地址配置的复杂度和网络的管理成本。如果路由器能够转发DHCP请求，只需要在一个子网中配置DHCP服务器就可以向其他子网提供TCP/IP配置的服务支持DHCP的应用环境
安装 如果报错，就在重新挂载一次
再下载dhcp
配置主文件 复制主配置文件的样本
[root@dyzx -]# cp -p /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example /etc/dhcp/dhcpd.conf
修改/etc/dhcp/dhcpd.conf文件
如果在启动服务的时候报错 第一进文件，查看网段写没写错，是不是client的地址网段是不是写错了，第二查看文件里面的内容是否是否有误。
可以通过：
[root@server39 lijiaying]# tail -30 /var/log/messages
来查看文件的最后30行
Nov 17 08:02:19 server39 journal: shell-extensions did not set error for gs_plugin_refresh
Nov 17 08:05:01 server39 dbus[714]: [system] Activating service name='org.freedesktop.problems' (using servicehelper)
Nov 17 08:05:01 server39 dbus[714]: [system] Successfully activated service 'org.freedesktop.problems'
Nov 17 08:05:05 server39 dbus[714]: [system] Activating via systemd: service name='net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1a550799addca520b3501251e1d10b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63759f4b10856c2e237a4514380d448e/" rel="bookmark">
			【Mac开发环境搭建】Docker安装Redis、Nacos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Dokcer安装Redis拉取镜像创建配置文件创建容器连接测试Redis连接工具[Quick Redis]设置Redis自启动 Docker安装Nacos Dokcer安装Redis 拉取镜像 docker pull redis 创建配置文件 # bind 127.0.0.1 -::1 bind 0.0.0.0 # 是否启用保护模式 protected-mode no # redis端口 port 6379 # 密码设置（需要密码就取消下面的注释） # requirepass root12345678 tcp-backlog 511 # 用户多少秒没有操作就断开连接，设置为0为不断开 timeout 0 # 后端连接会经常断开，设置为60不断开 tcp-keepalive 60 # 是否以守护线程的方式运行 daemonize no pidfile /var/run/redis_6379.pid loglevel notice logfile "" databases 16 always-show-logo no set-proc-title yes proc-title-template "{title} {listen-addr} {server-mode}" # 将数据持久化到dump.rdb的频率 save 3600 1 save 300 100 save 60 10000 stop-writes-on-bgsave-error yes rdbcompression yes rdbchecksum yes dbfilename dump.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63759f4b10856c2e237a4514380d448e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c3a26755495154e0ca1f5cc234e7907/" rel="bookmark">
			python-tk-弹框超时自动关闭
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import ctypes # 2000ms后自动关闭 ctypes.windll.user32.MessageBoxTimeoutW(0,'请选择(不理会，则10秒后自动关闭)\n','询问','yes',0,2000) 参考：https://blog.csdn.net/mcw_720624/article/details/125292833
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7654ad7f3ca29d9176408bb7e306825/" rel="bookmark">
			ncbi-datasets-cli-高效便捷下载NCBI数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介安装```datasets download```下载基因组/基因序列按照GCA list文件编号下载下载大基因组genome完整参数gene参数 ```datasets summary```下载元数据```dataformat```将json转换成表格格式通过json文件解析其他字段问题 简介 NCBI Datasets 可以轻松从 NCBI 数据库中收集数据。使用命令行界面（CLI）工具或 NCBI Datasets 网页界面查找和下载基因和基因组的序列、注释和元数据。如下是可用的工具：
安装 使用conda安装Datasets CLI tools, datasetsand dataformat: # 注意不是datasets而是ncbi-datasets-cli $ conda install -c conda-forge ncbi-datasets-cli (base) [yut@io02 ~]$ datasets --version datasets version: 15.25.0 datasets download下载基因组/基因序列 datasets从 NCBI 下载所有生命领域的生物序列数据，dataformat将前者下载的数据包中的元数据从 JSON Lines 格式转换为其他格式。
使用datasets下载人类参考基因组 GRCh38 的基因组数据包：
$ datasets download genome taxon human --reference --filename human-reference.zip 使用 dataformat从下载的人类参考基因组 GRCh38 数据包中提取选定的元数据字段：
$ dataformat tsv genome --package human-reference.zip --fields organism-name,assminfo-name,accession,assminfo-submitter Organism name	Assembly Name	Assembly Accession	Assembly Submitter Homo sapiens	GRCh38.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7654ad7f3ca29d9176408bb7e306825/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff792090bec3c008fd4073d4e514e66a/" rel="bookmark">
			Flink之OperatorState
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Flink中状态主要分为三种:
Operator State(算子状态)Keyed State(键控状态)Broadcast State(广播状态) 这里简单介绍一下Operator State的使用,说到使用State就必然要使用到Flink的容错机制也就是Checkpoint.具体内容见代码注解
数据源
这里选用Socket作为Source输入,便于测试➜ ~ nc -lk 8888 a b c k k k 状态算子代码/** * @Description TODO 自定义状态MapFunc **/ // 状态算子必须要实现对应的算子接口和CheckpointFunction接口 class StateMapFunc implements MapFunction&lt;String, String&gt;, CheckpointedFunction{ private ListState&lt;String&gt; strListState; /** * @Param o * @return String * @Description TODO map方法的正常处理逻辑 **/ @Override public String map(String s) throws Exception { // 模拟Task失败 if (s.equals("k") &amp;&amp; RandomUtils.nextInt(0, 5) == 3) { throw new Exception("Task 异常"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff792090bec3c008fd4073d4e514e66a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb724166e57ff5dff6c37ac3c876f657/" rel="bookmark">
			KITTI数据集解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“小白学视觉”，选择加"星标"或“置顶” 重磅干货，第一时间送达 1.KITTI数据集概述
KITTI数据集由德国卡尔斯鲁厄理工学院和丰田美国技术研究院联合创办，是目前国际上最大的自动驾驶场景下的计算机视觉算法评测数据集。 该数据集用于评测立体图像(stereo)，光流(optical flow)，视觉测距(visual odometry)，3D物体检测(object detection)和3D跟踪(tracking)等计算机视觉技术在车载环境下的性能。
KITTI包含市区、乡村和高速公路等场景采集的真实图像数据，每张图像中最多达15辆车和30个行人，还有各种程度的遮挡与截断。整个数据集由389对立体图像和光流图，39.2 km视觉测距序列以及超过200k 3D标注物体的图像组成[1] ，以10Hz的频率采样及同步。
总体上看，原始数据集被分类为’Road’, ’City’, ’Residential’, ’Campus’ 和 ’Person’。对于3D物体检测，label细分为car, van, truck, pedestrian, pedestrian(sitting), cyclist, tram以及misc组成。
地址: http://www.cvlibs.net/datasets/kitti
相关论文：
1、Geiger A, Lenz P, Urtasun R. Are we ready for autonomous driving? the kitti vision benchmark suite[C]//2012 IEEE Conference on Computer Vision and Pattern Recognition. IEEE, 2012: 3354-3361.
2、Geiger A, Lenz P, Stiller C, et al. Vision meets robotics: The kitti dataset[J]. The International Journal of Robotics Research, 2013, 32(11): 1231-1237.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb724166e57ff5dff6c37ac3c876f657/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89cc130b07bc972ddf0d5c6f4b6794b9/" rel="bookmark">
			Spring中用了哪些设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.简单工厂模式 又叫做静态工厂方法（StaticFactory Method）模式，但不属于23种GOF设计模式之一。 简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。 spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。如下配置，就是在 HelloItxxz 类中创建一个 itxxzBean。 &lt;beans&gt; &lt;bean id="singletonBean" class="com.itxxz.HelloItxxz"&gt; &lt;constructor-arg&gt; &lt;value&gt;Hello! 这是singletonBean&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/ bean&gt; &lt;bean id="itxxzBean" class="com.itxxz.HelloItxxz" singleton="false"&gt; &lt;constructor-arg&gt; &lt;value&gt;Hello! 这是itxxzBean! &lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/beans&gt; 二.工厂方法模式 通常由应用程序直接使用new创建新的对象，为了将对象的创建和使用相分离，采用工厂模式,即应用程序将对象的创建及初始化职责交给工厂对象。一般情况下,应用程序有自己的工厂对象来创建bean.如果将应用程序自己的工厂对象交给Spring管理,那么Spring管理的就不是普通的bean,而是工厂Bean。 就以工厂方法中的静态方法为例讲解一下：
import java.util.Random; public class StaticFactoryBean { public static Integer createRandom() { return new Integer(new Random().nextInt()); } } 建一个config.xm配置文件，将其纳入Spring容器来管理,需要通过factory-method指定静态方法名称：
&lt;bean id="random"class="example.chapter3.StaticFactoryBean" factory-method="createRandom" scope="prototype"/&gt; &lt;bean id="random"class="example.chapter3.StaticFactoryBean" factory-method="createRandom" scope="prototype"/&gt; 测试：
public static void main(String[] args) { //调用getBean()时,返回随机数.如果没有指定factory-method,会返回StaticFactoryBean的实例,即返回工厂Bean的实例 XmlBeanFactory factory = new XmlBeanFactory(new ClassPathResource("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89cc130b07bc972ddf0d5c6f4b6794b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/246c6b5b6dbea2707285c9d818a264f3/" rel="bookmark">
			COS对象存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 什么是对象存储 腾讯云叫COS，在阿里云叫OSS，是一样的对象存储（Cloud Object Storage，COS）是腾讯云提供的一种存储海量文件的分布式存储服务，具有高扩展性、低成本、可靠安全等优点。通过控制台、API、SDK 和工具等多样化方式，用户可简单、快速地接入 COS，进行多格式文件的上传、下载和管理，实现海量数据存储和管理。 二. 相关配置项 图床如果使用COS也需要设置一下配置 服务器上创建存储桶，从概览查看桶的信息 从密钥管理查看accessKey/secretKey 三. 代码实现 POM依赖 &lt;!--腾讯云存储依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.qcloud&lt;/groupId&gt; &lt;artifactId&gt;cos_api&lt;/artifactId&gt; &lt;version&gt;5.2.4&lt;/version&gt; &lt;/dependency&gt; COS配置文件 spring: tencent: accesskey: 你自己的secretId secretKey: 你自己的secretKey bucket: ap-nanjing bucketName: test-1254123199 path: https://test-1254123199.cos.ap-nanjing.myqcloud.com preffix: img servlet: multipart: max-file-size: 10MB max-request-size: 10MB server: tomcat: max-swallow-size: 10MB COS配置类 @Data @Component @ConfigurationProperties(prefix = "spring.tencent") public class OssConfig { private String accesskey; private String secretKey; private String bucket; private String bucketName; private String path; private String preffix; } 控制器 /** * 文件上传控制器 */ @Controller @RequestMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/246c6b5b6dbea2707285c9d818a264f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6a244272d4be860bc454c93bd941d04/" rel="bookmark">
			docker 部署mysql主从复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：环境准备
1：创建mysql主库镜像
docker run -p 3307:3306 --name mysql_m \ -v /opt/mysql_m/log:/var/log/mysql \ -v /opt/mysql_m/data:/var/lib/mysql \ -v /opt/mysql_m/conf:/etc/mysql \ -e MYSQL_ROOT_PASSWORD=123456 \ -d mysql:5.7 2：在/opt/mysql-m/conf 创建文件 my.cnf,并做如下配置
cd /opt/mysql_m/conf vi my.cnf [mysqld] #设置 server_id server_id=1 # 指定不需要同步的数据库名称 binlog-ignore-db=mysql # 开启二进制日志功能 log-bin=mall-mysql-bin #设置日志使用内存大小 binlog_cache_size=1M # 设置使用的日志格式( mixed,statement,row) # statement：以SQL语句的形式记录更改操作。 # row：以行级别的方式记录更改操作，即记录每个被修改的行的具体内容。 # mixed：将statement和row两种方式结合使用，在某些情况下使用statement，在其他情况下使用row。 binlog_format=mixed # 二进制日志过期清理时间。默认值为0，表示不自动清理 expire_logs_days=3 # 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断## 如 :1062&gt;错误是指一些主键重复，1032错误是因为主从数据库数据不一致 slave_skip_errors=1062 3：重启主库
docker restart mysql_m 4：创建启动slave容器
docker run -p 3308:3306 --name mysql_s \ -v /opt/mysql_s/log:/var/log/mysql \ -v /opt/mysql_s/data:/var/lib/mysql \ -v /opt/mysql_s/conf:/etc/mysql \ -e MYSQL_ROOT_PASSWORD=123456 \ -d mysql:5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6a244272d4be860bc454c93bd941d04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62880e3fbe1c1c09477b7ce9cfd8fe67/" rel="bookmark">
			linux挂载MTP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要进一步区分MTP设备和U盘设备，你可以在设备插拔时，使用系统调用获取设备的详细属性信息，从而进行进一步判断。
在Linux系统中，你可以使用 libmtp 库来操作MTP设备。当MTP设备插入时，你可以使用 libmtp 库中的相关函数来检查该设备是否为MTP设备。你可以根据函数的返回值来判断设备类型。
下面是一个使用 libmtp 库来判断MTP设备的示例代码：
#include &lt;libmtp.h&gt; #include &lt;stdio.h&gt; int main() { LIBMTP_raw_device_t *raw_devices = NULL; int num_devices = 0; int i; num_devices = LIBMTP_Get_Raw_Device_List(&amp;raw_devices); if (num_devices &lt;= 0) { printf("No MTP devices found\n"); return 0; } for (i = 0; i &lt; num_devices; i++) { LIBMTP_raw_device_t device = raw_devices[i]; MtpDeviceID device_id = device.device_entry.vendor_id; MtpDeviceID vendor_id = device.device_entry.product_id; // Check if the device is an MTP device int is_mtp = LIBMTP_Is_Raw_Device_Supported(device); if (is_mtp) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62880e3fbe1c1c09477b7ce9cfd8fe67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8401055c15f88258682f8d1384db1287/" rel="bookmark">
			在pycharm下配置graphviz与pydot，傻瓜式教程，避免GraphVizs executables not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装graphviz与pydot 由于神经网络搭建模型，其中绘制神经结构示意图较为麻烦，遂打算利用pydot与graphviz进行绘制。直接在pycharm终端中使用pip进行安装，不需要再单独下载软件，有看到其他博主强调安装顺序，所以在此先安装graphviz，再安装pydotplus
pip install graphviz pip install pydotplus 二、系统环境配置 安装完毕后需要将graphviz安装目录配置到系统环境下，如果不清楚graphviz的安装路径可以在终端输入
pip show graphviz 就会跳出安装的路径， Location部分xi
打开系统环境配置，依次为 控制面板-系统-高级系统设置-高级-环境变量-新建。在此输入变量名称以及路径，可以参考我的，切记将路径补充完整。新建之后点击确定，之后将计算机重启，再打开pycharm，就可以使用graphviz与pydot了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e1d145621dc2b6b41be7a5ee782e76d/" rel="bookmark">
			Rancher 容器中使用 jmap 工具导出内存日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 提升容器权限
编辑容器工作负载，在【安全/主机设置】中选中【特权模式】的【是：容器具有所有主机访问权限】
进入容器命令行，执行 jmap 命令
# 获取服务 pid ps -ef | grep java # 执行 jmap 导出内存日志 jmap -dump:live,format=b,file=/home/mydump.hprof 1 在宿主机中将文件从容器中导出
docker cp 容器ID:/home/mydump.hprof /home/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af7ff9ace4d47d5ddae97133098ac68c/" rel="bookmark">
			Python如何使用Matplotlib模块的pie()函数绘制饼形图？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 模块安装 先安装matplotlib： pip install matplotlib 安装numpy模块，安装matplotlib时候就已经安装这个依赖了，所以不用装了，当然也可以独立安装： 安装pandas： pip install numpy 2 实现思路 数据存放在excel中，对指定数据进行分析，所以需要用到pandas；对指定数据分析后绘制饼形图，需要用到Matplotlib模块的pie()函数；对以下指定excel内容进行分析；分析用户购买区域情况占比，以下数据仅为参考，无真实意义，把以下内容保存为data.xlsx: 用户	金额	地址 user001	130.22	重庆 user002	55.64	江苏省 user003	33	江苏省 user004	158.23	重庆 user005	124.56	安徽省 user006	33.26	山东省 user007	59.9	吉林省 user008	34.9	福建省 user009	45.36	山西省 user010	35.23	河南省 user011	123.25	广东省 user012	44.25	河北省 user013	58.26	广东省 user014	83.79	贵州省 user015	59.99	广东省 user016	63.12	福建省 user017	110.78	湖北省 user018	120.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af7ff9ace4d47d5ddae97133098ac68c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2bc625c2ec8f352c554c9db5d99f2c7/" rel="bookmark">
			java学习记录--ThreadLocal使用案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文借由并发环境下使用线程不安全的SimpleDateFormat优化案例,帮助大家理解ThreadLocal.
最近整理公司项目,发现不少写的比较糟糕的地方,比如下面这个:
public class DateUtil { private final static SimpleDateFormat sdfyhm = new SimpleDateFormat( "yyyyMMdd"); public synchronized static Date parseymdhms(String source) { try { return sdfyhm.parse(source); } catch (ParseException e) { e.printStackTrace(); return new Date(); } } } 首先分析下:
该处的函数parseymdhms()使用了synchronized修饰,意味着该操作是线程不安全的,所以需要同步,线程不安全也只能是SimpleDateFormat的parse()方法,查看下源码,在SimpleDateFormat里面有一个全局变量
protected Calendar calendar; Date parse() { calendar.clear(); ... // 执行一些操作, 设置 calendar 的日期什么的 calendar.getTime(); // 获取calendar的时间 } 该clear()操作会造成线程不安全.
此外使用synchronized 关键字对性能有很大影响,尤其是多线程的时候,每一次调用parseymdhms方法都会进行同步判断,并且同步本身开销就很大,因此这是不合理的解决方案.
改进方法 线程不安全是源于多线程使用了共享变量造成,所以这里使用ThreadLocal&lt;SimpleDateFormat&gt;来给每个线程单独创建副本变量,先给出代码,再分析这样的解决问题的原因.
/** * 日期工具类(使用了ThreadLocal获取SimpleDateFormat,其他方法可以直接拷贝common-lang) * @author Niu Li * @date 2016/11/19 */ public class DateUtil { private static Map&lt;String,ThreadLocal&lt;SimpleDateFormat&gt;&gt; sdfMap = new HashMap&lt;String, ThreadLocal&lt;SimpleDateFormat&gt;&gt;(); private static Logger logger = LoggerFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2bc625c2ec8f352c554c9db5d99f2c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ee42218362f612dba7c8d42bd8e038a/" rel="bookmark">
			什么是基因表达谱分析及其相关概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 相关概念1. 转录本2. 什么是L1000技术 相关概念 1. 转录本 转录本（transcript）是指在基因表达中产生的RNA分子。基因是DNA上的一段特定序列，通过基因表达，该DNA序列的信息被转录为RNA。转录本是这个转录过程的产物，是RNA的一种形式。
有两种主要类型的转录本：
mRNA（信使RNA）： mRNA是最常见的转录本类型，它包含了编码蛋白质的信息。在真核生物中，mRNA由转录过程产生，并带有一系列的外显子和内含子。经过剪接过程，内含子被剪切出去，而外显子被保留，形成成熟的mRNA分子。mRNA离开细胞核，进入细胞质，被翻译为蛋白质。
非编码RNA（ncRNA）： 与mRNA不同，非编码RNA并不编码蛋白质，而在细胞中担任其他功能。这包括多种类型，如：
rRNA（核糖体RNA）： 参与构建细胞核糖体的RNA。
tRNA（转运RNA）： 在蛋白质合成中传递氨基酸到正在合成的蛋白质链上。
miRNA（微小RNA）： 调控基因表达的小RNA分子。
lncRNA（长链非编码RNA）： 具有多种功能，包括调控基因表达和细胞过程。
总体而言，转录本是基因表达的产物，代表了特定基因的RNA副本，可以用于传递遗传信息（mRNA）或执行多种细胞功能（非编码RNA）。
2. 什么是L1000技术 L1000 技术是整合网络细胞印记库项目(Library of Integrated Network Based Cellular Signatures， LINCS)中使用的低成本基因表达谱测定技术。其考虑基因表达之间的相关性，将需要测量的基因目大幅减小，从而达到控制成本的目的．L1000 技术是挑选 978 个标志基因进行测量，进一步通过构建模型外推出其他基因的表达量。实验数据表明这些标志基因的表达可以代表全基因组 80%的信息。虽然存在一定误差，但是该技术可以将成本缩减到全基因组基因芯片成本的 1%，使得测量大规模基因表达谱得以实现．
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5460c2fbf8b688dd594ef26db84efd72/" rel="bookmark">
			CSP202206-2 寻宝大冒险 70分题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;iostream&gt; using namespace std; const int N = 2001; int A[N+1][N+1] = {0}; int B[51][51] = {0}; bool is_equal(int start_x,int start_y,int S){ //比较对应矩阵是否相等 bool is_equal = true; for(int i = start_x; i &lt;= start_x + S; i++ ){ for(int j = start_y; j &lt;= start_y + S;j++){ if(A[i][j] != B[i - start_x][j - start_y]){ is_equal = false; } } } return is_equal; } int main(){ int n,L,S,result = 0; cin &gt;&gt; n &gt;&gt; L &gt;&gt; S; for(int i = 0; i &lt; n; i++){ //输入A矩阵 int x,y; cin &gt;&gt; x &gt;&gt; y; A[x][y] = 1; } for(int i = S; i &gt;= 0;i--){ //输入B矩阵 for(int j = 0; j &lt; S+1 ;j++){ cin &gt;&gt; B[i][j]; } } for(int i = 0; i &lt;= L - S; i++){ for(int j = 0; j &lt;= L - S; j++){ if(A[i][j] == 0){ continue; //相当于剪枝了，因为题中说满足要求的子矩阵左下角肯定是个1，所以0就不进去考虑了 } if(is_equal(i,j,S)){ result++; } } } cout &lt;&lt; result; return 0; } 第一次做的时候就是全部的左下角都要进去比较一趟B矩阵，但是发现题目中说了藏宝图的左下角一定是1，所以如果是0就没有必要再一一比对了。加那个continue之前只有40分，加上之后就有70分了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dda9fc146ae184fdfc3c0c2c3d385e89/" rel="bookmark">
			【linux】 Shell函数返回值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 return 返回
shell中通过return返回是有限制的，必须是数字，最大返回255，超过255，则从0开始计算。
通常仅返回0或1；0表示成功，1表示失败。通过echo 直接返回。
在没有return 语句，函数将以最后一条命令运行结果，作为返回值。因此，通常在最后一行以echo “xxx”语句作为返回值。
如果有多条echo，则以最后一个echo为返回值。
通常用于返回数据，比如一个字符串值或者列表值 1、返回值的方式： 方法一：return
方法二： echo
2、return和echo使用场景区别： (1).使用return返回值：
使用return返回值，只能返回1-255的整数
函数使用return返回值，通常只是用来供其他地方调用获取状态，因此通常仅返回0或1；0表示成功，1表示失败
(2).使用echo返回值：
使用echo可以返回任何字符串结果
通常用于返回数据，比如一个字符串值或者列表值
3、场景示例
(一) return使用场景
函数通过return返回一个整数，这种场景通常是用来做判断的，也就是说在执行完函数之后，需要根据它的返回值做判断，通0表示成功，非0都是表示失败。
#!/bin/bash this_pid=$$ # 判断nginx进程是否正在运行 function is_nginx_running { ps -ef | grep nginx | grep -v grep | grep -v $this_pid &amp;&gt;/tmp/null if [ $? -eq 0 ];then # return 0,也可以省略0直接return,两个是等价 return else return 1 fi } # return在函数中的返回值，只是用来做状态判断的，根据状态值做下一步判断 # 函数的返回值为0时，表示nginx服务运行正常输出 &amp;&amp; 后字符串，否则返回 ||后字符串 is_nginx_running &amp;&amp; echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dda9fc146ae184fdfc3c0c2c3d385e89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/735afd0769a529cb5c6bc329b801d034/" rel="bookmark">
			微信小程序 30分钟倒计时功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ps:凑个数 getTimeDiff(date) { let _this = this; let curTime = new Date(date) _this.countDown(_this.timeFormatConvert(new Date(curTime.setMinutes(curTime.getMinutes() + 30)))) }, timeFormatConvert(e) { const Y = e.getFullYear(); // 年 const M = this.prefixZero(e.getMonth() + 1); // 月 const D = this.prefixZero(e.getDate()); // 日 const H = this.prefixZero(e.getHours()); // 时 const Mi = this.prefixZero(e.getMinutes()); // 分 const S = this.prefixZero(e.getSeconds()); // 秒 return Y + "-" + M + "-" + D + " "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/735afd0769a529cb5c6bc329b801d034/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/097eb0596189d65a6b833c99437fb8d4/" rel="bookmark">
			Flink之数据擦除及自定义Evictor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 窗口数据移除机制 Flink中窗口数据移除机制是通过Evictor来控制的, Flink内置的Evictor如下: DeltaEvictorTimeEvictorCountEvictor Evictor的作用就是在窗口触发前或窗口触发中将其中的某些数据进行移除. 1.1 源码解析 关于Evictor的源码只需要关注三个方法就可以了evictBefore,evictAfter,evict.
源码内容如下:
public class TimeEvictor&lt;W extends Window&gt; implements Evictor&lt;Object, W&gt; { // ... // doEvictAfter默认为false // 窗口计算前擦除数据 @Override public void evictBefore( Iterable&lt;TimestampedValue&lt;Object&gt;&gt; elements, int size, W window, EvictorContext ctx) { if (!doEvictAfter) { // 执行数据擦除方法 evict(elements, size, ctx); } } // 窗口计算后擦除数据 @Override public void evictAfter( Iterable&lt;TimestampedValue&lt;Object&gt;&gt; elements, int size, W window, EvictorContext ctx) { if (doEvictAfter) { // 执行数据擦除方法 evict(elements, size, ctx); } } // 擦除数据逻辑 private void evict(Iterable&lt;TimestampedValue&lt;Object&gt;&gt; elements, int size, EvictorContext ctx) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/097eb0596189d65a6b833c99437fb8d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20cf8758d0bcd739d98a90ced8103666/" rel="bookmark">
			SpringEvent事件通知机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“Spring Event” 是 Spring 框架通过事件驱动的编程模型来处理应用程序中的事件。开发者可以定义自己的事件，然后在应用程序中触发这些事件。Spring 框架提供了用于发布和监听事件的机制，以实现松散耦合的组件间通信。
有两个核心组件：
事件监听器 案例代码：
1.创建事件
@Getter public class UserRegisterEvent extends ApplicationEvent { private User user; public UserRegisterEvent(Object source, User user) { super(source); System.out.println(source); this.user = user; } } 2.创建监听器
@Slf4j @Component public class UserRegisterListener { @Autowired private UserBackpackService userBackpackService; @EventListener(classes = UserRegisterEvent.class) public void sendCard(UserRegisterEvent event) { User user = event.getUser(); System.out.println("给"+user.getId()+"发改名卡..."); } } 3.发布事件
@Service public class UserServiceImpl implements UserService { @Autowired ApplicationEventPublisher applicationEventPublisher; @Override public void register(User user) { userDao.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20cf8758d0bcd739d98a90ced8103666/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef0d40b0f7e6c51d1c7411e82e3ffb35/" rel="bookmark">
			python django &#43; 微信小程序 商城源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景介绍
随着互联网的快速发展，线上购物越来越普及，而商城小程序作为一种便捷的购物方式，正逐渐成为消费者的首选。为了满足市场需求，我们利用Django和微信小程序技术，设计并实现了一个智能商城小程序，旨在为用户提供更加便捷、智能的购物体验。
二、技术选型
后端框架：Django
Django是一个基于Python的开源Web框架，具有强大的功能和灵活性。我们使用Django作为后端框架，处理逻辑和数据管理，为前端微信小程序提供API接口。前端框架：微信小程序
微信小程序是一种轻量级的应用程序，具有即开即用、无需下载安装等特点。我们使用微信小程序作为前端框架，通过API接口与后端进行数据交互，实现商城小程序的各项功能。 三、功能实现
登录注册功能
商城小程序支持用户登录和注册功能。用户可以通过输入用户名和密码进行登录，也可以通过授权登录快速进入小程序。注册功能允许用户填写个人信息并设置密码。商品搜索功能
商城小程序提供商品搜索功能，用户可以通过输入商品名称或关键字搜索相关商品。后端通过Django处理搜索逻辑，返回搜索结果给前端微信小程序展示。首页轮播图展示功能
商城小程序的首页轮播图会展示热门商品、促销活动等信息。我们通过Django提供轮播图数据接口，前端微信小程序使用API接口获取数据并展示轮播图。商品分类展示功能
商城小程序支持商品分类展示，用户可以查看不同分类的商品列表。后端通过Django处理分类数据，前端微信小程序使用API接口获取数据并展示分类列表。点击分类可查看对应商品的详情信息。商品详情及购物车功能
用户点击商品后，商城小程序会展示商品详情页面，包括商品名称、价格、图片、描述等信息。用户可以将商品加入购物车或直接下单购买。购物车页面显示已添加的商品及数量，用户可以修改数量或删除商品。点击“结算”按钮可进入订单确认页面。个人中心功能
商城小程序的个人中心页面显示用户个人信息，如用户名、头像、积分等。用户可以编辑个人信息、查看订单信息（包括待支付、已支付、已取消等状态）、管理收货地址及查看收藏的商品等。后台管理功能
商城小程序的后台管理界面包括统计分析、用户管理、广告管理、分类管理、商品管理、订单管理、评价管理和管理员管理等模块。通过这些模块，管理员可以对商城进行全面管理，包括查看用户数据、分析销售情况、调整广告策略、管理商品信息等。 代码截图：
项目截图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14e9d2524c35af6496163f8d594a2380/" rel="bookmark">
			Unity打包带管理员权限请求(VS2022)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity笔记 Unity打包exe并设置以管理员权限运行 - 哔哩哔哩
这个大佬的方法完全可用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d74d85cb7865eb5e30ee88e5e118d581/" rel="bookmark">
			【华为云IaaS基础三件套之----计算ECS、网络EIP、存储EVS】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MD@[华为云IaaS基础三件套----计算、网络、存储]
华为云IaaS基础三件套之----计算ECS、网络EIP、存储EVS 说明: 这里只是简单从计算/网络/存储，进行介绍，阐明云上对于云下的优势；因ECS是三者综合，故最后说明。
1.网络----弹性公网IP (EIP) 华为云EIP归属于不同region, 最终会在虚拟私有网络VPC内使用。
1.1 BGP类型可选（稳定） 1.线下IDC机房的网络，大多为静态BGP网络，由网络运营商手动配置的路由信息。当网络的拓扑结构或链路的状态发生变化时，运营商需要手动去修改路由表中相关的静态路由信息。
2.云上网络可选择动态BGP，使用BGP协议同时接入多个运营商，可支持20多条线路。可以根据设定的寻路协议实时自动优化网络结构，自动故障切换，保持网络持续稳定，高效。
3.动态BGP的服务可用性高达99.95%
参考文档: 静态BGP、全动态BGP之间有何区别？
1.2 弹性灵活 1.线下IDC机房的网络，带宽大小常年固定，购买后更改较为麻烦，如遇到临时性业务峰值（例如：双11），无法弹性扩容。
2.华为云EIP，可在EIP控制台–&gt;带宽加油包–&gt;临时按天按需进行扩容, 有效避免浪费。
参考文档: 华为云带宽加油包
1.3 简单易用 1.带宽绑定/解绑服务器、带宽调整，一键操作，实时生效。无需重启机器, 简单易用。
2.弹性公网IP支持与ECS、NAT网关、ELB、虚拟IP灵活的绑定与解绑，自动绑定网卡，无需手动配置。
1.4 安全可靠（结合VPC和ACL） 1.VPC之间通过隧道技术进行100%逻辑隔离，不同VPC之间默认不能通信。
2.网络ACL对子网进行防护，安全组对弹性云服务器进行防护，多重防护您的网络更安全。
2.存储----云硬盘(EVS) 云上存储有4种，云硬盘EVS、本地磁盘、弹性文件服务器SFS、对象存储OBS。这里只介绍最基本的EVS，相当于计算的硬盘。
2.1 稳定可靠 1.三副本技术: 云硬盘的存储系统采用三副本机制来保证数据的可靠性，即针对某份数据，默认将数据分为1 MiB大小的数据块，每一个数据块被复制为3个副本，然后按照一定的分布式存储算法将这些副本保存在集群中的不同节点上。
2.技术特点: 2.2.1 存储系统自动确保3个数据副本分布在不同机柜的不同服务器的不同物理磁盘上，单个硬件设备的故障不会影响业务。2.2.2存储系统确保3个数据副本之间的数据强一致性。
例：对于服务器A的物理磁盘A上的数据块P1，系统将它的数据备份为服务器B的物理磁盘B上的P1’‘和服务器C的物理磁盘C上的P1’，P1、P1’和P1’‘共同构成了同一个数据块的三个副本。若P1所在的物理磁盘发生故障，则P1’和P1’'可以继续提供存储服务，确保业务不受影响。
参考文档: 云硬盘三副本技术
2.2 弹性灵活 1.硬盘扩容方便, 简单易用，也可根据需要实时升级成更高性能的硬盘类型（需要重启服务器）。
2.云硬盘支持可选多种类型：高IO/通用型SSD/超高IO/通用型SSD/极速型SSD。
参考文档: 磁盘类型及性能介绍
2.3 备份策略方便 1.华为云EVS有两种备份策略: 快照、备份。都极为方便 (云服务器还可一键制作镜像)
2.硬盘快照：免费, 每块硬盘可手动创建7个快照, 在进行数据风险操作时, 可采用此方式, 快速备份。（与云硬盘数据存储在一起）
操作路径: 云硬盘控制台–&gt;找到需要建快照的硬盘–&gt;点击–&gt;快照页面–&gt;创建快照
3.硬盘备份：按OBS存储量进行收费，便宜且可靠(100GB,3年,360)。可自定义备份策略，操作简单。
操作路径: 云硬盘控制台–&gt;找到需要建备份的硬盘–&gt;点击–&gt;备份页面–&gt;创建备份
参考文档: 备份和快照的区别
2.4 安全–云硬盘加密 当用户由于业务需求从而需要对存储在云硬盘的数据进行加密时，EVS为用户提供加密功能，可以对新创建的云硬盘进行加密。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d74d85cb7865eb5e30ee88e5e118d581/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abb7b59483045feb63ad26f54988d6b1/" rel="bookmark">
			gurobi最新下载安装教程 2023.11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 gurobi下载gurobi安装gurobi lincese获取添加系统环境变量 gurobi和pythonpython中调用gurobi gurobi下载 https://www.gurobi.com/
点击下载中心 download center
可以直接选择 Gurobi Optimizer下载
gurobi安装 gurobi可以通过python进行调用，但是需要先获得gurobi的lincese。
gurobi lincese获取 官网申请 academic
但这个激活码需要进行IP地址的验证。如果学校的网关没有将本校的 IP 地址标注为学术机构，那么会出现 Error 303/305 错误，IP 验证不会成功，学术许可不会激活。是否识别为学术机构与 Gurobi 原厂无关，是学校网络的设置问题。
2. gurobi中文网
http://www.gurobi.cn/NewsView1.Asp?id=4
在线PDF中填写自己的基本信息并手写签字，之后发邮件到help@gurobi.cn，实测不到一小时即可审核完毕，获得对应的许可。
添加系统环境变量 grbgetkey这个序号与计算机硬件捆绑，一旦激活就会失效。运行激活码之后，产生的 gurobi.lic 许可文件保存在以下目录：
Windows 操作系统：把 gurobi.lic 文件放在 c:\gurobi 目录下；Linux 操作系统： 把 gurobi.lic 文件放在 opt/gurobi 目录下；Mac 操作系统： 把 gurobi.lic 放在 /Library/gurobi 目录下；
如果没有这些目录，请创建一个。这是Gurobi 默认搜索位置。 如果保存到其他位置，需要创建 GRB_LICENSE_FILE 系统环境变量（不是用户环境变量），指向保存的目录和文件名（例如 GRB_LICENSE_FILE = C:\myfolder\gurobi.lic)。需要重启电脑使之生效。如果既放置在了上面的默认搜索目录，又设置了 GRB_LICENSE_FILE 系统环境变量指向不同的目录和文件，Gurobi 会以 GRB_LICENSE_FILE 的设置为准。
每台机器上只需要保存一个gurobi.lic 文件。请删除多余只保留一个。高版本产生的许可文件兼容低版本。
我这里放在E盘
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abb7b59483045feb63ad26f54988d6b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8120130230e92c084b7c6bbb55c2e7a6/" rel="bookmark">
			解决java发邮件错误javax.net.ssl.SSLHandshakeException: No appropriate protocol
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java发送邮件时报以下错误信息：
javax.net.ssl.SSLHandshakeException: No appropriate protocol (protocol is disabled or cipher
[com.bm6api.controller.v1.AppUserController] - sendLoginAuthCodeMail 发送登录验证码邮件 : {"code":200,"info":"Success"} [org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor] - Written [{"code":200,"info":"Success"}] as "text/html" using [org.springframework.http.converter.StringHttpMessageConverter@3c3f40cb] [org.springframework.web.servlet.DispatcherServlet] - Null ModelAndView returned to DispatcherServlet with name 'SpringMVC': assuming HandlerAdapter completed request handling [org.springframework.web.servlet.DispatcherServlet] - Successfully completed request [freemarker.cache] - TemplateLoader.findTemplateSource("email_login_auth_en_US.ftl"): Not found [freemarker.cache] - TemplateLoader.findTemplateSource("email_login_auth_en.ftl"): Not found [freemarker.cache] - TemplateLoader.findTemplateSource("email_login_auth.ftl"): Found [freemarker.cache] - "email_login_auth.ftl"("en_US", UTF-8, parsed): using cached since javax.mail.MessagingException: Could not connect to SMTP host: smtp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8120130230e92c084b7c6bbb55c2e7a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f66c38a1f12327f200bde92772687a0/" rel="bookmark">
			Nacos漏洞复现合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要复现nacos的一些经典漏洞，既是分享也是为了记录自己的成长，近期会持续更新。
1. QVD-2023-6271 Nacos身份绕过漏洞 1.1 漏洞级别 ：高危 1.2 漏洞描述：低版本的Nacos存在默认的scertkey在未更换的情况下可以生成任意的可用accesstoken 1.3利用范围 nacos &lt;=2.2.0 1.4 漏洞复现 先来重点介绍一下如何任意生成一个可用的accesstoken
在nacos中accesstoken的生成是通过jwt的字符串创建的。
在nacos中默认的secertkey为：
SecretKey012345678901234567890123456789012345678901234567890123456789 jwt的payload参数为
{ "sub": "nacos", "exp": 1699974368 } #其中exp为时间戳，实际测试中这个时间戳早于或晚于当前时间都可以生效，如果无效的话可以调整时间戳到当前时间以后 至此一份完整的jwt生成数据就形成了
注：请注意红框部分的secret base64 encoded 必须勾选，否则生成的encoded就是错误的，笔者在此踩过雷。
至此万能accesstoken就生成了，实际测试一下：
在login接口的header添加下列参数
Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJuYWNvcyIsImV4cCI6MTYxODEyMzI5N30.YC6gtGxpYNDrSvNzmu2S4YF5Hd1Xwj1AJx5ZrdizO2A 一个完整的request包如下：(username和password可以随意填写)
POST /nacos/v1/auth/users/login HTTP/2 Host: User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/119.0 Accept: application/json, text/plain, */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 34 Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin Te: trailers Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f66c38a1f12327f200bde92772687a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bc5a215fce337d1e2681ed926879880/" rel="bookmark">
			Nacos 身份认证绕过漏洞（已修复）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nacos存在权限绕过漏洞，攻击者利用该漏洞可以未授权访问用户列表（我的Nacos版本为1.2.1） 漏洞复现：
http://127.0.0.1:8849/nacos/v1/auth/users?pageNo=1&amp;pageSize=9 利用漏洞复现问题
http://127.0.0.1:8849/nacos/v1/auth/users?username=test1&amp;password=test1
可以这样创建用户
使用该账号发现可以登录账号
漏洞修复： 1.将Nacos升级到2.2.0.1或以上版本 2.此版本nacos配置文件开启鉴权，（默认是不开启的）nacos.core.auth.enabled=true 重新启动Nacos，再次测试：
测试完成，将创建的用户删除：
http://127.0.0.1:8849/nacos/v1/auth/users?username=test1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/648ebb3c1701b94ef32c9cb7a1dabe0f/" rel="bookmark">
			如何正确使用 JavaScript 中的 slice() 方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 JavaScript 中，slice() 是一个常用的数组方法，用于从现有数组中提取一部分元素，然后返回一个新的数组。它是一个非常有用的工具，可以帮助你在不改变原始数组的情况下操作数组的子集。本文将介绍 slice() 的基本概念、使用方法、实践案例和互动练习，以帮助你更好地理解和掌握这一功能强大的方法。
slice() 基本概念 在很多情况下，你可能需要从一个数组中提取特定范围的元素，而不希望改变原始数组，这就是 slice() 方法的用武之地。它接受两个参数：起始索引和结束索引（不包含在提取范围内）。通过指定这两个参数，你可以轻松地创建一个新的数组，其中包含原始数组中指定范围的元素。
其语法为：
array.slice(begin, end) 参数说明:
begin:extraction 开始位置的索引(从0开始)end:extraction 结束位置的索引(但该位置的元素本身不包括在内) slice() 的使用方法 在 JavaScript 中，slice() 方法有两种常见的用法：
1. 提取指定范围的元素 const originalArray = [1, 2, 3, 4, 5]; const newArray = originalArray.slice(1, 4); console.log(newArray); // 输出: [2, 3, 4] 在上面的示例中，originalArray 是原始数组，我们使用 slice(1, 4) 提取了索引 1 到 3 之间的元素（不包括索引 4），然后创建了一个新的数组 newArray。
2. 复制整个数组 你还可以使用 slice() 来复制整个数组：
const originalArray = [1, 2, 3, 4, 5]; const newArray = originalArray.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/648ebb3c1701b94ef32c9cb7a1dabe0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bbb21a1ab07106772e4767c2379e73b/" rel="bookmark">
			Java中将ByteArrayOutputStream转换为ByteArrayInputStream
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 代码示例：
package com.thb; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; public class Demo3 { public static void main(String[] args) { ByteArrayOutputStream bos = new ByteArrayOutputStream(); // 在输出流中写入数据 bos.writeBytes("hello".getBytes()); // 将 ByteArrayOutputStream中的内容转换为字节数组，输入到ByteArrayInputStream中 ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); // 取出ByteArrayInputStream中的字节 byte[] bytes = bis.readAllBytes(); for (int i = 0; i &lt; bytes.length; i++) { System.out.println((char)bytes[i]); } } } 运行输出：
h e l l o 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aea10d4b5ede713fef3f62afdd73e6df/" rel="bookmark">
			Maven 的 spring-boot-maven-plugin 红色报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、想要处理此情况，在工具下面加上指定的版本号。
2、给自己的maven的setting文件加工一下。
&lt;mirrors&gt; &lt;!--阿里云镜像1--&gt; &lt;mirror&gt; &lt;id&gt;aliyunId&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/central&lt;/url&gt; &lt;/mirror&gt; &lt;!--阿里云镜像2--&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;!--阿里云镜像3--&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; &lt;!--阿里云镜像4--&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://central.maven.org/maven2&lt;/url&gt; &lt;/mirror&gt; &lt;!--maven官方镜像--&gt; &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name&lt;/name&gt; &lt;url&gt;https://repol.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 然后重新打开idea或者maven更新一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27e72b2f5643980e6bfc3429c6cbd8d9/" rel="bookmark">
			A newer version of WinPcap (internal version 5.1.71.1819) is already
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 安装ensp时提示如下：
解决方法如下： 进入C盘下面路径：
C:\Windows\SysWOW64
把wpcap.dll 改为wpcap.dll.old
packet.dll改为packet.dll.old
改完之后从新安装ensp或者winpacp即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a6c465c4af98980ab9cd97718c8a365/" rel="bookmark">
			图像分类：对google/vit-large-patch32-384模型进行微调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 图像分类是很常见的场景，比如日常的物体识别，可很多时候我们还需要根据自己的数据来训练自己的分类，大模型出现以后，我们不需要再重头来训练我们的模型，直接根据已经训练好的大模型进行微调即可，本文就针对google/vit-large-patch32-384模型进行微调。
数据准备： 数据准备参考huggingface如何加载本地数据集进行大模型训练-CSDN博客
代码： import json import os from PIL import Image from datasets import Dataset from sklearn.metrics import accuracy_score,f1_score, recall_score from transformers import AutoImageProcessor from torchvision.transforms import RandomResizedCrop, Compose, Normalize, ToTensor from transformers import AutoModelForImageClassification, TrainingArguments, Trainer from transformers import DefaultDataCollator path = '/data/dataset/image' def gen(path): image_json = os.path.join(path, "image.json") with open(image_json, 'r') as f: # 读取JSON数据 data = json.load(f) for key, value in data.items(): imagePath = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a6c465c4af98980ab9cd97718c8a365/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29d90bc6295242747b9274bb67a801a7/" rel="bookmark">
			C&#43;&#43;基础之C&#43;&#43;中的输入输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 文章目录
前言
一、输入输出流
二、c++中输入输出语句
1.标准输入设备
2.标准输出设备
3.原理
三、iostream类库
前言 c++是一个重要的面向对象语言，本文梳理了c++中输入输出基本语法以及关于输入出相关知识的总结
一、输入输出流 输入输出是数据传送的过程，c++中将此过程形象的称为流，c++中输入输出流输入输出流是指由若干字节组成的序列，这些字节序列中的数据按顺序从一个对象传送到另一个对象。在输入操作时，字节流从输入设备流向内存；在输出操作时，字节流从内存流向输出设备。流中的内容可以是ASCII码值、二进制形式数据、数字音频视频、图形图像或者其他形式的信息。
（输入设备：如键盘、磁盘 输出设备：如屏幕、打印机等）
在c++中，输入输出流被定义为类，c++的I/O库中的类为流类，用流类定义的对象称为流对象。
二、c++中输入输出语句 1.标准输入设备 cin 是标准输入设备（相当于键盘），连续从键盘读取数据，"&gt;&gt;"为提取运算符。
输入的使用：cin &gt;&gt; 变量 （cin在输入字符串时，空格作为结束符）
2.标准输出设备 cout 是标准输出设备（相当于屏幕）,"&lt;&lt;"为插入运算符。
输出的使用：cout &lt;&lt; 输出项 &lt;&lt; endl (endl 相当于换行符"\n")
代码示例如下：
#include &lt;iostream&gt; using namespace std; int main() { int a; char ch; cout &lt;&lt; "请输入一个常数" &lt;&lt; endl; cin &gt;&gt; a; cout &lt;&lt; "请输入一个字母" &lt;&lt; endl; cin &gt;&gt; ch; cout &lt;&lt; "常数为" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29d90bc6295242747b9274bb67a801a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75786ec283536aff1dbe3cdd355c17fc/" rel="bookmark">
			Nginx 版本信息泄露解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx 【CVE-2021-23017;CVE-2022-41742】
【影响】
攻击者可能使用泄露的版本信息来确定该版本服务器有哪些安全漏洞，据此展开进一步的攻击。以下是百度的请求示例，也是有版本泄露：
【解决方案】
在Server节点增加以下配置：
# 隐藏版本信息 server_tokens off; # 隐藏Response响应头 more_clear_headers "server"; Nginx官网
more_clear_headers 没有找到官网说明，不过这个参数确实可以去掉Response的 server 信息。如：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c440094f5f4e09adc8ec5a5208254fef/" rel="bookmark">
			Pytorch 冻结参数更新的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Pytorch中，默认情况下，所有设置requires_grad=True的张量都能跟踪它们的梯度计算历史并支持梯度计算。然而，在某些情况下，我们不需要这样做，例如，当我们已经训练了模型，只想将其应用于一些输入数据时，即我们只想通过网络进行前向计算。此时，这个禁用梯度跟踪操作就显得很重要，即冻结某个变量或模块的参数更新。下面介绍三种方式实现这个操作。
第一种方法：requires_grad_(False)冻结
import torch import torch.nn as nn class my_model(nn.Module): def __init__(self): super(my_model, self).__init__() self.l1 = nn.Linear(3,3).requires_grad_(False) self.l2 = nn.Linear(3,3) def forward(self, x): out = self.l1(x) +self.l2(x) return out model = my_model() y=torch.rand(6,3) optimizer = torch.optim.SGD(model.parameters(), lr=0.1, momentum=0.9) for i in range(2): data = torch.randn(6,3) out = model(x) loss=nn.functional.mse_loss(y,out) optimizer.zero_grad() loss.backward() optimizer.step() print(list(model.named_parameters())) print(loss) 通过上述结果，我们会发现l1层的参数，完成没有更新，从而达到冻结的作用。可以通过list(model.named_parameters())查看参数更新情况
其次，我们查看一下，被冻结的参数是否进入学习。
model.state_dict() 我们发现这个被冻结的参数在学习层中（model.state_dict()只保存参与学习的参数），因此这是最纯粹的冻结。
第二种方法：detach（）分离操作
import torch import torch.nn as nn class my_model(nn.Module): def __init__(self): super(my_model, self).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c440094f5f4e09adc8ec5a5208254fef/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/34/">«</a>
	<span class="pagination__item pagination__item--current">35/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/36/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>