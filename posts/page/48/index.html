<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a20d2646e9091090b04aa05ca3c0e65/" rel="bookmark">
			KF32A学习笔记（一）：工程导入、编译烧录方法（KF32 IDE&#43; KF32 PRO）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 概述KF32 IDE打开现有项目工程1.工程导入2.编译工程3.下载程序 KF32 PRO 概述 本文主要是对KF32A150芯片程序的编译、烧录方法进行说明。针对开发过程中的编译烧录和无代码情况下的烧录两种场景，需要安装ChipON PRO KF32和ChipON IDE KF32两个上位机工具，安装包可以在芯旺微电子官网（https://www.chipon-ic.com/)获取。
两个软件安装后，在桌面共用一个图标：
双击启动后，在弹出的窗口选择要启动哪一个工具：
下面对两个软件分开进行介绍。
KF32 IDE 打开现有项目工程 在项目文件夹下双击启动软件：
显示未归属于项目空间
点击确定之后，会根据项目路径E:\01.4G_V2X\E10_APP，默认：
确定之后是空的：
需要导入工程。
1.工程导入 1.进入ChipON IDE开发界面如下：
2.此时还没有打开工程，需要导入一下。文件 - 导入：
3.常规 - 现有项目到工作空间中：
4.选择路径后，会自动识别出项目，选中即可（取消默认勾选的将项目复制到工作空间中）：
2.编译工程 1.电脑连接KF32-LINK-A调试编程器后，在ChipON IDE中进行识别。正确识别到编程器，在控制台会有对应的信息输出：
2.点击锤子图标即可进行编译，在控制台可以看到编译信息：
3.程序编译成功，没有错误时，控制台显示如下：
3.下载程序 程序编译成功后，点击下载进行烧录。下载成功如下图：
KF32 PRO 电脑连接KF32-LINK-A调试编程器情况下，打开时会自动识别编程器，也可以通过点击右上角的齿轮图标进行手动识别。软件界面如下：
1.选择芯片型号
根据使用的MCU型号，在下拉框中进行选择：
2.加载烧写文件
3.烧录文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37c8508dea70abe8df863c0191ba6c0b/" rel="bookmark">
			anaconda安装pytorch-GPU版本（python3.7）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 anaocnda安装pytoch-GPU版本（解决：默认CPU版本安装） 文章目录 anaocnda安装pytoch-GPU版本（解决：默认CPU版本安装）一、总体步骤规划二、查看cuda版本三、确定并下载pytorch、torchaudio以及torchversion对应版本安装文件1、确定torch版本及下载安装文件2、确定torchvision版本及下载安装文件3、确定torchaudio的版本及下载安装文件 四、在anaconda中安装对应whl文件五、测试安装成功谢谢!!!!! 一、总体步骤规划 1、确定电脑的cuda版本。
2、确定python的版本。
3、确定要下载的pytorch版本，torchaudio版本，以及torchvision版本
4、下载对应版本的whl镜像安装文件。
5、在anaconda prompt中激活环境，按顺序安装对应的whl文件。
6、测试是否安装成功。
注：本次教程下载torch1.10.1版本，cuda10.2版本，python3.7.4版本。
二、查看cuda版本 快捷键win+R，输入cmd，回车。
在命令行中输入nvidia-smi
可以看到，本机的CUDA Version是11.6版本，所以在选择torch+cuda版本时，要注意，必须小于11.6.
三、确定并下载pytorch、torchaudio以及torchversion对应版本安装文件 注意：以python3.7版本，window系统为例。
1、确定torch版本及下载安装文件 打开网址https://download.pytorch.org/whl/cu102
点击torch，可以看到很多版本torch的whl安装文件。
按快捷键ctrl+f，搜索cu102-cp37（表示cuda10.2版本，python3.7版本），寻找合适的安装文件。
这里我们选择torch1.10.1版本，cuda10.2版本，python3.7版本
点击下载即可。
注：如果下载速度过慢，建议改换手机热点进行下载，速度很快。
2、确定torchvision版本及下载安装文件 打开网址https://pytorch.org/get-started/previous-versions/
找到下载的torch版本对应的torchvision版本。
如torch1.10.1对应的torchvision版本为0.11.2。
打开网址https://download.pytorch.org/whl/cu102选择torchversion
点击进入，同理ctrl+f搜索“cu102-cp37”，点击下载该版本的torchversion
3、确定torchaudio的版本及下载安装文件 与第二步同理，确定torchaudio的版本为0.10.2
进入torchaudio
找到下载的文件。
点击下载即可。
四、在anaconda中安装对应whl文件 将三个文件放到一个文件夹下。如D:/pytorch_whl
在anaconda prompt中激活或创建一个虚拟环境
依次安装三个whl文件。注意文件的绝对路径。以刚才的安装路径D:\pytorch_whl 为例，依次按下面顺序输入
pip install D:\pytorch_whl\torch-1.10.1+cu102-cp37-cp37m-win_amd64.whl pip install D:\pytorch_whl\torchaudio-0.10.1+cu102-cp37-cp37m-win_amd64.whl pip install D:\pytorch_whl\torchvision-0.11.2+cu102-cp37-cp37m-win_amd64.whl 解析：pip install 绝对路径\文件名
等待安装完成即可。
五、测试安装成功 在虚拟环境下打开python，进入python编程环境后输入import torch 回车后输入torch.cuda.is_available()。如果返回True则安装成功。
有问题可以查看本人的其他文章，如虚拟环境的创建等。
或者评论询问。
谢谢!!! 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6547ee1d544a20ab884afe61bd93507c/" rel="bookmark">
			java – 设置构造函数参数时无法解析对bean’entalManagerFactory’的引用；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​​​​​​我在我的代码中收到此错误.
org.springframework.beans.factory.BeanCreationException: Error
creating bean with name ‘roleRepository’: Cannot create inner bean
‘(inner bean)#7540dc57’ of type
[org.springframework.orm.jpa.SharedEntityManagerCreator] while setting
bean property ‘entityManager’; nested exception is
org.springframework.beans.factory.BeanCreationException: Error
creating bean with name ‘(inner bean)#7540dc57’: Cannot resolve
reference to bean ‘entityManagerFactory’ while setting constructor
argument; nested exception is
org.springframework.beans.factory.NoSuchBeanDefinitionException: No
bean named ‘entityManagerFactory’ available
我看到了这些：
Cannot resolve reference to bean ‘entityManagerFactory’ while setting constructor argument
NoSuchBeanDefinitionException: No bean named ‘entityManagerFactory’ available
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6547ee1d544a20ab884afe61bd93507c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c0ec32b480595d4751ab53d5677343a/" rel="bookmark">
			HDFS HA 模式namenode1无法启动，JournalNode报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述
数据突然写不进去，重启hdfs发现datasophon01节点namenode掉线
grep “ERROR” xxx.log 查看日志报错
1.1 查看datasophon01 节点namenode报错
通过报错发现 JournalNode 有问题
1.2 查看 JournalNode 节点
报错日志
JournalNode 原理
为了保证 Active 节点和 Standby 节点，即可以可靠的保持数据的一致性，又不会影响集群的可用性，HDFS 在 Active 节点和 Standby 节点之间引入了另外一个节点 JournalNode 节点。 JournalNode 节点作为 Active 节点和 Standby 节点的中间节点，它为两个节点解决了数据的同步的问题。首先 Active 节点会将元数据发送给 JournalNode 节点，然后 Standby 节点会从 JournalNode 节点获取需要同步的元数据。即使 Standby 节点故障了、产生问题了，在它恢复正常状态后，也可以从 JournalNode 节点中同步相应的数据。这就要求 JournalNode 节点需要有持久化的功能来保证元数据不丢。 但是，问题又来了，JournalNode 节点如果挂掉又怎么办？那么这就对 JournalNode 节点提出了新的要求，它需要保证自己的可靠性，才能保证为 Standby 节点提供数据。因此 JournalNode 节点本身也是一个多节点的集群，从而保证它自身的可靠性。而且 JournalNode 节点会在集群自动的选择一个"主"节点出来，Active 节点会和 JournalNode 的主节点通信，然后 JournalNode 集群的主节点会将数据发送给其他的节点，只要有过半的节点完成了数据的存储，JournalNode 集群的主节点，就会将成功信息返回给 Active 节点。当 JournalNode 集群的主节点挂掉，其他的 JournalNode 节点会快速选举出新的"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c0ec32b480595d4751ab53d5677343a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58011ff0463c2426197a20be6bc9089c/" rel="bookmark">
			ForkAndJoin-＞RecursiveTask
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、用途 Java 7开始引入了一种新的Fork/Join线程池，它可以执行一种特殊的任务：把一个大任务拆成多个小任务并行执行。Java7引入了Fork/Join框架，我们通过RecursiveTask这个类就可以方便地实现Fork/Join模式。
我们举个例子：如果要计算一个超大数组的和，最简单的做法是用一个循环在一个线程内完成：
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐ └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘ 还有一种方法，可以把数组拆成两部分，分别计算，最后加起来就是最终结果，这样可以用两个线程并行执行：
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐ └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘ ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐ └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘ 如果拆成两部分还是很大，我们还可以继续拆，用4个线程并行执行：
┌─┬─┬─┬─┬─┬─┐ └─┴─┴─┴─┴─┴─┘ ┌─┬─┬─┬─┬─┬─┐ └─┴─┴─┴─┴─┴─┘ ┌─┬─┬─┬─┬─┬─┐ └─┴─┴─┴─┴─┴─┘ ┌─┬─┬─┬─┬─┬─┐ └─┴─┴─┴─┴─┴─┘ 二、实例代码 例如，对一个大数组进行并行求和的RecursiveTask，就可以这样编写：
class SumTask extends RecursiveTask&lt;Long&gt; { static final int THRESHOLD = 100; long[] array; int start; int end; SumTask(long[] array, int start, int end) { this.array = array; this.start = start; this.end = end; } @Override protected Long compute() { if (end - start &lt;= THRESHOLD) { // 如果任务足够小,直接计算: long sum = 0; for (int i = start; i &lt; end; i++) { sum += array[i]; } try { Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58011ff0463c2426197a20be6bc9089c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebf5ce84a8fb1f86990391328549caf4/" rel="bookmark">
			基于opencv与pyqt5的人脸检测照相机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于opencv与pyqt5的人脸检测照相机
先放代码
import sys import cv2 from PyQt5.QtCore import QTimer, Qt, QDateTime from PyQt5.QtGui import QImage, QPixmap from PyQt5.QtWidgets import QApplication, QLabel, QVBoxLayout, QWidget, QPushButton, QMessageBox class CameraWidget(QWidget): def __init__(self): super().__init__() self.camera = cv2.VideoCapture(0) # 打开摄像头 self.image_label = QLabel(self) # 显示图像的Label layout = QVBoxLayout(self) layout.addWidget(self.image_label) self.timer = QTimer() # 定时器，用于不断读取图像 self.timer.timeout.connect(self.update_frame) self.start_button = QPushButton('开始摄像头', self) # 开始摄像头按钮 self.start_button.clicked.connect(self.start_camera) layout.addWidget(self.start_button) self.pause_button = QPushButton('暂停摄像头', self) # 暂停摄像头按钮 self.pause_button.clicked.connect(self.pause_camera) layout.addWidget(self.pause_button) self.capture_button = QPushButton('拍照', self) # 拍照按钮 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebf5ce84a8fb1f86990391328549caf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2460fb35b79551a48e059923ee812e3/" rel="bookmark">
			【k8s】核心概念篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 应用部署方式演变容器编排问题k8s简介k8s组件master节点node节点附加组件组件之间调用流 架构图核心概念服务的分类(无状态&amp;有状态)专业术语 应用部署方式演变 在部署应用程序的方式上，主要经历了三个时代：传统部署 -&gt; 虚拟化部署 -&gt; 容器化部署
传统部署：互联网早期，会直接将应用程序部署在物理机上
优点：简单，不需要其它技术的参与
缺点：不能为应用程序定义资源使用边界，很难合理地分配计算资源，而且程序之间容易产生影响
虚拟化部署：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境
优点：程序环境不会相互产生影响，提供了一定程度的安全性
缺点：增加了操作系统，浪费了部分资源
容器化部署：与虚拟化类似，但是共享了操作系统
优点：
可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等
运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦
容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署
容器编排问题 一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器
当并发访问量变大的时候，怎么样做到横向扩展容器数量
Swarm：Docker自己的容器编排工具，适合中小型项目Mesos：Apache的一个资源统一管控的工具，需要和Marathon结合使用，早于docker，支持5w+节点的控制Kubernetes：Google开源的的容器编排工具 k8s简介 kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器----Borg系统的一个开源版本，于2014年9月发布第一个版本，2015年7月发布第一个正式版本。
kubernetes的本质是一组服务器集群，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：
自我修复：一旦某一个容器崩溃，能够在1秒中左右迅速启动新的容器弹性伸缩：可以根据需要，自动对集群中正在运行的容器数量进行调整服务发现：服务可以通过自动发现的形式找到它所依赖的服务负载均衡：如果一个服务起动了多个容器，能够自动实现请求的负载均衡版本回退：如果发现新发布的程序版本有问题，可以立即回退到原来的版本存储编排：可以根据容器自身的需求自动创建存储卷 k8s组件 master节点 集群的控制平面，负责集群的决策(管理)。
ApiServer : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制Scheduler : 负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上ControllerManager : 负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等Etcd ：负责存储集群中各种资源对象的信息 node节点 集群的数据平面，负责为容器提供运行环境(干活的)
Kubelet : 负责维护容器的生命周期，即通过控制docker，来创建、更新、销毁容器KubeProxy : 负责提供集群内部的服务发现和负载均衡Docker : 负责节点上容器的各种操作 附加组件 kube-dns：负责为整个集群提供 DNS 服务Ingress Controller：为服务提供外网入口Prometheus：提供资源监控Dashboard：提供 GUIFederation：提供跨可用区的集群Fluentd-elasticsearch：提供集群日志采集、存储与查询 组件之间调用流 以部署一台nginx为例进行说明
首先明确一点：一旦k8s启动之后，master和node都会将自身的数据存储在etcd数据库中
一个nginx服务的安装请求，首先会被发送到master节点的apiserver组件上
apiserver组件调用scheduler组件去决定到底将服务安装在哪个node节点上
在此时，它会从etcd中读取node节点的信息，然后按照一定的算法进行选择，并将结果告知apiserver)
apiserver调用controller-manager去调度node节点安装nginx服务
kubelet接收到指令之后，会通知docker，然后由docker来启动nginx的pod
pod：k8s的最小操作单元，容器必须跑在pod中
到这里，一个nginx服务就运行成功了
架构图 核心概念 服务的分类(无状态&amp;有状态) 无状态 -&gt; 不依赖本地服务器环境
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2460fb35b79551a48e059923ee812e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eefcd9b996f2254e8253642c957f500/" rel="bookmark">
			IDEA中配置gradle加速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、IDEA配置如下二、配置阿里镜像加速2.1 创建init.gradle文件 三、重启IDEA 一、IDEA配置如下 二、配置阿里镜像加速 2.1 创建init.gradle文件 init.gradle 配置如下：
allprojects { repositories { mavenLocal() maven { allowInsecureProtocol true url 'https://maven.aliyun.com/nexus/content/repositories/central/' } } } 三、重启IDEA 可以看到gradle已经配置加速成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b33c2690f2e2c50c8e1bd034a5450f90/" rel="bookmark">
			Java项目：276SSM的仓库管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目介绍 基于SSM的仓库管理系统设计与实现
角色：管理员、员工
管理员：管理员登录系统后，可以对个人中心、员工管理、厂商信息管理、司机信息管理、门店信息管理、仓库信息管理、货物信息管理、货物入库管理、货物出库管理等功能
员工：员工登录到仓库管理系统后，可以对个人中心、厂商信息管理、司机信息管理、门店信息管理、仓库信息管理、货物信息管理、货物入库管理、货物出库管理等功能
由于本程序规模不大，可供课程设计，毕业设计学习演示之用
环境需要 1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目 6.数据库：MySql 5.7/8.0等版本均可；
技术栈 后端：SSM(Spring+SpringMVC+Mybatis)
前端：JSP+CSS+JS+JQUERY+Layui
使用说明 1. 使用Navicat或者其它工具，在mysql中创建对应名称的数据库，并导入项目的sql文件；
2. 使用IDEA/Eclipse/MyEclipse导入项目，修改配置，运行项目；
3. 将项目中db.xml配置文件中的数据库配置改为自己的配置，然后运行；
运行截图 相关代码 ConfigController
package com.controller; import java.util.Arrays; import java.util.Map; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import com.annotation.IgnoreAuth; import com.baomidou.mybatisplus.mapper.EntityWrapper; import com.entity.ConfigEntity; import com.service.ConfigService; import com.utils.PageUtils; import com.utils.R; import com.utils.ValidatorUtils; /** * 登录相关 */ @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b33c2690f2e2c50c8e1bd034a5450f90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a819eaebfc9d94a596211c5feaa9d85b/" rel="bookmark">
			SpringCloudAlibaba项目框架搭建详细过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、安装Alibaba Cloud Toolkit 插件： 二、创建SpringCloudAlibaba父项目及子模块命名： 1、项目名称：QKWL-SpringCloudAlibaba 2、子模块名称：qkwl-nacos 3、子模块名称：seata-account 4、子模块名称：seata-order 5、子模块名称：seata-stock 6、子模块名称：seata-business 三、SpringCloudAlibaba及子组件推荐版本： SpringCloudAlibabaVersion: 2021.0.5.0* SpringCloudVersion: SpringCloud 2021.0.5 SpringBootVersion: 2.6.13 NacosVersion:2.2.0 SentinelVersion:1.8.6 RocketMQVersion:4.9.4 DubboVersion: - SeataVersion: 1.6.1 四、SpringCloudAlibaba项目环境搭建： 1、创建父项目，名称：QKWL-SpringCloudAlibaba 2、子模块名称：qkwl-nacos 3、子模块名称：seata-account 移动子模块seata-account到alibaba-cloud文件夹中； 主模块pom.xml中添加子模块seata-account； 4、子模块名称：seata-order 移动子模块seata-order到alibaba-cloud文件夹中； 主模块pom.xml中添加子模块seata-order； 5、子模块名称：seata-stock 移动子模块seata-stock到alibaba-cloud文件夹中； 主模块pom.xml中添加子模块seata-stock； 6、子模块名称：seata-business 移动子模块seata-business到alibaba-cloud文件夹中； 主模块pom.xml中添加子模块seata-business； 7、所有模块pom.xml中添加 springboot、springcloud 、springcloudalibaba 版本号（参考版本对照表） &lt;properties&gt; &lt;spring-cloud-alibaba.version&gt;2021.0.5.0&lt;/spring-cloud-alibaba.version&gt; &lt;spring-cloud.version&gt;2021.0.5&lt;/spring-cloud.version&gt; &lt;spring-boot.version&gt;2.6.13&lt;/spring-boot.version&gt; &lt;/properties&gt; 8、各个模块运行情况 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a700cd45d7cd706d0a3409fcd9304cd/" rel="bookmark">
			shell远程执行命令无法将命令结果给变量赋值问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		远程执行命令，使用 “&lt;&lt;EOF” 的方式叫做 Heredoc，如果内部使用了变量，实际上是在本地shell做了替换，再提交到远程shell执行！ 关于HereDoc：https://linuxize.com/post/bash-heredoc/#using-heredoc-with-ssh
使用无引号分隔符时，请确保转义所有变量、命令和特殊字符，否则将在本地进行插值！
$变量，默认是提前在本地shell替换。$(命令)，默认是提前在本地shell执行。
比如，在 node1(192.168.0.1) 执行如下命令：
ssh -q root@node2 &lt;&lt;EOF echo $HOSTNAME log=$(hostname -I) echo $log EOF 实际上 node2(192.168.0.2) 执行的命令为：
echo node1 log=192.168.0.1 #如果命令返回带有空格，这里还会报错“命令不存在”，让人摸不着头脑 echo 可以看到，node2执行的命令都是被提前执行。
解决：避免替换变量和执行命令，进行转义。 方式一：将 ‘$’ 改成 ‘\$’
上述代码改成：
ssh -q root@node2 &lt;&lt;EOF echo $HOSTNAME log=\$(hostname -I) #注意前缀 echo \$log #注意前缀 EOF 实际node2执行的命令为：
echo node1 log=$(hostname -I) #在node2才执行 hostname -I echo $log #在node2才打印变量 方式二：将 EOF 改成 ‘EOF’，相当于全局禁用变量替换和命令执行！
ssh -q root@node2 &lt;&lt;'EOF' echo $HOSTNAME log=$(hostname -I) echo $log EOF 实际node2执行的命令为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a700cd45d7cd706d0a3409fcd9304cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c91fb3a4671fd0290566592ec133317a/" rel="bookmark">
			写作干货 | 论文中的Introduction部分主要写什么内容？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：科学指南针服务平台
编辑：研路科研人Sci
“研路漫漫，伴你同行”
Introduction是对Abstract的扩展，详细介绍这篇论文的领域背景和面临的困难，告诉读者这篇论文解决了什么，有什么样的科研结果。一般审稿人看到这里就可以判断出论文的总体质量如何，是否满足期刊的要求。在一定程度上，前言的质量也决定了读者是否会产生进一步阅读论文的兴趣。
小编今天就从重要性、内容结构、句式干货分享、常见误区四个方面来给大家总结干货，小伙伴们抓紧收藏呀！
在Introduction中，你必须告诉读者以下这些问题
我的研究主题是什么？
解释你为什么要研究这个主题，让读者进入你的逻辑体系之中。
在我做这项研究之前，现有学者对这个主题的了解有多少？
这项研究将产出什么样的创新或者将以什么样的创新方式进行研究？
Introduction三段式结构
Background（研究领域大范围，大背景介绍）
用简洁的语句给出研究背景，引导读者了解和主题相关的背景信息。从总体到局部，从现实问题到科学问题，逐步细化说明，进而提出存在的问题，找到切入点，定位你的研究主题。
注意：1. 用现实数据说明，2. 活用逻辑关联词
Literature review（研究领域细化及未知领域空白介绍）
1.说明研究现状：通过说明别人的研究成果，引出当前研究的不足、研究正确性的质疑与验证、当前研究的补充。
2.引出研究主题：如何填补上述技术的不足、或者功能和机制等有待进一步的探索和发现。
l In this paper （提出本文的研究主题，总结研究意义和重要性）
使用xx技术，xx方法，做了xx实验，可以概述关键成果，关键数据（针对上面提出的不足或者空白给出解决方案，这是审稿人和读者的关注点），并总结本文的创新点和意义。
introduction常用句式，可参考
一、用来引出自己研究重要性和创新性以及前人研究的不足之处。
Their studies may be more reasonable if they had ... considered this situation.
Their results could be better convinced if they...
Their conclusion may remain some uncertainties
二、当研究方法和方向与前人一样时，用来强调自己的工作。
However, data is still scarce/rare/less accurate,we need to/aim to/have to provide more documents/data/records/studies/increase the dataset.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c91fb3a4671fd0290566592ec133317a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c45392b8fafd1d11a57f7711ea4b7ebf/" rel="bookmark">
			js之加减乘除精度问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：在计算金额时对于精度要求比较高，所以需要考虑精度问题 例子：
const m = 1.11; const n = 100; //直接进行乘法： console.log(m*n) //111.00000000000001 解决方案：
使用decimal.js
decimal.js是使用的二进制来计算的，所以可以更好地实现格化式数学运算，对数字进行高精度处理；使用decimal类型处理数据可以保证数据计算更为精确，还可以节省储存空间。
实现步骤：
下载依赖：
$ npm install --save decimal.js import { Decimal } from 'decimal.js' 使用：
const m = 1.11; const n= 100; // 加法 let add = new Decimal(m).add(new Decimal(b)) // 减法 let sub = new Decimal(m).sub(new Decimal(n)) // 乘法 let mul = new Decimal(m).mul(new Decimal(n)) console.log(mul.toNumber()) // 111 // 除法 let div = new Decimal(m).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c45392b8fafd1d11a57f7711ea4b7ebf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb5396f7f756757734595ad044052419/" rel="bookmark">
			教你如何使用API接口获取数据！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用API接口获取数据的过程通常涉及到几个步骤，包括了解API、注册获取API密钥、编写代码调用API并处理返回的数据。下面是一个详细的教程。
一、了解API API（Application Programming Interface）即应用程序编程接口，是一种使不同的应用程序能共享数据和功能的软件工具。API可以通过网络、软件或硬件实现。在网络环境中，API使得应用程序能够彼此交互。在软件或硬件中，API使得不同的组件能够互相操作。
在编写代码调用API之前，你需要了解API的工作方式。一般来说，你需要知道以下几个方面：
API的请求方法：常用的HTTP请求方法有GET、POST、PUT、DELETE等，不同的请求方法对应不同的操作。API的URL：这是你的代码将发送请求的地址。API的参数：一些API可能需要参数来完成特定的操作，例如，你可能需要提供一个特定的ID来获取某个特定的数据。API的返回数据：你需要知道API返回的数据的格式（如JSON、XML等）以及数据的含义。 二、注册获取API密钥 在使用一些需要认证的API时，你需要先进行注册并获取API密钥。API密钥一般在API提供者的网站上创建和管理。创建API密钥后，你需要在你的代码中使用这个密钥来进行身份验证。
三、编写代码调用API并处理返回的数据 下面是一个使用Python的requests库调用API的例子：
import requests # API地址和密钥 api_url = "https://api.example.com/data" api_key = "your_api_key" # 请求参数（例如筛选条件） params = { "keywords": "手机", "category": "electronics" } # 发送GET请求获取数据 response = requests.get(api_url, params=params, headers={"X-Api-Key": api_key}) # 解析JSON数据 data = response.json() 在这个例子中，我们使用requests库发送GET请求，并将API地址、请求参数和API密钥作为参数传递给请求函数。响应数据将以JSON格式返回，我们使用response.json()方法将其解析为Python字典。
需要注意的是，不同的API可能有不同的请求方法和参数，因此在使用具体的API时，你可能需要调整上述代码。另外，一些API可能需要额外的身份验证步骤，例如提供一个访问令牌（access token）。在这种情况下，你需要按照API提供者的要求进行操作。
四、异常处理 在调用API的过程中，可能会出现一些错误，如网络错误、超时或API返回的错误状态。为了程序的健壮性，我们需要进行异常处理。下面是使用Python的try-except语句进行异常处理的例子：
import requests from requests.exceptions import RequestException # API地址和密钥 api_url = "https://api.example.com/data" api_key = "your_api_key" # 请求参数（例如筛选条件） params = { "keywords": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb5396f7f756757734595ad044052419/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a79cb0bc833c35e379d9ae2e9faac2d0/" rel="bookmark">
			JVM垃圾收集器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		垃圾回收算法 分代收集理论 当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几 块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。 比如在 新生代 中，每次收集都会 有大量对象(近99%)死去 ，所以可以 选择复制算法 ，只需要付出少量对象的复制成本就可 以完成每次垃圾收集。而 老年代 的对象 存活几率是比较高 的，而且没有额外的空间对它进行分配担保，所以我们必须 选 择“标记-清除”或“标记-整理”算法 进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法慢10倍以上。 标记-复制算法 为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的 内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。 标记-清除算法 算法分为 “标记”和“清除 ”阶段：标记存活的对象， 统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 。它是最基础的收集算法，比较简单，但是会带来两个明显的问题： 1. 效率问题 (如果需要标记的对象太多，效率不高) 2. 空间问题（标记清除后会产生大量不连续的碎片） 标记-整理算法 根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。 垃圾收集器 如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。
虽然我们对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的Java虚拟机就不会实现那么多不同的垃圾收集器了。
1.1 Serial收集器(-XX:+UseSerialGC -XX:+UseSerialOldGC) Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ "Stop The World" ），直到它收集结束。
新生代采用复制算法，老年代采用标记-整理算法。
虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。
但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。
Serial Old收集器是Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。
1.2 Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代)) Parallel收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器类似。默认的收集线程数跟cpu核数相同，当然也可以用参数(-XX:ParallelGCThreads)指定收集线程数，但是一般不推荐修改。
Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。 Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。
新生代采用复制算法，老年代采用标记-整理算法。
Parallel Old收集器是Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器(JDK8默认的新生代和老年代收集器)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a79cb0bc833c35e379d9ae2e9faac2d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0fb43ecba46de5fcf5a74e7977ec3fc/" rel="bookmark">
			idea2023自带的maven打包报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 从idea2019切换到2023.2.2版本后发现新版本自带的maven（版本号3.9.2）启动程序后依赖的jar对应的项目就不能正常打包，具体内容如下：
二、问题描述 1、一个有A,B两个项目，A项目依赖B项目使用maven打出来的jar
2、A项目正常启动后，使用idea重新打包
3、日志栏出现报错提示：
D:\maven\ldyx\repository\com\ldyx\common\common-component\1.0.0-SNAPSHOT\common-component-1.0.0-SNAPSHOT.jar.14328037589785374012.tmp -&gt; D:\maven\ldyx\repository\com\ldyx\common\common-component\1.0.0-SNAPSHOT\common-component-1.0.0-SNAPSHOT.jar
大概意思是打包出来的临时文件无法tmp将原来的jar覆盖
4、手动去文件资源管理器直接删除，提示文件被占用，将A项目停掉后重试也不起作用
5、将idea重启有效，但是这种方法太呆了，睡了一觉后想到可能是maven打包问题，于是看了一下idea2019自带的maven版本，果然和2023的不一样，于是乎尝试了下述方案，问题解决。
三、解决方案 将idea设置为自己安装的maven，本文使用的版本是3.6.1设置路径：file-&gt;settings-&gt;build,Execution,Deployment-&gt;Build Tools-&gt;maven
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac11124c327546b713d2d7d20298941c/" rel="bookmark">
			windows10下linux子系统(wsl)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 windows10下linux子系统安装如何更改安装目录到其他盘如何重启 Windows 10 子系统（WSL) ubuntuwsl升级为wsl2WSL中启动docker如何找到wsl子系统对应的本地文件目录在wsl中如何访问window文件其他遇到docker: unrecognized service 参考 windows10下linux子系统 windows10可以安装linux子系统，但是就目前个人使用感受来说，作为新手入门和学习linux可以使用，但若是作为开发中的编译环境来使用那就不可了，经常会报出一些出乎意料的错误，慎用官方说明文档：https://docs.microsoft.com/zh-cn/windows/wsl/ 适用于 Linux 的 Windows 子系统概述 | Microsoft Docs 安装 在windows10下安装linux子系统可以参考微软的文档https://docs.microsoft.com/en-us/windows/wsl/install-win10，其实主要也就三步
step1.管理员打开PowerShell,运行如下命令后会提示重启
Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux step2.在微软商店搜索ubuntu进行下载安装
step3.安装完成后进入ubuntu会提示创建用户和密码，按提示做就行了
安装完Ubuntu后忽然意识到没有设置root密码，我们可以在终端输入命令 sudo passwd，然后输入当前用户的密码，enter，终端会提示我们输入新的密码并确认，此时的密码就是root新密码。修改成功后，输入命令 su root，再输入新的密码就ok了
如果你想默认root用户登录，那么打开cmd执行以下命令即可
&lt;ubuntu版本&gt; config --default-user root ‪其中的 &lt;ubuntu版本&gt; 并不是固定的，你可以到此路径下查看：C:\Users\&lt;用户名&gt;\AppData\Local\Microsoft\WindowsApps，比如我的查到为ubuntu2004.exe ，那么我就执行
ubuntu2004 config --default-user root 如何更改安装目录到其他盘 默认情况下wsl是安装在c盘的，如果我们的c盘比较吃紧的话，那么就需要考虑迁移到其他盘,命令示例如下wsl -l --all -v # 查看已安装的linux发行版本 wsl --export Ubuntu d:\wsl2-ubuntu.tar # 导出分发版为tar文件到d盘 wsl --unregister Ubuntu # 注销当前分发版 wsl --import Ubuntu d:\wsl2-ubuntu d:\wsl2-ubuntu.tar --version 2 # 重新导入并安装WSL在D盘 del d:\wsl2-ubuntu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac11124c327546b713d2d7d20298941c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcb12b1730e5a19d6164d1519612910c/" rel="bookmark">
			报错处理：Java Heap Space Error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，今天我来分享一个我在运维过程中遇到的问题，关于Linux上Tomcat启动时出现的“Java Heap Space Error”（Java堆内存错误），以及如何解决这个问题的。
首先，让我们来看看这个报错信息。当你在启动Tomcat时，如果你看到类似以下的错误信息：
java.lang.OutOfMemoryError: Java heap space 那么，这意味着Java虚拟机（JVM）在尝试分配更多的内存时遇到了问题。在这种情况下，以下是可能的原因和解决方案：
内存不足：首先，检查你的服务器内存使用情况。如果内存不足，你可以尝试关闭一些不必要的服务或者增加服务器的内存。如果你在虚拟机中运行Tomcat，你也可以尝试增加虚拟机的内存分配。
JVM配置不当：在Tomcat的配置文件（通常是setenv.sh或setenv.bat）中，可以设置JVM的内存参数，如-Xms和-Xmx。-Xms表示JVM初始堆大小，-Xmx表示JVM最大堆大小。你可以尝试增大这两个参数的值，但需要注意不要超过你的服务器物理内存或虚拟机的最大内存。
程序内存泄漏：如果你的应用或Tomcat本身存在内存泄漏的问题，也会导致内存耗尽。这时需要详细分析应用的内存使用情况，检查是否存在长时间不能被垃圾回收的对象。如果是Tomcat本身的问题，可能需要升级到更高版本的Tomcat或者向Tomcat官方反馈问题。
其他系统问题：有时候，其他系统问题也可能导致内存不足的错误。例如，磁盘空间不足、进程被过度CPU资源等。在解决上述问题后，如果仍然无法启动Tomcat，可以尝试查看系统日志或Tomcat的错误日志，查找更多关于问题的信息。
总之，如果你遇到类似的报错信息，可以从上述几个方面入手，逐步排查并解决问题。记得在进行任何配置更改或系统调整前，备份重要的数据，并确保你知道如何撤销更改以恢复到之前的状态。
最后，如果你还有其他问题或者需要进一步的帮助，欢迎关注我的公众号【运维家】，并在文章下方留言或者私信我。我会尽力回复并提供帮助。谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/826f69663dee27b760320a1b1cf16500/" rel="bookmark">
			数据结构 线性表习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设我们有一个顺序表 L，其中存储了一些元素。我们将通过这个算法来删除顺序表中最后一个大于其后继元素的元素。
1. 首先，我们初始化两个变量 i 和 j。
- 变量 i 作为循环变量，用于遍历顺序表 L 的元素。
- 变量 j 初始化为 0，用于记录最后一个满足条件的元素的位置。
2. 开始循环遍历顺序表 L。从位置 l（注意，这里 l 是一个变量）开始，一直遍历到顺序表的最后一个元素（索引为 L-&gt;length - 1）。
3. 在每次循环中，我们比较当前元素 L-&gt;data[i] 与其后继元素 L-&gt;data[i+1] 的值。
- 如果当前元素大于其后继元素，说明我们找到了满足条件的元素。我们将 j 更新为当前的位置 i，以便后续操作中删除该元素。
4. 循环结束后，我们得到顺序表 L 中最后一个大于其后继元素的元素的位置 j。
5. 接下来，我们使用另一个循环，从位置 j 开始，将顺序表 L 中后续元素依次左移一位，以覆盖掉最后一个大于其后继元素的元素。
- 也就是将 L-&gt;data[i] 的值更新为 L-&gt;data[i+1]，直到顺序表的倒数第二个元素（索引为 L-&gt;length - 2）。
6. 最后，我们将顺序表 L 的长度减一（L-&gt;length--），表示删除了一个元素。
这样，最后一个大于其后继元素的元素将被删除，并且顺序表的长度减小了一。
请注意，这段代码是使用 C 语言编写的，其中出现的 "-&gt;" 操作符用于访问指向结构体的指针中的成员。
该算法的目标是将元素 x 插入到顺序表 L 中，同时保持顺序表的有序性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/826f69663dee27b760320a1b1cf16500/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0734cebb00fb8bf25410ec07b07f258/" rel="bookmark">
			elk&#43;kafka日志分析系统搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、elk引入
二、认识elk+kafka+filebeat
Elasticsearch
Logstash
Kibana
kafka
三、elk+kafka架构图
四、elasticsearch部署
1、服务器情况
2、添加环境变量
3、系统性能优化
4、node1节点部署
5、启动集群
6、查看集群状态
五、kibana
1、部署环境
2、安装kibana
3、启动kibana
六、部署kafka
1、部署环境
2、安装kafka
3、启动zookeeper
4、启动kafka
5、验证kafka
七、logstash部署
1、环境部署
2、安装lostash
3、启动logstash
八、filebeat部署
1、环境部署
2、安装filebeat
3、启动filebeat
九、启动nginx验证kibana是否正常展示数据
1、启动nginx
2、登录kibana验证
一、elk引入 如果在实际生产情况下，查看日志大都通过SSH客户端登服务器去看，使用较多的命令就是 less 、cat、head、tail。如果服务部署了几十台甚至上百台服务器，就要分别登录到这些台机器上看，这样大大的降低了我们的工作效率，等到了分布式和微服务架构流行时代，一个从APP或H5发起的请求除了需要登陆服务器去排查日志，往往还会经过远程软件远程到了别的主机继续处理，开发人员定位问题可能还需要根据TraceID或者业务唯一主键去跟踪服务的链路日志，基于传统SSH方式登陆主机查看日志的方式就像图中排查线路的工人一样困难，线上服务器几十上百之多，出了问题难以快速响应，因此需要高效、实时的日志存储和检索平台，ELK就提供这样一套解决方案。
二、认识elk+kafka+filebeat ELK是三个开源软件的缩写，分别表示：Elasticsearch , Logstash, Kibana , 它们都是开源软件。Filebeat是用于转发和集中日志数据的轻量级传送工具。Filebeat监视您指定的日志文件或位置，收集日志事件，并将它们转发到Elasticsearch或 Logstash进行索引。
首先，elk作为日志分析架构，主要使用这几个组合：filebeat（采集）+logstash（管道）+elasticsearch（存储和搜索）+kibana（日志应用）的这种组合比较常见。
kafka作为适合大吞吐数据的临时队列，比较适合放置在filebeat和logstash之间
Elasticsearch Elasticsearch 是一个实时的分布式存储、搜索、分析的引擎。
Elasticsearch 是一个分布式的、开源的搜索分析引擎，支持各种数据类型，包括文本、数字、地理、结构化、非结构化。
Elasticsearch 因其简单的 REST API、分布式特性、告诉、可扩展而闻名。
Elasticsearch 是 Elastic 产品栈的核心，Elastic 产品栈是个开源工具集合，用于数据接收、存储、分析、可视化。
Logstash Logstash是具有实时流水线能力的开源的数据收集引擎。Logstash可以动态统一不同来源的数据，并将数据标准化到您选择的目标输出。它提供了大量插件，可帮助我们解析，丰富，转换和缓冲任何类型的数据
Kibana Kibana是一个开源的分析与可视化平台，设计出来用于和Elasticsearch一起使用的。你可以用kibana搜索、查看存放在Elasticsearch中的数据。Kibana与Elasticsearch的交互方式是各种不同的图表、表格、地图等，直观的展示数据，从而达到高级的数据分析与可视化的目的。
kafka Kafka是Apache旗下的一款分布式流媒体平台，Kafka是一种高吞吐量、持久性、分布式的发布订阅的消息队列系统。 它最初由LinkedIn(领英)公司发布，使用Scala语言编写，与2010年12月份开源，成为Apache的顶级子项目。 它主要用于处理消费者规模网站中的所有动作流数据。动作指(网页浏览、搜索和其它用户行动所产生的数据)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0734cebb00fb8bf25410ec07b07f258/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c100d4ea86a40d89fcebf84c415d4f9b/" rel="bookmark">
			Python 逢七拍手小游戏1.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		""" 逢七拍手游戏 介绍： 逢七拍手游戏的规则是：从1开始顺序数数，数到有7，或者是7的倍数时，就拍一手。 例如：7、14、17......70...... 知识点： 1、循环语句for 2、嵌套条件语句if/elif/else 3、数据类型转换 4、字符串索引 5、退出程序函数exit() 举一反三： 1、当输入非整数时，如何给出提示，并重新输入 2、如何循环输入，直至满足退出条件 """ count = 0 # 计次 # 提示语 print('根据您输入数字，输出它倍数以及包含它的所有数') num = int(input('请输入1-9的数字：')) # 制定范围 if num &lt; 1 or num &gt; 9: print('输入有误！请重新输入1-9的数字') exit() # 停止当前程序的执行并退出 # 在1-100中找到倍数和包含本身的数 for i in range(1, 101): # 倍数 if i % num == 0: print(i, end='\t') count += 1 # 计数 # 包含本身的数 else: for j in str(i): if j == str(num): print(i, end='\t') count += 1 # 计数 # 换行排列 if count % 5 == 0 and count !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c100d4ea86a40d89fcebf84c415d4f9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f3d99d6ec39623ac43f47337c4ef3ae/" rel="bookmark">
			Hugging Face 无法连接问题 OSError: We couldn‘t connect to ‘https://huggingface.co‘ to load this file 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天打算用一下hugging face的BERT模型，跑代码的时候显示连接不了，应该是hugging face的网站不稳定，国内连接比较困难。报错信息如下：
解决方案很简单，根据报错的提示，打开Hugging Face官网，将所需要的模型下载到本地，更改一下引用路径就可以啦！
step 1：打开Hugging Face官网https://huggingface.co/docs/transformers/installation#offline-mode：
step 2：搜索你需要的模型，点击Files and version，这里是bert-base-uncased：
step 3：根据你的框架选择合适的文件，我用的是pytorch （如果是TensorFlow就将pytorch_model.bin换成tf_model.h5就好啦），选择以下五个文件下载到本地：
step 4：将下载好的文件放在你需要的目录下，比如我这里建立了一个bert-base-uncased文件夹存放：
step 5：将用到的地方改成你自己的路径就可以啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/311717fa541f06cfd90dfd1927182ab9/" rel="bookmark">
			JVM字节码结构文件剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提问：java中对多能实现多少个接口？ 00 00==&gt;FFFF==&gt;15*16^3+15*16^2+15*16+15
class常量池类型分类 一:源代码 package com.tuling.smlz.jvm.classbyatecode; /** * Created by smlz on 2019/11/5. */ public class TulingByteCode { private String userName; public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } } 二:通过我们javap -verbose TulingByteCode .class反编译 //表示我们通过反编译的来源是哪个字节码文件 Classfile /D:/work_space/idea_space/spring-cloud-source/tuling-jvm/target/classes/com/tuling/smlz/jvm/classbyatecode/TulingByteCode.class //最后修改日期；文件大小 Last modified 2019-11-5; size 629 bytes //文件的md5值 MD5 checksum a0a9c001787f00738627278b0946a388 //.class文件是通过哪个源文件编译过来的 Compiled from "TulingByteCode.java" //字节码的详细信息 public class com.tuling.smlz.jvm.classbyatecode.TulingByteCode //jdk的次版本号 minor version: 0 //jdk的主版本号 major version: 52 //访问权限 flags: ACC_PUBLIC, ACC_SUPER //常量池 Constant pool: #1 = Methodref #4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/311717fa541f06cfd90dfd1927182ab9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d51913fe987be325b59ad157b10a5bc1/" rel="bookmark">
			ide(pycharm,goland...)装多个lua插件导致奔溃的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去对应目录下删除插件（注意：不是IDE的安装目录）：
Windows: Configuration (idea.config.path): C:\Users\&lt;user&gt;\AppData\Roaming\JetBrains\IntelliJIdea2020.3 Plugins (idea.plugins.path): C:\Users\&lt;user&gt;\AppData\Roaming\JetBrains\IntelliJIdea2020.3\plugins System (idea.system.path): C:\Users\&lt;user&gt;\AppData\Local\JetBrains\IntelliJIdea2020.3 Logs (idea.log.path): C:\Users\&lt;user&gt;\AppData\Local\JetBrains\IntelliJIdea2020.3\log macOS: Configuration (idea.config.path): ~/Library/Application Support/JetBrains/IntelliJIdea2020.3 Plugins (idea.plugins.path): ~/Library/Application Support/JetBrains/IntelliJIdea2020.3/plugins System (idea.system.path): ~/Library/Caches/JetBrains/IntelliJIdea2020.3 Logs (idea.log.path): ~/Library/Logs/JetBrains/IntelliJIdea2020.3 Linux: Configuration (idea.config.path): ~/.config/JetBrains/IntelliJIdea2020.3 Plugins (idea.plugins.path): ~/.local/share/JetBrains/IntelliJIdea2020.3 System (idea.system.path): ~/.cache/JetBrains/IntelliJIdea2020.3 Logs (idea.log.path): ~/.cache/JetBrains/IntelliJIdea2020.3/log 删除插件即可：
附——离线下载插件 离线下载地址：
http://plugins.jetbrains.com/
1、下载插件：http://plugins.jetbrains.com/
2、安装插件：settings -&gt; plugins -&gt; install plugin from disk，然后重启IDEA即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f1d3d64bc87c5bde21421435f19a06d/" rel="bookmark">
			webpack4&#43;vue3.0&#43;element-plus创建基于vue3的项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webpack4+vue3.0创建基于vue3的项目 1 安装vue vue-cli2 创建步骤2.1 创建命令2.2 Please pick preset(选择预定配置）2.3 Check the features needed for your project (选择你项目需要添加的功能)2.4 Choose a version of Vue.js that you want to start the project with (选择项目使用的vue版本)2.5 Use history mode for router? (路由是否使用 history模式)2.6 Pick a CSS pre-processor ： (选择一个CSS预处理器)2.7 Pick a linter / formatter config (选择一个格式化配置)2.8 Pick additional lint features (选择代码格式检查时机)2.9 Where do you prefer placing config for Babel, ESLint, etc.?2.10 Save this as a preset for future projects?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f1d3d64bc87c5bde21421435f19a06d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1467655fcc74e17646853d9ef1a7cda/" rel="bookmark">
			PTA 编程题 -- 后天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果今天是星期三，后天就是星期五；如果今天是星期六，后天就是星期一。我们用数字1到7对应星期一到星期日。给定某一天，请你输出那天的“后天”是星期几。
输入格式： 输入第一行给出一个正整数D（1 ≤ D ≤ 7），代表星期里的某一天。
输出格式： 在一行中输出D天的后天是星期几。
输入样例： 3 输出样例： 5 思路：先计算今天是星期一后的第几天。显然如果今日是星期D，那么今天就是星期一后的第D-1天。所以后天就是星期一后的第D-1+2天。如果这个数小于等于6，那么后天的星期数就是1+(D-1+2)；如果这个数大于等于7了，说明从星期一起算，后天经过的时间超过一周了，我们需要对它模7，得到(D-1+2)%7，然后后天的星期数就是1+(D-1+2)%7。综合起来看，如果一个数小于等于6，那么模7等于没模，所以后天的星期数可以统一写成1+(D-1+2)%7。
这个思路好处是不但能计算后天，还能计算后n天是星期几。
代码：
#include &lt;stdio.h&gt; int main () { int D; scanf("%d", &amp;D); printf("%d",1+(D-1+2)%7); return 0; } 更多PTA题目的的参考代码，可以在下面的小程序里找到哦 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3bd727a70fe2ae12c2a0098cfcc369b/" rel="bookmark">
			Java JVM分析利器JProfiler 结合IDEA使用详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、JProfiler是什么？二、我的环境三、安装步骤1.Idea安装JProfiler插件1.下载程序的安装包 四、启动 前言 对于我们Java程序员而言，肯定需要对项目工程进行JVM监控分析，最终选择jprofiler，它可以远程链接，使用方便，功能也很强大！
一、JProfiler是什么？ JProfiler是一个重量级的JVM监控工具，提供对JVM精确监控，其中堆遍历、CPU剖析、线程剖析看成定位当前系统瓶颈的得力工具。可以统计压测过程中JVM的监控数据，定位性能问题。
二、我的环境 IDEA版本：IntelliJ IDEA 2023.1.2
JDK版本：JDK17
三、安装步骤 1.Idea安装JProfiler插件 手动下载插件的地址：点击下载
IDEA操作路径：File-&gt;Settings-&gt;Plugins 搜索：JProfiler 然后点击Install
快捷键：Ctrl+Alt+s
安装成功后Idea如下图：
1.下载程序的安装包 官网下载地址：点击访问下载
点击DOWNLOAD,然后根据你的操作系统选择对应的下载安装包，我的是Windows系统，我就下载Windows的安装包！
下载完成后进行安装
![在这里插入图片描述](https://img-blog.csdnimg.cn/a0cf4eefab0f4c2ea4d4006ac18eb889.png
安装路径可以自己选择，我选择默认的
接下来需要配置许可证，需要去官网进行申请，填写姓名，公司名称，邮箱然后点击PROCEED
注册网址：点击访问
然后你会收到一份邮件，将注册码复制出来，
然后回到注册界面，填写好信息
截止出现上面的界面，就代表已经安装成功了！
四、启动 会自动获取填充
就启动成功了！然后就可以很直观的看到数据了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6f56d66a897d6a84172540293a05be3/" rel="bookmark">
			坐标文件的加前缀处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		野外测量坐标文件，统一加前缀。
代码如下，提取每条记录的第一个数字，加前缀后，补齐4位。
import easygui as eg import re qz="AAABCA" str1 = eg.fileopenbox('选择数据文件.') eg.msgbox(str1) fn=str1 fn1=fn+'.txt' f1=open(fn1,'w',encoding='utf-8') with open(fn,'r',encoding='utf-8') as f: ss=f.readlines() for e in ss: t=e no=re.findall(r'\d+',e)[0] lst=t.split(",")[1:] tt=','.join(lst) no="{:0&gt;4}".format(no) t1=qz+no+','+tt f1.write(t1) f1.close() 先选择数据文件fn，然后生成数据文件fn.txt。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cb309ef6d827f2aaf8dd86b80709ad7/" rel="bookmark">
			前端界面直接生成源码？用这个工具直接生成VUE代码，简单易用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐一个前端代码生成工具iVX。我个人使用这个工具也有一段时间了，感觉做的很不错。有需要生成前端代码的同学可以关注了解一下，在下面的这个例子中，我生成了两个编辑框和两个按钮。
上手一个工具的最便捷路径就是看它的官方文档和教程。同样，iVX官网也提供了这些详细的教程以及相应的案例。沉下心来，跟着每一节课慢慢的去学习，你就会了解到iVX的强大。
首先，我要向大家说明的是iVX并不是一个免费的软件，因为当你使用它的发布按钮时你会发现它是需要钱的。但是先不要着急排斥，你在iVX做的程序如果想要直接发布成一个应用程序的话，那么它是需要钱的。如果你只是使用iVX生成界面代码的话，并且导出源码，那么它是免费的
我们只需要点击页面右上角的文件，然后选择导出前端源码即可将代码导出为一个压缩包。在点击导出前端源码这个按钮，浏览器会弹出一个窗口下载这个压缩包，压缩包内就是我们需要用到的源码。
这个iVX生成的源码的下载界面截图。需要注意的，在导出源码之前，你不要忘记点击保存。。。因为它不是自动保存的，我一开始忘记点保存，卡了好久。。点击保存后，直接就可以生成源码了。
看，这是iVX生成的源码，不错吧！我个人之所以喜欢这个工具，很大原因是我是一个后台开发者，前端的东西感觉很复杂又不想碰，所以选择了iVX，如果你跟我一样的话，那么是个不错的选择。如果你本身就是一个前端开发者的话，那么这个工具会更好的帮助到你。
在iVX的官网上有它的详细教程，这个教程可以方便我们很快的学会它这个界面编程。前面也讲了，本身iVX是通过界面拖拽的方式来自动生成代码的，使用VB6以及C#的同学应该都知道，很方便。比你手动写UI界面代码也方便的多了
当然我们不能指望这东西生成的代码完全符合我们的要求，这个后面肯定要改的。但的确可以为我们提供不同的思路，而且说实话它的组件真的挺多的。。。那啥地图它都有。。所以我想无论是在学习前端的同学，还是已经上手的同学用起来都挺方便的。至于它生成应用程序收费这个，人家也要吃饭。不过导出源码这个免费，可以让我们有极大的操作
空间了。最后如果对你有帮助，记得点赞收藏评论关注！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/311a2fdf6832615f1983eee6ebecbd7c/" rel="bookmark">
			Java内存模型-JMM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 说明主内存与工作内存内存间交互操作volatile关键字可见性禁止指令重排序 针对long和double型变量的特殊规则原子性、可见性与有序性先行先发生原则 说明 Java内存模型（Java Memory Model，JMM）是Java编程语言中用于管理多线程并发访问共享内存的规范。它定义了多线程程序中内存访问的行为和规则，以确保程序在不同的计算机体系结构和JVM实现中的一致性和可预测性。
主内存与工作内存 Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。为了获得更好的执行效能，Java内存模 型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器是否要进行调整代码执行顺序这类优化措施。
Java内存模型规定了所有的变量都存储在主内存（Main Memory，也是虚拟机内存的一部分）中。每条线程还有自己的工作内存（Working Memory，可以理解为高速缓存），线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，如下图
内存间交互操作 关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从 工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下8种操作来完成。Java虚拟机实 现时必须保证下面提及的每一种操作都是原子的、不可再分的
lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的 变量副本中。
use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量， 每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
可以将Java内存模型的操作简化为read、write、lock和unlock四种，但这只是语言描述上的等价化简，Java内存模型的基础设计并未改变。
volatile关键字 关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，Java内存模型为volatile专门定义了一些特殊的访问规则。
当一个变量被定义成volatile之后，它将具备两项特性：第一项是保证此变量对所有线程的可见，第二个语义是禁止指令重排序优化，这里进行说明。
可见性 在多线程编程中，当一个线程修改了一个共享变量的值时，其他线程可能不会立即看到这个变化。因为每个线程都有自己的工作内存，都有一份共享变量的副本，每个线程可能会在自己的工作内存中缓存共享变量的值，而不是直接从主内存中读取。
使用volatile关键字可以解决工作多线程先共享变量的可见性问题
volatile 读写操作如下：
写入操作：每次对 volatile 变量的写入操作都会立即刷新到主内存中，而不会在本地线程缓存中保留副本。这确保了其他线程在读取时可以看到最新的值。
读取操作：每次对 volatile 变量的读取操作都会从主内存中获取最新的值，而不是使用本地缓存的旧值。这确保了读操作能够看到写操作的效果。
因此，volatile 关键字确保了在多线程环境下对变量的读写都与主内存同步，从而实现了可见性。这使得任何一个线程对 volatile 变量的修改都会被立即反映到主内存，而其他线程在读取该变量时可以看到最新的值，而不需要担心线程间的数据不一致性问题。
禁止指令重排序 下面先说一个指令重排序出现的问题
假设有一个包含两个整数字段的类：
class ReorderExample { private int x = 0; private volatile boolean flag = false; public void writer() { x = 42; // 写操作1 flag = true; // 写操作2 } public void reader() { if (flag) { // 读操作1 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/311a2fdf6832615f1983eee6ebecbd7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8283f814a63876dae903861d889dc888/" rel="bookmark">
			VScode配置默认终端为Anaconda Prompt (2023/9)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上一堆教程说的是在设置中的Terminal › Integrated › Shell: Window进行配置，但是新版的VScode已经找不到这个设置项了。
新版VScode可以首先找到Terminal › Integrated › Profiles: Window，之后点击edit in setting.json，然后setting.json会出现一些默认的格式。如图：
如果安装过anaconda是有“Command Prompt"的参数的，之后我们找到Anconda Prompt，右键选择属性，将目标里的参数复制下来，将对应的部分放进“Command Prompt"的”args"里即可。
如果想进一步设置点击New Terminal默认就是开启cmd的话（VScode默认是PS），再setting.json中再添加一句：
"terminal.integrated.defaultProfile.windows": "Command Prompt" 注意这一行是和上面的"terminal.integrated.profiles.windows"是同级的，即：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cda6f66a353285e60713a98bf5ea4ffc/" rel="bookmark">
			关于CANoeIL层的capl用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于CANoeIL层的capl用法 1、IL层简介2、capl用法示意用于控制节点向总线发送信号 1、IL层简介 IL即interaction layer，CAnoe的标准模型库将BUS在水平方向上，划分成三部分：IL（交互层）、NM（网络管理）、TP（传输协议）。在垂直方向上，划分成了三部分：CAN、FlexRay、Ethernet。IL层定义message 和signal的行为方式，比如什么时候发，发送周期是多少。
2、capl用法示意 用于控制节点向总线发送信号 在发送报文的节点中添加以下capl代码：
on preStart { ILControlInit();//CANoe IL init ILControlStop();//CANoe IL 停止发送报文 } 运行canoe可以发现该节点不再发送报文，去掉ILControlStop可以正常发报文在总线上。
也可以把stop()改为ILControlStart()也可以正常发送信号
总结这几个语句可以用于控制节点向总线发送信号。
ILControlInit();//CANoe IL init ILControlStop();//CANoe IL 停止发送报文 ILControlStart();//CANoe IL 开始发送报文 其他用法未完待续…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb2570954699a72ad5103f56eab4caea/" rel="bookmark">
			android系统目录结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 android系统目录结构问答偏好设置保存在哪里在应用设置中点击清除数据，清除的是什么在应用设置中点击清除缓存，清除的是什么 参考 android系统目录结构 / - system (一般只有root权限才能访问) - data - app （存放应用程序的 APK 文件） - data（内部存储） - &lt;安装的应用包名&gt; - app_textures - app_webview(webview缓存等) - app_webview_&lt;进程名，如com.xxx.xxx:xxx&gt;(多进程情况下) - cache （getCacheDir()） - code_cache - databases(数据库)	- files（getFilesDir()） - shared_prefs(偏好设置) - local	- sdcard(外部存储) - Android - data(应用私有目录) - &lt;安装的应用包名&gt; - ... - storage(外部存储，文件管理器里看到的就是这里，手机插上电脑看到的也是这里) - emulated - 0 - Android - data(应用私有目录) - &lt;安装的应用包名&gt; - ... - DCIM - Download - Pictures - Music - Movies - documents - self 从内部存储空间访问，可以使用 getFilesDir() 或 getCacheDir() 方法，这里可以保存一些少量又比较重要的数据从外部存储空间访问，可以使用 getExternalFilesDir() 或 getExternalCacheDir() 方法 问答 偏好设置保存在哪里 偏好设置保存在内部存储 /data/data/包名/shared_prefs目录下，以xml形式存在 在应用设置中点击清除数据，清除的是什么 会清除应用的内部存储和外部存储，也就是清除内外部data/data/包名下的所有文件 在应用设置中点击清除缓存，清除的是什么 会清除应用的内部存储和外部存储的缓存目录即cache目录 参考 应用数据和文件 | Android 开发者 | Android Developers(56条消息) 解析Android内部存储、外部存储的区别_hudawei996的博客-CSDN博客_android 内部存储和外部存储的区别(56条消息) 彻底理解android中的内部存储与外部存储_One-Heart的博客-CSDN博客_android内部存储和外部存储 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33da99947c51994d8e5f6d88c5ce686a/" rel="bookmark">
			JumpServer新增加windows终端web终端连接出现用户名或密码认证错误登录失败，账户密码确认是正确无误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环景：
Jumpserver Copyright FIT2CLOUD 飞致云 © 2014-2021
远程计算机：windows server 2019
问题描述：
JumpServer新增加windows终端连接出现用户名或密码认证错误，登录失败,账户密码确认是正确无误
解决方案： 1.windows计算机属性远程桌面-只允许使用网络级别…前面√去掉即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3694b1e1942bf7274646323f572675e7/" rel="bookmark">
			Java 格式化之使用 %02X 格式化mac地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录下使用 %02X 格式化mac地址的方法。
String.format 传入 %ABX 的意思，拆解如下，
%X ：正常输出十六进制数 。%AX：十六进制数，输出 A 位。如果本身大于 A 位，正常输出。%ABX：十六进制数，输出 A 位，不足 A 位就补 B 。如果本身大于 A 位，正常输出。 以 %X，%2X， %02X 为例，
%X：十六进制数正常输出 。%2X：十六进制数，输出 2 位。如果本身大于 2 位，正常输出。%02X ：十六进制数，输出 2 位，不足 2 位就补 0 。如果本身大于 2 位，正常输出。 可以同时格式化多个，格式化 mac 地址时很方便，
System.out.println("String.format(\"%2X\", 15) :" + String.format("%2X", 15)); System.out.println("String.format(\"%02X\", 15) :" + String.format("%02X", 15)); System.out.println("String.format(\"%02X:%02X:%02X:%02X:%02X:%02X\", 10,11,12,13,14,15) :" + String.format("%02X:%02X:%02X:%02X:%02X:%02X", 10,11,12,13,14,15)); 运行结果，
String.format("%2X", 15) : F String.format("%02X", 15) :0F String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3694b1e1942bf7274646323f572675e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e813011fbf05dd27aaa4f7ba0c8881f9/" rel="bookmark">
			Linux(Centos7)系统安装Python3.6.8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux(Centos7)系统安装Python3.6.8教程 tips: 系统自带的python2不要卸载，一些系统命令要用，2和3可以共存。
1、首先要查看系统中有没有自带的gcc gcc --version 2、通过wget命令下载并解压 wget https://www.python.org/ftp/python/3.6.8/Python-3.6.8.tgz tar -zxf Python-3.6.8.tgz -C /opt 3、安装依赖环境 首先说一下-devel 这个意思是软件包所对应的开发包，我们也可以看到我们所有的依赖都是软件包的开发包。zlib是一个运行库，zlib-devel包括运行库和头文件等，在需要编译C/C++程序的时候，python就会用到。
yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel 工具作用zlib-develzlib是一个提供数据压缩用的函式库，这个包主要功能就是控制处理器和内存，以此来达到压缩和解压缩的目的bzip2-devel与zlib一样是一个解压缩软件openssl加密通讯，python的一些网页框架服务会用到，包如其名使用的是ssl协议。是一个多用途、快平台的密码工具ncurses一个提供功能定义，屏幕绘制的图形互动动态库，vim就用到过这个包SQLite这个应该不陌生，轻型数据库readline提供交互式的文本编辑功能tk提供基本的可视化界面类似于swinggdbm提供简单的资料管理函数db4为客户端/服务器提供嵌入式数据库支持libpcap数据包捕获函数库，网络分接口收集数据，数据过滤器决定是否接受数据包xz具有高压缩率的数据压缩软件libffi提供了python调用其他语言的功能 4、编译安装 cd /opt/Python-3.6.8/ &amp;&amp; ./configure --prefix=/usr/local/python3 --enable-optimizations &amp;&amp; make &amp;&amp; make install ln -s /usr/local/python3/bin/python3 /usr/bin/python3 ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 If you want a release build with all stable optimizations active (PGO, etc), please run ./configure --enable-optimizations # 说明： 很多教程都有最后一步，但是很少有网站会告诉你为什么会有最后一步。 所谓软连接就相当于win下的快捷方式。你可以通过快捷方式打开你想要使用的软件。 但是为什么要把快捷方式放在/usr/bin/呢。这就涉及到环境变量的问题了， 你当然可以不使用最后的软连接而直接把/usr/local/python3/bin加到环境变量里面， 那随你喜好。但是在这里/usr/bin/是默认已经在环境变量里面的， 把快捷方式放到这个文件夹相当于间接的把该Python3加入环境变量， 这样你才可以直接在终端输入“python3”打开Python。 # 为什么不把软连接放到桌面呢？ 我觉得有两个原因：第一、无法在终端通过命令行操作Python3。第二、并不是所有的Linux系统都是图形化界面，可能没有桌面啊，亲！ 至于最后一句是为pip建立软件接。pip3是Python3内置的一个软件。用来安装Python包的。比如要安装Python3的numpy包。直接在终端使用如下命令即可： pip3 install requests 5、验证 [root@master Python-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e813011fbf05dd27aaa4f7ba0c8881f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3349abc9e5fffbf27ca541da7a475b5b/" rel="bookmark">
			docker安装nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker安装nginx 一，拉取nginx镜像 docker pull nginx:latest 启动临时镜像(后边要删除) docker run --name nginx01 -d -p 80:80 nginx 二，创建本地文件夹 sudo mkdir -p /mydata/nginx/{log,ssl,html,conf/conf.d} sudo chmod -R 755 /mydata/nginx/html 三，通过 docker cp 命令将容器内的 nginx 配置文件 copy 到刚创建的主机文件目录中 docker cp nginx01:/etc/nginx/nginx.conf /mydata/nginx/conf/nginx.conf docker cp nginx01:/etc/nginx/conf.d/default.conf /mydata/nginx/conf/conf.d/default.conf 四，停止并删除nginx01容器 docker stop nginx01 docker rm nginx01 五，启动镜像 docker run --name nginx -d --restart=always --privileged=true -v /mydata/nginx/html:/usr/share/nginx/html -v /mydata/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /mydata/nginx/conf/conf.d/default.conf:/etc/nginx/conf.d/default.conf -v /mydata/nginx/log:/var/log/nginx -v /mydata/nginx/ssl:/ssl/ -p 443:443 -p 80:80 nginx 使用 --privileged=true 参数，容器内的 root 用户才拥有真正的 root 权限，否则容器内的 root 只是主机上的一个普通用户。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3349abc9e5fffbf27ca541da7a475b5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70331c7daefdc81104864806c80fb2b9/" rel="bookmark">
			caj转pdf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		caj转pdf CAJ文件中国知网下载论文的一种.caj为后缀的文件，想要打开这种文件就必须下载知网的‘全球学术快报’或者CAJViewer软件。想要打开caj非常的麻烦。 caj2pdf是[github](https://link.zhihu.com/?target=https%3A//github.com/caj2pdf/caj2pdf)上的一个有1.7k star项目，是由github用户caj2pdf发布的，遵守GLWT开源许可的开源软件。项目地址：[https://github.com/caj2pdf/caj2pdf]() 本教程使用centos服务器。使用java操作caj转pdf（附代码） 一、代码获取 打开Github上caj2pdf网页，下载源代码文件caj2pdf.zip（通过git clone或者直接下载zip包）
2.解决依赖，caj2pdf至少需要3个依赖 Python 3.3+PyPDF2mutool 1.查看python版本,如果版本低于3.3，可跳转另一篇文章 http://www.123ou.top/blog/8
[root@xxx Python-3.6.8]# python3 -V Python 3.6.8 2.安装PyPDF2
sudo pip3 install PyPDF2 3.安装mutool
cd /usr/local #可自行选中安装目录 wget https://mupdf.com/downloads/archive/mupdf-1.20.3-source.tar.gz tar -zxvf mupdf-1.20.3-source.tar.gz cd mupdf-1.20.3-source make make install 安装编译mutool 报错 及解决方案见文章末尾
3.准备好环境，将下载的caj2pdf通过ftp上传到服务器。我是放在/usr/local目录下，可自行选中解压目录 cd /usr/local/caj2pdf/ ll 查看文件是否有执行（x）权限，没有权限的话执行以下
chmod +x caj2pdf chmod +x jbi* 再次查看文件权限
创建软连接
ln -s /usr/local/caj2pdf/caj2pdf /usr/bin/ 用法
# 打印文件基本信息（文件类型、页面数、大纲项目数） caj2pdf show [input_file] # 转换文件 caj2pdf convert [input_file] -o/--output [output_file] # 从 CAJ 文件中提取大纲信息并添加至 PDF 文件 ## 遇到不支持的文件类型或 Bug 时，可用 CAJViewer 打印 PDF 文件，并用这条命令为其添加大纲 caj2pdf outlines [input_file] -o/--output [pdf_file] 示列
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70331c7daefdc81104864806c80fb2b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b8c78ed9c421983513efbcf7cb215e1/" rel="bookmark">
			day07
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、数据库连接池原理
JavaWeb 数据库连接池是一种管理数据库连接的机制。它通过创建一组初始化的数据库连接，在需要时将连接分配给应用程序，并在使用后将其归还给连接池，以便重复使用。 数据库连接池的原理如下： 1. 初始化连接池：在应用程序启动时，创建一定数量的数据库连接，并将它们保存在连接池中。这些连接可以使用数据库驱动程序的特定API进行创建。 2. 连接分配：当应用程序需要与数据库交互时，从连接池中获取一个可用连接。 3. 连接使用：应用程序使用获取的连接执行数据库操作。 4. 连接归还：当应用程序使用完连接后，将其归还给连接池。归还连接时，可以通过关闭连接或重置连接的状态来确保连接处于可重用状态。 5. 连接池管理：连接池负责管理连接的状态和数量。它监控连接的使用情况，并根据需要创建新的连接或关闭闲置的连接。 数据库连接池的好处包括： 1. 提高性能：数据库连接的创建和关闭是一项昂贵的操作。使用连接池可以避免频繁的创建和关闭连接，提高数据库访问的性能。 2. 资源管理：连接池可以根据应用程序的需求和资源的可用性来管理连接数量，防止资源浪费。 3. 连接重用：连接池允许连接被重复使用，减少了连接的创建和关闭次数，提高了应用程序的响应速度。 总结起来，通过使用数据库连接池，JavaWeb 应用程序可以更高效地管理数据库连接，提高应用程序的性能和可扩展性。 当应用程序需要与数据库进行交互时，通常需要创建一个数据库连接来执行相关的操作。然而，频繁地创建和关闭连接会给数据库服务器带来不必要的开销和性能问题。为了解决这个问题，引入了数据库连接池，其原理如下： 1. 连接初始化：在应用程序启动时，连接池会初始化一定数量的数据库连接，这些连接处于可用状态并保存在连接池中。 2. 连接获取：当应用程序需要数据库连接时，它可以从连接池中获取一个可用的连接。连接池会管理这些连接的状态，标记哪些连接是可用的，哪些连接正在被使用。 3. 连接复用：应用程序使用连接执行数据库操作，包括查询、插入、更新等。当操作完成后，应用程序会将连接返回给连接池，而不是直接关闭连接。这样做的好处是，这些连接可以被其他需要连接的应用程序复用，而不必重新创建连接。 4. 连接回收：连接池会监控连接的使用情况。如果连接长时间未被使用（闲置状态），连接池会将其关闭以节省资源。同时，连接池还可以根据需要动态地创建新的连接，以满足应用程序对连接的需求。 5. 资源管理：连接池还负责管理连接的数量和使用情况。它可以限制连接的最大数量，并根据需求动态调整连接池的大小，以充分利用系统资源。 通过使用数据库连接池，可以减少创建和关闭连接的开销，提高数据库访问的效率和性能。连接池可以更好地管理连接资源，避免连接的过度创建和销毁，同时提供连接的复用和动态调整，适应不同应用的需求。这样，应用程序可以更高效地与数据库进行交互，提升整体系统的性能和可伸缩性。 2、LambdaQueryWrapper表达式
LambdaQueryWrapper 是 MyBatis-Plus 框架提供的一个查询条件封装类，用于构建 SQL 查询条件。
它可以通过 Lambda 表达式来定义查询条件，提供了一种更简洁、易读的方式来编写数据库查询。
使用 LambdaQueryWrapper 需要以下步骤：
导入相关的包： import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; 创建 LambdaQueryWrapper 对象： LambdaQueryWrapper&lt;DishFlavor&gt; queryWrapper=new LambdaQueryWrapper&lt;&gt;(); 添加查询条件： queryWrapper.eq(Entity::getField, value); // 相等条件 queryWrapper.ne(Entity::getField, value); // 不等条件 queryWrapper.like(Entity::getField, value); // 模糊查询条件 queryWrapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b8c78ed9c421983513efbcf7cb215e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0a06473ff821f81d760e573c1a36bb4/" rel="bookmark">
			Cinema 4D R2024(c4d2024)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cinema 4D 2024是一款专业的三维建模、动画和渲染软件。被广泛用于电影制作、广告设计、工业设计等领域。
Cinema 4D 2024具有强大的建模工具，可以创建各种复杂的几何体，包括多边形网格、NURBS曲线和体积对象。它还提供了丰富的材质和纹理编辑功能，使用户能够为模型添加逼真的表面效果。
该软件还具备出色的动画功能，支持关键帧动画、物理模拟和粒子系统等特效。用户可以通过简单的操作设置对象的运动路径、变形效果和相机视角，实现令人惊叹的动画效果。
在渲染方面，Cinema 4D 2024提供了高质量的渲染引擎，能够产生逼真的光照和阴影效果。用户可以选择不同的渲染选项，包括标准渲染器、物理渲染器和第三方插件，以满足不同项目的需求。
此外，Cinema 4D 2024还支持与其他设计软件的集成，如Adobe After Effects、Photoshop和Illustrator等。这使得用户可以轻松地将Cinema 4D中创建的模型和动画与其他软件进行无缝衔接，实现更复杂的设计效果。
总的来说，Cinema 4D 2024是一款功能强大、易于学习和使用的三维建模和动画软件，适用于各种创意设计项目。无论您是专业设计师还是初学者，都可以通过Cinema 4D实现令人惊叹的视觉效果。
Cinema 4D R2024(c4d2024)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6e4c3967972352ba3a8eb950151a7b8/" rel="bookmark">
			JVM内存模型剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK体系结构 Java语言的跨平台特性 JVM内存模型 Java虚拟机内部分成三部分：类装载子系统，运行时数据区（内存模型），字节码执行引擎。
运行时数据区包含有：本地方法栈，线程栈，堆，方法区（元空间），程序计数器。
线程栈：开辟一个内存空间用来存放线程的，一个线程若对应有多个方法，每个方法会对应在内存空间中分配一个小区域栈贞给到方法，
每个栈贞中会存放：局部变量，操作数栈（方法内部的操作在该栈执行），动态连接（方法内部调用其他方法时，指向被调用方法的真实存放地址），方法出口。
程序计数器：每个线程在执行的过程中，方法执行的每一步都会有程序计数器进行计数标记，而字节码执行引擎就是动态修改程序计数器计数的。
堆：用于存放新创建的对象，其中线程栈中存放有该新创建对象的引用地址
方法区（元空间）：存放的是，静态变量，类信息，其中方法区中也存放有新创建对象的引用地址。
本地方法栈：主要是调用本地方法的从而分配内存空间，本地方法主要是与C语言交互的常量
注意：其中堆和方法区（元空间）是所有线程共享的内存，
eg:
以上代码运行后，可看到java所谓的汇编语言结果：此处需要参照JVM指令手册
堆内存分配： 年轻代和老年代的占比=1:2
年轻代：包含有Eden区和survior区（s0,s1）占比是(Eden:s0:s1=8:1:1)
Minor gc : 主要是回收年轻代区域的内存。
Fullgc: 主要回收所有区域的内存，在进行fullgc是会进行stw（stop the work）操作,停止用户线程
JVM内存参数设置 Spring Boot程序的JVM参数设置格式(Tomcat启动直接加在bin目录下catalina.sh文件里)： java ‐Xms2048M ‐Xmx2048M ‐Xmn1024M ‐Xss512K ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M ‐jar microservice‐eurek a‐server.jar 关于 元空间的JVM参数 有两个： -XX:MetaspaceSize=N和 -XX:MaxMetaspaceSize=N -XX：MaxMetaspaceSize： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。 -XX：MetaspaceSize： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位， 默认是21M ，达到该值就会触发 full gc进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。 这个跟早期jdk版本的-XX:PermSize参数意思不一样，- XX:PermSize 代表永久代的初始容量。 由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生 了大小调整，基于这种情况， 一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值 ，并设置得比初始值要大， 对于8G物理内存的机器来说，一般我会将这两个值都设置为256M。 StackOverflowError示例： // JVM设置 ‐Xss128k(默认1M) public class StackOverflowTest { static int count = 0; static void redo() { count++; redo(); } public static void main(String[] args) { try { redo(); } catch (Throwable t) { t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6e4c3967972352ba3a8eb950151a7b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7463acabdc829917537f05cfa2de607d/" rel="bookmark">
			Python 逢7拍手游戏的规则是：从1开始顺序数数，数到有7或者包含7的倍数的时候拍手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当您使用 PyCharm 编写程序时，可以按照以下规则实现“逢7拍手游戏”：
在这段代码中，我们定义了一个名为 `clap_game()` 的函数，它接受一个参数 `max_num`，用来指定游戏数数的最大值。在函数体内，我们使用 `for` 循环遍历从 1 到 `max_num` 的所有数字。
对于每个数字，我们首先检查它是否是 7 的倍数，通过 `num % 7 == 0` 来进行判断。如果是，我们打印出 "Clap!" 表示拍手。否则，我们将数字转换为字符串，然后检查是否包含 '7'，通过 `'7' in str(num)` 来进行判断。如果包含 '7'，同样打印出 "Clap!" 表示拍手。如果都不满足，我们直接打印出数字本身。
最后，在主程序中，我们选择将游戏数数的最大值设为 100，并调用 `clap_game()` 函数来开始运行游戏。你可以根据需要修改 `max_number` 的值。
在运行这段代码后，程序将按照规则进行数数，并在满足条件时拍手，打印出相应的结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ace4344a8a9c17bc3c96b22c3e4c3211/" rel="bookmark">
			Python变量的命名规范以及运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题一：python变量的命名规范
Python变量的命名规范是指对变量名的命名规则和规范。在Python中，变量名必须以字母或下划线开头，可以包含字母、数字和下划线。变量名是区分大小写的，不同的大小写视为不同的变量名，且不能使用Python关键字作为变量名。建议使用一种风格来命名变量，例如采用下划线分隔的小写字母命名法（snake_case），或首字母大写的驼峰命名法（CamelCase）等。变量名应具有描述性，并且能够清晰地表达变量的含义。
问题二：Python中的运算符
Python中的运算符是用来进行各种数学和逻辑运算的符号或特殊字符。常用的运算符有算术运算符、赋值运算符、比较运算符、布尔运算符和位运算符。算术运算符用于执行基本的数学运算，例如加法、减法、乘法和除法等。赋值运算符用于给变量赋值。比较运算符用于比较两个值的大小关系，并返回布尔值True或False。布尔运算符用于执行逻辑运算，例如与运算、或运算和非运算等。位运算符用于对二进制数进行位操作，例如位与、位或和位非等。在Python中，运算符的使用可以通过运算符优先级和结合性来确定运算的顺序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f8e8bb4a9a2f55b460c38f91a7c0d13/" rel="bookmark">
			防火墙之firewall配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		firewall ​ CentOS 7中防火墙已经由firewalld来管理，Centos7默认安装了firewalld。
与iptables区别 iptables 仅能通过命令行进行配置；而 firewalld 提供了图形接口，类似windows防火墙的操作方式；iptables 每一个单独更改意味着清除所有旧的规则，并从 /etc/sysconfig/iptables 中读取所有新的规；则；而 firewalld 在有规则变动后，可以仅仅运行规则中的不同之处，即在 firewalld 运行时间内，改变设置时可以不丢失现行链接；iptables 的配置文件在 /etc/sysconfig/iptables 中；而 firewalld 的配置文件在 /usr/lib/firewalld/ 和 /etc/firewalld/ 中的各种 XML 文件中；iptables 没有守护进程，并不能算是真正意义上的服务；而 firewalld 有守护进程；iptables 通过控制端口来控制服务，而 firewalld 则是通过控制协议来控制端口；firewalld默认是拒绝；而iptables默认是允许。 firewall 服务 # 查看服务状态 service firewalld status systemctl status firewalld firewall-cmd --state # 启动 service firewalld start systemctl start firewalld # 重启 service firewalld restart systemctl start firewalld # 关闭 service firewalld stop # 重新加载 firewall-cmd --reload	# 每次修改规则、配置后，需要重新加载使其生效！ 开机启动 # 设置开机启动 systemctl enable firewalld # 停止并禁用开机启动 systemctl disable firewalld firewalld区域与配置规则 ​ 宽松模式:：trusted ，单独拒绝的源ip地址写入block，适合于拒绝的少，允许的多的应用场景：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f8e8bb4a9a2f55b460c38f91a7c0d13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cda1807f5f9987e5fb53bace2982ece/" rel="bookmark">
			OriginPro 调整坐标轴
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.移动坐标轴 通常OriginPro作图的时候，坐标轴位置是比较固定的，x轴在最左边，y轴在最下边，但是有时候计算结果的y值比较对称，这时候我们就想把x轴移动到y轴中间位置处，
实际上我们可以单击坐标轴然后 上下键就可以移动，但是有时候不一定能准确移动到指定位置，这时候，可以双击坐标轴找到 line and Ticks --&gt; line --&gt;Axis Postion，选择 at position 就可以准确的移动x轴了。
2.拉伸坐标轴 如下图，如果想要把x轴变得很窄，
可以单击图片正中，出现了如图所示的框就可以自由拉伸了，
3.固定坐标轴长度比例 双击图片，size/speed --&gt; Link Anix length to Scale 前面 的勾选即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95325a468cbc7fea0c253804828adbd6/" rel="bookmark">
			Spring Boot基础 习题【附答案解析】1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.单选题（共16题,55.0分） 1 在web.xml文件中配置Spring框架,下面配置正确的是?（3.5分）
A、&lt;context-param&gt;
&lt;param-name&gt;contextConfig&lt;/param-name&gt;
&lt;param-value&gt;/WEB-INF/classes/applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;B、&lt;context-param&gt;
&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
&lt;param-value&gt;/WEB-INF/classes/applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;C、&lt;context-param&gt;
&lt;param-name&gt;servletConfig&lt;/param-name&gt;
&lt;param-value&gt;/WEB-INF/classes/applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;D、&lt;context-param&gt;
&lt;param-name&gt;config&lt;/param-name&gt;
&lt;param-value&gt;/WEB-INF/classes/applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt; 我的答案： B得分： 3.5分
2 下列哪个Spring模块提供了IoC容器和依赖注入的基本功能?（3.4分）
A、Spring SecurityB、Spring MVCC、Spring DataD、Spring Core 我的答案： D得分： 3.4分
答案解析：
Spring Core是Spring框架的核心模块,提供了IoC容器和依赖注入的基本功能。
3 在Spring中，@Qualifier注解的主要作用是什么？（3.5分）
A、 指定Bean的作用域
B、 启用事务管理
C、 限定注入的Bean名称
D、 定义Bean的初始化方法
我的答案： C得分： 3.5分
答案解析：
@Qualifier注解的主要作用是限定注入的Bean名称，当多个相同类型的Bean存在时，可以通过@Qualifier注解指定要注入的Bean的名称。
4 在Spring中,哪个注解用于在配置类中定义一个Bean?（3.4分）
A、 @Service
B、 @Component
C、 @Autowired
D、 @Bean
我的答案： D得分： 3.4分
答案解析：
@Bean注解用于在配置类中定义一个Bean。
5 Spring框架的主要目标是什么?（3.4分）
A、简化Java应用程序的开发B、增加应用程序的复杂性C、降低应用程序的可维护性D、加速应用程序的执行速度 我的答案： A得分： 3.4分
答案解析：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95325a468cbc7fea0c253804828adbd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc75e67678eaf59cc1937219453f775b/" rel="bookmark">
			Jmeter-非GUI命令行模式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景说明： JMeter执行方式有两种，一种是GUI模式，一种是非GUI模式。
GUI模式就是界面模式，非GUI模式就是命令行模式。GUI模式主要用来编写和调试脚本用的，接口的性能测试最好是采用命令行模式，因为该模式可以和其它框架进行对接，进行自动化测试平台的集成。
2.应用场景 无需交互界面或受环境限制（图形化界面消耗更多资源，如CPU和内存，容易使压力机达到瓶颈，从而影响测试结果）远程或分布式执行（同时生成更多的压力请求，达到客户端能模拟大并发请求的目的）持续集成，通过shell脚本或批处理命令把脚本配置到Jenkins上实现持续集成，生成的测试结果可被报表生成模块直接使用，便于生成报告 3.优点 节约系统资源：无需启动界面，节约系统资源便捷快速：仅需启动命令行，输入命令便可执行易于持续集成：可通过shell脚本命令执行 4.参数详解 --? 打印命令行选项并退出 -h, --help 打印使用信息并退出 -v, --version 打印版本信息并退出 -p, --propfile &lt;参数&gt; 要使用的 jmeter 属性文件 -q, --addprop &lt;参数&gt; 额外的 JMeter 属性文件 -t, --testfile &lt;参数&gt; 要运行的 jmeter 测试（.jmx）文件 -l, --logfile &lt;参数&gt; 将样本记录到的文件 -i, --jmeterlogconf &lt;参数&gt; jmeter 日志配置文件（log4j2.xml） -j, --jmeterlogfile &lt;参数&gt; jmeter 运行日志文件 (jmeter.log) -n, --nongui 在 nongui 模式下运行 JMeter -s, --server 运行 JMeter 服务器 -H, --proxyHost &lt;参数&gt; 为 JMeter 设置代理服务器以使用 -P, --proxyPort &lt;参数&gt; 设置 JMeter 使用的代理服务器端口 -N, --nonProxyHosts &lt;参数&gt; 设置非代理主机列表（例如 *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc75e67678eaf59cc1937219453f775b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c55bbb456b19257280e5a21b53d299b/" rel="bookmark">
			在PyTorch里面利用transformers的Trainer微调预训练大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 transformers提供了非常便捷的api来进行大模型的微调，下面就讲一讲利用Trainer来微调大模型的步骤
第一步：加载预训练的大模型
from transformers import AutoModelForSequenceClassification model = AutoModelForSequenceClassification.from_pretrained("distilbert-base-uncased") 第二步：设置训练超参
from transformers import TrainingArguments training_args = TrainingArguments( output_dir="path/to/save/folder/", learning_rate=2e-5, per_device_train_batch_size=8, per_device_eval_batch_size=8, num_train_epochs=2, ) 比如这个里面设置了epoch等于2
第三步：获取分词器tokenizer
from transformers import AutoTokenizer tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased") 第四步：加载数据集
from datasets import load_dataset dataset = load_dataset("rotten_tomatoes") # doctest: +IGNORE_RESULT 第五步：创建一个分词函数，指定数据集需要进行分词的字段：
def tokenize_dataset(dataset): return tokenizer(dataset["text"]) 第六步：调用map()来将该分词函数应用于整个数据集
dataset = dataset.map(tokenize_dataset, batched=True) 第七步：使用DataCollatorWithPadding来批量填充数据，加速填充过程：
from transformers import DataCollatorWithPadding data_collator = DataCollatorWithPadding(tokenizer=tokenizer) 第八步：初始化Trainer
from transformers import Trainer trainer = Trainer( model=model, args=training_args, train_dataset=dataset["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c55bbb456b19257280e5a21b53d299b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aebf838b5e42bccfc8042d7c35f7f18/" rel="bookmark">
			数据倾斜和数据倾斜的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是数据倾斜 Hadoop能够进行对海量数据进行批处理的核心，在于它的分布式思想，也就是多台服务器（节点）组成集群，进行分布式的数据处理。
举个例子，假如要处理一个10亿数据的表格，我的集群由10个节点组成，一台服务器处理这10亿数据需要10个小时，现在我将10亿条数据平均的分配到不同的节点上，每台节点负责处理1亿条数据，那么原本需要10个小时完成的工作，现在只需要1个小时即可。
而以上只是理想情况，实际上分配到每台节点的数据量并不是均匀的，当大量的数据分配到某一个节点时（假设5亿条），那么原本只需要1小时完成的工作，变成了其中9个节点不到1小时就完成了工作，而分配到了5亿数据的节点，花了5个小时才完成。
从最终结果来看，就是这个处理10亿数据的任务，集群花了5个小时才最终得出结果。大量的数据集中到了一台或者几台机器上计算，这些数据的计算速度远远低于平均计算速度，导致整个计算过程过慢，这种情况就是发生了数据倾斜。
2、数据倾斜的表现 2.1、MapReduce任务 主要表现在Reuduce阶段卡在99.99%，一直99.99%不能结束。
有一个多几个Reuduce卡住；各种container报错OOM；读写的数据量极大，至少远远超过其它正常的Reuduce。伴随着数据倾斜，会出现任务被kill等各种诡异的表现。 2.2、Spark任务 绝大多数task执行得都非常快，但个别task执行的极慢；
单个Executor执行时间特别久，整体任务卡在某个stage不能结束；
Executor lost，OOM，Shuffle过程出错；
正常运行的任务突然失败；
用SparkStreaming做实时算法时候，一直会有 executor 出现 OOM 的错误，但是其余的executor内存使用率却很低。
3、发生数据倾斜的原因 正常的数据分布理论上都是倾斜的，就是我们所说的二八原理：80%的财富集中在20%的人手中, 80%的用户只使用20%的功能 , 20%的用户贡献了80%的访问量 , 不同的数据字段可能的数据倾斜一般有两种情况：
唯一值非常少，极少数值有非常多的记录值（唯一值少于几千）；
唯一值比较多，这个字段的某些值有远远多于其他值的记录数，但是它的占比也小于百分之一或千分之一。
可以理解为：
数据频率倾斜——某一个区域数据要远远大于其他区域；数据大小倾斜——部分记录的大小远远大于平均值。 无论是MR还是Spark任务进行计算的时候，都会触发 Shuffle 动作，一旦触发，所有相同key的值就会拉到一个或几个节点上，就容易发生单个节点处理数据量爆增的情况 。
Shuffle 的中文含义是“洗牌”，其原理在这里不展开说，但通过下面这张图，你能了解到它的对数据进行了什么样的处理。
3.1、key 分布不均匀 某些key的数量过于集中，存在大量相同值的数据；存在大量异常值或空值。 3.2、业务数据本身的特性 例如某个分公司或某个城市订单量大幅提升几十倍甚至几百倍，对该城市的订单统计聚合时，容易发生数据倾斜。
3.3、某些 SQL 语句本身就有数据倾斜 两个表中关联字段存在大量空值，或是关联字段的数据不统一，例如在A表中值是大写，B表中值是小写等情况。
4、触发数据倾斜的SQL操作 关键词情况后果join其中一个表较小，但是key集中分发到某一个或几个Reduce/Stage的数据远高于平均值大表与大表，但是分桶的判断字段0值或空值过多这些空值都由一个Reduce/Stage处理，非常慢group bygroup by维度过小，某值的数量过多处理某值的Reduce/Stage非常耗时count distinct某特殊值过多处理此特殊值的Reduce/Stage非常耗时 5、数据倾斜的解决方案 首先排除过滤倾斜key，ETL预处理这种治标不治本的方法，然后详细来讲解各种不同的处理方式。
5.1、参数调整 5.1.1、通用优化：提高 shuffle 并行度 Spark的shuffle并行度默认值是200，建议根据服务器的情况进行调整。一般是集群cpu总和的2-3倍。当发生数据倾斜的时候，适当增大并行度，可以将原本被分配到同一个Task的不同Key分配到不同Task。
set spark.sql.shuffle.partitions= [num_tasks] 5.1.1.1、原理 5.1.1.2、缺点 它没有从根本上改变数据倾斜的本质和问题，只是说尽可能地去缓解和减轻 shuffle reduce task 的数据压力，以及数据倾斜的问题。。
5.1.2、map 端聚合，启动负载均衡 适用范围： group by 造成的数据倾斜。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0aebf838b5e42bccfc8042d7c35f7f18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89a54a73215e9342f0e2e003ecf4ace5/" rel="bookmark">
			数学建模| 非线性规划（Matlab）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非线性规划（Matlab） 非线性规划Matlab函数Matlab使用例子 非线性规划 非线性规划：约束条件和目标函数存在非线性函数。简单点说，约束条件和目标函数中至少一个决策变量不是一次方，例如三角函数、对数、多次方等。
线性规划和非线性在解决上的不同：线性规划可以有通用方法，但是非线性规划的求解是没有特定算的，只能用近似的算法，每种算法都有自己适用的范围。这些算法有很多，Matlab内部已经实现好了，有现成的函数，如果想了解内部具体的实现可以另寻查找，本文就只介绍如何调用Matlab中的函数达成求非线性规划。
Matlab函数 Matlab函数：
[x,value]=fmincon(func,x0,A,b,Aeq,beq,lb,ub,nonlcon，options) 参数解释：
func 表示目标函数。A 表示不等式约束条件系数矩阵，b 表示不等式约束条件常数矩阵。Aeq 表示等式约束条件系数矩阵，beq 表示等式约束条件常数矩阵。lb 表示决策变量的下限数组，ub表示决策变量的上限数组。x 表示目标函数 func 取得最小值时的决策变量取值数组。value 表示目标函数 func 取得的最小值。x0表示初始值。nonlcon 非线性约束，包括不等式和等式。options是优化参数。 Matlab中线性规划的标准形式：C(x)和Ceq(x)是非线性约束的不等式和等式。
min ⁡ f ( x ) \min f(x) minf(x)
s . t . { A x ⩽ b A e q ⋅ x = b e q l b ⩽ x ⩽ u b C ( x ) ⩽ 0 C e q ( x ) = 0 s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89a54a73215e9342f0e2e003ecf4ace5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/47/">«</a>
	<span class="pagination__item pagination__item--current">48/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/49/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>