<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc76f3ae1e4fdad4430d00607b7ff284/" rel="bookmark">
			官方版本若依打印日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import org.slf4j.Logger; import org.slf4j.LoggerFactory; protected final Logger logger = LoggerFactory.getLogger(this.getClass()); logger.info("测试"); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49c4043c623375b748bae81c59526e9c/" rel="bookmark">
			学习笔记之——NeRF SLAM（基于神经辐射场的SLAM）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NeRF SLAM（Neural Radiance Fields Simultaneous Localization and Mapping）是一种结合神经辐射场（NeRF）和SLAM（Simultaneous Localization and Mapping）的先进技术，用于实时地构建三维环境地图并同时估计相机的姿态。目前NeRF-SLAM主要有以下两个方向：
SLAM为NeRF训练提供位姿，然后建立稠密细腻的三维场景。简而言之就是NeRF只做mapping在NeRF里建立各种损失函数反过来优化pose和depth。 简而言之就是full slam 那么基于这两个方向，目前的NeRF SLAM的工作主要分为以下三类：仅优化NeRF、仅优化位姿、位姿和NeRF联合优化。与此同时，本文也把最新的3D Gaussian Splatting也加入调研序列中。每个工作介绍的时候都会给出论文的下载链接、源代码（如有）、demo video（如有）
本博文，意在记录本人调研NeRF-SLAM的时候做的学习记录，部分资料来源于网络，本博文仅仅供本人学习记录用~
目录
什么是NeRF？
NeRF
仅优化NeRF
NeRF++
Instant-NGP
RO-MAP
vMAP
Point-NeRF
NeRF-SLAM SMERF
Nerfies
仅优化位姿
iNeRF
NeRF-Loc
Loc-NeRF
NeRF-VINS
位姿和NeRF联合优化
iMAP
BARF
NeRF--
NICE-SLAM
Vox-Fusion
NoPe-NeRF
RoDynRF
DIM-SLAM
Orbeez-SLAM
GO-SLAM
NICER-SLAM
Co-SLAM
雷达NeRF SLAM
LiDAR-NeRF
IR-MCL
NeRF-LOAM
LONER 3D Gaussian Splatting
参考文献
什么是NeRF？ NeRF 所做的任务是 Novel View Synthesis（新视角合成），即在若干已知视角下对场景进行一系列的观测（相机内外参、图像、Pose 等），合成任意新视角下的图像。传统方法中，通常这一任务采用三维重建再渲染的方式实现，NeRF 希望不进行显式的三维重建过程，仅根据内外参直接得到新视角渲染的图像。为了实现这一目的，NeRF 使用用神经网络作为一个 3D 场景的隐式表达，代替传统的点云、网格、体素、TSDF 等方式，通过这样的网络可以直接渲染任意角度任意位置的投影图像。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49c4043c623375b748bae81c59526e9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9156afa6f964722ac4bab6b6a6879867/" rel="bookmark">
			张量操作与线性回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、张量的操作：拼接、切分、索引和变换 （1）张量拼接与切分 1.1 torch.cat() 功能：将张量按维度dim进行拼接
• tensors: 张量序列
• dim : 要拼接的维度
torch.cat(tensors, dim=0, out=None)函数用于沿着指定维度dim将多个张量拼接在一起。它接受一个张量列表tensors作为输入，并返回一个拼接后的张量。参数dim指定了拼接的维度，默认为0。
flag = True if flag: t = torch.ones((2, 3)) #创建一个形状为(2, 3)的全为1的张量t t_0 = torch.cat([t, t], dim=0) # 将张量t沿着dim=0的维度拼接两次，得到张量t_0 t_1 = torch.cat([t, t, t], dim=1)# 将张量t沿着dim=1的维度拼接三次，得到张量t_1 print("t_0:{} shape:{}\nt_1:{} shape:{}".format(t_0, t_0.shape, t_1, t_1.shape)) t_0:tensor([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]) shape:torch.Size([4, 3]) t_1:tensor([[1., 1., 1., 1., 1., 1., 1., 1., 1.], [1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9156afa6f964722ac4bab6b6a6879867/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5fd214cdd0d2b3b4272e73b022ba5c2/" rel="bookmark">
			Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目部署问题： 大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：
依赖关系复杂，容易出现兼容问题
开发、测试、生产环境有差异
Docker如何解决依赖的兼容问题？
将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包
将每个应用放到一个隔离容器去运行，避免互相干扰
Docker如何解决不同系统环境的问题？
Docker将用户程序与所需要调用的系统（比如Ubuntu）函数库一起打包
Docker运行到不同操作系统时，直接基于打包的库函数，借助于操作系统的Linux内核运行
Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容问题？
Docker允许开发中将应用、依赖、函数库、配置一起 打包，形成可移植镜像。
Docker应用运行在容器中，使用沙箱机制，相互 隔离
Docker如何解决开发、测试、生产环境有差异的问题
Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行
Docker与虚拟机 虚拟机是在操作系统中模拟硬件设备，然后运行另一个操作系统，比如在Windows系统里面运行Ubuntu系统，这样可以运行任意的Ubuntu应用了
特性Docker虚拟机性能接近原生性能较差硬盘占用一般为MB一般为GB启动秒级分钟级 镜像和容器 镜像（Image）：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起称为镜像。
容器（Container）：镜像中的应用程序运行后形成的进程就是 容器，只是Docker会给容器做隔离，对外不可见
Docker和DockerHub DockerHub：是一个Docker镜像的托管平台。这样的平台称之为Docker Registry
Docker架构 Docker是一个CS架构的程序，由两部分组成：
服务端：Docker守护进程，负责处理Docker指令，管理镜像、容器等
客户端：通过命令或者RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。
镜像相关的命令 镜像一般分成两部分：[repository]:[tag].
没有指定tag时，默认时latest，代表最新版本镜像
CentOS拉取镜像步骤： 从DockerHub搜索镜像
根据镜像名称拉去想要的镜像
通过docker命令
docker images 查看镜像
容器相关命令 docker run 命令常见参数：
--name：指定容器名称
-p：指定端口映射
-d：让容器后台运行
-v：把数据卷挂载到某个容器目录
查看容器日志命令：
docker logs
添加 -f 参数可以持续查看日志
查看容器状态：
docker ps
数据卷 容器与数据耦合问题：
不便于修改
数据不可复用
升级维护困难
什么是数据卷： 是一个虚拟目录，指向宿主机文件系统中的某个目录。
操作数据卷 数据卷基础语法如下：
docker volume[COMMAND] docker volume 命令时数据卷操作，根据命令后跟随的command来确定下一步的操作：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5fd214cdd0d2b3b4272e73b022ba5c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88b93af6d8818ff479a3bcc4f41f2c88/" rel="bookmark">
			80后的技术职涯回顾2024
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年，职业生涯已过半。
2000年，作为计算机专业的中专生，第一份工作是酒店的网管。工作之余考取了MCSE，MCDBA。
2003年，作为一个初创公司的第一名网络工程师，在全国各地运营商做项目实施。最后做到网络部门经理，因被卷入办公室政治，2015年被辞退。工作之余考取了PMP，ItileV3
2016年，在一家上市公司做APP项目经理。工作之余考取了ACP。
2017年，先后参与了大数据和人工智能的创业项目，都因资金链断了而终止。
2018年，加入了一个SaaS创业团队，作为CIO管理自研团队和外包团队。2022年公司财务违规被查，公司解散。工作之余考取了MCP，ItileV4。
2022年-2023年待业，主要工作就是接送孩子，期间找到过一个工作，是给人家里安装和维修宽带，做了6个月。目前正在参与国家开放大学的大专学历的远程学习。
如果把20岁到60岁作为职业生涯，大概就40年，我已经用掉了20多年。至于40岁到60岁，对于我自己，确实还需要认真的规划下这20年的职业生涯，但也许，社会或企业HR并不认为你还有什么所谓的职业生涯了。
回顾这段工作经历，还是有很多值得感恩的事情：
刚毕业时，第一个选择题是应聘程序员还是网络工程师。因为年轻，坐不住，想出去看看，所以锁定可以出差的工作，就选择了网络行业。最终也顺利成为了网络工程师，全国各地做项目。
当进入公司管理层团队时，恰好也是在准备组建自己家庭的时候。
后续就是不断尝试加入创业团队，最终在SaaS这个创业公司，最大化实现了自我价值。
其实对自己的期待，只是希望做一个工程师而已，遇到了一些机遇，后来做了项目经理和CIO，作为一个中专生，如果有梦想，也不过如此了。
反思这段经历，也有比较遗憾的事情，可供年轻人引以为戒：
以为工作经验和国际认证可以弥补学历的不足，学历是硬伤，很难被其它优势取代。
当项目结束后，一个新项目启动时，过往的人际关系也随着清零和重建，没有努力去经营人脉，做不到人脉的积累。
虽已没有展望未来的激情，但还是要有面对后半生挑战的勇气：
伴随健康，朋友，权利及财富的丧失，后半生会很快一贫如洗。青年时至少还有未来可以寻找自己的好运，至于后半生的好运，则像是等待对过往不幸的补偿。
前半生，通过责怪别人的过错，呵护了自己脆弱的自信。后半生要培养出面对不愉快或矛盾冲突的能力。为了解决问题，改变自己比改变别人更加简单和有效。
青年时受到物质的吸引并通过物质来解决自我怀疑和自尊心的问题。如果对物质的关注，偏爱和欲望视为前半生的美德，后半生对人性的深入考察，从专注于事情转为专注人情。
年轻时喜欢给自己贴上各种标签，后半生则应抛弃被标签化的人格与面具，同时容纳下许多冲突的自我，不再追求过度抽象的逻辑，不再用过度简单的方式解读人生百态和命运无常，认识到信念只是些想法而不是真理。
随着年龄的增长，个人能力不可避免地丧失，自我主义将成为一种自我挫败。利他主义不再是一种手段而是目的，自我牺牲在后半生不止是一种美德，更是一种需要。
摆脱了传统社会身份，分开社会责任和内在的自我，从社会认同转变为自我认同，对人格完整的寻求是后半生的主要挑战。
2024年，成长为自已本来的样子。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a9aa92cb88cebf33f087bf4ae4f8192/" rel="bookmark">
			性能优化（CPU优化技术）-ARM Neon详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍ARM Neon技术，包括SIMD技术、SIMT、ARM Neon的指令、寄存器、意图为读者提供对ARM Neon的一个整体理解。
🎬个人简介：一个全栈工程师的升级之路！
📋个人专栏：高性能（HPC）开发基础教程
🎀CSDN主页 发狂的小花
🌄人生秘诀：学习的本质就是极致重复!
目录
1 并行技术的几种方式
1.2 SISD
1.3 MIMD
1.4 SIMD
1.4.1 概念和特点
1.4.2 产生的原因
1.5 MISD
1.6 SIMT
2 NEON介绍
2.1 ARM Neon 特点
2.2 ARM Neon 数据类型
2.2.1 Neon 数据类型的命名格式
2.2.2 支持的数据类型 2.3 ARM Neon 指令
2.4 Neon 寄存器
2.4.1 Neon一般的执行流程
2.4.2 Neon 寄存器
2.5 Neon数据处理指令分类
3 一般使用ARM Neon优化的几种方式
1 并行技术的几种方式 并行计算根据费林分类法，将指令流和数据流的几种不同的方式分成四种计算机类型：SISD、MISD、MIMD、SIMD。NVIDIA CUDA设计出SIMT技术区别于这四种。
1.2 SISD SISD是单指令流单数据流（Single Instruction Single Data）的缩写，是一种计算机体系结构。在SISD中，所有的指令和数据都按照一定的顺序串行执行，即每条指令只处理一个操作数，且每个操作数只在一条指令中使用。
SISD的特点是简单、直观，但效率较低。因为所有指令和数据都必须按顺序执行，所以无法充分利用现代处理器的并行计算能力。不过，由于其实现相对简单，所以在一些简单的应用场景下仍然有一定的应用价值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a9aa92cb88cebf33f087bf4ae4f8192/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7de839bec7e36e6666f60ce52773f27e/" rel="bookmark">
			十四：爬虫-Redis基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、背景 随着互联网+大数据时代的来临，传统的关系型数据库已经不能满足中大型网站日益增长的访问量和数据量。这个时候就需要一种能够快速存取数据的组件来缓解数据库服务I/O的压力，来解决系统性能上的瓶颈。
2、redis是什么 Redis 全称 Remote Dictionary Server（即远程字典服务），它是一个基于内存实现的键值型非关系（NoSQL）数据库，是由c语言编写的。
常见的内存型数据库，除 Redis 之外，还有 Oracle Berkeley DB（甲骨文旗下的一款产品）、SQlite（轻量级内存数据库）、Memcache（键值型分布式缓存数据库）、Altibase（基于内存的高性能数据库）。
3、redis特点 与其他内存型数据库相比，Redis 具有以下特点：
Redis 不仅可以将数据完全保存在内存中，还可以通过磁盘实现数据的持久存储；Redis 支持丰富的数据类型，包括 string、list、set、zset、hash 等多种数据类型，因此它也被称为“数据结构服务器”；Redis 支持主从同步，即 master-slave 主从复制模式。数据可以从主服务器向任意数量的从服务器上同步，有效地保证数据的安全性；Redis 支持多种编程语言，包括 C、C++、Python、Java、PHP、Ruby、Lua 等语言。 4、redis优势 下面对 Redis 的优势进行了简单总结：
性能极高：Redis 基于内存实现数据存储，它的读取速度是 110000次/s，写速度是 81000次/s；多用途工具： Redis 有很多的用途，比如可以用作缓存、消息队列、搭建 Redis 集群等；命令提示功能：Redis 客户端拥有强大的命令提示功能，使用起来非常的方便，降低了学习门槛；可移植性：Redis 使用用标准 C语言 编写的，能够在大多数操作系统上运行，比如 Linux，Mac，Solaris 等。 5、Redis架构 Redis体系架构主要分为两个部分：
Redis服务端Redis客户端 客户端和服务端可以位于同一台计算机上，也可以位于不同的计算机上。服务端是整个架构的“大脑”，能够把数据存储到内存中，并且起到管理数据的作用。
6、Redis应用场景 Redis 用来缓存一些经常被访问的热点数据、或者需要耗费大量资源的内容，通过把这些内容放到 Redis 中，可以让应用程序快速地读取它们。例如，网站的首页需要经常被访问，并且在创建首页的过程中会消耗的较多的资源，此时就可以使用 Redis 将整个首页缓存起来，从而降低网站的压力，减少页面访问的延迟时间。
7、redis学习地址 1、官网地址：https://redis.io/
2、命令地址：http://doc.redisfans.com/
3、更多配置文件: https://www.cnblogs.com/kreo/p/4423362.html
8、redis与其他数据库的对比 数据库的存储方式大体可分为两大类，基于磁盘存储和基于内存存储。磁盘存储的数据库，因为磁头机械运动以及系统调用等因素导致读写效率较低。Redis 基于内存来实现数据存取，相对于磁盘来说，其读写速度要高出好几个数量级。下表将 Redis 数据库与其他常用数据库做了简单对比：
Redis 基于内存来实现数据的存储，因此其速度非常快。但是我们知道，计算机的内存是非常珍贵的资源，所以 Redis 不适合存储较大的文件或者二进制数据，否则会出现错误，Redis 适合存储较小的文本信息。理论上 Redis 的每个 key、value 的大小不超过 512 MB。总得来说，上述数据库各有优势，当我们选用数据库时，也要因地制宜，选择一款与业务场景最相符合的数据库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7de839bec7e36e6666f60ce52773f27e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcd3dc33c343c60a14a35e14dc6971e8/" rel="bookmark">
			【小白专用】C#创建XML文件 更新2024.1.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public static void CreateXml(string strPath) { string directPath = Path.Combine(strPath, "AppData"); string strFileName = directPath + @"/EmployeesList.xml"; //创建xml文档 XmlDocument xmldoc = new XmlDocument(); //加入XML声明 XmlDeclaration xmldecl = xmldoc.CreateXmlDeclaration("1.0", "UTF-8", null); xmldoc.AppendChild(xmldecl); // 创建一个注释节点 XmlNode comment = xmldoc.CreateComment("这是一个注释"); xmldoc.AppendChild(comment); //加入一个根元素 XmlElement employees = xmldoc.CreateElement("Employees"); xmldoc.AppendChild(employees); //根元素加入一些子元素 for (int i = 1; i &lt; 5; i++) { // 创建一个注释节点 XmlNode comment1 = xmldoc.CreateComment("Employee" + i); employees.AppendChild(comment1); XmlElement employee = xmldoc.CreateElement("Employee" + i);//创建一个子节点 employee.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcd3dc33c343c60a14a35e14dc6971e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a2664ebfffbca4530ad92e898f6156/" rel="bookmark">
			OpenSSL provider
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提供者 标准提供者默认提供者传统提供者FIPS 提供者基本提供者空提供者加载提供者 标准提供者 提供者是算法实现的容器。每当通过高级别 API 使用加密算法时，都会选择一个提供者。实际上是由该提供者实现执行所需的工作。OpenSSL 自带了五个提供者。在未来，我们预计第三方将分发自己的提供者，这些提供者可以动态添加到 OpenSSL 中。有关编写提供者的文档，请参阅 provider(7) 手册页。
默认提供者 默认提供者收集了所有标准内置的 OpenSSL 算法实现。如果应用程序未明确指定任何其他内容（例如在应用程序中或通过配置中），那么将使用这个提供者。如果尚未加载其他提供者，当我们首次尝试从提供者获取算法时，它将被自动加载。如果已加载其他提供者，那么它将不会被自动加载。因此，如果您想与其他提供者一起使用它，那么您必须显式加载它。
这是一个“内置”提供者，这意味着它编译和链接到 libcrypto 库中，并不存在为单独的独立模块。
传统提供者 传统提供者是一组传统算法的集合，这些算法要么已不再普遍使用，要么被认为是不安全的，并且强烈建议不要使用。然而，一些应用程序可能需要使用这些算法以实现向后兼容性。该提供者不会被默认加载。这可能意味着从之前版本的 OpenSSL 升级的一些应用程序可能会发现一些算法不再可用，除非它们显式加载传统提供者。
传统提供者中的算法包括 MD2、MD4、MDC2、RMD160、CAST5、BF（Blowfish）、IDEA、SEED、RC2、RC4、RC5 和 DES（但不包括 3DES）。
FIPS 提供者 FIPS 提供者包含了默认提供者中可用的一部分算法实现，这些算法符合 FIPS 标准。预期该提供者将通过 FIPS140-2 验证。
在某些情况下，与默认提供者中等价算法相比，该提供者中的算法实现可能存在细微的行为差异。这通常是为了符合 FIPS 标准。
基本提供者 基本提供者包含了默认提供者中可用的一小部分非加密算法。例如，它包含了用于将密钥序列化和反序列化为文件的算法。如果未加载默认提供者，则应始终加载该提供者（特别是如果您使用 FIPS 提供者）。
空提供者 空提供者“内置”到 libcrypto 中，不包含任何算法实现。为了确保默认提供者不会被自动加载，可以加载空提供者。
如果您正在使用非默认的库上下文，并希望确保默认库上下文不会被意外使用，这将会很有用。
加载提供者 要加载的提供者可以在 OpenSSL 配置文件中指定。有关如何通过配置文件配置提供者以及如何自动激活它们的信息，请参阅 config(5) 手册页。
以下是一个加载和激活默认库上下文中的传统提供者和默认提供者的最小配置文件示例。
openssl_conf = openssl_init [openssl_init] providers = provider_sect [provider_sect] default = default_sect legacy = legacy_sect [default_sect] activate = 1 [legacy_sect] activate = 1 也可以通过编程方式加载提供者。例如，您可以加载传统提供者到默认库上下文中，如下所示。请注意，一旦您显式地将提供者加载到库上下文中，默认提供者将不再自动加载。因此，通常还需要显式加载默认提供者，就像下面的示例一样：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44a2664ebfffbca4530ad92e898f6156/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/730834bb3c33c2ced012ed6b28db0ad0/" rel="bookmark">
			2023年12月第4周面试算法题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		809. 情感丰富的文字——阅读理解题 1、s = “abcd”; words = [“abc”]; 的情况怎么处理
2、怎么求lens与lenw？（连续出现的字符串长度）
class Solution { public: bool isStretchy(const string&amp; s, const string&amp; word) { int i = 0; int j = 0; while (i &lt; s.size() &amp;&amp; j &lt; word.size()) { if (s[i] != word[j]) { return false; } int lens = 0; int lenw = 0; while (i + lens &lt; s.size() &amp;&amp; s[i + lens] == s[i]) { lens++; } while (j + lenw &lt; word.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/730834bb3c33c2ced012ed6b28db0ad0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e9f7dfd94fcd7ac74a1057f6e83713d/" rel="bookmark">
			深度学习｜15.2 注释、one-hot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何识别姓名 建立一个关于姓名的字典。在识别过程中，查找字典中是否存在相关的记录，若有，则大概率是姓名。注意的是，商业级需要3到5万或10万，需要查找速度也要进一步进行优化。
one-hot编码-独热编码 躺平yyds——独热编码
ont-hot编码只能统计出，哪些词项在句子中有出现过，而没有考虑出这些词项前后摆放的逻辑关系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f4875823da1c10f0707245e7c9ce77b/" rel="bookmark">
			软件体系架构复习二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		呃，前面复习的忘了发了。从后面开始吧
Unit 11--18 复习Tips： 重点在于对概念的理解，概念间关系的理解。 对具体的识别方法，处理方法等根据自己的兴趣做一些了解即可 。 如：关于 软件架构脆弱性的成因 ， 首先要知道软件脆弱性是什么，然后知道“软件架构的脆弱 性通常与软件架构的风格和模式有关”， 至于具体不同架构模式的脆弱性表现，只要根据兴趣了解一下就可以，需要举例子时能举出来即可。 这八章均是如此要求。 一、Unit 11-12 软件架构度量和软件架构演化 1.1为什么需要进行软件架构度量？ （软件架构度量的意义/好处）
软件架构作为软件开发的早中期模型，通过对软件架构进行评估分析，能够及早的发现软件开发过程中可能遇到的问题，并提出可行的解决方案，进而提高了软件质量保障，降低了软件开发的风险。
1.2软件度量与软件演化之间的关系？ 通过对演化前后的软件进行度量，分析相关质量属性的变化情况，可以得到软件的内部架构与外在属性之间的联系，有利于进一步在总体上把握和控制软件演化的方向
1.3为什么要进行软件架构演化？ 软件架构演化的目的为了适应用户需求、开发环境、运行环境的变化。
一是在开发过程中用户的需求以及开发环境会发生变化，需要通过改变软件架构来适应用户需求的变化以及开发环境的变化；
二是在项目开发完成后，用户的需求依然可能发生改变，软件的运行环境也可能会发生变化，需要通过架构演化来适应这一系列变化。
1.4软件架构演化的类型？ 静态演化：（1）是什么、（2）必要性、（3）一般流程
（1）静态演化是指开发尚未完成过程中、或者说开发已完成但系统停止运行过程中发生的演化。
（2）在架构开发和实现过程中需要对原有架构进行调整，保证架构与需求之间的一致性
在开发完成后，由于运行环境发生变化，需要对软件进行修改升级。
（3）架构理解——演化需求分析——演化计划设计——演化计划实现——系统测试
动态演化：（1）是什么、（2）必要性、（3）内容以及技术
（1）软件运行过程中，对系统进行更新，且不停止软件功能的运行
（2）系统内部执行导 致的系统架构的变更；二是系统外部发送请求对软件进行重部署
（3）属性变更、接口变更、拓扑结构变更、架构风格变更，
技术：动态重配置（主从模式、中央控制模式、客户端-服务端模式）
二、Unit13 软件架构重构 2.1 软件架构重构是什么，为什么要进行软件架构重构 软件架构重构是指在不改变软件功能以及软件可见部分的前提下，对软件的可维护性、可拓展性等质量属性进行优化的过程。软件从架构重构是软件质量保障的重要手段、是软件架构演化的重要方式。
2.2 基于度量的软件架构重构 （1）如何通过软件架构度量获取重构需求 （2）如何通过软件架构度量进行软件重构建议（如何重构）
（3）基于度量评估的架构重构过程
架构重构一定是在通过度量明确架构缺陷之后才进行的
基于度量对软件架构进行评估——产生重构需求——分析重构需求——设计重构计划——执行重构操作
三、Unit14-15 软件架构腐蚀与软件架构恢复 3.1什么是软件架构腐蚀 是指实际开发中的软件架构与预期的软件架构之间的差别。软件架构腐蚀是由于软件修改产生的，而非人为恶意的。
解决方法（架构腐蚀前：预防腐蚀；架构腐蚀中：减轻架构腐蚀危害；架构腐蚀后：进行腐蚀修复）
3.2什么是软件架构恢复，有什么意义 软件架构恢复是逆向工程的实践和研究的方向。软件架构恢复是指根据项目工程，完成由低层向高层的抽象过程，得到系统架构中组成元素。开发人员可以根据恢复出的系统架构，对系统的代码编写、代码测试等进一步评估优化。
3.3软件架构腐蚀和软件架构恢复之间的关系 随着软件开发的进行，难免会产生文档的缺失，代码与预期的偏差越来越大（架构腐蚀的定义），进而逐步发生软件的架构腐蚀。这时候如果人工来阅读代码来恢复架构的话，无疑很是费时费力，这个时候通过逆向工程来恢复架构对预防软件腐蚀就显得很有意义
四、Unit16-18 技术债、坏味道、脆弱性 4.1 软件技术债的含义和分类 含义：
指软件开发人员为了保证项目进展，或因为时间的原因，或因为开发人员本身技术的原因，在该采用某些最优的设计方案时采取了某些妥协，以在短期内加速开发，进而加重自己未来的开发负担。
分类：
设计债务（没有采用最优架构）
代码债务（没有遵循标准代码格式等）
测试债务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f4875823da1c10f0707245e7c9ce77b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a4926b2e4853c4192f55cddad5a77eb/" rel="bookmark">
			数据结构模拟实现LinkedList双向不循环链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、双向不循环链表的概念
二、链表的接口
三、链表的方法实现
（1）display方法
（2）size方法
（3）contains方法
（4）addFirst方法
（5）addLast方法
（6）addIndex方法
（7）remove方法
（8）removeAllKey方法
（9）clear方法
四、最终代码
一、双向不循环链表的概念 双向不循环链表中的节点有三个域，一个是存储数据的val域，一个是前驱prev域，还有一个是下个节点next域，和单向不同的就是多了一个前驱域。如图：
定义一个MyLinkedList类，这个类包含要模拟实现的方法，还有一个内部类ListNode，这个内部类就是链表的节点，代码如下：
public class MyLinkedList implements Ilist{ public ListNode head;//头结点 public ListNode last;//尾结点 static class ListNode { int val; ListNode next; ListNode prev; public ListNode(int val) { this.val = val; } } } 二、链表的接口 代码如下：
public interface Ilist { //头插法 void addFirst(int data); //尾插法 void addLast(int data); //任意位置插入,第一个数据节点为0号下标 void addIndex(int index,int data); //查找是否包含关键字key是否在单链表当中 boolean contains(int key); //删除第一次出现关键字为key的节点 void remove(int key); //删除所有值为key的节点 void removeAllKey(int key); //得到单链表的长度 int size(); void clear(); void display(); } 三、链表的方法实现 （1）display方法 此方法是打印所有链表节点的val值，因此要遍历一遍链表的节点。代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a4926b2e4853c4192f55cddad5a77eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c50aa97e4ac5a47d71c5b3d173e324d/" rel="bookmark">
			【BIG_FG_CSDN】C&#43;&#43; 数组与指针 （个人向——学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一维数组 在内存占用连续存储单元的相同类型数据序列的存储。
数组是静态存储器的块；在编译时确定大小后才能使用；
其声明格式如下：
元素类型 数组名[常量]； 元素类型：数组中元素的数据类型；
常量：数组的长度，即数组中存放数据的最大个数；可以是数，也可以是自己的常量；
如：
const int MaxSize=100; int a[MaxSize]; 数组定义后，编译系统为其分配地址连续的一段内存空间.
数组名即是所分配内存的首地址，也称为数组的首地址；
数组声明时为其初始化赋值 格式为： 元素类型 数组名[常量]={初值 1,初值 2,...,初值 n};
初始化时，元素的个数应该小于等于数组的长度；
例如：
int a[10]={1,2,3}; //定义数组长度为 10，前 3 个元素初始化为 1,2,3，其它元素为 0； int a[]={1,2,3}; //定义数组，长度省略，则长度等于初始化数据的实际个数 3。 int a[100]={0}; //数组中的值全部为0，只有{0}可以全部初始化；在做true与false时非常有用； 使用数组 数组元素通过下标来访问，每个元素均可视为一个变量来使用，
元素的访问方式为： 数组名[下标]；
下标值的有效范围是 0~数组长度-1；如果越界了，编译器是可以正常运行的，但是会出错；
除字符数组外，其它类型的数组不允许整体访问，也就是数组的输入输出需要对各个元素进行，也就是 数组名[下标] 这种方式使用；
访问数组元素的地址格式为： &amp;数组名[下标]或数组名+下标
数组的内存形象展示 例如：
int a[10];
声明了一个长度为 10 的 int 型一维数组，
系统需要为 a 分配连续的 40B 的内存空间，
元素的访问方式为 a[i]，
地址访问方式为&amp;a[i]或 a+i，i 值的有效范围是 0~9。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c50aa97e4ac5a47d71c5b3d173e324d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d0a9e2c3f4e7c15c6bcc79aa068ee58/" rel="bookmark">
			租房数据分析可视化大屏&#43;58同城 Django框架 大数据毕业设计（附源码）✅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		毕业设计：2023-2024年计算机专业毕业设计选题汇总（建议收藏）
毕业设计：2023-2024年最新最全计算机专业毕设选题推荐汇总
🍅感兴趣的可以先收藏起来，点赞、关注不迷路，大家在毕设选题，项目以及论文编写等相关问题都可以给我留言咨询，希望帮助同学们顺利毕业 。🍅
1、项目介绍 技术栈：
python租房数据分析可视化系统 毕业设计 58同城
python语言、MySQL数据库、Django框架、Echarts可视化
租房数据分析可视化系统是一个基于python语言、MySQL数据库、Django框架和Echarts可视化技术开发的系统。该系统旨在帮助用户通过对租房数据进行分析和可视化展示，提供更直观、全面的租房市场信息，以便用户做出更明智的租房决策。
2、项目界面 （1）租房数据可视化大屏
（2）租房数据管理
（3）系统首页
（4）租房数据条件查询
（5）评论功能
（6）租房数据
3、项目说明 租房数据分析可视化系统是一个基于python语言、MySQL数据库、Django框架和Echarts可视化技术开发的系统。该系统旨在帮助用户通过对租房数据进行分析和可视化展示，提供更直观、全面的租房市场信息，以便用户做出更明智的租房决策。
系统主要包括以下功能：
数据采集与存储：系统通过爬虫技术从58同城等租房网站上采集租房相关数据，并将其存储到MySQL数据库中，包括房源信息、租金、房屋面积、地理位置等各项数据。
数据清洗与处理：对采集到的数据进行清洗和处理，包括去除重复数据、处理缺失值、格式化数据等，以确保数据的准确性和一致性。
数据分析与统计：通过对租房数据进行统计和分析，提取出各种有价值的信息，包括不同城市的租金分布、租房面积分布、租房热门区域等，为用户提供全面的租房市场概况。
可视化展示：利用Echarts可视化技术，将分析结果以图表的形式展示给用户，包括柱状图、饼图、地图等，使用户更直观地了解租房市场的情况。
用户管理与权限控制：系统提供用户管理功能，包括用户注册、登录、密码找回等，同时还可以根据用户的身份和权限，控制其对系统功能的访问和使用。
通过租房数据分析可视化系统，用户可以快速了解租房市场的情况，包括租金水平、热门区域、房屋面积分布等，从而更好地选择合适的租房房源。同时，系统还可以为租房从业人员、房产中介等提供市场调研和决策支持。
4、核心代码 # -*- coding: utf-8 -*- import random import time from urllib import parse from datetime import date, datetime from django.shortcuts import redirect from ..common.helper import * from ..common.vercode import * from simple_mysql import db as mysql import base64 # 处理时间对象序列化问题 class DateEncoder(json.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d0a9e2c3f4e7c15c6bcc79aa068ee58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1930156daaacdefbdd3678098d3d6f50/" rel="bookmark">
			Linux：apache优化（7）—— 日志分割|日志合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作用：随着网站访问量的增加，访问日志中的信息会越来越多， Apache 默认访问日志access_log单个文件会越来越大，日志文件体积越大，信息都在一个文件中，查看及分析信息会及不方便。
分割 实现方式： 1.利用 apache 自带的日志轮循程序 rotatelogs
ErrorLog "|rotatelogs 命令的绝对路径 -l logs/error_%Y%m%d_%H%M%S.log 秒数" CustomLog "| rotatelogs 命令的绝对路径-l logs/access_%Y%m%d_%H%M%S.log 秒数" Combined 2.利用一个发展已经比较成熟的日志轮循工具 cronolog
ErrorLog "|cronolog 绝对路径 -l /usr/local/httpd/logs/error_%Y%m%d%H%M%S.log " CustomLog "|cronnolog绝对路径 -l /usr/local/httpd/logs/access_%Y%m%d%H%M%S.log" combined 3.利用定时任务和 shell 脚本做日志切割
方式一： 利用 apache 自带的日志轮循程序 rotatelogs日志分割：
[root@linuxa ~]# vi /usr/local/httpd/conf/httpd.conf ##10秒切割一次日志文件(切割日志时间频率可以自行改变，根据PV来决定，)，-l选项是小写的L表示local time（本地时间）
215行插入 CustomLog "|/usr/local/httpd/bin/rotatelogs -l /usr/local/httpd/logs/access_%Y%m%d%H%M%S.log 10" combined :wq 方式二：利用一个发展已经比较成熟的日志轮循工具 cronolog
[root@linuxa ~]# tar xf cronolog-1.6.2.tar.gz -C /usr/src/ [root@linuxa ~]# cd /usr/src/cronolog-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1930156daaacdefbdd3678098d3d6f50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf3467267413380c64e14796e7e4326e/" rel="bookmark">
			哈夫曼树到最佳归并树python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Huffman树Huffman树的实现最佳归并树 Huffman树 哈夫曼树通常应用在编码方面，主要为了解决权重或者说频次上的最佳问题。一般来说一个好的编码方案会大大提升通信的效率，降低延迟！如果把编码中出现的频次当作权重，则越是频繁出现的通信语句应当是短小的，而不常用的语句应当是较为长的，这样才能保证我们通信中用的较多的语句占用不大的带宽。
其步骤如下：
给定n个权值w1,w2,w3…将每个权值分别作为一个二叉树的根节点，构成森林F，按照权重排序从F中选两个权重最小的节点，作为一个新节点的左右孩子节点，并且当前权重赋值为两个子节点权重之和删除选中的两个子节点，并将第三步生成的新节点加入F中对应的位置。重复上一步和当前一步直到F中仅剩一棵树即可。 以四个权重7，5，2，4为例：
上图来自王道数据结构。
Huffman树的实现 class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def huffman(weight): tree_list = [TreeNode(val=i) for i in sorted(weight, reverse=True)] while len(tree_list) &gt; 1: left, right = tree_list.pop(), tree_list.pop() new_node = TreeNode(left.val + right.val, left, right) for i in range(len(tree_list) - 1, -1, -1): if new_node.val &lt; tree_list[i].val: break tree_list.insert(i+1, new_node) return tree_list[0] if __name__ == '__main__': weight = [5, 2, 4, 7] ans = huffman(weight) 最佳归并树 我们都知道正常的哈夫曼树只有度为0的节点和度为2的节点，同理最佳归并树也是这样，假设有一个k叉的归并树，那么这棵树应该只有度为0和度为k的节点，总结点数为 k n k + 0 n 0 + 1 = n k + n 0 kn_k+0n_0+1=n_k+n_0 knk​+0n0​+1=nk​+n0​可以得出 n 0 = ( k − 1 ) n k + 1 , n k = ( n 0 − 1 ) / ( k − 1 ) n_0=(k-1)n_k+1,n_k=(n_0-1)/(k-1) n0​=(k−1)nk​+1,nk​=(n0​−1)/(k−1)如果整除则可以说明给定的权重个数正好可以构成归并树，否则说明有 ( n 0 − 1 ) % ( k − 1 ) 个 n 0 (n_0-1)\%(k-1)个n_0 (n0​−1)%(k−1)个n0​节点是多余的，此时应当使用一个 n 0 n_0 n0​节点充当 n k n_k nk​节点，然后再补充 k − 1 − ( n 0 − 1 ) % ( k − 1 ) k-1-(n_0-1)\%(k-1) k−1−(n0​−1)%(k−1)个 n 0 n_0 n0​节点，并将新补充的节点权重置为0即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf3467267413380c64e14796e7e4326e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc49c36cd397443c48839e190a4bb31c/" rel="bookmark">
			力扣题目学习笔记(OC &#43; Swift)27.移除元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
方法一、双指针 注意到上述描述中存在“元素的顺序可以改变”，数组无序，目的是去重，那么我们使用双指针来遍历及操作。
定义双指针left和right，left从0开始向右侧遍历，right从最后一位开始向左侧遍历，最坏情况下只遍历一次数组，效率较高。
当left值等于val时，将right位置的值赋值给left，right减1向左侧移动一位，下次若还相同，则继续将right位置的值赋值给left，right减1向左侧移动一位，直至left位置的值不等于val，将left加1，右移一位。代码如下：
Swift func removeElement(_ nums: inout [Int], _ val: Int) -&gt; Int { guard nums.count &gt; 0 else {return 0} let cnt = nums.count var left = 0, right = cnt while left&lt;right { if nums[left] == val { nums[left] = nums[right-1] right -= 1 }else { left += 1 } } return left } OC - (NSInteger) removeElement:(NSMutableArray *)nums val:(NSInteger)val { if (nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc49c36cd397443c48839e190a4bb31c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41ae24d36376da62ecdf652680c3b4ee/" rel="bookmark">
			2023结婚成家，2024借势起飞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		您好，我是码农飞哥（wei158556），感谢您阅读本文，欢迎一键三连哦。
💪🏻 1. Python基础专栏，基础知识一网打尽，9.9元买不了吃亏，买不了上当。 Python从入门到精通
😁 2. 毕业设计专栏，毕业季咱们不慌忙，几百款毕业设计等你选。
❤️ 3. Python爬虫专栏，系统性的学习爬虫的知识点。9.9元买不了吃亏，买不了上当 。python爬虫入门进阶
❤️ 4. Ceph实战，从原理到实战应有尽有。 Ceph实战
❤️ 5. Java高并发编程入门，打卡学习Java高并发。 Java高并发编程入门
文章目录 1. 说在前面2. 回望2023年2.1. 2023年立的Flag完成否？2.1.1.未完成第一个Flag2.1.2. 未完成第二个Flag2.1.3. 未完成第三个Flag2.1.4. 顺利完成第四个Flag 2.2. 说说2023年做了哪些事2.2.1. 顺利步入婚礼殿堂（2023年最大的一件事）2.2.2. 开辟了一个新的副业之道2.2.3. 知识付费的一年 3. 展望2024年3.1. 工作上3.2. 个人IP&amp;副业上3.2.1. 执行路径 3.3. 读书&amp;锻炼上 4. 感谢 2023 年的那些人 1. 说在前面 2023年1月1日 14:02分，2023年已经走进了历史中。新年第一天从年终总结开始，这里先附上2022年的年终总结： 很二2022，滚蛋吧！ 幸福2023，过来吧！。
如果用两个词来形容我的2023的话，那一定是 紧张 以及幸福。 这里的紧张有初去丈母娘家时的紧张；有婚礼发言时的紧张。这里的幸福有领证时的幸福；有结婚时的幸福。
2. 回望2023年 2.1. 2023年立的Flag完成否？ 回顾2023年的任务之前，首先，来看下2022年立下的那些Flag。2022年我共计立下共计列下来4个Flag。首先，检视一下这些Flag。
2.1.1.未完成第一个Flag 第一个Flag：更加专注于主业 这一块整体来说还是没有完成好，主要从两方面说明：
工作环境上：部门内部发生了一些人事变动，我被动地受到了一些影响。不过，好在新领导对我还比较赏识，暂时平稳度过危机。 但是，世事难料，未来的事情谁说的好呢。
学习上：2023年只系统地学习了RocketMQ的知识点，有关于技术预研，架构演进，性能优化的知识点还是没有深入去了解。
2023年听到最多的消息就是裁员的消息。 2024年行情也会更加的内卷，像我这种大龄程序员可能是随时失业。失业的达摩克利斯之剑始终悬挂在我头上。该怎么办呢？
2.1.2. 未完成第二个Flag 第二个Flag：身体是自己的，体重控制在60KG。 今天称下来体重依然还有 67.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41ae24d36376da62ecdf652680c3b4ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c404824f4f6de848c1b358cd4eec2362/" rel="bookmark">
			【VTK三维重建-体绘制】第四期 VTK中GPU加速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很高兴在雪易的CSDN遇见你 VTK技术爱好者 QQ：870202403
前言 上期内容讲到VTK的体绘制技术vtkGPUVolumeRayCastMapper，本文分享VTK中GPU加速的相关内容，希望对各位小伙伴有所帮助！
感谢各位小伙伴的点赞+关注，小易会继续努力分享，一起进步！
你的点赞就是我的动力(＾Ｕ＾)ノ~ＹＯ
目录
前言
1. vtkGPUInfoList
1.1 Probe
1.2 IsProbed
1.3 GetNumberOfGPUs
1.4 GetGPUInfo
2. vtkGPUInfo
2.1 设置/获取专用显存（DedicatedVideoMemory）
2.2 设置/获取专用系统内存（DedicatedSystemMemory）
2.3 设置/获取共享系统内存（SharedSystemMemory）
3. 实际应用
4. vtkDummyGPUInfoList
5. vtkGPUInfoList其他子类
结论：
1. vtkGPUInfoList 用于存储主机各GPU显存信息列表。
vtkGPUInfoList存储了一系列的vtkGPUInfo。一个主机可以有多个gpu。它通过使用系统调用探测主机来创建和设置列表。这是一个抽象类。具体类是特定于操作系统的。
其重要参数如下：
1.1 Probe 查询该主机中的vtkGPUInfo信息。
1.2 IsProbed 返回是否查询该主机的vtkGPUInfo信息。
1.3 GetNumberOfGPUs 获取GPU的数量
1.4 GetGPUInfo 获取GPU的信息
/** * Return information about GPU i. * \pre probed: IsProbed() * \pre valid_index: i&gt;=0 &amp;&amp; i&lt;GetNumberOfGPUs() * \post result_exists: result!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c404824f4f6de848c1b358cd4eec2362/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73f82dbc46677bc17bd79c3a25b33c61/" rel="bookmark">
			Windows CPU部署llama2量化模型并实现API接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 模型部署本地运行llama2使用fastapi实现API接口常用git仓库 模型部署 从huggingface下载模型
https://huggingface.co/
放在本地文件夹，如下
本地运行llama2 from ctransformers import AutoModelForCausalLM llm = AutoModelForCausalLM.from_pretrained("D:\llm\llama2\models\llama2-7b-chat-ggml", model_file = 'llama-2-7b-chat.ggmlv3.q3_K_S.bin') print(llm('&lt;s&gt;Human: 介绍一下中国\n&lt;/s&gt;&lt;s&gt;Assistant: ')) 使用fastapi实现API接口 服务端
import uvicorn from fastapi import FastAPI from pydantic import BaseModel from ctransformers import AutoModelForCausalLM # 参考 https://blog.csdn.net/qq_36187610/article/details/131835752 app = FastAPI() class Query(BaseModel): text: str @app.post("/chat/") async def chat(query: Query): input = query.text llm = AutoModelForCausalLM.from_pretrained("D:\llm\llama2\models\llama2-7b-chat-ggml", model_file = 'llama-2-7b-chat.ggmlv3.q3_K_S.bin') output = llm('&lt;s&gt;Human: ' + input + '\n&lt;/s&gt;&lt;s&gt;Assistant: ') print(output) return {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73f82dbc46677bc17bd79c3a25b33c61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e320e52f37abd1fd8a74950d76ef4d6/" rel="bookmark">
			Linux学习第49天：Linux块设备驱动实验（一）：Linux三大驱动之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux版本号4.1.15 芯片I.MX6ULL 大叔学Linux 品人间百味 思文短情长 本章学习Linux三大驱动之一的块设备驱动，主要应用场景为存储设备。
本章的思维导图如下：
一、什么是块设备 块设备---存储设备
以块为单位进行读写访问
在机构上可以进行随机访问，使用缓冲区来暂时存放数据。
I/O算法也不同。
二、块设备驱动框架 1.block_device结构体 1 struct block_device { 2 dev_t bd_dev; /* not a kdev_t - it's a search key */ 3 int bd_openers; 4 struct inode *bd_inode; /* will die */ 5 struct super_block *bd_super; 6 struct mutex bd_mutex; /* open/close mutex */ 7 struct list_head bd_inodes; 8 void * bd_claiming; 9 void * bd_holder; 10 int bd_holders; 11 bool bd_write_holder; 12 #ifdef CONFIG_SYSFS 13 struct list_head bd_holder_disks; 14 #endif 15 struct block_device *bd_contains; 16 unsigned bd_block_size; 17 struct hd_struct *bd_part; 18 /*number of times partitions within this device have been opened.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e320e52f37abd1fd8a74950d76ef4d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba4ac922d6344ae12aee55b1678eb3ec/" rel="bookmark">
			怎么获取客户端真实IP？GO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用 Golang 的 net/rpc 包进行 RPC 服务开发时，我们有时候会遇到需要获取客户端的真实 IP 和当前连接 net.Conn 的需求。然而在 net/rpc 的服务处理方法中，并没有提供直接获取到这些信息的途径。
那么，我们应该如何去获取这些信息呢？实现这个功能会有一些复杂，因为RPC的默认处理器没有提供获取net.Conn连接对象的接口。我们需要自定义RPC的编解码器和处理器来获得这些信息。以下是我的解决方案：
首先，我们要创建一个新的RPC服务处理器：
type serverCodec struct { rwc io.ReadWriteCloser dec *gob.Decoder // for reading JSON values enc *gob.Encoder // for writing JSON values encBuf *bufio.Writer conn net.Conn } func (c *serverCodec) ReadRequestHeader(r *rpc.Request) error { err := c.dec.Decode(r) if err != nil { return err } return nil } func (c *serverCodec) ReadRequestBody(body interface{}) error { return c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba4ac922d6344ae12aee55b1678eb3ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04830e56bf97c3394c988bf3eb86f653/" rel="bookmark">
			CSS-4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平面转换 整体认识 div { margin: 100px 0; width: 100px; height: 100px; background-color: pink; /* 过渡效果 */ transition: all 1s; } /* 当鼠标悬停到div时，进行平面转换 */ div:hover { transform: translate(800px) rotate(360deg) scale(2) skew(180deg); } 作用：为元素添加动态效果，一般与过渡配合使用 概念：改变盒子在平面内的形态（位移、旋转、缩放、倾斜） 平移 案例展示：通过平移实现"居中"效果 （原理：利用 transform: translate(); 取值为百分比时候，是参照盒子自身尺寸计算结果的特点） &lt;style&gt; .box { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); width: 100px; height: 100px; background-color: pink; } &lt;/style&gt; &lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;/body&gt; 属性： transform: translate(X轴移动距离，Y轴移动距离); 取值： 1.像素单位数值 2.百分比（参照盒子自身尺寸计算结果） 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04830e56bf97c3394c988bf3eb86f653/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d6700e1d8536222910f35c7b7849449/" rel="bookmark">
			前端八股文（HTML篇）一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.什么是DOCTYPE,有何用呢？
2.说说对html语义化的理解
3.src和href的区别？
4.title与h1的区别，b与strong的区别，i与em的区别？
5.什么是严格模式与混杂模式？
6.前端页面有哪三层构成，分别是什么？
7.行内元素和块级元素分别有哪些？有何区别？
八.HTML5中新增了哪些新特性？移除了哪些元素？
九.对于Web标准以及W3C的理解
十.知道什么是微格式吗？
1.什么是DOCTYPE,有何用呢？ Doctype是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明时必须的。
2.说说对html语义化的理解 HTML标签的语义化，简单来说，就是用正确的标签做正确的事情，给某块内容用上一个最恰当的标签，使页面有良好的结构，页面元素有含义。
语义化的优点如下:
在没有css样式情况下也能够让页面呈现出清晰的结构有利于SEO和搜索引擎建立良好的沟通，有助于爬虫抓取更多的有效信息，爬出是依赖于标签来确定上下文和各个关键字的权重。方便团队开发和维护，语义化更具有可读性，遵循w3c标准的团队都遵循这个标准，可以减少差异化。 3.src和href的区别？ src和href都是HTML中特定元素的属性，都可以用来引入外部的资源。两者区别如下：
src：全称source，它通常用于img，video，audio，script元素，通过src指向请求外部资源的来源地址，指向的内容会嵌入到文档中当前标签所在的位置，它会将资源下载并应用到文档内，比如说：js脚本、img图片、frame等元素。当浏览器解析到该元素时，会暂停其它资源下载，直到将该资源加载、编译、执行完毕。这也是为什么将js脚本放在底部而不是头部的原因。href：全称hyper reference ，意味着超链接，指向网络资源，当浏览器识别到它指向的文件时，就会并行下载资源，不会停止对当前文档的处理，通常用于a，link元素。 4.title与h1的区别，b与strong的区别，i与em的区别？ title属性表示网页的标题，h1元素表示层次明确的页面的内容标题，对页面信息的抓取也有很大的影响strong是标明重点内容，有语气加强的含义而b是展示强调内容i是italic（斜体）的简写，是早期的斜体元素，表示内容展示为斜体，而em是emphasize（强调）的简写，表示强调的文本。 5.什么是严格模式与混杂模式？ 严格模式：是以浏览器支持的最高标准运行混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为 6.前端页面有哪三层构成，分别是什么？ 构成：结构层，表示层，行为层
1.结构层
结构层是由HTML超文本标记语言来创建的，也就是页面中的各种标签，在结构层中保存了用户可以看到所有内容。
2.表示层
表示层是由css负责创建，它的作用是如何显示有关内容，学名：层叠样式表。
3.行为层
行为层表示网页内容跟用户之间产生交互性，简单来说就是用户操作了网页，网页给用户一个反馈。
7.行内元素和块级元素分别有哪些？有何区别？ 常见的块级元素：p,div,form,ul,li ,ol,table,h1,h2,h3,h4,h5,h6,dl,dt,dd
常见的行内元素：span,a,img,button,input,select
块级元素：
总是在新行上开始，就是每个块级元素独占一行，默认从上到下排列宽度缺少时它的容器的100%,除非设置一个宽度高度，行高以及外边距和内边距都是可以设置的块级元素可以容纳其他行内元素和块级元素 行内元素：
和其他元素都会在一行显示高，行高以及外边距和内边距可以设置宽度就是文字或者图片的宽度，不能改变行级元素只能容纳文本或者其他行内元素 八.HTML5中新增了哪些新特性？移除了哪些元素？ HTML5中主要是关于图像，位置，存储，多任务等功能的增加：
语义化标签，如：article，footer，header，nav等视频video，音频audio画布canvas表单控件，calemdar，date，time，email地理本地离线存储，localStorage长期存储数据，浏览器关闭数据不丢失，sessionStorage的数据在浏览器关闭后自动删除拖拽释放 移除的元素：
纯表现的元素：basefont、font、s、strike、tt、u、big、center对可选性产生负面影响的元素：frame、frameset、noframes 九.对于Web标准以及W3C的理解 web标准简单来说可以分为结构，表现，行为。其中结构是由HTML各种标签组成，简单来说就是body里面写入标签是为了页面的结构。表现是指css层叠样式表，用过css可以让我们的页面结构标签更具美感。行为是指页面和用户具有一定的交互。
W3C，全称：world wide web consortium是一个制定各种标准的非盈利性组织，也叫万维网联盟，标准包括HTML、CSS、ECMAScript等等，web标准的制定有很多好处，比如说：
可以统一开发流程，统一使用标准化开发工具（VSCode、WebStorm、Sublime），方便多人协作学习成本降低，只需要学习标准就行，否则就要学习各个浏览器厂商标准跨平台，方便迁移都不同设备降低代码维护成本、 十.知道什么是微格式吗？ 所谓的微格式是建立在已有的，被广泛采用的标准基础之上的一组简单的，开发的数据格式。
具体表现是把语义嵌套在HTML中，以便有助于分离式开发，并通过制定一些简单的约定，来兼顾HTML文档的可阅读性，相当于对web网页进行语义化注解。
采用微格式的web页面，在HTMl文档中给一些标签增加一些属性，这些属性对信息的语义结构进行注解，有助于处理HTML文档的软件，更好的理解HTML文档。当爬取web内容时，能够更为准确地识别到内容块的语义，微格式可以对网站进行SEO优化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e35d4ecd3e4e454b5e8918bb6019682/" rel="bookmark">
			前端八股文（CSS篇）一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.px和em的区别
2.介绍下BFC及其应用
3.介绍下粘性布局（sticky）
4.清除浮动的方法
5.如何用css或js实现多行文本溢出省略效果，考虑兼容
6.如何触发重排和重绘？
7.重绘与重排的区别？
8.说说两种盒模型以及区别
9. 讲一下png8、png16、png32的区别，并简单讲讲 png 的压缩原理
10.分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景
1.px和em的区别 px全称pixel像素，是相对于屏幕分辨率而言的，它是一个绝对单位，但同时具有一定的相对性。因为在同一个设备上每个像素代表的物理长度是固定不变的，这点表现的是绝对性。但是在不同的设备之间，每个设备像素所代表的的物理长度是可以变化的，这点表现的是相对性。
em是一个相对长度单位，具体大小需要相对于父元素计算，比如父元素的字体大小为80px，那么子元素1em就表示大小和父元素一样为80ox，0.5em就表示字体大小是父元素的一半为40px
2.介绍下BFC及其应用 所谓BFC，指的是一个独立的布局环境，BFC内部的元素布局与外部互不影响。
触发BFC的方式有很多，常见的有：
设置浮动overflow设置为auto，scroll，hiddenposition设置为absolute，fixed 常见的BFC应用有：
解决浮动元素令父元素高度坍塌的问题解决非浮动元素被浮动元素覆盖问题解决外边距垂直方向重合的问题 3.介绍下粘性布局（sticky） position中sticky值是css3新增的，设置sticky值后，在屏幕范围时该元素的位置并不受定位影响（设置top，left等属性是无效的），当该元素的位置将要偏移范围时，定位又会变成fixed，根据设置的left，top等属性成固定位置的效果
sticky属性值有以下几个特点：
该元素并不脱离文档流，仍然保留元素原本在文档流中的位置当元素在容器中被滚动超过指定的偏移值时，元素在容器内固定在指定位置。即如果你设置了top: 50px，那么在sticky元素到达距离相对定位的元素顶部50px的位置时固定，不再向上移动。元素固定的相对偏移是相对离他最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于viewport来计算元素的偏移量 4.清除浮动的方法 clear清除浮动（添加空div法）在浮动元素下方添加空div，并给该元素写css样式：{clear:both;height:0;overflow:hidden;}给浮动元素父级设置高度父级同时浮动（需要给父级同级元素添加浮动）父级设置为inline-block，其margin:0 auto居中方法失效给父级添加overflow：hidden清除浮动方法万能清除法: ::after伪元素清浮动 5.如何用css或js实现多行文本溢出省略效果，考虑兼容 单行：
overflow: hidden; text-overflow:ellipsis; white-space: nowrap; 多行：
display:-webkit-box; -webkit-box-orient:vertical; -webkit-line-clamp:3;//行数 overflow:hidden; 兼容：
p{position: relative; line-height: 20px; max-height: 40px;overflow: hidden;} p::after{content: "..."; position: absolute; bottom: 0; right: 0; padding-left: 40px; background: -webkit-linear-gradient(left, transparent, #fff 55%); background: -o-linear-gradient(right, transparent, #fff 55%); background: -moz-linear-gradient(right, transparent, #fff 55%); background: linear-gradient(to right, transparent, #fff 55%); } JS实现方式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e35d4ecd3e4e454b5e8918bb6019682/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27be1cfec9520c80c073e080113fbf48/" rel="bookmark">
			前端八股文（CSS篇）二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.css中可继承与不可继承属性有哪些
2.link和@import的区别
3.transition和animation的区别
4.margin和padding的使用场景
5.：：before和：after的双冒号和单冒号有什么区别？
6.display:inline-block什么时候会显示间隙
7.如何判断元素是否到达可视区域
8.z-index属性在什么情况下会失效
9. Sass,Less是什么？为什么要使用它们？
10.对媒体查询的理解？
1.css中可继承与不可继承属性有哪些 一,无继承性的属性：
display：规定元素应该生成的框类型文本属性： vertical-align：垂直文本对齐text-decoration：规定添加到文本的装饰text-shadow：文本阴影效果white-space：空白符的处理unicode-bidi：设置文本的方向 3.盒子模型的属性：width，height，margin，border，padding
4.背景属性：background，background-color，background-image，background-repeat，background-position，background-attachment
5.定位属性：float，clear，position，top，right，bottom，left，min-width，min-height，max-width，max-height，overflow，clip，z-index
6.生成内容属性：content，counter-reset，counter-increment
7.轮廓样式属性：outline-style，outline-width、outlien-color，outline
8.页面样式属性：size，page-break-before，page-break-after
9.声音样式属性：：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during
二，有继承性的属性：
1.字体系列属性：
font-family：字体系列font-weight：字体的粗细font-size：字体的大小font-style：字体的风格 2.文本系列属性：
text-indent：文本缩进text-align:文本水平对齐line-height：行高word-spacing：单词之间的简距letter-spacing：中文或字母之间的间距text-transform：控制文本大小color：文本颜色 3.元素可见性：
visibility：控制元素显示隐藏 4.列表布局属性
list-style：列表风格 5.光标属性
cursor：光标显示为何种形态 2.link和@import的区别 两者都是外部引用css的方式，它们区别如下：
link是XHTML的标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载css。link引用css时，在页面载入时候同时加载；@import需要页面网页完全载入以后加载。link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持link支持使用JavaScript控制DOM去改变样式；而@import不支持 3.transition和animation的区别 transition是过渡属性，强调过渡，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。animation是动画属性，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。 4.margin和padding的使用场景 需要在border外侧添加空白，且空白处不需要背景时，使用margin需要在border内侧添加空白，且空白处需要背景时，使用padding。 5.：：before和：after的双冒号和单冒号有什么区别？ 1.冒号（：）用于css3伪类，双冒号（：：）用于css3伪元素。
2.：：before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在于页面之中。
注意： :before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before、::after。
6.display:inline-block什么时候会显示间隙 有空格时会有间隙，可以删除空格解决。margin正值时，可以让margin使用负值解决；使用font-size时，可通过设置font-size：0，letter-spacing，word-spacing解决。 7.如何判断元素是否到达可视区域 以图片显示为例：
window.innerHeight是浏览器可视区的高度；document.body.scrollTop||document.doucmentElement.scrollTop是浏览器滚动过的距离imgs.offsetTop是元素顶部距离文档顶部的高度（包括滚动条的距离）内容达到显示区域的：img.offsetTop&lt;window.innerHeight+document.body.scrollTop 8.z-index属性在什么情况下会失效 通常z-index的使用是在两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要时relative，absolute或是fixed。
z-index属性在下列情况下会失效：
父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或fixed中的一种；元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block； 9. Sass,Less是什么？为什么要使用它们？ 它们都是css预处理器，是css上的一种抽象层。他们是一种特殊的语法/语言编译成css。例如Less是一种动态样式语言，将css赋予了动态语言的特性，如变量，继承，运算，函数，Less既可以在客户端运行，也可以在服务器端运行。
为什么要使用它们？
结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27be1cfec9520c80c073e080113fbf48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ad15cad0e975967bb2053965f5fb685/" rel="bookmark">
			【分布式微服务专题】SpringSecurity快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言阅读对象阅读导航前置知识笔记正文一、Spring Security介绍1.1 什么是Spring Security1.2 它是干什么的1.3 Spring Security和Shiro比较 二、快速开始2.1 用户认证2.1.1 设置用户名2.1.1.1 基于application.yml配置文件2.1.1.2 基于Java Config配置方式 2.1.2 设置加密方式2.1.2.1 {id}encodedPassword2.1.2.2 使用PasswordEncoder加密 2.1.3 自定义用户信息加载2.1.4 自定义登录页面2.1.5 前后端分离认证2.1.6 用户认证流程总结 2.2 访问控制2.2.1 web授权： 基于url的访问控制2.2.2 方法授权：基于注解的访问控制 三、Spring Security整合JWT实现自定义登录认证3.1 自定义登录认证业务流程3.2 JWT介绍3.2.1 什么是JWT 3.3 JWT结构3.3.1 JWT头部header3.3.2 JWT载荷payload3.3.3 JWT签名signature3.3.4 组合在一起3.3.5 如何使用 3.4 代码实现自定义登录3.5 JWT续期问题3.5.1 刷新令牌（Refresh Token）3.5.2 自动延长JWT有效期 学习总结感谢 前言 阅读对象 阅读导航 系列上一篇文章：《》
前置知识 笔记正文 一、Spring Security介绍 1.1 什么是Spring Security 官方介绍：Spring Security 是一个功能强大且高度可定制的身份验证和访问控制框架。它是用于保护基于 Spring 的应用程序。
Spring Security 是一个框架，侧重于为 Java 应用程序提供身份验证和授权。与所有 Spring 项目一样，Spring 安全性的真正强大之处，在于它很容易扩展以满足定制需求
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ad15cad0e975967bb2053965f5fb685/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dcfe53ead071a5631a449bb41f4c711/" rel="bookmark">
			Axios 面试题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Axios 面试题及答案 什么是 Axios？它有哪些主要特点和优势？
答案： Axios 是一个基于 Promise 的 JavaScript HTTP 客户端库，用于浏览器和 Node.js。它具有以下主要特点和优势：
支持浏览器和 Node.js 环境下的 HTTP 请求。提供了简单易用的 API，可以处理异步请求。支持 Promise API，可以更好地处理请求的结果。自动转换请求和响应的数据为 JSON 格式。提供了请求拦截器和响应拦截器，可以在请求发送和响应返回时进行拦截和处理。支持取消请求，可以中断正在进行的请求。提供了丰富的配置选项，可以灵活地配置请求的参数和行为。在浏览器中可以利用 XMLHttpRequest 或 Fetch 进行请求，而在 Node.js 中可以利用 http 或 https 模块进行请求。 如何在 Axios 中设置请求的超时时间？
答案： 在 Axios 中可以通过配置 timeout 参数来设置请求的超时时间。timeout 参数表示请求在指定的毫秒数内没有完成，则会被取消。示例代码如下：
axios.get('/api/data', { timeout: 5000 // 设置超时时间为 5 秒 }) .then(response =&gt; { // 请求成功的处理逻辑 }) .catch(error =&gt; { // 请求失败的处理逻辑 }); ``` Axios 的请求拦截器和响应拦截器有什么作用？如何使用它们？
答案： 请求拦截器和响应拦截器是 Axios 提供的两个重要功能，用于在请求发送和响应返回时进行拦截和处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dcfe53ead071a5631a449bb41f4c711/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fd1bdd9735f5e43ea6e5d1e37a7a61d/" rel="bookmark">
			2024CleanMyMac X全新免费永久版下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果你的Mac运行速度变慢，很有可能是因为RAM内存被过度占用了。本文将向Mac用户，尤其是小白用户归纳一些常见的Mac内存清理方法。通过释放RAM内存，你将会看到自己Mac的运行速度有显著提升。
你的Mac运行速度是否变得慢到让人抓狂？打开的应用程序经常出现卡顿？你是否经常看到“系统的应用程序内存不足”的提示消息？所有这些状况都可能是因为Mac电脑的RAM内存被使用过度占用。本文将向Mac用户，尤其是小白用户归纳一些常见的Mac内存清理方法。通过释放RAM内存，你将会看到自己Mac的运行速度有显著提升。
CleanMyMac X全新版下载如下:
https://wm.makeding.com/iclk/?zoneid=49983 首先，在介绍如何进行Mac内存清理之前，我们来解答一些用户可能感到好奇的一个疑问：什么是RAM内存？解答了这个问题后，我们再来介绍如何清理Mac电脑的内存，以及一些帮助你清理或优化Mac内存的有用技巧。
什么是RAM内存？ 先快速科普一下什么是内存。计算机内存，英文缩写为RAM，含义是“随机存取存储器”。内存为电脑正在运行的任务和过程提供存储。内存与Mac电脑的磁盘存储空间的区别在于，内存能让Mac运行应用程序时速度更快，因此Mac旨在将某些内容保留在内存中，以加快处理速度。
目前，8GB内存仍然是苹果电脑的主流配置，也是许多用户购买Mac时的选择，不过一些较早的机型仅具有4GB 的内存。如果你不运行需要大量内存的应用程序和游戏，其实8GB应该够日常使用的。
但是，有些设计不良的网页和应用程序可能会导致内存被大量占用，所以，即使是用来做最简单日常使用的Mac用户，也有可能遇到RAM内存不足的情况，从而导致卡顿和系统崩溃等烦恼。
下面我们将介绍一些在Mac上常见的清理内存占用的方法： 1. 重启Mac 重新启动电脑是释放内存的最简单方法。在大多数情况下，它的确可以解决Mac内存不足的问题。
当Mac重启时，它将清空内存以及所有正在使用的缓存。因此，一般情况下，重启后的Mac运行起来相对会更加流畅。
但是，还是会出现很多不方便重启的情况。也许你运行的应用程序或系统已经卡住，而重启会导致丢失某些未保存的数据；也许重启后要重新打开多个应用程序会让你觉得很繁琐，或者你的某个应用程序正在进行不能被中断的任务，例如无法断点续传的文件已经下载到80%了。
如果你不想重启Mac，要清理释放内存该怎么做呢？请继续往下阅读。
2. 使用专业的内存清理工具 使用第三方清理工具，可以让你更好的管理Mac的内存使用情况，尤其是那些经常需要同时运行多个应用程序或电脑内存配置相对较低的用户。这种情况下，使用第三方清理工具，会更方便，更省力——不必再每次出现卡顿或内存不足的时候就得重启Mac了。
目前有很多款第三方清理应用程序，比较受Mac用户欢迎的是CleanMyMac X, 其功能比较完善，包括释放内存、一键智能扫描垃圾和缓存文件、清理磁盘空间、卸载流氓软件等等，大家可以免费下载来试试。
那么，如何使用这款应用程序来精准地解决内存问题呢？该应用程序中有一个名为“释放RAM”的工具。这就是你所需要的。具体步骤如下：
下载CleanMyMac X（可从此处获得免费版本）打开程序，然后单击左侧菜单中的“维护”模块现在，找到“释放RAM”按钮 这个工具可以让你的Mac在你需要时快速地腾出内存。例如，当你需要解冻某些应用程序被卡住的问题时。
3. 更新macOS 由于内存不足问题有时可能也与macOS已知的系统问题有关。因此，最好记得定期检查自己的Mac是否运行的是最新版本的系统。如果不是，则应在必要时进行更新。一般来说，系统更新会解决掉一些bug，这也会让Mac的内存使用情况得到优化。
4. 查看“活动监视器” 当Mac速度变慢或应用程序卡住时，有经验的用户可能最先想到的是检查Mac自带的应用程序“活动监视器”。 你可以在“实用工具”中找到它，也可以在Spotlight聚焦搜索中输入“活动监视器”（按Command +空格以打开Spotlight聚焦搜索窗口）。
你可以在“活动监视器”中查看内存的使用量，从而帮助你确定是否有特定的应用程序正在消耗了过多的资源。
你可以看到有关每个进程和应用程序的详细信息，例如内存占用量、线程数等等。在这些列下方，您会看到一个内存压力图，以及有关“物理内存”、“已使用内存”、“已缓存文件”和“已使用的交换”等数据。旁边还列出了 “应用内存”、“联动内存”和“被压缩”等信息。
活动监视器所列出的这些内存信息相对比较专业，有经验的Mac用户可以通过这些数据来管理内存，而对Mac小白用户来说使用起来就不是那么友好了。
5. 关闭不用的应用程序 即使不查看活动监视器，快速浏览一下程序坞也会发现一些暂时不再需要使用的应用程序，此时就可以关闭这些程序，从而释放了一些内存资源。在查看程序坞时，你会注意到某些应用程序的图标下方有一个点，这表示的是应用程序处于打开状态。
要手动退出打开的应用程序，在程序坞上用鼠标右键点击它的图标，在弹出的菜单中选择“退出”即可。
6. 阻止非必要的应用程序自动启动 在后台偷偷运行的应用程序也会占用RAM内存资源。即使你从未打开过这些应用程序，你也会发现这些应用程序仍然在后台运行着。这可以是因为你的Mac启动项中包含了这些应用程序，这意味着它们在你启动Mac时将自动运行。
那么，如何阻止非必要的应用程序自动启动呢？方法如下：
打开系统偏好设置单击“用户与群组”单击“登录项”选项卡在这里，你会看到一系列应用程序，它们将在每次启动Mac时自动运行如果认为有哪个应用程序你认为是非必要自动运行的，则在列表中选中它，然后单击（-）按钮
以上就是Mac清理内存的常见方法。对于动手能力不强或刚刚开始使用Mac的用户，我们认为最好的解决方案还是选择使用专业的第三方内存清理工具。最后要提醒的是，选择第三方应用程序，记得选择像CleanMyMac X 这类已经获得Apple认证的软件。使用未经认证的软件可能会带来不必要的风险。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/397edfa033c74de3596a3b52ef3f7669/" rel="bookmark">
			mysql原理--Explain详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述
一条查询语句在经过 MySQL 查询优化器的各种基于成本和规则的优化会后生成一个所谓的 执行计划 ，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。设计 MySQL 的大叔贴心的为我们提供了 EXPLAIN 语句来帮助我们查看某个查询语句的具体执行计划。
如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个 EXPLAIN ，就像这样：EXPLAIN SELECT 1\G
输出的一大坨东西就是所谓的 执行计划 ，我的任务就是带领大家看懂这一大坨东西里边的每个列都是干啥用的，以及在这个 执行计划 的辅助下，我们应该怎样改进自己的查询语句以使查询执行起来更高效。其实除了以 SELECT 开头的查询语句，其余的 DELETE 、 INSERT 、 REPLACE 以及 UPDATE 语句前边都可以加上 EXPLAIN这个词儿，用来查看这些语句的执行计划，不过我们这里对 SELECT 语句更感兴趣，所以后边只会以 SELECT 语句为例来描述 EXPLAIN 语句的用法。为了让大家先有一个感性的认识，我们把 EXPLAIN 语句输出的各个列的作用先大致罗列一下：
列名描述id在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 idselect_typeSELECT 关键字对应的那个查询的类型table表名partitions匹配的分区信息type针对单表的访问方法possible_keys可能用到的索引key实际上使用的索引key_len实际使用到的索引长度ref当使用索引列等值查询时，与索引列进行等值匹配的对象信息rows预估的需要读取的记录条数filtered某个表经过搜索条件过滤后剩余记录条数的百分比Extra一些额外的信息 为了故事的顺利发展，我们还是要请出我们前边已经用了n遍的 single_table 表，为了防止大家忘了，再把它的结构描述一遍：
CREATE TABLE single_table ( id INT NOT NULL AUTO_INCREMENT, key1 VARCHAR(100), key2 INT, key3 VARCHAR(100), key_part1 VARCHAR(100), key_part2 VARCHAR(100), key_part3 VARCHAR(100), common_field VARCHAR(100), PRIMARY KEY (id), KEY idx_key1 (key1), UNIQUE KEY idx_key2 (key2), KEY idx_key3 (key3), KEY idx_key_part(key_part1, key_part2, key_part3) ) Engine=InnoDB CHARSET=utf8; 我们仍然假设有两个和 single_table 表构造一模一样的 t1 、 t2 表，而且这两个表里边儿有10000条记录，除 id 列外其余的列都插入随机值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/397edfa033c74de3596a3b52ef3f7669/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b96f9623553ac8f08a636243c23138e/" rel="bookmark">
			P1163 银行贷款
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		P1163 银行贷款 P1163 银行贷款
题意 1.从银行贷款后，在一段时间内每月偿还固定的分期付款。这个问题要求计算出贷款者向银行支付的利率。假设利率按月累计。
2.三个用空格隔开的正整数。第一个整数表示贷款的原值n，第二个整数表示每月支付的分期付款金额 m，第三个整数表示分期付款还清贷款所需的总月数t。
思路 先判断题目用什么知识点，例：这题二分。理解题意，将实例演示出来。注意细节，将实例带到所写的代码中看看能不能实现。 坑点 数据保证答案不超过300.0%，给l,r定义范围。钱多钱少与在二分中间值的左边还是右边要搞搞清楚。ans&gt;0，还有钱没还清，利润小了，往右边找。ans&lt;0，多还钱了，利润大了所有往左找。 算法一：浮点二分 时间复杂度 输出大小: 1.90697479248047 MiB
编译时间: 1.14s
实现步骤 首先定义函数，函数里面用二分（模版）解答，n贷款，m分期付款，t月数根据题目，在理解题目意思的前提下，用二分法将题意表达出来。最后在主函数中应用所定义的函数。 代码 #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; double n,m,t;//n贷款，m分期付款，t月数 //double h; double find(double l,double r){ double mid=(l+r)/2;//表示一开始的利润 double ans=n;//ans为剩下的钱 for(int i=1;i&lt;=t;i++){ ans=ans*(1+mid)-m; } if(ans==0||r-l&lt;0.000001){//保证精准度足够 return mid; } if(ans&gt;0){//还有钱没还清，利润小了 ,往右边找 return find(l,mid); //相当于r=mid } if(ans&lt;0){//多还钱了，利润大了所有往左找 return find(mid,r);//相当于l=mid } } int main(){ //	cin&gt;&gt;n&gt;&gt;m&gt;&gt;t; scanf("%lf%lf%lf",&amp;n,&amp;m,&amp;t); double h=find(0,5);//数据保证答案不超过300.0% //给l,r定义范围 printf("%.1lf",h*100); return 0; } 总结 浮点二分和二分一样，都要先定义一个函数，再在主函数里运用函数，说白了，唯一不同的就是，数值是一个是浮点型，一个是整型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e8f7882ed39d31bff50ca287358c7be/" rel="bookmark">
			深度学习——PIL和OpenCV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PIL 官方文档
格式互转
opencv cv2.imread()
参数：
filepath：读入imge的完整路径
flags：标志位，{cv2.IMREAD_COLOR，cv2.IMREAD_GRAYSCALE，cv2.IMREAD_UNCHANGED}
cv2.IMREAD_COLOR：默认参数，读入一副彩色图片，忽略alpha通道，可用1作为实参替代
cv2.IMREAD_GRAYSCALE：读入灰度图片，可用0作为实参替代
cv2.IMREAD_UNCHANGED：名思义，读入完整图片，包括alpha通道，可用-1作为实参替代
二值图片读取与ndarray数据查看
cv2.imshow(window_name, image)
cv2.add() 图像相加的一些特殊性质，超过255仍为255
https://blog.csdn.net/qq1198768105/article/details/126334509
cv2.cvtColor()
https://blog.csdn.net/weixin_36670529/article/details/113755331
cv2.imwrite(frame_name, frame)
cv2.threshold(img, threshold, maxval,type)
注意返回值有两个，一个是设置的阈值，一个是图片本身
https://blog.csdn.net/m0_51004308/article/details/113179712
cv2.connectedComponentsWithStats()
https://zhuanlan.zhihu.com/p/59486758
https://blog.csdn.net/weixin_44599604/article/details/111687531
https://www.5axxw.com/questions/simple/fbcmbh
cv2.rectangle(),cv2.cricle(),cv2.line(),cv2.putText()
https://blog.csdn.net/AX642511931/article/details/124239421
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecdd1524014d03471125db2838d642c5/" rel="bookmark">
			微信小程序开发系列-11组件间通信02
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序开发系列目录 《微信小程序开发系列-01创建一个最小的小程序项目》
《微信小程序开发系列-02注册小程序》
《微信小程序开发系列-03全局配置中的“window”和“tabBar”》
《微信小程序开发系列-04获取用户图像和昵称》
《微信小程序开发系列-05登录小程序》
《微信小程序开发系列-06事件》
《微信小程序开发系列-07组件》
《微信小程序开发系列-08自定义组件模版特性》
《微信小程序开发系列-09自定义组件样式特性》
《微信小程序开发系列-10组件间通信01》
文章目录 微信小程序开发系列目录前言behaviorsbehaviors的定义behaviors的使用引用外部behaviors引用内置behaviorswx://form-field普通页面form组件的submit自定义组件中form组件的submit 小结 selector什么是selectorselector的使用 获取组件实例总结 前言 上一篇文章中将组件间通信还有一个模块没有学习到，本文继续学习。
behaviors behaviors 是用于组件间代码共享的特性。
behaviors的定义 每个 behavior 可以包含一组属性、数据、生命周期函数和方法。组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。 每个组件可以引用多个 behavior ，behavior 也可以引用其它 behavior 。
详细的参数含义和使用请参考 Behavior 参考文档。
// my-behavior.js module.exports = Behavior({ behaviors: [], properties: { myBehaviorProperty: { type: String } }, data: { myBehaviorData: {} }, attached: function(){}, methods: { myBehaviorMethod: function(){} } }) behaviors的使用 使用 Component 构造器来构造页面的一个好处是可以使用 behaviors 来提取所有页面中公用的代码段。
组件既可以使用外部引入的behavior，也可以使用内置的behavior。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecdd1524014d03471125db2838d642c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e1338653e998fd1e7e5a7bbe46558e5/" rel="bookmark">
			51单片机中TCON, IE, PCON等寄存器的剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在单片机中，如何快速通过名字记忆IQ寄存器中每一个控制位的作用呢？
IE（interrupt enable）寄存器中，都是中断的使能位置。
其中的EA（enable all）是总使能位，ES(enable serial)是串口中断使能位，其余是两个外部中断EX(enable external)的使能位（其余的两个外部中断在其他的寄存器中），和三个定时器ET(enable timer)的中断使能位。
TCON(timer control)寄存器中，是一个关于定时器/计时器的控制寄存器,但是也集成了外部中断的一些控制位，如下图：
其中I打头的，都是关于外部中断的控制位，TCON中关于外部中断的中的位数的名字非常奇怪，其中一个为IE，和IE寄存器的名字一样，不知道的还以为是总中断的控制位，也有人认为其的缩写是（interrupt enbale），但是其确实一个关于外部中断的标志位，所以名字很奇怪。在所有的寄存器中，标志位都是由芯片自己控制的，也就是标志位自己会变成1或者0，这个标志位是用来给操作者读取的，是芯片对于中断的一种外界的反应，相当于串口中断中的TI和RI，是自己变化的。IE和TI和RI一样，是中断的一个标志，不过是外部中断的标志，只需要记住TCON中集成的外部中断的中断标志（部分，只有两个），而其中的IT（interrupt type），也是外部中断的控制位，表示的中断类型，IT = 1的时候是下降沿，IT = 0的时候是低电平。总之，外部中断没有自己独立的一个，为外部中断控制寄存器，其控制位都是分布在别的寄存器中的。其控制位，除了控制中断的使能位之外，其余的都是I开头的。
其中，T打头都是定时器的控制位，虽然表示的计时器少了一个（一共有三个计时器）。TR（time run）表示的是可以允许让计时器开始计时，为1的时候，是可以开始允许计时的。而TF（time overflow）是计时器溢出的时候，表示的是计时器中断标志位，和上述的IE是一样的，溢出的时候就是为1，都是由硬件完成的，平时没有什么用，我猜正是因为这些硬件标志位，才让程序执行中断函数的。
SCON（serial control）串口控制器，串口控制器和计时器一样，都是有自己独立的控制器。
其中的SM0 和 SM1表示的是四种串口的工作方式，以及对应的波特率，在练习中选择的是方式一。REN（receive enable）表示的是让串口能够收到消息。TI和RI都是串口中断的标志位，这个一般是进入串口中断的时候，用来判断究竟是收到满了中断，还是发送满了中断了。其余的控制位就不用管了。
PCON（power control）电源控制器。
这个寄存器的使用有限，通常是和SCON配合使用，其中的SMOD和SMOD0两个的用法是不一样的。
当SMOD0（B6位） = 0的时候，SCON中的SM0才是选择工作模式使用的，为1的时候，是其他用处。
同时SMOD也是SCON中公式的指数，我们一般选择为0，所以在串口中断的时候，PCON = 0的。
总结一下需要的调整的寄存器：外部中断需要调整两个寄存器就好了，定时器的话，需要调整三个寄存器以及初值，IE,TCON（两个变量）,TMOD三个寄存器以及TL和TH的初值，前两个是控制寄存器，TMOD是选择定时器的模式使用的，GATE控制位看样子是和外部中断配合，做延时使用的，C/非T是用来切换定时器和计数器的，定时器是使用内部的时钟计时，计数器顾名思义就是用来计数的，这个是需要连接外部的引脚来将是否计数传进来的。串口中断的话，需要IE，需要SCON,PCON，TCON（一个变量），还需要TMOD，也需要调整TH和TL的值，不过这个过程可能在PCON设置波特率的时候就已经确定了TH的值了。IE是用来打开全部中断和串口中断的（不打开定时器中断），SCON是用来调整串口中断控制位的，PCON是用来调整波特率的，TMOD用来调整计时器模式的，其中需要TCON是用来激活TR1的，没有这个控制位的话定时器是不能跑的，值得一提的是，这个是不需要开启定时器中断的，而且串口中断的话占用的一定是定时器1。所以后续更改的是定时器1里面的数值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d16f2e65e6e2e87118b6409fb8e045/" rel="bookmark">
			使用pyqt5&#43;qtdesign设计模仿网易云音乐客户端界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例效果图 设计界面效果图：
运行效果图：
本项目目前只是对界面进行了设计，功能都没有进行完善，想完善的小伙伴自己拿到UI文件之后，自己完善即可。
简要设计思路说明 使用QFrame将界面分割布局成如下几个部分：
一些图案+文字的按钮直接用QPushButton即可，按钮是可以添加图案的，例如：
中间的右边展示内容的部分，可以使用QStackedWidget进行设计，方便点击按钮时，对界面进行切换，如图：
下方的进度条使用QProgressBar进行设计即可，自己改变长宽和颜色即可。
总结 图标都是在iconfont获取的，大家自己去下载即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7344f8fa279c279e1254625e22de12a/" rel="bookmark">
			ubuntu 20.04 自由切换 python 的版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 当前 ubuntu 20.04 默认安装了多个 python 的版本，执行 python 时，默认版本是 Python 2.7.18 zhangsz@zhangsz:~$ python Python 2.7.18 (default, Jul 1 2022, 12:27:04) [GCC 9.4.0] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; 如何更改切换 python 对应的 python 版本，比如 执行 python 时 打开的是 Python 3.8.10
为何需要切换 python 对应的版本，就是有的应用，比如 repo 必须 使用 Python 3.x 的版本，而有的 sdk 编译系统 就使用 python 2.x 的版本，造成需要 python 对于的版本在 python 2.x 与 python 3.x 之间自由切换，而不是 安装卸载操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7344f8fa279c279e1254625e22de12a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e193f571ac70ad3c6e361070bcb3724/" rel="bookmark">
			对房价数据集进行处理和数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是带我去滑雪，每天教你一个小技巧！
房价数据集通常包含各种各样的特征，如房屋面积、地理位置、建造年份等。通过对数据进行处理和分析，可以更好地理解这些特征之间的关系，以及它们对房价的影响程度。这有助于确定哪些特征是最重要的，从而更有针对性地制定房地产策略。本次使用波士顿房价数据集boston_housing_data.csv，该数据集有城镇人均犯罪率（CRIM）、住宅用地所占比例（ZN）、城镇中非住宅用地所占比例（INDUS）等共计13个特征变量，响应变量为社区房价中位数（MEDV）。实现对房价数据进行可视化和统计分析：如绘制直方图、密度图、箱线图以及查看各个散点图的分布，最后使用支持向量机和KNN等几种机器学习方法进行学习。下面开始实战。
（1）导入相关模块 import numpy as np import pandas as pd import matplotlib.pyplot as plt from sklearn.model_selection import train_test_split from numpy import arange from matplotlib import pyplot from pandas import read_csv from pandas import set_option from pandas.plotting import scatter_matrix from sklearn.preprocessing import StandardScaler from sklearn.model_selection import train_test_split from sklearn.model_selection import KFold from sklearn.model_selection import cross_val_predict from sklearn.model_selection import cross_val_score from sklearn.model_selection import GridSearchCV from sklearn.linear_model import LinearRegression from sklearn.linear_model import Lasso from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e193f571ac70ad3c6e361070bcb3724/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31f611ebda63c4890fbd1ebf4190e915/" rel="bookmark">
			redisson作为分布式锁的底层实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. redisson如何实现尝试获取锁的逻辑 如何实现在一段的时间内不断的尝试获取锁 其实就是搞了个while循环，不断的去尝试获取锁资源。但是因为latch的存在会在给定的时间内处于休眠状态。这个事件，监听的是解锁动作，如果解锁动作发生。会调用latch.release方法，这样while循环又可以重新启动，去尝试获取锁资源了。（相比单纯的轮训，避免了对cpu资源的浪费。通过信号通知，避免了没必要的轮训）尝试获取锁的过程是怎样的？ 使用了redis脚本执行的方式。因为存在根据查询结果，来决定执行什么变更动作。所以一定要保证动作串行执行。如果key不存，则新增key和param（线程id+redisClientid）记录，value为数值型，value=1。 如果，key + param存在，则表名key已被默认线程持有，并且这个线程就是当前线程。如果，key + param不存在，则表明key已被默认线程持有，并且这个线程不是当前线程。 2. redisson释放锁的逻辑如何实现 因为加锁时，会设置过期时间。所以就算不主动解锁。key过期了就相当于解锁了。
redisson的解锁过程如下图。先判断线程是否持有该锁。如果有，则value值减1。然后判断value是否大于0，如果大于0，则给key设置一个默认的过期时间30秒；如果等于0，则可以删除key和发布一个key删除事件。
3. redisson释放锁时，如何唤起其它线程取争抢锁 4. redisson如何解决A线程加锁，但是B线程去释放锁的问题 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dfcfee513f927eb6ceb464cd2c0b4d8/" rel="bookmark">
			阶段十-分布式-docker虚拟化容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 Docker简介 1.2 节 Docker理念 Docker是基于Go语言实现的云开源项目；通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。
1.3 节 Docker概念 Docker 是一个开源的应用容器引擎，基于go语言并遵从apache2协议开源。
Docker可以让开发者打包他们的应用以及依赖包到一个轻量级，可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。
1.4 节 Docker的三要素和架构图 Docker的三要素：镜像、容器、仓库
镜像：Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。
容器：
Docker 利用容器（Container）独立运行的一个或一组应用。容器是用镜像创建的运行实例。
它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。
可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。
容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。
仓库：
仓库（Repository）是集中存放镜像文件的场所也是下载镜像的地方。
仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。
仓库分为公开仓库（Public）和私有仓库（Private）两种形式。
最大的公开仓库是 Docker Hub(https://hub.docker.com/)，
Docker
存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云 等
第二章 Centos7上安装docker 2.1 节 卸载（可选） 如果之前安装过旧版本的Docker，可以使用下面命令卸载：
yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine \ docker-ce 2.2 节 安装docker 1）首先需要大家虚拟机联网，安装yum工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dfcfee513f927eb6ceb464cd2c0b4d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b27890263452398359b0914f5e3d1681/" rel="bookmark">
			2024年金融变革RWA的7大展望
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：Sanjay@Roofstock onChain的副总裁
编译：秦晋 碳链价值
稳定币、代币化国债、去中心化私人信贷、实物支持的NFTs、气候和再生金融DeFi - 这些只是未来一年将重塑资本市场的部分趋势。
在不断变化的金融格局中，过去两年给我们带来了一系列独特的挑战。其中最主要的是美国的通货膨胀--2022年6月达到惊人的9.1%，这促使美联储实施了一系列激进的加息措施（目前仍在继续）。
与此同时，加密货币行业也经历了自己的风暴，Terra/Luna、Celsius、Voyager和FTX 等大型项目以及Silvergate、Signature和硅谷银行（Silicon Valley Bank）等银行纷纷倒下。
在这场动荡中，区块链建设者们继续奋力前行，现实世界资产（RWA）领域成为创新和弹性的灯塔。从本质上来说，真实世界资产代币化的核心是在区块链上创建一种投资工具，这种工具与房地产或汽车等有形资产或其他任何可能以实物形式存在的东西相关联。一旦所有权被记录在区块链上，资产就可以交易、分割或安全持有。
进入2024 年，以下七大RWA展望将重塑金融格局：
1. 稳定币：可编程货币的基石
随着联邦监管的迫近，稳定币--可编程货币的缩影--正处于变革性增长的边缘，从根本上改变了我们对货币的看法。在美国，有两家发行商在这一领域占据主导地位--Circle（作为多链解决方案发行USDC）和Paxos（提供Paypal的PYUSD等标记解决方案，如）。在全球范围内，稳定币的市值约为1250亿美元，并形成为价值互联网提供动力的基础架构层。稳定币具有稳定性和灵活性，将彻底改变全球支付、汇款、电子商务、贸易金融等领域。
2. 代币化国债：传统金融与去中心化金融的桥梁
代币化国债体现了传统金融和去中心化金融的真正融合。随着无风险短期国债收益率从2022年初的接近于零上升到2023年10月的约5.4%，富兰克林邓普顿、Ondo、Backed、Maple、Open Eden和Superstate等公司率先将短期美国国债和银行存款代币化。根据数据代币和分析平台RWA.xyz的数据，这一新资产类别目前拥有7亿美元的市值。代币化国债正在打破壁垒，为投资和金融包容性提供新的途径。
3. 私人信贷：通过 DeFi 为中小企业赋能
美国私人信贷市场价值1万亿美元，全球私人信贷市场价值1.7万亿美元，但长期以来，中小型企业一直未能进入这一市场。Centrifuge、Goldfinch、Credit、Maple、Huma等 DeFi 借贷协议正在改变游戏规则，打开了从公共市场、银行系统和传统私人信贷发放机构获得债务资本的闸门。
私人信贷发起人。RWA.xyz 专注于特定行业或地域，目前估计该市场约有5.5亿美元的活跃贷款，未来几个月仍将保持增长势头。
4.NFT：彻底变革藏品融资模式
全球每年的艺术品销售额超过650亿美元（仅美国就有300亿美元），不难看出艺术品中蕴藏着巨大商机。但是，传统艺术品和收藏品市场缺乏流动性，而且费用高昂（拍卖行通常会对小件商品加收15-20% 费用）。据估计，全球收藏品市场（钱币、邮票、书籍、漫画、艺术品、玩具等）的规模约为4000亿美元，同样缺乏流动性。像eBay这样的市场平台和一些较小的定制市场迎合了这一行业的需求，而借贷方式一般仅限于利率较高的典当行。
幸运的是，4K和arcade.xyz等去中心化协议正在改变这一模式。通过将实物收藏品带入区块链，针对Supreme T-Shirts和漫画书等资产的借贷已成为现实。这些举措使借贷民主化，让全世界的收藏者都能获得借贷。
5. 消费品牌NFT：提升客户参与度
包括耐克（Nike）、阿迪达斯（Adidas）、路易威登（Louis Vuitton）和可口可乐（Coca-Cola）等在内的领先消费品牌都在拥抱NFT。从 Polygon上的星巴克到传言中亚马逊的私有区块链的努力，大品牌正在利用区块链来增强数字足迹、客户参与和娱乐体验。无论是在公共区块链（Polygon上的星巴克）还是私人区块链（围绕亚马逊传闻）上，通过融入游戏和元宇宙元素，这些品牌正在塑造消费者互动的未来。
6. 气候和再生金融领域DeFi
在环境、社会和治理（ESG）问题日益受到关注情况下，区块链技术正在推动价值20亿美元且不断增长的碳市场发生积极变化。Flowcarbon等公司正在利用区块链的潜力来提高这一重要市场的透明度，要实现《巴黎协定》的目标，到2030年这一市场必须实现15倍增长。区块链在碳生命周期每个阶段的准确性和透明度对于促进可持续发展的未来不可或缺。
7. 代币化存款和批发银行结算：彻底改变跨境交易
区块链技术正在重塑银行处理代币化存款和批发结算的方式。虽然在美国，中央银行数字货币（CBDC）可能不是一个急需解决的问题，特别是如果私人发行商可以在联邦或州一级受到监管，但一些银行正在对代币化存款和银行内部或银行间批发结算进行区块链技术试验。花旗银行和摩根大通银行等行业巨头的试点证明了即时跨境交易的潜力。未来几个月，这一领域将继续扩大，从而提高全球金融的效率。
这些RWA趋势预示着一个新的金融时代的到来，为长期存在的挑战提供了解决方案。虽然它们的市值现在看起来可能不大，但其变革潜力是不可估量的。稳定币、代币化国库、去中心化私人信贷、实物支持的无形资产、消费者品牌无形资产、气候和再生金融领域的DeFi 以及代币化存款/批发银行结算不仅仅是趋势，它们还是一个更加包容、高效和可持续的金融未来的基石。在2024年，这些创新无疑将引领潮流，为企业和个人带来无与伦比的机遇。
推荐阅读：
历史罚单
最大牛市
AI货币
元宇宙
暗流涌动
&lt; END &gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e62420bb8a4defc87a5ec07329799f9/" rel="bookmark">
			0101包冲突导致安装docker失败-docker-云原生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 前言2 报错3 解决结语 1 前言 最近在学习k8s，前置条件就是要安装指定版本的docker，命令如下
yum install -y docker-ce-20.10.7 docker-ce-cli-20.10.7 containerd.io-1.4.6 2 报错 file /usr/libexec/docker/cli-plugins/docker-buildx from install of docker-ce-cli-1:20.10.7-3.el7.x86_64 conflicts with file from package docker-buildx-plugin-0:0.11.2-1.el7.x86_64 释义：从包docker-ce-cli安装的文件与包docker-buildx-plugin冲突 3 解决 明确那个包是你需要的？这里我需要docker-ce-cli
docker-buildx-plugin这个包可能是以前安装留下 移除不需要的安装包
yum -y remove docker-buildx-plugin 重新安装成功
结语 ❓QQ:806797785
⭐️
参考：
[1]云原生视频地址[CP/OL].
[2]docker安装报错[CP/OL].
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a985f5ff573be1c04a2a1518d37b96dc/" rel="bookmark">
			文件内容采集-go
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求背景 1、多个线程写文件，并且在达到文件大小限制时进行文件绕接，但是绕接文件不压缩
2、另起一个线程对文件内容进行采集，然后将内容统一归档到指定路径
写文件客户端
package collectFile import ( "bufio" "fmt" "os" "path/filepath" "strconv" "time" ) func WriteClientRun() { serviceNamePrefix := "svc-" for i := 0; i &lt; 10; i++ { go writeFile(serviceNamePrefix + strconv.Itoa(i)) } } func writeFile(serviceName string) { for { doWriteFile(serviceName) } } func doWriteFile(serviceName string) { dirPath := filepath.Join("D:\\tmp\\alarm_log", serviceName, BaseParent) _, dirStatErr := os.Stat(dirPath) if os.IsNotExist(dirStatErr) { dirCreateStatErr := os.MkdirAll(dirPath, 0777) if dirCreateStatErr != nil { fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a985f5ff573be1c04a2a1518d37b96dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58d775001d847768917ce33269d67455/" rel="bookmark">
			matlab概率论例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高斯概率模型： [f,xi] = ksdensity(x): returns a probability density estimate, f, for the sample in the vector x. The estimate is based on a normal kernel function, and is evaluated at 100 equally spaced points, xi, that cover the range of the data in x. 代码：
&gt;&gt; %Give a random sample x=[2*randn(6000,1); 5+randn(4000,1)]; %Calculate the probability density of each point [f,xi]=ksdensity(x); %plot subplot(211); plot(x); title('Sample Data') subplot(212); plot(xi,f); title('PDF'); &gt;&gt; 图形：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58d775001d847768917ce33269d67455/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ba84b406f1455922edbeae3a4be663/" rel="bookmark">
			Nginx配置限流，技能拉满！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		戳上方蓝字“Java知音”关注我
1概述 限流（Rate Limitting）是服务降级的一种方式，通过限制系统的输入和输出流量以达到保护系统的目的。
比如我们的网站暴露在公网环境中，除了用户的正常访问，网络爬虫、恶意攻击或者大促等突发流量都可能都会对系统造成压力，如果这种压力超出了服务器的处理能力，会造成响应过慢甚至系统崩溃的问题。
因此，当并发请求数过大时，我们通过限制一部分请求（比如限制同一IP的频繁请求）来保证服务器可以正确响应另一部分的请求。
nginx 提供了两种限流方式，一种是限制请求速率，一种是限制连接数量。
另外还提供了对下载/上传速度的限制。
2限制请求速率 nginx 的 ngx_http_limit_req_module 模块提供限制请求处理速率的能力，使用了漏桶算法（leaky bucket algorithm）。我们可以想像有一只上面进水、下面匀速出水的桶，如果桶里面有水，那刚进去的水就要存在桶里等下面的水流完之后才会流出，如果进水的速度大于水流出的速度，桶里的水就会满，这时水就不会进到桶里，而是直接从桶的上面溢出。
对应到处理网络请求，水代表从客户端来的请求，而桶代表一个队列，请求在该队列中依据先进先出（FIFO）算法等待被处理。漏的水代表请求离开缓冲区并被服务器处理，溢出代表了请求被丢弃并且永不被服务。
2.1、正常限流 nginx 中有两个主要的指令可以用来配置限流：limit_req_zone 和 limit_req。
下面是一个最简单的限流的例子：
limit_req_zone $binary_remote_addr zone=test:10m rate=2r/s; server { location / { limit_req zone=test; } } imit_req_zone 用于设置限流和共享内存区域的参数，格式为：limit_req_zone key zone rate。
key： 定义限流对象，$binary_remote_addr 是 nginx 中的变量，表示基于 remote_addr(客户端IP) 来做限流，binary_ 是二进制存储。使用 $binary_remote_addr 而不是 $remote_addr 是因为二进制存储可以压缩内存占用量。$remote_addr 变量的大小从7到15个字节不等，而 $binary_remote_addr变量的大小对于 IPv4 始终为4个字节，对于 IPv6 地址则为16个字节。
zone： 定义共享内存区来存储访问信息，访问信息包括每个 IP 地址状态和访问受限请求 URL 的频率等。zone 的定义又分为两个部分：由 zone= 关键字标识的区域名称，以及冒号后面的区域大小。test:10m 表示一个大小为10M，名字为 test 的内存区域。1M 能存储16000个 IP 地址的访问信息，test 大概可以存储约160000个地址。nginx 创建新记录的时候，会移除前60秒内没有被使用的记录，如果释放的空间还是存储不了新的记录，会返回503的状态码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7ba84b406f1455922edbeae3a4be663/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/323325f3ed0d6ebd09fc371c6f2e4f1b/" rel="bookmark">
			阶段十-分布式-nginx服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Nginx简介 Nginx 是高性能的 HTTP 和反向代理的服务器，处理高并发能力是十分强大的，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数。tomcat并发数量理论值是500，实际也就300左右。
1.2 正向代理 正向代理代理的是客户端，帮客户端发送请求给目标服务器，服务器响应后，由代理服务器将响应内容返回给客户端。使客户端对目标服务器不可见。比较常见的用户场景就是翻墙。
1.3 反向代理 反向代理在生产中应用还是比较多的，代理服务器代理目标服务器，负责收发请求，目标服务器对客户端来说是不可见的，不过客户端请求目标服务器和请求代理是一样的效果。比较常见的场景就是nginx的负载均衡
1.4 负载均衡 增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡。
1.5 动静分离 将网站的动态资源和静态资源分别部署到不同的服务器，并由nginx统一调用。
二、Nginx安装 【1】安装pcre依赖
1.下载压缩包：wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz
2.解压压缩包：tar -xvf pcre-8.37.tar.gz
3.安装gcc：yum install gcc
4.安装gcc：yum install -y gcc gcc-c++
5.在pcre-8.37目录输入：./configure 6.在pcre-8.37目录输入：make &amp;&amp; make install
【2】安装 openssl 、zlib 、 gcc 依赖
yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel
【3】安装nginx
1.将nginx压缩包上传到usr/local目录下
2.解压到当前目录：tar -xvf nginx-1.12.2.tar.gz
3.进入nginx-1.12.2目录输入：./configure
4.进入nginx-1.12.2目录输入：make &amp;&amp; make install
【4】启动nginx
1.进入sbin目录：cd /usr/local/nginx/sbin
2.启动服务：./nginx 【5】关闭防火墙
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/323325f3ed0d6ebd09fc371c6f2e4f1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0346ba96cba3eb09748577989f82cf9/" rel="bookmark">
			C&#43;&#43; 侯捷 内存管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 的内存获取机制：
void* p1 = malloc(512); free(p1); complex&lt;int&gt;* p2 = new complex&lt;int&gt;; delete p2; void* p3 = ::operator new(512); ::operator delete(p3); //GNUC void* p4 = alloc::allocate(512); alloc::deallocate(p4, 512); //GNUC4.9 void* p5 = allocator&lt;int&gt;().allocate(7); //分配7个int allocator&lt;int&gt;().deallocate((int*)p5, 7); 表达式 new delete new的步骤：
申请一段指定类大小的空间：new —&gt; operator new —&gt; malloc转化为对应类类型调用类构造函数 在operator new的源码中，有个std::nothrow_t&amp; _THROW0()参数，表示这个函数不抛异常，取而代之的是返回一个空指针，用户通过判断是否为空指针来判断是否分配成功。
array new、array delete array new是分配一个对象数组，通常容易犯得一个错误是在delete的时候忘记在delete后面加[]导致内存泄漏的问题。
replacement new 允许我们将对象分配在已经构建的内存中
他不会进行内存分配，而是调用重载的operator new，用于返回已经分配好的内存，转型、调用构造函数。
#include&lt;new&gt; char* buf = new char[sizeof(Complex)* 3]; Complex* pc = new(buf) Complex(1, 2); // replacement new!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0346ba96cba3eb09748577989f82cf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3d87e47a9be79da1b7445209ff5331d/" rel="bookmark">
			Collections工具类整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//int[]转List&lt;Integer&gt;: //使用Arrays.stream(ints).boxed().collect(Collectors.toList()); //排序:Collections.sort, 没有返回值；默认是顺序排序。 //翻转:Collections.reverse, 没有返回值； //交换元素:Collections.swap, 没有返回值； Collections.sort底层使用的排序算法 基本数据类型的封装类：双轴快速排序。双轴快速排序是对经典快速排序的改进，它利用两个轴点（即两个基准元素）将数组划分为三个部分：小于第一个轴点、介于两个轴点之间和大于第二个轴点
其它的对象类型：优化后的归并排序（TimSort）算法。【算法】排序算法之归并排序 - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c1fdd845715465bede0089e3956b1b1/" rel="bookmark">
			R语言【CoordinateCleaner】——cc_gbif(): 根据通过 method 参数定义的方法，删除或标记地理空间中异常值的记录。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cc_gbif()是R语言包coordinatecleaner中的一个函数，用于清理GBIF（全球生物多样性信息设施）数据集的地理坐标。该函数可以识别潜在的坐标错误，并对其进行修正或删除。
以下是cc_gbifl()函数的一般用法和主要参数：
cc_gbif(data, species = NULL, geometry = c("point", "polygon"), geometry_column = NULL, latitude_column = "decimalLatitude", longitude_column = "decimalLongitude", coordinate_precision_column = NULL, bounding_box = NULL, geographic_extent = NULL, keep_records_without_coordinates = TRUE) 参数说明：
data: 输入的数据框或数据表，包含GBIF数据集。species: 可选参数，用于筛选特定物种的观测记录。默认为NULL，表示使用所有物种的记录。geometry: 指定数据集的几何类型，可以是"point"（点）或"polygon"（多边形）。如果数据集是点集，则几何类型应设置为"point"。如果数据集是多边形（如网格区域），则几何类型应设置为"polygon"。默认为"point"。geometry_column: 数据集中存储几何信息的列名。默认为NULL，表示函数将自动检测列名。latitude_column: 纬度信息所在的列名，默认为"decimalLatitude"。longitude_column: 经度信息所在的列名，默认为"decimalLongitude"。coordinate_precision_column: 坐标精度信息所在的列名，用于检测坐标错误。默认为NULL，表示不使用该列进行错误检测。bounding_box: 可选参数，指定限制数据集的边界框（经度范围和纬度范围）。默认为NULL，表示不限制边界框。geographic_extent: 可选参数，指定限制数据集的地理范围（国家、大陆等）。默认为NULL，表示不限制地理范围。keep_records_without_coordinates: 一个逻辑值，表示是否保留没有坐标信息的记录。默认为TRUE，即保留这些记录。 函数功能：
cc_gbif()函数用于对GBIF数据集进行清理和修正，以消除潜在的坐标错误。它可以识别并修复以下类型的坐标问题：
重复的坐标：如果数据集中存在相同的坐标点，函数会将其合并为一个唯一的坐标点。空白坐标：如果数据集中存在缺失的坐标点，函数会删除这些记录。错误的坐标范围：函数会通过比较坐标点与世界各地的实际范围进行验证，并删除超出范围的记录。错误的坐标精度：如果提供了坐标精度信息（通过coordinate_precision_column参数），函数会根据精度信息检测可能的坐标错误，并进行修正或删除。 cc_gbif()函数是R语言包coordinatecleaner中的一个功能强大的函数，用于清理GBIF数据集中的地理坐标。它可以识别并修复重复的坐标点、空白的坐标点以及超出范围的坐标记录。此外，该函数还可以利用提供的坐标精度信息来检测可能的坐标错误，并进行修正或删除。
使用cc_gbif()函数时，用户可以通过指定特定物种的观测记录、几何类型（点或多边形）、存储几何信息的列名等参数来定制化处理。还可以选择限制数据集的边界框或地理范围。函数还提供了一个选项，决定是否保留没有坐标信息的记录。
通过使用cc_gbif()函数，用户可以有效地清理和纠正GBIF数据集中的地理坐标，提高数据的质量和准确性。这对于生物多样性研究、生态分析和地理信息系统应用都非常有价值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17764866a21bff6b111a295117950324/" rel="bookmark">
			AWS CDK安装到AWS EC2 Linux 2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 小结问题及解决安装NPM安装aws-cdk-lib找不到Python3 测试参考 小结 AWS CDK安装到AWS EC2 Linux 2，并记录过程。
问题及解决 安装NPM [ec2-user@ip-100-92-28-119 aws]$ sudo yum install npm Loaded plugins: priorities, update-motd, upgrade-helper amzn2-core | 3.6 kB 00:00:00 amzn2extra-ecs | 2.9 kB 00:00:00 amzn2extra-epel | 3.0 kB 00:00:00 amzn2extra-mate-desktop1.x | 3.0 kB 00:00:00 amzn2extra-python3.8 | 2.9 kB 00:00:00 epel/x86_64/metalink | 4.9 kB 00:00:00 epel | 4.7 kB 00:00:00 (1/2): epel/x86_64/updateinfo | 1.0 MB 00:00:00 (2/2): epel/x86_64/primary_db | 7.0 MB 00:00:00 311 packages excluded due to repository priority protections Resolving Dependencies --&gt; Running transaction check ---&gt; Package npm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17764866a21bff6b111a295117950324/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/4/">«</a>
	<span class="pagination__item pagination__item--current">5/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/6/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>