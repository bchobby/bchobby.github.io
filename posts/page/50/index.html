<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b19ca22951f2a8e5581a8dced2138d1/" rel="bookmark">
			使用Python编写一个多线程的12306抢票程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国庆长假即将到来，大家纷纷计划着自己的旅行行程。然而，对于很多人来说，抢购火车票人们成了一个令人头疼的问题。12306网站的服务器经常因为流量高而崩溃，导致抢票变得越来越严重异常困难。
首先，让我们来了解一下12306抢票的难点。由于很多人都在同一时间段内访问12306网站，服务器的负载率非常高，导致网站响应变慢甚至崩溃。这使得抢票变得异常困难，因为您需要在短时间内提交请求并获取票务信息。
Python可以支持多线程访问，所以为了解决这个问题，我们可以使用多线程编程的技术。多线程允许我们同时执行多个任务，从而提高程序的效率。在这个案例中，我们可以使用多线程来同时发送多个请求给12306网站，从而增加我们抢票的成功率。但是12306抢票的难点还在于网站的反抢措施。为了杜绝恶意抢票行为，12306网站采取了多种反抢技术，如验证码、IP封禁等。这使得抢票变得更加困难，因为我们需要采取行动这些反爬措施才能成功抢到票。
首先，我们需要编写一个起始页解析函数，用于获取12306网站的起始页信息。在这个函数中，我们可以使用Python的requests库发送HTTP请求，并使用代理IP来隐藏真实IP地址，减少被封禁的风险。下面是一个示例代码：
import requests def parse_start_page(): proxyHost = "u6205.5.tp.16yun.cn" proxyPort = "5445" proxyUser = "16QMSOML" proxyPass = "280651" proxies = { "http": f"http://{proxyUser}:{proxyPass}@{proxyHost}:{proxyPort}", "https": f"http://{proxyUser}:{proxyPass}@{proxyHost}:{proxyPort}" } url = "https://12306.com/start_page" response = requests.get(url, proxies=proxies) if response.status_code == 200: # 解析起始页信息 start_page_data = response.text # 进一步处理起始页数据 ... else: print("无法访问起始页") parse_start_page() 然后设置请求头信息：在发送HTTP请求时，设置合适的User-Agent和Referer等请求头信息，模拟正常的浏览器行为。下面是一个示例代码
import requests headers = { "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b19ca22951f2a8e5581a8dced2138d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ab79b1b63cb1ef231f1342975f8cb7/" rel="bookmark">
			vue vue-devtools调试工具神器安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 vue vue-devtools调试工具神器安装 前言chrome商店直接安装手动安装 第一步：找到vue-devtools的github项目，并将其clone到本地. vue-devtools第二步：安装项目所需要的npm包第三步：编译项目文件第四步：添加至chrome游览器vue-devtools如何使用文章转自 vue vue-devtools调试工具神器安装 前言 vue-devtools是一款基于chrome游览器的插件，用于调试vue应用，这可以极大地提高我们的调试效率。接下来我们就介绍一下vue-devtools的安装。
chrome商店直接安装 vue-devtools可以从chrome商店直接下载安装，非常简单，这里就不过多介绍了。不过要注意的一点就是，需要FQ才能下载。
手动安装 第一步：找到vue-devtools的github项目，并将其clone到本地. vue-devtools git clone https://github.com/vuejs/vue-devtools.git 第二步：安装项目所需要的npm包 npm install //如果太慢的话，可以安装一个cnpm, 然后命令换成 cnpm install 第三步：编译项目文件 npm run build 第四步：添加至chrome游览器 游览器输入地址“chrome://extensions/”进入扩展程序页面，点击“加载已解压的扩展程序...”按钮，选择vue-devtools&gt;shells下的chrome文件夹。 /** *如果看不见“加载已解压的扩展程序...”按钮，则需要勾选“开发者模式”。 */ 我这里把编译过的文件上传了百度云，后续步骤依旧，并且还附上了一个.crx文件，在chrome拓展程序页面上把文件拖进去即可安装。若百度云失效可文章下留言，我看到后会重新生成链接。
链接:https://pan.baidu.com/s/139hspAnspD7bJbo81xigmg 密码:1hsv 如果百度链接失效，再试试下面这个
链接：https://pan.baidu.com/s/1hCovWs-8ftBpVypNvKpD1g 提取码：blal vue-devtools如何使用 当我们添加完vue-devtools扩展程序之后，我们在调试vue应用的时候，chrome开发者工具中会看一个vue的一栏，点击之后就可以看见当前页面vue对象的一些信息。vue-devtools使用起来还是比较简单的，上手非常的容易，这里就细讲其使用说明了。
非常好用的调试工具，有了它我们就可以更好的学习Vue了！！！
文章转自 https://www.jianshu.com/p/63f09651724c
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0a4bacd08af0e20739d30c81d923a5c/" rel="bookmark">
			学习到的一种解决github网站打不开的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 gitHub网站打不开！
解决方案： 首先，按住电脑的Win+R键输入文件路径C:\Windows\System32\drivers\etc点击确认：
出现了以下文件夹：
复制hosts文件至桌面。
再按住电脑的Win+R键输入cmd点击确定：
输入ping github.com命令，点击回车：
可以用记事本的方式打开桌面的hosts文件，新加一行记录，即刚查出的ip地址，并保存：
将桌面修改后的hosts文件复制到原来的文件夹中并替换掉原文件：
然后(以谷歌浏览器为例)打开谷歌浏览器访问chrome://net-internals/#hsts，在Query HSTS/PKP domain这里输入github.com点击查询：
（微软浏览器访问edge://net-internals/#hsts）
（查询HSTS/PKP域 输入域名查询当前HSTS/PKP设置 不懂）
在Delete domain security policies这里输入github.com点击删除：
（删除域安全策略 输入域名，删除动态HSTS策略(不能删除预加载的条目) 不懂）
最后重新访问github.com的官网：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97c7cbea765aa00d25244d597c226294/" rel="bookmark">
			Kubernetes 使用configmap挂载卷给Pod内的nginx容器，并且实现nginx的代理服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
实验：使用configmap挂载卷给Pod内的nginx容器
1、创建nginx.conf配置文件（必须由nginx镜像里的nginx.conf修改而来，防止出现配置不相似的情况出现，导致访问不了nginx网页）
2、通过nginx.conf文件创建configmap容器（注意nginx.conf文件必须在该目录下）
3、查看创建的configmap和它的详细资料
4、根据configmap创建nginx-deployment.yaml文件
5、运行nginx-deployment.yaml，创建Pod
6、创建Service发布nginx容器服务，创建nginx-service.yaml文件
7、运行nginx-service.yaml，创建Pod
8、验证访问
实验：使用Configmap将nginx容器变为代理服务器，使集群内访问集群外边的资源通过nginx tcp代理。
1、使用nginx-config.yaml文件创建Configmap
2、搭建nginx容器，调用Configmap更新nginx的配置文件（添加入网口的标签）：
3、运行 nginx-deployment2.yaml，搭建Pod
4、运行 nginx-service2.yaml，搭建Service服务
5、运行nginx-service2.yaml 和 nginx-service3.yaml， 搭建Service服务
6、验证访问：
实验：使用configmap挂载卷给Pod内的nginx容器 1、创建nginx.conf配置文件（必须由nginx镜像里的nginx.conf修改而来，防止出现配置不相似的情况出现，导致访问不了nginx网页） (base) root@sd-cluster-04:/etc/nginx# cat nginx.conf # claylpf test user nginx; worker_processes auto; error_log /var/log/nginx/error.log notice; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97c7cbea765aa00d25244d597c226294/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac05984a7626522985a3e894d5992ac8/" rel="bookmark">
			Spring JPA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.Spring data jpa 简介 首先我并不推荐使用jpa作为ORM框架,毕竟对于负责查询的时候还是不太灵活,还是建议使用mybatis,自己写sql比较好.但是如果公司用这个就没办法了,可以学习一下,对于简单查询还是非常好用的.
首先JPA是Java持久层API,由Sun公司开发, 希望整合ORM技术，实现天下归一. 诞生的缘由是为了整合第三方ORM框架，建立一种标准的方式，目前也是在按照这个方向发展，但是还没能完全实现。在ORM框架中，Hibernate是一支很大的部队，使用很广泛，也很方便，能力也很强，同时Hibernate也是和JPA整合的比较良好，我们可以认为JPA是标准，事实上也是，JPA几乎都是接口，实现都是Hibernate在做，宏观上面看，在JPA的统一之下Hibernate很良好的运行。
Spring-data-jpa，Spring与jpa的整合
Spring主要是在做第三方工具的整合 不重新造轮子. 而在与第三方整合这方面，Spring做了持久化这一块的工作，于是就有了Spring-data-**这一系列包。包括，Spring-data-jpa,Spring-data-template,Spring-data-mongodb,Spring-data-redis
Spring-data-jpa，目的少使用sql
我们都知道，在使用持久化工具的时候，一般都有一个对象来操作数据库，在原生的Hibernate中叫做Session，在JPA中叫做EntityManager，在MyBatis中叫做SqlSession，通过这个对象来操作数据库。我们一般按照三层结构来看的话，Service层做业务逻辑处理，Dao层和数据库打交道，在Dao中，就存在着上面的对象。那么ORM框架本身提供的功能有什么呢？答案是基本的CRUD(增删改查)，所有的基础CRUD框架都提供，我们使用起来感觉很方便，很给力，业务逻辑层面的处理ORM是没有提供的，如果使用原生的框架，业务逻辑代码我们一般会自定义，会自己去写SQL语句，然后执行。在这个时候，Spring-data-jpa的威力就体现出来了，ORM提供的能力他都提供，ORM框架没有提供的业务逻辑功能Spring-data-jpa也提供，全方位的解决用户的需求。使用Spring-data-jpa进行开发的过程中，常用的功能，我们几乎不需要写一条sql语句，至少在我看来，企业级应用基本上可以不用写任何一条sql，当然spring-data-jpa也提供自己写sql的方式
返回值为对象的意义
是jpa查询表内容返回值基本上都是对象,但是仅仅需要一个字段返回整体对象不是会有很多数据冗余吗,其实大多数情况对一个数据表的查询不可能只有一次或者说这个表不仅仅是这一次会用到,如果我写好一个返回对象的方法,之后都可以直接调用,一般情况下多出一点数据对网络的压力可以忽略不计,而这样对开发效率的提升还是很大的.如果仅仅想得到一部分字段也可以新建一个只有想要字段的Entity.
二.Spring data jpa 基本使用 对于配置方法和基础的dao层写法等不做介绍,基础篇仅当做一个方法字典.
1.核心方法
查询所有数据 findAll() 修改 添加数据 S save(S entity) 分页查询 Page&lt;S&gt; findAll(Example&lt;S&gt; example, Pageable pageable) 根据id查询 findOne() 根据实体类属性查询： findByProperty (type Property); 例如：findByAge(int age) 删除 void delete(T entity) 计数 查询 long count() 或者 根据某个属性的值查询总数 countByAge(int age) 是否存在 boolean existsById(ID primaryKey) 2.查询关键字
-and
And 例如：findByUsernameAndPassword(String user, Striang pwd)；
-or Or 例如：findByUsernameOrAddress(String user, String addr)；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac05984a7626522985a3e894d5992ac8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ddf068cfcda4a42a3f5380cc7485b71/" rel="bookmark">
			Java-坦克攻击（多线程实现子弹）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java-坦克攻击（多线程实现子弹） 实现过程 定义子弹类（Bullet） /** * 子弹类 * @author: SEA * @date: 2023/3/18 */ public class Bullet { //子弹坐标和发射方向 int x; int y; int direction; int speed = 5;//子弹初始速度为 5 public Bullet(int x, int y, int direction) { this.x = x; this.y = y; this.direction = direction; } public int getSpeed() { return speed; } public void setSpeed(int speed) { this.speed = speed; } } 普通坦克类（Tank） 新增属性： （1）子弹对象Bullet； 新增方法： （1）setBullet() 和 getBullet();（2）坦克攻击方法attack()，计算坦克发射出的子弹初始坐标; /** * 坦克 * @author: SEA * @date: 2023/3/2 */ public class Tank{ private int x;//坦克的横坐标 private int y;//坦克的纵坐标 private int direction;//坦克的朝向：0 =&gt; 向上 ，1 =&gt; 向下 ，2 =&gt; 向左 ， 3 =&gt; 向右 private int speed = 5;//坦克速度 private Bullet bullet;//坦克子弹 public Tank(int x, int y) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ddf068cfcda4a42a3f5380cc7485b71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/923239967bf1c8a6c988ea9f1a4783e3/" rel="bookmark">
			Redis 配置文件详解 - 持久化（RDB、AOF）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Redis 配置文件详解
单位
包含 INCLUDES
网络 NETWORK
通用 GENERAL
快照 SNAPSHOTTING （持久化）
复制 REPLICATION（主从复制） 安全 SECURITY（账号密码设置）
​编辑 限制 CLIENTS
追加模式 APPEND ONLY MODE Redis 持久化
RDB ( Redis DataBase )
什么是RDB呢？
触发机制：
如何恢复rdb文件里面的数据：
RDB持久化的优缺点：
AOF ( Append Only File) 什么是AOF呢？ AOF的配置：
测试AOF日志文件的修复：
AOF文件重写规则说明：
AOF持久化的优缺点：
扩展：
Redis 配置文件详解 启动Redis的时候，就通过配置文件来启动
redis-server /usr/local/redis/redis-7.0.11/redis.conf 单位 1、配置文件 unit单位 对大小写不敏感！
包含 INCLUDES 可以导入其他的配置文件，就好比python中导入包import命令一样，只不过是跟c语言导入配置差不多。
网络 NETWORK bind 127.0.0.1 # 绑定的ip（我们可以设定为0.0.0.0，这样外部的机器也能访问我们的redis数据库了） protected-mode yes # 保护模式，目的是保护redis数据库的安全 port 6379 #端口设置，用于发布出去的端口 通用 GENERAL 其中的配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/923239967bf1c8a6c988ea9f1a4783e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe8f296cea028fac482082196c1997ee/" rel="bookmark">
			在SpringBoot项目中整合SpringSession，基于Redis实现对Session的管理和事件监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、SpringSession简介 SpringSession是基于Spring框架的Session管理解决方案。它基于标准的Servlet容器API，提供了Session的分布式管理解决方案，支持把Session存储在多种场景下，比如内存、MongoDB、Redis等，并且能够快速集成到Spring应用程序中。使用SpringSession实现Session管理，可以有效解决Session共享的问题，提升系统的可伸缩性和可靠性。同时，SpringSession还提供了一些扩展，如Spring Session Data Redis、Spring Session JDBC等，可用于与不同的数据源进行集成。
这边博客主要记录了如何在SpringBoot项目中整合SpringSession，并基于Redis实现对Session的管理和事件监听，具体过程如下：
2、整合SpringSession的步骤 2.1、引用SpringSession相关依赖 这里引入了spring-session和Redis的相关依赖，项目其他依赖根据自己的项目按需引入即可。其中spring-session依赖有很多版本（根据Session存储场景区分），这里我们引入spring-session-data-redis即可。
&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2.2、通过Java Config进行配置 这里通过Java实现SpringSession的配置。
EnableRedisHttpSession注解，开启SpringSession的配置，默认加载SpringSession需要的配置内容。其中maxInactiveIntervalInSeconds用来设置Session的过期时间，默认是1800s（30分钟），这里为了方便测试改成了2分钟。引入LettuceConnectionFactory 工厂类，用于配置和管理与Redis服务器连接的，它是Spring Data Redis的一部分。HttpSessionIdResolver 类主要实现SessionId的解析，SpringSession默认的使用的是CookieHttpSessionIdResolver，即基于Cookie解析SessionId，因为项目使用了前后端分离，所以这里改成了http请求头的解析方式，同时修改了请求头的key为“X-Token”，默认值为“X-Auth-Token”。 @Configuration @EnableRedisHttpSession(maxInactiveIntervalInSeconds=60 * 2) public class QriverSpringSessionConfig { @Bean public LettuceConnectionFactory connectionFactory(){ return new LettuceConnectionFactory(); } @Bean public HttpSessionIdResolver sessionIdResolver() { return new HeaderHttpSessionIdResolver("X-Token"); } } 如果之前项目中没有引入Redis，这里还需要增加Redis的相关链接信息，如下所示：
spring: redis: host: 127.0.0.1 port: 6379 ssl: false database: 0 password: 123456 2.3、前端获取token并作为鉴权标识 前端在登录系统成功时，可以通过返回的response 的Headers中解析到Token值，一般会在前端封装的http请求中进行全局处理，如下下图所示:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe8f296cea028fac482082196c1997ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9e3254d9a217be9284c24144e6f7f12/" rel="bookmark">
			Gof23设计模式之状态模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述 【例】通过按钮来控制一个电梯的状态，一个电梯有开门状态，关门状态，停止状态，运行状态。每一种状态改变，都有可能要根据其他状态来更新处理。例如，如果电梯门现在处于运行时状态，就不能进行开门操作，而如果电梯门是停止状态，就可以执行开门操作。
public interface ILift { //电梯的4个状态 //开门状态 public final static int OPENING_STATE = 1; //关门状态 public final static int CLOSING_STATE = 2; //运行状态 public final static int RUNNING_STATE = 3; //停止状态 public final static int STOPPING_STATE = 4; //设置电梯的状态 public void setState(int state); //电梯的动作 public void open(); public void close(); public void run(); public void stop(); } public class Lift implements ILift { private int state; @Override public void setState(int state) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9e3254d9a217be9284c24144e6f7f12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/badb9cd995c52049eca450d228ebf7ee/" rel="bookmark">
			Matlab图像处理-RGB模型在显示系统的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RGB模型在显示系统的应用 RGB模型常用于显示系统。彩色阴极射线管和彩色光栅图形显示器均利用R、G、B数值来驱动R、G、B电子枪发射电子，分别激发荧光屏幕上的R、G、B三色荧光粉末。粉末通过添加和混合发出不同亮度的光并产生各种颜色。 扫描仪通过吸收原稿经反射或透射发出的光中的R、G、B成分，并用它来表现原稿的颜色。 RGB 色彩空间是与设备相关的色彩空间。 因此，不同的扫描仪扫描同一幅图像会得到不同的彩色图像数据：不同型号的显示器显示相同的图像也会有不同的彩色显示结果。
Matlab实现RGB模型 在Matlab中，RGB图像可以表示为 的三维矩阵。每个彩色像素对应于彩色图像中特定空间位置的红、绿、蓝三个分量。组件图像的数据类型决定了它们的取值范围。如果RGB图像的数据类型为double，则每个分量图像的取值范围为[0，1]，如果数据类型为uint8或uint16，则每个分量图像的取值范围分别为[0，255]或[ 0，65535]。
图像合成如果PR、PG、PB分别代表3种 RGB 分量，那么一幅RGB图像就是利用cat（级联）算子将这些分量图像组合成彩色图像：
RGB_image=cat(3,PR,PG,PB); %将PR、PG、PB三个矩阵在第3个维度上进行级联
注意，在上面的cat操作中，图像应该按照R、G、B的顺序排列，如果所有的分量图像都相等，那么结果将是一张灰度图像。
分量提取让RGB_image代表一个RGB图像，下面的命令可以提取3个分量图像：
PR=RGB_image(:,:,1);
PG=RGB_image(:,:,2);
PB=RGB_image(:,:,3);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fe6168afa4dd201b63fff2f2337fabb/" rel="bookmark">
			教学计划编制问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		教学计划编制问题
学生姓名：XX 指导老师：XXX
摘 要 本课程设计主要针对计算机系本科课程，根据课程之间的依赖关系，制定课程安排计划，并满足各学期课程数目大致相同。在课程设计中，系统开发平台为Windows XP，程序设计设计语言采用C++，程序运行平台为Windows XP，数据结构为邻接表。对于每个学期的课程数目采用了学分变量进行控制，以实现各学期课程数目大致相同。在程序设计中，采用了面向对象解决问题的方法。程序通过调试运行，初步实现了设计目标，并且经过适当完善后，将可以应用在教学中解决教学计划编制问题。
关键词 程序设计；数据结构；AOV网；邻接表；C++；课程计划
1 引 言
计算机系的学生必须要完成教学计划中规定的一系列课程，有些课程之间存在相互之间的依赖关系。比如说：《C++程序设计基础》应在《数据结构》之前开设，《大学物理（下）》必须要在《大学物理（上）》学完之后才可以学习。在教学计划编制的过程中，有一个层次的关系。因此，有一个有效、便捷的教学计划编制系统是十分重要的。
1.1 课程设计目的
本课程设计主要是针对计算机系本科课程，根据课程之间的依赖关系，制定课程安排计划，并满足各学期课程数目大致相同。
教学计划编制系统是基于C++的软件系统，通过建立AOV网，按学期对课程序号、课程代号、课程名称以及课程学分进行相应输出，并且保证用户实现自由选择专业选修课功能。
1.2 课程设计内容
教学计划编制系统主要是处理课程之间的依赖关系。表1.1列出了若干门计算机系本科课程，其中有些课程不要求先修课程，例如，C1是独立于其他课程的基础课，而有些课程却需要有先修课程，比如，学完程序设计语言C++和离散数学后才能学习数据结构。具体情况如表1.1所示。
表1.1 课程以及课程之间的依赖关系
课程代号
课程名称
先修课程
C1
高等数学
无
C2
计算机科学导论
无
C3
离散数学
C1
C4
程序设计语言C++
C1、C2
C5
数据结构
C3、C4
C6
计算机原理
C2、C4
C7
数据库原理
C4、C5、C6
先修课程规定了课程之间的依赖关系，这种关系可以用AOV网来表示，其中顶点表示课程，弧表示依赖关系，如图1.1所示。
图1.1 表1.1对应的AOV网
程序的主要功能是实现课程的排序，以满足同一学期所修的课程相互之间无依赖关系，并且已修完其所有先修课程。另外，设置学分变量，控制每个学期的课程量基本均匀。
2 概要设计
2.1 设计思路
数据结构课程主要讨论数据表示和数据处理的基本问题。数据要能被计算机处理，首先必须能够存储在计算机的内存中，这项任务称为数据表示，数据表示的核心任务是数据结构的设计；一个实际问题的求解必须满足各项处理要求，这项任务称为数据处理，数据处理的核心任务是算法设计。
本课程设计是基于C++程序设计语言实现的。C++语言的主要特点表现在两个方面，一是全面兼容C，二是支持面向对象的方法。因此，C++既支持面向过程的程序设计，又支持面向对象的程序设计。
C++语言最有意义的方面是支持面向对象的特征，基于对象的程序是以类和对象为基础的，程序的操作是围绕对象进行的。在此基础上利用了继承机制和多态性，就成为面向对象的程序设计。
数据结构中的数据表示和数据处理问题都可以通过C++类中数据和对数据进行操作的函数来实现。
2.2 数据表示
教学计划编制问题中，操作对象是课程。课程之间的依赖关系用AOV网表示， AOV网的构造采用邻接表实现。因此，本程序设计定义了两个类：课程类和邻接表类。
课程类（Lesson）添加了5个私有成员变量用来定义课程的5个属性：课程代号、课程名称、课程序号、课程学分以及是否被选择过的课程标记。同时还定义了8个成员函数，已实现相关的操作功能。
邻接表类（ALGraph）定义了2个整型成员变量和1个结构体数组来存放顶点数、边数和顶点表。同时还定义了4个成员函数实现用来实现AOV网的构造、删除、排序以及相关输出功能。
2.3 数据处理
数据处理必须借助函数来实现。本程序设计通过调用类的各种成员函数实现各种需要操作。
课程类（Lesson）的成员函数如表2.1所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fe6168afa4dd201b63fff2f2337fabb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df718a42bddf85dd77403d3524ad46d8/" rel="bookmark">
			焕发生机｜嵌入式存储eMMC原理解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.EMMC背景回顾
EMMC存储的发展历史可以追溯到1997年，当时该技术是为了解决移动设备中存储器的问题而提出的。当时移动设备的存储器主要是NOR flash，这种存储器虽然读写速度快，但是造价高、容量小，不适合大规模应用。而EMMC的出现，将存储器和处理器或其他电子元件一起集成到单一芯片中，形成小巧、轻便的封装模块，解决了这个问题。随着技术的不断发展，EMMC规格的标准也逐渐从eMMC4.3时代发展到eMMC4.4时代，并进一步发展出eMMC4.5和eMMC 5.0等版本。其中，eMMC 5.0是三星于2013年7月29日首先量产的行业首款eMMC 5.0存储产品。
2.EMMC基本原理
eMMC是嵌入式MultiMediaCard的简称，它是对MMC存储卡标准的一个拓展，以满足更高标准的性能、成本、体积、稳定、易用等的需求。eMMC整体架构主要可以分为Flash Memory、Flash Controller以及Host Interface三大部分。
其中，Flash Memory是eMMC存储数据的主要部分，属于非易失性存储器，用于存放系统、应用和数据等，类似于PC系统中的硬盘。在eMMC内部，Flash Memory会被划分成不同的区域，包括BOOT Area Partition、RPMB Partition、General Purpose Partition和User Data Area等。
3.EMMC应用场景
由于EMMC具有大容量、高可靠性、低功耗、可扩展性强等特点，被广泛应用于各种嵌入式系统中，如手机和平板等移动设备。在这些设备中，eMMC通常会与处理器或SOC配合使用，以实现数据的存储和读取。开发者可以使用eMMC存储和读取设备中的系统和应用数据，包括操作系统代码、用户数据、应用程序等。
同时，随着技术的发展，EMMC的读写速度也不断提升，比如最新的eMMC 5.1读写速度已经可以达到UHS-II等级的速度。此外，EMMC也被应用于一些新兴的技术领域，比如DPU。在DPU中，EMMC作为存储器使用，支持DPU处理大量数据时所需的大容量存储器，同时满足DPU对高速数据传输的需求。
业内也有一个iNAND，是西部数据公司符合eMMC协议的一种芯片系列名称。也就是说，iNAND是一种eMMC，它基于eMMC协议进行设计和生产。是由存储系统和接口电路构成的，但它的接口电路比较复杂，功能很健全。它不仅提供了块的ECC校验相关的逻辑，而且本身自己完成了存储系统的ECC功能。这样，当SoC使用iNAND时，它就不需要自己编写代码来进行ECC相关操作，从而大大简化了SoC的编程难度。
另外，WD在HDD上采用的OptiNAND不是EMMC，基于UFS的产品。此前，WD针对HDD的创新提出了OptiNAND技术。OptiNAND技术的核心就是新增了iNAND UFS EFD，把磁道记录等元数据记录在iNAND之中。
根据官方的介绍，OptiNAND可以提升容量、性能和可靠性。
容量：采用triple stage actuator (TSA) 技术，实现更大的实现更大的TPI(每英寸磁道)数量和更高的面密度，在不需要增加碟片数量和磁头数量的情况下，实现容量的提升。原来放置在碟片的元数据，现在放在iNAND，也相当于给用户腾空了原来占用的数据空间，利于用户容量的提升。性能：降低了相邻磁道的干扰ATI，也可以降低写缓存的刷新频率，这样就可以减少延迟，提升性能可靠性：主要在EPO突然掉电场景，iNAND下刷的用户数据比之前DRAM缓存更多。 4.eMMC健康状态查询
在linux下，eMMC也是一个块设备，类似 /dev/mmcblk*。查看块设备的smartctl工具，对emmc也能查到一部分信息，但是信息很少。
# smartctl -a /dev/mmcblk0 smartctl 6.6 2021-07-22 r5044 [x86_64-linux-4.18.0-140-generic] (local build) Copyright (C) 2002-18, Bruce Allen &lt;brucea@smartmontools.org&gt; === START OF INFORMATION SECTION === model number: SanDisk Ultra Fit (Toshiba 1306) firmware version: OI_R248R354E4B8AF6AFAAI405T54JABOHX7244_SD03_V06.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df718a42bddf85dd77403d3524ad46d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ea01cf6fb9389a1fae20af4ac36ce7a/" rel="bookmark">
			算法总结10 线段树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法总结10 线段树 线段树2569. 更新数组后处理求和查询 线段树 有一个数组，我们要：
更新数组的值（例如：都加上一个数，把子数组内的元素取反）查询一个子数组的值（例如：求和，求最大值，求最小值） 更新于查询，如果暴力去做，每个操作都是O(n)的。所以我们需要提升效率。
两大思想：
挑选O(n)个特殊区间，使得任意一个区间，可以拆分为O(logn)个特殊区间（用最近公共祖先来思考）
O(n)&lt;=4n 挑选O(n)个特殊区间：build
lazy 更新 / 延迟更新
lazy tag：用一个数组维护每个区间需要更新的值
如果说这个值 = 0，表示不需要更新
如果这个值 ！= 0，表示更新操作在这个区间停住了，不继续地柜更新子区间了 如果后面又来了一个更新，破坏了于lazy tag的区间，那么这个区间就得继续递归更新了
模板：
class Solution: def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -&gt; List[int]: n = len(nums1) todo = [0] * (4 * n) def build(o: int, l: int, r: int) -&gt; None: if l == r: # ... return m = (l + r) // 2 build(o * 2, l, m) build(o * 2 + 1, m + 1, r) # 维护.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ea01cf6fb9389a1fae20af4ac36ce7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/396e62bbce4295841f48efaedf27c814/" rel="bookmark">
			算法总结9 高阶DP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法总结9 高阶DP 数位DP2801. 统计范围内的步进数字数目233. 数字 1 的个数面试题 17.06. 2出现的次数600. 不含连续1的非负整数902. 最大为 N 的数字组合1012. 至少有 1 位重复的数字1067. 范围内的数字计数1397. 找到所有好字符串 数位DP 2801. 统计范围内的步进数字数目 以该题作为模板，完成后面的所有题。
class Solution: def countSteppingNumbers(self, low: str, high: str) -&gt; int: MOD = 10 ** 9 + 7 def calc(s): @cache # 记忆化搜索 def dfs(i, pre, is_limit, is_num): if i == len(s): return int(is_num) res = 0 # 1. 直接跳过当前数位 if not is_num: # 可以跳过当前数位 res = dfs(i + 1, pre, False, False) # 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/396e62bbce4295841f48efaedf27c814/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5d7cf8c062fe33e3974ff3b058620b3/" rel="bookmark">
			Java线程池ExecutorService和Executors应用(Spring Boot微服务)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录：476
场景：在Spring Boot微服务中使用ExecutorService管理Java线程池。使用Executors创建线程池。使用Runnable接口实现类提交线程任务到线程池执行。
版本：JDK 1.8,Spring Boot 2.6.3。
1.线程和线程池基础
JDK自带线程和线程池包位置：java.util.concurrent.*，以及java.lang.Runnable和java.lang.Thread在java.lang.*中。
1.1线程接口Runnable
接口全称：java.lang.Runnable。
接口注释：The Runnable interface should be implemented by any class whose instances are intended to be executed by a thread.
说明：提交给线程执行的类需实现Runnable接口。该接口只有一个抽象方法public abstract void run()。具体业务逻辑如需被线程调用的话，必须在此run方法内调用业务逻辑。
1.2线程Thread
类全称：java.lang.Thread。
类注释：A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently.
说明：线程java.lang.Thread实现了java.lang.Runnable接口。在java.lang.Thread中维护了JVM中对线程的属性和方法的操作。方法包括线程创建、初始化、启动、运行、停止等。属性包括
线程名称、优先级、守护进程标志位、线程组、线程本地变量等。
接收Runnable线程任务方式：一般在创建Thread线程对象时，在有参构造函数的输入参数中传入自定义线程任务(实现Runnable接口的对象)。比如：public Thread(Runnable target)。
1.3线程池
(1)接口
java.util.concurrent.Executor，线程池顶层接口，只有一个抽象方法void execute(Runnable command)。此方法执行提交给线程池已实现Runnable接口的线程任务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5d7cf8c062fe33e3974ff3b058620b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96b5a2d78addcffc25e525df20e36c8d/" rel="bookmark">
			Java线程池ThreadPoolExecutor应用(Spring Boot微服务)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录：475
场景：在Spring Boot微服务中使用Java线程池ThreadPoolExecutor。实现Runnable接口提交线程任务到线程池。
版本：JDK 1.8,Spring Boot 2.6.3。
1.使用注解配置线程池ThreadPoolExecutor
(1)说明
ThreadPoolExecutor，全称：java.util.concurrent.ThreadPoolExecutor。
使用@Bean("threadPoolExecutorHz")注解把线程池注入到Spring IOC容器中。
(2)代码
@Configuration public class ThreadPoolConfig { @Bean("threadPoolExecutorHz") public ThreadPoolExecutor threadPoolExecutor(){ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 8, 16, 10, TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(10), new ThreadPoolExecutor.CallerRunsPolicy() ); return threadPoolExecutor; } } (3)线程参数
corePoolSize: the number of threads to keep in the pool, even if they are idle, unless allowCoreThreadTimeOut is set
maximumPoolSize: the maximum number of threads to allow in the pool
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96b5a2d78addcffc25e525df20e36c8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da9d102999736ea3605c05b4bcad1bd8/" rel="bookmark">
			Python怎么使用代理IP？什么是代理IP？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python众多的科技领域当中，爬虫的存在一直是独树一帜的；虽然其他语言也能进行网络数据的爬取，但是Python凭借更简洁的语法，更简单的逻辑而获得爬虫爱好者的喜爱。而代理IP的使用也是每一位爬虫使用者所需掌握的内容，那么什么是代理IP呢？
一、代理IP
在Python爬虫中，如果过多的访问同一个网站，会被网站的运维人员检测到进而封禁我们的IP地址，这个时候就需要我们用代理IP来代替我们自己的IP来进行访问
二、使用代理IP的原理
代理IP又叫做代理服务器，是服务端和个人浏览器中间的一座代理中转站；当浏览器请求访问时，返回的结果会先送到这个中转站然后在发送到你的浏览器上，而服务端检测到的访问数据都只是在这个中转站上，可以很好的防止个人IP被ben。
三、使用IP代理的方式
因为代理IP在Python中主要用在爬虫方面，所以我们先导入好爬虫所需要的第三方库
import requests # 导入库 然后添加一个代理IP，可以根据自己的需要，添加多个代理IP，这样就是创建了一个IP代理池:
"http":"http://IP地址：端口号" 通过requests库的get请求，得到百度网页的返回内容，当然这个内容返回的结果首先要经过代理服务器然后才到我们自己的电脑浏览器上。
四、总结
目前，国内的代理IP服务商是非常众多，有收费也有不收费的；如果只是爬虫的需求，一般免费的代理IP都可以满足。不要将资源放在没有必要的地方，而是根据自己的需要合理分配资源。
关于Python技术储备
学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
一、Python所有方向的学习路线
Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python必备开发工具
三、Python视频合集
观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
四、实战案例
光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
五、Python练习题
检查学习结果。
六、面试资料
我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
最后祝大家天天进步！！
上面这份完整版的Python全套学习资料已经上传至CSDN官方，朋友如果需要可以直接微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b14a4f4ed25cc83a55e2ab3a1fd2aeb/" rel="bookmark">
			el-table 取消鼠标移入时变色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		::v-deep .el-table--enable-row-hover .el-table__body tr:hover&gt;td {
background-color: transparent;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d42d4afbd44d02aa54e26bfba674fe6/" rel="bookmark">
			【MICCAI 2023 Challenges ：STS-基于3D CBCT的牙齿分割任务】学习记录：使用nnU-Net V2训练自己的数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文是对天池平台发布的【MICCAI 2023 Challenges ：STS-基于3D CBCT的牙齿分割任务】比赛进行一个初步总结，主要包含开发过程、训练技巧以及创新思路，对于此次比赛的详细信息可移步官网查看。
提示：开发过程，训练技巧同样适用于其他数据集：
提示：以下是本篇文章正文内容，下面案例可供参考
一、大赛数据简介 主题：在提供的三维CBCT数据集上实现牙齿分割任务。
此项任务基于三维CBCT数据集，任务的核心目标是在三维上分割出牙齿结构。我们将采用Dice、豪斯多夫距离、IOU等评价指标进行评估（评估及得分详细信息见评价指标）。同样地，具体的任务目标可参考下图：
评价指标：所有参赛选手均需对测试集的所有图像进行牙齿分割，生成对应的二值化mask。我们会对选手所提交的mask与我们的基准mask计算Dice、霍夫距离、IOU。
（1）Dice系数（Dice coefficient）用于评估两个集合的相似度，公式为：
（2）IoU（Intersection over Union）公式为：
其中，公式中A表示选手模型预测的mask，B表示Groud Truth的基准mask。
（3）三维豪斯多夫距离是基于体素（voxel）级别的距离度量，公式为：
其中，(x1, y1, z1)和(x2, y2, z2)表示两个体素的坐标，|x1 - x2|、|y1 - y2|和|z1 - z2|表示对应坐标轴上的距离。
**评分规则：**参赛选手的得分主要依据上述三个评分指标，主要为了便于评分，比赛统一将豪斯多夫距离进行归一化，使其值在0-1之间。最终取三个指标的加权平均，具体的评分公式为：score=0.4∗Dice+0.3∗IOU+0.3∗(1−H(d))
二、开发过程 1.准备nnU-Net V2的开发环境：【nnUNet】 （1）进入官网，下载ZIP到本地，或者直接SSH CLone。
（2）打开服务器终端，创建一个新环境，注意查看官方文档的安装说明！！！！python3.9版本以上
打开终端，创建环境 conda create -n nnUNet python=3.9
安装torch2.0，安装torch慢，直接下载whl文件pip install安装：【whl链接】https://download.pytorch.org/whl/torch_stable.html
实在不会，看此篇教程，博主写的很好：https://blog.csdn.net/i__om/article/details/128773034
下图是我在Linux服务器下安装的版本，仅供参考，具体根据自己需要进行安装;(这图片水印怎么去掉，烦死了)，到这里，nnUNet所需的torch环境已安装好，接下来安装nnUNetV2。
2.安装nnU-Net V2 （1）官网 https://github.com/MIC-DKFZ/nnUNet/blob/master/documentation/installation_instructions.md。根据官网的步骤来安装，打开终端，激活刚刚创建的新环境，按照步骤一步一步来，注意pip install -e .的时候别忘了后面的.（安装的时候一定要保持目录干净，官方的啥样，你的就啥样，如果你在nnUNet提前创建了新的目录，在安装的时候会报错，一定要安装完之后在创建）
（2）接下来就是数据集准备，创建目录结构，和具体怎么训练、推理的教程，暂时没时间写了，请先移步官方文档，有空会更新。
官方文档说明的很详细，【https://github.com/MIC-DKFZ/nnUNet】按照自己的需求创建（若遇到困难，请进一步搜素如何nnUNetv2的使用教程之类的文章，后续有时间我会继续更新）
3. 一些训练过程和推理过程踩过的坑（耐心等待，有时间就更新） 4. “投机取巧”，不走寻常路（耐心等待，有时间就更新） 5. 比赛提供数据集的处理方式（耐心等待，有时间就更新） 6. 半监督学习在此比赛的表现（耐心等待，有时间就更新） 三、训练技巧（耐心等待，有时间就更新） 四、创新思路（耐心等待，有时间就更新） 五、实验结果对比分析（大概有30条结果，后续更新） 总结（耐心等待，有时间就更新） 完结撒花（提前）：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/164e83cdd13f5234b4c388a457b78713/" rel="bookmark">
			深度学习有什么用？深度学习应用领域有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2023年的今天，深度学习已经在许多领域中取得了重大突破，包括计算机视觉、自然语言处理、医学、金融、自动驾驶等。掌握深度学习技能可以让你在多个领域中有机会解决现实世界的问题。深度学习有什么用？
深度学习在各个领域中有广泛的应用，其用途包括但不限于以下几个方面：
计算机视觉：
图像分类：将图像分为不同的类别，如猫、狗、汽车等。物体检测：识别图像中的特定物体，并标出其位置。人脸识别：识别图像或视频中的人脸。图像生成：生成具有艺术性或创造性的图像，如风格迁移和GAN（生成对抗网络）生成的图像。 自然语言处理：
机器翻译：将一种语言的文本翻译成另一种语言。文本分类：将文本数据分为不同的类别，如垃圾邮件检测和情感分析。文本生成：生成自然语言文本，如文本摘要、对话生成和故事创作。 语音识别：
语音转文本：将语音信号转换为可读的文本。语音生成：生成自然流畅的语音，如虚拟助手和有声读物。 医学和生物信息学：
医学影像分析：诊断和检测医学图像中的疾病，如X射线和MRI。基因组学分析：分析基因和蛋白质序列以了解基因组学和药物研究。 自动驾驶：
深度学习在自动驾驶汽车中用于感知环境、决策和控制车辆，以实现安全的自动驾驶。 金融领域：
信用风险评估：使用深度学习来评估贷款申请人的信用风险。高频交易：用于开发算法进行高频交易和市场分析。 游戏：
游戏智能：开发具有高级智能的游戏角色和虚拟敌人。游戏生成：生成游戏世界、地图和关卡。 推荐系统：
个性化推荐：根据用户的行为和兴趣，推荐电影、音乐、商品等。 工业和制造业：
检测和质量控制：检测制造过程中的缺陷或质量问题。预测维护：预测机器设备的故障并进行维护。 深度学习在各种领域中都有广泛的应用，它的强大特性使其能够处理大量复杂的数据并进行高级的模式识别，从而改进了各种任务的性能和效率。
免费分享一些我整理的人工智能学习资料给大家，整理了很久，非常全面。包括一些人工智能基础入门视频+AI常用框架实战视频、计算机视觉、机器学习、图像识别、NLP、OpenCV、YOLO、pytorch、深度学习与神经网络等视频、课件源码、国内外知名精华资源、AI热门论文等。
下面是部分截图，点击文末名片关注我的公众号【AI技术星球】发送暗号 321 领取（一定要发 321） 学好人工智能，要多看书，多动手，多实践，要想提高自己的水平，一定要学会沉下心来慢慢的系统学习，最终才能有所收获。
点击下方名片，扫码关注公众号【AI技术星球】发送暗号 321 免费领取文中资料。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4aa2edaa70c3bc0f2e71948d481660f/" rel="bookmark">
			9.12python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		猜数字
import random a = random.randint(0, 10) print(a) i = 0 while 1: b = int(input()) if b &lt; a: print("小了") i = i + 1 elif b &gt; a: print("大了") i = i + 1 else: print("对了") i = i + 1 break ———— while 1: b = int(input()) if b != a: if b &lt; a: print("小了") i = i + 1 elif b &gt; a: print("大了") i = i + 1 else: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4aa2edaa70c3bc0f2e71948d481660f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bca0a84d3228200f3320c818f60cf9c/" rel="bookmark">
			shell获取命令输出和返回值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 shell 中，可以使用以下方式获取命令的输出和返回值：
使用反引号（``）把命令括起来，就可以将命令的输出赋值给一个变量。例如：
output=`ls -l` 这样，变量 output 就包含了命令 ls -l 的输出。
使用 $? 获取命令的返回值。例如：
ls -l echo $? 在这个例子中，命令 ls -l 的返回值会被输出。
注意：如果命令中包含管道（|），那么 $? 会返回最后一条命令的返回值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deee1080e4556b2ebeb28b57546e3ba5/" rel="bookmark">
			Centos7离线安装mysql8 glibc版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查看mysql是否安装
yum list installed mysql*
或者：
rpm -qa | grep -i mysql
2.卸载
yum remove mysql*
3.删除残留文件
find / -name mysql
rm -rf /var/lib/mysql
rm -rf /etc/my.cnf
rm -rf /etc/profile.d/mysql.sh
rm -rf /etc/init.d/mysql
4.杀掉进程
ps -ef|grep mysql
5.建用户
useradd mysql
6.切用户
su - mysql
7.参考官方安装文档：https://dev.mysql.com/doc/refman/8.0/en/binary-installation.html
8.安装依赖包-root
yum install libaio
9.删除原有mariadb的配置文件-root
rm -rf /etc/my.cnf
10.下载glibc版本、解压、改文件名-mysql、建一些依赖目录
&gt;wget https://mirrors.aliyun.com/mysql/MySQL-8.0/mysql-8.0.28-linux-glibc2.12-x86_64.tar.xz
&gt;tar xvf mysql-8.0.28-linux-glibc2.12-x86_64.tar.xz
&gt;mv mysql-8.0.28-linux-glibc2.12-x86_64 mysql-8.0.28
&gt;cd mysql-8.0.28
&gt;mkdir mysql-files
&gt;chown mysql:mysql mysql-files
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/deee1080e4556b2ebeb28b57546e3ba5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fe71117ade34dd163d5fb8de84f0038/" rel="bookmark">
			前端开发工作中可能会遇到的问题及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、uni-app小程序中xxx代码依赖分析忽略二、uni-app弹窗列表滚动, 弹框下面的内容也跟随滚动三、uni-app小程序正常自定义组件不生效 四、uni-app popup 弹出层底部空隙问题
五、uni-app小程序自定义导航栏后iOS页面可上下滑动问题解决方案
六. uni-app中的分享二维码以及保存到相册
七、vue运行时报错
一、uni-app小程序中xxx代码依赖分析忽略 新的任务发生了这个问题，一启动这个大红色看着十分碍眼，好在报错提示也给了解决办法，如下图所示
"ignoreDevUnusedFiles": false, "ignoreUploadUnusedFiles": false, 二、uni-app弹窗列表滚动, 弹框下面的内容也跟随滚动 弹窗组件代码,需要在最外层的view中加入 @touchmove.stop.prevent="moveHandle"，就可以解决这个问题了
三、uni-app小程序正常自定义组件不生效 这是一个离奇的问题，正常自定义组件在页面引入，注册，使用，但是编译后居然没有显示出来而且也没有报其他的错误，这到底是为什么呢, 我也不知道…… 这个hbuilder 肯定不能逮着我一个人坑对不对，查了下，别人也遇到了这个问题，
总结下来有以下大致两种解决方法
1.每次引用新建组件，把编译器关闭后再重启
2.新建组件后，再新建一个页面,重新编译(亲测有效)，新建的组件就生效了，就是那么离奇
如果有更好的方法，欢迎提出，再不想用上方这两个蠢蠢的办法了
四、uni-app popup 弹出层底部空隙问题 如图所示，我遇到的问题是底部弹出层有一个间隙的问题，我看了下应该是样式问题， 是它自带了一个padding-bottom,于是我看了源码，这个问题就解决了
解决方法：
首先找到Popup的源码
因为设置的是底部弹出层，就着重看关于底部弹出的样式
五、 uni-app小程序自定义导航栏后iOS页面可上下滑动问题解决方案 提起这个我就想,真好啊，又是一个长知识的机会!!!（内心真实想法—把用apple的人的都抓起来) ,在安卓就好好的，偏偏它就会出问题，请看以下问题：
问题描述：
在开发小程序的过程中，自定义了导航栏，但是发现在ios中页面整体可上下移动，造成体验极差。
解决方案：
“disableScroll”:true,//ios禁止页面整体上下滑动
{ "path": "home/index", "style": { "navigationStyle": "custom",//关闭原生导航栏 "disableScroll":true,//ios禁止页面整体上下滑动 } }, 问题描述:
如下图所示：在安卓真机和开发着工具中都是正常，但是到了大苹果(我不用大苹果我还不知道它还能左滑滑右滑滑~~~)
这是一个样式问题，所以我们看下原本的页面样式代码；
解决方案：
当时我不知道这个问题是怎么回事，后来请教了同事后仔细想想其实这个问题也很好解决，
起初设置的宽度是100%,但是下方又设置了padding内边距, 而盒子宽度默认的计算方式是content-box，下图有详细解释
所以在对应的html页面结构中的父元素中，给它的样式加上这样一句，就可以解决了
六、uni-app中的分享二维码以及保存到相册 这个应该不算是一个难点，这是因为我之前没有做过，觉得很新鲜，所以分享在这里,要实现的功能呢长这个样子，以弹窗的形式出现用户可以选择转发给好友或者是保存相册后从相册转发
1.页面结构，因为是弹窗的形式所以选用了uni-popup &lt;uni-popup ref="popup" animation mask-background-color="rgba(0,0,0,0.2)" @change="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fe71117ade34dd163d5fb8de84f0038/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44db80e1a9fe8b2ba471336528a083bd/" rel="bookmark">
			E2E 端到端保护
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、E2E介绍 E2E通过一些机制，使sw-c发送终端和sw-c接收终端的数据保持一致，保证信息的完整性。
E2E可适用于各种总线通信，例如CAN、CAN FD、LIN、FlexRay总线通信中。
二、E2E算法 E2E策略的整体思路是CRC校验和计数器。E2E有很多算法，是autosar提供的，可以直接用，如E2E_P01，E2E_P02，E2E_P04，E2E_P05，E2E_P06。以E2E_P01进行算法说明。
发送方采用保护函数E2E_P01Protect，接收方采用校验函数E2E_P01Check。
发送方：选择算法E2E_P01，把需要保护的原始数据，DataID（16bit）、Counter通过算法计算出crc值，加上计数器的值（计数器每发送一次值就增加），形成E2E的报头，即4个bit的Counter，1个字节的CRC以及需要被保护的原数据，一起打包发送给接收方。
注：
1.当 E2E_P01DataIDMode = E2E_P01_DATAID_NIBBLE 时的DataID 信息在数据中位置由用户定义。
2.Data ID 有四种模式：E2E_P01_DATAID_BOTH、E2E_P01_DATAID_ALT、E2E_P01_DATAID_LOW、E2E_P01_DATAID_NIBBLE。
当 E2E_P01DataIDMode = E2E_P01_DATAID_BOTH 时，DataID 的长度为 16Bits。DataID 两个字节均参与 Crc 的计算，但是不参与数据传输；
E2E_P01DataIDMode = E2E_P01_DATAID_ALT 时，DataID 的长度为 16Bits。当 Counter 为偶数时，DataID 的低字节参与 Crc 的计算，但不参与数据传输, 而当 Counter 为奇数时，DataID 的高字节参与Crc 的计算，不参与数据传输；
当 E2E_P01DataIDMode = E2E_P01_DATAID_LOW 时，DataID 的高字节不使用，应置为 0x00，此时相当于可用 Data ID 长度为 8Bits。DataID 的低字节参与 Crc 的计算，但不参与数据传输；
当 E2E_P01DataIDMode = E2E_P01_DATAID_NIBBLE 时，DataID 高字节的高半字节不使用，应置为 0x00，此时相当于可用 DataID 的长度为 12Bits，且此时 Data ID 高字节的低半字节不仅参与 Crc 计算，还与数据一起传输，位置由 DataIDNibbleOffset 决定。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44db80e1a9fe8b2ba471336528a083bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/820b1cfb415aba1de5acfcd366d30e28/" rel="bookmark">
			数据结构汇总（竞赛&#43;笔试）（有待补全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.链表 1.1 单链表
(1) 笔试写法
struct Node { int val; Node *next; Node(int _val) : val(_val), next(NULL){} } *head; // p 后插入新节点 void insert(Node *p , int x) { Node *q = new Node(x); q-&gt;next = p-&gt;next; p-&gt;next = q; } // 删除节点p -&gt; next void remove(Node *p) { auto q = p-&gt;next; p-&gt;next = q-&gt;next; delete(q); } //查找x节点 Node *find(int x) { for(auto p = head ; p !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/820b1cfb415aba1de5acfcd366d30e28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f97ccc43d782d033741f855f68970940/" rel="bookmark">
			ADS1256&#43;STM32程序详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ADS1256是TI公司推出的微功耗、高精度、8通道、24位高性能模数转换器（ADC）。该器件提供高达23比特的无噪声精度、数据速率高达30kSPS（次采样/秒）、十万分之一的非线性特性以及具备众输入模拟多路开关、输入缓冲器、可编程增益放大器和可编程数字滤波器等，,有完善的自校正和系统校正系统,SPI串行数据传输接口。可为设计人员带来完整而高分辨率的量测解决方，如应变计、气体分析、仪器仪表、压力传感器、血液分析、医疗科学仪器等应用，ADS1256采用SSOP-2封装。
ADS1256特点 1、8通道输入：可同时采集8路信号。 2、测量范围广：0-5V输入电压采样
3、采集频率高，精度高：采集卡的采集速率为30K/s。 ADS1256示意图
1． 时序图 STM32SPI可以直接连接，ADS1256的CS线仅仅只是做片选使用数据输出结束需要发送一次脉冲。在SCLK第一脉冲DIN开始接受数据输入，数据输入完毕的T6内SCLK需要保持低电平，然后调制一个周期的脉冲信号，数据即可全部到达DOUT总线，一次读写完毕。
核心源码： #include &lt;stdio.h&gt;
#include "stm32f10x_gpio.h"
#include "ADS1256.h"
//***************************
// Pin assign // STM32 ADS1256 // GPIOB_Pin_11 &lt;--- DRDY
// GPIOB_Pin_12 ---&gt; CS
// GPIOB_Pin_13 ---&gt; SCK
// GPIOB_Pin_14(MISO) &lt;--- DOUT
// GPIOB_Pin_15(MOSI) ---&gt; DIN
//*************************** #define RCC_DRDY RCC_APB2Periph_GPIOB
#define PORT_DRDY GPIOB
#define PIN_DRDY GPIO_Pin_11
#define PORT_CS GPIOB
#define PIN_CS GPIO_Pin_12
#define CS_0() GPIO_ResetBits(PORT_CS, PIN_CS);
#define CS_1() GPIO_SetBits(PORT_CS, PIN_CS);
#define ADS1256_DRDY (PORT_DRDY-&gt;IDR &amp; PIN_DRDY)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f97ccc43d782d033741f855f68970940/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca682f980a5f54bf46229bd4ddab8637/" rel="bookmark">
			软件测试---功能分解、等价类、边界值、因果图、错误推测、正交实验、场景法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、黑盒测试 1、功能分解法 功能分解法就是把软件需求中的每一个功能加以分解，分解为功能单位，以功能单位为对象进行测试用例涉及。
例子：用户管理系统可以分为如下，当然也可以进一步往下分解。
根据上面的功能分解图可以对分解出来的最底层功能单元逐个进行测试用例设计和测试。同时可以从功能单元是否全部实现来判断上层功能的完备性。
2、等价类划分法 优点：每一个输入域都考虑到了。
缺点：产生的测试用例过多，可能产生一些无效的测试用例，也可能有一些特殊的点没有考虑。
等价类划分法是将需求中功能输入要求进行分解，将输入域划分成若干部分，然后从每个部分中选取少数代表性数据作为测试用例，每一类的代表性数据在测试中的作用等价于这一类中的其它值。等价类划分法必须在分解输入要求的基础上列出等价类分解表，划分出有效等价类及无效等价类。
a) 有效等价类：对于功能需求来说是合理的、有意义的输入数据构成的集合。利用有效等价类可检验软件是否实现了软件需求规格说明中所规定的功能。
b) 无效等价类：与有效等价类相反。对于功能需求来说是非法的，但有意义的数据集合。利用无效等价类可检验软件在功能实现的基础上是否对异常输入进行了保护。
例子：
1）、创建等价类表（分析过程）
2）、设计测试用例
一条测试用例尽可能覆盖多的有效等价类；每一个无效等价类都必须有一条测试用例覆盖他，在有一个无效等价类的时候，别的输入就必须是有效等价类
3、边界值分析法 03.黑盒测试-边界值-【软件测试实战教程】_哔哩哔哩_bilibili
等价类法中例子，用边界值法进行补充和修改之后
边界值分析法是针对软件边界情况进行验证。通常需要选择边界内、边界上及边界外的值对程序进行验证。对于边界值分析法主要步骤如下：
a) 分析软件文档，找出功能需求中所有可能存在的边界条件。
b) 对于边界条件，找出边界内、边界上及边界外的输入数据。
c) 根据输入数据设计测试用例。
4、因果图法 视频讲解：04.黑盒测试-因果图-【软件测试实战教程】_哔哩哔哩_bilibili
因果图法是从软件需求规格说明描述的自然语言中找出功能的因（输入）和果（输出或状态改变），通过因果图转换为判定表，根据判定表设计测试用例。
适用场景：1、需要描述多种条件的组合；2、不同组合会产生多个动作
例子：视频的11：40秒
（上图中 c和d互斥是错的，应该b和d互斥，画图可以省略）
然后把上面的图转化为表格的形式，如下：
接着分分析其余的情况： 转化为判定表如下：
5、判定表法 05.黑盒测试方法论-判定表-【软件测试实战教程】_哔哩哔哩_bilibili
1）、确定条件桩
2）、确定动作桩
判定表分析：
3）、确定初始判定表
4）、简化判定表 前八个只要条件桩c1=0，动作装A1=1，因此可以合并；还有12、14、15项时，不可能的结果我们就不用测试。最后剩下六条，然后按照每一条的规则设计测试用例就可以了。
6、错误推测法 错误推测法是指：在测试程序时，人们可以根据经验或直觉推测程序中可能存在的各种错误，从而有针对性地编写检查这些错误的测试用例的方法。
例如，测试一个对线性表（比如数组）进行排序的程序，可推测列出以下几项需要特别测试的情况：
输入的线性表为空表；
1. 表中只含有一个元素；
2.输入表中所有元素已排好序；
3. 输入表已按逆序排好；
4.输入表中部分或全部元素相同。 7、正交试验法 软件测试-正交实验法_哔哩哔哩_bilibili
当我们的输入项很多，每个输入项的取值也很多，这样我们的测试用例就很多，因果图也很乱很复杂。
正交试验法是从大量的试验点中挑出适量的、有挖根生的点，应用正交表，合理地安排试验的方法。该方法主要步骤如下：
a) 提取功能说明，构造因此状态表。把影响实验指标的条件称为因子，影响实验因子的条件叫做因子的状态。在设计测试用例时，首先要根据软件需求规格说明找出影响功能实现的操作对象或外部因素，把它们当作因子，把各个因子的取值当作状态。
b) 加权筛选，生成因素分析表。对因子与状态的选择可按重要程度分别加权。根据因子及状态作用的大小、出现频率等因素，确定权值大小。
c) 利用正交表进行各因子的状态组合，构造有效的测试输入数据集，形成测试用例。
（正交表有人已经总结的，可以上网查找，也有自动生成的工具，比如：Slothman）
8、场景法 06.黑盒测试-场景法-【软件测试实战教程】_哔哩哔哩_bilibili
场景法是根据软件文档划分软件运行场景，根据软件运行场景设计测试场景。用例场景用来描述流经用例的路径，从用例开始到结束遍历这条路径上所有基本流和备选流。基本流是经过用例最简单的路径，一个备选流可能从基本流开始，在某个特定条件下执行，然后重新加入到基本流中，也可能起源于另一个备选流，或终止用例而不再重新加入某个流。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca682f980a5f54bf46229bd4ddab8637/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d02cef0e9552c6a4d4574ce01f2e539/" rel="bookmark">
			淄博烧烤电商——项目环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、项目环境搭建 1、jdk-17（之前已安装并配置好环境变量） 2、idea2023.1.2 由于本项目要求使用jdk-17，笔者原有的idea2020版本不能兼容，故安装idea2023新版本 安装并破解
3、maven3.6（之前已安装好并能正常使用） - 设置仓库repo文件夹 - 设置阿里云镜像 &lt;mirrors&gt; &lt;!--阿里云镜像1--&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 4、部署项目 将压缩包解压后打开，并刷新maven 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccb55662d809fcaa58575e3563783af5/" rel="bookmark">
			Java的abstract应用和代理模式应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录：474
场景：Java的abstract应用，一个抽象类，多个实现类。Java代理模式应用，使用代理模式执行具体实现类，在代理类中做日志等记录。
版本：JDK 1.8。
1.一个Java抽象类
(1)说明
使用Java关键字abstract修饰的类，就是抽象类。
使用Java关键字abstract修饰的方法，就是抽象方法。抽象方法没有方法体。
(2)代码
public abstract class SportContest { //赛事任务 private TaskDto taskDto; //开场仪式 public abstract String announceStart(); //举行比赛 public abstract ResultDto playGame(); //颁奖仪式 public abstract String announceEnd(ResultDto resultDto); //举行体育赛事 public String holdSportGame() { String result01 = announceStart(); ResultDto result02 = playGame(); String result03 = announceEnd(result02); return result03; } public TaskDto getTaskDto() { return taskDto; } public void setTaskDto(TaskDto taskDto) { this.taskDto = taskDto; } } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccb55662d809fcaa58575e3563783af5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae25fc2218e1328da12e06a6cbee479d/" rel="bookmark">
			springboot对接postgres
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装postgres 注意:下述链接方式会自动创建数据库steven_russell,若需要创建其他数据库，可以手动执行命令创建数据库
docker run --name postgres \
-p 5432:5432 \
-e POSTGRES_USER=steven_russell \
-e POSTGRES_PASSWORD=123456 \
-itd --privileged=true postgres
docker安装postgres_Steven-Russell的博客-CSDN博客
创建springBoot项目 搭建最简单的SpringBoot项目_Steven-Russell的博客-CSDN博客
引入postgres依赖 &lt;dependency&gt; &lt;groupId&gt;org.postgresql&lt;/groupId&gt; &lt;artifactId&gt;postgresql&lt;/artifactId&gt; &lt;/dependency&gt; 编辑resource配置文件 注意：需要配置方言
spring: datasource: url: jdbc:postgresql://192.168.30.128:5432/steven_russell username: steven_russell password: 123456 jpa: hibernate: ddl-auto: update show-sql: true database-platform: org.hibernate.dialect.PostgresPlusDialect 创建实体 @Data @Entity @Table(name = "tbl_user") public class User { @Id @Column @GeneratedValue private int id; @Column private String name; @Column private String addr; @UpdateTimestamp @Column private Date updateTime; } 创建repository 创建controller @RestController @RequestMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae25fc2218e1328da12e06a6cbee479d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06fffcc4b06e2ba33cc9f5809865c84e/" rel="bookmark">
			Flask 中最受欢迎的5个扩展插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 Flask-Admin Django中有个杀手锏的功能就是自带Admin面板，所有数据都可以通过Admin后台来操作， Flask-Admin 就是一个功能和Django-Admin非常类似的库，有了它你再也不需要直接去数据库查数据改数据了。
Github地址：添加链接描述
2、Flask-SQLAlchemy Flask-SQLAlchemy 直接在SQLAlchemy的基础上封装了一层，简化了配置以及SQLAlchemy库的导入路径
# config.py SQLALCHEMY_DATABASE_URI = '' # app.py def create_app(config_name=None, app_name=None): """使用工厂模式创建app""" if not app_name: app_name = __name__ app = Flask(app_name) from flask_sqlalchemy import SQLAlchemy db = SQLAlchemy() db.init_app(app) # model.py class User(db.Model): id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String, unique=True, nullable=False) email = db.Column(db.String, unique=True, nullable=False) db.session.add(User(username="Flask", email="example@example.com")) db.session.commit() 3、 Flask-Migrate Flask-migrate 是一个SQLAlchemy 数据库升级迁移工具，基于Alembic实现，它提供了一系列命进行数据库升级撤回操作。
from flask_alembic import Alembic alembic = Alembic() alembic.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06fffcc4b06e2ba33cc9f5809865c84e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa0211da9fce4e90b42c41f8f2f7ce58/" rel="bookmark">
			【Linux】Rsync基于SSH认证的使用（rsync 命令属于1 v 4 的命令、rsync常用参数基本用法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Rsync基于SSH认证的使用 rsync 默认使用 rsync 协议进行远程登录和数据传输，想使用ssh协议进行传输需要使用-e参数指定，并且远程主机需要开启 sshd 服务，rsync 在传输数据之前会先与远程主机进行一次 ssh 登录认证，然后通过 ssh 隧道进行数据传输。只需数据同步双方安装 rsync，但不必启动 rsyncd 服务。
可用 -e 选项指定协议：
rsync -r -e ssh /var/sysnc-src/ username@10.110.101.100:/var/rsync-dest #指定通过ssh协议将/var/sysnc-src的数据递归同步到ip为10.110.101.100主机的/var/rsync-dest目录 也可省略 -e：
省略-e表示使用的是默认的rsync协议；
rsync -r /var/rsync-src/ username@10.101.11.11:/var/rsync-dest/ 使用 ssh 认证与传输的缺点是不安全：
登录认证使用的账号是远程主机可登录的系统账号，且需要手动输入密码；
同步数据不受目录限制。
rsync 命令属于1 v 4 的命令 类似于 cp 命令 -- 实现本地备份传输数据
类似于scp 命令 -- 远程备份传输数据
类似于 rm 命令 -- 实现无差异同步备份
类似于 ls 命令 -- 本地文件信息查看
① rsync==cp [root@backup ~]# cp -a /etc/hosts /tmp/ [root@backup ~]# ls /tmp/hosts [root@backup ~]# rm /tmp/hosts [root@backup ~]# rsync /etc/hosts /tmp/ [root@backup ~]# ls /tmp/hosts /tmp/hosts ② rsync == scp 远程数据同步方式（类似scp）---又称为隧道传输
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa0211da9fce4e90b42c41f8f2f7ce58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ff63e1cc7dd502db235a79d242e8ef7/" rel="bookmark">
			echarts柱状图堆叠-顶部圆角
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 设置柱条顶层圆角 for (let j = option.series.length - 1; j &gt;= 0; j--) { // legend个数，echarts堆叠是最后一个在最上面，所以先找最后一个不全为0的数组 const allZero = option.series[j].data.every(function(item) { return item === 0; }); if (!allZero) { for (const i in option.series[j].data) { // 横坐标数 if (option.series[j].data[i] != 0) { // 找到最后一个不为0的数据，添加圆角 option.series[j].itemStyle.normal = { borderRadius: [4, 4, 0, 0] }; break; // 退出该柱条的循环 } } break; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb07cf2e015760c585e29e714ff69fca/" rel="bookmark">
			超级电容-一阶RC模型-RLS参数辨识-Simulink仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.超级电容器一阶RC等效电路模型
步骤1&gt;求解超级电容器模型的传递函数
步骤2&gt;传递函数离散化
步骤3&gt;RLS最小二乘参数辨识
2.仿真实验
(1)利用超级电容模型进行仿真
（2）利用辨识得到R\C结果构建等效电路
（3）结果对比
电压
电流
电流局部 搭建模型与实际模型一致度较高，辨识算法和数学模型正确性满足 4.联系方式 QQ 1978009424
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b53c5f74e2271be370fd393de9bf7c42/" rel="bookmark">
			vscode的vue代码提示与补全没反应（vetur问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode的vue代码提示与补全没反应（vetur问题）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d6142d014e00f1d29c30b57ccd2e26c/" rel="bookmark">
			Prometheus Grafana搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、prometheus介绍 prometheus是由谷歌研发的一款开源的监控软件，它通过安装在远程机器上的exporter，通过HTTP协议从远程的机器收集数据并存储在本地的时序数据库上
同时Prometheus后端用 golang语言开发，前端是 Grafana
Prometheus 还是一款基于时序数据库的开源监控告警系统，非常适合Kubernetes集群的监控。Prometheus的基本原理是通过HTTP协议周期性抓取被监控组件的状态，任意组件只要提供对应的HTTP接口就可以接入监控。不需要任何SDK或者其他的集成过程。这样做非常适合做虚拟化环境监控系统，比如VM、Docker、Kubernetes等。输出被监控组件信息的HTTP接口被叫做exporter 。目前互联网公司常用的组件大部分都有exporter可以直接使用，比如Varnish、Haproxy、
Nginx、MySQL、Linux系统信息(包括磁盘、内存、CPU、网络等等)。Promethus有以下特点：
支持多维数据模型：由度量名和键值对组成的时间序列数据内置时间序列数据库TSDB支持PromQL查询语言，可以完成非常复杂的查询和分析，对图表展示和告警非常有意义支持HTTP的Pull方式采集时间序列数据支持PushGateway采集瞬时任务的数据支持服务发现和静态配置两种方式发现目标支持接入GrafanaPrometheus的流行和Kubernetes密不可分，支持对Kubernetes、容器、OpenStack的监控。 二、prometheus部署 1、使用系统 ip角色系统192.168.12.13prometheus（服务器端）grafana、node_exporter2(客户端)centos7192.168.12.12node_exporter1（数据采集数据）centos7 prometheus下载地址：
https://prometheus.io/download/ 本次使用的prometheus版本为：
下载后直接上传服务器192.168.12.13 /date目录下
也可以在服务器上使用wget下载prometheus安装包
[root@node3 date]# wget https://github.com/prometheus/prometheus/releases/download/v2.27.1/prometheus-2.27.1.linux-amd64.tar.gz [root@node3 date]# tar -xf prometheus-2.27.1.linux-amd64.tar.gz [root@node3 date]# mv prometheus-2.27.1.linux-amd64/ Prometheus 查看版本号：
[root@node3 Prometheus]# ./prometheus --version prometheus, version 2.27.1 (branch: HEAD, revision: db7f0bcec27bd8aeebad6b08ac849516efa9ae02) build user: root@fd804fbd4f25 build date: 20210518-14:17:54 go version: go1.16.4 platform: linux/amd64 [root@node3 prometheus]# pwd /date/prometheus [root@node3 Prometheus]# 查看帮助文档
[root@node3 prometheus]# ./prometheus --help usage: prometheus [&lt;flags&gt;] The Prometheus monitoring server Flags: -h, --help Show context-sensitive help (also try --help-long and --help-man).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d6142d014e00f1d29c30b57ccd2e26c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b809784b8c42737bec8e30f26767c197/" rel="bookmark">
			java实现克里金插值导出geojson矢量数据（kriging）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生成效果
在现代科学研究中，数据的处理和分析是至关重要的一环。然而，我们往往会遇到数据缺失的情况，这时就需要使用插值方法来填补这些缺失值。其中，克里金插值法是一种常用的方法，在很多领域都有广泛的应用。
首先，克里金插值法在地质勘探领域中有着广泛的应用。在地质勘探中，我们需要研究地下的地质结构和矿藏分布情况。然而，在采集数据时，由于种种原因，我们无法获取到完整的数据集。这时，我们就可以使用克里金插值法来估算缺失的数据，从而更加准确地进行矿藏勘探和开采工作。
其次，克里金插值法在气象学领域中也有着重要的应用。在气象学中，我们需要预测未来的气象情况，比如温度、降雨量等。然而，由于气象数据的采集难度较大，数据缺失的情况也比较常见。这时，我们可以利用已有的气象数据，使用克里金插值法来预测缺失数据，从而更好地进行气象预测和防灾减灾工作。
除此之外，克里金插值法还在许多其他领域中得到了广泛的应用，比如环境监测、土地利用规划等。可以说，克里金插值法已经成为了数据处理和分析领域中不可或缺的一部分。
综上所述，克里金插值法在许多领域都有着广泛的应用，能够帮助我们更好地处理和分析数据，提高研究和预测的准确性。相信随着科学技术的不断发展，克里金插值法在更多领域中也将得到更加广泛和深入的应用。
一、控制类代码实现
//http://localhost:8935/api/export/controlInterpolationVec?intv=0,30,50,70,90,150&amp;trainfn=traindata.json&amp;IM=Kriging @ApiOperation(value = "Interpolation") @GetMapping(value = "/controlInterpolationVec") // @Scheduled(cron = "0 10 * * * ?") public String stationInterpolationVec(String intv,String trainfn,String IM) { String traindt= FileUtils.ReadTxt(trainfn); int nNum = 3; // String monitorTime = DateUtil.format(DateUtil.addDateHours(new Date(),-1),"yyyy-MM-dd%20HH:00:00"); // // 获取数据 // JSONObject obj = JSON.parseObject(HttpUtils.sendGet(EDVRURL,"monitorTime=" + monitorTime + "&amp;regionCode=370300")); // String re = HttpUtils.SendPostRain(adcd,btime,etime); // JSONObject obj = JSON.parseObject(re); JSONObject obj = JSON.parseObject(traindt); // JSONObject obj = JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b809784b8c42737bec8e30f26767c197/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a22b553456b74607fe3573c5683d45a/" rel="bookmark">
			YOLOv8最新改进系列：YOLOv8&#43;BiFormer（CVPR 2023最新提出），基于动态稀疏注意力构建高效金字塔网络架构，用动态、查询感知的方式实现计算的有效分配，嘎嘎提升目标检测效果！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLOv8最新改进系列 BiFormer论文在这！
详细的改进教程以及源码，戳这！戳这！！戳这！！！B站：AI学术叫叫兽 改进后的源码在相簿的链接中，动态中也有链接，感谢支持！祝科研遥遥领先！
截止到发稿，B站YOLOv8最新改进系列的源码包已更新了24种+损失函数改进！
自己排列组合2-4种后，不考虑位置已达上万种改进方法，考虑位置不同后可排列上百万种！专注AI,关注B站博主：AI学术叫叫兽！
YOLOv8最新改进系列：YOLOv8+BiFormer，基于动态稀疏注意力构建高效金字塔网络架构,用动态、查询感知的方式实现计算的有效分配，嘎嘎提升目标检测效果！！！ YOLOv8最新改进系列一、BiFormer概述1.1 导读1.2 方法-Bi-Level Routing Attention1.3 实验1.4 文章总结 二、YOLOv8+GSConv+Slim Neck2.1 修改YAML文件2.2 新建BiFormer.py2.3注册(包含很多改进，不需要的可删) 三、验证是否成功即可 一、BiFormer概述 1.1 导读 众所周知，Transformer相比于CNNs的一大核心优势便是借助自注意力机制的优势捕捉长距离上下文依赖。正所谓物极必反，在原始的 Transformer 架构设计中，这种结构虽然在一定程度上带来了性能上的提升，但却会引起两个老生常态的问题：
1、内存占用大
2、计算代价高
在我B站视频的演示中，充分的证明了上述问题。
让我们先简单的看下上图：其中图(a)是原始的注意力实现，其直接在全局范围内操作，导致高计算复杂性和大量内存占用；而对于图(b)-(d)，这些方法通过引入具有不同手工模式的稀疏注意力来减轻复杂性，例如局部窗口、轴向条纹和扩张窗口等；而图(e)则是基于可变形注意力通过不规则网格来实现图像自适应稀疏性；
总的来说，作者认为以上这些方法大都是通过将 手工制作 和 与内容无关 的稀疏性引入到注意力机制来试图缓解这个问题。因此，本文通过双层路由(bi-level routing)提出了一种新颖的动态稀疏注意力(dynamic sparse attention )，以实现更灵活的计算分配和内容感知，使其具备动态的查询感知稀疏性，如图(f)所示。
此外，基于该基础模块，本文构建了一个名为BiFormer的新型通用视觉网络架构。由于 BiFormer 以查询自适应的方式关注一小部分相关标记，而不会分散其他不相关标记的注意力，因此它具有良好的性能和高计算效率。最后，通过在图像分类、目标检测和语义分割等多项计算机视觉任务的实证结果充分验证了所提方法的有效性。
1.2 方法-Bi-Level Routing Attention 为了缓解多头自注意力(Multi-Head Self-Attention, MHSA)的可扩展性问题，先前的一些方法提出了不同的稀疏注意力机制，其中每个查询只关注少量的键值对，而非全部。然而，这些方法有两个共性问题：
要么使用手工制作的静态模式（无法自适应）；
要么在所有查询中共享键值对的采样子集（无法做到互不干扰）；
为此，作者探索了一种动态的、查询感知的稀疏注意力机制，其关键思想是在粗糙区域级别过滤掉大部分不相关的键值对，以便只保留一小部分路由区域（这不就把冗余的信息干掉了吗老铁们）。其次，作者在这些路由区域的联合中应用细粒度的token-to-token注意力。
简单梳理下。假设我们输入一张特征图，通过线性映射获得QKV；其次，我们通过领接矩阵构建有向图找到不同键值对对应的参与关系，可以理解为每个给定区域应该参与的区域；最后，有了区域到区域路由索引矩阵 ，我们便可以应用细粒度的token-to-token注意力了。
上面是 BRA 模块的示意图。从图中可以看出，该方法是通过收集前 k 个相关窗口中的键值对，并利用稀疏性操作直接跳过最不相关区域的计算来节省参数量和计算量。值得一提的是，以上操作涉及 GPU 友好的密集矩阵乘法，利于服务器端做推理加速。
BiFormer
基于BRA模块，本文构建了一种新颖的通用视觉转换器BiFormer。如上图所示，其遵循大多数的vision transformer架构设计，也是采用四级金字塔结构，即下采样32倍。
具体来说，BiFormer在第一阶段使用重叠块嵌入，在第二到第四阶段使用块合并模块来降低输入空间分辨率，同时增加通道数，然后是采用连续的BiFormer块做特征变换。需要注意的是，在每个块的开始均是使用 的深度卷积来隐式编码相对位置信息。随后依次应用BRA模块和扩展率为 的 2 层 多层感知机(Multi-Layer Perceptron, MLP)模块，分别用于交叉位置关系建模和每个位置嵌入。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a22b553456b74607fe3573c5683d45a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fe79c50ca618482e29b8ef042efff1f/" rel="bookmark">
			Xcelium（xrun）的基础使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Xcelium的基础使用 https://www.cnblogs.com/Alfred-HOO/articles/17416139.html 一，基础问答
1，Xcelium的由来？
Xcelium（xrun）是cadence最新的仿真工具，Incisive(irun)的升级版本。
2，如何用xrun完成三步仿真？
xrun默认是单步仿真
xrun add.v //自动完成comp , elab ,sim 三步仿真：
comp : xrun -compile add.v elab : xrun -elaborate add.v //生成snapshot sim : xrun -R //自动识别snapshot 3、Xcelium的特性
严格的语法检查确保设计的成功，若代码不改变，默认不重新comp，elab代码，来减少仿真时间（如需要重新comp，elab，可添加-noupdate）
二，常用的option
三，help使用
whichxrun//查看xrun是否可以直接调用
xrun -helpargs//打印出xrun的option作用及用法（xrun -helpall）
当仿真报错，可以使用下面命令debug具体报错类型
xmhelpxrunBADPRFxmhelp xmsim BADPRF (根据报错信息调整xmvlog ，xmelab ，xmsim)
$nchelp ncvlog BADPRF(根据报错信息调整ncvlog，ncelab，ncsim).
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb3ceacaacb78d7a56cf26aa1141349f/" rel="bookmark">
			Git入门讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git入门讲解 一、初识Git 1.1 什么是Git Git是一个分布式的版本控制软件。最初由Linus Torvalds（林纳斯·托瓦兹）创建，旨在管理Linux内核的开发。
它可以跟踪文件的修改历史记录并允许多个人协同开发同一个项目。
版本控制，类似于毕业论文、写文案、视频剪辑等，需要反复修改和保留原历史数据
分布式
文件夹拷贝
本地版本控制
集中式版本控制
分布式版本控制
版本控制专业概念 在软件开发和其他文件管理场景中，版本控制是一种管理文件修改历史的技术。
它允许开发者或团队对文件进行更改，并保留每个版本的历史记录。
分布式版本控制与集中式版本控制的区别 当我们使用传统的集中式版本控制系统（如SVN）时，代码仓库通常位于服务器上，开发者需要从服务器上下载代码并将修改提交到服务器上。这种架构存在一些问题，例如：
单点故障：如果服务器出现故障，所有开发者都无法提交和获取代码。依赖网络：开发者需要始终连接到网络才能进行版本控制操作。难以协同：如果多个开发者同时修改了同一个文件，可能会出现冲突，需要手动解决。 为了解决这些问题，Git采用了分布式版本控制的架构。在Git中，每个开发者都有一个本地的代码仓库，可以在本地进行修改和提交，并可以将这些修改推送到远程的代码仓库中，与其他人的修改进行合并。这种分布式的架构带来了以下好处：
去中心化：不再依赖于单个服务器，每个开发者都有自己的完整版本库，可以在本地完全独立地进行版本控制操作。离线工作：开发者可以在没有网络连接的情况下进行版本控制操作，并可以在连接到网络时将修改推送到远程代码仓库中。容错性强：即使某个开发者的本地版本库出现故障，其他开发者的版本库仍然可以正常工作。 1.2为什么要做版本控制 要保留之前所有的版本，以便回滚和修改。
1.3 安装git 官方下载地址：https://git-scm.com/downloads
安装教程：Git - 安装 Git (git-scm.com)
下载后一路next安装即可
二、git管理 2.1 如何让git对一个目录进行版本控制 想要让git对一个目录进行版本控制需要以下步骤:
1、进入要管理的文件夹
2、执行初始化命令
git init //初始化 让git帮助我们管理当前文件夹 3、管理目录下的文件状态
git status //检测当前目录下文件的状态 注:新增的文件和修改过后的文件都是红色
4、管理指定文件 （红变绿），将文件由工作区变动文件放入暂存区
git add 文件名 --&gt;管理一个文件 git add . --&gt;将该目录下所有已变动文件放入暂存区 红色:新增的文件/修改了原老文件
绿色: git 已经管理起来
5、个人信息配置：邮箱、用户名【一次即可】
git config --global user.email "your@example.com" git config --global user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb3ceacaacb78d7a56cf26aa1141349f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8e0cc5aad2624824ba85cb67453b41e/" rel="bookmark">
			picgo报错Error: connect ECONNREFUSED 127.0.0.1:443的解决方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		picgo报错Error: connect ECONNREFUSED 127.0.0.1:443的解决方式 1报错的原因 报错为RequestError: Error: connect ECONNREFUSED 127.0.0.1:443
2使用到的网站 在线ping，查询DNS
ITDOG - 在线ping_在线tcping_网站测速_HTTP测速_API测速_路由追踪_在线MTR_DNS查询_ITDOG-云邦畅想
3使用到的教程 解决服务器 DNS 无法解析 github 域名问题
picgo报错Error: connect ECONNREFUSED 127.0.0.1:443的解决方式_JohnnyassSilverhand的博客-CSDN博客
需要解析如下域名：
github.com nodeload.github.com api.github.com raw.github.com training.github.com assets-cdn.github.com codeload.github.com help.github.com github.global.ssl.fastly.net documentcloud.github.com raw.githubusercontent.com githubstatus.com pkg-containers.githubusercontent.com C:\Windows\system32\drivers\etc\hosts打开后追加填入地址
20.205.243.166 github.com 20.205.243.165 nodeload.github.com 20.205.243.168 api.github.com 185.199.110.133 raw.github.com 185.199.109.153 training.github.com 185.199.111.153 assets-cdn.github.com 20.205.243.165 codeload.github.com 140.82.114.17 help.github.com 151.101.1.194 github.global.ssl.fastly.net 185.199.108.153 documentcloud.github.com 185.199.109.153 githubstatus.com 185.199.109.133 raw.githubusercontent.com 185.199.111.154 pkg-containers.githubusercontent.com 4我出现的问题 评论图片 追加填入地址后 image-20230911135056865 刷新本地dns 刷新本地 dns 缓存：cmd执行命令行ipconfig /flushdns
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8e0cc5aad2624824ba85cb67453b41e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c53ade81f231aec4e682e51fb80d951/" rel="bookmark">
			车载Android应用开发与分析 - 初试 SystemUI Plugin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前面的视频、文章中我们介绍完了整个车载Android应用开发所需要的基础知识：
【视频文稿】车载Android应用开发与分析 - 走进车载操作系统 - 掘金【视频文稿】车载Android应用开发与分析 - AOSP的下载与编译 - 掘金【视频文稿】车载Android应用开发与分析 - 开发系统应用 - 掘金【视频文稿】车载Android应用开发与分析 - AIDL实践与封装(上) - 掘金【视频文稿】车载Android应用开发与分析 - AIDL实践与封装(下) - 掘金 本期内容，我们介绍原生Android Automotive中车载应用的实现方式和它的原理。首先要介绍的就是车载应用开发中非常重要的一个系统应用，Android系统的UI - SystemUI。
由于原生Android系统的SystemUI代码量很大、内容也非常庞杂，这里我会挑选出对车载SystemUI开发具有参考意义的模块进行介绍，大约会有4-5期的内容，主要分为以下几个模块：
车载Android应用开发与分析 - SystemUI 「功能」与「源码结构」分析 - 掘金车载Android应用开发与分析 - 初试 SystemUI Plugin SystemUI的源代码可能是所有Android原生应用中最复杂的一个，当我们需要定制SystemUI时，庞大的源码量会对的定制化开发带来巨大的潜在风险。所以目前车载SystemUI常见的做法就是，从原生SystemUI中移植少量必须的源码，然后从头定制一个源码、功能完全可控的SystemUI。
重新开发一个SystemUI就是唯一的选项吗？当然不是！Google官方早就注意到了这个问题，所以SystemUI中提供插件化的开发方式 - SystemUI Plugin。
本文源码地址：/frameworks/base/+/refs/heads/main/packages/SystemUI/plugin/ExamplePlugin/
本文源码环境基于Android 13
SystemUI Plugin SystemUI plugin机制是一种让SystemUI的功能可以被动态替换或修改的方法，它可以让开发者快速创建和迭代SystemUI的原型，而尽可能少的修改SystemUI的主框架。
注意：使用Plugin并不能保证我们完全不需要修改SystemUI的主框架，毕竟需求永远是多变的。
Plugin Hooks Plugin hooks是一些预定义的插件接口，它们可以让应用实现一些特定的功能，并通过Intent和注解来注册和声明插件的类型和版本。Plugin hooks有多种类型，例如OverlayPlugin, QSFactory, VolumeDialog等，每种类型都有一个对应的action和expected interface，用于标识插件的功能和要求。
Android 13中Plugin hooks预定义接口主要有以下几种：
BcSmartspaceDataPlugin：这个plugin可以让应用提供自定义的数据给锁屏界面上的智能空间（BcSmartspace），例如天气、日历、新闻等。ClockProviderPlugin：这个plugin可以让应用提供自定义的时钟样式给锁屏界面和始终应用。DozeServicePlugin：这个plugin可以让应用自定义Doze模式的行为，例如控制屏幕亮度、显示内容、传感器等。FalsingPlugin：这个plugin可以让应用自定义对误触（Falsing）事件的检测和处理，例如判断用户是否真的想滑动通知栏或解锁屏幕等。GlobalActions：这个plugin可以让应用自定义全局操作（GlobalActions）对话框的外观和行为，例如添加新的操作按钮或改变对话框样式。GlobalActionsPanelPlugin：这个plugin可以让应用在全局操作对话框中添加一个可展开的面板，用于显示更多的操作选项或信息。IntentButtonProvider：这个plugin可以让应用在锁屏界面上添加一个自定义的按钮，用于启动一个指定的Intent。NavigationEdgeBackPlugin：这个plugin可以让应用自定义导航栏边缘返回（NavigationEdgeBack）手势的行为，例如改变触发区域或动画效果。NotificationListenerController：这个plugin可以让应用控制通知监听器（NotificationListener）服务的连接和断开，以及获取通知事件和数据。NotificationMenuRowPlugin：这个plugin可以让应用自定义通知菜单栏（NotificationMenuRow）的外观和行为，例如添加新的菜单项或改变菜单样式。NotificationPersonExtractorPlugin：这个plugin可以让应用自定义从通知中提取人物信息（NotificationPersonExtractor）的逻辑，例如识别通知中包含的联系人或头像等。OverlayPlugin：这个plugin可以让应用自定义覆盖在通知栏上方的视图（OverlayView），用于显示一些额外的内容或功能。PluginFragment：这个plugin可以让应用在SystemUI中嵌入一个Fragment，用于显示一些自定义的界面或功能。QSFactory：这个plugin可以让应用提供自定义的快速设置工厂（QSFactory），用于创建快速设置图块或面板。SensorManagerPlugin：这个plugin可以让应用使用SensorManager服务来注册和取消注册传感器监听器，以及获取传感器事件和数据。ToastPlugin：这个plugin可以让应用自定义Toast消息（Toast）的外观和行为，例如改变Toast位置或持续时间等。ViewProvider：这个plugin可以让应用提供一个自定义的视图（View），用于替换SystemUI中某些组件或功能。VolumeDialog：这个plugin可以让应用自定义音量调节对话框（VolumeDialog）的外观和行为，例如添加新的音量控制选项或改变音量条的样式。 Plugin 上手 创建一个AndroidStudio的SystemUI plugin项目，可以参考以下的步骤：
1）编译SystemUIPluginLib.jar
使用Plugin之前我们需要编译出SystemUIPluginLib.jar，在AOSP源码根目录执行下面的指令。
make SystemUIPluginLib 然后就可以在下面的目录中得到SystemUIPluginLib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c53ade81f231aec4e682e51fb80d951/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c7feac5c3cd26cb5028400d1a1da739/" rel="bookmark">
			8、Spring security配置放过的请求又被拦截了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 在项目中有一些接口需要放开spring security拦截，配置方法如下，其中permitUrls为需要放过的请求路径。
@Override public void configure(WebSecurity web) { web.ignoring().antMatchers(permitUrls); } 问题描述 实际请求地址：/api/v1.0/manufacturer/test/authorization/index
配置了放开如下路径，但是仍然被拦截
"/" + VERSION_NO + "/manufacturer/**/authorization/index", 其中VERSION_NO 为版本号如：v1.0 或 v2.0
原因分析： 匹配路径规则从域名后即开始匹配，因此配置spring security放过路径是就要从域名后路径开始考虑
解决方案： 去掉请求路径前面的/api
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcfea28b71d6936c7f938670f9bdf45b/" rel="bookmark">
			huggingface的数据集加载方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加载huggingface上的数据集 假设数据集长这样
通过下面的代码进行加载
rom datasets import load_dataset from transformers import AutoModelForSequenceClassification, AutoTokenizer #加载模型 model = AutoModelForSequenceClassification.from_pretrained("bert-base-uncased") tokenizer = AutoTokenizer.from_pretrained("bert-base-uncased") # 加载数据 dataset = load_dataset("glue", "mrpc", split="train") # 数据token def encode(examples): return tokenizer(examples["sentence1"], examples["sentence2"], truncation=True, padding="max_length") #修改 dataset = dataset.map(lambda examples: {"labels": examples["label"]}, batched=True) # 添加数据 dataset = dataset.map(encode, batched=True) dataset[0] ---------------每个数据行都是用dict的形式输出的 {'sentence1': 'Amrozi accused his brother , whom he called " the witness " , of deliberately distorting his evidence .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcfea28b71d6936c7f938670f9bdf45b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c0e1430fdd89a367e307e9390c28cb0/" rel="bookmark">
			找不到Gateway Filter 中的Unable to find GatewayFilterFactory with name AddRequestHeadersIfNotPresent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习Gateway Filter中 配置FilterAddRequestHeadersIfNotPresent时运行报错Unable to find GatewayFilterFactory with name AddRequestHeadersIfNotPresent，我查看了一遍配置文件并没有写错名字或缩进错误
找了半天也没有发现任何错误，然后我在@Configuration注解下的配置文件中尝试使用api形式去写，但是根本找不到.addRequestHeadersIfNotPresen，可以找到.addRequestHeader方法。
有可能是添加依赖的问题，但是和其他的断言api相互矛盾，如果是依赖的问题，其他的api也应该不能使用，所以这个问题到现在还没有解决，有没有大神可以解决一下，看看是哪里的问题！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7723e90a00cdd89c00110b3fcbcbd1a1/" rel="bookmark">
			对象多级对象数组同级合并子节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 递归合并子节点函数
const mergeChildren = (data:columnObj[]) =&gt; {
const mergedData:columnObj[] = [];
for (let i=0; i&lt;data.length; i++) {
const item = { ...data[i] };
if (item.children &amp;&amp; item.children.length&gt;0) {
const mergedItem = mergedData.find(merged =&gt; merged.title === item.title);
if (mergedItem) {
mergedItem.children!.push(...item.children);
} else {
mergedData.push(item);
}
} else {
mergedData.push(item);
}
// 递归处理子节点
for (let k = 0; k&lt;mergedData.length; k++) {
if (mergedData[k].children &amp;&amp; mergedData[k].children!.length &gt; 0) {
mergedData[k].children = mergeChildren(mergedData[k].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7723e90a00cdd89c00110b3fcbcbd1a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b5bdb6155e6e42ad43afeb67d381aad/" rel="bookmark">
			浅谈Oauth2.0授权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 近期公司准备上身份认证平台（IAM），主要有两块内容，一部分是单点登录、一部分是账号生命周期管理。其中涉及几个常用的单点登录标准认证协议，其中有SMAL、LOAP、CAS、OIDC、Oauth2.0，本篇文章对Oauth2.0认证协议进行讲解。
二、Oauth发展史 OAuth的发展史可以分为以下几个阶段：
2007年12月，OAuth 1.0版本发布，并迅速成为工业标准。
2008年6月，发布了OAuth 1.0 Revision A，这是一个稍作修改的修订版本，主要修正了一个安全方面的漏洞。
2010年4月，OAuth 1.0在IETF发布，协议编号RFC 5849。
2010年，发布了OAuth 2.0，这是OAuth协议的下一个版本，该版本与OAuth 1.0不兼容。
OAuth 诞生之初是为了解决 Web 浏览器场景下的授权问题。比如有一个网站A，在新用户注册时是支持QQ账号注册的，如果网站A能拿到QQ昵称和头像作为网站A用户注册的基本资料，这样新注册用户流程就简单多了，很多信息都不需要用户自己填写，直接套用QQ号的信息就可以了。这样的注册模式就对用户很友好，自然很容易提升用户注册的热情。 三、Oauth2.0定义 OAuth 2.0一词中的"Auth"表示"授权Authorization"，字母"O"表示"开放Open"，连在一起就表示"开放授权"。这也是为什么我们使用OAuth的场景，通常发生在开放平台的环境下。首先需要区分下认证和授权：
认证（Authentication）：用来验证某个用户是否具有访问系统的权限。如果认证通过，该用户就可以访问系统，从而创建、修改、删除、查询平台支持的资源。认证的方式就是我们登录，比如账密登录、手机验证码登录等。授权（Authorization）：用来验证某个用户是否具有访问某个资源的权限，如果授权通过，该用户就能对资源做增删改查等操作。 简单而言，认证就是证明访问者的身份，决定他是否能进入系统；授权则是决定访问者能做哪些内容。一般来说，都是先认证后检查授权。
四、Oauth2.0常用角色 OAuth 2.0 主要有4类角色：
resource owner：资源所有者，指终端的“用户”（即授权登录中资料信息的拥有者）。
resource server：资源服务器，即服务提供商存放受保护资源。访问这些资源，需要获得访问令牌（access token）。
client：客户端，代表向受保护资源进行资源请求的第三方应用程序。
authorization server： 授权服务器， 在验证资源所有者并获得授权成功后，将发放访问令牌给客户端。
五、Oauth2.0常用模式 OAuth2.0提供了四种授权(获取令牌)方式，四种方式均采用不同的执行流程，让我们适应不同的场景。
授权码（authorization-code）隐藏式（implicit）密码式（password）：客户端凭证（client credentials） 5.1、授权码（authorization-code）--最广泛 授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。
重要步骤说明：
第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。
https://b.com/oauth/authorize? response_type=code&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read 上面 URL 中，response_type参数表示要求返回授权码（code），client_id参数让 B 知道是谁在请求，redirect_uri参数是 B 接受或拒绝请求后的跳转网址，scope参数表示要求的授权范围（这里是只读）。 第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回redirect_uri参数指定的网址。跳转时，会传回一个授权码，就像下面这样。下面 URL 中，code参数就是授权码。 https://a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b5bdb6155e6e42ad43afeb67d381aad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddbeca82e714b894af14c0e05779234f/" rel="bookmark">
			mac端Python编辑开发：pycharm pro 2023 for mac
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，今天我要向大家介绍一款非常实用的Mac软件——JetBrains pycharm pro 2023 for mac。
使用场景疑问：你是否经常需要进行Python编程开发？你是否需要一款强大的集成开发环境（IDE）来帮助你更加高效地进行Python编程开发？
安装：pycharm pro 2023 for mac
主要功能介绍：JetBrains pycharm pro 2023 for mac是一款专业的Python集成开发环境，它可以帮助你更加高效地进行Python编程开发，包括代码编写、调试、测试、代码重构等操作。
其中，JetBrains pycharm pro 2023 for mac的主要功能包括：
代码编写：JetBrains pycharm pro 2023 for mac可以根据你的代码习惯和代码风格，智能推荐代码实现方案，提高你的编码效率。代码调试：JetBrains pycharm pro 2023 for mac提供了强大的调试功能，可以帮助你更加快速地定位代码错误和调试程序。代码重构：JetBrains pycharm pro 2023 for mac可以帮助你更加方便地进行代码重构操作，提高你的代码质量和可维护性。代码检查：JetBrains pycharm pro 2023 for mac可以自动检查你的代码质量和风格，提供代码优化和重构建议。插件支持：JetBrains pycharm pro 2023 for mac支持丰富的插件，可以根据你的需求进行定制和扩展，提高你的编程效率和体验。 除此之外，JetBrains pycharm pro 2023 for mac还提供了丰富的集成功能，包括与GitHub、Bitbucket、Visual Studio Code等各种开发工具的集成，让你更加方便地进行协作和开发。
总之，JetBrains pycharm pro 2023 for mac是一款非常实用的Python集成开发环境，它可以帮助你更加高效地进行Python编程开发，提高你的编码效率和代码质量。如果你是一位Python开发者，那么JetBrains pycharm pro 2023 for mac绝对是一个不错的选择。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddbeca82e714b894af14c0e05779234f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d67fffd61e497c936a5465d1313c578/" rel="bookmark">
			单点登录常用协议原理和流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 近期公司准备上身份认证平台（IAM），主要有两块内容，一部分是单点登录、一部分是账号生命周期管理。其中涉及几个常用的单点登录标准认证协议，其中有SMAL、LOAP、CAS、OIDC、Oauth2.0，本篇文章简单介绍。
二、单点登录介绍 单点登录是指用户只需输入一次用户密码，在某一个应用完成认证登录后，即可直接进入所有应用系统。由此可以看出，单点登录比统一认证更进一步，它在让所有应用系统使用一套用户密码访问的基础上，还能让用户只需要登录其中一个应用，访问其他应用不在需要再输入这套用户密码。
三、单点登录协议 3.1、CAS协议 CAS（ Central Authentication Service）中央认证服务，是一种独立开发指令协议，旨在为web应用系统提供一种可靠的单点登录方法。
CAS是开源的企业级单点登录方案，Apache2.0许可证，允许修改、发布、商用。
Cas包含两个部分，Cas Server和Cas Client。
Cas Server需要单独部署，负责对用户的认证工作。
Cas Client和受保护的客户端应用部署在一起，以Filter的方式保护受保护的资源，负责处理对客户端受保护资源的访问请求，需要对请求方进行身份认证时，重定向到Cas Server进行认证。
Cas Client支持多种客户端，包括Java、PHP、Python、.Net、Perl、Apache、uPortal、Ruby等语言。
流程说明： I，用户浏览器访问应用中的受保护资源。
II，Cas Client拦截请求，检查请求中是否带有Service Ticket（ST），如果没有就将请求重定向到Cas Server登录地址，并传送Service。
III，用户输入认证信息，登录
IV，用户登录成功，Cas Server随机产生一个相当长度、唯一、不可伪造的Service Ticket，并缓存Service Ticket用于验证，之后重定向到Service地址，并为客户端浏览器设置一个Ticket Granded Cookie（TGC）。
V，Cas Client拿到Service和新产生的Ticket后，请求Cas Server验证Service Ticket。
VI，Cas Server验证通过后，返回用户信息。
协议过程中所有与Cas的交互均采用SSL协议，确保ST和TGC的安全性；过程中有两次重定向的过程；Ticket验证过程对用户来说是透明的。
当用户访问另一个应用的服务再次重定向到Cas Server时，Cas Server会主动获取TGC，如果TGC有效，则直接进入步骤IV，如果TGC失效则需要用户重新认证。
3.2、OAuth2.0协议 OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如用户信息、照片，联系人），而无需将用户名和密码提供给第三方应用。
常见使用场景：
API访问授权授权登录web应用单点登录 认证和授权过程中涉及的三方包括：
服务提供商（IAM）：用户用来存储受保护资源。
用户：受保护资源的拥有者。
客户端（应用）：需要访问受保护资源的第三方应用。
流程说明： I，用户打开客户端，客户端要求用户授权。
II，用户同意给与授权，向服务提供商获取一个临时授权码。
III，客户端使用临时授权码，向服务提供商申请令牌。
IV，服务提供商验证临时授权码无误后，向客户端发放令牌。
V，客户端使用令牌，向服务提供商申请获取受保护资源。
VI，服务提供商确认令牌无误后，向客户端开发保护资源。
详细见《浅谈Oauth2.0授权》。
3.3、OIDC协议 OIDC（OpenID Connect），OIDC=(Identity, Authentication) + OAuth 2.0。它在Oauth2.0之上构建了一个身份层，是一个基于Oauth2.0协议的身份认证标准协议。OIDC的核心在于在Oauth2.0的授权流程中，一并提供ID Token来标识用户身份认证信息，ID Token使用JWT格式包装，可以安全地传输给第三方客户端并且容易被验证。此外还提供了UserInfo接口，可以获取用户更完整的信息。OIDC协议可以适用于各种类型的客户端（比如服务端应用，移动APP，JS应用），且完全兼容OAuth2.0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d67fffd61e497c936a5465d1313c578/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/49/">«</a>
	<span class="pagination__item pagination__item--current">50/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/51/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>