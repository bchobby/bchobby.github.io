<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7574baed98212eddb45f73aae250aff/" rel="bookmark">
			MySQL8.0！！！登录失败|ERROR 1045 (28000): Access denied for user ‘root‘@‘localhost‘ (using password
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		还是老规矩，重点直接看黄字，或者直接看第三节解决方案，其他都是废话！！
运行环境：windows10、mysql8.0.24、cmd用管理员权限运行。
一、前情提要：
1、博主找了一份源码，数据库sql文件的编码格式是utf8mb4，然后当时的mysql版本是mysql5.0不支持utf8mb4，于是就开始了卸载旧版本安装新版本（当前最新mysql8.0.24）的历程。
2、跟着网上的教程一顿操作猛如虎之后，以为安装成功，输入mysql -u root -p，然后输入生成的初始root密码，结果就报错ERROR 1045 (28000): Access denied for user ‘root‘@‘localhost‘ (using password: YES)。（如图）
3、接着我就去收这个error的解决方案，然后网上让我修改my.ini文件的[mysqld]底下加了一句skip-grant-tables，然后再登录就报错：ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost’ (10061)
4、然后后面怎么操作都是报这个error2003的错误！
！！！好家伙，如果你目前的情况跟我一样，首先，你先在cmd里面输入命令net start mysql，这里显示启动成功，然后打开“服务”，发现mysql服务根本就没有启动！！！！！ orz！！！！万恶之源！！！解决了一上午终于被我找到原因了！！
好的，如果以上都是一样，那么你的情况与我相同，一下解决方案对你来说有效，可以接着往下跟着操作就好了。除给出解决方案以外，我还会解释报错的原因和解释。
二、报错原因
首先感谢博主：博文链接
1、首先报错：无权限错误
ERROR 1045 (28000): Access denied for user ‘root‘@‘localhost‘ (using password: YES)
【翻译：拒绝用户“root”@“localhost”的访问（使用密码：是）】
原因：root没有使用权限
常规解决方案：也就是在my.ini中加那一句skip-grant-tables；但是这个方法用过之后不仅没有解决问题，mysql服务也无法正常打开！通过查询解决方案后，发现这个方法对于mysql8.0以上版本并不适用，需要另一种解决方案。
正确解决方案：见下一小节。
2、报错：mysql服务未启动错误
ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost’ (10061)
【翻译：错误2003（HY000）：无法连接到“localhost”上的MySQL服务器（10061）】
也就是mysql服务没有打开
原因：试了之后发现把上一步加进my.ini里面的那句skip-grant-tables删掉就不会报这个错了，mysql服务也能正常打开，所以产生这个报错的原因就是上一步的操作影响。
正确解决方案：见下一小节。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7574baed98212eddb45f73aae250aff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bba255392b6a4060d3705f82b4eb6383/" rel="bookmark">
			Spring学习笔记（二）【CGLIB浅拷贝BeanCopier的使用和详解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CGLIB浅拷贝BeanCopier的使用和详解 一、bean拷贝工具 bean拷贝工具类比较
常用的bean拷贝工具类当中，主要有Apache提供的beanUtils、Spring提供的beanUtils、Cglib提供的beanCopier，性能上分析如下表所示（该表来自网上的数据）
类方法归属单次耗时[ms]100万次耗时[ms]平均耗时[ms]BeanUtilscopyPropertiesApache0.31019630253.1400570.030253BeanUtilscopyPropertiesSpring0.0720822155.7443780.002155BeanCopiercopyCglib0.00507158.4152010.000058 上表当中可以发现三者性能：cglib &gt; spring &gt; hutool
本次所讲的内容是关于BeanCopier类的使用，当我们需要拷贝大量的数据，使用这个是最快的，而对于拷贝少量对象时，和其它的拷贝工具类速度也差不多，现在CGLIB也并入Spring，所以在Spring项目中可以直接使用它，不需要添加其他maven
原依赖 &lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; 优点：
拷贝速度快 缺点：
无法实现null字段跳过每次使用都需要调用create函数，如果上述实验把create放到循环里，结果会变成5s无法实现复杂类型的拷贝（如List） 在使用他的时候，我们需要先创建一个BeanCopier对象，源代码如下
public static BeanCopier create(Class source, Class target, boolean useConverter) { Generator gen = new Generator(); gen.setSource(source); gen.setTarget(target); gen.setUseConverter(useConverter); return gen.create(); } create函数参数解析：
第一个参数source：需要拷贝的对象第二个参数target：拷贝后的目标对象类型第三个参数useConverter：用户控制转换器，是否使用自定义的转换器 useConverter控制权限转换：
这个是用户控制转换器，如果设置为false，它会对拷贝的对象和被拷贝的对象的类型进行判断，如果类型不同就不会拷贝，如果要使他会拷贝，就需要设置为true，自己拿到控制权对其进行处理，一般情况下使用的都是false
二、自定义转换器演示 首先我们有两个类，属性都相同，但有一个类中其中一个属性类型与另外一个类对应的属性类型不一致，情况如下
@Data public class User { private String username; private Integer password; } @Data public class UserDTO { private String username; private String password; } 执行代码 User user = new User(); user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bba255392b6a4060d3705f82b4eb6383/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28b90ca8d90cb691cb5650687508dade/" rel="bookmark">
			【计算机基础知识7】垃圾回收机制与内存泄漏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言 一、垃圾回收机制的工作原理
1. 标记-清除算法的基本原理
2. 垃圾回收器的类型及其工作方式
3. 垃圾回收的回收策略和触发机制
三、内存泄漏的定义和原因
1. 内存泄漏的概念和影响
2. 常见的内存泄漏情况及其原因
四、如何避免和处理内存泄漏
1. 使用合适的数据结构和算法
2. 及时释放资源和关闭连接
3. 避免循环引用和多余的对象引用
4. 使用内存泄漏检测工具及测试策略
五、最佳实践和经验教训
1. 编写高效、可维护和无内存泄漏的代码的最佳实践
2. 运维人员应该注意的内存泄漏问题
六、结论
前言 垃圾回收机制是编程语言运行时环境的一部分，负责自动管理内存，防止内存泄漏和过度占用内存。其重要性在于，它可以帮助程序员在编写代码时更关注于程序逻辑而不是内存管理，从而提高程序的生产力和质量。垃圾回收机制通过自动回收不再使用的内存，使得内存可以更有效地被重用，避免了内存泄漏的问题。
内存泄漏可能导致应用程序运行缓慢，甚至崩溃，这会对业务连续性和应用程序的可用性产生负面影响。此外，内存泄漏可能导致系统资源浪费，甚至引发资源枯竭，从而影响整个系统的性能和稳定性。因此，预防和处理内存泄漏是应用程序和系统稳定性至关重要的方面。
一、垃圾回收机制的工作原理 1. 标记-清除算法的基本原理 标记-清除算法是垃圾回收机制中最基本的一种。这种算法包括两个阶段：标记阶段和清除阶段。
在标记阶段，垃圾回收器会遍历程序的所有对象，找出所有可达的对象，并给它们打上标记；在清除阶段，垃圾回收器会遍历所有对象，把没有标记的对象（即不可达对象）进行清理，以释放它们占用的内存。
2. 垃圾回收器的类型及其工作方式 增量式垃圾回收器：这种垃圾回收器在应用程序运行时进行回收工作，不会导致应用程序停顿。它会分批次逐步地回收内存，从而避免了一次性大量回收带来的性能问题。
分代式垃圾回收器：这种垃圾回收器基于这样一个观察：大多数对象很快就会变得不可达，而少数对象则需要更长时间才能变得不可达。分代式垃圾回收器将系统中的所有对象分为新生代和老年代两个区域。在新生代中，刚刚创建的对象会被放置在这里，而老年代则存储长时间存在的对象。一旦新生代中的对象经过一定次数的引用后仍然存在，就会将其移动到老年代中。这种方式的优点是可以更有效地发现并清除长时间存在的不可达对象。
复制式垃圾回收器：这种垃圾回收器将系统中的所有对象分为两个相同的区域，并同时在两个区域中分配内存。一旦其中一个区域的内存被用尽，就会将另一个区域中的所有对象复制到这个区域中，然后清空另一个区域。这种方式的优点是可以避免在标记和清除阶段进行全局扫描，从而提高效率。
标记-整理算法：这种算法与标记-清除算法类似，但在清除阶段有所不同。标记-整理算法会在清除阶段遍历所有标记的对象，并将它们移动到一端，然后清除它们之间的内存。这种方式的优点是可以避免内存碎片化问题，从而提高内存的使用效率。
3. 垃圾回收的回收策略和触发机制 引用计数法：这是最基本的垃圾回收策略之一。每个对象都有一个引用计数，每当有一个引用指向该对象时，引用计数就会加一；每当引用被释放时，引用计数就会减一。当引用计数为零时，就说明该对象已经不可达，可以将其回收。
可达性分析法：这是另一种基本的垃圾回收策略。这种方法通过跟踪程序的执行过程，找出所有可达的对象，并将它们标记为可达状态；然后将所有不可达的对象进行清理。可达性分析法比引用计数法更加复杂，但是它可以发现更多的不可达对象。
三、内存泄漏的定义和原因 1. 内存泄漏的概念和影响 内存泄漏是指程序在申请内存后，无法释放未再使用的内存空间。内存泄漏可能会导致程序运行缓慢，甚至崩溃，从而影响应用程序和系统的可用性和稳定性。内存泄漏也可能导致系统资源的浪费，甚至引发资源枯竭，从而影响整个系统的性能和稳定性。因此，预防和处理内存泄漏是编程中的重要任务之一。
2. 常见的内存泄漏情况及其原因 循环引用：循环引用是指两个或多个对象互相引用，而没有被外部访问。由于这些对象互相引用而不被释放，导致内存泄漏问题。例如，两个对象互相引用并且同时持有一个长时间的生命周期，那么这些对象将永远不会被回收，从而导致内存泄漏。
长生命周期对象持有短生命周期对象的引用：这种情况是指一个长生命周期的对象（如全局变量或静态变量）持有短生命周期对象的引用。由于长生命周期对象的生命周期比短生命周期对象长，因此可能导致短生命周期对象无法被回收，从而造成内存泄漏。
未正确释放资源或关闭连接：这种情况通常发生在网络编程或文件处理等领域中。例如，当一个网络连接被打开但未正确关闭时，会导致该连接占用的内存无法被释放。
四、如何避免和处理内存泄漏 1. 使用合适的数据结构和算法 选择合适的数据结构和算法可以有效地减少内存泄漏的发生。了解数据结构和算法的特性，如生命周期、内存占用等，可以帮助程序员更好地管理内存。
2. 及时释放资源和关闭连接 在程序中，及时释放不再使用的资源，如文件、网络连接等，以避免资源泄漏。同时，对于需要关闭的连接，一定要在不再使用时进行关闭，以便操作系统可以回收相关资源。
3. 避免循环引用和多余的对象引用 对于可能出现循环引用的场景，应尽量避免。例如，使用弱引用代替强引用，或者使用智能指针等方式，可以有效地解决循环引用的问题。
4. 使用内存泄漏检测工具及测试策略 使用内存泄漏检测工具可以帮助程序员定位和发现内存泄漏的问题。通过制定合理的测试策略，如内存泄漏检测、压力测试等，可以有效地发现和修复内存泄漏的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28b90ca8d90cb691cb5650687508dade/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f77f78c6ca0a4e52d482e251d71b8abe/" rel="bookmark">
			latex如何写中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 非常简单 添加一个宏包
\usepackage{ctex} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b99395b6dcc32c5e39855a2c50443c4/" rel="bookmark">
			Failed to configure a DataSource: ‘url‘ attribute is not specified and no embedded datasource could
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题描述 在学习springcloud课程中，在连接Nacos配置中心时，把配置文件上传到Nacos后，启动项目报错，springboot项目报错为：Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.
Reason: Failed to determine a suitable driver class
仔细检查配置文件后发现没有任何配置问题
报错内容为：配置数据源失败:没有指定'url'属性，无法配置任何嵌入的数据源。
2.问题分析 这里我使用的cloud版本是2021.0.5,Nacos版本是2021.1.0
报错原因是新版的SpringCloud默认没有安装bootstrap依赖，因此不能读取项目bootstrap.yml文件内容，间接导致不能读取Nacos配置内容引发的读取不到数据库url报错。
3.问题解决 添加spring-cloud-starter-bootstrap依赖
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc54dfba6efb9d6b7b1e8cbc06902137/" rel="bookmark">
			7系列FPGA数据手册:概述------中文翻译版总体介绍7系列FPGA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7系列FPGA数据手册:概述------中文翻译版 总体介绍7系列FPGA功能摘要Spartan-7系列FPGA功能摘要Artix-7系列FPGA功能摘要Kintex-7系列FPGA功能摘要Virtex-7系列FPGA功能摘要堆叠式硅互联（SSI）技术CLBs, Slices, and LUTs时钟管理 混合模式时钟管理器与锁相环MMCM附加的可编程功能时钟分配 全局时钟线区域时钟I/O时钟Block RAM 同步操作可编程数据宽度错误检测和纠正FIFO控制器Digital Signal Processing---DSP slice输入/输出 I/O电气特性三态数控阻抗和低功耗I/O特性I/O逻辑 输入输出延迟ISERDES和OSERDES低功耗G比特收发器 发送器接收器带外信号传输用于PCI Express设计的集成接口模块配置加密、回读和部分重配置XADC（数模转换器）7 Series FPGA Ordering Information 总体介绍 Xilinx®7系列FPGA包括四个系列（Spartan®,Artix®-7,Kintex®-7,Virtex®-7），能够满足系统全部范围的要求，价格低廉，尺寸小，对成本敏感，超高端的连接带宽，逻辑容量及信号处理能力的大量应用，满足了系统对高性能的要求。7系列的FPGA包括：
Spartan®-7系列：价格低廉，供电电源低，I/O性能高。可提供低成本，非常小的外形尺寸封装，以实现最小的PCB占地面积。Artix®-7系列：针对需要串行收发器以及高DSP和逻辑吞吐量的低功耗应用进行了优化。为高吞吐量、成本敏感型应用提供最低的总物料成本。Kintex®-7系列：针对最佳性价比进行了优化，与上一代产品相比提高了两倍，支持新一代的FPGA。Virtex®-7系列：针对最高系统性能和容量进行了优化，系统性能提高了两倍。通过硅堆叠技术（SSI）实现的最高性能器件。 7系列FPGA采用最先进的高性能、低功耗（HPL）、28nm、高k金属栅（HKMG）工艺技术，I/O带宽为2.9TB/s，逻辑单元容量为200万个，DSP定点运算性能为5.3TMAC/s，[其中Virtex-7系列的DSP处理能力为5,335 GMAC/s（GMAC/s：每秒10亿次乘加运算）]，实现了无与伦比的性能提升，同时功耗比前一代器件低50%，为ASSP（Application Specific Standard Parts 专用标准产品）和ASIC提供了完全可编程的替代方案。
7系列FPGA功能摘要 先进的高性能FPGA逻辑，基于可配置为分布式内存的实6输入查找表（LUT）技术；36KB双端口块RAM 内置FIFO逻辑，用于片上数据缓冲；高性能SelectIOTM技术，支持高达1866Mb/s的DDR3接口；内置多千兆收发器实现高速串行连接，最高可达600Mb/s。针对6.6Gb/s至28.05Gb/s的速率，提供特殊的低功耗模式，并对芯片间的接口做了优化。用户可配置模拟接口（XADC），集成12位1Msps带片上热传感器和电源传感器的模数转换器；带有25×18乘法器、48位累加器和前值加法器的DSP片可实现高性能滤波，包括优化的对称系数滤波；强大的时钟管理模块（CMT），结合锁相环（PLL）和混合模式时钟管理器（MMCM），可实现高精度和低抖动；利用MicroBlazeTM处理器快速部署嵌入式处理器；适用于PCI Express®（PCIe）的集成块，最多可支持×8 Gen3端点和根端口设计；多种配置选项，包括支持商用存储器、带HMAV/SHA-256（加密算法）身份验证的256位AES（Advanced Encryption Standard高级加密标准）加密，内置SEU检测和纠正。低成本、线耦合、裸芯倒片封装和高信号完整性倒片封装，可在同一封装系列的产品之间轻松移植。所有封装均提供无铅封装和精选含铅封装选项；专为高性能和低功耗而设计，具有28nm、HKMG、HPL工艺、1.0V核心电压工艺技术和0.9V电压选项，可实现更低功耗。 表1：7系列FPGA比较
注释：
以分布式RAM形式提供额外内存。峰值DSP性能是基于对称滤波器实现的。MicroBlaze CPU的峰值性能是基于微控制器预置来实现的。 Spartan-7系列FPGA功能摘要 表2：按型号划分的Spartan-7 FPGA功能摘要
注释：
1.每个7系列FPGA包含4个LUT和8个触发器；只有某些片可以将它们的LUT用作分布式RAM或SRL（移位寄存器）。
2.每个DSP片包括一个前置加法器、一个25×18乘法器、一个加法器和一个累加器。
3.Block RAM的大小基本上为36KB；每个BRAM也可以用作两个独立的18KB Blocks。
4.每一个CMT包含一个MMCM和一个PLL。
5.不包括配置库0。
表3 Spartan-7 FPGA封装组合及最大I/O数
注释：
1.HR=高范围I/O，支持1.2V到3.3V的I/O电压。
Artix-7系列FPGA功能摘要 表四：按型号划分的Artix-7 FPGA功能摘要
注释：
每个7系列FPGA包含4个LUT和8个触发器；只有某些片可以将它们的LUT用作分布式RAM或SRL（移位寄存器）。每个DSP片包括一个前置加法器、一个25×18乘法器、一个加法器和一个累加器。Block RAM的大小基本上为36KB；每个BRAM也可以用作两个独立的18KB Blocks。每一个CMT包含一个MMCM和一个PLL。Artix-7系列FPGA接口块用作PCIe时，最多支持x4 Gen 2。不包括配置库0。此数字不包括GTP收发器。
表五：Artix-7 FPGA封装组合及最大I/O数
1.所有列出的封装均为无铅封装（SBG、FBG、FFG、除了15）。一些封装在有铅选项中可用。
2.FGG484和FBG484引脚兼容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc54dfba6efb9d6b7b1e8cbc06902137/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2bf619298d4550a860ca7924c2112f2/" rel="bookmark">
			出现Browse information of one xxxx解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不良现象如下：
Browse information of one or more files is not available:
Doing a project rebuild might fix this.
解决的方法：将C文件里面的内容全部注释掉，再编译正常。
然后再将注释掉的代码打开，再次编译就正常了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1153da38fd37f20ba242099c5e458792/" rel="bookmark">
			C&#43;&#43; 一种数组快速排序方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言
（1）分治算法
快速排序，其实是一种分治算法，那么在了解快速排序之前，我们先来看看什么是分治算法。在算法设计中，我们引入分而治之的策略，称为分治算法，其本质就是将一个大规模的问题分解为若干个规模较小的相同子问题，分而治之。
（2）分治算法解题方法
1.分解：
将要解决的问题分解为若干个规模较小、相互独立、与原问题形式相同的子问题。
2.治理：
求解各个子问题。由于各个子问题与原问题形式相同，只是规模较小而已，而当子问题划分得足够小时，就可以用简单的方法解决。
3.合并：
按原问题的要求，将子问题的解逐层合并构成原问题的解。
二、快速排序
1.问题分析
快速排序是比较快的排序方法。它的基本思想是通过一组排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据小，然后再按此方法对这两部分数据进行快速排序，整个排序过程可以递归进行，以此使所有数据变成有序序列。
2.算法设计
（1）分解：
先从数列中取出一个元素作为基准元素。一基准元素为标准，将问题分解为两个子序列，使小于或者等于基准元素的子序列在左侧，使大于基准元素的子序列在右侧。
（2）治理 ：
对两个子序列进行快速排序（递归快速排序）。
（3）合并：
将排好的两个子序列合并在一起，得到原问题的解。
（4）基准元素的选取：
①：取第一个元素。(通常选取第一个元素)
②：取最后一个元素
③：取中间位置的元素
④：取第一个、最后一个、中间位置元素三者之中位数
⑤：取第一个和最后一个之间位置的随机数 k (low&lt;=k&lt;=hight)
3.算法分析
假设当前的待排序的序列为 R[low,hight] ， 其中 low&lt;=hight。同时选取首元素为基准元素。
步骤一：选取首元素的第一个元素作为基准元素 pivot=R[low] ，i=low ，j=hight。
步骤二：从右向左扫描，找到小于等于 pivot 的数，如果找到，R[i] 和 R[j] 交换 ，i++。
步骤三：从左向右扫描，找到大于 pivot 的数，如果找到，R[i] 和 R[j] 交换，j--。
步骤四：重复 步骤二~步骤三，直到 j 与 i 的指针重合 返回位置 mid=i ，该位置的数正好是 pivot 元素。
至此换成一趟排序，此时以 mid 为界线，将数据分割为两个子序列，左侧子序列都比 pivot 数小，右侧子序列都比 pivot 数大，然后再分别对这两个子序列进行快速排序。 下面我将以序列（30，24，5，58，18，36，12，42，39）为例，进行图解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1153da38fd37f20ba242099c5e458792/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e8ab66ac0de574193b0d7cd2c9b932d/" rel="bookmark">
			详解Android 关机/重启流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文基于android 10源码分析
手机长按power键，弹出关机提示对话框，如下图
一、先来看长按power键执行的流程。
开机后先注册输入监听事件，长按power键时，kernel层会发出一个事件上来，该事件最终被InputDispatcher.handleReceiveCallback监听到
frameworks\native\services\inputflinger\InputDispatcher.cpp int InputDispatcher::handleReceiveCallback(int fd, int events, void* data) { InputDispatcher* d = static_cast&lt;InputDispatcher*&gt;(data); { .......... sp&lt;Connection&gt; connection = d-&gt;mConnectionsByFd.valueAt(connectionIndex); if (!(events &amp; (ALOOPER_EVENT_ERROR | ALOOPER_EVENT_HANGUP))) { ....... status_t status; for (;;) { uint32_t seq; bool handled; //收到完成分发的信号才跳出循环 status = connection-&gt;inputPublisher.receiveFinishedSignal(&amp;seq, &amp;handled); if (status) { break; } //完成分发循环 d-&gt;finishDispatchCycleLocked(currentTime, connection, seq, handled); gotOne = true; } ........ } ......... return 0; // remove the callback } // release lock frameworks\native\services\inputflinger\InputDispatcher.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e8ab66ac0de574193b0d7cd2c9b932d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/166deca07bd8c9233d3ff87c8bd1be8e/" rel="bookmark">
			Hydro OJ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hydro oj首页 引言 随着计算机科学与技术的迅猛发展，程序设计竞赛、算法训练以及编程能力评估等活动越来越受到关注。在这些活动中，一个高效、稳定的在线评测系统是必不可少的。Hydro OJ 就是为满足这一需求而设计的一个出色的在线评测系统。
1.Hydro OJ 是什么？ HydroOJ 是一个新兴的在线评测系统，目前尚处于发展阶段，正在维护 BZOJ 题库、CCF 真题题库及英文翻译。建站一年来已获得七千注册量、二十万评测量，域功能为数所大学与培训机构提供服务。下面列举其部分特点：
为开源项目 Hydro 的官方站，由 Hydro 开发组为 HydroOJ 提供技术支持。开源项目 Hydro（又名 vj5）继承了 Vijos(vj4) 的所有功能并进行了大幅度优化、扩展及加强。它支持域，训练计划，多语言页面，多网站主题，在线 IDE 等其他大部分 OJ 所不具备的功能。评测机 HydroJudge 支持子任务依赖，文件IO，子任务单独设置时空限制，多写法 Special Judge，交互，自定义评测脚本等功能。RemoteJudge（远端评测）已支持：Luogu，Codeforces，SPOJ，POJ，UOJ。并仍在不断增加对更多 OJ 平台的支持。通过域功能，用户可基于 HydroOJ 免费搭建一个功能同自建 OJ 几乎无差别的平台。其采用独立数据库，独立判题，完整管理权限，强大的权限组系统，同时可以自由引用官方的公开题目（包括 RemoteJudge 题库）创建比赛，作业和训练计划。由一台高性能实体服务器与三台分布在多国的反向代理服务器提供网站服务，使用腾讯云服务加速国内访问速度，使用 Cloudflare 代理抵抗网络攻击，为用户提供高速安全的网站访问体验。日常评测算力达 16 CPU核心，评测高峰期时启动伸缩组可达最高上百 CPU核心，配合评测优先级系统为用户提供高效稳定的评测服务与在线 IDE 自测服务。现有资金足以支持 HydroOJ 继续运行至少两年。 2.Hydro OJ的历史 在此，我将向大家介绍 Hydro 的前世今生。该项目前前后后耗时两年多，推翻两版设计，最终在逻辑上参考了 vj4 的优秀架构。
为解决 jd4 仅支持常规题目（无spj，无交互）的严重问题，最早从评测模块入手，创造了 jd5，并一直应用于 http://vijos.org。因站长无精力对新版代码进行完整review，vijos当前采用了 jd4+jd5 的混合评测方案，之后 jd5 改名为 HydroJudge。
评测模块完工后，咕了一个月，便开工后端主项目 Hydro。由于 Hydro 特色为插件扩展性，且无先例可以参考，因此在插件 API 设计上花费了很多功夫，也走了很多弯路。最终选定基于统一 EventBus 的 hook 方案。在主项目完工后，这时github存储库拥有了约20 star，项目也于 oj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/166deca07bd8c9233d3ff87c8bd1be8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8217eae251cebb1d61b67f5cace6e853/" rel="bookmark">
			[Android] AndroidManifest.xml 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自： https://www.cnblogs.com/shujk/p/14961572.html
正文： AndroidManifest.xml 是每个android程序中必须的文件，它位于整个项目的根目录。我们每天都在使用这个文件，往里面配置程序运行所必要的组件，权限，以及一些相关信息。
一、概述：
AndroidManifest.xml是Android应用的入口文件，它描述了package中暴露的组件（activities, services, 等等），他们各自的实现类，各种能被处理的数据和启动位置。 除了能声明程序中的Activities, ContentProviders, Services, 和Intent Receivers,还能指定permissions和instrumentation（安全控制和测试）。
二、结构图
&lt;?xmlversion="1.0"encoding="utf-8"?&gt; &lt;manifest&gt; &lt;uses-sdk/&gt; &lt;uses-configuration/&gt; &lt;uses-feature/&gt; &lt;uses-permission/&gt; &lt;permission/&gt; &lt;permission-tree/&gt; &lt;permission-group/&gt; &lt;instrumentation/&gt; &lt;supports-screens/&gt; &lt;application&gt; &lt;activity&gt; &lt;intent-filter&gt; &lt;action/&gt; &lt;category/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity-alias&gt; &lt;intent-filter&gt;&lt;/intent-filter&gt; &lt;meta-data/&gt; &lt;/activity-alias&gt; &lt;service&gt; &lt;intent-filter&gt;&lt;/intent-filter&gt; &lt;meta-data/&gt; &lt;/service&gt; &lt;receiver&gt; &lt;intent-filter&gt;&lt;/intent-filter&gt; &lt;meta-data/&gt; &lt;/receiver&gt; &lt;provider&gt; &lt;grant-uri-permission/&gt; &lt;meta-data/&gt; &lt;/provider&gt; &lt;uses-library/&gt; &lt;/application&gt; &lt;/manifest&gt; 三、详解
1、Manifest:属性
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.somnus.yunyi" android:sharedUserId="string" android:sharedUserLabel="string resource" android:versionCode="integer" android:versionName="string" android:installLocation=["auto" | "internalOnly" | "preferExternal"] &gt; &lt;/manifest&gt; A、xmlns:android
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8217eae251cebb1d61b67f5cace6e853/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eacf88fbfac786e6e88f9fa5dcdeb63e/" rel="bookmark">
			FPGA编译报错内容[Common 17-55] ‘set_property‘ expects at least one object.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： FPGA代码编译时报错
问题描述 编译报错内容[Common 17-55] ‘set_property’ expects at least one object.
原因分析： 当一个引脚存在于xdc文件中，但是工程的顶层模块的引脚里没有这个引脚时，就会报出这个错误
解决方案： 查找报错的这个引脚是否存在于工程的顶层模块的引脚列表中，
最大的可能是xdc中的引脚名与工程中的引脚名不一致，一般是拼写错误，或者误删了；
如果不小心将工程的顶层文件设置错误
那么就会爆出很多个[Common 17-55] ‘set_property’ expects at least one object.错误；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e79b4ebb7e0e232b2206936039377610/" rel="bookmark">
			YOLOv8最新改进系列：YOLOv8融合SwinTransformer模块，有效提升小目标检测效果！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLOv8最新改进系列 Transformer提出的论文戳这
详细的改进教程以及源码，戳这！戳这！！戳这！！！B站：AI学术叫叫兽 源码在相簿的链接中，动态中也有链接，感谢支持！祝科研遥遥领先！
截止到发稿，B站YOLOv8最新改进系列的源码包已更新了20种！
YOLOv8最新改进系列：YOLOv8融合SwinTransformer模块，有效提升小目标检测效果！ YOLOv8最新改进系列一、swin transformer概述二、YOLOv8融合SwinTransformer模块2.1 修改YAML文件2.2 新建SwinTransformer.py2.3 修改tasks.py2.3.1 导包2.3.2 注册 三、验证是否成功即可 一、swin transformer概述 上图是Swin Transformer的整体结构，非常像卷积的层级结构，分辨率每层变成一半，而通道数变成两倍。首先Patch Partition,就是VIT中等分成小块的操作；然后分成4个stage，每个stage中包括两个部分，分别是patch Merging（第一个块是线性层） 和Swin Transformer Block。patch Merging是一个类似于池化的操作，池化会损失信息，patch Merging不会。右图是Swin Transformer Block结构，和transformer block基本类似，不同的地方在多头自注意力MSA换成了窗口多头自注意力W-MSA和移动窗口多头自注意力SW-MSA，右图紫框。详细的内容可以去作者提出的文章了解。本文主要进行YOLOv8的优化。
二、YOLOv8融合SwinTransformer模块 2.1 修改YAML文件 # Ultralytics YOLO 🚀, AGPL-3.0 license # YOLOv8 object detection model with P3-P5 outputs. For Usage examples see https://docs.ultralytics.com/tasks/detect # Parameters nc: 80 # number of classes scales: # model compound scaling constants, i.e. 'model=yolov8n.yaml' will call yolov8.yaml with scale 'n' # [depth, width, max_channels] n: [0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e79b4ebb7e0e232b2206936039377610/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18023fb4ff49e077df52657211b972c9/" rel="bookmark">
			python执行cmd命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用subprocess 在python中，执行cmd命令，可以调用另一个python文件执行，方便使用argparser传参。执行的时候，cmd控制台不会弹出来。
def run_cmd(): # CMD命令 cmd_command = "dir" # 这只是一个例子，你可以替换成你需要的任何CMD命令 # 执行CMD命令 process = subprocess.Popen(cmd_command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) # 获取命令执行的结果 stdout, stderr = process.communicate() # 标准输出 # print(stdout.decode("gbk")) # 标准错误 # print(stderr.decode("gbk") == "") if process.returncode != 0: print(f'Error occurred: {stderr.decode()}') else: print(stdout.decode("gbk")) 其中，stdout 是返回的 cmd 输出结果，windows 中编码使用的是 gbk，使用 utf8 有些字符会转码错误并报错。下面是写的一个函数，基本的处理流程就是这样，如果报错的话，会返回None作为错误输出，正确执行的话，会返回输出的结果。
""" @:param cmd_command:cmd命令 @:return None or 代码执行的结果，即在cmd控制台的输出 """ def run_cmd_command(cmd_command): process = subprocess.Popen(cmd_command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) stdout, stderr = process.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18023fb4ff49e077df52657211b972c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64ec1c60ce3f2e04a53df7734f5c64e4/" rel="bookmark">
			黑客工具软件大全100套（非常详细）从零基础入门到精通，看完这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		黑客工具软件大全100套
1 Nessus：最好的UNIX漏洞扫描工具 Nessus 是最好的免费网络漏洞扫描器，它可以运行于几乎所有的UNIX平台之上。它不止永久升级，还免费提供多达11000种插件（但需要注册并接受EULA-acceptance–终端用户授权协议）。它的主要功能是远程或本地（已授权的）安全检查，客户端/服务器架构，GTK（Linux下的一种图形界面）图形界面，内置脚本语言编译器，可以用其编写自定义插件，或用来阅读别人写的插件。Nessus 3 已经开发完成（now closed source），其现阶段仍然免费，除非您想获得最新的插件。
2 Wireshark：网络嗅探工具 Wireshark （2006年夏天之前叫做 Ethereal）是一款非常棒的Unix和Windows上的开源网络协议分析器。它可以实时检测网络通讯数据，也可以检测其抓取的网络通讯数据快照文件。可以通过图形界面浏览这些数据，可以查看网络通讯数据包中每一层的详细内容。Wireshark拥有许多强大的特性：包含有强显示过滤器语言（rich display filter language）和查看TCP会话重构流的能力；它更支持上百种协议和媒体类型； 拥有一个类似tcpdump（一个Linux下的网络协议分析工具）的名为tethereal的的命令行版本。不得不说一句，Ethereal已经饱受许多可远程利用的漏洞折磨，所以请经常对其进行升级，并在不安全网络或敌方网络（例如安全会议的网络）中谨慎使用之。
3 Snort：一款广受欢迎的开源IDS（Intrusion Detection System）（**检测系统）工具 这款小型的**检测和预防系统擅长于通讯分析和IP数据包登录（packet logging）。Snort除了能够进行协议分析、内容搜索和包含其它许多预处理程序，还可以检测上千种蠕虫病毒、漏洞、端口扫描以及其它可疑行为检测。Snort使用一种简单的基于规则的语言来描述网络通讯，以及判断对于网络数据是放行还是拦截，其检测引擎是模块化的。 用于分析Snort警报的网页形式的引擎 Basic Analysis and Security Engine (BASE)可免费获得。
开源的Snort为个人、小企业、集团用户提供良好的服务。其母公司SourceFire提供丰富的企业级特性和定期升级以丰富其产品线。提供（必须注册）5天免费的规则试用，您也可以在Bleeding Edge Snort找到很多免费规则。
4 Netcat：网络瑞士军刀 这个简单的小工具可以读和写经过TCP或UDP网络连接的数据。它被设计成一个可靠的可以被其它程序或脚本直接和简单使用的后台工具。同时，它也是一个功能多样的网络调试和检查工具，因为它可以生成几乎所有您想要的网络连接，包括通过端口绑定来接受输入连接。Netcat最早由Hobbit在1995年发布，但在其广为流传的情况下并没有得到很好的维护。现在nc110.tgz已经很难找了。这个简单易用的工具促使了很多人写出了很多其它Netcat应用，其中有很多功能都是原版本没有的。其中最有趣的是Socat，它将Netcat扩展成可以支持多种其它socket类型，SSL加密，SOCKS代理，以及其它扩展的更强大的工具。它也在本列表中得到了自己的位置（第71位）。还有Chris Gibson’s Ncat，能够提供更多对便携设备的支持。其它基于Netcat的工具还有OpenBSD’s nc，Cryptcat，Netcat6，PNetcat，SBD，又叫做GNU Netcat。
5 Metasploit Framework：黑掉整个星球 2004年Metasploit的发布在安全界引发了强烈的地震。没有一款新工具能够一发布就挤进此列表的15强（也就是说2000年和2003年的调查没有这种情况），更何况此工具更在5强之列，超过了很多广为流传的诞生了几十年的老牌工具。它是一个强大的开源平台，供开发、测试和使用恶意代码。这种可扩展的模型将负载控制、编码器、无操作生成器和漏洞整合在一起，使得Metasploit Framework成为一种研究高危漏洞的途径。它自带上百种漏洞，还可以在online exploit building demo（在线漏洞生成演示）看到如何生成漏洞。这使得您自己编写漏洞变得更简单，它势必将提升非法shellcode代码的水平，扩大网络阴暗面。与其相似的专业漏洞工具，例如Core Impact和Canvas已经被许多专业领域用户使用。Metasploit降低了这种能力的门槛，将其推广给大众。
6 Hping2：一种网络探测工具，是ping的超级变种 这个小工具可以发送自定义的ICMP，UDP和TCP数据包，并接收所有反馈信息。它的灵感来源于ping命令，但其功能远远超过ping。它还包含一个小型的路由跟踪模块，并支持IP分段。此工具可以在常用工具无法对有防火墙保护的主机进行路由跟踪/ping/探测时大显身手。它经常可以帮助您找出防火墙的规则集，当然还可以通过它来学习TCP/IP协议，并作一些IP协议的实验。
7 Kismet：一款超强的无线嗅探器 Kismet是一款基于命令行（ncurses）的802.11 layer2无线网络探测器、嗅探器、和**检测系统。它对网络进行被动嗅探（相对于许多主动工具，例如NetStumbler），可以发现隐形网络（非信标）。它可以通过嗅探TCP、UDP、ARP和DHCP数据包来自动检测网络IP段，以Wireshark/TCPDump兼容格式记录通讯日志，更加可以将被检测到的网络分块并按照下载的分布图进行范围估计。如您所想，这款工具一般被wardriving所使用。嗯！还有warwalking、warflying和warskating……
8 Tcpdump：最经典的网络监控和数据捕获嗅探器 在Ethereal（Wireshark）出现之前大家都用Tcpdump，而且很多人现在还在一直使用。它也许没有Wireshark那么多花里胡哨的东西（比如漂亮的图形界面，亦或数以百计的应用协议逻辑分析），但它能出色的完成很多任务，并且漏洞非常少，消耗系统资源也非常少。它很少添加新特性了，但经常修复一些bug和维持较小的体积。它能很好的跟踪网络问题来源，并能监控网络活动。其Windows下的版本叫做WinDump。Libpcap/WinPcap的包捕获库就是基于TCPDump，它也用在Nmap等其它工具中。
9 Cain and Abel：Windows平台上最好的密码恢复工具 UNIX用户经常声称正是因为Unix平台下有很多非常好的免费安全工具，所以Unix才会成为最好的平台，而Windows平台一般不在他们的考虑范围之内。他们也许是对的，但Cain &amp; Abel确实让人眼前一亮。这种只运行于Windows平台的密码恢复工具可以作很多事情。它可以通过嗅探网络来找到密码、利用字典破解加密密码、暴力破解密码和密码分析、记录VoIP会话、解码非常复杂的密码、星号查看、剥离缓存密码以及分析路由协议。另外其文档也很齐全（well documented）。
10 John the Ripper：一款强大的、简单的以及支持多平台的密码破解器 John the Ripper是最快的密码破解器，当前支持多种主流Unix （官方支持11种，没有计算不同的架构）、DOS、Win32、BeO和OpenVMS。它的主要功能就是检测弱Unix密码。它支持主流Unix下的多种（3种）密码哈希加密类型，它们是Kerberos、AFS以及Windows NT/2000/XP LM。其它哈希类型可以通过补丁包加载。如果您希望从一些单词表开始的话，您可以在这里、这里和这里找到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64ec1c60ce3f2e04a53df7734f5c64e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1d6737d61f044b873b3b96b8d6dd295/" rel="bookmark">
			报错Dependency ‘com.alibaba.cloud:spring-cloud-alibaba-dependencies:2021.0.5.0‘ not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习springcloud的时候跟着老师创建项目，在maven中导入springcloud依赖和springcloudAlibaba依赖的时候，maven坐标一直爆红，刚开始以为是springcloud和springcloudAlibaba的版本有问题，这里我说一下我jdk使用的是11，maven是3.3.9.springboot是2.7.15，springcloud和springcloudAlibaba使用的是2021.0.5，我换了很多个版本都没有用。编译之后控制台报错为Dependency 'com.alibaba.cloud:spring-cloud-alibaba-dependencies:2021.0.5.0' not found
解决办法：我最后一次挣扎是去重新下载一个高版本的maven，当我下载好maven之后更改了原来的maven本地仓库的名字之后，在idea中settings中有重新更新了一下maven本地仓库的地址，更新完之后，idea自动刷新，然后就好了；
总结一下：这个问题的出现只要不是版本问题就大概率是maven仓库的问题，可以修改一下本地maven仓库的地址，或者把本地的maven仓库清除一下重新在idea中配置，这个坑让我找了大概两个小时，真不容易啊
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc7275c346f77278e245645fe721c98a/" rel="bookmark">
			复制文件到Docker容器内
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker cp 命令用于在Docker容器之间复制文件或目录。
举例说明：
假设一个运行的容器ID为9a28f199688e，想要将本地文件/path/to/local-file 复制到容器中的 /path/to/destination 目录中。
执行命令如下：
docker cp /path/to/local-file 9a28f199688e:/path/to/destination 还可以使用 -a 选项来递归复制整个目录：
docker cp -a /path/to/local-directory 9a28f199688e:/path/to/destination 这将把本地目录 /path/to/local-directory 中的所有文件和子目录复制到容器的 /path/to/destination 目录中。
请注意，容器必须已经启动并且必须在运行中才能使用docker cp 命令。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a3b16304eb276a77936667e90547972/" rel="bookmark">
			vue3中，封装el-select选择器组件(一)——表单四等分布局、查询、重置resetFields、el-date-picker起止日期、特殊字符校验、自定义指令v-throttle用于按钮防抖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3中，封装el-select选择器组件(一)——表单四等分布局、查询、重置resetFields、el-date-picker起止日期、特殊字符校验、自定义指令v-throttle用于按钮防抖 效果
1-流程状态
2-牵头单位
3-系统内单位角色
页面文件 index.vue
&lt;template&gt; &lt;div class="main-content"&gt; &lt;el-form ref="formRef" class="inline-form" label-position="right" label-width="130px" :model="formInline" &gt; &lt;el-form-item class="width25" label="项目名称：" prop="prjName"&gt; &lt;el-input v-model="formInline.prjName" maxlength="100" placeholder="请输入" @input="(e) =&gt; (formInline.prjName = replaceCommonText(e))" /&gt; &lt;/el-form-item&gt; &lt;el-form-item class="width25" label="开始时间："&gt; &lt;el-date-picker v-model="prjDate" end-placeholder="结束日期" format="YYYY-MM-DD" placeholder="请选择" range-separator="至" start-placeholder="开始日期" type="daterange" value-format="YYYY-MM-DD" /&gt; &lt;/el-form-item&gt; &lt;el-form-item class="width25" label="牵头单位：" prop="leadUnit"&gt; &lt;unitSelect v-model="formInline.leadUnit" v-model:contrUnitName="formInline.leadUnitName" @change-unit="handleUnitChange" /&gt; &lt;/el-form-item&gt; &lt;el-form-item class="width25" label="系统内单位角色：" prop="innerRole"&gt; &lt;dictSelect v-model="formInline.innerRole" :dictid="'sgCompRole'" /&gt; &lt;/el-form-item&gt; &lt;el-form-item class="width25" label="流程状态：" prop="processState"&gt; &lt;dictSelect v-model="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a3b16304eb276a77936667e90547972/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/397f5d96dee433a97f937384fdd770ec/" rel="bookmark">
			linux 安装bazel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网上找了很多安装教程，但都安装失败了，主要是网络问题。 使用华为的镜像源安装就很快 下载软件包 curl -O https://mirrors.huaweicloud.com/bazel/6.0.0/bazel_6.0.0-linux-x86_64.deb 安装软件包 sudo dpkg -i bazel_6.0.0-linux-x86_64.deb 检查是否安装成功 bazel --version 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66cf1036a17d2a9901af0d9a6c1e9431/" rel="bookmark">
			强大易用的开源 建站工具Halo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		特点 可插拔架构 Halo 采用可插拔架构，功能模块之间耦合度低、灵活性提高。支持用户按需安装、卸载插件，操作便捷。同时提供插件开发接口以确保较高扩展性和可维护性。
☑ 支持在运行时安装和卸载插件
☑ 更加方便地集成三方平台
☑ 统一的可配置设置表单
☑ 支持自定义模型，自动生成 RESTful API
功能丰富的主题机制 Halo 提供完整的主题模板机制，用于构建前台界面。这意味着用户可以根据自己的喜好选择不同类型的主题模板来定制化自己的站点外观。
☑ 动态切换主题模板
☑ 支持实时编辑和预览效果
☑ 多语言支持
☑ 与插件配合实现更多功能
编辑器 Halo 的富文本编辑器提供了方便丰富的功能，包括添加标题、段落、引用、列表、代码块等元素，并支持设置样式属性、上传图片、插入视频等功能。这些工具让你的文章创作更加便捷和生动。
☑ 完备的富文本格式支持
☑ 支持拖拽和粘贴图片上传
☑ 支持通过插件扩展编辑器
更多特性 代码开源
Halo 的项目代码开源在 GitHub 上且处于积极维护状态，截止目前已经发布了 109 个版本。你也可以在上面提交你的问题或者参与代码贡献。
易于部署
推荐使用 Docker 的方式部署 Halo，便于升级，同时避免了各种环境依赖的问题。统一管理在工作目录中的应用数据也能方便地进行备份和迁移。
插件机制
支持在插件运行时为系统添加新功能，同时保持 Halo 自身的简洁轻量。这种灵活的插件机制让用户根据自身需求自由扩展 Halo 的功能，帮助用户实现富有想象力的站点。
模板机制
支持自定义配置、主题预览、多语言等功能。这种灵活的模板系统让用户可以针对自己的需求进行自定义配置，为网站带来更加个性化的外观和交互体验。
附件管理
支持多种存储策略，并支持通过插件扩展外部存储位置，可以让用户更加灵活地地上传、查看和管理附件。
搜索引擎
内置全文搜索引擎，支持关键字搜索文章和页面内容。同时支持通过插件扩展外部搜索引擎，做到让用户按需选择、自由扩展。
部署 快速部署
docker run -it -d --name halo -p 8090:8090 -v ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66cf1036a17d2a9901af0d9a6c1e9431/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad2ca3412e49cbf7093a89404b346843/" rel="bookmark">
			vue——项目中加载public中的静态资源——技能提升
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue——项目中加载public中的静态资源 应用场景需求分析代码1.`antd-design-vue`的代码如下：2.通过接口获取到数据后，给activeKey赋值为tab列表的第一项3.切换`tab`时触发的`callback`方法 `public`文件中存放的`html`页面打包后`dist`文件夹中的`html`页面重点是加载同一个页面时，今天和昨天的页面中数据略有不同时，浏览器缓存的问题，是否可以通过给页面添加`时间戳`的形式来破解，等我测试后再来说明。 应用场景 在写后台管理系统的时候，遇到一个需求就是关于热力图的功能，需要加载不同的页面，这个页面需要每日更新一次，所以请求页面html的最终解决办法就是：将页面html+对应的文件夹，放在public文件夹中，打包后生成的文件会存放在dist文件夹中。在项目中使用此页面路径的时候，直接通过’html页面名称’的方式就可以拿到了。
需求分析 如下图所示：每一个tab标签都表示一个html页面，点击对应的tab，下方就要展示对应的html页面的内容。
代码 1.antd-design-vue的代码如下： &lt;a-tabs type="card" v-model="activeKey" @change="callback"&gt; &lt;a-tab-pane v-for="item in data" :key="item.url" :tab="item.url"&gt; &lt;/a-tab-pane&gt; &lt;/a-tabs&gt; &lt;iframe :src="src" v-if="src" frameborder="0" width="100%" height="1000" id="iframeId" &gt;&lt;/iframe&gt; 2.通过接口获取到数据后，给activeKey赋值为tab列表的第一项 this.activeKey = this.data &amp;&amp; this.data[0] &amp;&amp; this.data[0].url; this.src = this.data &amp;&amp; this.data[0] &amp;&amp; this.data[0].url + '?' + new Date().getTime();//通过?+时间戳的方式来防止浏览器缓存的出现 3.切换tab时触发的callback方法 callback(val) { this.src = ''; setTimeout(()=&gt;{ this.src = val + '?' + new Date().getTime(); },200) }, public文件中存放的html页面 打包后dist文件夹中的html页面 重点是加载同一个页面时，今天和昨天的页面中数据略有不同时，浏览器缓存的问题，是否可以通过给页面添加时间戳的形式来破解，等我测试后再来说明。 完成！！！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad2ca3412e49cbf7093a89404b346843/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a92e0049e454e1fdddd6737821b883c/" rel="bookmark">
			github.com网站提示无法访问此页面——亲测有效（已解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在看stepin-template的vue3版本，发现这个后台框架还是有很多不足的地方。于是想要提交一个关于菜单折叠展开的issue。
github.com网站提示无法访问此页面 效果图1.打开命令提示符窗口，`ping github.com`2.在电脑`hosts`文件中添加`ip地址 github.com`2.1 `hosts`文件的位置：`C:\Windows\System32\drivers\etc`2.2 修改此文件需要管理员权限2.2.1 一种方式——以管理员身份运行记事本，打开`hosts`文件修改2.2.2 一种方式——用`vscode`软件打开`hosts`文件 **`经过上面的两步后，还是提示无法访问！！！`**3.刷新DNS缓存 效果图 但是一打开github.com网站，就提示下图了：
于是百度搜索解决办法：
附上大神提供的解决办法：github.com网站无法访问：https://zhuanlan.zhihu.com/p/500450465
我这边的处理方法也记录一下：
1.打开命令提示符窗口，ping github.com 通过ping github.com的方式获取ip地址：
2.在电脑hosts文件中添加ip地址 github.com 2.1 hosts文件的位置：C:\Windows\System32\drivers\etc 选择此文件，右击“打开方式”，选择以“记事本”格式打开。
在此文件的最后添加：此时的的ip就是上面ping到的github.com的ip
但是此时保存时，提示没有权限，有的打开的时候就会提示没有权限。
2.2 修改此文件需要管理员权限 2.2.1 一种方式——以管理员身份运行记事本，打开hosts文件修改 在电脑上检索“记事本”，右击“以管理员身份运行”，然后点击记事本中的打开，找到刚才的hosts文件，此时在进行编辑即可保存成功。
2.2.2 一种方式——用vscode软件打开hosts文件 修改后有下角会提示是否以管理员身份编辑，点击是即可保存成功。
经过上面的两步后，还是提示无法访问！！！ 于是，我根据文章开头找到的大神的操作链接，进行了第三步操作。
3.刷新DNS缓存 看到评论说可能还需要刷新dns缓存，可以先不刷新看看情况，如果不可以就再刷新。
步骤为：win（就是键盘上左下角有4个方块的键）+r，打开运行窗口，输入cmd打开窗口，输入ipconfig /flushdns后回车即可。
成功！！！多多积累，多多收获！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bebafcf83f54130a575142cf06359f61/" rel="bookmark">
			安装WSL2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是WSL2 WSL2是Windows Subsystem for Linux的第二个版本，是一个为Windows系统提供Linux运行环境的子系统。WSL2相比于早期版本，采用了全新的虚拟化技术，使得在Windows系统下运行Linux应用程序的速度比之前更快，同时能够提供更好的文件系统性能。
WSL 2使用Linux内核，这也是它相比于早期版本的一个最重要的改进。这意味着，WSL 2现在可以运行更多的Linux应用程序，包括那些需要内核支持的应用程序。而且WSL2通过Hyper-V虚拟技术运行，可以在Windows系统内部运行，响应更为迅速。
二、wsl2安装步骤 1、硬件虚拟化 Hyper-V 是 Microsoft 的硬件虚拟化产品。 它用于创建并运行计算机的软件版本，称为“虚 拟机”。
开启电脑的虚拟化，一般电脑都是默认开启的。可以在 任务管理器-&gt;性能-&gt;CPU下查看虚拟化是否开启。
2、查看Hyper-v是否开启 启用Hyper-v可以在电脑中配置虚拟机。开启步骤：控制面板-&gt;程序-&gt;启用或关闭Windows 功能-&gt;把Hyper-v勾上-&gt;最后重启电脑就可以了。
a. 可能遇到的问题 —— 没有Hyper-V 解决方案：
首先，在PC上打开一个新的记事本文件。输入以下内容：
在“保存类型”下拉菜单中选择“所有文件(*.*)”。之后，为文件命名。然后，在末尾添加.bat扩展名以将其保存为批处理文件。确保末尾没有附加 .txt 或其他文件扩展名。最后，点击“保存”。
然后选择“以管理员身份运行”。
Hyper-V 安装完成后，重新启动 Windows 11 计算机。打开一个 Windows 功能窗口。向下滚动并启用 Hyper-V、windows虚拟机监控程序平台、适用于linux的Windows子系统、虚拟机平台。
3、WAL2安装步骤 有win系统要求：win10 2004及更高版本或win11。 a.启用适用于 Linux 的 Windows 子系统 需要先启用“适用于 Linux 的 Windows 子系统”可选功能，然后才能在 Windows 上安装 Linux 。
以管理员身份打开 PowerShell（“开始”菜单 &gt;“PowerShell” &gt;单击右键 &gt;“以管理员身份运行”），然后输入以下命令：
b.启用虚拟机功能 安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要虚拟化功能才能使用此功能。
以管理员身份打开 PowerShell 并运行：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bebafcf83f54130a575142cf06359f61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eaec5f5575d112bcf6498e887b6bc9e/" rel="bookmark">
			从零编写STM32H7的MDK SPI FLASH下载算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从零编写STM32H7的MDK SPI FLASH下载算法 - 知乎
Part1前言 当我们要下载编译好的镜像到Flash时，首先要做的一步就是选择合适的Flash下载算法，而这个算法本身就是一个FLM文件：
代码既可以下载到内部flash，也可以下载到外部flash，或者一部分下载到内部，一部分下载到外部。
Part2一、将代码中的图片资源下载到外部flash 在UI设计中往往需要大量的图片和字体，图片和字体资源在代码中以静态数组的形式存在，这些大数组在内部flash中一般存放不下，所以需要把这些占用资源比较大的数组放在外部flash中，然后通过QSPI地址映射的方式访问，或者通过SPI将flash中的资源分批读取到RAM缓存中使用。
通过MDK打开分散加载文件，配置“ExtFlashSection”段： ; ************************************************************* ; *** Scatter-Loading Description File generated by uVision *** ; ************************************************************* LR_IROM1 0x08000000 0x00020000 { ; load region size_region ER_IROM1 0x08000000 0x00020000 { ; load address = execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) .ANY (+XO) } RW_IRAM1 0x20000000 0x00020000 { ; RW data .ANY (+RW +ZI) } RW_IRAM2 0x24000000 0x00080000 { .ANY (+RW +ZI) } } LR_EROM1 0x90000000 0x01000000 { ; load region size_region ER_EROM1 0x90000000 0x01000000 { ; load address = execution address *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eaec5f5575d112bcf6498e887b6bc9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d48b792fa797a8e8768ae2105b42bd4/" rel="bookmark">
			Anaconda安装GPU版本pytorch(成功)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看电脑环境，选择CUDA版本 CUDA（Compute Unified Device Architecture）中文名为统一计算设备架构，，是显卡厂商NVDIV推出的运算平台，可以帮助GPU处理图形相关的计算问题。
我们可以通过在命令行输入以下命令来查看我们电脑的CUDA版本配置，下面可以看到我的CUDA版本为11.7若电脑没有独立显卡，则该命令输入无效
nvidia-smi CUDA版本： 11.7.99
安装GPU版的pytorch包。因为pytorch包需要与CUDA版本相匹配，所以需要根据自己机器的CUDA版本择对应版本的pytorch包进行安装CUDA 与驱动关系
创建conda环境 在指定路径创建虚拟环境
Anaconda改变虚拟环境安装路径
conda create -n pytorch-GPU python=3.7 # 创建一个python3.7的conda环境 conda activate pytorch-GPU # 进入该conda环境 换conda源, 清华镜像源 conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ 南京大学镜像https://mirror.nju.edu.cn/pub/anaconda/cloud/pytorch/win-64/
安装pytorch conda方法： 参考了一些文章：
conda安装GPU版pytorch，结果却是cpu版本[找到问题根源，从容解决]
conda安装GPU版pytorch，结果总是cpu版本
pytorch的文件名的普通命名格式:
一个在python=3.7conda 环境下，cudatoolkit=10.1版本的pytorch=1.7.0的文件名为pytorch-1.7.0-py3.7_cuda10.1.243_cudnn7.6.3_0.tar.bz2
我选择的版本如下：
python=3.8,cudatoolkit=11.7以及pytorch=2.0.0
conda install cudatoolkit=11.7 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/win-64/ pip安装（成功安装GPU版本） 官方下载whl
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d48b792fa797a8e8768ae2105b42bd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c5294e693deb128bad2f674e4ec7d96/" rel="bookmark">
			痞子衡嵌入式：恩智浦i.MX RT1xxx系列MCU硬件那些事（2.3）- 串行NOR Flash下载算法(J-Link工具篇)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/henjay724/p/13770137.html
大家好，我是痞子衡，是正经搞技术的痞子。今天痞子衡给大家介绍的是J-Link工具下i.MXRT的串行NOR Flash下载算法设计。
在i.MXRT硬件那些事系列之《在串行NOR Flash XIP调试原理》一文中，痞子衡简单提了一下串行NOR Flash下载算法的概念，并没有介绍具体设计细节，关于NOR Flash下载算法每个IDE/工具都有自己的一套设计，虽然基本设计理念是一样的，但是细节方面还是有区别，今天痞子衡就来细聊J-Link下的NOR Flash下载算法：
一、J-Link各版本对i.MXRT的支持 从Segger官网上看，目前最新的J-Link驱动版本是V6.86b，其能够支持目前所有已量产的i.MXRT系列，而痞子衡PC上安装的是V6.52e，从 J-Link历史各版本Release Note 上看，痞子衡目前的J-Link版本不支持全部i.MXRT型号，那么如果想要支持新芯片（比如i.MXRT1170），是不是一定要重新安装最新J-Link呢？其实未必！
版本发布时间支持芯片V6.842020-09-04i.MXRT1024V6.642020-03-13i.MXRT1170V6.602019-12-16i.MXRT1010V6.462019-05-23i.MXRT500、i.MXRT600V6.442019-03-01i.MXRT1015V6.402018-10-26i.MXRT1064V6.342018-08-07i.MXRT1060V6.322018-04-20i.MXRT1050、i.MXRT1020 J-Link对新MCU型号的下载支持并不是与自身版本严格绑定的，其增加新芯片的方式很灵活，只需要按要求添加相应的算法文件即可，这样我们可以不必等待Segger的正式发布。
二、为当前J-Link增加新i.MXRT型号支持 关于增加i.MXRT新型号的支持，痞子衡之前写过一篇文章 《轻松为i.MXRT设计更新Segger J-Link Flash下载算法文件》，简介了如何为v.6.52e版本新增i.MXRT600的支持（那篇文章其实有点疏忽，v6.52版本已经开始支持i.MXRT600，直接集成进JLinkARM.dll中了，没有显式地放在JLinkDevices.xml文件中）。
为当前J-Link驱动增加新i.MXRT型号支持，其实就是在 \SEGGER\JLink_V652e\JLinkDevices.xml 文件中按模板添加一些代码，至于那些代码是什么含义，在 \SEGGER\JLink_V652e\Doc\Manuals\UM08001_JLink.pdf 文档的 Chapter 12 Open Flashloader 有详细解释。
让我们试着分析 JLinkDevices.xml 文件中那些模板代码的含义，且以最常见的 i.MXRT1060 型号为例：
&lt;Device&gt; &lt;ChipInfo Vendor="NXP" Name="MIMXRT1062xxx6A" WorkRAMAddr="0x20000000" WorkRAMSize="0x00080000" Core="JLINK_CORE_CORTEX_M7" JLinkScriptFile="Devices/NXP/iMXRT106x/NXP_iMXRT106x.pex" Aliases="MIMXRT1062DVL6A" /&gt; &lt;FlashBankInfo Name="QSPI Flash" BaseAddr="0x60000000" MaxSize="0x04000000" Loader="Devices/NXP/iMXRT106x/NXP_iMXRT106x_QSPI.elf" LoaderType="FLASH_ALGO_TYPE_OPEN" /&gt; &lt;/Device&gt; 模板代码中参数主要分两类：ChipInfo和FlashBankInfo，前者描述算法适用的MCU芯片相关信息，后者描述在该MCU上适用的Flash操作相关信息。
先说ChipInfo下的参数：Vendor和Name主要是创建J-Flash工程或者在IDE里在线下载时弹出J-Link选项框时用于确定选择这个下载算法文件的标识。Core用于指定MCU芯片内核类型。JLinkScriptFile指定开始启用下载算法前需预加载的Jlink脚本（可以根据MCU特性做一些特殊的初始化工作，比如RT600的Debug Mailbox激活，RT1170的双核切换等）。Aliases就是Name的详细展开。
ChipInfo下最重要的两个参数其实是WorkRAMAddr和WorkRAMSize，它们指明了下载算法(某种elf格式文件)被加载进MCU内部SRAM执行的区域，这两个参数值与MCU型号息息相关，必须是合法有效的，但可以不唯一。后面的文章里痞子衡会介绍下载算法设计原理，其最重要的特性是Read-Only Position Independent和Read-Write Position Independent，即下载算法本身不是固定地址链接，而是位置无关链接，算法代码机器码是可以被放到任意地址去执行的。
再说FlashBankInfo下的参数：Name标明下载算法适用的Flash类型（FlashBankInfo可以有多个，对应不同Flash的下载算法）。BaseAddr和MaxSize标明该Flash在MCU系统内存映射中的地址范围，主要用于后续XIP调试，跟下载关系不大。Loader和LoaderType则指明下载算法文件位置和类型，这是核心，对于新i.MXRT型号的下载支持，大部分工作其实就是提供合适的Loader。
三、NOR Flash下载算法设计 前面讲了J-Link对于新i.MXRT型号的下载支持，其实就是提供合适的Loader文件，Loader文件的设计是核心，那么J-Link的Loader到底是怎么设计的呢？这得先从理解LoaderType这个参数说起。
搜遍整个UM08001_JLink文档，LoaderType仅有一个值，即FLASH_ALGO_TYPE_OPEN，文档里的解释是使用公开的Flashloader算法设计，这个公开的Flashloader指的是ARM官方的基于CMSIS的Flashloader。
ARM开源的Flashloader算法属于CMSIS-Pack 中的 Device Family Pack (DFP) 里的一个组成部分，它本来是专用于Keil MDK下的，但是Segger为了保持其J-Link工具链的通用性，选择了与ARM Flashloader的API接口保持一致，这意味着Keil MDK与J-Link两者的下载算法文件基本是可以交换使用的（当然设计上有一点小区别，后面文章会介绍）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c5294e693deb128bad2f674e4ec7d96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75e5f1d6e634d50b69f174661790326b/" rel="bookmark">
			Docker安装Redis(mac)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装docker 下载地址：Docker中文网 官网
下载完直接安装并移到应用目录中即可（对于docker的使用、配置等这不阐述）
二、安装Redis 2.1 搜索并拉取镜像 Redis官方网站 Redis
docker search redis 我们下载第一个官网认证的redis，官方镜像仓库地址 https://hub.docker.com/
2.2 安装 查看下载好的镜像
docker images 安装redis
docker run -d -p 6379:6379 --name redis8 redis 查看刚安装的redis
docker ps 查看版本号
docker exec -it redis8 redis-cli -v 到此简单的安装redis完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b9469fd4b5e0e5fcd0e27c13153de02/" rel="bookmark">
			nginx拦截指定的url
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在配置nginx规则拦截的时候我们要清楚自己的需求
需求如下：
外网地址：不能被访问
内网地址：能访问
外网地址如下：外网ip+端口/pac/pul/check （这里域名ip都可以）
内网地址如下：内网ip+端口/pac/pul/check (内网ip不做拦截)
nginx配置如下：
location /pac { if ( $request_uri = /pac/pul/chec) { return 404; } root html; index index.html index.htm; proxy_set_header X-real-ip $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header CLOUD-FORWORD-CLENT-IP-REMOTADDR $http_x_forwarded_for; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header REMOTE_PORT $remote_port; proxy_set_header Host 内网域名或者ip; proxy_pass 内网域名或者ip/gate/pac; client_max_body_size 30m; } 上面的配置和需求这里简单说明一下：
1、我们的环境有内网和外网之分，但是有些请求只能内网访问 外网不能访问
2、所有通过nginx localtion 配置添加判断条件 当外网访问等于我设定条件时返回指定错误响应码
此方法也可以用来判断 ip 域名等等
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51da3b9ab422ff541bd830a8f9b8de2e/" rel="bookmark">
			CMakeLists.txt快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：CMakeLists.txt的基本结构 编写CMakeLists.txt最常用的功能就是调用其他的.h头文件和.so/.a库文件，将.cpp/.c/.cc文件编译成可执行文件或者新的库文件。
命令的官方网站：CMake Reference Documentation
最常用的命令如下:
# 本CMakeLists.txt的project名称 # 会自动创建两个变量，PROJECT_SOURCE_DIR和PROJECT_NAME # ${PROJECT_SOURCE_DIR}：本CMakeLists.txt所在的文件夹路径 # ${PROJECT_NAME}：本CMakeLists.txt的project名称 project(xxx) # 获取路径下所有的.cpp/.c/.cc文件，并赋值给变量中 aux_source_directory(路径 变量) # 给文件名/路径名或其他字符串起别名，用${变量}获取变量内容 set(变量 文件名/路径/...) # 添加编译选项 add_definitions(编译选项) # 打印消息 message(消息) # 编译子文件夹的CMakeLists.txt # 当运行到add_subdirectory这一句时，会先将子文件夹进行编译 add_subdirectory(子文件夹名称) # 将.cpp/.c/.cc文件生成.a静态库 # 注意，库文件名称通常为libxxx.so，在这里只要写xxx即可 add_library(库文件名称 STATIC 文件) # 将.cpp/.c/.cc文件生成可执行文件 add_executable(可执行文件名称 文件) # 规定.h头文件路径 include_directories(路径) # 规定.so/.a库文件路径 link_directories(路径) # 对add_library或add_executable生成的文件进行链接操作 # 注意，库文件名称通常为libxxx.so，在这里只要写xxx即可 target_link_libraries(库文件名称/可执行文件名称 链接的库文件名称) 通常一个CMakeLists.txt需按照下面的流程：
project(xxx) #必须 add_subdirectory(子文件夹名称) #父目录必须，子目录不必 add_library(库文件名称 STATIC 文件) #通常子目录(二选一) add_executable(可执行文件名称 文件) #通常父目录(二选一) include_directories(路径) #必须 link_directories(路径) #必须 target_link_libraries(库文件名称/可执行文件名称 链接的库文件名称) #必须 除了这些之外，就是些set变量的语句，if判断的语句，或者其他编译选项的语句，但基本结构都是这样的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51da3b9ab422ff541bd830a8f9b8de2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34bb79c08f27d46215e965411e4590ed/" rel="bookmark">
			前端面试八股文（最新版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、基础（大概率不问）
1.如何理解HTML语义化的？
2.HTML5有哪些新标签
3. BFC是什么？
4. 如何实现垂直居中？
5. Css选择器的优先级如何确定？【背诵】
6. 如何清除浮动？
7. var/ let / const 区别
二、Js [基础概念]
7. JS 的数据类型有哪些？
8. 数组的方法有哪些？
9. 原型链是什么
10. this的指向 11. JS 的 new 做了什么【记忆】
12. JS 的立即执行函数是什么【概念题】
13. JS 的闭包是什么？怎么用？
14. JS 如何实现类？
15. JS 如何实现继承？
16. 判断数据类型的方法
17. 作用域和作用域链
18.事件流有三个阶段：
三、js 重点
1. 遍历数组
2. 排序方法
3. 数据去重
4. 深浅拷贝
一、基础（大概率不问） 1.如何理解HTML语义化的？ 语义化标签时写html标签的一种方法论。
段落要写成p标签，标题我会用h1-h6之间，文章呢用article,那么时间我会用time标签，画板会用kawasi标签。
优点：适合搜索引擎来检索，适合人类阅读利于团队维护
2.HTML5有哪些新标签 回答:平常用的就是header、atikou
延伸问题:Canvas 和SVG的区别?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34bb79c08f27d46215e965411e4590ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08960e8ff1ee3789566a3dcb1efb4066/" rel="bookmark">
			华为平板横屏双击右下角熄屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 华为平板在横屏模式下双击右下角会熄屏。可是是因为你开启了连点器之类的应用所导致的。
解决方式：
打开设置，找到【辅助功能】： 点击【无障碍】 滑到最下面找到【已安装的服务】 在里面找到自己的连点器软件 可以看到是开启状态，点击 我们可以将它关闭 此时会有弹窗，单击确定即可关闭 我们可以看到，此项服务已被关闭 改为横屏模式再次双击屏幕右下角，我们可以发现问题已经解决 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a319b816ab51f8946c46ad3e0bc9da70/" rel="bookmark">
			【Red Hat 7.9---详细安装Oracle 11g】---图形化界面方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Red Hat 7.9---详细安装Oracle 11g】---图形化界面方式 🔻 一、安装前规划🔻 二、安装前准备一（系统参数修改）⛳ 2.1 内核版本、系统版本查看⛳ 2.2 修改主机名-重启生效⛳ 2.3 关闭selinux⛳ 2.4 防火墙设置1521端口开放⛳ 2.5 系统相关配置检查2.5.1 🍁 修改/dev/shm 大小（/dev/shm空间不能小于分配给oracle使用内存的大小）2.5.2 🍁 /tmp（临时文件存储空间） &gt;1G2.5.3 🍁 /u01（软件安装目录） &gt;2.5G2.5.4 🍁 内核需求 ⛳ 2.6 系统光盘镜像文件挂载---配置本地yum源2.6.1 🍁 上传iso镜像文件并挂载到 /mnt/dvd/ 下2.6.2 🍁 备份yum源文件2.6.3🍁 本地yum源配置2.6.4🍁 验证本地yum源配置 ⛳ 2.7 Orange11g有关依赖包检查及安装⛳ 2.8 修改资源限制参数并使其生效⛳ 2.9 系统内核参数修改⛳ 2.10 用户创建进程数的限制 🔻 三、安装前准备（创建用户、用户组以及安装目录）⛳ 3.1 创建用户组⛳ 3.2 创建oracle用户和设置密码⛳ 3.3 创建安装目录⛳ 3.4 设置oracle用户环境变量⛳ 3.5 创建oracle安装文件所在目录 🔻 四、开始安装⛳ 4.1 配置更新以及技术支持⛳ 4.2 配置安装选项⛳ 4.3 选择网格安装选项⛳ 4.4 选择语言⛳ 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a319b816ab51f8946c46ad3e0bc9da70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47aa97cfc1a996b1fd1e84b96bc19683/" rel="bookmark">
			Elasticsearch：倒数排序融合 - Reciprocal rank fusion (RRF)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		警告：此功能处于技术预览阶段，可能会在未来版本中更改或删除。 Elastic 将尽最大努力修复任何问题，但技术预览中的功能不受官方 GA 功能的支持 SLA 约束。
倒数排序融合（RRF）是一种将具有不同相关性指标的多个结果集组合成单个结果集的方法。 RRF 无需调优，不同的相关性指标也不必相互关联即可获得高质量的结果。该方法的优势在于不利用相关分数，而仅靠排名计算。相关分数存在的问题在于不同模型的分数范围差。
使用 Reciprocal Rank Fusion (RRF) 的简化混合搜索 通常，最好的排名是通过组合多种排名方法来实现的，例如 BM25 和生成密集向量嵌入的 ML 模型。 在实践中，将结果集组合成一个单一的组合相关性排名结果集被证明是非常具有挑战性的。 当然，理论上你可以将每个结果集的分数归一化（因为原始分数在完全不同的范围内），然后进行线性组合，根据每个排名的分数加权和排序最终结果集方法。 只要你提供正确的权重，Elasticsearch 就支持它并且运行良好。 为此，你需要了解环境中每种方法得分的统计分布，并有条不紊地优化权重。 实际上，这超出了绝大多数用户的能力。
另一种方法是 RRF 算法，它提供了出色的排序方法零样本混合，正如学术研究所证明的那样。 如果你不了解不同方法中排名分数的确切分布，这不仅是最好的混合方式，而且客观上也是混合排名方法的好方法 —— 即使你知道如何归一化及分数的分布情况，也很难被击败。 基本概念是结果的组合顺序由每个结果集中每个文档的位置（和存在）定义。 因此可以方便地忽略排名分数。
Elastic 8.8 支持具有多个密集向量查询和在倒排索引上运行的单个查询的 RRF。 在不久的将来，我们希望支持来自 BM25 和 Elastic 的检索模型（两者都是稀疏向量）的混合结果，从而产生同类最佳的零样本集（无域内训练）排名方法。
​
D - 文档集R - 一组排名作为 1..|D| 的排列K - 通常默认设置为 60 RRF 使用以下公式来确定对每个文档进行排名的分数：
score = 0.0 for q in queries: if d in result(q): score += 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47aa97cfc1a996b1fd1e84b96bc19683/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f752f3ff6b86660a0088606dc192267c/" rel="bookmark">
			Qt编译MySQL驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简述 Qt默认没有MySQL驱动动态库，所以Qt开发时需要手动编译对应的MySQL驱动动态库。编译过程需要本地已经安装MySQL，安装对应路径有MySQL相关头文件。 环境
系统：Window10 64bitMySQL：mysql-5.6.24-win32（MySQL链接：https://cdn.mysql.com/archives/mysql-5.6/mysql-5.6.24-win32.zip）Qt：qt-opensource-windows-x86-5.12.12.exeVs：vs2017企业版 二、动态编译Qt MySql驱动 Qt安装时勾选Sources解压mysql-5.6.24-win32安装包，然后通过响应指令启动MySQL打开安装Qt的相应目录，例如：C:\Qt\Qt5.12.12\5.12.12\Src\qtbase\src\plugins\sqldrivers\mysql通过txt编辑器编辑mysql.pro 本文福利，莬费领取Qt开发学习资料包、技术视频，内容包括（C++语言基础，Qt编程入门，QT信号与槽机制，QT界面开发-图像绘制，QT网络，QT数据库编程，QT项目实战，QSS，OpenCV，Quick模块，面试题等等）↓↓↓↓↓↓见下面↓↓文章底部点击莬费领取↓↓ 编辑后结果：
TARGET = qsqlmysql HEADERS += $$PWD/qsql_mysql_p.h SOURCES += $$PWD/qsql_mysql.cpp $$PWD/main.cpp #QMAKE_USE += mysql #需要注释，否则报错 OTHER_FILES += mysql.json PLUGIN_CLASS_NAME = QMYSQLDriverPlugin win32:LIBS += -LD:/mysql-5.7.23-winx64/lib/ -llibmysql INCLUDEPATH += D:/mysql-5.7.23-winx64/include DEPENDPATH += D:/mysql-5.7.23-winx64/include #上面的D:/mysql-5.7.23-winx64，是自己对应的MySQL目录 include(../qsqldriverbase.pri) #需要添加最后这个include，否则提示：qtsqldrivers-config.pri no such file or directory 编译后驱动目录：C:\plugins\sqldrivers将libmysql.dll(这个动态库在MySQL的lib目录下)下载后复制到Qt的安装目录中E:\Qt\Qt5.12\5.12.0\mingw73_32\bin把生成目录C:\plugins\sqldrivers下面的动态库dll复制到“plugins\sqldrivers”目录(例如：C:\Qt\Qt5.12.12\5.12.12\msvc2017\plugins\sqldrivers) 测试验证：qt代码：
qDebug() &lt;&lt; QSqlDatabase::drivers(); 三、静态编译Qt MySql驱动 注意：静态编译Qt MySql驱动时，调用静态编译Qt环境的qmake。
第一步
源码包中目录：qtbase\src\plugins\sqldrivers\mysql
打开mysql.pro,对该文件进行修改：
TARGET = qsqlmysql CONFIG += static HEADERS += $$PWD/qsql_mysql_p.h SOURCES += $$PWD/qsql_mysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f752f3ff6b86660a0088606dc192267c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/997ed4652a948a40b601b3eab7ad6fcb/" rel="bookmark">
			kubernets_实战篇（minikube）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		minikube 一、前提准备1，安装工具 二、启动集群1，启动集群2，暴露Pod（1）kubernetes Service 类型 三、集群操作1，Pod操作2，启用插件3，清理集群资源 一、前提准备 本文环境是基于，在线k8s环境，linux ，x86_64
1，安装工具 安装 minikube ## 下载 curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-latest.x86_64.rpm sudo rpm -Uvh minikube-latest.x86_64.rpm ## 启动 minikube start --force 安装 kubectl curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl" install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl ## 检验版本 kubectl version --client 二、启动集群 1，启动集群 minikube start --froce ### 创建Deployment kubectl create deployment hello-node --image=registry.k8s.io/e2e-test-images/agnhost:2.39 -- /agnhost netexec --http-port=8080 2，暴露Pod 暴露Pod 为 kubernetes Service
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/997ed4652a948a40b601b3eab7ad6fcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee8744eeaa414ce7c0f532b100d2b1d6/" rel="bookmark">
			购物商场项目实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.项目开始 1）此项目为在线电商项目
2）包含首页，搜索列表，商品详情，购物车，订单，支付，用户登录/注册等多个子模块
3）使用Vue全家桶+ES6+webpack+Axios等前端技术
4）采用模块化，组件化，工程化的模式进行开发
2.项目展示 2.1项目功能页面展示： 2.2项目技术展示： 2.3项目路由展示： 2.4项目接口展示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd21206b2f415f61226ffc1af9ec8382/" rel="bookmark">
			Flink基础实操-计算单词出现次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🥇🥇【大数据学习记录篇】-持续更新中~🥇🥇
个人主页：beixi@
本文章收录于专栏（点击传送）：【大数据学习】
💓💓持续更新中，感谢各位前辈朋友们支持学习~
上一篇文章写到了Flink环境搭建，这篇文章接着上篇文章延伸Flink的使用-计算单词出现次数，如果Flink境没有搭建的小伙伴们可以参考我上一篇文章：大数据组件-Flink环境搭建
文章目录 1.环境介绍2.Scala交互统计：3.JAVA工程统计 1.环境介绍 本次用到的环境有：
**JDK1.8
Flink 1.13.0
Oracle Linux7.4
**
2.Scala交互统计： 1.启动flink进入 scala 交互模式。
start-scala-shell.sh local 2.输入脚本，求词频。
val wordcount=benv.readTextFile(“file:///root/experiment/datas/wordcount.txt”).flatMap(_.split("\t")).map((_,1)).groupBy(0).sum(1) wordcount.print 3.JAVA工程统计 打开IDEA集成开发工具：
选择 Create New Project菜单项，创建一个新的项目工程，在新的项目工程中选择窗口左侧的Maven菜单项，如图：
点击Next按钮，如下图：
输入框GroupId中填写experiment, 输入框ArtifactId中填写project，如下图：
点击Next按钮，如下图：
点击Finish按钮，如下图：
点击提示窗口中的close按钮，如下图：
在右下角弹出的对话框中，选择Enable Auto-Import（如未弹出该对话框请忽略此步骤）
更改pom.xml文件，如下图：
&lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;scala.binary.version&gt;2.11&lt;/scala.binary.version&gt; &lt;flink.version&gt;1.13.0&lt;/flink.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-java&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-clients_${scala.binary.version}&lt;/artifactId&gt; &lt;version&gt;${flink.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 鼠标点击项目中Java文件夹，单击右键选择New,子菜单中选择Package,如下图所示：
弹出对话框，如下图：
窗口输入框中填写创建的包名flink，如下图：
点击按钮OK，如下图：
鼠标点击包flink，单击右键选择New,子菜单中选择java Class,如下图所示：
弹出窗口，如下图： 16. 弹出窗口中填写类名，如下图：
17. 创建的WordCountJava类中，输入代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd21206b2f415f61226ffc1af9ec8382/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a14cfe139463c013b92de9d0b6288b4a/" rel="bookmark">
			mysql索引详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MySQL三层逻辑架构 MySQL的存储引擎架构将查询处理与数据的存储/提取相分离。下面是MySQL的逻辑架构图:
1、第一层负责连接管理、授权认证、安全等等。 每个客户端的连接都对应着服务器上的一个线程。服务器上维护了一个线程池，避免为每个连接都创建销毁一个线程。当客户端连接到MySQL服务器时，服务器对其进行认证。可以通过用户名和密码的方式进行认证，也可以通过SSL证书进行认证。登录认证通过后，服务器还会验证该客户端是否有执行某个查询的权限。
2、第二层负责解析查询 编译SQL，并对其进行优化(如调整表的读取顺序，选择合适的索引等)。对于SELECT语句，在解析查询前，服务器会先检查查询缓存，如果能在其中找到对应的查询结果，则无需再进行查询解析、优化等过程，直接返回查询结果。存储过程、触发器、视图等都在这一层实现。
3、第三层是存储引擎 存储引擎负责在MySQL中存储数据、提取数据、开启一个事务等等。存储引擎通过API与上层进行通信，这些API屏蔽了不同存储引擎之间的差异，使得这些差异对上层查询过程透明。存储引擎不会去解析SQL。
二、对比InnoDB与MyISAM 1、存储结构 MyISAM:每个MyISAM在磁盘上存储成三个文件。分别为:表定义文件、数据文件、索引文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD(MYData)。索引文件的扩展名是.MYI(MYIndex)。
InnoDB:所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件)，InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。
2、存储空间 MylSAM: MyISAM支持支持三种不同的存储格式∶静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。当表在创建之后并导入数据之后，不会再进行修改操作，可以使用压缩表，极大的减少磁盘的空间占用。
InnoDB:需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。
3、可移植性、备份及恢复 MyISAM:数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。InnoDB:免费的方案可以是拷贝数据文件、备份binlog，或者用mysqldump，在数据量达到几十G的时候就相对痛苦了。
4、事务支持 MyISAM:强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。
InnoDB:提供事务支持事务，外部键等高级数据库功能。具有事务(commit)、回滚(rollack)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
5、AUTO_INCREMENT MyISAM:可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。
InoDB: InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。
6、表锁差异 MyISAM:只支持表级锁，用户在操作myisam表时,select,update，delete，insert语句都会给表自动锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。
InnoDB:支持事务和行级锁，是inodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。
7、全文索引 MylSAM:支持FULLTEXT类型的全文索引
InnoDB:不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。
8、表主键 MylSAM:允许没有任何索引和主键的表存在，索引都是保存行的地址。
InnoDB:如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。
9、表的具体行数 MyISAM:保存有表的总行数，如果select count() from table;会直接取出出该值。
InnoDB:没有保存表的总行数，如果使用select count(*) from table;就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。
10、CRUD操作 MyISAM:如果执行大量的SELECT，MyISAM是更好的选择。
InnoDB:如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。
11、外键 MylSAM:不支持
InnoDB:支持
三、sql优化简介 1、什么情况下进行sql优化 性能低、执行时间太长、等待时间太长、连接查询、索引失效。
2、sql语句执行过程 （1）编写过程
select distinct ... from ... join ... on ... where ... group by .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a14cfe139463c013b92de9d0b6288b4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0a97626d975144d5befdb766030dab7/" rel="bookmark">
			Redisson——联合锁和红锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 联合锁和红锁放在一起来分析，是因为这两种锁实现在Redisson中，关联密切。
/** * Returns MultiLock instance associated with specified &lt;code&gt;locks&lt;/code&gt; * * @param locks - collection of locks * @return MultiLock object */ RLock getMultiLock(RLock... locks); /* * Use getLock method instead. Returned instance uses Redis Slave synchronization */ @Deprecated RLock getRedLock(RLock... locks); 红锁 上面getRedLock方法上有@Deprecated注解，说明在Redisson实现中，不推荐使用红锁。
简介 红锁是官方提出的一个锁方案，大概如下：
假设redis集群有5个节点，一个客户端申请锁时，会向所有的节点申请锁，只有大于一半的节点数量返回成功，且耗费的总时间小于锁有效时间，才会判定为拿锁成功，否则会被认定为失败，需要将已经成功的节点锁释放掉。
具体官方文档见：redis.io/topics/dist…
实现 RedissonRedLock继承了联合锁【RedissonMultiLock】，也没有重写核心方法。
/** * RedLock locking algorithm implementation for multiple locks. * It manages all locks as one. * * @see &lt;a href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0a97626d975144d5befdb766030dab7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec2a246ba39937919021c69799721717/" rel="bookmark">
			运行在JVM上的编程语言，认为只有java你就狭隘了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 公司国外市场部的同事，外包写了一个discord机器人！！！ 要我们配合部署，给了个jar；因为是部署到线上环境，为了安全让外包人员给了源码进行Review，git拉下来一看，国粹，什么鬼！！！ 抱着文件后缀，问了下强大的GPT，才知道原来不止是java语言可以运行在JVM上。。。 下面我就简单的介绍一下这种语言
二、运行在JVM上并与Java紧密集成的编程语言-Clojure Clojure 是一种动态函数式编程语言，它运行在 Java 虚拟机（JVM）上并与 Java 紧密集成。 Clojure 是由 Rich Hickey开发的，它结合了函数式编程的思想和强大的并发性能，提供了一种简洁、可扩展和可靠的编程语言。
以下是 Clojure 的一些主要特点和概念：
函数式编程：Clojure 是一门函数式编程语言，强调使用纯函数和不可变数据。它鼓励将计算视为函数的求值，避免副作用和可变状态，从而提高代码的可读性、可维护性和并发性。
不可变数据：在 Clojure 中，数据结构是不可变的，这意味着一旦创建，就无法修改。当对数据进行操作时，会返回一个新的数据结构，而不会改变原始数据。这种不可变性有助于避免竞态条件和共享状态的问题，并简化了并发编程。
持久化数据结构：Clojure 提供了一系列高效的持久化数据结构，如列表、矢量、集合和映射。这些数据结构在进行修改时可以共享大部分不变的部分，从而提供了高效的操作和内存使用。
Lisp 历史和语法：Clojure 是一门 Lisp 方言，它继承了 Lisp 的强大元编程能力和简洁的语法。Clojure 的代码以表达式的形式表示，并使用方括号来组织代码。这种语法使得 Clojure 具有强大的宏系统和代码生成能力。
并发编程：Clojure 提供了一些强大的并发编程工具，如原子（atom）、代理（agent）和软件事务内存（Software Transactional Memory，简称 STM）。这些工具使得编写并发代码变得更加简单和安全，可以有效地处理共享状态和多线程环境。
Java 互操作性：由于运行在 JVM 上，Clojure 可以无缝地与 Java 代码进行交互和集成。Clojure 可以直接调用 Java 类和方法，并且可以访问 Java 生态系统中丰富的库和工具。
社区支持和库生态系统：Clojure 拥有活跃的社区和丰富的库生态系统。有许多开源库可供选择，涵盖了各种领域，从 Web 开发到数据处理和科学计算。
Clojure 的设计目标是简洁、具有表达力和可靠性。它适用于各种应用场景，从命令行工具到大规模分布式系统。 作为一门函数式编程语言，Clojure提供了一种不同于传统命令式语言的思考方式，并且在并发编程方面具有很强的优势。
三、Clojure怎么打jar包 在 Windows 环境下，您可以使用 Leiningen 构建工具将 Clojure 代码打包成 JAR 文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec2a246ba39937919021c69799721717/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9de90c44739596f2b2852a951f21794/" rel="bookmark">
			深度思考rpc框架面经之一：基本组件和概览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 一个rpc框架应该具有哪些组件？ 一个RPC（远程过程调用）框架通常由以下几个组件组成：
通信协议（Communication Protocol）：RPC框架需要定义一种通信协议，用于客户端和服务器之间的通信。这个协议可以是自定义的二进制格式，也可以是像JSON-RPC、gRPC、Thrift等标准化的协议。
序列化和反序列化（Serialization/Deserialization）：在远程过程调用中，参数和返回值需要在网络上进行传输。因此，数据必须被序列化为通信协议所支持的格式，然后在接收端进行反序列化。这使得客户端和服务器能够将数据转换为字节流以进行传输，并将其还原为数据结构以供处理。
代理（Proxy）：客户端需要通过代理来调用远程服务器上的方法。代理隐藏了底层的网络通信细节，使得客户端能够像调用本地方法一样调用远程方法，这里的代理负责具体的发送请求动作
Stub（存根）：服务器端也需要处理客户端发送的请求。Stub在服务器端扮演了代理的角色，接收客户端请求，解析它们，并将其转发给实际的服务实现。同样，客户端也需要存根来完成接收服务端的请求，从字节流中反序列化数据，序列化数据发送给客户端。
服务接口定义（Service Interface Definition）：RPC框架需要定义一种服务接口描述语言，以明确定义服务提供的方法和参数。这可以是使用IDL（接口定义语言）或类似的方法。
服务注册和发现（Service Registration and Discovery）：在一个分布式环境中，服务的位置可能会经常变化，因此需要一种机制来注册和发现可用的服务。这可以通过集中式服务注册中心或分布式服务发现机制来实现。
负载均衡（Load Balancing）：当多个服务提供相同功能时，负载均衡是确保请求在它们之间平衡分配的机制。这有助于提高系统的可伸缩性和性能。
安全性（Security）：RPC框架需要提供一定程度的安全性，确保通信过程中的数据传输和访问不会受到未经授权的访问或恶意攻击。
故障处理（Fault Tolerance）：分布式系统中难免会遇到故障，RPC框架应该具备一些故障处理机制，例如重试、超时设置和错误处理，以保障系统的可靠性。
监控和日志（Monitoring and Logging）：为了方便排查问题和了解系统的运行状况，RPC框架应该支持监控和日志记录，收集关键的性能指标和事件信息。
这些组件共同构成了一个完整的RPC框架，使得分布式系统中的不同服务能够方便地进行通信和交互。不同的RPC框架可能会有一些特定的功能和特性，但总体来说，它们都应该满足上述基本要素。
1.2 什么是Stub存根 1.2.1 这里的存根是指什么，用于服务调用端还是提供端 存根（Stub）是RPC框架中的一个关键组件，它是服务调用的客户端与服务器端之间的一个中介。存根可以存在于两端：
客户端存根（Client Stub）：当客户端希望调用远程服务时，它实际上首先调用的是客户端存根。客户端存根负责：
将调用的方法和参数序列化为一种格式，这个格式能够通过网络传输。通过网络发送这个序列化后的请求到服务器端。接收服务器的响应，然后反序列化该响应以转换为客户端可用的格式。 服务器端存根（Server Stub）：服务器端收到客户端的请求后，是由服务器端存根来处理这个请求的。服务器端存根的职责包括：
从网络接收序列化后的请求数据。反序列化这个请求以获取原始的方法调用和参数。调用实际的服务实现。将结果序列化并发送回客户端。 从上述描述中可以看出，存根起到了在客户端和服务器端之间转化调用的桥梁作用。客户端通过存根发送请求，服务器端通过存根接收请求并发送响应。
在许多RPC框架中，存根是自动生成的，通常是基于服务的接口定义（如IDL - 接口定义语言）。这样做的目的是为了减少开发者的工作量，使他们能够专注于业务逻辑的实现，而不是通信的细节。
1.2.2 给我一个protocol buffer协议中规定生成的存根格式 Protocol Buffers（通常简称为protobuf）是Google开发的一种序列化协议。在protobuf的上下文中，当我们谈论“存根”时，通常是指gRPC（Google的远程过程调用系统）中用protobuf定义的服务的客户端和服务器代码。
以下是一个protobuf协议的简单示例，定义了一个HelloService服务：
syntax = "proto3"; package example; // The message format for a greeting. message HelloRequest { string name = 1; } message HelloResponse { string greeting = 1; } // The HelloService service definition.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9de90c44739596f2b2852a951f21794/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dca137183774ca2850cd629ca3061bb/" rel="bookmark">
			全网最详细的linux逻辑卷制作教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、为什么要制作逻辑卷？ 1、我们举个例子来说，比如我们我们在生产环境下有一块/dev/sdc 的磁盘挂在了/date 数据库目录下面，但是随着业务量的增加，我们需要对/date 目录进行扩容，如果我们制作了逻辑卷这时候我么只需要在已有的基础上在把新盘做成卷组加入到逻辑卷组当中，这样无论以后我们的/date 目录是否在新增也不怕了
反之，如果我们是直接就mount挂盘 那会导致我们如果想要对这个/date 目录进行扩容是没有办法扩容的 如果业务量增大的话 只能进行数据迁移，重新挂盘操作，但这样无疑是给我们的工作带来了无形中的压力。
其实制作逻辑卷用通俗的话来讲就是 我去买了两台电脑 一台电脑支持在原有基础上扩容 一台不支持在原有基础之上扩容（纯属个人理解但是感觉还是有点点不贴进实际情况，欢迎各位老铁发表自己的观点和看法）
二、本次逻辑卷制作均是使用虚拟机示范 1、打开虚拟机添加硬盘 点击硬盘
点击添加
到这里后面一般都默认选择下一步
因为这里是做示范所有20G已经足够了
查看是否添加成功 我这里已经多出来了一块硬盘说明我已经添加成功了
接下来启动虚拟机查看硬盘是否已经添加成功
现在我已经登录到了添加硬盘的node3主机
2、查看磁盘创建分区 通过命令lsblk 我们可以看到磁盘已经添加成功
查看现有磁盘情况，我们发现系统已经有一个21G的磁盘sdb， 还未对其分区
对 /dev/sdb 进行分区
建立新的分区：
输入 p 打印现有分区情况（还没有分区）
输入 n 新建分区
输入 p 为建立主分区（此时的p是在n后的，不是打印）
输入 1 为建立第一个主分区
分区起始位置可以直接回车，默认是1
其实也可以不用分区 直接创建物理卷
输入 p 打印分区情况，发现已建立一个分区 /dev/sdb1，但是 此分区为 Linux 格式
改变系统标识符：
输入 t 改变分区1的属性
输入 L 查看有个属性对应的命令
输入 8e 改变分区1为 Linux LVM格式
输入 p 打印分区情况，发现建立的分区 /dev/sdb1 为 Linux LVM 格式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dca137183774ca2850cd629ca3061bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ce9cb9ce15c0db51c946c9cd1cc9009/" rel="bookmark">
			android 开发部分需要注意的小问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 由于版本的更迭，部分操作需要有一些小改动，通常只在项目开始的时候用一下，时间长了容易忘记，在此做个笔记。
目录
1、Android 文件操作
2、Android 相机拍照
3、flutter修改sdk路径
1、Android 文件操作 Android 开发中经常需要读取文件，除了正常的权限变更获取之外还需要在 AndroidManifest.xml 中注册文件服务，这个经常忘记，报错才会想起来。
&lt;application ........ &lt;!-- 文件服务 --&gt; &lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="applicationId.fileprovider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_path" /&gt; &lt;/provider&gt; &lt;/application&gt; 在 res资源文件夹中新建 xml 文件夹，并在 xml 下建 文件 file_path.xml 内容如下
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;resources&gt; &lt;paths&gt; &lt;external-path name="ext_root" path="/" /&gt; &lt;/paths&gt; &lt;/resources&gt; 2、Android 相机拍照 Android 中使用相机的场景 通常为 扫描和拍照，扫描正常操作就好了，如果相机用到拍照的话，那么需要在 Application 中 设置 StrictMode 才能正常使用拍照功能，代码如下
val builder = StrictMode.VmPolicy.Builder() StrictMode.setVmPolicy(builder.build()) builder.detectFileUriExposure() 以上是两个不怎么能记住的点
3、flutter修改sdk路径 flutter config --android-sdk *******
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ce9cb9ce15c0db51c946c9cd1cc9009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f404d92105eaf4a25ba8314a6daa3a8/" rel="bookmark">
			[taro react] 【run dev:h5】 报错 Uncaught ReferenceError: $RefreshSig$ is not defined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一篇踩坑篇，因为目前没有好的文章，所以这边做一个记录。
公司想做多端，我今天有空就准备预习了一下taro 这个框架，谁知刚创建了项目就卡主了，一直提示一个报错： Uncaught ReferenceError: $RefreshSig $ is not defined。一开始还以为是我创建项目的时候哪里配置使用不对的问题，重新创建了两遍项目后就排除了这个可能。一片白的页面，一直报红的控制台：
我眉头紧锁，因为我知道：我碰到事儿了！
debug流程启动！ 第一步：百度、google。尝试了一个多小时，方案都不行。启动plan B
debug流程　第二步：社区。到github 里找到了open中的issues。 底下有这样的一个方案：在config/dev.js中加入了isWatch:true。
如上图加到代码中再重新run一下项目就跑通了。
此bug为taro 3.5.7的版本bug，后期说是会修复。这里要补充一下就是taro的更新比较多，且经常出一些莫名其妙的bug。所以，如果准备使用taro开发的话，建议最好锁一下版本号，避免项目在运行时出现一些意料之外的情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a23a634f72e9267d5f9dd2f810e8f529/" rel="bookmark">
			使用java代码导出数据库sql文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用java代码导出数据库sql文件 导出目标导出工具类 导出目标 导出包含数据库表结构、索引、外键以及表里面的数据
导出分析
1. 我们不需要导出所有的表 比如 _copy、_bak之类的备份表。
2. 我们不需要导出日志表（如 _log表）中的数据 只需要表结构
3. 基于SaaS架构的数据库一般会有一个租户id，比如项目id、租户id之类的，假设我们有需求，只想导出某个项目下的数据
导出工具类 private static final Logger logger = LoggerFactory.getLogger(MySQLDatabaseTableStructureAndDataSQLExporter.class); /** * 数据库sql采集 * @param ignoreTab 忽略采集哪些表 * @param logTab 哪些表只采集表结构、不采集insert语句 * @param projectIds 导出的项目id 多个逗号隔开【方法底层去判断数据库表是否有 project_id参数 如果有导出insert语句时就只导出指定项目下的数据】 */ private static void collectSql(List&lt;String&gt; ignoreTab, List&lt;String&gt; logTab, String projectIds) { String jdbcUrl = "jdbc:mysql://localhost:3306/数据库?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai"; String username = "你的用户名"; String password = "你的密码"; String databaseName = "数据库"; // 修改为你要导出的数据库名 String outputFilePath = databaseName+"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a23a634f72e9267d5f9dd2f810e8f529/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5b2ff182f328c37d6db3817f831d5ce/" rel="bookmark">
			RocketMQ集群搭建方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 集群特点 ●NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。
●Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的Brokerld来定义，Brokerld为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。
●Producer与NameServer集群中的其中一个节点(随机选择)建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。
●Consumer与NameServer集群中的其中一个节点(随机选择)建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。
2 集群模式 1)单Master模式
这种方式风险较大，一旦Broker重启或者宕机时，会导致整个服务不可用。不建议线上环境使用，可以用于本地测试。
2)多Master模式
一个集群无Slave，全是Master，例如2个Master或者3个Master，这种模式的优缺点如下：
●优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢(异步刷盘丢失少量消息，同步刷盘一条不丢)，性能最高；
●缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。
3)多Master多Slave模式(异步)
每个Master配置一个Slave，有多对Master-Slave，HA采用异步复制方式，主备有短暂消息延迟(毫秒级)，这种模式的优缺点如下：
●优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样；
●缺点：Master宕机，磁盘损坏情况下会丢失少量消息。
4)多Master多Slave模式 (同步)
每个Master配置一个Slave，有多对Master-Slave，HA采用同步双写方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：
优点：数据与服务都无单点故障，Master宕机情况下, 消息无延迟，服务可用性与数据可用
性都非常高；
●缺点：性能比异步复制模式略低(大约低10%左右)，发送单个消息的RT会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fda2f5e7b0c04a23cf309cdb5beb1e09/" rel="bookmark">
			【手把手教你】使用DoWhy做因果推断分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言
因果推断是一种统计和哲学框架，旨在从数据中识别变量之间的因果关系，而不仅仅是相关性或关联。换句话说，它试图解答“如果我做X，会发生什么？”这类问题，而非仅仅描述“X与Y有关联”这种观察性的信息。
在金融量化中，因果推断的应用相当重要。金融市场是一个高度复杂、多变量互动的系统。在这样的环境中，仅依赖相关性往往是不足够的，因为相关性并不意味着因果性。例如，股票价格上升可能与多个因素相关，如交易量增加、宏观经济指标改善或公司业绩增长。然而，并不是所有这些因素都是导致股票价格上升的真正“原因”。
通过因果推断，量化分析师、投资者和决策者可以更精准地识别哪些因素会影响股票价格、市场走势或其他金融指标。这不仅有助于更有效地管理风险，还可以用于创建更为强健的交易策略。
【号外】qstock已更新到1.3.6版本！修正了问财不能调用的问题，请使用“pip install qstock ”进行安装，或通过’pip install –upgrade qstock’进行更新。
qstock系列专题：
【qstock开源了】数据篇之行情交易数据
【qstock数据篇】行业概念板块与资金流
【qstock量化】数据篇之股票基本面数据
【qstock量化】数据篇之宏观指标和财经新闻文本
【qstock量化】动态交互数据可视化
【qstock量化】技术形态与概念热点选股池
【手把手教你】使用qstock实现量化策略选股
【手把手教你】使用qstock进行量化回测
基于qstock的量化复盘与自动盯盘
qstock 玩转问财：一行代码实现条件选股
DoWhy库简介
DoWhy是一个用于因果推断（Causal Inference）的Python库。该库由微软研究院（Microsoft Research）开发，旨在简化从数据中识别因果关系的过程DoWhy提供了一整套统一和一致的API，支持从建模到识别，再到因果效应估计和验证的整个工作流程。
主要特点
模块化和可扩展性: DoWhy将因果推断流程分解为四个主要步骤：模型建立、识别、估计和验证。这使得用户可以轻松更换不同的估计或验证方法。
基于图模型: DoWhy使用因果图（Causal Graph）作为基础模型，帮助用户更直观地理解变量之间的关系，并且可以明确地指定共同因素（Common Causes）和介入变量（Interventions）。
多种因果估计方法: DoWhy支持多种因果估计算法，包括反事实模型（Counterfactual Models）、工具变量法（Instrumental Variables）、传播分数匹配（Propensity Score Matching）等。
诊断和验证: 除了因果效应的点估计外，DoWhy还提供了用于检验模型健壮性和有效性的诊断工具。
使用DoWhy通常涉及以下几个步骤：
数据准备: 获取和预处理你需要分析的数据。
建立因果模型: 利用因果图明确指定处理（Treatment）变量、结果（Outcome）变量和可能的共同因素（Common Causes）。
识别因果效应: 基于你的因果模型，DoWhy将尝试识别一个合适的估计方法。
估计因果效应: 使用识别的方法来估计处理变量对结果变量的因果效应。
验证和诊断: 评估估计的因果效应的稳健性和可靠性。
应用示例
下面以跳空高开（Gap Up）是否对一个股票指数（如沪深300指数）的日收益率有因果影响，使用qstock库获取数据和DoWhy库进行因果推断。为了避免反向因果的影响，共同因素变量均滞后一期。
import qstock as qs import pandas as pd import numpy as np import pandas_ta as ta import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fda2f5e7b0c04a23cf309cdb5beb1e09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b517174b0fdc7529dc3d1caf28fb562/" rel="bookmark">
			精神泡芙 | 三体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文字神奇地记录和传递着故事和想法，"精神泡芙"系列就来记录读过的文字和这些文字引起的思考与波澜吧。回家的路上想给这个系列起个名字，突然想起这个周末又没有买到想吃很久的泡芙，于是"精神泡芙"就诞生了！
泡芙，从上大学时3块钱可以买到8个，到去了nku后跑去遥远的文科组团买，再到现在变成了并不是想吃就可以买到的甜食hhh…
写在2023.9.3晚 黑暗森林完结 在上班的公交车上，国家图书馆的书架上，午休公司楼梯间里，还有"小破出租屋"附近商场的西西弗里，《三体》系列从去年这个时候就这样陆陆续续看到了今年这个时候😝😝。期间甚至还上映了动画，以至于火的那阵子让我借不到书。这个周末终于看到了黑暗森林法则的全貌，前期的线索也逐渐串了起来，主要人物的神秘责任也都一一浮出水面；走出书店上厕所的路上，感觉自己的神经元也被激活了书写的想法(灵感出现啦)，于是站在人来人往、热热闹闹的商场一角，快速写下了下面这段话。
看到了残酷的黑暗森林法则的全貌：宇宙间能量总数是一定的，一个文明的发展建立在消灭其他文明的基础上；当发现了其他文明的存在，无论其内部是善良还是邪恶，也无论其技术相对自己是落后还是先进，由于猜疑链和技术爆炸的存在，唯一的选择就只能是消灭他，否则自己将有可能被对方或其他文明发现且消灭。
这也就是三体世界在发现地球🌍🌍被叶文洁暴露后派出智子、水滴和庞大的三体舰队前往遥远的太阳系准备消灭人类文明的原因，更是罗辑的咒语得以威胁三体的原因：如果三体继续消灭地球和人类，罗辑就把三体世界和周围三十颗恒星的相对位置广播📢📢至整个银河系🌌🌌，那么三体和太阳系的位置都暴露了，宇宙间其他文明必然会消灭三体和地球，即同归于尽！
三体世界的技术发展早已超越了人类世界，智子锁死了人类基础理论的进步，可最后三体还是输给了人类的智谋！
但让我意外的一点是，罗辑表示：人类晚于三体参透黑暗森林法并不是由于文明进化不成熟，而是由于人类社会存在的感情——爱；最初向叶文洁发出警告(“不要回答！不要回答！不要回答！”)的三体监听员却说：其实三体世界也是有爱的，只是发现不利于文明生存后被抑制在了萌芽状态，但其顽强的存活在了少数三体人的心里❤️❤️。
这里就忍不住让人唏嘘和感慨除罗辑外另外一个伟大的角色——章北海，他努力和坚持了两个世纪，从内心隐藏的逃亡计划几乎骗过了所有人、成功成为增援未来政工干部的一员，到为了推动辐射推进飞船的发展，甚至用陨石子弹射杀了支持工质推进飞船的科学家，使得恒星级战舰成为可能；再到他冬眠苏醒后成为"自然选择号"战舰的执行舰长，预言人类会在与三体终极战斗中失败，而带领"自然选择号"战舰逃跑，成功躲过了水滴在末日之战中对人类太空武装力量的全军歼灭！可最后，以为早已经铁石心肠的自己却死于内心深处仍存有的恻隐之心，死于"是一部分人死，还是都死"中来自同伴战舰的攻击…他只比对方晚了几秒(是的，我不希望这个角色被写死，可他的确和自然选择号上两千多人一起，葬身黑暗广袤的太空)
阅读和思考要继续，加油鸭！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fa2609453130eb4b7bc3675ac30bb2f/" rel="bookmark">
			如何一键导出PDF文档的图片？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近工作需要下载了一些pdf论文，需要将其中一些图片提取出来，网上找了很多工具大多效果不是很好。
后来在论坛看到一个在线工具，试用了一下还不错：
提取pdf图片 - www.strerr.com
选择一个pdf文件
等待提取完成，可以选择zip打包下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd46cae4fb90659a32cf55c18af6dd9f/" rel="bookmark">
			【AWS实验】 配置中转网关及对等连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 实验概览目标实验环境任务 1：查看网络拓扑并创建基准任务 2：创建中转网关任务 3：创建中转网关挂载任务 4：创建中转网关路由表任务 4.1：创建路由表关联任务 4.2：创建路由传播 任务 5：更新 VPC 路由表任务 5.1：网络验证 任务 6：创建与远程区域中转网关的对等连接任务 6.1：记录远程区域的中转网关 ID任务 6.2：创建中转网关对等连接任务 6.3：接受中转网关对等连接请求 – 远程区域任务 6.4：更新路由表关联 – 远程区域任务 6.5：更新中转网关路由表 – 远程区域任务 6.6：更新 VPC 路由表 – 远程区域任务 6.7：网络验证 任务 7：创建路由筛选条件任务 7.1：网络验证 任务 8：可视化和分析网络（可选）任务 8.1：将网络可视化任务 8.2：分析路由 总结 实验概览 可以使用对等连接来连接 Amazon Virtual Private Cloud (Amazon VPC)。但是，如果无法集中管理连接策略，那么跨多个 Amazon VPC 管理点到点连接可能会造成运营成本高昂且操作繁琐。对于本地连接，需要将 AWS VPN 附加到每个单独的 Amazon VPC。当 VPC 数量增长到数百个时，这种解决方案的构建可能非常耗时，而且难以管理。
使用 AWS Transit Gateway，只需要创建和管理从中央网关到网络中每个 VPC、本地数据中心或远程办公室的一条连接。中转网关就像一个轮轴，控制着流量在连接的所有网络之间的路由方式，而这些网络就像辐条一样。这种轴辐式模型可以显著简化管理工作并降低运营成本，因为每个网络只需连接到中转网关，而不是连接到所有其他网络。将任何新的 VPC 连接到中转网关，然后该 VPC 就会自动向连接到中转网关的所有其他网络开放。这种易连接性让您能够随着需求的增长轻松地扩展网络。
在本实验中，将通过中转网关来构建和配置路由，这些中转网关具有不同的复杂程度。首先，将检查现有 VPC、子网、路由表和 Amazon Elastic Compute Cloud (Amazon EC2) 实例。然后，将创建一个中转网关并将四个现有 VPC 附加到该网关。需要研究中转网关上的默认路由表，该路由表可以让附加到中转网关的 VPC 进行多对多通信。在确认中转网关正常运行后，需要修改该中转网关上的路由表，以便隔离特定 VPC 之间的通信。最后，需要跨区域边界建立两个中转网关的对等连接，以便展示如何配置具有中转网关的全局网络。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd46cae4fb90659a32cf55c18af6dd9f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/51/">«</a>
	<span class="pagination__item pagination__item--current">52/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/53/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>