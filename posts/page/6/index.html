<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a639b1c47e5701db8129dc6ba05d129/" rel="bookmark">
			LeetCode中等题之盛最多水的容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
返回容器可以储存的最大水量。
说明：你不能倾斜容器。
示例 1：
输入：[1,8,6,2,5,4,8,3,7]
输出：49
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
示例 2：
输入：height = [1,1]
输出：1
解题思路 在数组的头和尾分别设置一个指针，通过题目可以知道目的主要是找最大，直接比较两个指针指向的值大小，小的值的指针往中间靠即可在搜索中找到最大容量。
class Solution: def maxArea(self, height: List[int]) -&gt; int: i,j,ans=0,len(height)-1,-1 while i!=j: if height[i]&lt;height[j]: ans=max(ans,(j-i)*height[i]) i+=1 else: ans=max(ans,(j-i)*height[j]) j-=1 return ans 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f098e864d583a6cd401b0092933377fb/" rel="bookmark">
			【小白专用】winform启动界面&#43;登录窗口 更新2024.1.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求场景：先展示启动界面，然后打开登录界面，如果登录成功就跳转到主界面
首先在程序的入口路径加载启动界面，使用ShowDialog显示界面，
然后在启动界面中添加定时器，来实现显示一段时间的效果，等到时间到了就关闭
启动界面的窗口。传递一个对象给登录界面，用来保存登录状态，显示登录界面，
如果登录成功就在登录界面中对这个传递进来的对象就行修改，这里使用1作为成功
的返回值，注意这里也需要使用ShowDialog来打开这个窗口。等到登录窗口关闭后
判断这个返回值，如果为成功则显示用户主界面，如果不成功的话程序就会直接退出。
主要代码如下
using System; using System.Collections.Generic; using System.Linq; using System.Threading.Tasks; using System.Windows.Forms; namespace AliWorkbenchProgram { internal static class Program { /// &lt;summary&gt; /// 应用程序的主入口点。 /// &lt;/summary&gt; [STAThread] static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); //启动界面 loadFrm form = new loadFrm(); form.ShowDialog(); //保存返回值 int[] loginResult = new int[] { 0 }; //传递返回值对象给登录窗口 loginFrm main = new loginFrm(loginResult); main.ShowDialog(); //由于使用的是ShowDialog，所有只有在窗口关闭后才会继续向下执行 if (loginResult[0] == 1) { //打开主界面 Application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f098e864d583a6cd401b0092933377fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1d571794b25a99e4d5ba10096b7e966/" rel="bookmark">
			数据结构OJ实验7-树结构及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A. 树的先序遍历（双亲转先序） 题目描述 亲表示法结果，用一个二维数组表示，位置下标从0开始，如果双亲位置为-1则表示该结点为根结点
编写程序，输出该树的先根遍历结果。
输入 第一个输入t，表示有t棵树
接着每棵树输入3行：
第1行输入n，表示树有n个结点
第2行输入n个英文字母，表示每个树结点的数值
第3行输入n个整数，表示每个结点的双亲在数组的下标
以此类推输入下一棵树
输出 共输出t行，每行输出一棵树的先根遍历结果
样例查看模式 正常显示查看格式
输入样例1 2
7
A B C D E F G
-1 0 0 0 1 1 3
10
A B C D R E F G H K
4 4 4 0 -1 0 2 6 6 6
输出样例1 ABEFCDG
RADEBCFGHK
AC代码 #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; struct node { char data; int fa; node() { data = '0'; fa = -1;//全部默认自己为根 } }; class tree { vector&lt;node&gt;t; int n; public: tree() { cin &gt;&gt; n; t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1d571794b25a99e4d5ba10096b7e966/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcf14fd134173a055f3bfc97f5448f80/" rel="bookmark">
			【C&#43;&#43;】STL 容器 - map 关联容器 ② ( map 容器常用 api 操作 | 容器插入元素操作 - map#insert 函数 | 插入 / 修改 元素操作 - operator[] )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、map 容器插入元素操作 - map#insert 函数1、函数原型简介2、pair 键值对初始化方式 二、map 容器 插入 / 修改 元素操作 - map#operator[] 函数三、代码示例 - map 容器插入 / 更新元素1、代码示例2、执行结果 一、map 容器插入元素操作 - map#insert 函数 1、函数原型简介 在 C++ 语言 标准模板库 ( STL , Standard Template Library ) 的 std::map 容器 的 insert 函数 可以 向 map 中插入一个键值对 ;
map#insert 函数原型 :
pair&lt;iterator, bool&gt; insert(const value_type&amp; value); 参数解析 : 参数类型 : value_type 是 map 容器中存储的元素的类型 , 具体类型为 pair&lt;const Key, T&gt; 类型 , Key 是键的类型 , T 是值的类型 ;参数对象 : 传入的 value 对象 就是一个 pair 对组对象 , 是一个 键值对 元素 ; 返回值解析 : 返回值类型为 pair&lt;iterator, bool&gt; , 也是一个 pair 对组对象 ; 返回值对组的 第一个值是 iterator 迭代器 , 指向已经插入的 键值对 元素 ;返回值对组的 第二个值是 布尔值 , 表示插入是否成功 , 如果键 Key 已经存在 , 则插入失败 , 返回 false ;如果键 Key 不存在 , 则插入新元素 , 返回 true ; 2、pair 键值对初始化方式 在上面的章节中提到 , 调用 map#insert 函数 向 map 容器中插入 键值对元素 , 需要 创建一个 pair&lt;const Key, T&gt; 键值对对象 作为 参数 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcf14fd134173a055f3bfc97f5448f80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab569da1f693ff8400e80289d7600f7d/" rel="bookmark">
			【小白专用】c#制作简单启动画面 更新2024.1.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VS2020创建一个C# Windows窗体应用程序，将主窗体改名为FormMain，再创建一个窗体起名为SplashScreen。向程序中加载一个图片作为启动画面，如下图
然后编辑SplashScreen.cs代码
using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; namespace AliWorkbenchProgram { /// &lt;summary&gt; /// 启动画面 /// &lt;/summary&gt; public partial class SplashScreen : Form { /// &lt;summary&gt; /// 启动画面本身 /// &lt;/summary&gt; static SplashScreen instance; /// &lt;summary&gt; /// 显示的图片 /// &lt;/summary&gt; Bitmap bitmap; public static SplashScreen Instance { get { return instance; } set { instance = value; } } public SplashScreen() { InitializeComponent(); // 设置窗体的类型 FormBorderStyle = FormBorderStyle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab569da1f693ff8400e80289d7600f7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d86d86bc73318a5e689455ba8fbf924/" rel="bookmark">
			Maven中的SNAPSHOT版本和Release版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven中建立的依赖管理方式基本已成为Java语言依赖管理的事实标准，Maven的替代者Gradle也基本沿用了Maven的依赖管理机制。在Maven依赖管理中，唯一标识一个依赖项是由该依赖项的三个属性构成的，分别是groupId、artifactId以及version。这三个属性可以唯一确定一个组件（Jar包或者War包）。
其实在Nexus仓库中，一个仓库一般分为public(Release)仓和SNAPSHOT仓，前者存放正式版本，后者存放快照版本。如果在项目配置文件中（无论是build.gradle还是pom.xml）指定的版本号带有’-SNAPSHOT’后缀，比如版本号为’Junit-4.10-SNAPSHOT’，那么打出的包就是一个快照版本。
快照版本和正式版本的主要区别在于，本地获取这些依赖的机制有所不同。假设你依赖一个库的正式版本，构建的时候构建工具会先在本次仓库中查找是否已经有了这个依赖库，如果没有的话才会去远程仓库中去拉取。所以假设你发布了Junit-4.10.jar到了远程仓库，有一个项目依赖了这个库，它第一次构建的时候会把该库从远程仓库中下载到本地仓库缓存，以后再次构建都不会去访问远程仓库了。所以如果你修改了代码，向远程仓库中发布了新的软件包，但仍然叫Junit-4.10.jar，那么依赖这个库的项目就无法得到最新更新。你只有在重新发布的时候升级版本，比如叫做Junit-4.11.jar，然后通知依赖该库的项目组也修改依赖版本为Junit-4.11,这样才能使用到你最新添加的功能。
这种方式在团队内部开发的时候会变的特别蛋痛。假设有两个小组负责维护两个组件，example-service和example-ui,其中example-ui项目依赖于example-service。而这两个项目每天都会构建多次，如果每次构建你都要升级example-service的版本，那么你会疯掉。这个时候SNAPSHOT版本就派上用场了。每天日常构建时你可以构建example-service的快照版本，比如example-service-1.0-SNAPSHOT.jar，而example-ui依赖该快照版本。每次example-ui构建时，会优先去远程仓库中查看是否有最新的example-service-1.0-SNAPSHOT.jar，如果有则下载下来使用。即使本地仓库中已经有了example-service-1.0-SNAPSHOT.jar，它也会尝试去远程仓库中查看同名的jar是否是最新的。有的人可能会问，这样不就不能充分利用本地仓库的缓存机制了吗？别着急，Maven比我们想象中的要聪明。在配置Maven的Repository的时候中有个配置项，可以配置对于SNAPSHOT版本向远程仓库中查找的频率。频率共有四种，分别是always、daily、interval、never。当本地仓库中存在需要的依赖项目时，always是每次都去远程仓库查看是否有更新，daily是只在第一次的时候查看是否有更新，当天的其它时候则不会查看；interval允许设置一个分钟为单位的间隔时间，在这个间隔时间内只会去远程仓库中查找一次，never是不会去远程仓库中查找（这种就和正式版本的行为一样了）。
Maven版本的配置方式为：
&lt;repository&gt; &lt;id&gt;myRepository&lt;/id&gt; &lt;url&gt;...&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;XXX&lt;/updatePolicy&gt; &lt;/snapshots&gt; &lt;/repository&gt; 12345678 其中updatePolicy就是那4种类型之一。如果配置间隔时间更新，可以写作interval:XX(XX是间隔分钟数)。daily配置是默认值。
而在Gradle，可以设置本地缓存的更新策略。
configurations.all { // check for updates every build resolutionStrategy.cacheChangingModulesFor 0,'seconds' } 123456 当然也可以按照分钟或者小时来设置
configurations.all { resolutionStrategy.cacheChangingModulesFor 10, ‘minutes' } 12345 configurations.all { resolutionStrategy.cacheChangingModulesFor 4, ‘hours' } 12345 所以一般在开发模式下，我们可以频繁的发布SNAPSHOT版本，以便让其它项目能实时的使用到最新的功能做联调；当版本趋于稳定时，再发布一个正式版本，供正式使用。当然在做正式发布时，也要确保当前项目的依赖项中不包含对任何SNAPSHOT版本的依赖，保证正式版本的稳定性。
原文链接：https://www.cnblogs.com/huang0925/p/5169624.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06b7e361dab530638cf6d8b9c0a674e5/" rel="bookmark">
			美团面试：索引的设计规范，你知道哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		美团面试：索引的设计规范，你知道哪些？ 尼恩说在前面 在40岁老架构师 尼恩的读者交流群(50+)中，尼恩一直在指导大家改造简历、指导面试。指导很多小伙伴拿到了一线互联网企业网易、美团、字节、如阿里、滴滴、极兔、有赞、希音、百度、美团的面试资格，拿到大厂offer。
其中，数据库的面试题，是核心和重点的题目，比如前段时间小伙伴面试美团，就遇到了下面这个 题：
索引的设计规范，你知道哪些？
小伙伴虽然用过索引，但是索引的设计规范忘记得一干二净，回答也是朦朦胧胧、支支吾吾， 当然，面试也就挂了。小伙伴赶紧来求助尼恩。
在这里，尼恩在这里给大家做一下系统化、体系化的梳理，按照下面的套路去回答，可以充分展示一下大家雄厚的 “技术肌肉”，让面试官爱到 “不能自已、口水直流”。
也一并把这个题目以及参考答案，收入咱们的 《尼恩Java面试宝典PDF》V154版本，供后面的小伙伴参考，提升大家的 3高 架构、设计、开发水平。
特别提示，尼恩的3高架构宇宙，尼恩Java面试宝典，都是持续升级。
《尼恩 架构笔记》《尼恩高并发三部曲》《尼恩Java面试宝典》的PDF，请到文末公号【技术自由圈】取
文章目录 美团面试：索引的设计规范，你知道哪些？尼恩说在前面1、索引原理2、索引的分类3、索引的优缺点4、参考的索引设计规范4.1 索引命名规范4.2 尽量选择整型列做索引4.3 优先建立唯一性索引4.4 为经常需要排序、分组和联合操作的字段建立索引4.5 为常作为查询条件的字段建立索引4.6 限制索引的数目4.7 尽量使用数据量少的索引4.9 尽量使用前缀来索引4.10 删除不再使用或者很少使用的索引4.11 最左前缀匹配原则，非常重要的原则。4.12 尽量选择区分度高的列作为索引4.13 索引列不能参与计算，保持列“干净”4.14 尽量的扩展索引，不要新建索引4.15 考虑建立联合索引来提高查询效率 参考文献：说在最后：有问题可以找老架构取经尼恩技术圣经系列PDF 1、索引原理 索引是帮助MySQL高效获取数据的数据结构，注意，是帮助高性能的获取数据。
索引好比是一本书的目录，可以直接根据页码找到对应的内容，目的就是为了加快数据库的查询速度。
索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。索引是一种能帮助mysql提高了查询效率的数据结构：索引数据结构。 索引的存储原理大致可以概括为一句话：以空间换时间。
数据库在未添加索引, 进行查询的时候默认是进行全文搜索，也就是说有多少数据就进行多少次查询，然后找到相应的数据就把它们放到结果集中，直到全文扫描完毕。
数据库添加了索引之后，通过索引快速找到数据在磁盘上的位置，可以快速地读取数据，而不用从头开始全表扫描。
一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。
2、索引的分类 主键索引：primary key
设定为主键后，数据库自动建立索引，InnoDB为聚簇索引，主键索引列值不能为空（Null）。 唯一索引：
索引列的值必须唯一，但允许有空值（Null），但只允许有一个空值（Null）。 复合索引：
一个索引可以包含多个列，多个列共同构成一个复合索引。 全文索引：
Full Text（MySQL5.7之前，只有MYISAM存储引擎引擎支持全文索引）。全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找允许在这些索引列中插入重复值和空值。全文索引可以在Char、VarChar 上创建。 空间索引：
MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型，MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。 前缀索引：
在文本类型为char、varchar、text类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。 3、索引的优缺点 优点：
大大提高数据查询速度。可以提高数据检索的效率，降低数据库的IO成本，类似于书的目录。通过索引列对数据进行排序，降低数据的排序成本降低了CPU的消耗。被索引的列会自动进行排序，包括【单例索引】和【组合索引】，只是组合索引的排序需要复杂一些。如果按照索引列的顺序进行排序，对order 不用语句来说，效率就会提高很多。 缺点：
索引会占据磁盘空间。索引虽然会提高查询效率，但是会降低更新表的效率。比如每次对表进行增删改查操作，MySQL不仅要保存数据，还有保存或者更新对应的索引文件。维护索引需要消耗数据库资源。 综合索引的优缺点：
数据库表中不是索引越多越好，而是仅为那些常用的搜索字段建立索引效果最佳! 4、参考的索引设计规范 每个公司，都有自己的 设计规范，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06b7e361dab530638cf6d8b9c0a674e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20ca3287de7c2516040a3fa5b2f5a672/" rel="bookmark">
			《2023年企业IoT和OT威胁报告》：物联网恶意软件攻击增长400%
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容概括： 物联网（IoT）设备无疑改变了我们生活、工作和管理运营技术（OT）环境的方式。总体而言，到2027年，全球物联网设备数量预计将超过290亿，比2023年的167亿大幅增加。设备和智能技术的激增也为网络犯罪分子提供了更多的机会，他们开始将物联网连接变成一个潜在的威胁，甚至是毁灭性的现实。为了帮助组织更好地了解当前的物联网形势以及最佳防护措施，Zscaler threatlabz研究团队分析了来自Zscaler Zero Trust Exchange（世界上最大的内联安全云）的设备流量和物联网恶意软件数据，形成了这份《2023年企业IoT和OT威胁报告》。重要发现：1.物联网设备流量增长18%，这一趋势与物联网和连接设备的稳步采用表现一致。2.路由器是最易受攻击的设备，因为它们始终连接、无处不在的特性，以及作为网络流量中央控制点的功能，使其成为主要目标。3.与2022年同期相比，物联网恶意软件攻击增长了400%以上，这凸显了优先防范恶意软件的必要性。4.制造业是受恶意软件攻击最多的行业，占所有攻击的5%，平均每周受到6000次攻击。5.僵尸网络活动继续占据主导地位，Mirai和Gafgyt恶意软件家族占攻击有效载荷的66%。6.自2022年以来，教育领域遭受的恶意软件攻击大幅增加，比例跃升了961%。7.网络犯罪分子的目标是遗留漏洞，在39个“最受欢迎的漏洞”中就有34个存在三年以上的漏洞。8.墨西哥和美国是受灾最严重的国家，占攻击总数的3%。
研判认为： 目前国内用户使用的物联网设备主要包含机顶盒、智能电视、智能手表、数据终端和媒体播放器这五类。其中机顶盒和智能电视可谓每家每户都有，我方建议相关组织增加适当的安全措施，例如：加密通讯、访问控制、身份验证等。工信、网信等相关部门应逐步有效引导，增强居民的安全意识，了解物联网设备的安全风险，并采取适当的安全措施，例如更改默认密码、定期更新密码等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/397b60cc7bb8765bce17eb5c2beac990/" rel="bookmark">
			.net8时代,微软.net开发策略，F#不就是VB语言吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看了一下F#代码几乎和VB差不多，重复造轮子微软却玩的很开心。
可是真正的VB6,vb.net却抛弃了
.网络管理语言策略。NET微软学习
https://learn.microsoft.com/en-us/dotnet/fundamentals/languages
微软提供三种语言。网络平台-C#,F#和视觉基础.在本文中,您将了解我们对每种语言的策略。寻找其他文章的链接,这些文章介绍了这些策略如何引导我们,以及如何更多地了解每种语言。
C# C#是一种跨平台通用语言,它使开发人员在编写高性能代码的同时能够进行生产。数以百万计的开发人员,C#是最受欢迎的。网络语言。C#在生态系统中得到广泛的支持.网 工作负荷 .基于面向对象的原则,它包含了来自其他范例的许多特性,尤其是功能性编程。低级别的特性支持高效率的场景,而不编写不安全的代码。其中大部分。网络运行时和库是用C#编写的,而C#的进展通常对所有人都有利.网络开发商。
我们的C#策略 我们将继续发展C#,以满足开发人员不断变化的需求,并保持最先进的编程语言。我们将积极创新,广泛地与负责创新的团队合作.网络库、开发工具和工作负载支持,同时注意保持语言的精神。认识到正在使用C#的领域的多样性,我们将倾向于语言和性能的改进,使所有或大多数开发人员受益,并对向后兼容性保持高度的承诺。我们将继续增强更广泛的力量。网络生态系统并在C#的未来中发挥作用,同时保持对设计决策的管理。
你可以阅读更多关于这个策略如何引导我们 C#指南 .
F# F#是一种简洁、健壮和表现性的语言,它以表达为基础,默认不变。它侧重于表现力、简单和优雅,被成千上万的开发人员使用,他们欣赏它的实用功能第一的方法。网。F#提供全功率的。在混合语言解决方案中使用C#并与之合作良好.社区对编译器和运行时,以及F#工具和框架的广泛数组做出了重大贡献。
我们的F#策略 我们将推动F#进化,支持F#生态系统的语言领导和治理.我们将鼓励社区为改进F#语言和开发人员的体验做出贡献.我们将继续依靠社区提供重要的图书馆、开发工具和 工作量 支持。随着语言的发展,F#将支持。网络平台改进和保持与新的C#功能的互操作性.我们将跨语言、工具和文档工作,以降低新开发人员和组织进入F#的障碍,并将其扩展到新领域。
你可以阅读更多关于这个策略如何引导我们 F# guide .
视觉基础 视觉基础(vb)作为一种容易接近的语言,有很长的历史,它更倾向于清晰而不是简洁。它的成千上万的开发人员集中在传统的基于Windows的客户端 工作负荷 在那里,vb长期以来开创了伟大的工具和使用方便。如今的vb开发人员从一种稳定而成熟的面向对象语言中获益,而这种语言也在不断增长。网络生态系统和正在进行的工具改进。一些。网络工作负载在vb中不支持,对于vb开发人员来说,在这些场景中使用C#是很常见的。
我们的视觉基础策略 我们将确保视觉基础仍然是一种简单易懂的语言,具有稳定的设计。核心图书馆。网络(如BCL)将支持vb和许多改进.网络运行时和库将自动受益于vb.当C#或。网络运行时引入需要语言支持的新功能,vb通常采用只使用的方法,避免使用新语法。我们不打算将视觉基础扩展到新的工作负载。我们将继续投资于视觉工作室和C#互操作的经验,特别是在核心的vb场景,如Windows表单和库。
你可以阅读更多关于这个策略如何引导我们 视觉基础指南 .
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64ca839989962012005a947e17aa3c21/" rel="bookmark">
			axios的使用及说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.说明
2.直接使用
3.封装使用
4.注意
1.说明 官网：Axios 实例 | Axios中文文档 | Axios中文网
Axios 是一个基于 promise 网络请求库，作用于node.js 和浏览器中。 它是 isomorphic 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js http 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。 在前端项目中通过axios进行发送请求，通过代理后调用后端接口，并接收返回，将返回信息显示在前端画面中。
axios返回的是一个promise。执行then方法，接收执行成功的结果，显示在画面中。执行catch 方法用于对执行异常进行处理，如弹出提示信息。执行finally方法用于进行清理工作，如关闭画面loading。
2.直接使用 ①安装
npm install axios ②配置
在js或ts文件中创建请求的文件，用于设置请求的共同配置及请求拦截器和响应拦截器。
(1)导入axios
import axios from "axios"; (2)设置全局的axios的配置
通过axios的defaults进行配置。可以设置基础url，这样在api请求中只需要设置相对url；
可以配置共用的请求头，如token及其他的自定义的请求头。
也可以为某个请求配置独有的请求头属性。
//配置请求的基础url axios.defaults.baseURL = 'https://api.example.com'; //配置共同的请求头，所有的请求头中都带有X-request axios.defaults.headers.common['X-request'] = 'ajax'; //配置post请求头，只对post请求起作用，在post请求头中设置Content-Type axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; (3)配置请求拦截器及响应拦截器
请求拦截器：
// 添加请求拦截器 axios.interceptors.request.use(function (config) { // 在发送请求之前做些什么 return config; }, function (error) { // 对请求错误做些什么 return Promise.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64ca839989962012005a947e17aa3c21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66df78b8c66df8a0cc7b4decc77064c7/" rel="bookmark">
			图的深度优先和广度优先遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 图的遍历图的存储结构一个例子python实现 图的遍历 图的遍历指从某一个顶点出发按照一定的线路对其余各个顶点进行访问，通常访问的顺序有深度优先和广度优先两个方向。数据结构中链型结构，如链表，顺序表等，还有树形结构，如二叉树等都属于图的一种退化，链形结构通常是顺序遍历直接使用for循环即可，树形结构的访问相对比较复杂，对于二叉树有先序遍历，中序遍历等，而其中的层次遍历就是广度优先遍历，与广泛意义的图不一样的是，树的遍历往往从根节点开始，依照数据存储习惯不用孩子父亲表示法则很难往回访问，所以一般不能从任意节点开始遍历，而图则可以从任意起点开始！
图的存储结构 不同于链表和树，图的存储通常使用一个正方形的矩阵或者一个list容器。方形矩阵很好解释，矩阵坐标为(i,j)的元素就可以表示从第i个顶点到第j个顶点的权重，这样的表示方法同时也方便统计顶点的出度和入度，而用链表来存储的方式就是通常所说的邻接链表法，一个链表用于存放各个顶点然后链表的每个节点作为头可以横向链接当前节点往外出的节点。
一个例子 上述例子来自王道书，是一个无向图。尝试从节点1开始分别使用深度优先遍历和广度优先遍历来访问各个节点。深度优先遍历就是所谓的“一条路走到黑”，从1开始往5的方向走很快就见底，这样便完成了一次深度优先遍历，检查各个节点是否都被访问过，显然2、6等节点均未被访问，则需要接着从1的另一个方向开始第二次深度优先遍历，顺序为2-6-3-4-8-7或者2-6-7-3-4-8等等，遍历的结果并不唯一，这取决于用户输入节点的顺序。
广度优先遍历则类似二叉树的层序遍历，从节点1开始，则检查1的出口临近所有节点，2和5，然后检查2和5的临近节点6…，每次都需要把当前节点所有的出临近节点优先访问，则顺序可为1-5-2-6-3-7-4-8，顺序也不唯一。
python实现 import numpy as np from collections import deque class G: # mt=1,邻接矩阵,mt=0,邻接表 def __init__(self, graph, info, mt=1): self.graph = graph self.info = info self.mt = mt def visit(elem): print(elem) def get_next_vertx(graph, j): if graph.mt == 1: for i in enumerate(graph.graph[j]): if i[1]: yield i[0] else: continue elif graph.mt == 0: for i in graph.graph[j]: yield i def dfs(graph, index, flag=1): global visited if flag: flag = 0 visited = [0] * len(graph.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66df78b8c66df8a0cc7b4decc77064c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0143d49938ac9b7e1312e1515c608d3a/" rel="bookmark">
			车载电子电器架构 —— 电子电气系统功能开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		车载电子电器架构 —— 电子电气系统功能开发 我是穿拖鞋的汉子，魔都中坚持长期主义的汽车电子工程师。 老规矩，分享一段喜欢的文字，避免自己成为高知识低文化的工程师： 屏蔽力是信息过载时代一个人的特殊竞争力，任何消耗你的人和事，多看一眼都是你的不对。非必要不费力证明自己，无利益不试图说服别人，是精神上的节能减排。
无人问津也好,技不如人也罢,你都要试着安静下来,去做自己该做的事.而不是让内心的烦躁、焦虑、毁掉你本就不多的热情和定力。
文章大体有如下内容： 1、车载功能开发概述 2、车载电子电气功能开发流程 正文如下： 一、车载功能开发概述 功能开发主要是围绕用户驾车体验，将整车功能分为动力驱动、操控、安全和智能等模块。 1、新能源 -&gt; 新能源相关功能、中高压管理、电动后驱、无线充电； 车载新能源相关功能、中高压管理、电动后驱和无线充电是新能源汽车领域的核心技术和功能，它们共同构成了新能源汽车的先进性和优势。 车载新能源相关功能中最突出的是“对外放电”功能。通过原车的取电板，将取电枪连接充电口就能给插板通电，个人使用的车子能以最高3.3千瓦的标准对外放电，而现在最高的标准能达到6.0千瓦以上。一般的电动工具功率都不到三千瓦，工作灯的功率只是几百瓦而已，就算给一些设备同时供电也能坚持很长时间。这是燃油车做不到的，燃油车虽然能通过逆变器转为220V对外放电，但需要车辆怠速运行并且无法支持大功率设备，所以新能源汽车不仅是代步车，同时还是一台优秀的“工作车”。 中高压管理是新能源汽车的一个重要组成部分，它负责控制和管理车辆的高压电路系统。由于新能源汽车的电池组等关键部件需要高压才能工作，因此中高压管理系统的性能直接影响到车辆的安全性和可靠性。 电动后驱是新能源汽车的一种驱动方式，它通过电动机来驱动车辆的后轮。这种方式可以提供更好的动力性能和操控性能，同时也能提高车辆的能效和减少对环境的污染。 无线充电是一种新兴的充电技术，它通过无线方式为电子设备提供电能。这种技术可以大大简化充电过程，提高充电的便利性和安全性，尤其适用于电动汽车等大型设备的充电。 车载新能源相关功能、中高压管理、电动后驱和无线充电等技术是新能源汽车领域的重要发展方向，它们将有助于推动新能源汽车的普及和发展。 2、车载基本功能 -&gt; 电气架构、诊断、软硬件平台、电源管理、数据采集、OTA、售后等车辆基本功能； -&gt;电器架构 车载电气架构是汽车中电子电气系统的集成和组织方式，它涉及到汽车中各种电器设备和系统的布局、连接和管理工作。车载电气架构是汽车电气系统的重要组成部分，它的设计直接影响到汽车的性能、安全和可靠性。 车载电气架构的主要功能是将汽车中的各种电器设备和系统进行集成和整合，形成一个完整的电气系统。它负责电力的分配、控制和监控，以及信号的传输和处理，确保各个电器设备能够正常运行，同时避免不同设备之间的干扰和冲突。车载电气架构还负责管理和控制车辆的电子控制系统，包括发动机控制系统、底盘控制系统、安全控制系统等。 车载电气架构的设计和优化是汽车研发的重要环节。通过合理的设计和优化，可以降低汽车的成本、提高汽车的可靠性、提升汽车的智能化水平。车载电气架构的发展趋势是智能化、模块化和集成化，未来将会有更多的智能化传感器、执行器和控制器应用到汽车中，实现更加智能化的管理和控制。 -&gt; 车载诊断 车载诊断是指通过车辆内部的传感器和通讯设备，对车辆的状态和故障进行实时监测和诊断。车载诊断系统可以通过读取车辆的故障码和数据流，确定故障部位及原因，从而帮助维修人员快速准确地修复车辆故障。 车载诊断系统的核心组件是车载诊断模块，它负责监测和诊断车辆的各个系统和部件，并将故障码和相关数据存储在内部存储器中。通过专用的诊断设备或诊断软件，维修人员可以连接到诊断模块，读取故障码和数据流，以便进行进一步的故障排除和修复工作。 车载诊断系统的应用可以大大提高车辆的可靠性和安全性，同时也可以降低维修成本和时间。通过实时监测和诊断车辆的状态，可以及时发现潜在的故障和问题，避免小问题变成大故障。同时，车载诊断系统也可以帮助维修人员快速定位和解决故障，提高维修效率和质量。 车载诊断系统的发展趋势是智能化和网络化。未来，车载诊断系统将能够更加全面地监测车辆的状态和故障，同时也可以通过无线网络与其他设备进行通讯，实现远程诊断和维护。这将进一步推动车载诊断技术的发展和应用。 -&gt; 软硬件平台 车载软硬件平台是车载计算平台的核心构成，主要包括硬件平台、系统软件和功能软件三个部分。 硬件平台是车载计算平台的物理基础，主要由异构硬件组成，包括CPU计算单元、AI单元（GPU、ASIC、FPGA）、MCU控制单元、存储、ISP等其他硬件。这些硬件共同协作，负责车辆的各种控制和监测任务。 系统软件是连接硬件和功能软件的桥梁，主要包括硬件抽象层（如Hypervisor、BSP）、操作系统内核（如QNX/Linux/Andriod/Vxworks）、中间件组件等。系统软件负责管理和调度硬件资源，为功能软件提供稳定可靠的运行环境。 功能软件是实现车辆控制和监测功能的核心，主要包括自动驾驶通用框架（如感知、决策、执行）、功能软件通用框架（如数据抽象/数据流框架/基础服务）等。功能软件通过接收和解析各种传感器信号，实现对车辆的精确控制和实时监测。 此外，车载软硬件平台还包括其他组件，如工具链（开发、仿真、调试、测试等）和安全体系（功能安全、信息安全等）。这些组件为车载软硬件平台的开发、部署和维护提供了全面支持。 车载软硬件平台的发展趋势是高度集成化和模块化。未来，随着车载计算能力的不断提升，车载软硬件平台将能够支持更加复杂和智能的车辆控制和监测功能。同时，随着智能网联技术的不断发展，车载软硬件平台将与车联网技术深度融合，实现更加智能的车辆管理和服务。 -&gt; 车载电源管理 车载电源管理是汽车电子电气系统中的重要组成部分，主要负责管理车载电源的分配、控制和监控，以确保汽车中各个电器设备和系统能够正常运行。 车载电源管理的主要功能包括： 电源分配：根据各个电器设备和系统的需求，将电源合理地分配给各个用电设备，以保证设备的正常运行。 电源控制：通过控制电源的通断和电压调节等方式，实现对车载用电设备的控制和管理。 电源监控：对车载电源的电压、电流、温度等参数进行实时监测，及时发现异常情况并进行处理，保证电源系统的安全和可靠性。 能量回收：在汽车制动或滑行时，通过能量回收技术将车辆的动能转化为电能储存起来，提高能源的利用效率。 故障诊断：对车载电源系统和用电设备进行故障诊断和检测，及时发现和排除故障，保证车辆的正常运行。 车载电源管理技术的发展趋势是智能化和集成化。未来，随着汽车电子电气系统的不断复杂化和智能化，车载电源管理技术将越来越重要。智能化电源管理系统能够根据用电设备和系统的实时需求进行智能调节和控制，提高能源的利用效率；集成化电源管理系统能够将汽车中的各种电器设备和系统进行集成和整合，形成统一的电气系统，方便管理和维护。 -&gt; 车载数据采集 车载数据采集是利用传感器、通讯设备和其他技术手段，在车辆运行过程中获取车辆状态、驾驶员行为、环境感知等信息的过程。这些信息可以用于车辆监测、诊断、控制和优化等方面，对于提高车辆安全性和可靠性、降低能耗和提高运营效率具有重要意义。 车载数据采集的主要方式包括： 车辆总线通过CAN卡和电脑IPEmotion软件通信，数据存储在电脑上。 车辆信号和记录仪通信，数据存储在记录仪中。 IPEmotion软件集成了OBD II协议，连接车辆OBD接口，即可直接读取车辆OBD II相关数据。 车载数据采集的主要应用场景包括： 车辆监测和诊断：通过采集车辆运行状态和故障信息，对车辆进行实时监测和故障诊断，提高车辆的安全性和可靠性。 驾驶员行为分析：通过采集驾驶员操作行为和驾驶习惯等信息，对驾驶员行为进行分析和评估，帮助驾驶员改进驾驶习惯和提高驾驶技能。 智能交通系统：通过车载数据采集，将车辆运行信息和道路状况等数据上传到云端，为智能交通系统的规划和优化提供数据支持。 节能减排：通过采集车辆能耗和排放等信息，对车辆进行优化控制和调度，降低能耗和排放，提高环保性能。 车载数据采集技术的发展趋势是智能化和实时化。未来，随着传感器技术、通讯技术和云计算技术的发展，车载数据采集将更加智能化和实时化，能够更好地满足车辆监测、诊断和控制等方面的需求。同时，随着智能交通和车联网技术的发展，车载数据采集将与其他技术手段进行融合，形成更加全面和高效的数据采集和处理系统。 -&gt; OTA 车载OTA（Over-The-Air）是指通过无线网络对车辆软件进行远程升级的技术。通过OTA升级，车主可以在不前往线下4S店或维修中心的情况下，直接在车内下载和更新车辆软件，从而实现对车辆功能的改进、缺陷修复或性能提升。 OTA技术最早在2000年左右出现在日本，目前广泛应用于智能手机等IT设备。在汽车领域，OTA升级类似于电脑的Windows系统升级或手机的系统升级，每次升级都可以得到改善、修复漏洞或者获得更多的功能、性能提升，也可以理解为是视觉效果的改善。 OTA技术可以通过无线网络下载数据包从而对汽车系统进行升级，实现了远程无线方式对汽车系统进行升级的目标。严格来说，OTA分为两种类型，FOTA和SOTA：FOTA指的是给汽车下载一个完整的固件镜像或者修补现有的固件；SOTA则偏向于应用软件升级，如娱乐系统、导航系统等。 这种技术对于车主来说十分方便，同时减少了车辆维护的成本和时间。而随着车联网技术的不断发展，车载OTA技术也将得到更广泛的应用和推广。 -&gt; 车载售后 车载售后主要是指对汽车售出后所提供的各种服务，包括安装调试、使用指导、维修保养、处理消费者来信等。 车载售后的主要目的是为了确保消费者能够更好地使用和维护自己的车辆，提高车辆的使用寿命和安全性，同时也能提升消费者对汽车品牌的忠诚度和满意度。 车载售后的具体内容包括： 安装调试：为消费者提供专业的安装和调试服务，确保车辆的各项功能能够正常使用。 使用指导：向消费者提供使用方面的指导和培训，使消费者能够更好地了解和使用车辆的各种功能。 维修保养：提供专业的维修和保养服务，包括对车辆进行定期检查、更换零部件等，确保车辆始终保持良好的状态。 处理消费者来信：对消费者的来信进行及时处理，解答消费者关于车辆的疑问和问题，同时收集消费者的反馈和建议，为产品的改进和服务的提升提供参考。 车载售后的服务质量直接影响到消费者的购车体验和对品牌的信任度，因此对于汽车品牌来说，提供优质的车载售后服务是至关重要的。 操控 -&gt;制动、轮胎、悬架，转向四个系统的主要功能。 -&gt; 制动 车载制动是指汽车制动系统，是汽车中用于减速和停车的系统。它通过制动器或制动器与滑行作用的组合，使汽车减速或停车。 车载制动系统通常由制动踏板、制动总泵、制动分泵、刹车片、刹车盘等组成。当驾驶员踩下制动踏板时，踏板力通过制动总泵和制动分泵转换成车轮制动力，使汽车减速或停车。 车载制动系统可以分为行车制动系统、驻车制动系统和紧急制动系统等。行车制动系统是汽车行驶过程中最常用的制动系统，用于控制汽车减速或在最短的距离内停车。驻车制动系统是在车辆停放时使用的制动系统，用于保持车辆稳定，防止车辆自行溜车。紧急制动系统是在紧急情况下使用的制动系统，通过最大程度地发挥制动器的效能，使汽车在最短的距离内停车。 车载制动系统的性能对于汽车的安全性和稳定性至关重要。因此，对于汽车制造商来说，设计和制造出性能优良、可靠性高的车载制动系统是非常重要的。同时，驾驶员也需要注意制动系统的保养和维护，确保其始终保持良好的工作状态。 -&gt; 轮胎 车载轮胎是汽车的重要部件之一，它支撑着汽车的整体重量，与地面接触，传递驱动力和制动力，吸收和缓冲来自路面的冲击，并保证车辆的操控性和行驶稳定性。 车载轮胎通常由胎面、胎侧、胎圈等部分组成。胎面是与地面接触的部分，它由橡胶制成，具有防滑、耐磨和抗磨损等特性。胎侧是轮胎的侧面部分，它具有保护胎面和支撑轮胎的作用。胎圈则是轮胎与轮毂连接的部分，它具有固定轮胎的作用。 车载轮胎的规格和型号各不相同，不同车型需要使用不同规格和型号的轮胎。在选择轮胎时，需要根据车辆的用途、行驶条件和驾驶员的驾驶习惯等因素进行综合考虑。 为了保证车载轮胎的安全性和使用寿命，驾驶员需要注意以下几点： 1、定期检查轮胎的气压和磨损情况，确保轮胎的气压符合标准，磨损情况正常。 2、避免在行驶过程中急加速、急刹车或急转弯等激烈驾驶行为，以免造成轮胎磨损或损坏。 3、定期进行轮胎换位，保证轮胎的磨损均匀。 4、保持轮胎清洁，避免油、酸、碱等腐蚀性物质接触轮胎。 5、及时更换老化或损坏的轮胎，以免发生安全事故。 -&gt; 悬架 车载悬架是汽车底盘的重要组成部分，它连接着车身和车轮，起到传递载荷、缓冲震动、控制车身姿态等作用，对汽车的行驶稳定性和舒适性有着至关重要的影响。 根据控制形式的不同，车载悬架可以分为被动式悬架和主动式悬架。被动式悬架的参数是固定的，无法根据路况实时调整，而主动式悬架则可以通过控制系统的调整来改变参数，以更好地适应路况。 根据汽车导向机构的不同，车载悬架可以分为独立悬架和非独立悬架。非独立悬架的结构特点是两侧车轮由一根整体式车桥相连，而独立悬架则是每一侧的车轮都是单独地通过弹性悬架悬挂在车架或车身下面。独立悬架具有质量轻、减少车身受到的冲击、提高车轮的地面附着力等优点，因此在现代轿车中得到广泛应用。 此外，常见的独立悬架包括横臂式、纵臂式、多连杆式、烛式以及麦弗逊式悬架等。麦弗逊式悬架一般用于轿车的前轮，是当今最为流行的独立悬架之一。双叉臂式悬架是双横臂悬架中的一种，拥有上下两个叉臂，横向力由两个叉臂同时吸收，支柱只承载车身重量。多连杆式悬架则是由连杆、减震器和减震弹簧组成的。 -&gt; 转向 车载转向系统是汽车中用于控制车辆转向的机构。它通过操纵方向盘，经过一套传动机构，使转向轮在路面上偏转一定的角度，以改变汽车的行驶方向。 车载转向系统的作用是根据驾驶员的意愿控制汽车的行驶方向。在行驶过程中，驾驶员通过转动方向盘来操作转向系统，使车辆按照预期的方向行驶。转向系统能够使汽车按照驾驶员的意愿改变行驶方向，也能使驾驶员利用这套机构，在汽车转向轮受到路面干扰作用自动偏转而改变行驶方向时，使转向轮向相反方向偏转，从而使汽车恢复原来的行驶方向。 车载转向系统的性能对于汽车的安全性和稳定性至关重要。一个良好的转向系统应该具备良好的操纵性、合适的转向力和位置感、具有回正功能、适当的路感、工作可靠、节能、低噪声等特点。 随着科技的发展，车载转向系统也在不断进步和改进。例如，一些高端汽车采用了电动助力转向系统，通过电机提供辅助扭矩，帮助驾驶员更轻松地转动方向盘。此外，还有一些研究正在探索自动驾驶技术，通过自动控制系统实现汽车的自主转向，从而提高驾驶的安全性和便利性。 主动安全 -&gt; 避免碰撞、低速泊车、正常驾驶辅助、各种信息的识别提醒等。 避免碰撞、低速泊车、正常驾驶辅助以及各种信息的识别提醒是车载技术的关键组成部分，它们旨在提高驾驶的安全性和便利性。 首先，避免碰撞是车载技术的核心功能之一。通过雷达、激光雷达、摄像头等传感器以及先进的算法，车载系统可以实时监测周围的交通环境，预测潜在的碰撞风险，并采取相应的措施以避免碰撞。例如，自动紧急制动系统可以在检测到潜在的碰撞时自动刹车，以降低或避免碰撞的风险。 其次，低速泊车辅助也是车载技术的重要应用之一。通过超声波传感器或摄像头等传感器以及自动泊车系统，驾驶员可以在低速时将车辆停放在指定的停车位中。这种技术可以大大简化停车过程，提高停车的安全性和便利性。 此外，正常驾驶辅助也是车载技术的重要组成部分。这些辅助系统可以帮助驾驶员更好地掌控车辆，提高驾驶的舒适性和安全性。例如，自适应巡航控制系统可以根据道路状况和交通状况自动调整车辆的速度，以保持与前车的安全距离；车道偏离预警系统可以在车辆偏离车道时提醒周边行人或车辆保障安全。 最后，各种信息的识别和提醒也是车载技术的重要功能之一。通过语音识别、自然语言处理等技术，车载系统可以识别驾驶员的指令并给出相应的回应。例如，语音助手可以帮助驾驶员设置导航、播放音乐等；智能后视镜可以通过摄像头实时显示车辆后方的景象，方便驾驶员观察路况。 被动安全 -&gt; 碰撞后对车内的保护，如安全气囊、主动头枕等，以及对车外行人的保护.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0143d49938ac9b7e1312e1515c608d3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a729e7f163519b974a9ef471a39e2d9a/" rel="bookmark">
			http基本格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在计网主要详细介绍了网络的底层,这里主要讲网络的应用层
http/https http 简介 作用 : HTTP(Hypertext Transfer Protocol)是一种用于传输超文本（Hypertext）数据的协议，通常用于在Web浏览器和Web服务器之间传递信息。
特点 : 不加密传输数据,基于C/S模型
使用端口 : 80
分为请求和响应两个方面
请求格式 请求行 get 获取资源 post 创建资源,如登陆账号密码后,服务器返回token,以后每次按token登陆 put 更改资源 DELETE 删除资源 请求路径 URL、协议版本... 请求头 Content-Type ：请求体的格式 Content-Length ：请求的总大小 User-Agent ：使用的是什么客户端 Authorization ：认证信息(例如登录产生的 token ) 请求体(载荷) 一对子节,由Content-Type指明类型,如JSON 的 Content-Type 是application/json 响应格式 状态码 200 正常 302 304 重定向,寻找已缓存的资源 403 Forbidden 404 Not Found 客户端错误 503 500 服务器问题	响应头 跟请求头类似 响应体 响应得到的不同数据 URL 格式 scheme://host:port/resource_path?param1=val1&amp;param2=val2#id
scheme ：协议，例如 http和https host ：主机名，例如 www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a729e7f163519b974a9ef471a39e2d9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707a355b35e0db1c5afda78e5b87b3e0/" rel="bookmark">
			线性代数_正交矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正交矩阵是线性代数中一种非常重要的矩阵类型，它在数学理论和实际应用中都有着广泛的用途。正交矩阵的定义如下：
设 \( A \) 是一个 \( n \times n \) 的方阵，如果满足 \( A^T A = AA^T = I_n \)，其中 \( A^T \) 是矩阵 \( A \) 的转置，\( I_n \) 是 \( n \) 阶的单位矩阵，那么矩阵 \( A \) 称为正交矩阵。
正交矩阵具有以下几个重要的性质：
1. **单位向量**：正交矩阵的每一行（或每一列）都是单位向量。
2. **相互正交**：正交矩阵的任意两个不同的行（或列）向量都是正交的，即它们的点积为零。
3. **行列式**：正交矩阵的行列式 \( \det(A) \) 只能是 \( \pm 1 \)。当 \( \det(A) = 1 \) 时，矩阵 \( A \) 被称为特殊正交矩阵；当 \( \det(A) = -1 \) 时，矩阵 \( A \) 被称为瑕旋转矩阵。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/707a355b35e0db1c5afda78e5b87b3e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d654ca3d0b36d4af88646a4ea3d55de8/" rel="bookmark">
			CSS-3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定位 作用：灵活的改变盒子在网页中位置
相对定位 div { position: relative; top: 200px; left: 200px; } 特点： 1. 改变位置的参照物是"自己原来的位置" 2. 不脱标（不脱离标准），占据原来的位置 3. 标签显示模式的特点不会改变 绝对定位 div { position: absolute; bottom: 0; right: 0; } 使用场景： 子级绝对定位，父级相对定位（子绝父相） 特点： 1. 脱标（脱离标准），不会占据原来的位置 2. 参照物：先找最近的已经定位的祖先元素，如果所有祖先元素都没有定位，参照浏览器可视区改位置 3. 显示模式特点改变：宽高生效（具备了行内块的特点） 固定定位 div { position: fixed; top: 0; right: 0; } 使用场景： 元素的位置在网页滚动时不会改变 特点： 1. 脱标（脱离标准），不会占据原来的位置 2. 参照物：浏览器窗口 3. 显示模式特点：具备行内块特点 定位居中 方式一： img { position: absolute; left: 50%; top: 50%; margin-left: -213px; margin-top: -241px; } 方式二： img { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } 子级的水平、垂直两个方向都偏移父级的50% 然后，子级向左、向上移动自身尺寸的一半（有两种实现方式） 方式一：使用 margin，手动计算 margin-top: -100px; margin-left: -100px; 方式二：（自动计算，推荐使用） transform: translate(-50%, -50%); 堆叠层级 &lt;style&gt; div { position: absolute; width: 200px; height: 200px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d654ca3d0b36d4af88646a4ea3d55de8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d4c1c8ee1fbca5166ba4648168a6585/" rel="bookmark">
			深度学习｜10.5 卷积步长 10.6 三维卷积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 10.5 卷积步长10. 6 三维卷积![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/b5bfa24f57964b0f81f9602f5780c278.png) 10.5 卷积步长 卷积步长是指每计算一次卷积，卷积移动的距离。
设步长为k，原矩阵规模为nxn，核矩阵规模为fxf，则k+k+k+k+…+k+f&lt;n,新生成的矩阵规模为 ⌊ n − f k ⌋ + 1 \lfloor \frac{n-f}{k} \rfloor+1 ⌊kn−f​⌋+1,如果考虑到填充的情况，原式将进一步修正为 ⌊ n − f + 2 p k ⌋ + 1 \lfloor \frac{n-f+2p}{k} \rfloor+1 ⌊kn−f+2p​⌋+1,
10. 6 三维卷积 可以采用多个过滤器，并将它们的对应的计算结果放到一块，从而从二维空间整合到三维空间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9538fe91fcfeb95f4d9ed58b219f844/" rel="bookmark">
			单目相机标定理论及张正友标定法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们的真实世界是三维的，拍摄的图片是二维的，相机起到的就是映射的过程，可以把相机看成一个广义的函数，输入的三位场景，输出是二维的图片（灰度图），一般情况下我们看到的是彩色图，彩色图是RGB三通道，每个通道可以认为是一张灰度图，也就是三维场景经过广义的函数（相机）得到照片，函数（映射关系）是不可逆的，也就是说我们无法从二维照片恢复出三维世界，相机是物理模型很难用数学模型完全量化，所以我们就需要一个简化的数学模型来代表复杂的三维到二维的成像过程。
文章目录 一、相机标定1、相机的数学意义2、相机标定的意义 二、小孔成像1、小孔成像原理 一、相机标定 1、相机的数学意义 真实世界是三维的，拍摄的图片是二维的相机(看成一个广义函数 )：输入三维场景，输出是二维的图片（灰度图）彩色围是RGB三通道，每个通道可以认为是一张灰度图函数（ 映射关系）是不可逆的，也就是无法从二维照片恢复出三维世界 2、相机标定的意义 相机标定 : 使用带有pattern的标定板来求解相机参数的过程用一个简化的数学模型来代表复杂的三维到二维的成像过程相机参数包括:相机内参( 焦距 ），外参( 旋转矩阵 )，镜头畸变参数用途 : 畸变校正，双目视觉，结构光，三维重建，SLAM等等
二、小孔成像 1、小孔成像原理 简单没有镇头
有一个小的光圈
真实世界的3D物体，发出光线通过光圈相机的另一侧，像平面位置，得到一个倒立的实像
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba3906a71bf1bc00701f4edc5c6b77d0/" rel="bookmark">
			【GoLang】Go语言几种标准库介绍(三)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言几种库debug 库 (各种调试文件格式访问及调试功能)相关的包和工具：示例 encoding (常见算法如 JSON、XML、Base64 等)常用的子包和其主要功能：示例 flag(命令行解析)关键概念：示例示例执行 总结专栏集锦写在最后 前言 上一篇，我们介绍了container、crypto、database三个库，这篇我们继续介绍剩下的库
几种库 debug 库 (各种调试文件格式访问及调试功能) 在 Go 语言的标准库中，并没有一个名为 debug 的独立库。
然而，Go 提供了一系列的工具和包，用于调试和性能分析。
这些工具和包包括 debug/pprof、runtime/pprof、net/http/pprof 等，用于生成和分析性能剖析数据。
相关的包和工具： runtime/pprof： 提供了运行时性能分析的功能，可以用于查看 CPU 和内存的使用情况。它通过在代码中插入特殊的语句来收集性能数据。net/http/pprof： 提供了 HTTP 接口，用于在运行时进行性能分析。可以通过浏览器或使用 go tool pprof 工具来查看分析结果。debug/pprof： 为 net/http/pprof 提供了基础的实现，可以方便地将性能分析数据暴露为 HTTP 端点。 示例 以net/http/pprof 包的示例
package main import ( _ "net/http/pprof" "net/http" "time" ) func main() { // 启动 HTTP 服务 go func() { http.ListenAndServe(":6060", nil) }() // 示例业务逻辑 for { work() time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba3906a71bf1bc00701f4edc5c6b77d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8623e5b5920cf9206bddd81894e71052/" rel="bookmark">
			2401编辑器,好插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文
CScintillaCtrl,CScintillaView和CScintillaDocv1.82
Scintilla编辑控件的免费MFC和ATL/WTL包装类
这些类为Scintilla编辑控件(http://www.scintilla.org)提供MFC和ATL/WTL包装.此控件提供开源跨平台编辑控件.
部分功能包括语法高亮,调用提示,括号高亮,风格,边距和标记等等.提供的包装类使其更容易在窗口的MFC/WTL项目中的控件中包含.
特征 1,实现Scintillav5.4.1提供的所有功能.
2,CScintillaCtrl包装类,与在MFC的"CEdit"包装类相同语义.此类还可不依赖MFC,与ATL/WTL一起使用.
3,自动使用Scintilla提供的直接访问功能提高性能.
4,CScintillaView和CScintillaDoc类提供完整的,可放入现有项目中,而不是内置的MFC富编辑或编辑控件类的文档/视图实现.
5,内置MFC持久性支持.
6,使用WM_NOTIFY和WM_COMMAND发送的所有通知都映射到视图包装类中,以方便使用C++虚函数.
7,CScintillaView类,提供默认折叠实现.
8,包括普通Scintilla提供表达支持的完整"查找和替换"支持.为此,从标准MFC"CFindReplaceDialog"类继承来实现的"CScintillaFindReplaceDlg"类.
9,包括CScintillaView中的完整MFC打印实现.
10,完全支持标准页设置对话框和打印页边距.
11,包括打印页眉和页脚的框架.
12,包括对所有标准MFC菜单项的支持,如剪切,复制,粘贴等.
13,示例演示了如何转发顶级消息到Scintilla控件.
14,示例还演示了如何实现自动补全,并在代码中调用提示.
15,这些类隐藏了Scintilla自身不支持窗口的Unicode(又名UTF16)的事实.Scintilla通过UTF8支持Unicode,"CScintillaCtrl"包装类负责,安装Scintilla的Unicode代码页及UTF8之间的转换串.
如果你查看"ScintillaCtrl.h"头文件,在Scintilla中,会看见涉及串参数,及函数的宽字符的串版本等.在"_UNICODE"的#ifdef预处理器中包装这些宽符串函数.
16在内部,这些函数执行在窗口Unicode和Scintilla的UTF8间的转换.注意,要执行此转换,代码使用WideCharToMultiByte和MultiByteToWideChar提供的UTF8翻译功能.
用法 要在代码中使用该类,只需在你的模块中包含ScintillaCtrl.h和ScintillaCtrl.cpp,并#include ScintillaCtrl.h.
如果要使用文档/视图包装器,则还包括ScintillaDocView.h及ScintillaDocView.cpp.
如果用mfc,则代码需要静态或动态包含MFC.否则,仅使用ATL/WTL.
如果要动态链接到Scintilla,在"Scintilla.dll"和"Lexilla.dll"上,启动应用时,应调用LoadLibrary.
如果静态包含控件代码,则需要自己注册Scintilla窗口类.另见Scintilla/Lexilla网站上的说明1,2.
要查看各种类运行情况,请查看"ScintillaDemoView.cpp"模块和示例中的"ScintillaDemo.cpp".
版权 产品以二进制形式发布时,可在产品(商业,共享软件,免费软件或其他)中使用.
可你想要的方式修改源码,但不能修改每个模块顶部的版权细节.
如果想用应用分发源码,则只允许分发作者发布的版本.来维护源码的单个分发点.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/630bcb8588d9144956a96c2c4f0ff5e4/" rel="bookmark">
			shell命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Linux的变量种类
按变量的生存周期来划分，Linux变量可分为两类：
1.1 永久的：需要修改配置文件，变量永久生效。
1.2 临时的：使用export命令声明即可，变量在关闭shell时失效。
2.设置变量的三种方法
2.1 在/etc/profile文件中添加变量【对所有用户生效(永久的)】
用VI在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。
例如：编辑/etc/profile文件，添加CLASSPATH变量
# vi /etc/profile
export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib
注：修改文件后要想马上生效还要运行# source /etc/profile不然只能在下次重进此用户时生效。
2.2 在用户目录下的.bash_profile文件中增加变量【对单一用户生效(永久的)】
用VI在用户目录下的.bash_profile文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。
例如：编辑guok用户目录(/home/guok)下的.bash_profile
$ vi /home/guok/.bash.profile
添加如下内容：
export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib
注：修改文件后要想马上生效还要运行$ source /home/guok/.bash_profile不然只能在下次重进此用户时生效。
2.3 直接运行export命令定义变量【只对当前shell(BASH)有效(临时的)】
在shell的命令行下直接使用[export 变量名=变量值] 定义变量，该变量只在当前的shell(BASH)或其子shell(BASH)下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话 还需要重新定义。
3.环境变量的查看
3.1 使用echo命令查看单个环境变量。例如：
echo $PATH
3.2 使用env查看所有环境变量。例如：
env
3.3 使用set查看所有本地定义的环境变量。
unset可以删除指定的环境变量。
4.常用的环境变量
PATH 决定了shell将到哪些目录中寻找命令或程序
HOME 当前用户主目录
HISTSIZE　历史记录数
LOGNAME 当前用户的登录名
HOSTNAME　指主机的名称
SHELL 当前用户Shell类型
LANGUGE 语言相关的环境变量，多语言可以修改此环境变量
MAIL　当前用户的邮件存放目录
PS1　基本提示符，对于root用户是#，对于普通用户是$
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39e09041f725e5830682719158f1b3d6/" rel="bookmark">
			shell变量详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 创建变量 xpz=xiaopzi
2 读取变量 (1)echo ${xpz}
(2)echo $xpz
(3)注意：echo ${xpz}s 和 echo $xpzs 输出是不一样的
3 撤销变量 unset xpz
unset -f 函数名 //撤销函数
小结：bash是弱类型语言，默认会把变量当成字符串处理，所以，我们可以认为bash中的变量值都是字符串。
变量是存在作用域的概念的，按照作用域划分：本地变量和环境变量
本地变量 本地变量的作用域：只对当前bash进程有效，对当前shell之外的其他shell进程，包括当前shell的子进程都无效
本地变量还分为：局部变量和全局变量
局部变量创建方式:local varname=value
局部变量的作用域：局部变量只对当前函数或者代码段有效
环境变量 声明方式：export varname=value
作用域：当前shell进程以及子进程
脚本执行方式 1 source ./test.sh
. /root/test/test.sh
点 空格 脚本全路径
//表示脚本在当前进程执行
2 ./test.sh //打开一个子进程
只读变量 声明方式：readonly varname＝value
不可修改，不可撤销（unset），如果想让只读变量消失，只能退出当前shell
作用域：和本地变量一样，如果想让子shell进程继承，只能变成环境只读变量
环境只读变量 声明方式：export readonly varname=value
特殊变量 $? 保存了上一个命令执行状态返回值
范围：0-255 0表示成功
位置变量
$# 表示传入脚本参数的个数
$@ 参数列表，获取到所有参数
$* 参数列表 同$#
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39e09041f725e5830682719158f1b3d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09f669f58bee9a84b586561cd81e8308/" rel="bookmark">
			适用于电脑的 8 款文件/软件迁移软件 – 快速安全地更换电脑！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将文件/软件从一台设备传输到另一台设备已成为我们日常生活的重要组成部分，无论是出于个人目的还是出于职业目的。在当今快节奏的世界中，我们经常需要在不同设备之间传输大文件，例如视频、照片、文档等。虽然云服务提供了一种共享文件的好方法，但它们也有局限性。它们不仅成本高昂，而且需要互联网连接，而互联网连接可能并不总是可用。
幸运的是，随着文件/软件传输软件的出现，传输大文件变得更加容易、方便和可靠。市场上有许多文件/软件传输软件解决方案。然而，并非所有这些都提供相同的质量、效率和易用性。在这篇博文中，我们将讨论适用于电脑 的 8 个文件/软件文件传输软件，它们可以帮助您快速、安全地共享文件。
什么是文件/软件传输软件？ 文件/软件传输软件是一种用于在不同设备或计算机之间传输文件的软件。这些软件解决方案旨在促进快速、安全和可靠的文件传输，无需 USB 驱动器或外部硬盘驱动器等物理设备。通过这些软件解决方案，用户可以传输任何大小的文件，从文档和图像等小文件到视频和整个文件夹等大文件。
文件/软件传输软件使用专门的协议在两个设备之间建立连接，使它们能够安全、快速地传输数据。文件传输软件可用于个人和专业目的，包括与朋友和家人共享文件、项目协作以及备份数据。
适用于电脑的 8 款最佳文件/软件传输软件 1. 奇客电脑迁移 奇客电脑迁移是市场上最受欢迎的基于云的文件传输软件解决方案之一。它提供多种文件迁移，包括软件与授权信息。奇客电脑迁移用户友好，允许用户快速传输任何大小的文件。它与各种操作系统无缝集成，包括 Windows、Mac 。
奇客电脑迁移电脑数据迁移可以轻松地将所有数据从旧电脑转移到新电脑，支持程序、软件设置、文档（Word、Excel、钉钉文件等）、音乐、图片、视频、收藏夹、电子邮件等所有电脑文件迁移。https://www.geekersoft.cn/dian-nao-qian-yi.html
此外，奇客电脑迁移提供了一个软件授权信息查看迁移功能，用户可以实时管理软件授权管理文件。能很好的避免软件搬家后不能使用问题，该软件使用户能够迁移整个文件夹，使其成为项目团队的理想选择。
优点：
– 用户友好的界面
– 与各种操作系统集成
– 提供软件与授权迁移
缺点：
– 免费版本的存储选项有限。
2. 特雷索里特 Tresorit 是市场上最安全的文件传输软件解决方案之一。它使用端到端加密技术来确保所有传输的数据都是安全的。Tresorit 提供 14 天免费试用，试用后用户可以选择不同的定价计划。该软件还具有用户友好性，使用户能够轻松地与其他用户共享文件。
此外，Tresorit 允许用户为他们共享的每个文件或文件夹设置特定权限，从而轻松管理访问控制。该软件还提供与各种操作系统的集成，包括 Windows、Mac 和 Linux。
优点：
– 通过端到端加密提供顶级安全性
– 允许用户为文件或文件夹设置特定权限
– 用户友好的界面
缺点：
– 成本可能很高，尤其是对于预算有限的团队而言。
– 定价结构可能不适合小型企业或自由职业者。
3、WeTransfer WeTransfer 是一款流行的文件传输软件，提供免费和付费版本。免费版本允许用户一次最多传输 2GB 的数据，而付费版本则提供高达 20GB 的传输限制。该软件易于使用，使用户能够快速传输文件，无需注册任何帐户或安装额外的软件。
通过 WeTransfer，用户可以通过电子邮件发送文件或共享上传文件的链接。该网站还提供视觉背景和 GIF，使其成为一种愉快而有趣的文件共享体验。
优点：
– 提供快速、简单的文件传输，无需注册帐户
– 网站界面具有视觉吸引力
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09f669f58bee9a84b586561cd81e8308/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d60e64d0cdabb140f94e9b827866379/" rel="bookmark">
			（附源码）node.js&#43;高校跳蚤市场网站 毕业设计39420
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		node.js高校跳蚤市场网站 摘 要 随着互联网的使用越来越广泛，人们开始选择网站购物，但是就目前来说，这些购物网站所面对的对象大多是社会总体人群，在商品选择的问题上，并没有很强的针对性，而且大多数购物系统均需购买者支付邮费，因此不能很好的满足用户对商品出售的需求。面对这一现状，在充分利用网上购物技术这一总体优势的基础上，完善了对应的软体架设以及程序编码的工作，采取MySQL作为后台数据的主要存储单元，采用SSM框架、JSP技术、Ajax技术进行业务系统的编码及其开发，设计了一个专门针对购物用户的跳蚤市场应用网站，给购物用户提提供商品交易的平台。
该系统的设计遵循了模块化的原则，将一个完整的跳蚤市场网站分解为各个模块，然后逐一实现各个模块的功能，最后把各个模块组装到一起构成一个完整的跳蚤市场网站。
关键词：跳蚤市场；Node.js ；数据库
node.js University Flea Market Website Abstract As the Internet is used more and more widely, people begin to choose websites for shopping. However, for the moment, these shopping websites are mostly targeted at the general population of the society. They are not very targeted in terms of commodity selection, and most shopping systems require the buyer to pay the postage, so they cannot meet the user's demand for commodity sales.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d60e64d0cdabb140f94e9b827866379/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/565c85ec25721c001ec16c1c1ef4e423/" rel="bookmark">
			18. Mysql 存储过程，实现动态数据透视
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述常见操作创建存储过程存储过程局部变量定义和赋值查看存储过程删除存储过程调用存储过程 示例-动态数据透视详细讲解总结参考资料 概述 Mysql 存储过程是一组预先编译的 sql 语句集合，它们被存储在数据库中，并可以被多次调用执行。存储过程可以接受参数、执行复杂的逻辑操作，并返回结果或修改数据库的状态。
存储过程有以下几个优点：
代码复用：存储过程可以将常用的操作逻辑封装起来，以便在多个地方重复使用，避免重复编写相同的 sql 语句。
提高性能：存储过程在编译时进行优化，可以减少通信开销，提高数据库的执行效率。
安全性：存储过程可以控制对数据库的访问权限，只暴露必要的接口，提高数据的安全性。
简化操作：存储过程可以执行复杂的数据库操作，减少客户端与数据库之间的交互次数，简化了客户端的代码。
常见操作 创建存储过程 使用 create procedure 语句来创建存储过程，语法如下：
create procedure procedure_name ([in|out|inout] parameter_name data_type [, ...]) begin -- 存储过程的代码逻辑 end; 其中，procedure_name是存储过程的名称，parameter_name是存储过程的参数名，data_type是参数的数据类型。 in、out 或 inout 类型解释如下：，分别表示输入参数、输出参数和输入输出参数。
in ：表示当前参数为输入参数，存储过程只是读取这个参数的值。如果没有定义参数种类， 默认就是 in 。out ：表示当前参数为输出参数，执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值。inout ：表示当前参数既可以为输入参数，也可以为输出参数。 存储过程局部变量定义和赋值 局部变量的定义和赋值，在上一节有提到过，具体可查看：Mysql 变量的使用。
declare &lt;变量名&gt; &lt;变量类型&gt; default &lt;默认值&gt;; set &lt;变量名&gt;=&lt;值&gt;; 查看存储过程 # 查看存储过程和函数的创建信息 show create procedure 存储过程名称; # 查看存储过程状态信息 show procedure status like '%max_salary%'; 删除存储过程 删除是必修课，在任何一个DDL语句中都必须学习创建和删除，语法如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/565c85ec25721c001ec16c1c1ef4e423/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8becc7aa88403e28e397735d68ff3eff/" rel="bookmark">
			Octave处理高斯光束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 读取图像截取感兴趣区域强度图拟合 Octave是一种开源的数值计算软件，主要用于科学计算、数据分析和数值模拟等领域。既提供了一个用户友好的命令行界面，使用户能够通过输入简单的命令来进行各种数学运算和数据操作。也提供了功能完备的GUI窗口，可以时刻监控变量。因其与Matlab相似的语法和功能，因此也被视为Matlab的开源替代品。
用不同的语言和工具处理高斯光束：
Python✨R语言✨Julia✨Mathemetica✨C#✨Excel+VBA✨ImageJ✨Octave
读取图像 Octave与Matlab有着几乎完全相同的语法，堪称Matlab的最佳开源替代。其图像处理方法也与Matlab如出一辙，首先，通过imread打开图像。
Octave界面上方会显示当前目录，若图像在当前目录中，可使用相对路径；否则需要使用绝对路径。
img = imread('test.bmp');%通过相对路径读取图片 img = imread('D:\Code\optics\img\test.bmp');%通过绝对路径读取图片 size(img) %ans = % 1024 1280 imshow(img) 下图是Octave的绘图窗口。
截取感兴趣区域 上图中存在大量的无用信息，目标光斑仅占据很小的一片区域，故需对图像进行截取，首先通过函数ginput选择截取区域。ginput操作的是最后被打开而未被关闭的窗口对象，其输入参数为将要选取的点的个数，在这里我们选择两个点将目标区域框起来，其返回值为选取点的横纵坐标。
和Matlab不同，如果不明确其输出变量X,Y,Btn，那么返回值将只显示第一项，即X。
imshow(img) [X,Y,Btn] = ginput(2) %X = % 353.24 % 434.34 %Y = % 178.93 % 265.93 %Btn = % 1 % 1 接下来通过矩阵选取的方式，选择感兴趣的区域，需要注意的是，截取图像时行在前，列在后，而x代表列数，y代表行数。截取之后的图片如下图所示
roi = img(178:265, 353:434); imshow(roi) 强度图 灰度图并不直观，相比之下，3D网格图可以更加直观地表现光斑的强度信息，mesh函数可以做到这一点
mesh(roi) 通过view函数，可调整网格图的视角，例如，[0 0 1]表示俯视图
view([0 0 1]) 二者效果如下
默认视图view([0 0 1]) 拟合 高斯光束之所以被冠以高斯之名，乃因其在空间中强度呈现出高斯分布，所以接下来就要通过高斯函数对齐进行拟合。然而作为二维数据的图像，在拟合时并不直观，故此可从每一行选出最大值作为单一坐标下的强度，然后再行数据拟合。
arr = max(roi); arr = double(arr); %将其转为浮点型 x = 1:length(arr)*1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8becc7aa88403e28e397735d68ff3eff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2b3c8f12acbc537afd0700132055bcf/" rel="bookmark">
			VUE——IDEA 启动前端工程VS文件启动前端工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IDEA 启动前端
目录 前言一、打开控制台二、输入npm install三、依赖下载完之后，输入npm run dev，运行前端项目1、IDEA启动前端工程2、文件目录启动前端工程 四、点击http://localhost:8080后续敬请期待 前言 启动已有的vue前端项目
一、打开控制台 选中前端工程，右键，点价下图按钮
二、输入npm install 输入npm install 下载依赖
三、依赖下载完之后，输入npm run dev，运行前端项目 1、IDEA启动前端工程 2、文件目录启动前端工程 找到文件目录，在地址输入cmd，回车
输入npm run dev，回车即可
四、点击http://localhost:8080 运行成功之后，点击图中的 http://localhost:8080 即可访问启动的前端页面
后续敬请期待 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/347604ddf0b39dfe398a8d9ee72b569e/" rel="bookmark">
			BIO和NIO编程(待完善)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BIO 阻塞式IO, 不支持高并发
NIO 非阻塞式IO
Reactor模式
NIO的三大核心组件：Selector 选择器、Channel 管道、buffer 缓冲区
SelectionKey: 连接事件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55346e6ade0f4380701fa39dfda111b9/" rel="bookmark">
			基于Spring Boot的校园二手平台设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、技术栈
二、系统功能介绍
三、核心代码
1、登录模块
2、文件上传模块
3、代码封装
前言 信息数据从传统到当代，是一直在变革当中，突如其来的互联网让传统的信息管理看到了革命性的曙光，因为传统信息管理从时效性，还是安全性，还是可操作性等各个方面来讲，遇到了互联网时代才发现能补上自古以来的短板，有效的提升管理的效率和业务水平。传统的管理模式，时间越久管理的内容越多，也需要更多的人来对数据进行整理，并且数据的汇总查询方面效率也是极其的低下，并且数据安全方面永远不会保证安全性能。结合数据内容管理的种种缺点，在互联网时代都可以得到有效的补充。结合先进的互联网技术，开发符合需求的软件，让数据内容管理不管是从录入的及时性，查看的及时性还是汇总分析的及时性，都能让正确率达到最高，管理更加的科学和便捷。本次开发的校园二手平台实现了学生可以快速查询到自己想要的商品。系统运用到了关系型数据库中MySql作为系统的数据库，有效的对数据进行安全的存储，有效的备份，对数据可靠性方面得到了保证。并且程序也具备程序需求的所有功能，使得操作性还是安全性都大大提高，让校园二手平台更能从理念走到现实，极大提高了学生们的信息处理效率。
一、技术栈 末尾获取源码
SpringBoot+Vue+JS+ jQuery+Ajax...
二、系统功能介绍 首页是系统前台用户注册登录页面，有账号密码的用户可以输入自己的账号密码登录到系统；没有账号密码的可点击注册用户输入自己的相关信息即可注册成功； 登录进入到系统，会在个人中心显示你注册时候输入的信息并且可以选择修改自己的个人信息或者头像等； 在首页用户可以查看到系统的公告信息，如需要更深度了解公告信息则可以选择点击相应的公告信息进入查看； 在商品界面我们可以看到管理员发布的商品信息，如有喜欢的商品则可以点击想要的商品进入商品详情页面进行加入购物车或者选择直接购买又或者选择留言； 在商品求购页面，用户可以查看到其他用户发布的求购商品，如用户有该商品可以选择点击相应商品进入到商品详情页面查看用户的联系方式进行联系。 在购物车页面，用户可以查看自己加入购物车的商品，如有需要则可以点击购买选择下单并且付款； 在前台页面，点击导航上的后台管理可以跳转到管理员和用户的登录页面 输入正确的账号密码后会跳转到校园二手平台的后台首页，进入到系统的页面如下图显示以下全部功能限于管理员仅有； 在个人中心中，管理员可以修改自己的密码或者修改自己的信息； 在管理员管理中，现有的管理员可以添加新的管理员； 在举报入口页面，管理员可以查看用户举报的信息情况等； 在基础数据管理中，管理员可以对公告类型和商品类型进行添加删除修改等操作； 在公告信息管理中，管理员可以发布新的公告信息又或者可以删除等操作； 在商品管理中，管理员可以在商品管理中添加新的商品又或者删除修改商品等；在商品留言中，管理员可以查看用户针对某个商品留言；在商品订单中可以查看用户下单的商品信息； 在商品求购中，管理员可以查看用户发布的商品求购商品，如有违禁可以选择删除等； 三、核心代码 1、登录模块 package com.controller; import java.util.Arrays; import java.util.Calendar; import java.util.Date; import java.util.Map; import javax.servlet.http.HttpServletRequest; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestController; import com.annotation.IgnoreAuth; import com.baomidou.mybatisplus.mapper.EntityWrapper; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55346e6ade0f4380701fa39dfda111b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95717217f10d7f29a0d2b975059f7408/" rel="bookmark">
			基于Spring Boot的疫情社区管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、技术栈
二、系统功能介绍
前台首页功能模块
管理员功能模块
用户功能模块
三、核心代码
1、登录模块
2、文件上传模块
3、代码封装
前言 随着互联网大趋势的到来，社会的方方面面，各行各业都在考虑利用互联网作为媒介将自己的信息更及时有效地推广出去，而其中最好的方式就是建立网络管理系统，并对其进行信息管理。由于现在网络的发达，疫情社区管理系统的资讯信息通过网络进行信息管理掀起了热潮，所以针对疫情社区管理系统的用户需求开发出一套疫情社区管理系统。
整个开发过程首先对软件系统进行需求分析，得出系统的主要功能。接着对系统进行总体设计和详细设计。总体设计主要包括系统功能设计、系统总体结构设计、系统数据结构设计和系统安全设计等；详细设计主要包括系统数据库访问的实现，主要功能模块的具体实现，模块实现关键代码等。最后对系统进行功能测试，并对测试结果进行分析总结，得出系统中存在的不足及需要改进的地方，为以后的系统维护提供了方便，同时也为今后开发类似系统提供了借鉴和帮助。
本系统开发利用现有的成熟技术参考，以源代码为模板，分析功能调整与疫情社区管理系统的实际需求相结合，确定了Java开发疫情社区管理系统的使用。
一、技术栈 末尾获取源码
SpringBoot+Vue+JS+ jQuery+Ajax...
二、系统功能介绍 前台首页功能模块 疫情社区管理系统，在系统首页可以首页、医疗专家、志愿者信息、论坛信息、疫情公告、留言反馈、个人中心、后台管理等内容
登录、用户注册，在用户注册页面可以填写用户名、密码、姓名、身份证、手机、地址等进行用户注册
医疗专家，在医疗专家页面填写账号、职称、手机、价格、服务时间、简述等信息进行咨询、预约 管理员功能模块 管理员登录，管理员通过输入用户名，密码，角色等信息进入疫情社区管理系统
管理员登录进入疫情社区管理系统可以查看首页、个人中心，用户管理、医疗专家管理、专家咨询管理、咨询回复管理、预约信息管理、健康档案管理、志愿者信息管理、报名信息管理、行动报告管理、业务代办管理、费用缴纳管理、留言板管理、论坛管理、系统管理等内容
用户管理，在用户管理页面可以查看用户名、密码、姓名、性别、头像、身份证、手机、地址等内容，并可根据需要进行修改，删除或查看详细内容等操作
医疗专家管理，在医疗专家管理页面可以查看账号、密码、专家姓名、性别、头像、职称、手机、价格、服务时间、简述等内容，并可根据需要对医疗专家管理进行修改，删除或查看详细内容等操作
志愿者信息管理，在志愿者信息管理页面可以查看名称、图片、简介、招募要求、文件、招募人数、报名人数、日期等内容，并可根据需要对志愿者信息管理进行修改，删除或查看详细内容等操作
轮播图；该页面为轮播图管理界面。管理员可以在此页面进行首页轮播图的管理，通过新建操作可在轮播图中加入新的图片，还可以对以上传的图片进行修改操作，以及图片的删除操作
预约信息管理，在预约信息管理页面可以查看名称、账号、专家姓名、价格、预约日期、预约时间等内容，并可根据需要进行修改，删除或查看详细内容等操作
健康档案管理，在健康档案管理页面可以查看档案编号、名称、用户名、姓名、检查状况、医生建议、发布日期等内容，并可根据需要进行修改，删除或查看详细内容等操作
行动报告管理，在行动报告管理页面可以查看名称、用户名、姓名、行动轨迹、体温、身体状况等内容，并可根据需要进行修改，删除或查看详细内容等操作
用户功能模块 用户登录，用户通过输入用户名，密码，角色等信息进入疫情社区管理系统
用户登录进入疫情社区管理系统可以查看首页、个人中心、专家咨询管理、咨询回复管理、预约信息管理、健康档案管理、报名信息管理、行动报告管理、业务代办管理、费用缴纳管理等功能
预约信息管理，在预约信息管理页面可以通过填写名称、账号、专家姓名、价格、预约日期、预约时间等详细信息进行查看详情
健康档案管理，在健康档案管理页面可以通过填写档案编号、名称、用户名、姓名、检查状况、医生建议、发布日期等内容进行查看、详情
行动报告管理，在行动报告管理页面可以通过填写名称、用户名、姓名、行动轨迹、体温、身体状况等内容进行查看、详情
三、核心代码 1、登录模块 package com.controller; import java.util.Arrays; import java.util.Calendar; import java.util.Date; import java.util.Map; import javax.servlet.http.HttpServletRequest; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95717217f10d7f29a0d2b975059f7408/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e45204f6825e1a4471455940f616d0fa/" rel="bookmark">
			FingerprintService启动-Android13
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FingerprintService启动-Android13 1、指纹服务启动1.1 rc启动Binder对接指纹厂商TA库1.2 FingerprintService启动1.2.1 SystemServer启动FingerprintService1.2.2 注册Binder服务fingerprint 2、获取底层信息2.1 AIDL 对接TA中获取2.2 指纹类型判断 android13-release 1、指纹服务启动 1.1 rc启动Binder对接指纹厂商TA库 android虚拟设备 这里android.hardware.biometrics.fingerprint@2.1-service.rc，实际现在Android 13上使用 AIDL 调用指纹厂商TA so库
（HIDL转换AIDL了解一下：AOSP &gt; 文档 &gt; 核心主题 &gt; HIDL；对于fwk层实质是一样的，之前只是区分hwBinder域，这里注册的Binder服务android.hardware.biometrics.fingerprint@2.1::IBiometricsFingerprint/default）
12-24 09:54:06.228 0 0 I init : Parsing file /vendor/etc/init/android.hardware.biometrics.fingerprint@2.1-service.rc... 12-24 09:54:16.601 511 511 D android.hardware.biometrics.fingerprint@2.1-service: Opening fingerprint hal library... 12-24 09:54:16.616 511 511 D FingerprintHal: ----------------&gt; fingerprint_open -----------------&gt; 12-24 09:54:16.616 511 511 D FingerprintHal: ----------------&gt; set_notify_callback -----------------&gt; 12-24 09:54:16.616 511 511 D FingerprintHal: fingerprint callback notification set 12-24 09:54:16.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e45204f6825e1a4471455940f616d0fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f29c6729de4f84f76d06c56ac525d71/" rel="bookmark">
			分布式系统架构设计之分布式数据存储的扩展方式、主从复制以及分布式一致性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三、水平扩展和垂直扩展 在分布式系统中，数据存储的扩展是为了适应业务的增长和提高系统的性能。分为水平扩展和垂直扩展两种方式，这两种方式在架构设计和应用场景上有着不同的优势和局限性。
水平扩展 水平扩展是通过增加节点或服务器的数量来扩大整个系统的容量和性能。在数据存储领域，水平扩展通常表现为将数据分不到多个节点或副本上，每个节点负责存储一部分数据，先来看看水平扩展的一些关键特性：
数据分片：将数据按照某种规则分成多个片段，每个片段分配给不同的节点。这样可以降低单个节点的负载，提高系统整体的读写性能。分布式存储系统：采用分布式数据库或存储系统，使得数据可以水平分布在不同的节点上，提高了系统的可扩展性。负载均衡：通过负载均衡算法确保每个节点的负载均衡相对均衡，避免单一节点成为瓶颈。弹性伸缩：可根据业务需求动态添加或移除节点，实现系统的弹性伸缩。 使用水平扩展之后，我们可以：
提高系统的横向扩展性，适应大规模数据和高并发访问易于实现和操作，可以通过添加节点来线性扩展性能 但是以下挑战在使用水平扩展的时候需要关注：
一些复杂业务场景难以进行水平分割，导致某些节点负载过重，比如具有强烈一致性需求的场景数据一致性和事务处理相对复杂度很高 垂直扩展 垂直扩展是通过提升单个节点或服务器的性能来提高整个系统的容量和性能。在数据存储方面，垂直扩展通常表现为增加节点的硬件资源，例如更大的内存、更强大的 CPU、更快的存储设备等。看看水平扩展的一些关键特性：
单节点资源增加：通过升级节点的硬件配置，增加处理能力、内容容量和存储速度。数据库垂直分区：将不同的数据或表分布到不同的节点上，使每个节点专注于处理特定类型的数据。缓存和索引优化：通过更高效的缓存机制和索引设计来提高单节点的读取性能。数据库垂直划分：将数据库按照业务功能垂直划分，每个数据库负责不同的业务模块。 使用垂直扩展的优势：
针对一些单一业务模块压力较大的场景，提高了单节点的性能相对简单，不涉及数据的分片和迁移 但是：
成本较高，硬件升级和维护可能导致较大的投入不易应对业务的爆炸性增长，存在一定的性能瓶颈 在实际应用场景中，水平扩展和垂直扩展经常是组合使用，根据具体的业务场景和需求来综合考虑，选择何种扩展方式，需要架构师根据系统的特点、业务需求、性能要求和预算等多个方面来进行全面评估。
四、主从复制和分布式一致性 主从复制 主从复制是一种数据复制模型，其中一个数据节点的变更操作会被异步地复制到其他节点中，一般只主节点的变更操作到从节点上。这种模型通常用于提高系统的可用性、读取性能以及数据备份场景。
主从复制一般包括以下步骤：
主节点写入：所有应用的写入操作先发生在主节点上，对主节点的库表进行写入。异步复制：主节点写入数据之后，将变更操作记录成日志，并将这些日志异步地传播到从节点，比如 MySQL 的 binlog。从节点应用：从节点接收到日志推送后，将主节点的变更操作应用用本地数据，使得从节点的数据与主节点数据保持一致。 使用主动复制，可以：
提高读取性能：从节点可以专门处理读取请求，分担主节点的读取压力，提高整体读取性能，这也就是平时说的读写分离的实现模式容灾备份：从节点在主节点发生故障时，可以转变成为主节点，提供容灾备份能力，保障系统在故障场景下的可用性数据分发：从节点还可以设计成位于不同的地理位置，实现数据在多个地点的分发，一般异地多活和国际化场景多采用此种模式 但采用主从复制之后，也存在以下挑战：
数据延迟：由于异步复制的特性，从节点的数据可能存在一定的延迟，不过使用云原生技术时，有云原生产品来保障，该挑战基本上可以避免解决写入压力：所有写入操作都在主节点，可能会造成主节点的写入压力过大，所以对于主节点的运维精力要投入更多 分布式一致性 分布式一致性是指在分布式系统中，各个节点对共享状态的变更达成一致的过程。保持一致性是分布式系统中的核心挑战，因为各个节点质检的通信可能存在延迟、故障、网络分区等问题。
CAP 原理 前面章节部分已经详细解释了 CAP 原理，这里不再赘述，知识点再次提醒：
一致性：所有节点看到的数据是一致的可用性：每个非故障节点都能读写分区容忍性：系统在遇到网络分区的情况下依旧可以保持一致性和可用性 一致性类型 强一致性：所有节点在同一时间看到的数据状态是相同的弱一致性：允许节点在不同时间看到不同的数据状态，但最终会一致最终一致性：最终所有节点都会达到一致状态，但是在中间阶段可能存在不一致 分布式协议 两阶段提交（2PC）：保证事务的一致性，但可能存在阻塞和单点故障三阶段提交（3PC）：解决了 2PC 的一些问题，但依旧存在不足Paxos 和 Raft：分布式共识协议，用于解决分布式一致性问题 挑战 性能开销：一致性协议会带来额外的通信和计算开销网络分区：可能导致节点之间无法达成一致，需要在一致性和可用性之间做出权衡 在分布式一致性中还有一个特别经典的内容，那就是分布式事务，这里不对分布式事务进行介绍，后面会有专门的章节来详细讲解分布式事务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f150572f40e9d73acc0a5b863a21007/" rel="bookmark">
			C语言中的难点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 C语言把内存划分成四个区，它把一般的变量和数组等存在于内存中的栈区，全局变量在静态区若指针没有被初始化,那么指针可能会指向任何内存位置,这样可能会导致程序崩溃或者行为不确定，野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）指针变量在定义时如果未初始化多个指针指向同一个地址,这样使用没什么问题c++中有string类可以直接定义字符串，而c语言中不可以，只可以引入string.h包含处理字符串的函数，但是定义还是char[]数组类型数据结构(尤其是栈)应该尽可能地在自然边界上对齐。 原因在
于，为了访问未对齐的 内存，处理器需要作两次内存访问；而对齐的内访问仅需要一次访问。总体来说：结构体的内存对齐是拿空间来换取时间的做法。优点是提高了cpu访问性能。p+1就是a+1的值都代表a[1]的地址，两者是相等的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d85612b9415f48a9b7f0f2e18b462c5/" rel="bookmark">
			从零开始配置kali2023环境：配置jupyter的多内核环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在kali2023上面尝试用anaconda3，anaconda2安装实现配置jupyter的多内核环境时出现各种问题，现在可以通过镜像方式解决
1. 搜索镜像 ┌──(holyeyes㉿kali2023)-[~]
└─$ sudo docker search anaconda
┌──(holyeyes㉿kali2023)-[~] └─$ sudo docker search anaconda [sudo] password for holyeyes: NAME DESCRIPTION STARS OFFICIAL AUTOMATED continuumio/anaconda3 Powerful and flexible python distribution 755 [OK] continuumio/anaconda Powerful and flexible python distribution 218 [OK] okwrtdsh/anaconda3 Anaconda3, Jupyter Notebook, OpenCV3, Tensor… 41 [OK] drunkar/anaconda-tensorflow-gpu anaconda-tensorflow-gpu 12 [OK] fzinfz/anaconda3 multi-kernel jupyter(py 3.7+/2.7.15 &amp; bash) … 4 continuumio/anaconda2 4 continuumio/anaconda-pkg-build 2 xychelsea/anaconda3 Anaconda 3 base containers, including with N… 2 kunitaya/anaconda3 Anaconda3 on CentOS 1 [OK] geordgez/anaconda-sh 1 alleninstitute/anaconda3_neuron_1370 1 mikewright/anaconda-tensorflow An image that can be used to quickly start a… 1 [OK] quantrocket/anaconda3-uwsgi Learn more at https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d85612b9415f48a9b7f0f2e18b462c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5ac8b55bb8102ed3120a0598c0a20b1/" rel="bookmark">
			从零开始做题：pyHAHA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.题目信息 https://adworld.xctf.org.cn/challenges/list
解题思路 分析pyc文件
分析压缩包中的MP3，分析MP3解隐写得到的字符
01字符串画图
pyc反编译，py代码逆向分析
解题步骤 1.分析pyc 1.1 拿到一个pyc，通过tool.lu/pyc反编译，结果显示反编译不成功，猜测是pyc隐写 补充知识点：
pyc文件：python是一种解释器语言，为了提高运行效率，将py源码文件编译为pyc可执行文件
pyc反编译：通过工具将pyc文件反编译成py源码
1.2 用winhex打开该文件，发现2galf，1galf关键字，看出是倒序了而且压缩了 1.3 将文件进行正序并发现少文件头03F30D0A补上 f = open('PyHaHa2.pyc','wb') with open('PyHaHa.pyc','rb') as g: f.write(g.read()[::-1]) f.close() 1.4 另存为PyHaHa2-modify -zip，用7-zip解压缩得到Dream It Possible 1.5 用工具DeEgger Embedder可以提取Dream It Possible - extracted，得到base32编码的内容 1.6 通过tool.lu/pyc反编译PyHaHa2-modify.pyc得到 #!/usr/bin/env python # visit http://tool.lu/pyc/ for more information from os import urandom def generate(m, k): result = 0 for i in bin(m ^ k)[2:]: result = result &lt;&lt; 1 if int(i): result = result ^ m ^ k if result &gt;&gt; 256: result = result ^ P continue return result def encrypt(seed): key = int(urandom(32).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5ac8b55bb8102ed3120a0598c0a20b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0705e84e484a9f2ffebcd8eaa5cb05a6/" rel="bookmark">
			vue3 element plus el-table封装（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上文是对el-table的基本封装，只能满足最简单的应用，本文主要是在上文的基础上增加slot插槽，并且对col插槽进行拓展，增加通用性
// BaseTable.vue
&lt;template&gt; &lt;el-table&gt; &lt;template v-for="name in tableSlots" :key="name" #[name]&gt; &lt;slot :name="name"&gt;&lt;/slot&gt; &lt;/template&gt; &lt;el-table-column v-for="(col,index) in $attrs.config" :key="index" v-bind="col"&gt; &lt;template v-if="col.slot" #[getColSlot(col)]="scope" &gt; &lt;slot :name="col.slot" v-bind="scope"&gt;&lt;/slot&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/template&gt; &lt;script lang="ts" setup&gt; const slots=useSlots(); const tableSlots=computed(()=&gt;{ // 原生el-table插槽只有default,append,empty // 原生el-table-column插槽只有table插槽只有default,header // 这里将header单独处理，认为是col的插槽，从table插槽中排除 return Object.keys(slots).filter(name=&gt;name!=='header') }) const getColSlot=(col)=&gt;{ return col.slot==='header'?'header':'default' } &lt;/script&gt; //index.vue
&lt;template&gt; &lt;BaseTable :config="config" :data="tableData" :style="{width:'800px'}"&gt; &lt;template #status="scope"&gt; &lt;el-text :type="scope.row.status.type "&gt;{{ scope.row.status.content }}&lt;/el-text&gt; &lt;/template&gt; &lt;template #btn="scope"&gt; &lt;el-button type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0705e84e484a9f2ffebcd8eaa5cb05a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21e49b4a952e6a5fa618e26a89d0596d/" rel="bookmark">
			【算法】数论---取模运算法则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		取模运算（余数运算）有一些基本的运算法则：
(a + b) % m = (a % m + b % m) % m(a - b) % m = (a % m - b % m) % m(a * b) % m = (a % m * b % m) % ma ^ b % p = ((a % p)^b) % p 取模运算（余数运算）有一些基本的性质：
同余性质： 如果两个整数 a 和 b 对于某个正整数 m 有 a % m = b % m，那么 a 和 b 被称为对模 m 同余，记作 a ≡ b (mod m)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f1d65a5dd8e3237abb461cb3a8bd276/" rel="bookmark">
			【RDMA】rdma-core驱动源码包|ibverbs|rdmacm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
源码包
编译
用法
驱动包内的例子
其他
源码包 mellanox的rdma驱动源码包形式如下：
MLNX_OFED_LINUX-5.8-1.1.2.1-rhel9.0-ext/src/MLNX_OFED_SRC-5.8-1.1.2.1/SRPMS
rdma-core-58mlnx43-1.58112.src.rpm
rpm -ivh rdma-core-58mlnx43-1.58112.src.rpm 安装完成后
源码解压到：/root/rpmbuild/SOURCES/
RDMA Core Userspace Libraries and Daemons
这是 Linux 内核驱动程序的用户空间组件，属于/infiniband 子系统。具体包含以下设备节点的用户空间库：
/dev/infiniband/uverbsX（libibverbs）/dev/infiniband/rdma_cm（librdmacm）/dev/infiniband/umadX（libibumad） libibverbs RDMA 内核驱动程序的用户空间组件包含在 providers/ 目录下。支持以下内核 RDMA 驱动程序：
efa.koiw_cxgb4.kohfi1.kohns-roce.koi40iw.koib_qib.komlx4_ib.komlx5_ib.koib_mthca.koocrdma.koqedr.kordma_rxe.kosiw.kovmw_pvrdma.ko 此外，还提供了以下额外的服务守护进程：
srp_daemon（ib_srp.ko）iwpmd（针对 iwarp 内核提供程序）ibacm（用于 InfiniBand 通信管理助手） 编译 进入驱动包目录，执行：
$ bash build.sh
输出在：build/bin 和 build/lib build/bin 目录包含示例程序，build/lib 目录包含共享库。
注意：目前不易从构建目录运行插件，插件仅从系统路径加载
编译之前环境可能需要安装一些依赖，如：
CentOS 7:
$ yum install epel-release
$ yum install cmake3 ninja-build pandoc
详情见README.md
用法 略
驱动包内的例子 驱动包例子的源码在驱动包的excample内
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f1d65a5dd8e3237abb461cb3a8bd276/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b8b0eb0635e895e517034d712c406de/" rel="bookmark">
			【Docker-Dev】Mac M2 搭建docker的redis环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis的dev环境docker搭建 1、前言2、官方文档重点信息提取2.1、创建redis实例2.2、使用自己的redis.conf文件。 3、单机版redis搭建4、redis集群版4.1、一些验证4.2、一些问题 结语 1、前言 本文主要针对M2下，相应进行开发环境搭建，然后做一个文档记录，是第二弹文章，搭建是采用docker compose文件。
希望对相关人有帮助。如果只想要Docker-Compose文件，请转到第三节的单机模式和第四节的集群模式。
针对第四节集群模式，这里有个地方需要提前说明，目前redis cluster的搭建模式，存在一个问题无法解决，即无法通过Docker暴露出的端口进行宿主机的外部访问连接，后续只能看看是否研究开启tsl或者其他方式允许访问。从内部各种方式可以验证出，集群状态是正常的，而且数据能正常访问。
原本是打算使用redis-commander进行docker集群内访问redis cluster，但是很可惜，官方似乎在docker compose组建的运行环境下是存在问题的，Issue看这。
2、官方文档重点信息提取 redis的docker镜像官网地址在此处点击。
hub地址是需要翻墙访问
2.1、创建redis实例 docker run --name some-redis -d redis 如果想持久化，则是如下命令：
docker run --name some-redis -d redis redis-server --save 60 1 --loglevel warning redis-server --save 60 1 --loglevel warning，这是传递给 Redis 服务器的参数，它告诉 Redis 服务器在后台每隔 60 秒检查一次数据库，如果有至少一个键被修改，则将其写入磁盘。后面的 1 表示如果至少有一个键被修改，则每秒进行一次检查。–loglevel warning 设置 Redis 服务器的日志级别为 “warning”，表示只记录警告级别的日志。
2.2、使用自己的redis.conf文件。 创建自己的Dockerfile文件，将上下文中的redis.conf添加到/data/中，如下所示
FROM redis COPY redis.conf /usr/local/etc/redis/redis.conf CMD [ "redis-server", "/usr/local/etc/redis/redis.conf" ] 也可以使用docker命令
docker run -v /myredis/conf:/usr/local/etc/redis --name myredis redis redis-server /usr/local/etc/redis/redis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b8b0eb0635e895e517034d712c406de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/771aae1e06ae3031c73a8849d0a18f29/" rel="bookmark">
			【算法】数论---快速幂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是快速幂？
快速幂:快速求a^b % p的值,时间复杂度:O(logb)
一、暴力写法--- 循环b次求出a^b mod p (时间复杂度:O(b)) int a,b,p; cin&gt;&gt;a&gt;&gt;b&gt;&gt;p; long long res=1; while(b--)res = res * a %p; cout&lt;&lt;res&lt;&lt;endl; 二、快速幂（时间复杂度:O(logb)） #include&lt;iostream&gt; using namespace std; typedef long long LL; LL qmi(int a, int b, int p) { LL ans = 1 % p; //这里%p是为了防止在b==0，p==1的情况出错 while (b) { if (b &amp; 1) ans = ans * a % p; //使用b的二进制的最后一位 b &gt;&gt;= 1; //使用完b的二进制的最后一位后将最后一位删掉 a = a * (LL)a % p; //计算下次要用的a } return ans; } int main() { int n; cin&gt;&gt;n; while(n--) { int a,b,p; cin&gt;&gt;a&gt;&gt;b&gt;&gt;p; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/771aae1e06ae3031c73a8849d0a18f29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b9264736db2c693487a7951607cab0/" rel="bookmark">
			【算法】数论---欧拉函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是欧拉函数？
对于正整数n，欧拉函数是小于或等于n的正整数中与n互质的数的数目，记作φ(n)
φ(1)=1
当m,n互质时，φ(mn)=φ(m)∗φ(n)
一、求一个正整数的欧拉函数---（先对它分解质因数，然后套公式） int x; cin&gt;&gt;x; int ans=x; map&lt;int,int&gt;h; for(int i=2;i&lt;=x/i;i++) { while(x%i==0) { x/=i; h[i]++; } } if(x&gt;1)h[x]++; for(auto i:h) { int j=i.first; //因为j最大不超过2x10^9，所有j的数据类型用int就足够了 ans=ans/j*(j-1); //因为每个j都是ans的质因子，所有ans/j肯定可以整除的，并且因为ans/j*(j-1)的结果肯定会小于ans，所有ans的数据类型用int就足够了 }//这里必须得是ans/j*(j-1)这个顺序，防止爆int cout&lt;&lt;ans&lt;&lt;endl; 二、求一个正整数的欧拉函数---线性筛法 #include&lt;iostream&gt; using namespace std; const int N=1000010; int primes[N],idx=0; bool st[N];int ou[N]; int main() { int n; cin&gt;&gt;n; for(int i=2;i&lt;=n;i++) { if(!st[i]) { primes[idx++]=i; ou[i]=i-1; } for(int j=0;primes[j]*i&lt;=n;j++) { st[primes[j]*i]=true; //primes[j]*i将会遍历所有的和数，然后在这里将它们标记（筛掉），再在下面将它们的欧拉函数求出 if(i%primes[j]==0) //i%primes[j]==0说明primes[j]是i的最小质因数 { ou[primes[j]*i]=ou[i]*primes[j]; break; } else //i%primes[j]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5b9264736db2c693487a7951607cab0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c706a9192429d83bf8a5ef49b85887b/" rel="bookmark">
			微信小程序-父子页面传值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		父子页面传值 父页面向子页面传值 方法一：
父页面：
1. /page/xxx/xxx?id=1 子页面：
onLoad:function(option){ } 方法二
&lt;bindtap=“func” data-xxx=””&gt; 子页面向父页面传值 定义父子页面 父页面：hotspot
子页面：topic
设计：hotspot页面，点击“请选择话题”，然后跳转到topic页面，topic页面显示默认的 热点列表；点击任意热点话题，跳转回hotspot页面并显示已选择的话题title。
hotspot.wxml
&lt;view bindtap="chooseTopic"&gt;{{topicTitle}}&lt;/view&gt; hotspot.js
data: { topicTitle:"请选择话题" }, /* 跳转到topic页面 */ chooseTopic: function(){ wx.navigateTo({ url: '/pages/topic/topic', }) }, /* 设置topicTitle */ setTopicTitle: function(d){ this.setData({topicTitle:d.title}); } topic.wxml
&lt;view&gt; &lt;view class="item" wx:for="{{topicList}}" bindtap="chooseTopic" data-topic="{{item}}"&gt; &lt;text &gt;#{{item.title}}&lt;/text&gt; &lt;text&gt;查看:{{item.view}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; topic.js
data: { /* 实际项目中，数据一般从后端获取，此处仅作模拟用 */ topicList:[ {id:0, title:"人工智能", view:100}, {id:1, title:"新能源汽车", view:95} ] }, chooseTopic: function(data){ var topicInfo = data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c706a9192429d83bf8a5ef49b85887b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8594e9e15a0d9f08963891cdf32dc2a/" rel="bookmark">
			解锁编程新年的神器——探索Maven Helper插件的妙用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 推荐阅读 轻松驾驭JDBC：一篇文章帮你搞定数据库连接
ChatGPT爆火一周年，快来拥有专属你的ChatGPT应用！
GraalVM+native-image+Visual Studio 在Win10上全流程安装，避坑+实操
文章目录 推荐阅读安装使用其他方法 下载链接
安装 点击设置，搜索maven helper 插件，然后选择安装。
安装完成后，重启idea.
使用 打开项目文件pom.xml后，可以发现文件的底端多了个“Dependency Analyzer”的选项。
切换到“Dependency Analyzer”视图后，可以发现如下界面
其中三个选项分别表示如下:
Conflicts---------查看冲突All Dependencies as List---------列表形式查看所有依赖All Dependencies as Tree---------树形式查看所有依赖 3、当没有依赖冲突或者解决依赖冲突时，当选择Conflicts时，右上角会多了个“No Conflicts”
当出现冲突需要解决时，下面会显示冲突的信息，我们可以选择冲突的依赖 Exclude它。
5、点击 Exclude 之后，插件自动会在 pom.xml 文件中添加 相关代码，进行子依赖的排除。
其他方法 1、IEDA其他快捷键
可以使用快捷键 Ctrl+Shift+AIt+U（idea默认的快捷键），直接显示出依赖关系树 选择右侧maven，点击右上角“Show Dependencies”图标后，会显示出依赖关系图。 2、使用Maven命令查看依赖冲突方法:
查看依赖： maven dependency:tree 查看依赖是否冲突： mvn dependency:tree -Dverbose -Dincludes=&lt;groupId&gt;:&lt;artifactId&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/468bb3628d3e720916a76fae9e14bcdd/" rel="bookmark">
			深度学习｜10.4 填充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		填充 首先有个问题就是nxn的矩阵用fxf的过滤器可以生成多大的矩阵
由于从一个nxn的矩阵变成一个 ( n − f + 1 ) × ( n − f + 1 ) (n-f+1) \times (n-f+1) (n−f+1)×(n−f+1)的矩阵，矩阵规模变小了，也就意味着有些信息是丢失的（如果不可逆的话）。
填充的目的——使得输入规模和输出规模保持一致 假设p为填充量，则输出规模将会扩充上2p。
而只有f为奇数时，才有办法确保算出来的p是整数。
也就是说为了填充能够实现前后规模相等的情况，往往核/过滤器的大小要设置成奇数乘上奇数的形式（比如3x3和5x5）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/121e911a0bbb5ba530a14084ecca9d89/" rel="bookmark">
			Linux驱动学习—pinctl和gpio子系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、pinctl和gpio子系统（一） 1.1pinctrl 子系统主要工作内容 &lt;1&gt;获取设备树中 pin 信息，管理系统中所有的可以控制的 pin， 在系统初始化的时候， 枚举所有可以控制的 pin， 并标识这些 pin。 &lt;2&gt;根据获取到的 pin 信息来设置 pin 的复用功能，对于 SOC 而言， 其引脚除了配置成普通的 GPIO 之外，若干个引脚还可以组成一个 pin group， 形成特定的功能。 &lt;3&gt;根据获取到的 pin 信息来设置 pin 的电气特性，比如上/下拉、速度、驱动能力等。 对应使用者来说，只需要在设备树里面设置好某个 pin 的相关属性即可，其他的初始化工作均由 pinctrl 子系统来完成。
1.2gpio子系统主要工作内容 当使用 pinctrl 子系统将引脚的复用设置为 GPIO，可以使用 GPIO 子系统来操作GPIO，Linux 内核提供了 pinctrl 子系统和 gpio 子系统用于 GPIO 驱动。
通过 GPIO 子系统功能要实现：
&lt;1&gt;引脚功能的配置（设置为 GPIO，GPIO 的方向， 输入输出模式，读取/设置 GPIO 的值） &lt;2&gt;实现软硬件的分离（分离出硬件差异， 有厂商提供的底层支持； 软件分层。 驱动只需要调用接口 API 即可操作 GPIO） &lt;3&gt;iommu 内存管理（直接调用宏即可操作 GPIO） gpio 子系统的主要目的就是方便驱动开发者使用 gpio，驱动开发者在设备树中添加 gpio 相关信息，然后就可以在驱动程序中使用 gpio 子系统提供的 API函数来操作 GPIO， Linux 内核向驱动开发者屏蔽掉了 GPIO 的设置过程，极大的方便了驱动开发者使用 GPIO。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/121e911a0bbb5ba530a14084ecca9d89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75bb70bf072e1b05a606837a671a6177/" rel="bookmark">
			vue3&#43;ts开发干货笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结一下在vue3中ts的使用。当篇记录部分来自于vue官网，记录一下，算是加深印象吧。
纯干笔记，不断补充，想到什么写什么，水平有限，欢迎评论指正！
类型标注 props &lt;script setup lang="ts"&gt; const props = defineProps({ foo: { type: String, required: true }, bar: Number }) props.foo // string props.bar // number | undefined &lt;/script&gt; 可以通过更直接的泛型定义
&lt;script setup lang="ts"&gt; const props = defineProps&lt;{ foo: string bar?: number }&gt;() &lt;/script&gt; 也可以将 props 的类型移入一个单独的接口中
&lt;script setup lang="ts"&gt; interface Props { foo: string bar?: number } const props = defineProps&lt;Props&gt;() &lt;/script&gt; 把定义单独放到另一个文件中，引入使用
&lt;script setup lang="ts"&gt; import type { Props } from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75bb70bf072e1b05a606837a671a6177/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49b8946730ba2b6658e89e5ac55ac50d/" rel="bookmark">
			[JS设计模式]Prototype Pattern
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Prototype pattern Prototype pattern可便于同类型的多个对象共享属性。原型（prototype）是JS原生的对象，其他对象可以通过原型链（prototype chain）来访问原型。单独看这句描述可能还是有点儿抽象，下面通过具体的示例来详细阐述。
class Dog { constructor(name) { this.name = name; } bark() { return `Woof!`; } } const dog1 = new Dog("Kadi"); console.log(dog1.__proto__); console.log(Dog.prototype); 这里可以看到，constructor有一个name属性;根据ES6类的语法规则，所有在类中定义的属性(本例的属性bark)，都自动加入到类的prototype中,Dog类本身有两个属性：constructor和bark。
有两种方式可以查看类的原型中的属性，一种是通过类本身的prototype，另一种是通过实例的__proto__。
从上图的调试信息可以看到，Dog类的prototype也是一个object，其中有两个属性bark和constructor，另外还有一个原型对象([[Prototype]])。
通常类的实例的__proto__直接引用类的prototype，如果类本身不包含某个属性，JS就会向下搜索原型链，查看在原型链中是否能找到被访问的属性。而在dog1实例中，发现有两个[[prototype]]，而且还有包含关系，这就是所谓的原型链。
因为所有实例都可以访问类的原型对象，因此原型模式使得实例在访问相同属性时，不用每次都创建该属性的副本。只需要将属性加入到原型中，则所有的实例都可以访问。另外，在创建实例对象后，也支持添加新的属性到原型中，其他实例对象也可以访问这个新加入的属性。
const dog2 = new Dog("Husky") Dog.prototype.play = ()=&gt; console.log(`playing`); dog1.play(); 我们再创建一个“Husky”的实例，然后对Dog类的原型添加一个新的属性play，接着通过dog1实例来调用play函数，看能否正常运行。
从运行结果来看，dog1能正常访问play属性。
再举个例子，定义一个SuperDog并继承Dog，SuperDog有一个fly属性。通过创建一个SuperDog的实例dog3，且dog3调用bark属性
class SuperDog extends Dog { constructor(name) { super(name); } fly() { console.log("Flying!"); } } const dog3 = new SuperDog("Super") dog3.fly(); dog3.bark(); console.log(dog3.__proto__); 此示例中有3级原型链，实例访问属性的搜索路径也非常清晰。dog3._proto_ -&gt; SuperDog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49b8946730ba2b6658e89e5ac55ac50d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aadfe039356129a19e64ae2b16b93aa5/" rel="bookmark">
			微信小程序开发系列-10组件间通信01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序开发系列目录 《微信小程序开发系列-01创建一个最小的小程序项目》
《微信小程序开发系列-02注册小程序》
《微信小程序开发系列-03全局配置中的“window”和“tabBar”》
《微信小程序开发系列-04获取用户图像和昵称》
《微信小程序开发系列-05登录小程序》
《微信小程序开发系列-06事件》
《微信小程序开发系列-07组件》
《微信小程序开发系列-08自定义组件模版特性》
《微信小程序开发系列-09自定义组件样式特性》
​
文章目录 微信小程序开发系列目录前言组件间通信普通事件绑定自定义事件类型绑定 总结 前言 通过06、07、08文章可以知道页面有事件系统，页面可以通过数据绑定进行逻辑层和渲染层通信。自定义组件可理解为一种特殊的页面，因此组件间、组件与“页面”间应该也是可以通信的。那么本文就学习下组件间的通信方式。
组件间通信 组件间的基本通信方式有以下3种。
WXML 数据绑定：用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容数据（自基础库版本 2.0.9 开始，还可以在数据中包含函数）。《微信小程序开发系列-08自定义组件模版特性》文章的数据绑定一节有介绍，本文不再赘述。事件：用于子组件向父组件传递数据，可以传递任意数据。父组件可以通过 this.selectComponent 方法获取子组件实例对象，直接访问子组件的任意数据和方法。 普通事件绑定 框架为开发者提供了一系列基础组件，而基础组件的事件在页面中的完整生成方式是：
在页面wxml的标签上通过bindtap指定事件处理函数；在页面的js中声明事件处理函数；当用户点击对应的标签时，事件便能触发； 框架为开发者提供了一系列事件类型，如tap事件(详细可参考《微信小程序开发系列-06事件》事件分类一节)。因此对开发者来说只需要2步就能完成对事件的处理：
绑定事件处理函数：在wxml文件的标签上通过bindtap绑定tap的事件处理函数声明事件处理函数：在对应的js中声明事件处理函数 做完这两步后，当用户点击对应的标签时，事件便能触发；只要是框架已经提供的事件类型，无论是页面还是自定义组件都可以按照这种方式来构造事件的处理。
为了便于后文的表述，我将框架提供的事件类型称为“标准事件”。
到这里，便想到一个问题，如果我想自定义事件，而不是框架已经为我们定义好的事件类型，那应该怎么实现？
自定义事件类型绑定 对于“标准事件”，声明事件处理函数的动作相当于注册了一个监听函数，当事件触发时，就会调用这个监听函数。其实，到目前为止，我一直不知道 当用户点击标签，这个点击动作的产生 到 监听函数被调用之间到底发生了什么？怎样就触发了 监听函数被调用？
到这里，便想到一个问题，如果我想自定义事件，而不是框架已经为我们定义好的事件类型，那应该怎么实现？
例如，我将bind:tap改成bing:sif666_event，其他都不改，myEvent函数还会被调用吗？试下。。。
结果是myEvent函数没有被调用，console没有输出。我猜想tap事件被触发 到监听函数被调用之间可能还有一个什么动作，而这个动作可能就是console没有输出的关键。
我们前面提到的那个关键“动作”就是triggerEvent函数。它可以为自定义事件类型在code层面去触发事件，进而做出响应。
自定义触发事件的选项还可以控制是否冒泡、捕获等。本文就不再演示了。
总结 本文掌握了普通事件绑定和自定义事件类型绑定，重点是理解自定义事件类型的绑定，该方法给开发者更多自由发挥的空间。selectComponent方法将在下篇博文中记录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f35638e7035aa8a877f5bbb017e96558/" rel="bookmark">
			微信小程序与vue区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序和Vue是两个完全不同的东西，虽然它们都是前端技术，但是有以下几点区别：
技术栈不同： 微信小程序使用WXML、WXSS和JavaScript进行开发，而Vue使用HTML、CSS和JavaScript进行开发。微信小程序是一种基于微信平台的专门的小程序开发技术，而Vue是一种通用的前端开发框架，可以用于创建各种类型的Web应用程序。
目标平台不同： 微信小程序是一种专门为微信平台设计的小程序，可以在微信中直接运行，而Vue可以用于开发各种类型的Web应用程序，可以在各种浏览器中运行。
开发方式不同： 微信小程序开发需要使用微信提供的开发工具和API，遵循微信小程序的开发规范和限制；而Vue开发则可以使用各种开发工具和框架，自由度更高。
生命周期不同： 微信小程序有自己的生命周期，与Vue的生命周期不同，需要特别注意。微信小程序的生命周期包括onLoad、onShow、onReady等；而Vue的生命周期包括beforeCreate、created、mounted等。
组件系统不同： 微信小程序有自己的组件系统，而Vue也有自己的组件系统。微信小程序的组件系统与Vue的组件系统有很多不同之处，需要分别学习和掌握。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a472a8c1e70b876bc3b6d08191a90a98/" rel="bookmark">
			AI电商时代开始：阿里能否反杀拼多多
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“AI电商时代刚刚开始，对谁都是机会，也是挑战。”
针对阿里员工对于拼多多财报和电商等的讨论，马云在阿里内网罕见地参与了谈论并发言。
阿里巴巴一向雷厉风行，已打响了AI电商的“第一炮”。
根据《晚点LatePost》报道，淘天集团刚刚梳理完其AI业务，同时对内发布了淘天自己的大模型产品 “星辰”；国际数字商业集团的AI团队已超过百人。
一、淘天集团：4个AI团队，内部发布大模型“星辰” 淘天集团今年5月经历了架构重组，新管理团队亮相时，“科技驱动”成为新的三大战略之一。
但在当时，电商的业务场景如何与AI能力结合，并没有明确策略。淘天内部对AI的讨论主要是将其作为帮助中小商家提高效率的工具之一，比如当时中小商家负责人汪海曾提到会为商家免费提供包括图片和视频制作、详情页生成等有AIGC能力的工具产品等。
战略指引下，淘天集团多个团队自发在AI业务上探索，淘天一度有约20个团队在做AI相关业务，但这也导致出现了重复造轮子、同质化严重的问题。
AI的重要性在淘天集团正自上而下地贯彻。有员工称，虽然目前尚未列入考核指标，但现在所有的产品和技术人员都会被要求思考业务和AI结合的可行性，有的团队计划下个季度也开始做一些产品尝试。
淘天集团如今已经训练出了自己的大模型产品“星辰”（此前名为“图灵”），但据知情人士称，该大模型产品不会对外发布，对内主要应用于两个业务，一是搜索、广告、推荐，二是逛逛的内容化。
此外，淘天集团还在筹建新的大模型研究团队，计划以技术名义形成一个大团队，与集团内几个应用场景探索的AI业务团队，共用底层显卡、算法工程。
目前，淘天集团在AI上已经有诸多应用。
AI能力在电商场景里的应用并非刚开始，淘宝“千人千面”的算法模型本质就是AI。只不过，基于自然语言的交互，还可以生成图片、视频等内容的大模型AI带来了更大的想象空间。
移动互联网时代的产品从来不是将网页上的东西直接搬到手机上，AI时代会有什么新的产品和应用形态目前还难以想象。
在更远的未来到来之前，竞争可能仍然是阿里电商最为紧迫的事情。
二、阿里国际商业集团：百人AI团队，1/3在训练模型 阿里国际商业集团成立AIBusiness，AI Business团队中，模型训练人员在1/3左右，其他人员负责模型推理应用和基建以及具体产品的开发运营。
算法团队主攻三个方向：多语言的电商大模型训练，对话模型和下游任务，图像生成能力。
AI Business的AI服务已应用在阿里国际内部的AliExpress（速卖通）、Trendyol、Daraz等业务，主要包括商品信息本地化、图像设计、客服机器人、客服翻译等场景。
11月，基于自研的LLM模型，AI Business团队正式对外发布具备翻译、营销、本地化内容、设计等一系列功能的AI产品“Aidge”，除了支持阿里国际各业务，还将接口开放给了独立软件服务商（ISV）和SaaS服务商，以供他们在此基础上开发出更符合商家需求的产品。
在AI Business的“Aidge”产品发布前，阿里国际旗下各业务部门的技术团队已经自主做了一些应用的尝试和探索。
比如今年8月，国际批发业务阿里国际站率先发布一款商家侧的AI应用，包含生意助手和OKKI AI两大服务，帮助商家智能发布和管理商品，更高效地生成图片和视频，还可以提供实时翻译、数据分析等功能。11月，优化后的商品获得的海外询盘量比之前增加了15%。
三、AI电商时代正在开启 正如马云所言，AI电商时代才刚刚开始。
在海外，亚马逊同阿里巴巴一样，同样开启了AI化进程。并且同阿里巴巴在国内面对拼多多和抖音快手一样，亚马逊当前也正面临Temu、SHEIN还有TikTok的威胁。
而在国内，京东也毫不示弱，全线配备了AI智能客服“京小智”，在双十一期间，开售仅10分钟，京东云智能客服累计咨询服务量就超过了188万次。与此同时，其他互联网公司也瞄准了这个领域，腾讯广告利用混元大模型支持了智能化广告制作；百度上线百度优选智能助手“小优”，给消费者当智能导购；小红书也上线了AI智能笔记助手，帮助商家实现商品笔记一键发布。
在整个电商产业链中，AI在每个节点都开始发挥重要作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8ffb4f1a8b5eb22e8a8432cafed5b22/" rel="bookmark">
			【更新】cyのMemo（20231231~）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言 最终，无事发生，我的跨年是在图书馆（因为我忘带卡打不开实验室门），和去年一样。其实我并不想去图书馆，但是觉得在床上跨年太颓废，找个好点的处所，至少说得过去些。人嘛，体面些，不磕碜。
我对2023年基本满意，至少比前两年要好很多，在经历越来越多事情后，对世间事物的运行规律更加清楚，对自己的未来更加明晰。大家都是资深成年人，跨不跨年又有何谓？正如我现在认为的那样，拼死拼活，爬到多高的位置，无非是换了个圈子，总有比你更强的人，如果给我重来的机会，或许本科毕业就找个活干。不如养生。
20231231 吃惊地发现SXY在31日凌晨两点多竟然在淮海中路云海大厦的一间酒吧，灯红酒绿。我不是对酒吧有何偏见，但是至少在我的印象里，SXY不像是那种会去酒吧到深夜的人，我不清楚为什么，但人或许总是会变。之前跟宝玺、剑仙一起吃饭时，宝玺问你们喝酒都是为了什么，剑仙说当然是精神解脱，我不以为然，因为我喝酒都是跟最好的朋友一起吃饭才会喝。或许酒的确是有那些用途的吧。然而，LXY不仅没有感冒，而且生龙活虎地在31日清晨七点，去操场跑23.24km跨年（用时2:00:55，平均配速5’12"/km，汗颜），瞋目结舌。我知道她很猛，但没想到会这么猛。我自己最长也不曾跑过半马以上的距离，更不用说是在场地。而且31号早晨重度污染，好多跑团的活动都临时取消，真是早起的鸟儿有霾吸。我撺掇LXY一起报锡马，她要是能去，我们四五个兄弟绝对不追求成绩，主线任务就是破风带路。旧岁到此结束，无论喜怒哀乐，相信新年将有无限可能。——To you all df.apply的broadcast参数，布尔型的可选参数。当为None或False时，会返回一个与原dataframe的column或index长度相同的Series。 当为True时，会返回一个index和column跟原dataframe相同的dataframe（当然结果进行了广播）。
还有一个很重要的参数raw： 布尔型。默认为False。当为False时，会将dataframe中的每一个column或每一个index上以Series的形式传到函数中（这也是常规的做法，此时逻辑是循环，通常很慢）。当为True时，则会把数据以np.ndarray的形式传到函数中，如果这个时候func用的就是numpy的函数，则执行效率会非常高。
在0.23版本以后，这个参数会被替换成result_type='broadcast'，可选值包括以下几种：expand、reduce、broardcast、None。确定返回形式。（0.23.0以后版本才有并且只有当axis=1时这个参数才能发挥作用）
此外，apply支持位置参数agrs，和关键词参数**kwds 另外，假定X是dataframe的一列，比如每行的数值是一个列表或者np.ndarray，可以使用np.array(X)是无法将它变成一个矩阵的，得用np.stack或者np.vstack才行。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/5/">«</a>
	<span class="pagination__item pagination__item--current">6/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/7/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>