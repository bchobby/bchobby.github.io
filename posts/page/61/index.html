<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/264b00e873c76902fa518f4abcab6333/" rel="bookmark">
			日语中单词后面1，2，3，4，5是什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在很多课本和词典的词条后面都有①、②、⓪等数字（⓪是零外面有圈的表示）,很多人表示不解。再有，在讲解日语声调时，常常刊登一大页难以理解的图，有的读者根本无法看明白。在这里把日语声调尽量讲明白，供各位学习时参考。
任何国家的语言都有声调。中国话的声调（四声）被认为是最难学的，英语、俄语有重音（有的还有次重音）。那么日语的声调特点是什么呢？就是高音。日语单词后面带圈的数字叫“音调核”，告诉读者该词读音由高转低的位置。
首先应该说明，日语单词的发音比较单纯，除了拗音外，每一个假名为一个拍节（注意：这里包括长音、拨音、促音）。在读单词时要一个假名、一个假名地读，不能贪污掉一个，这里同样包括长音、拨音、促音。如：おかあさん是5个音节（拍节），这里有长音和拨音；ちょっと是3个拍节，这里有拗音和促音。必须正确的发音，这样才能准确地记住。因为发音差一点，意思就有可能发生变化，甚至变成完全不同的单词。那么如何把握调门呢？这就要靠音调核了。
日语的发音有2个特征：一是单峰型，没有多次起伏。二是前2个假名音调一定相反：第一个高，第二个就低；相反，第一个低，第二个就高。
明白了这2个特征，加之理解了音调核的含义是：“告诉读者该词读音由高转低的位置”。那么就可以发音读单词了。（由于这里不能用发音示范，只能说明关键问题，其他只好自己领悟了。）
⓪型：单词不论是几个音节（最少是1个音节），从低音入手，第二拍升高，一直到读到最后拍节也不下降。
①型：单词不论是几个音节（最少是1个音节），从高音入手，第二拍下降，一直到读到最后拍节也不上升。
②型：单词不论是几个音节（最少是2个音节），从低音入手，第二拍升高，第三拍下降读到最后拍节也不上升。
③型：单词不论是几个音节（最少是3个音节），从低音入手，第二拍升高，第三拍保持，第四拍下降，读到最后拍节也不上升。
④型：单词不论是几个音节（最少是4个音节），从低音入手，第二拍升高，保持到第四拍，第五拍下降，读到最后拍节也不上升。
⑤型：单词不论是几个音节（最少是5个音节），从低音入手，第二拍升高，保持到第五拍，第六拍下降，读到最后拍节也不上升。
⑥型：单词不论是几个音节（最少是6个音节），从低音入手，第二拍升高，保持到第六拍，第七拍下降，读到最后拍节也不上升。
……顺次类推。
从这里得厂出结论：除“①型从高音入手，第二拍下降，一直到读到最后也不上升”外，其他全是“从低音入手，第二拍升高，一直保持到音调核数字的拍节，然后下降，读到最后拍节也不上升”。也就是说，音调核数字拍节的后面假名，就是读音下降的位置。
在实际学习单词的过程中，会出现如下几个问题：
1，有时一个单词标明2个音调核。这说明该词有2种读法，一般读前面标记，但是也可以读后面的标记。
2，有时一个单词是复合词，由2个单词复合而成。音调核的标记也有2个，中间有“+”号。这样时会出现双峰型。由于一眼就可以看出是复合词，所以双峰也没有关系。
3，音调核的重要性在于正确发音。但是在说话中掺有各种感情，如：惊讶、愤怒、怀疑、焦急等等，声调会发生变化。在正常情况下，能正常的发出读音就可以了。
4，有几个比较有对比性的发音要特别记住：
a， 雨①、饴⓪； 桥②、箸①； 帰る①、変える⓪等假名相同而声调不同、代表的含义不同的单词；
b， 在こそあど系统中，これ、それ、あれ等近、中、远称均是◎、而疑问称どれ是 ①，这不只是物主代词这样，场所代词、方向代词、连体词、副词也相同。
c，大部分疑问词都是①，如：なに、だれ、いくつ等等。
5，在学习中会发现这样的情况：假如是3个拍节的词，有的标记③，有的标记⓪；当然，4个拍节的词，有的标记④，而有的标记⓪；甚至一个3个拍节的词同时标记③⓪；4个拍节的词同时标记④⓪。这是怎么回事呢？
3个拍节的词标记③，表示当后面添加助词时，助词就要下降；如果标记⓪，则表示当后面添加助词时，助词继续读高，不下降；4个拍节的词也是同样。几个拍节的词都相同。如果同时有④⓪之类的标记，则表示2个读法都可以。
以上简单地说明了日语单词的发音要领，但是由于这里没有声音设备，只能对纸空谈。不过，有了这些知识，再看着单词后面的音调核，听听磁带的发音，我想就可以掌握要领了。至于能否记住，就在于你练习的次数了。
重音的位置 1就表示第一个假名重读 3就是第三个假名重读
有一点要注意 2个假名组成的单体 如果是2的话，读平调，第二个假名不重读
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1078cb723223bcc57f6c07298809b219/" rel="bookmark">
			【Chat GPT】用 ChatGPT 运行 Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 ChatGPT 是一个基于 GPT-2 模型的人工智能聊天机器人，它可以进行智能对话，同时还支持 Python 编程语言的运行，可以通过 API 接口进行调用。本文将介绍如何使用 ChatGPT 运行 Python 代码，并提供一个实际代码案例。
ChatGPT 简介 ChatGPT 是一个可以与人进行智能对话的人工智能聊天机器人，它基于 GPT-2 模型开发。GPT-2 是 OpenAI 公司开发的一种基于深度学习的自然语言处理模型，它能够生成高质量的文章、诗歌、故事等，同时还能够进行智能对话。ChatGPT 利用 GPT-2 模型进行自然语言理解和生成，可以与用户进行流畅的对话。
ChatGPT 接口 ChatGPT 提供了 API 接口，可以通过 HTTP 请求向 ChatGPT 发送消息并接收机器人的回复。发送的消息必须使用 JSON 格式，包含以下字段：
{ "message": "你好" } 接收到的机器人的回复也是一个 JSON 字符串，包含以下字段：
{ "message": "你好呀！" } 其中，message 字段表示回复的文本内容。
ChatGPT Python SDK 为了方便使用 ChatGPT，我们还提供了一个 Python SDK。可以通过 pip 安装：
pip install chatgpt 安装完成后，可以通过以下代码进行测试：
from chatgpt import ChatGPT chatbot = ChatGPT() response = chatbot.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1078cb723223bcc57f6c07298809b219/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ca404dccf17c61cb3f80d5ba9334e52/" rel="bookmark">
			后端怎样防止重复提交订单？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后端怎样防止重复提交订单？ 1.加乐观锁 既然悲观锁有性能问题，为了提升接口性能，我们可以使用乐观锁。需要在表中增加一个timestamp或者version字段，这里以version字段为例。
在更新数据之前先查询一下数据：
select id,amount,version from user id=123; 如果数据存在，假设查到的version等于1，再使用id和version字段作为查询条件更新数据：
update user set amount=amount+100,version=version+1 where id=123 and version=1; 更新数据的同时version+1，然后判断本次update操作的影响行数，如果大于0，则说明本次更新成功，如果等于0，则说明本次更新没有让数据变更。
由于第一次请求version等于1是可以成功的，操作成功后version变成2了。这时如果并发的请求过来，再执行相同的sql：
update user set amount=amount+100,version=version+1 where id=123 and version=1; 该update操作不会真正更新数据，最终sql的执行结果影响行数是0，因为version已经变成2了，where中的version=1肯定无法满足条件。但为了保证接口幂等性，接口可以直接返回成功，因为version值已经修改了，那么前面必定已经成功过一次，后面都是重复的请求。
具体流程如下：
具体步骤：
先根据id查询用户信息，包含version字段根据id和version字段值作为where条件的参数，更新用户信息，同时version+1判断操作影响行数，如果影响1行，则说明是一次请求，可以做其他数据操作。如果影响0行，说明是重复请求，则直接返回成功。 2.根据状态判断 很多时候业务表是有状态的，比如订单表中有：1-下单、2-已支付、3-完成、4-撤销等状态。如果这些状态的值是有规律的，按照业务节点正好是从小到大，我们就能通过它来保证接口的幂等性。
假如id=123的订单状态是已支付，现在要变成完成状态。
update `order` set status=3 where id=123 and status=2; 第一次请求时，该订单的状态是已支付，值是2，所以该update语句可以正常更新数据，sql执行结果的影响行数是1，订单状态变成了3。
后面有相同的请求过来，再执行相同的sql时，由于订单状态变成了3，再用status=2作为条件，无法查询出需要更新的数据，所以最终sql执行结果的影响行数是0，即不会真正的更新数据。但为了保证接口幂等性，影响行数是0时，接口也可以直接返回成功。
具体流程图如下：
具体步骤：
用户通过浏览器发起请求，服务端收集数据。根据id和当前状态作为条件，更新成下一个状态判断操作影响行数，如果影响了1行，说明当前操作成功，可以进行其他数据操作。如果影响了0行，说明是重复请求，直接返回成功。 3.加分布式锁 其实前面介绍过的加唯一索引或者加防重表，本质是使用了数据库的分布式锁，也属于分布式锁的一种。但由于数据库分布式锁的性能不太好，我们可以改用：redis或zookeeper。
鉴于现在很多公司分布式配置中心改用apollo或nacos，已经很少用zookeeper了，我们以redis为例介绍分布式锁。
目前主要有三种方式实现redis的分布式锁：
setNx命令set命令Redission框架 每种方案各有利弊，具体实现细节我就不说了，有兴趣的朋友可以加我微信找我私聊。
具体流程图如下：
具体步骤：
用户通过浏览器发起请求，服务端会收集数据，并且生成订单号code作为唯一业务字段。使用redis的set命令，将该订单code设置到redis中，同时设置超时时间。判断是否设置成功，如果设置成功，说明是第一次请求，则进行数据操作。如果设置失败，说明是重复请求，则直接返回成功。 需要特别注意的是：分布式锁一定要设置一个合理的过期时间，如果设置过短，无法有效的防止重复请求。如果设置过长，可能会浪费redis的存储空间，需要根据实际业务情况而定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05e53caf021ee4efb9dc4fd270ed50e4/" rel="bookmark">
			一次讲全！Java常见的23种设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		、什么是设计模式： 设计模式是一套经过反复使用的代码设计经验，目的是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 设计模式于己于人于系统都是多赢的，它使得代码编写真正工程化，它是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。
二、Java的23种设计模式： 接下来我们详细介绍Java中23种设计模式的概念，应用场景等情况，并结合他们的特点及设计模式的原则进行分析！
1、创建型-工厂方法模式： 工厂方法模式分为三种：
（1）简单工厂模式：
建立一个工厂类，并定义一个接口对实现了同一接口的产品类进行创建。首先看下关系图：
（2）工厂方法模式：
工厂方法模式是对简单工厂模式的改进，简单工厂的缺陷在于不符合“开闭原则”，每次添加新产品类就需要修改工厂类，不利于系统的扩展维护。而工厂方法将工厂抽象化，并定义一个创建对象的接口。
每增加新产品，只需增加该产品以及对应的具体实现工厂类，由具体工厂类决定要实例化的产品是哪个，将对象的创建与实例化延迟到子类，这样工厂的设计就符合“开闭原则”了，扩展时不必去修改原来的代码。
（3）静态工厂方法模式：
静态工厂模式是将工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。
2、创建型-抽象工厂模式： 抽象工厂模式主要用于创建相关对象的家族。当一个产品族中需要被设计在一起工作时，通过抽象工厂模式，能够保证客户端始终只使用同一个产品族中的对象；并且通过隔离具体类的生成，使得客户端不需要明确指定具体生成类；所有的具体工厂都实现了抽象工厂中定义的公共接口，因此只需要改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。
但该模式的缺点在于添加新的行为时比较麻烦，如果需要添加一个新产品族对象时，需要更改接口及其下所有子类，这必然会带来很大的麻烦。
UML结构图如下：
3、创建型-建造者模式： 建造者模式将复杂产品的创建步骤分解在在不同的方法中，使得创建过程更加清晰，从而更精确控制复杂对象的产生过程；通过隔离复杂对象的构建与使用，也就是将产品的创建与产品本身分离开来，使得同样的构建过程可以创建不同的对象；
并且每个具体建造者都相互独立，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。
4、创建型-单例模式： 单例模式可以确保系统中某个类只有一个实例，该类自行实例化并向整个系统提供这个实例的公共访问点，除了该公共访问点，不能通过其他途径访问该实例。
单例模式的优点在于：系统中只存在一个共用的实例对象，无需频繁创建和销毁对象，节约了系统资源，提高系统的性能；可以严格控制客户怎么样以及何时访问单例对象。
5、创建型-原型模式： 原型模式也是用于对象的创建，通过将一个对象作为原型，对其进行复制克隆，产生一个与源对象类似的新对象。
UML类图如下：
在 Java 中，原型模式的核心是就是原型类 Prototype，Prototype 类需要具备以下两个条件：实现 Cloneable 接口；重写 Object 类中的 clone() 方法，用于返回对象的拷贝。
Object 类中的 clone() 方法默认是浅拷贝，如果想要深拷贝对象，则需要在 clone() 方法中自定义自己的复制逻辑：
浅复制：将一个对象复制后，基本数据类型的变量会重新创建，而引用类型指向的还是原对象所指向的内存地址。
深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。
上面我们介绍了5种创建型模式，下面我们就开始介绍下7种结构型模式：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
6、结构型-适配器模式： 适配器模式主要用于将一个类或者接口转化成客户端希望的格式，使得原本不兼容的类可以在一起工作，将目标类和适配者类解耦；同时也符合“开闭原则”，可以在不修改原代码的基础上增加新的适配器类；将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性，但是缺点在于更换适配器的实现过程比较复杂。
所以，适配器模式比较适合以下场景：
（1）系统需要使用现有的类，而这些类的接口不符合系统的接口。
（2）使用第三方组件，组件接口定义和自己定义的不同，不希望修改自己的接口，但是要使用第三方组件接口的功能。
7、结构型-装饰器模式： 装饰器模式可以动态给对象添加一些额外的职责从而实现功能的拓展，在运行时选择不同的装饰器，从而实现不同的行为；比使用继承更加灵活，通过对不同的装饰类进行排列组合，创造出很多不同行为，得到功能更为强大的对象；符合“开闭原则”，被装饰类与装饰类独立变化，用户可以根据需要增加新的装饰类和被装饰类，在使用时再对其进行组合，原有代码无须改变。
但是装饰器模式也存在缺点，首先会产生很多的小对象，增加了系统的复杂性，第二是排错比较困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。
8、结构型-代理模式： 代理模式的设计动机是通过代理对象来访问真实对象，通过建立一个对象代理类，由代理对象控制原对象的引用，从而实现对真实对象的操作。
在代理模式中，代理对象主要起到一个中介的作用，用于协调与连接调用者(即客户端)和被调用者(即目标对象)，在一定程度上降低了系统的耦合度，同时也保护了目标对象。但缺点是在调用者与被调用者之间增加了代理对象，可能会造成请求的处理速度变慢。
9、结构型-桥接模式： 桥接模式将系统的抽象部分与实现部分分离解耦，使他们可以独立的变化。为了达到让抽象部分和实现部分独立变化的目的，桥接模式使用组合关系来代替继承关系，抽象部分拥有实现部分的接口对象，从而能够通过这个接口对象来调用具体实现部分的功能。
也就是说，桥接模式中的桥接是一个单方向的关系，只能够抽象部分去使用实现部分的对象，而不能反过来。
桥接模式符合“开闭原则”，提高了系统的可拓展性，在两个变化维度中任意扩展一个维度，都不需要修改原来的系统；并且实现细节对客户不透明，可以隐藏实现细节。但是由于聚合关系建立在抽象层，要求开发者针对抽象进行编程，这增加系统的理解和设计难度。
就像在Java中我们使用 JDBC 连接数据库时，在各个数据库之间进行切换，基本不需要动太多的代码，原因就是使用了桥接模式，JDBC 提供统一接口，每个数据库提供各自的实现，然后由桥接类创建一个连接数据库的驱动，使用某一个数据库的时候只需要切换一下就行。
10、结构型-外观模式： 外观模式通过对客户端提供一个统一的接口，用于访问子系统中的一群接口。使用外观模式有以下几点好处：
（1）更加易用：使得子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟外观类交互就可以了；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05e53caf021ee4efb9dc4fd270ed50e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20684ca6ea0f4eb9e8d88cc51bc2a5b0/" rel="bookmark">
			删除原安装jupyter，在anaconda中重新安装jupyter，修改jupyter默认启动位置，在anaconda中jupyter配置tensorflow模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		删除 原安装的jupyter并不是基于anaconda环境进行安装的，完全删除jupyter pip uninstall jupyter pip uninstall jupyter_core pip uninstall jupyter-client pip uninstall jupyter-console pip uninstall notebook pip uninstall qtconsole pip uninstall nbconvert pip uninstall nbformat 上述内容删除之后，查询文件夹会发现，该路径下C:\Users(你的用户名) 还存在着.jupyter文件夹，里面包含着对jupyter初始启动页面的路径配置，这个可以删除，也可以放任不管（建议删除） 安装 然后重新安装 jupyter打开anaconda prompt pip install jupyter 对于缺少的内容，一律按如下处理 pip install 缺少的内容 # 例如 pip install jupyter_core 修改 安装完后如果需要修改jupyter启动页面可以到C:\Users(你的用户名) 该路径下.jupyter文件夹中，打开jupyter_notebook_config.py，查找c.NotebookApp.notebook_dir = ，修改为你希望的默认启动位置，例如我的 c.NotebookApp.notebook_dir = 'E:\jupyter' tensorflow 安装 # 打开anaconda prompt # 查询python版本 python --version # 创建tensorflow虚拟环境 conda create -n tensorflow_env python=3.9.1 # 启动虚拟环境 activate tensorflow_env # 安装tensorflow pip install tensorflow # 如果出现error提示，则按照提示进行pip相应的文件，然后再安装一次tensorflow确保没有缺少 # 将 tensorflow 嵌入到 jupyter conda install ipython conda install jupyter # 安装ipykernel conda install ipykernel # 绑定内核 # tensorflow_env 为虚拟环境名称 # python(tensorflow) 为显示名称 python -m ipykernel install --user --name tensorflow_env --display-name "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20684ca6ea0f4eb9e8d88cc51bc2a5b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6173a6fbb8f124107b6d2abfc3beb12d/" rel="bookmark">
			小程序 wxchart 使用简单入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方参考： Example - wxCharts使用说明 · Issue #58 · xiaolin3303/wx-charts · GitHub
引入 地址：GitHub - xiaolin3303/wx-charts: 微信小程序图表charts组件，Charts for WeChat Mini Program
把clone下来的文件里dist下面的wxcharts.js或者wxcharts-min.js放到自己文件目录中
常用参数说明 参数说明
opts Object
opts.canvasId String Required 对应wxml中的canvasId
opts.type String Required 图表类型，可选值为：pie、line、column、area、ring、radar
opts.width Number Required canvas宽度，单位px
opts.height Number Required canvas高度，单位px
opts.legend Boolean 是否显示图表下方各类别的标识，默认true
opts.background String canvas背景颜色 ，默认#fff
opts.animation Boolean 是否动画展示，默认true
opts.enableScroll Boolean 是否开启图表可拖拽滚动，默认false，支持 line、area 图表类型（需配合绑定scrollStart, scroll, scrollEnd 方法）
opts.categories Array Required 数据类别分类 (pie、ring 图表不需要)
opts.dataLabel Boolean 是否在图表中显示数据内容值，默认true
opts.dataPointShare Boolean 是否在图表中显示数据点图形标识，默认true
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6173a6fbb8f124107b6d2abfc3beb12d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/367c13eb86a6482871f6dc3f1ce918a3/" rel="bookmark">
			异步编程简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异步编程简介 异步编程是一种编程模式，旨在提高程序的性能和响应速度。通过将某些任务异步执行，程序可以在等待结果时继续执行其他任务，从而减少了阻塞和等待的时间。在本篇博客中，我们将详细探讨异步编程的各个方面，并介绍常见的异步编程技术和工具。
什么是异步编程？ 传统的同步编程方式中，代码会按照顺序依次执行，直到前一个任务完成后才能执行下一个任务。这种方式在执行耗时较长的任务时，会导致程序的阻塞和响应缓慢。而异步编程通过将任务分解为更小的子任务，并且不需要等待前一个任务完成，从而实现并行执行多个任务的效果。
异步编程的核心思想是任务的提交和处理是分离的，任务提交后立即返回，由其他部分负责处理该任务的执行和结果。这种方式可以充分利用系统资源，提高程序的效率和吞吐量。
为什么使用异步编程？ 使用异步编程的好处包括：
提高程序的响应速度：异步编程可以减少等待时间，从而提高程序的响应速度，使用户获得更好的体验。
充分利用系统资源：异步编程可以并行执行多个任务，充分利用系统的处理能力，提高程序的效率。
改善用户界面的体验：在图形用户界面（GUI）应用程序中，异步编程可以防止用户界面的卡顿和无响应，增强用户的交互体验。
处理大量并发请求：异步编程对于处理大量并发请求非常有用，例如网络服务器应用程序中的请求处理。
常见的异步编程技术和工具 以下是一些常见的异步编程技术和工具：
1. 异步函数和回调 异步函数和回调是最常见的异步编程方式之一。在异步函数中，任务被封装为一个函数，并通过回调函数来处理任务的结果。当任务完成时，回调函数会被调用，从而继续执行后续的操作。
async function foo(callback) { // 异步任务的实现 // ... callback(result); } foo(function(result) { // 处理任务的结果 }); 2. Promise Promise 是一种用于处理异步操作的对象。它表示一个初始处于 pending（等待）状态的任务，并且可以在任务完成后变为 resolved（已完成）或 rejected（已拒绝）状态。Promise 提供了链式调用的机制，从而简化了异步代码的编写和管理。
const promise = new Promise((resolve, reject) =&gt; { // 异步任务的实现 // ... if (任务成功) { resolve(result); } else { reject(error); } }); promise.then(result =&gt; { // 处理任务的结果 }).catch(error =&gt; { // 处理任务的错误 }); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/367c13eb86a6482871f6dc3f1ce918a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a5c6867c14e7961781f8e817faf255f/" rel="bookmark">
			虚拟机中的win10连不上网怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装VMware 16和在其中安装win10系统参考这篇，很有详细且有用。
这篇主要记录我安装后发现虚拟机中win10连不上网了，查了好多，终于有一个方法弄好了。
1.打开主机的网络连接
双击所连接的网络的属性——&gt;共享 ，将小勾勾全部勾上点击确定，如果提示出现意外情况巴拉巴拉的，没事点确定就行了。
2.打开虚拟机 ，将要用的虚拟机的网络配置器改为NAT模式，开机就应该连上了
这样应该没问题了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17a47d4c1d4a744f2cd17320acbc1a72/" rel="bookmark">
			Win10部署Apache和PHP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win10部署Apache和PHP
一：部署理由
不少初学者同学在学习之初由于Apache、PHP和MySQL的安装和配置较为复杂，因此都是使用WAMP（Windows + Apache + MySQL + PHP）的集成环境（如PHPstydy、WampServer、AppServ等），这样就可以免去单独安装配置服务器的麻烦。但集成环境中使用的PHP都是非线程安全的版本（Not Thread Safe NTS），部分功能是不能使用的。
二：部署过程
（1）：Apache的下载和安装、卸载
第一步:登录Apache官网下载安装包。 下载地址1：Apache VS17 binaries and modules download
下载地址2：Apache Haus Downloads
第二步：将下载的Apache压缩包进行解压，再将文件放置于本地（如：E:\WAMP\Apache24）
第三步：配置Apache文件
打开Apache文件，找到conf文件并打开，打开httpd.conf文件，找到并修改 Define SRVROOT “E:\WAMP\Apache24”(既Apache文件所在路径) 使用Vscode将httpd.conf文件打开，找到73行左右，添加红框内代码。（路径修改为PHP所在的路径）【注意：此处最好将php8_module修改为php_module，避免发生后文提到的错误】 （3）：在httpd.conf文件中找到AddType,添加：AddType application/x-httpd-php .php .html .htm
（4）：为了避免和其他HTTP服务器占用的80端口冲突，可自定义修改端口号。
（5）：以管理员身份运行cmd命令窗口，进入Apache安装目录下的bin文件夹（若将apache文件添加至系统环境变量，则不需要在bin目录下运行命令），输入命令 httpd -k install进行安装apache服务器。
第四步：启动Apache
方式1：打开Apache文件，找到bin目录下的ApacheMonitor.exe文件，点击start。
方式2：在cmd窗口输入httpd -k start
第五步：测试是否安装成功。打开浏览器输入 http://localhost:设置的端口号（如：http://localhost:8081），出现下图内容则表示成功安装。
Apache的卸载：
若不再需要使用Apache，要将其卸载，必须先暂停Apache的服务，若直接从路径中删除Apache文件，容易造成文件残留。
第一步：停止Apache服务 命令：net stop Apache2.4 或 httpd -k stop 或 右击“此电脑”——&gt;选择“管理”——&gt;“服务和应用程序”——&gt;“服务”，找到Apache服务关停。
第二步：卸载Apache 命令：sc delete apache2.4 或 httpd -k uninstall -n apache2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17a47d4c1d4a744f2cd17320acbc1a72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f0544fed2c5fac8aa6391a214ad7db0/" rel="bookmark">
			element-ui 分页pagination组件 动态设置默认页码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;el-pagination hide-on-single-page @current-change="Current" :page-size="pageSize" :pager-count="11" ref="pagination" layout="prev, pager, next" :total="data.total" :current-page="pageIndex" &gt;&lt;/el-pagination&gt; 直接上代码
this.$nextTick(() =&gt; {//注意要用this.$nextTick，否则不生效 this.$refs.pagination.internalCurrentPage = this.pageIndex; }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c120362d9ec36bc9025f47fc9d0297bb/" rel="bookmark">
			软件设计师中级王勇老师课程笔记-10数据流图DFD&#43;数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据软考-软件设计师中级考试王勇老师课程做的手写笔记，包含12个章节，计算机组成与体系结构、操作系统、数据库系统、计算机网络、数据结构与算法基础、程序设计语言与语言处理基础、法律法规、软件工程、面向对象、数据库和数据流图、UML、数据结构与算法应用、面向对象程序设计等内容，个人认为本笔记可以用来过一遍基础知识，王勇老师讲的一些技巧还是比较实用的，有问题欢迎指正！
欢迎大家下载呀！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3baf2b5ffdc5fa4c87524828e6ab7c11/" rel="bookmark">
			[Python]前端11_Web框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Web框架 Python的主流Web框架是： 1.Django： Django是一个高级的、全功能的 Web 框架，被广泛用于构建复杂而强大的 Web 应用程序。 它提供了许多内置的功能和工具，如管理员界面、身份验证、数据库ORM等，使开发者能够快速构建稳定、可扩展的应用程序。 2.Flask： Flask 是一个简约而灵活的微型Web框架，专注于构建小型或中型的 Web 应用程序和 API。 相比于 Django，Flask更加轻量级，并允许开发者根据需要选择所需的插件和库，以便在项目中进行定制。 3.Pyramid： Pyramid 是一个通用的 Web 框架，可以满足从小型到大型应用程序的需求。 它提供了一种灵活且可扩展的方式来构建 Web 应用程序，并支持各种功能，如URL路由、会话管理、表单处理等。 Pyramid提倡对应用程序结构的自由控制，并鼓励使用现有的Python工具和库来实现功能。 4.Tornado： Tornado 并没有被完全淘汰出三大主流框架之一。 尽管 Django、Flask 和 Pyramid 是 Python 生态系统中最受欢迎的 Web 框架，但 Tornado 仍然有其独特的优势和用途。 Tornado 是一个高性能的异步Web框架，它以支持并发处理和非阻塞IO操作为目标。 它经常用于构建高度可扩展且具有实时响应需求的应用程序，例如聊天应用、实时消息传递系统和实时分析工具等。 由于其出色的性能和强大的异步功能，Tornado 在特定场景下仍然被广泛使用。 虽然 Django、Flask 和 Pyramid 更加通用、适用于各种类型的 Web 应用程序， 但 Tornado 的专长在于处理大量并发连接和实时性要求较高的应用。 总结： 1.django 特点：大而全，自带的功能特别多，即：庞然大物 不足：有时候显得笨重 2.flask 特点：短小精悍，自带的功能非常少， 但是它第三方的模块特别多，如果将flask第三方模块全部加起来完全盖过django 不足：比较依赖第三方的开发者，而且兼容性问题不容小觑 3.tornado 特点：异步非阻塞，支持高并发（甚至可以开发游戏服务器） 不足：自行了解... 因此，根据项目需求和技术要求，开发者可以根据情况选择合适的框架，并在需要时考虑使用 Tornado 来满足特殊的需求。 这些框架都具有优秀的生态系统和活跃的开发社区，且得到了广泛的应用和支持。选择哪个框架取决于项目需求、开发团队的喜好以及个人技能水平。 补充： 我们从手动搭建web框架中可知，框架主要是下面部分组成 A部分:socket部分 B部分:路由与视图函数对应关系（路由匹配） C部分:模板语法 django A部分用的是别人的（wsgiref模块） B部分用的是自己的 C部分用的是自己的（没有jinja2模块好用，但是也很方便） flask A部分用的是别人的（werkzeug,而werkzeug内部还是wsgiref模块） B部分用的是自己的 C部分用的是别人的（jinja2模块） tornado A、B、C部分都是自己写的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb12eaff1e0ecca178fd5eee23658e58/" rel="bookmark">
			[Python]前端10_手动搭建Web框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最简单的数据交互 import socket server = socket.socket() # 默认TCP协议 server.bind(('127.0.0.1', 8080)) server.listen(5) while True: conn, addr = server.accept() data = conn.recv(1024) print(data) conn.send(b'HTTP/1.1\r\n\r\nHello Web!') # HTTP协议 conn.close() # 运行程序，并在网页上输入：127.0.0.1:8080 即可获取服务端发来的数据——Hello Web! 服务端发送HTML import socket server = socket.socket() server.bind(('127.0.0.1', 8080)) server.listen(5) while True: conn, addr = server.accept() data = conn.recv(1024) data = data.decode('utf-8') # 二进制数据转为字符串 conn.send(b'HTTP/1.1\r\n\r\n') # TCP协议特性，可以粘包 current_path = data.split(' ')[1] if current_path == '/apple': conn.send(b'Apple is here!') elif current_path == '/banana': conn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb12eaff1e0ecca178fd5eee23658e58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7f22030a961f7455afbd46732d3c968/" rel="bookmark">
			mysql分页为什么越来越慢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL性能优化-分页查询越来越慢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90d3bccaf08186fb3fc29487d80ad13b/" rel="bookmark">
			Python基础知识-2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		名片管理系统 def addHandler(): print("添加名片") def deleteHandler(): IsDelete = input("(づ￣3￣)づ╭❤～亲~您确定要删除名片吗？Yes/No").upper() if (IsDelete == 'YES'): print("删除名片") else: print("删除失败") def editHandler(): print("修改名片") def queryHandler(): print("查询名片") def showHandler(): print("展示名片") def start(): operate = int(input("请输入要操作的数字")) while True: print("------------------------------\n名片管理系统v1.0\n1:添加名片\n2:删除名片\n3:修改名片\n4:查询名片\n5.显示名片") if (operate == 1): addHandler() break elif (operate == 2): deleteHandler() break elif (operate == 3): editHandler() break elif (operate == 4): queryHandler() break else: showHandler() break start() Socket UDP发送协议 import socket # 1.创建socketd,并连接 # AF_INET:表示这个socket是用来进行网络连接 # SOCK_DGRAM:表示连接是一个UDP连接 socketDemo = socket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90d3bccaf08186fb3fc29487d80ad13b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24e13507db4b17bb9fd7363571cafeb1/" rel="bookmark">
			mobaXterm配置windows环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当使用mobaXterm打开一个本地的shell窗口的时候，执行一些已经在windows机器上配置好的命令时，提示找不到命令或者报错
针对这种场景，需要在settings的Terminal标签页下打开use windows path选项。之后重新开一个shell页面就可以正常使用已在windows环境中配置好的命令了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a283f37f1cba92351392ed80d208f0ce/" rel="bookmark">
			easyexcel 将对应列的格式改为数字或者文本格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在easyexcel 导出excel时 需要将某个列的格式指定，例如指定为数字格式
例如 需要把单元格格式设置为数值，并且保留小数点后三位，按道理来说应该是这样子设置
/** * test， 最终导出值 */ @ExcelProperty(value = "test") @ColumnWidth(value = 10) @NumberFormat("0.000") private double test; 这时候导出会发现这是个自定义类型的单元格
这时候就需要这样子设置了, 在小数后面加下横杠和空格（不加空格的话是不生效的，还是默认的常规）
/** * test， 最终导出值 */ @ExcelProperty(value = "test") @ColumnWidth(value = 10) //加下横线并且加多个空格 @NumberFormat("0.000_ ") private double test; 同理，保留几位小数就在后面加0，不保留小数直接去掉小数点和后面的0
参考 大神博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00657968dd47afda509db713222bba5f/" rel="bookmark">
			Spring Security安全配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Spring Boot与Spring MVC进行Web开发时，如果项目引入spring-boot- starter-security依赖启动器，MVC Security 安全管理功能就会自动生效，其默认的安全配置是在SecurityAutoConfiguration和UserDetailsServiceAutoConfiguration中实现的。其中，SecurityAutoConfiguration会导入并自动化配置SpringBootWebSecurityConfiguration用于启动Web安全管理，UserDetailsServiceAutoConfiguration则用于配置用户身份信息。
通过自定义WebSecurityConfigurerAdapter 类型的Bean组件，可以完全关闭Security 提供的Web应用默认安全配置，但是不会关闭UserDetailsService用户信息自动配置类。如果要关闭UserDetailsService默认用户信息配置，可以自定义UserDetailsService、AuthenticationProvider或AuthenticationManager类型的Bean组件。另外，可以通过自定义WebSecurityConfigurerAdapter类型的Bean组件覆盖默认访问规则。Spring Boot 提供了非常多方便的方法，可用于覆盖请求映射和静态资源的访问规则。
下面我们通过Spring Security API查看WebSecurityConfigurerAdapter的主要方法，具体所示：
configure(AuthenticationManagerBuilder auth)：定制用户认证管理器来实现用户认证
configure(HttpSecurity http)：定制基于HTTP请求的用户访问控制
从上面可以看到，WebSecurityConfigurerAdapter类中包含两个非常重要的配置方法，分别是configure(AuthenticationManagerBuilder auth)和configure(HttpSecurity http)。Configure(AuthenticationManagerBuilder auth)方法用于构建认证管理器，configure(HttpSecurity http)方法用于对基于HTTP的请求进行请求访问控制。
一、自定义用户认证：
通过自定义WebSecurityConfigurerAdapter类型的Bean组件，并重写configure(AuthenticationManagerBuilder auth)方法，可以自定义用户认证。针对自定义用户认证，Spring Security提供了多种自定义认证方式， 包括有: In-Memory Authentication (内存 身份认证)、JDBCAuthentication ( JDBC身份认证)、LDAP Authentication ( LDAP身份认证)、AuthenticationProvider (身份认证提供商)和UserDetailsService (身份详情服务)。 下面我们选取其中3个比较有代表性的方式讲解如何实现自定义用户认证。
二、自定义用户授权管理：
当一个系统建立之后，通常需要适当地做一些权限控制，使得不同用户具有不同的权限操作系统。例如，一般的项目中都会做一些简单的登录控制，只有特定用户才能登录访问。接下来我们针对Web应用中常见的自定义用户授权管理进行介绍。
自定义用户访问控制：
实际生产中，网站访问多是基于HTTP请求的，上面MVC Security 安全配置介绍时，我们已经分析出通过重写WebSecurityConfigurerAdapter类的configure(HttpSecurity http)方法可以对基于HTTP的请求访问进行控制。下面我们通过对configure(HttpSecurity http)方法剖析，分析自定义用户访问控制的实现过程。
configure(HttpSecurity http)方法的参数类型是HttpSecurity类，HttpSecurity类提供了Http请求的限制以及权限、Session 管理配置、CSRF跨站请求问题等方法，具体如下所示。
HttpSecurity 类的主要方法及说明：
authorizeRequests()：开启基于HtpSereleRequest请求访问的限制
formLogin()：开启基于表单的用户登录
httpBasic()：开启基于HTTP请求的Basic认证登录
logout()：开启退出登录的支持
sessionManagement()：开启Session管理配置
rememberMe()：开启记住我功能
csrf()：配置CSRF跨站请求伪造防护功能
此处重点讲解用户访问控制，这里先对authorizeRequests()方法的返回值做进一步查看，其中涉及用户访问控制的主要方法及说明如下所示。
antMatchers(java.lang.String .. antPatterns)：开启Ant风格的路径匹配
mvcMatchers(java.lang. String ... patterns)：开启MVC风格的路径匹配(与Ant风格类似)
regexMatchers(java.lang String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00657968dd47afda509db713222bba5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/873618bea60c2d511ab4661007e5b6bf/" rel="bookmark">
			maven安装中[WARNING] Plugin validation issues were detected in plugin(s)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开一个新的maven项目，在Maven的生命周期中选择install,
虽然安装成功了但是出现警告：Plugin validation issues were detected in 7 plugin(s)
Plugin validation issues were detected in 7 plugin(s) 类似于：
[WARNING] Plugin validation issues were detected in 7 plugin(s) [WARNING] [WARNING] * org.apache.maven.plugins:maven-resources-plugin:3.2.0 [WARNING] * org.apache.maven.plugins:maven-jar-plugin:3.2.2 [WARNING] * org.jacoco:jacoco-maven-plugin:0.8.8 [WARNING] * org.apache.maven.plugins:maven-compiler-plugin:3.10.1 [WARNING] * org.codehaus.mojo:build-helper-maven-plugin:3.3.0 [WARNING] * org.apache.maven.plugins:maven-surefire-plugin:2.22.2 [WARNING] * com.mysema.maven:apt-maven-plugin:1.1.3 [WARNING] [WARNING] For more or less details, use 'maven.plugin.validation' property with one of the values (case insensitive): [BRIEF, DEFAULT, VERBOSE] 网上查了好多，分析原因是这些列出来的依赖有可能会出现不生效的警告，具体的解决办法，一直没查到，于是我分析是不是Maven版本的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/873618bea60c2d511ab4661007e5b6bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ede93a26217593f7bd04ac4e2a075933/" rel="bookmark">
			云服务器远程nacos服务注册失败/不健康Client not connected, current status:STARTING
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Nacos报错docker安装不用 docker安装 Nacos报错 docker安装 使用docker在云服务器安装Nacos之后出现Client not connected, current status:STARTING
使用docker 安装之后需要添加映射端口
docker run -e JAVA_OPTS="-Xms256m -Xmx256m" -e MODE=standalone -e PREFER_HOST_MODE=hostname -p 8848:8848 -p 9848:9848 -p 9849:9849 --privileged=true -v /docker/nacos/conf:/home/nacos/conf -v /docker/nacos/logs:/home/nacos/logs --restart=always --name nacos -d nacos/nacos-server:2.0.2 使用docker 安装的nacos中需要添加3个端口为最优。
当nacos-client的版本小于服务器端的版本就只需要添加一个端口.
当nacos服务端升级至2.0以上后，多了grpc通信；
由于使用的是docker安装的nacos，只映射8848端口支撑不了grpc通信，可以降低客户端版本(使用1.x.x的nacos client)，或者添加上述两个端口9848和9849.
不用 docker安装 这个错误提示表明远程Nacos服务注册失败，原因可能是客户端未能成功连接Nacos服务器。当前状态为"STARTING"，表示正在启动中。
要解决这个问题，可以尝试以下几个步骤：
1、确保Nacos服务器正常运行：检查Nacos服务器是否已经正确启动，并且网络连接正常。
2、检查客户端配置：确保客户端的配置文件中，Nacos服务器的地址、端口号等信息正确配置。可以尝试重新设置这些配置项。
3、检查网络连接：确认客户端服务器与Nacos服务器之间的网络连接正常，可以尝试使用ping命令或telnet命令检查网络连接是否畅通。
4、检查防火墙设置：如果使用了防火墙，确保已经正确配置，允许客户端与Nacos服务器进行通信。
5、检查Nacos服务器日志：查看Nacos服务器的日志文件，检查是否有其他错误或异常信息，以便更好地定位问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/330153cfd81499af15043aac8c0745f5/" rel="bookmark">
			Git的快速入门（快速简单但超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.使用git代码进行提交远程仓库
2.IDEA集成使用远程仓库
Git的作用：版本控制
我们每一次提交一份（在原始代码的基础上）代码，称为一个版本。当我们想要回到某天所写的代码进行更新时，我们可以直接回到那个时候，那天的代码一行都不会多也不会少。正如你为女孩花不少心思，女孩的心却没有你的一丝痕迹，你在那天提交的版本，之后再重拾，它依旧和原来一样一丝不变。
OK！直接上操作，不说其他的废话，不讲原理，只讲最直接操作
1.使用git代码进行提交远程仓库 远程仓库咱们国内使用gitee，国外的使用GitHub，由于国内访问GitHub速度较慢，我们在此使用gitee演示，GitHub操作大差不差。
如果有小伙伴想要访问GitHub，可以私信我要VPN,使用VPN访问github速度就快的多了。
1.1先进入想要上传到远程仓库的本地文件夹中（根目录下），进入git 1.2输入git init ，创建本地仓库
git init 回车后文件夹下出现这个文件（是个隐藏文件，看不到的设置一下隐藏文件可见）
1.3输入git add . 添加所有文件至提交区域
git add . 输入git status
git status 可以看到很多绿色的文件，这就是文件添加至提交区了
1.4输入 git commit -m "拼图游戏初始化代码" （""引号内的是提交代码的版本Meseage）
git commit -m "拼图游戏初始化代码" 出现很多白色文件说明提交成功到本地了
1.5添加远程仓库（先要创建远程仓库，这一步详解看2.8）
创建后复制仓库url
执行命令 不可以按ctrl+v，右键点击paste进行粘贴
git remote add origin "url" 添加远程仓库 1.6推送至远程仓库
输入命令
git push -u origin master 看到这样就成功推送啦！！
去gitee查看，已经成功推送至gitee了，成功！ 2.IDEA集成使用远程仓库 2.1在IDEA中点击这个版本控制按钮 2.2创建本地仓库
2.3直接选中根目录，OK
2.4点击OK后，页面变成这样，框住的地方就是快捷键，先点击✔（执行的是commit代码到本地）
2.5commit后Unversioned files打勾，在下面的commit Message中写版本信息，然后点击commit，如果有提示，继续点击commit即可
2.6找到push后点击
2.7这里要填的是我们远程仓库的url
2.8在gitee创建远程仓库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/330153cfd81499af15043aac8c0745f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0332a741e01e1622bc605f85ba7b9fcb/" rel="bookmark">
			Fiddler Everywhere(TTP调试抓包工具) for Mac苹果电脑版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Fiddler Everywhere for Mac版是Mac电脑上的一款跨平台的HTTP调试抓包工具，Fiddler Everywhere for Mac能够记录客户端与服务器之间的所有HTTP（S）通信，支持对包进行监视、分析、设置断点、甚至修改请求/响应数据等操作。
适用于任何浏览器、任何应用程序、任何进程的网络调试代理。感兴趣的朋友快来下载使用吧。
软件特色 Fiddler Mac版的可扩展性强，可以使用任何.net语言开发的强大扩展，并且可以共享抓取的HTTP包流量来与团队进行协作。
友善的用户界面，直观且简单的使用方法，提供Windows、MacOS、Linux等多个平台的客户端，跨平台无缝协作。记录客户端与服务器之间的所有HTTP（S）通信，支持对包进行监视、分析、设置断点、甚至修改请求/响应数据等操作
强大的可扩展性，能够使用任何.net语言开发的扩展。良好的团队协作性，可以共享抓取的HTTP包流量来与团队成员之间进行协作
Fiddler Everywhere Mac版安装教程
Fiddler Everywhere Mac下载完成后，双击.pkg文件根据安装器提示进行安装即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f1020895f3bf389e632b10d3ed64001/" rel="bookmark">
			MongoDB 详解，超全！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB 详解，超全！！！ 引言 MongoDB是一种非关系型数据库管理系统，被广泛应用于现代应用程序的数据存储和处理。它具有灵活的数据模型、强大的查询语言和高性能的数据读写能力。本篇博客将详细介绍MongoDB的各个方面，包括基本概念、数据模型、查询语言、索引优化、数据复制与故障恢复等内容。让我们深入了解MongoDB，并掌握如何使用MongoDB构建可靠、高效的应用程序。
目录 概述 什么是MongoDBMongoDB的特点和优势 安装与配置 下载和安装MongoDB配置MongoDB服务器 数据模型 文档导向的数据模型集合和数据库索引嵌入式文档和引用 查询语言 CRUD操作查询和筛选排序和限制聚合管道 索引优化 索引的作用和原理索引的创建和管理索引的选择和优化 数据复制与故障恢复 复制集的概念和配置主从复制和故障转移数据恢复和备份 性能调优 查询性能优化索引性能优化数据模型设计与性能 安全性 访问控制与认证数据加密与传输安全安全审计与日志 最佳实践和案例分析 MongoDB在实际项目中的应用最佳实践和经验总结 结语 第一章 概述 什么是MongoDB MongoDB是一个开源的文档型数据库管理系统，采用BSON（Binary JSON）格式存储数据。它使用灵活的文档模型代替传统的表格模型，可以方便地存储和查询半结构化的数据。MongoDB的设计目标是轻松扩展和高性能，适用于需要处理大量数据和高并发请求的场景。
MongoDB的特点和优势 灵活的数据模型：MongoDB不需要事先定义表格结构，可以存储各种类型的数据，支持嵌入式文档和引用两种数据关联方式。强大的查询语言：MongoDB提供丰富的查询操作符和聚合管道功能，支持复杂的查询和分析需求。高性能的数据读写：MongoDB使用内存映射文件和预分配空间等技术优化数据读写性能，支持快速的插入、更新和查询操作。可扩展的存储和计算能力：MongoDB支持水平扩展和自动分片，可以方便地增加服务器和处理大规模数据。丰富的工具和生态系统：MongoDB提供了命令行工具和图形界面管理工具，还有众多的第三方库和框架支持。 第二章 安装与配置 下载和安装MongoDB 首先，我们需要从MongoDB官方网站下载适合自己操作系统的安装包。然后按照安装向导进行安装，过程比较简单。安装完成后，我们需要将MongoDB的可执行文件路径添加到系统环境变量中，以便可以在任意位置运行MongoDB命令。
配置MongoDB服务器 在安装完成后，我们需要进行一些基本的配置以确保MongoDB服务器的正常运行。主要包括以下几个方面：
数据存储路径：指定数据库文件的存储路径，建议选择一个空闲磁盘分区，并且具有足够的存储空间。监听地址和端口：指定MongoDB服务器监听的网络地址和端口，默认为127.0.0.1:27017，可以根据实际需求进行调整。认证设置：MongoDB支持对客户端连接进行身份认证，可以创建用户并分配权限，以确保数据的安全性。日志配置：可以指定日志文件的路径和级别，以便跟踪服务器的运行状态和故障排查。其他配置项：还有一些其他的配置项，如复制集、分片等高级配置，根据需要进行设置。 第三章 数据模型 文档导向的数据模型 MongoDB使用文档导向的数据模型来存储数据。文档是一个键值对的集合，类似于关系型数据库中的行，但是更为灵活。文档可以包含嵌入式文档、数组和其他复杂类型，可以根据需要自由地添加、修改和删除字段。
集合和数据库 MongoDB中的数据组织在集合（Collection）中，集合类似于关系型数据库中的表。一个集合可以包含多个文档，每个文档可以拥有不同的结构和字段。集合之间没有直接的关系，可以根据实际需求自由地创建和管理。
一个MongoDB服务器可以包含多个数据库，每个数据库独立存储数据。数据库是逻辑上的容器，可以将相关的集合组织在一起。每个数据库在服务器上有唯一的名称，在使用之前需要先创建。
索引 索引在MongoDB中起到加速查询的作用。通过索引，可以快速定位到符合特定条件的文档，提高查询效率。MongoDB支持多种类型的索引，包括单键索引、复合索引、全文索引等。
嵌入式文档和引用 MongoDB支持两种数据关联方式：嵌入式文档和引用。嵌入式文档是将一个文档嵌入到另一个文档中，形成文档的嵌套结构。引用是通过存储文档间的关联关系来实现数据关联。根据实际需求选择合适的数据关联方式。
第四章 查询语言 CRUD操作 在MongoDB中，CRUD操作（创建、读取、更新、删除）非常简单和直观。以下是一些常用的CRUD操作命令和示例：
创建文档：db.collection.insertOne()、db.collection.insertMany()读取文档：db.collection.find()、db.collection.findOne()更新文档：db.collection.updateOne()、db.collection.updateMany()删除文档：db.collection.deleteOne()、db.collection.deleteMany() 查询和筛选 MongoDB提供了丰富的查询操作符，可以用于指定查询条件和筛选结果。常用的查询操作符包括比较操作符（ e q 、 eq、 eq、ne、 g t 、 gt、 gt、lt等）、逻辑操作符（ a n d 、 and、 and、or、 n o t 等）和正则表达式操作符（ not等）和正则表达式操作符（ not等）和正则表达式操作符（regex）等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f1020895f3bf389e632b10d3ed64001/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/760f967f55e6ea7c05e54d71904e65e8/" rel="bookmark">
			软件设计师中级王勇老师课程笔记-1计算机组成与体系结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据软考-软件设计师中级考试王勇老师课程做的手写笔记，包含12个章节，计算机组成与体系结构、操作系统、数据库系统、计算机网络、数据结构与算法基础、程序设计语言与语言处理基础、法律法规、软件工程、面向对象、数据库和数据流图、UML、数据结构与算法应用、面向对象程序设计等内容，个人认为本笔记可以用来过一遍基础知识，王勇老师讲的一些技巧还是比较实用的，有问题欢迎指正！
欢迎大家下载呀！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10f3a0fca79f203a2e691719a4de29cf/" rel="bookmark">
			蜣螂优化(DBO)算法(含MATLAB代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先做一个声明：文章是由我的个人公众号中的推送直接复制粘贴而来，因此对智能优化算法感兴趣的朋友，可关注我的个人公众号：启发式算法讨论。我会不定期在公众号里分享不同的智能优化算法，经典的，或者是近几年提出的新型智能优化算法，并附MATLAB代码。
蜣螂优化(DBO)算法： “今天介绍的这个算法，应该是目前最新的一个群智能优化算法。实际上，一个周以前我就看到了，但是没有去深入了解和学习。昨天对它的原始参考文献进行了仔细阅读，并编码实现了这个算法，应该说，这个算法的收敛性能还是非常优越的！
这里再啰嗦一句，蜣螂，就是屎壳郎！翻译成蜣螂优化，会显得高大尚些，档次一下就有了，要是来个屎壳郎算法，就太不文雅了……”
蜣螂优化(Dung Beetle Optimizer, DBO)算法是2022年11月27日提出的，大家可以算算到今天才提出多久。它是由东华大学的沈波教授团队提出的一种全新的群智能优化算法。或许大家对这个团队不是很了解，但相信大家对麻雀搜索算法(Sparrow Search Algorithm, SSA)一定不陌生。著名的SSA就是由这个团队提出，感兴趣的同学可以进一步跟踪一下。
DBO算法的原始参考文献如下：
“Xue J, Shen B. Dung beetle optimizer: a new meta-heuristic algorithm for global optimization[J]. The Journal of Supercomputing, 2022: 1-32.”
01 灵感来源 蜣螂是自然界常见的昆虫，以动物的粪便为食。学过生物的同学都知道，它们在自然界中扮演着分解者的角色，这意味着它们在生态系统中至关重要。蜣螂有一个有趣的习惯，就是把粪便打成球状，然后滚出来，如图1所示。
​
图1 蜣螂的滚球行为
一方面，蜣螂会尽可能快速地移动它们的粪球，这样可防止被其他蜣螂竞争；另一方面，蜣螂会利用天体线索(特别是太阳、月亮和偏振光)来导航，使粪球沿直线滚动。然而，如果没有了光源(即完全黑暗)，蜣螂的路径就不再是直线，而是弯曲的，有时甚至略圆。一些自然因素(如风和不平整的地面)也会导致蜣螂偏离原来的方向。此外，蜣螂在滚动粪球时很可能遇到障碍物，无法前进。此时，蜣螂会爬到粪球上跳舞(包括一系列的旋转和停顿)，这也决定了它们新的运动方向。(这里我想好奇地问一下，你能想象一个东西站在粑粑上跳舞的画面吗)
蜣螂收获的粪球主要有两个目的:1) 一些粪球用来产卵和养育下一代；2) 其余的用作食物。具体来说，蜣螂把粪球埋起来，雌性蜣螂在这些粪球里产卵。粪球不仅是幼虫的发育场所，还为幼虫提供了生活所必需的食物。
另外，一些蜣螂会从其他蜣螂那里掠夺粪球，作者将它们称作小偷，如图2所示，这也是自然界中很常见的现象。
​
图2 蜣螂中的小偷掠夺粪球
基于蜣螂的这些行为，作者提出了DBO算法，主要灵感就来自于蜣螂的滚球、跳舞、觅食、偷窃和繁殖行为。准确来说，应该叫蜣螂优化器。
02 算法设计 如上所述，作者对蜣螂的滚球、跳舞、觅食、偷窃和繁殖行为进行数学建模。DBO算法主要包括四个过程：滚球、繁殖、觅食和偷窃。与前几期推送一样，目前我还不会在公众号里编辑数学公式。因此，这部分内容在Word文档里先写好，然后做成图片，最后导入。
​
​
​
​
由此，作者便提出了基于蜣螂滚球、跳舞、觅食、偷窃和繁殖行为的DBO算法。简单地说，DBO算法也是基于子种群的，每个子种群执行不同的搜索方式。与蛇优化(SO)和蜉蝣算法(MA)不同的是，DBO算法不是基于双种群的，而是基于多个子种群，作者划分了四个子种群。
03 计算流程 由于DBO算法将种群中的蜣螂划分成了四种不同的角色，因此它的计算流程会相对复杂一些，需要执行滚球、繁殖、觅食和偷窃四种算子。这里我用伪代码给出了它的计算流程，如图7所示。
​
图7 DBO算法计算流程
04 实验仿真 DBO算法到今天才提出两周不到，因此我非常好奇它的性能。这里对DBO算法的收敛性能进行了简单的测试。在编码中，所有参数按照它原始文献的取值进行设置，种群规模N为30，最大迭代次数T也与原文一致，等于500，问题维度D我选取的30。
这里以多峰函数Ackley、Levy和单峰函数Zakharov为例，展示DBO算法在30维环境下的收敛效果，如图8所示。这里就不再进一步做分析了。
​
(a) Ackley
​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10f3a0fca79f203a2e691719a4de29cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79130821c13147d59540b58663a417e2/" rel="bookmark">
			SQL数据分析——笔记系列【上篇】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.数据分析基础 数据分析：利用合适的工具，在统计学理论的支撑下，对数据进行一定程度的预处理，然后结合具体业务分析数据，帮助公司相关部门监控、定位、分析、解决问题，从而提高业务部门的决策能力和经营效率，发现业务机会，让企业取得持续竞争优势。
数据分析三大作用：现状分析、原因分析、预测分析。
数据分析分析内容层面：
1.总体概览指标（日销售额、日订单量、购买人数……）；
2.对比性指标（同比、环比、差指标）;
3.集中趋势指标（平均数、众数、中位数）；
4.离散程度指标（全距(极差)、方差、标准差）；
5.相关性指标（相关系数r，范围[-1,1]，正相关/负相关）；
6.因果关系
数据分析一般流程：
1.熟悉工具；2.明确目的；3.获取数据；4.熟悉数据；5.处理数据；
6.分析数据；7.得出结论；8.验证结论；9.展现结论
二.数据库基础 数据库：用来存储数据的仓库，用户可以对存放在这个仓库中的数据进行新增、查询、更新、删除等操作。
数据库管理系统（DBMS）：对数据库进行管理的一个系统，这个系统负责建立、使用和维护数据库，对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。
结构化数据：有行有列的二维数据。——&gt;【关系型数据库】
非结构化数据：不适合用行和列的形式来存储的数据（Word文档、HTML文档、图片等）。——&gt;【非关系型数据库】
SQL: Structured Query Language，结构化查询语言。
SQL包括：
1.DDL（数据定义）：create、drop、alter，主要作用于数据库、表、视图、索引。
2.DML（数据操纵）：select、insert、update、delete，主要作用于表。
3.DCL（数据控制）：grant、revoke，主要作用于表、列。
SQL查询处理步骤
1.查询分析：扫描全部SQL语句，进行词法和语法分析，判断查询语句是否符合SQL语法规则；
2.查询检查：进行语义检查，根据数据字典判断查询语句中涉及的数据库、数据表、列等信息是否存在；
3.查询优化：根据具体情况选择一个效率最高的执行策略；
4.查询执行：执行查询语句，返回查询结果。
主流数据库：
Mysql，受欢迎，比较主流，已被Oracle收购；
SQL Server，微软开发，与自己的产品交互比较好；
Oracle，甲骨文，数据库领域引领者；
DB2，IBM开发，主要目标用户是企业；
Hive SQL，大公司比较常见，Hive是基于Hadoop构建的一套数据仓库分析系统，与Mysql的语法基本一致。Hadoop是一种分布式处理架构，可大幅提高程序运行效率。
三.数据库工具准备 Mysql官网：www.mysql.com
DBeaver:一款免费的、开源的，开发人员和数据管理员通用的数据库管理工具。
DBeaver官网：DBeaver Community | Free Universal Database Tool
四.数据源 常规数据源：外部数据、公司现有数据、新建数据。
熟悉数据：
1.数据库是什么数据库；
2.数据库包含哪些表；
3.各表存储了什么信息，表中每列分别代表什么。
Mysql附属数据库information_schema：
show databases;
use information_schema;
show tables;
select * from information_schema.SCHEMATA;--查询Mysql中所有与库有关的信息
select * from information_schema.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79130821c13147d59540b58663a417e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c71bb72af9468659741fe1a594f1c90/" rel="bookmark">
			【Python】pyecharts 模块 ⑦ ( 绘制时间线柱状图 | 时间线 Timeline 简介 | 时间线 Timeline 柱状图开发要点 | 播放设置 | 主题设置 | 代码示例 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、pyecharts 绘制时间线柱状图1、时间线 Timeline 简介2、时间线 Timeline 柱状图开发要点3、代码示例 - 时间线 Timeline 柱状图 二、pyecharts 绘制时间线柱状图其它设置1、时间线 Timeline 播放设置2、时间线 Timeline 主题设置3、代码示例 - 时间线特殊设置 pyecharts 画廊网站 : https://gallery.pyecharts.org/#/
在该网站可查看官方示例 一、pyecharts 绘制时间线柱状图 1、时间线 Timeline 简介 pyecharts 时间线柱状图 中的 时间线 , 就是与 x 轴平行的一个 时间轴 ;
时间线 的类是 Timeline , 定义在 pyecharts.charts 模块中 ;
在 时间线 上的每个点 , 都代表一个时间点 ,
为 时间线 上的 每个 时间点 都提供一个柱状图 ,
当 时间线 开始播放时 , 随着时间线向前推进 , 推进到不同点 , 就会显示该点对应的 柱状图 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c71bb72af9468659741fe1a594f1c90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1aa50f72920e27e16ce274e9e0b7aa7/" rel="bookmark">
			Halcon初步学习二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、特征监测的应用
gen_rectangle1：创建矩形
（Rectangle名字，Rov1和Column1为左上角开始坐标，Rov2和Column2为右下角结束坐标）
gen_rectangle2：创建任意方向的矩形（放射矩形）
（Rectangle1名字，前两个值为中心做标，后两个值分别是长轴的一半和短轴的一半。rad：可以将Phi夹角转换为度数）
gen_circle：创建一个圆
（Circle名字，第一个中心的列坐标，第二个中心行坐标，圆的半径）
gen_ellipse：创建一个椭圆
（Ellipse名字，前两个是中心坐标，Phi弧度，长轴的半径，短轴的半径）
gen_region_line：创建一条线
（前两个值为开始点的做标，后两个为结束点坐标）
union2：把两个区域合并为一个大的区域
reduce_domain：剪切对象区域（等于把一块已经规划好的区域剪切出来）
elliptic_axis：获取区域的等效椭圆参数
（Ra长轴的一半，Rb短轴的一半，Phi弧度）
area_center：获取区域的面积和中心坐标
MeanRadius := sum(Ra) / |Ra| -1：计算区域的平均长半轴半径，|Ra|代表有多少个存在。
二、判断回形针的方向（练习）
set_display_font(WindowHandle, 16 , 'mono' , 'true' , 'false')：设置窗口字体显示的样式
disp_continue_message(WindowHandle, 'black' , 'true')：在右下角显示
（Press Run(F5) Continue字样）
binary_threshold：二值化阈值操作。意思：找暗的区域或者亮的区域，也可以理解为找背景色，或者前景色。（作用：对图象进行二值化。思路：0—UsedThreshold将回形针分割出来）
orientation_region：获取过滤后图像的方向。Phi弧度
dev_set_line_width(3)：设置输出对象的线宽。
disp_arrow：再窗口中显示的箭头。
disp_message：再窗口上显示回形针的度数/字符串。
（第二个填写是固定的度数deg(Phi)$'3.1f' + 'deg'）
三、查找PCB上的Pads区域（练习）
dev_set_part：修改窗口里显示图像的大小。
fast_threshold：快速阈值
（里面的20为最小面积不能低于20）
shape_trans：将填充后的区域转化为凸形。
boundary：获取凸形边界
dilation_circle：对边界区域进行膨胀操作
（结构原件为3.5，会变大）
union1：将膨胀的区域合并成一个区域
（跟union2相比这个更为简练切便捷）
edges_sub_pix：便捷提取
select_shape_xld：对边界的轮廓进行过滤
（保留长度在范围[10-200]之间）
union_adjacent_contors_xld：将相邻的轮廓合并为一个轮廓
fit_rectangle2_contour_xld：将合并后的轮廓 合并为一个仿射矩形轮廓 (仿射) 创建一个矩形 获取数据。
gen_rectangle2_contour_xld：生成放射轮廓
四、根据颜色提取想要的目标对象（练习）
for i := 1 to 2 by 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1aa50f72920e27e16ce274e9e0b7aa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7517ac1318e371cd2b53e513994eec84/" rel="bookmark">
			C语言之打印菱形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
题外话
1.打印简单菱形
2.进阶，打印中空菱形
3.再次进阶，打印自定义中空菱形
4.优化
题外话 在这里呢，我先说一下我今天所讲的内容，首先是菱形的打印，然后是进阶到打印空菱形，再进阶到自定义打印，我呢之前是连打印菱形都不会的，经过这么些天的写代码，改代码，真的觉得自己进步了很多，所如果看到这篇博客的小伙伴，真的不要担心自己写不好代码，只要你肯下功夫就一定能成为一个好的程序员。就像我之前看过一个报道，采访的是一个没有高考直接保送北大的小伙子，主持人问他你能有今天的成就你觉得天赋和努力哪个更重要，没想到小伙子说：我觉得这二者不能分开来讲吧，有时候，努力就是一种天赋，我当时听了这话深受感触，是啊，谁又能主宰别人的命运呢，只有自己可以，所以呢，我写这些话也是对自己的鞭策吧，让我们一起努力，一起坚持把键盘敲烂！
1.打印简单菱形 这里，我就拿5行的菱形举例了，这五行菱形呢，分为上和下两部分，一个是三角形，一个是倒着的三角形没有角，这里呢我就拿正的三角形进行讲解，如果你细心一点应该不难发现，要想实现这个三角形的打印，要有" "和“ *”，我们可以剥离来看，我们先不看空格，那么“*”就是一个直角三角形对吧，因为空格的出现才把“*给挤走的，倒三角也是一样的原理，这里我们一定要去画图去找关系才可以的，你想是很难想出来的，一定要多动手。好了，上代码和运行截图以及我的理解：
为什么说一定要去画图，就是因为这里面的取等条件的判断，只有你画出图来，思路清晰，才知道其中含义，这里我的答案不是唯一的，大家如果感兴趣可以自己去写属于自己的代码。
2.进阶，打印中空菱形 好了，现在菱形打印出来了，是不是感觉意犹未尽，我当时也有这种感觉，但是那时候会的太少了，所以也没深挖，但是现在不一样了，我可以给你们讲啊，嘿嘿，觉得还不错的小伙伴能点点关注收藏吗，求求了。好了，回归正题，那么空格菱形怎么打印呢，只需要在合适的地方加上限制条件就OK了。好了，我先上代码加运行截图，在讲解：
这里来看，我只是再循环里面加上了if语句，起到了限制作用，因为我们要打印中空菱形吗，所以只要 把菱形的边角打印出来，剩下的打印空格不就好了，这里比较好想的是j==0；因为第一个肯定是要打印的，那最后一个怎么弄呢，还是老办法，画图，真的很重要。画图，画图，画图！！！重要的事情说三遍，我这里就不去演示了。
3.再次进阶，打印自定义中空菱形 这次呢，又在中空菱形的基础上加上自定义了，其是想明白是不难的，难在画图和理解上，这里我给大家提供我的思路，就是先去列举5行，7行，9行怎么实现“ ”和“*”的打印，这个规律性很强，要去理解j和i的关系。
4.优化 这里呢我对其做出了优化，因为打印的菱形必然为奇数行，所以我对其进行了断言，只要输入偶数，就直接报错，不知道的小伙伴不要急，用assert进行断言，我这里直接给查询链接，https://legacy.cplusplus.com/reference/clibrary/
上代码：
当我输入为偶数，直接报错。 当时我做出来有点小激动，哈哈，那今天我就分享到这里了，希望大家能点一个大大的赞 ，嘿嘿，有什么问题评论去留言或者加我好友，我看见一定回，另外如果我有什么地方出问题了，欢迎大家告知，感谢，下次再见。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1240ad57383b0630867a4a5474be560/" rel="bookmark">
			Linux 压测工具---ab安装及参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ab压测工具 ab是apache bench命令的缩写。
原理： ab命令会创建多个并发访问线程，模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的，因此，它既可以用来测试apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其它Web服务器的压力。
ab命令对发出负载的计算机要求很低，它既不会占用很高CPU，也不会占用很多内存。但却会给目标服务器造成巨大的负载，其原理类似CC攻击。测试时也需要注意，一次性太大的负载。可能会造成目标服务器资源占用过高，严重时可能会导致死机。
使用ab命令但是不想安装apache，我们可以直接安装apache的工具包httpd-tools，这里已腾讯云的云服务器为例。
安装 yum -y install httpd-tools 参数 [root@VM-2-14-centos ~]# ab --help ab: wrong number of arguments Usage: ab [options] [http[s]://]hostname[:port]/path Options are: -n requests Number of requests to perform ##要执行的请求数 -c concurrency Number of multiple requests to make at a time ##单次发出的并发请求数 -t timelimit Seconds to max. to spend on benchmarking This implies -n 50000 ##用于测试的最大秒数，等价于 -n 等于50000 -s timeout Seconds to max. wait for each response Default is 30 seconds ##等待每个响应的最长秒数，默认值为30秒 -b windowsize Size of TCP send/receive buffer, in bytes ##TCP发送/接收缓存区的大小（字节） -B address Address to bind to when making outgoing connections ##建立传出连接时要绑定的地址 -p postfile File containing data to POST.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1240ad57383b0630867a4a5474be560/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31c62a6dc37f4e8981447320a162b274/" rel="bookmark">
			Latex表格拓宽至文本宽度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在latex进行排版时，出现了这样一个需求。一个普通的表格，需要将两边拉长，等于论文单栏的长度（双栏排版）。
然后试了下resizebox，确实拉长了，但是表格的字体变大了。
搜了半天，发现可以用\begin{tabular*}{\hsize}{@{}@{\extracolsep{\fill}}|c|c|c|c|c|c|@{}}，确实达到了想要的效果，但是对齐有点问题。并不是标准的居然，而是前面多一块空白，然后再居中。
感觉有点头大。忽然想，是不是该调一下缩进？在上面那种情况，小白我也调不好，干脆直接普通表格调就好了。
直接在表格数据前面和后面加空格，不就把表格变长了吗。所以在表格数据前后加\hsapce，
\hspace{0.5em}表格数据\hspace{0.5em}。然后调一调距离0.5这个参数就好了。
当然有大佬会直接调那更厉害了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/873db5660099afaf59483b980d86f9d7/" rel="bookmark">
			Unity TMP (TextMeshPro) 创建字体材质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 TMP 简介 完整名称：Text Mesh Pro ，unity新一代主流字体插件
1.1 组件变化 内置的Text组件以及与内置Text组件绑定的Button、DropDown、InputField均被替换为使用TextMeshPro的版本
内置的Text组件以及与内置Text组件绑定的Button、DropDown、InputField则被移动到Legacy菜单
1.2 变化说明 旧的组件只是移动到Legacy菜单，并不是真的弃用，目前还可以正常使用。
2D Legacy菜单
3D Legacy菜单
2 创建方法 2D元素 基于Canvas创建并显示，Hierachy窗口右键选择UI -&gt; Text - TextMeshPro 即可创建一个2D的TMP,可以在2D空间进行旋转移动缩放。
一些基本属性和内置Text相同，TMP比内置text可选属性变多。
3D元素 3D世界空间创建并显示，Hierachy窗口右键选择3D Object -&gt;Text - TextMeshPro 即可创建一个3D的TMP,可以在3D空间进行旋转移动缩放。
3D元素与2D元素区别在于渲染组件，2D是CanvasRenderer组件渲染，3D使用MeshRenderer渲染，材质使用TMP专用字体的子材质节点。
3 从字体创建TMP专用材质 字体可以直接导入TTF文件，选择TTF文件，右键 Create -&gt; TextMeshPro -&gt; FontAsset 即可创建TMP专用材质，拖入即可使用
创建完毕
赋值给TMP文字的FontAsset字段
4 设置TMP默认材质 TextMeshPro文件夹下TMP Setting文件，设置Resources文件夹相对路径，然后拖入对应字体，则修改创建TMP文字的默认字体。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5db0353a81278ffebd68911fe98732ab/" rel="bookmark">
			@Qualifier多个类实现接口时，bean的实例化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多个类实现接口时，bean实例化的方法
@Qualifier
@Qualifier是Java中的一个注解，用于区分同一类型的多个bean。它通常与@Autowired注解一起使用，用于指定要注入的特定bean。
在Spring中，当有多个同一类型的bean时，Spring无法确定要注入哪个bean。这时就需要使用@Qualifier注解来指定要注入的bean。
@Qualifier注解可以用于字段、构造函数和方法参数上。它的值可以是任何字符串，通常使用bean的名称作为值。
下面是一个使用@Qualifier注解的示例：
```
@Component("bean1")
public class MyBean1 implements MyInterface {
// ...
}
@Component("bean2")
public class MyBean2 implements MyInterface {
// ...
}
@Component
public class MyComponent {
@Autowired
@Qualifier("bean1")
private MyInterface myBean;
// ...
}
```
在这个例子中，我们有两个实现了MyInterface接口的bean：MyBean1和MyBean2。我们想要将MyBean1注入到MyComponent类中，因此我们使用@Qualifier("bean1")注解来指定要注入的bean。
需要注意的是，@Qualifier注解只有在与@Autowired注解一起使用时才有意义。如果没有@Autowired注解，@Qualifier注解将不起作用。
另外，@Qualifier注解也可以与@Primary注解一起使用。当有多个bean都被标记为@Primary时，@Qualifier注解可以用来指定要注入的特定bean。
总之，@Qualifier注解是Spring中非常有用的一个注解，它可以帮助我们解决同一类型的多个bean注入的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed45e8394cf24d5face97d67f8b6834d/" rel="bookmark">
			Spring项目中的拦截器和注册器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拦截器作用与使用方法
参考：Springboot下自定义与注册拦截器 https://www.cnblogs.com/liangf27/p/10466996.html
拦截器的作用是什么？一般什么场景使用？
拦截器的作用是在请求发送到服务器或响应返回到客户端之前，对请求或响应进行拦截和处理。拦截器可以对请求进行预处理，如添加请求头、验证请求参数等；也可以对响应进行处理，如添加响应头、对响应数据进行加工等。
拦截器一般用于以下场景：
1. 权限验证：在请求到达服务器之前，对用户的身份进行验证，判断用户是否有权限访问该资源。
2. 日志记录：记录请求的详细信息，如请求的URL、请求参数、请求时间等，方便后续的调试和分析。
3. 缓存处理：在请求到达服务器之前，检查缓存中是否已经存在该请求的响应结果，如果存在则直接返回缓存结果，减少服务器的压力。
4. 统一处理：对请求进行统一处理，如添加请求头、对请求参数进行加工等，避免重复的代码。
5. 异常处理：对请求和响应进行异常处理，如捕获异常、记录异常信息等，保证系统的稳定性和可靠性。
spring中拦截器的原理是什么？怎么实现的
Spring中的拦截器是基于AOP（面向切面编程）实现的。具体来说，Spring MVC中的拦截器是通过实现HandlerInterceptor接口定义的，该接口定义了三个方法：
1. preHandle：在请求处理之前进行调用，返回值为boolean类型，如果返回false，则请求中断，不会继续向下执行。
2. postHandle：在请求处理之后进行调用，但是在视图被渲染之前，即Controller方法调用之后。
3. afterCompletion：在整个请求处理完成后进行调用，即在视图渲染完毕之后。
SpringMVC中的拦截器定义后需要通过WebMvcConfigurer进行注册，并且可以指定拦截器的拦截路径。
在请求到达DispatcherServlet之后，会根据请求的URL和HandlerMapping进行匹配，找到对应的Controller方法。在执行Controller方法之前，会先执行拦截器的preHandle方法，如果返回false，则请求中断，不会继续执行。在Controller方法执行完毕之后，会执行拦截器的postHandle方法和afterCompletion方法。
总的来说，Spring中的拦截器是通过AOP实现的，通过拦截器可以对请求进行预处理和后处理，实现了请求的统一处理和异常处理等功能。
实例如下：
/***
* 性能监控拦截器
*/
@Component
@Log4j2
public class StopWatchInterceptor extends HandlerInterceptorAdapter {
private NamedThreadLocal&lt;Long&gt; startTimeThreadLocal = new NamedThreadLocal&lt;Long&gt;("StopWatch-StartTime");
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
throws Exception {
long beginTime = System.currentTimeMillis();
startTimeThreadLocal.set(beginTime);
return true;
}
@Override
public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed45e8394cf24d5face97d67f8b6834d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3272888c6e031e19b95150381eedeea1/" rel="bookmark">
			CTF-REVERSE练习之逆向初探
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逆向是指通过反汇编和调试等一些手段及工具，分析计算机程序的二进制可执行代码，从而获得程序的算法细节和实现原理的技术。不仅如此，逆向技能在信息安全面向的具体工作，如恶意代码分析、软件漏洞挖掘、移动安全以及对软件的破解方面发挥着巨大的作用。
前面介绍过CTF的web真题，那今天我们从CTF中选择一个REVERSE题型来讲解。
先介绍一下，REVERSE是CTF竞赛中的一种常见题目类型，主要考察参赛选手逆向工程相关的知识，考查形式为通过对一个二进制程序（exe、dll或者是elf等）进行逆向分析，了解程序内部的实现机制，最终目的可能是得到一个密码，或者是编写一个注册机用于计算指定用户名对应的注册码等。
那我们要怎么才能对一个程序进行逆向，一个完整的程序怎么看到它的代码呢？
当然别人也想到过这种问题，所以就出现了几种帮助逆向的工具。
1.PEiD是一款著名的查壳工具，其功能十分强大，几乎可以侦测出绝大部分的壳以及程序编译信息。PEiD支持各种外部插件，同时支持用户自定义的加壳程序签名信息。
2.Ollydbg简称OD，是一款具有图形用户界面的用户模式调试器，可以运行于各种主流Windows操作系统下。Ollydbg具有动态调试和静态分析功能，非常容易上手，对异常的跟踪处理相当灵活，并且许多爱好者为这款调试器编写了许多非常棒的插件，这些特性使得其成为Windows操作系统上用户模式下动态调试器的首选。Ollydbg的反汇编引擎十分强大，可以识别数千个被C和Windows频繁使用的函数，并可以自动对参数进行注释。底下是OD一些常用的快捷键。
F2 设置一个断点（如果断点已经存在，那么断点将被删除）
F4 运行到光标所在行（运行到光标所在行时自动断下）
F7 单步跟踪（如果遇到一个call，则跟踪进入）
F8 单步跟踪（如果遇到一个call，则执行完整个call）
F9 继续执行（运行程序，直到进程退出或遇到下一个断点）
3.IDA是一款交互式反汇编工具，其功能十分强大，支持多操作系统、多处理器下的二进制程序的反汇编分析，并且可以和使用者进行交互来提升处理效率。IDA支持插件，支持IDC脚本，Hex-
Rays
Decompiler是IDA一个十分强大的插件，支持将反汇编代码直接转换为C语言伪代码，极大的提高了反汇编分析人员的工作效率。这底下是ida的快捷键可以帮助我们更加高效的进行分析。
空格 在图形模式和列表视图模式之间切换反汇编视图
F5 将反汇编指令还原为伪代码
x 查看交叉引用
n 对变量名或者函数名进行重命名操作
d 将二进制数据解释为字节/双字/四字
c 将二进制数据解释为代码
a 将二进制数据解释为字符串
实验步骤 好我们来开始实验，先进入实验网页：[CTF-
REVERSE练习之逆向初探](https://www.hetianlab.com/expc.do?ec=ECID172.19.104.182014111410002900001&amp;pk_campaign=freebuf-
wemedia)。
题目描述：
主机C:\Reverse\1目录下有一个CrackMe1.exe程序，运行这个程序的时候会提示输入一个密码，当输入正确的密码时，会弹出过关提示消息框，请对CrackMe1.exe程序进行逆向分析和调试，找到正确的过关密码。
我们开始第一步进行外部行为分析不管在什么场景下，相信你在刚接触一个新事物的时候，都会仔细观察事物的外部特征，CTF做题也是一样的，在拿到题目之后可以运行程序，观察程序都有哪些地方可以输入数据，哪些按钮点击了会有什么样的反应，在操作过程中出现了哪些提示等。
我们通过对CrackMe1.exe程序的观察，知道程序需要输入一个密码，当不输入任何数据就点击按钮时，提示如下信息：
当输入一串测试数据时，提示如下信息：
这里有弹框还有提示，我们是不是直接去查找这个提示就可以了呢。但是我们在对一个程序进行逆向分析之前，除了程序的动态行为之外，查看程序是否加壳（被何种程序加壳？是什么编译器编译的？）也是一个非常关键的步骤。之前提到了PEID，我们就用PEID来查壳我们选中程序后单击右键，在右键菜单中选择“Scan
with PEiD”选项，就可以查看加壳信息了。我们这里看到的是Microsoft Visual C++
6.0，说明CrackMe1.exe没有加壳，且它是使用VC6编译的。
我们换OD来进行动态调试，
动态调试可以帮助我们了解程序内部执行逻辑的许多详细信息，很多信息只有在程序运行起来之后才会看到，这也是静态分析所无法简单获取到的。OD是我们在Windows操作系统下动态调试器的首选。
操作选择CrackMe1.exe程序后单击右键，在右键菜单中选择“用OllyICE”打开，就会进行OD调试器的主界面，我们在反汇编指令列表窗口中单击右键，依次选择“Ultra
String Reference”、“Find ASCII”菜单项，如图所示：
之后会弹出字符串列表窗口，这个窗口列出了当前进程内存空间中存在的各种字符串，我们可以查看是否存在有我们感兴趣的字符串。比如前面曾经提示“密码错误”的提示，那么我们就可以按下Ctrl+F，在弹出的窗口中输入“密码错误”，然后单击确定按钮查找：
上面还有一个密码正确，恭喜过关，这是不是关键呢？我们试一试双击这个看看。
双击找到字符串的那一行，来到OD的反汇编窗口，就能看到代码指令中引用这个字符串的地方了。如下图所示：
在这个代码片段中，我们还看到了一个jnz跳转指令，这个指令是否跳转将决定着弹出成功的提示还是弹出失败的提示，这样的跳转也就是所谓的关键跳转。在关键跳转之上的代码往往就是关键的密码判断逻辑，因此我们可以着重分析关键跳转之上的代码。在关键跳转之上，我们在下面的的位置下一个断点（鼠标单击这行代码选中，然后按下F2）：
00401456. 55 push ebp
下好断点之后，按下F9运行程序，随便输入一个密码（比如test）后单击按钮，程序就自动在我们的断点断下了，接下来按F8开始进行单步跟踪，当跟踪到00401490的时候，我们发现了我们输入的密码test，同时发现字符串HeeTianLab，如图所示：
仔细分析上面的代码，发现是在从这两个字符串里面取出字符一个一个进行对比，只要有一个字符不一样，最终都会跳转到提示失败的地方去。那么可以猜测HeeTianLab就是正确的密码了，我们运行另一个CrackMe1进程，输入HeeTianLab，弹出成功提示：
这就通关了，接下来我用另外一个神器IDA再来做一遍，有动态的神器，肯定还有一个静态的神器。
除了动态调试之外，静态分析也是一种很重要的技能。静态分析可以帮助我们快速了解程序的代码执行逻辑，尤其是使用IDA的Hex-
Rays插件将汇编代码生成伪代码的功能，可以极大地提高我们的分析效率。
使用IDA打开CrackMe1.exe程序，IDA会提示选择文件类型、处理器类型等，通常我们不需要修改这些设置，直接单击“OK”按钮即可。之后IDA会对程序进行分析，等待一段时间，待分析结束之后，在下方的“Output
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3272888c6e031e19b95150381eedeea1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c66fb694790bfa1297218ed67d430de5/" rel="bookmark">
			【cs61b】学习笔记day1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 java基础 Hello World java程序由一个类声明组成，使用关键字public class声明。在Java中，所有代码都位于类中。
运行的代码在一个名为main的方法中，该方法被声明为public static void main(String[] args)。
我们使用大括号{}表示一段代码的开始和结束。语句必须以分号结束
运行java程序 执行Java程序最常见的方法是通过两个.program的序列运行它。第一个是Java编译器，或javac。第二个是Java解释器(Java)。
变量和循环 所有的变量必须在使用之前声明，并且必须给它一个指定类型，而且这个类型在后面的程序中不可改变，类型在代码运行前就被验证循环定义包含在花括号内，测试的布尔表达式包含在圆括号内。我们的print语句只是System.out.print而不是System.out.println。这意味着我们不应该包括换行符(return)。print语句将一个数字添加到空格中。这样可以确保数字不会相互碰撞。在这些特性中，最重要的一个是 声明一个有指定类型的变量。 静态类型 Java最重要的特性之一是所有变量和表达式都有一个称为静态类型。
Java变量可以包含这种类型的值，而且只能包含这种类型的值。
此外，变量的类型永远不能改变。
Java编译器的关键特性之一是它执行静态类型检查。
静态类型具有以下优点:
编译器确保所有类型都是兼容的，使程序员更容易调试他们的代码。由于代码保证没有类型错误，编译程序的用户永远不会遇到类型错误。例如，Android应用程序是用Java编写的，并且通常只以.class文件的形式分发，即以编译格式分发。因此，这样的应用程序永远不会因为类型错误而崩溃，因为编译器已经检查过它们了。每个变量、参数和函数都有声明的类型，使程序员更容易理解和推理代码。
在Java中，我们可以说System.out.println (5 + " ");
但是在Python中，我们不能说print(5+“horse”)为什么会这样呢?
考虑这两个Java语句: String h = 5 + "horse"; int h = 5 + "horse"; 第一个会成功，第二个将给出一个编译器错误。由于Java是强类型的，如果您告诉它h是一个字符串，它可以将元素连接起来并给您一个字符串。但是当h是int型时，它不能把一个数字和一个字符串连接起来然后给你一个数字。
Python不限制类型，也不能假设你想要什么类型。x =5 +“horse”应该是一个数字吗?一个字符串?Python不知道。所以它出错了。
函数定义 在Python等语言中，函数可以在任何地方声明，甚至可以在函数外部声明。
在java中，不能在外面定义一个函数，所有的函数必须是类的一部分，类中的函数成为方法，所以在java中所有的函数都是方法。
函数的所有参数必须有声明的类型，Java中的函数只能返回一个值
好的编程风格的一些最重要的特征是:
一致的风格(空格、变量命名、大括号风格等)大小(行不要太宽，源文件不要太长)描述性命名(变量、函数、类)，例如变量或函数的名称为year或getUserName，而不是x或f。避免重复代码:除了一些更改之外，您几乎不应该有两个重要的代码块几乎相同。在适当的地方注释。Java中的行注释使用//分隔符。块(也就是多行注释)注释使用/* 和 */。
黄金法则是:编写代码时要让陌生人也能很容易理解。 break &amp; continue continue语句跳过循环当前迭代的其余部分，有效地直接跳转到增量条件。break关键字在调用时完全终止最内层循环。 1.2 定义和使用类 静态 &amp; 非静态方法 静态方法 Java中的所有代码都必须是类的一部分(或类似于类的东西，我们将在后面学习)。大多数代码都是在方法内部编写的。
让我们考虑一个例子:
public class Dog { public static void makeNoise() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c66fb694790bfa1297218ed67d430de5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fb40fbd05216891a7defe29e30c309a/" rel="bookmark">
			Ubuntu安装Gurobi&#43;CMake使用详细指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键词： Ubuntu, Gurobi, Cmake, CmakeLists
1 环境 Ubuntu 20.04Gurobi 10.01 2 安装Gurobi 2.1 下载Gurobi 下载地址：gurobi下载地址
这个一定要看：gurobi官方教程
截至今天（2023.6.1）最新版本是10.01，下载文件：gurobi10.0.1_linux64.tar.gz
2.2 解压 根据安装指导的说法，建议安装在/opt/目录下。所以需要把你下载下来的文件解压后复制到/opt、目录下
tar xvfz gurobi10.0.1_linux64.tar.gz sudo cp -r gurobi10.0.1_linux64/gurobi1001/ /opt/ 这时，你在/opt/gurobi1001/linux64/目录下就可以看到你解压的文件了
2.4 取得授权 使用高校邮箱和校园网IP可以获得Academic版本授权。
在这里申请授权码，如果你准备在单机上使用，建议你申请Named-User Academic类型，这样只需要每年认证一次即可。
授权后你会得到一串字符：形如 grbgetkey XXXXXX XXXXXX XXXXXX，复制这一串内容。
回到终端，输入你的授权码：
grbgetkey XXXXXX XXXXXX XXXXXX 这时会连接授权服务器，核验你的校园网IP，核验通过后，会让你选择授权文件的安装位置。一般默认安装在/home下即可。
当然你也可以把授权文件放在你的安装目录/bin下：
cd /opt/gurob1001/linux64/bin/ sudo chmod +777 grbgetkey grbgetkey XXXXXX XXXXXX XXXXXX 不管放在哪里，你都需要记住这个位置，后面会用到。
注意：
打开 gurobi.lic 文件，显示许可过期日期（ EXPIRATION=），以及支持的最大版本号（ VERSION=）。许可文件不能编辑。 许可到期后， 重新申请获得新激活码， 产生新的 gurobi.lic 许可文件替换掉旧许可文件授权码一旦激活，就和机器捆绑，无法转移、无法注销。更换机器、重装系统、更换用户账号都需要申请新授权码。授权码、授权文件、与你的电脑主板唯一对应。如果更换了电脑主板，即使是同一块硬盘，原有的授权也不能使用。需要重新申请，此时继续使用原有授权文件会报错如下： 即使连接校园网有时候也不一定可行，有的校园网IP无法被认证为教育IP。以上海交通大学校园网为例：直连SJTU时，会报错： error : ERROR 305: Ip: 58.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fb40fbd05216891a7defe29e30c309a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5075e4eb180210ff41b4c8f3bc016ab/" rel="bookmark">
			JSP详解，MVC开发模式，EL表达式，JSTL，三层架构，用户信息列表展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSP详解 jsp本质就是一个Servlet
指令 作用：用于配置JSP页面，导入资源文件格式：
&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 … %&gt;分类： page ： 配置JSP页面的 contentType：等同于response.setContentType() 设置响应体的mime类型以及字符集设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集） import：导包errorPage：当前页面发生异常后，会自动跳转到指定的错误页面isErrorPage：标识当前也是是否是错误页面。 true：是，可以使用内置对象exceptionfalse：否。默认值。不可以使用内置对象exception include ： 页面包含的。导入页面的资源文件 &lt;%@include file=“top.jsp”%&gt; taglib ： 导入资源 &lt;%@ taglib prefix=“c” uri=“http://java.sun.com/jsp/jstl/core” %&gt; prefix：前缀，自定义的 注释: html注释：
&lt;!-- --&gt;:只能注释html代码片段jsp注释：推荐使用
&lt;%-- --%&gt;：可以注释所有内置对象 在jsp页面中不需要创建，直接使用的对象一共有9个：
变量名 真实类型 作用 pageContext PageContext 当前页面共享数据，还可以获取其他八个内置对象request HttpServletRequest 一次请求访问的多个资源(转发)session HttpSession 一次会话的多个请求间application ServletContext 所有用户间共享数据response HttpServletResponse 响应对象page Object 当前页面(Servlet)的对象 thisout JspWriter 输出对象，数据输出到页面上config ServletConfig Servlet的配置对象exception Throwable 异常对象 MVC开发模式 jsp演变历史
早期只有servlet，只能使用response输出标签数据，非常麻烦后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 MVC：
M：Model，模型。JavaBean 完成具体的业务操作，如：查询数据库，封装对象 V：View，视图。JSP 展示数据 C：Controller，控制器。Servlet 获取用户的输入调用模型将数据交给视图进行展示 优缺点： 优点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5075e4eb180210ff41b4c8f3bc016ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2ee73910f4ccae5d02d36b08a74ef35/" rel="bookmark">
			java BigDecimal 保留两位小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Java 中，可以使用 setScale 方法来设置 BigDecimal 对象的小数位数。以下是一个例子，演示了如何将 BigDecimal 对象保留两位小数：
BigDecimal number = new BigDecimal("3.1415926"); BigDecimal roundedNumber = number.setScale(2, RoundingMode.HALF_UP); System.out.println(roundedNumber); // 输出结果为 3.14 在上述示例中，我们创建了一个 BigDecimal 对象 number，然后使用 setScale 方法设置小数位数为 2，并指定舍入方式为 RoundingMode.HALF_UP。最后，将结果赋值给 roundedNumber，它将保留两位小数。
请注意，setScale 方法不会修改原始的 BigDecimal 对象，而是返回一个新的 BigDecimal 对象作为结果。在设置小数位数时，需要指定舍入方式。在示例中，我们使用 RoundingMode.HALF_UP 进行四舍五入，您可以根据实际需求选择其他舍入方式。
如果想要对所有的 BigDecimal 对象都进行保留两位小数，可以考虑创建一个工具方法来处理该逻辑，便于重复使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a54a43225b86b9b11c8e0e68e2d7b12b/" rel="bookmark">
			苹果mac电脑如何安装虚拟机?CrossOver Mac2023
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac虚拟机怎么安装系统？macOS系统无法正常安装Windows应用，无法正常使用Windows系统中的文件。在macOS系统中安装虚拟机是一种比较恰当的解决方案。mac电脑怎么安装虚拟机？mac电脑安装虚拟机需要根据个人需求，有选择性地安装，因为有些虚拟机并不支持M1。下面我们来看详细介绍吧！
一、Mac虚拟机怎么安装系统 Mac虚拟机安装系统是一项复杂的操作，首先需要先下载Windows镜像文件，然后再通过mac虚拟机安装。
1.下载Windows镜像文件
在网上查找资源网站，然后将Windows 10镜像文件下载到mac上，这种镜像文件通常比较大，下载时间较长，而且资源网站也不容易找，有些网站还会冒充资源，携带大量计算机病毒，或者携带大量私货软件。
2.安装系统 安装系统时，我们需要借助虚拟机软件，怎么选择虚拟机软件，这个我们在第二部分再继续介绍。在mac中，常被使用的虚拟机软件是Parallels Desktop，这里我们以它为例来看看如何安装系统吧！
（1）创建虚拟机
虚拟机像一个盒子，首先要搭建Windows需要的框架。打开Parallels Desktop，单击右下角【+】便可以创建一个新的虚拟机环境。
（2）添加镜像文件
搭建了Windows系统需要的环境后，接下来要将前面下载的Windows镜像文件导入到虚拟环境中，根据文件保存路径添加即可，然后单击【继续】，进入Windows设置界面。
（3）设置Windows
这也是Parallels Desktop比较人性的一面，它会根据用户的使用场景匹配Windows系统所需要的配置方式。例如，我们这里常将虚拟机应用于办公，便可以选择【生产力】，然后单击【继续】，进入Windows基础设置界面。
（4）Windows基础设置
这里主要是设置Windows虚拟机的用户名称，以及用户登录密码。最后，单击【继续】，便完成了系统的安装。如此看来，在mac上使用虚拟机软件安装系统，是一项比较繁琐的工作。
二、mac电脑怎么安装虚拟机 mac电脑上的虚拟机有很多，有开源，也有非开源的。常见的虚拟机有刚才介绍的Parallels Desktop，还有开源的VirtualBox和VMware Workstation Pro，安装什么样的虚拟机要根据用户的个人需求，选定虚拟机后再安装便简单了。
1.怎样选择虚拟机
选择虚拟机时，首要考虑的当然是该虚拟机的功能，例如Parallels Desktop是少有的可以支持M1的虚拟机。同时，Parallels Desktop在系统恢复、图像处理、网络连接以及读写方面均明显优秀于其他mac虚拟机.，如果有这方面的需求建议安装Parallels Desktop。
Linux系统是码农们写程序时不可或缺的助手，那么作为开源的VirtualBox虚拟机便成为必要的软件了。虽然当前它不支持M1，但以后可能会适配的。
2.怎样安装虚拟机
据安装向导一步步操作便非常简单了，这里便不再过多赘述。
三、如何通过CrossOver安装Windows应用 通过上面两部分我们了解到，在mac安装虚拟机虽然能解决在mac不能安装Windows应用的障碍，但是下载安装虚拟机的成本太高，并且安装系统的学习成本也非常高，倒不如使用类虚拟机软件——CrossOver。
1.下载CrossOver
CrossOver Mac-安装包
https://wm.makeding.com/iclk/?zoneid=50028
2.安装软件
例如，我们通过【未列出的应用】路径将QQ游戏安装包导入CrossOver，然后选中安装文件，单击【继续】，便可在CrossOver创建Q游戏容器，并安装软件。
在容器内安装了运行Q游戏所需要的配置文件后，便会进入Q游戏的安装向导界面，跟随安装向导一步步操作，便能成功安装Q游戏。
3.启动应用
应用安装完成后，可以在【容器】中启动，也可以像启动mac自身应用一样在mac桌面启动应用。
四、总结
此篇内容，我们简单介绍了Mac虚拟机怎么安装系统，以及mac电脑怎么安装虚拟机。Mac虚拟机安装系统，是一项非常复杂的过程，首先要下载镜像文件，然后再通过mac虚拟机配置Windows系统所需要的环境。关于mac电脑安装虚拟机，这里我们介绍了两款常见虚拟机Parallels Desktop和VirtualBox，用户可以根据个人需求选择。在mac安装虚拟机从成本上而言，不如下载安装类虚拟机CrossOver。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5559b5225b80cfbaf09e8bbe53f27e3c/" rel="bookmark">
			CorelDRAW2022下载附带序列号安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CorelDRAW2022作为图形设计软件的代表，以其杰出和革新的特性赢得了长期的声誉和用户的赞赏，是一套屡获殊荣的图像编辑软件。
CorelDRAW 2022包含程序：
CorelDRAW 2022主程序矢量插图和页面布局工具
Corel PHOTO-PAINT 2022图像编辑工具：编辑照片，享受与 CorelDRAW 的集成工作流。
Core Font Manager 2022字体开发与管理工具：无需安装即可直接使用自己喜欢的字体。
PowerTRACE人工智能驱动的位图转矢量图工具
CorelDRAW.app通过网页浏览器进行在线图形设计，让您在没有电脑的时候也能登陆CDR，随时随地开展工作。
CAPTRUE屏幕捕获工具：轻松一键从计算机屏幕上捕捉图像，包括整个屏幕、单个窗口或菜单列表。
AfterShot 3 HDR原始照片编辑器：为 RAW 或 JPEG 照片进行专业级矫正和强化。
CorelDRAW 2022版延续并加强以往的传统，通过一整套专业的图形程序，让您在设计路上无往不利，轻松地转换各个工具。
这些新增的功能，在CorelDRAW中文官网上都能找到专业的文字和视频教程，保证您能够熟练地掌握每一种功能、运用每一个程序；更有专家为您提供专业建议，优秀案例供您寻找灵感，是您平面设计的得力助手。
CorelDRAW2022简称cdr2022中文版，是加拿大Corel公司推出的专业矢量插图、布局和照片编辑工具，经历二十多年的发展与蜕变，也已经有了32个版本，能给设计师提供矢量动画、页面设计、网站制作、位图编辑和网页动画等多种功能，使用户可创作出多种富于动感的特殊效果及点阵图像即时效果在简单的操作中就可得到实现，并引入了强大的新版式引擎、多功能颜色和谐和样式工具、通过64位和多核支持改进的性能以及完整的自助设计网站工具，帮助专业设计师及绘图爱好者提供简报、彩页、手册、产品包装、标识、网页等资源，以此允许用户更加容易精确地创建物体的尺寸和位置，减少点击步骤，节省设计时间。
cdr2022安装教程
1、在我博客下载解压获得coreldraw2022完整64位；
2、双击“CorelDRAW Graphics Suite 2022 V22.0.0.412 完整64位”开始安装，点击“允许程序所有操作”；
3、默认注册完成，点击下一步；
4、选择安装选项，这里小编已自定义安装为例；
5、选择您想要安装的程序；
6、选择您想要安装的程序功能；
7、选择文件安装路径；
8、正在安装，请稍等；
9、提示安装完成，点击桌面快捷方式运行软件即可；
10、以上即coreldraw2022的全部安装过程，希望能对您有所帮助！
直接复制粘贴地址下载即可绿色安装2022：
CDR最新win版下载：
https://wm.makeding.com/iclk/?zoneid=41581
CDR最新mac版下载：
https://wm.makeding.com/iclk/?zoneid=42701
X8版本详情查询：
https://blog.csdn.net/CaiHuaZeiPoJie/article/details/107589634
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b87fec1ce5c826d3c530023310509675/" rel="bookmark">
			K8S实战笔记--1（k8s安装 &#43; kuboard安装 &#43; Devops迁移ECS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 引言 在DevOps实战笔记–3，我们介绍了使用Jenkins流水线任务进行项目的自动化CI/CD，借助pipeline脚本(Jenkinsfile)可以方便地对项目进行统一的配置管理，并且将Jenkinsfile 存放在Gitlab中以便于后期维护。同时，我们对于K8S也有了初步的了解，限于实验机器的硬件条件，题主决定采用外部云服务器进行K8S的相关实验。本篇将从采购阿里云ECS服务器开始，对K8S集群的搭建进行讲解。
1. 搭建K8S集群并配置集群管理工具 1.1 Kuboard简介 Kuboard是一个K8S的多集群管理界面，在Github开源。使用Kuboard提供了多种认证方式，在Kuboard可以使用内建用户库、gitlab / github 单点登录或者 LDAP 用户库进行认证，避免管理员将 ServiceAccount 的 Token 分发给普通用户而造成的麻烦。使用内建用户库时，管理员可以配置用户的密码策略、密码过期时间等安全设置。并且，通过Kuboard可以使用图形界面进行工作负载的编辑，使用户从繁琐的YML文件中解放出来。
更多详情请见：Kuboard官网
1.2 购置ECS云服务器 国内主流的ECS供应商有：阿里云、华为云、腾讯云等。
阿里云：官网详情
华为云：官网详情
腾讯云：官网详情
读者可以根据自身条件选择合适的云服务器供应商，本次实验以阿里云服务器为例，通过阅读Kuboard官网的Kubernetes安装文档，根据其要求的规格进行服务器采购，具体的服务器规格为：2核4G的服务器至少两台（需要至少一台作为主节点、一台作为从节点）、CPU 必须为 x86架构、支持的操作系统为CentOS 7.8、 CentOS 7.9或 Ubuntu 20.04。
购置完成后，从对应供应商的web控制台中查看已经创建好的实例，使用SSH服务利用公网IP对服务器进行远程连接（服务器默认开启22端口）。在远程连接服务器时，可能出现如下错误：No supported authentication methods available [preauth]。解决方法为：查看 /etc/ssh/sshd_config是否配置了参数PasswordAuthentication为no，将其改为yes后利用systemctl restart sshd重启SSH服务。
1.3 安装K8S集群并搭建集群管理工具 Kubernetes + Kuboard安装难度相对较低，在Kuboard官网中，我们可以详细查阅Kuboard的安装文档：《Kuboard安装手册》，对应此安装文档，可以完成对应版本kuboard的安装。查看Kuboard v3.x版本说明，对比Kuboard兼容性列表，观察到Kuboard v3对大多数Kubernetes版本都有支持。值得一提的是，最新版本的Kubernetes已经舍弃了Docker并使用了其他的容器技术，鉴于本实验更多侧重于Docker容器技术的使用，建议选择Kubernetes v1.19版本。
1.4 将CI/CD服务迁移至云服务器 现将如下服务流程迁移至云服务器：Gitlab -&gt; Jenkins -&gt; Sonarqube -&gt; Harbor，除此之外，需要的支撑服务为：jdk + maven + docker等。
迁移CI/CD的工作流程为：
进行jdk + maven的安装，将其加入环境变量，运行source profile使配置生效，更改MAVEN_HOME/conf下的settings.xml文件，在其中配置国内镜像加速地址，并修改原有jdk编译插件为1.8版本。
在创建ECS实例时，若未选择在实例中添加自定义docker镜像，可选择手动安装docker。在使用docker20.10.9及以下版本时，经docker-compose命令创建并运行容器时可能出现线程创建错误，将docker升级后解决。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b87fec1ce5c826d3c530023310509675/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9074af8ea0919676b085433e33783532/" rel="bookmark">
			Springboot-MyBatis配置-配置端口号与服务路径(idea社区版2023.1.4&#43;apache-maven-3.9.3-bin)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
MyBatis的Maven包
application.properties配置文件位置
项目结构层次
编码过程
1、model/Users.java
2、dao/UsersMapper.java
3、resources/mapper/UsersMapper.xml
4、service/UsersService.java
5、serviceimpl/UsersServiceImpl.java
6、controller/UsersController.java
7、Action.java
启动校验
总结
承接上文：Springboot快速搭建跨域API接口(idea社区版2023.1.4+apache-maven-3.9.3-bin)_红目香薰的博客-CSDN博客
MyBatis的Maven包 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Web支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- JDBC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 集成MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9074af8ea0919676b085433e33783532/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cafc0de27d4c941d88c2b13dfc5e4bf/" rel="bookmark">
			线程的join和yield
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、线程的join 主要作用是同步，它可以使得线程之间的并行执行变为串行执行。在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。调用这个方法的线程将被阻塞，即A进入阻塞状态。
- 方法join(long)的功能在内部是使用wait(long)方法来实现的，所以join(long)方法具有释放锁的特点。但是sleep(long)不释放锁。
现有T1、T2、T3三个线程，怎样保证T2在T1执行完后执行，T3在T2执行完后执行
package com.yan2; //现有T1、T2、T3三个线程，怎样保证T2在T1执行完后执行，T3在T2执行完后执行 public class Test41 { public static void main(String[] args) { Thread t1=new Thread() { @Override public void run() { System.out.println(Thread.currentThread().getName()+" begin..."); System.out.println(Thread.currentThread().getName()+" end..."); } }; Thread t2=new Thread() { @Override public void run() { try { t1.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+" begin..."); System.out.println(Thread.currentThread().getName()+" end..."); } }; Thread t3=new Thread() { @Override public void run() { try { t2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cafc0de27d4c941d88c2b13dfc5e4bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57d87f2a99753b5c33b560d72d40ccec/" rel="bookmark">
			Python基础知识-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注释的使用 #表示的是一个注释 print("hello world") 常见的数据类型 数字类型： 整数型int print(10) 浮点型float print(3.1415) 复数complex print((-1)**0.5) 字符串类型 布尔型 列表型/数组型 ['aa','bb'] 字典类型 {'name':"lhh",'user':'秦始皇'} 元祖型 （1,2,3,552,3,4,5） 集合类型 {9,'hello',true,'good'} 查看数据类型 a = (-1)**0.5 b = 2**2 print(a,b) print(type(a)) print(isinstance(c,str)) #Ture 不同进制数据的表示方式 a = 98 #十进制 b = 0b0101010101 #二进制 c = 0o23 #八进制 d = 0x1134 #十六进制 循环语句 import random tempNum = int(input('请输入指定数字:')) secret = random.randint(1, 10) print(secret) while tempNum != secret: temp = int(input("猜错啦！请重新输入：")) if temp &gt; secret: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57d87f2a99753b5c33b560d72d40ccec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ba8a6887835b0f8fc5cfffe18fff3b6/" rel="bookmark">
			【CS61B】 课后练习 HW 0: A Java Crash Course
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Exercise 1a: Drawing a TriangleExercise 1b: DrawTriangleExcercise2Exercise 3Exercise 4 Exercise 1a: Drawing a Triangle public class TriangleDrawer { public static void main(String[] args) { int i=1; while(i&lt;=5){ int cnt=i; while(cnt&gt;0){ System.out.print('*'); cnt--; } System.out.println(); i++; } } } Exercise 1b: DrawTriangle public class TriangleDrawer { public static void drawTriangle(int N) { int i=1; while(N&gt;0){ int cnt=i; while(cnt&gt;0){ System.out.print('*'); cnt--; } System.out.println(); N--; i++; } } public static void main(String[] args) { drawTriangle(5); } } Excercise2 public class ClassNameHere { public static int max(int[] m) { int len=m.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ba8a6887835b0f8fc5cfffe18fff3b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed258ea752640021ec6bedd058c1f37c/" rel="bookmark">
			cdr x4检测显示软件产品已被禁用警告弹窗，如何解决教程分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		偶尔翻开移动硬盘，找到这货，CorelDraw X4简体中文正式版。网上现在比较难下载得到了，X4是我最常用的一个。现在把它分享出来，有需要的可以去下载使用。
orelDRAW X4打开显示被禁用！这个是解决方法很简单！
解决方法：
首先，卸载原来的CorelDRAW X4；
把存在电脑里的盗版CDR清除掉，安装最新版，即可使用。
这个是完整安装版，，安装好直接就可以使用了。
安装方法，解压，运行autorun.exe，选CorelDRAW安装即可。
安装完提示：产品安装不成功，请重新安装（错误24），请下载此补丁：下载，DR14.dta文件换掉原有程序 …\CorelDRAW X4\Programs 目录下的DR14.dta文件。原有程序目录查看方式: 有软件图标上右键,看快捷方式中的目标位置。
CorelDraw X4更新2020简体中文正式版下载地址：
WIN版本下载：http://wm.makeding.com/iclk/?zoneid=33861
MAC版本下载：http://wm.makeding.com/iclk/?zoneid=33862
2020版更新内容详情：
https://blog.csdn.net/CaiHuaZeiPoJie/article/details/105992542
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77d8b2f58c7aa6a13ff2f110bb4b9947/" rel="bookmark">
			CorelDRAW x4提示非法软件产品被禁用解决方法教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说起PS大部分人都有所耳闻，甚至会一些简单的操作。但是CDR x4这名字相信有很多人就很陌生了，所以在这里也很有必要先说一下CDR到底是个什么样的存在。
CDR全名CorelDRAW ，是加拿大Corel公司出品的矢量图形制作工具软件，这个图形工具给设计师提供了矢量动画、页面设计、网站制作、位图编辑和网页动画等多种功能，它跟PS最大的区别就是PS通常用来处理制作位图，它用来绘制矢量图，而矢量图不失真的特点也深受设计师的喜爱，然而对于想学这款软件的个人而言，它的价格也无疑高的离谱，官方税前售价竟然在8000RMB左右。
CDR作为成名杰作，Corel公司对于它的盗版打击力度无疑也是非常的大，很多朋友下载破解版或者用注册机注册以后只要电脑联网，很快就会被官方检测出来变为30天试用期的评估版，对于此种情况小编也是做了多种努力却也毫无作用，也是一次偶然的机会在这款软件的交流群群中有人提到了这种方法，经多多次的查找相关内容和实验最终破解成功，到目前为止都没有被官方检测出来，下面就把这种方法分享给大家。
这种方法大家都称为卸载再次安装法:将CDR官方检测盗版，把存在电脑里的CDR清除安装最新版即可使用。
分享最新版地址：
WIN版本下载：http://wm.makeding.com/iclk/?zoneid=33861
MAC版本下载：http://wm.makeding.com/iclk/?zoneid=33862
2020版更新详情：
https://blog.csdn.net/CaiHuaZeiPoJie/article/details/105992542
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1723faffb51110369eb5cbc63a6e3643/" rel="bookmark">
			MathType7应用中文版特色功能介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MathType 是由美国Design Science公司开发的功能强大的数学公式编辑器，它同时支持Windows和Macintosh 操作系统，与常见的文字处理软件和演示程序配合使用，能够在各种文档中加入复杂的数学公式和符号。2021年11月1日，MathType升级到MathType 6.9简体中文版。 实现了“所见即所得”的工作模式，可以将编辑好的公式保存成多种图片格式或透明图片模式，可以很方便的添加或移除符号、表达式等模板（只需要简单地用鼠标拖进拖出即可)，也可以很方便地修改模板。
MathType 实现“所见即所得”的工作模式，是一个强大的数学公式编辑器。它可以将编辑好的公式保存成多种图片格式或透明图片模式，可以很方便的添加或移除符号、表达式等模板（只需要简单地用鼠标拖进拖出即可)，也可以很方便地修改模板。MathType公式编辑器软件主要使用用户为初中、高中以及大学的学生、老师，理科专业工作者，可用于编辑数学试卷、书籍、报刊、论文、幻灯演示等方面，是编辑数学、物理公式资料的必备工具。
MathType 6.9简体中文版新特性：
兼容Windows 8；
兼容Microsoft Office 2013；
MathPage技术进一步改善；
兼容800个以上的应用程序和网站。
综上，Mathtype公式编辑器可能更容易让大家接受，也是目前用户相当多的一款公式编辑器软件，其用户主要为初中、高中以及大学的学生、老师，理科、工科专业工作者，可用于编辑数理化试卷、书籍、报刊、论文、幻灯演示等方面，是编辑数理化公式资料的必备神器。小编今天就给大家介绍下这款工具。
MathType主要优势：
Euclid字体设置了几百个数学符号；
具有应用于几何、化学及其他方面的新样板和符号；
专业的颜色支持；
为全球广域网创建公式。
将输出公式译成其他语言(例如：TeX、AMS-TeX、LaTeX、MathML及自定义语言)的翻译器。
用于公式编号、格式设置及转换Microsoft Word文档的专用命令。
可自定义的工具栏，可容纳最近使用过的几百个符号、表达式和公式。
可自定义的键盘快捷键。
在编辑公式这个方面来说，MathType是使用最多的一个工具，因为它操作简单，不需要复杂的学习过程就可以很快地掌握操作技巧，并且功能也比Office自带的公式编辑器完善很多，可以对公式进行批量修改、编号等一系列的排版操作，所以它被越来越多的人群来使用。
目前市面上流传的MathType破解版都是英文的， 对于英文比较好的人来说这个没有问题，但是还有相当多的一些用户对英文是不感冒的，因此非常不方便!
所以建议大家还是使用最新的MathyType版本。除了兼容性之外，MathType 在其它一些功能方面也不如MathType 完善，但是对于简单的编辑公式是没有问题。
简要介绍MathType在Word中使用：
1.支持Word办公
Office Web Apps、移动Office和Office RT：上述软件不可以编辑MathType公式，但是可以显示和打印在其他Office版本上已经建立的公式。32和64位的Office：MathType 最新版本完完全全兼容上述软件。
2：插入公式：不管是否有公式编号，Word功能区的MathType选项卡都可以轻松插入公式。
3.在文档中更改公式的字体和格式
MathType在Word中增加了自己的菜单栏，涵盖了很多有用的命令。公式格式就是其中之一，它允许你更改文档中所有公式的字体和样式。
4.内联编辑公式或独立的窗口编辑公式
两种编辑模式：MathType允许像其他公式编辑器一样编辑内联公式，也可以在独立的窗口编辑。多个缩放级别：在一个正常缩放级别的Word文档中编辑公式的时候很难识别小的下标、上标和重音符号。例如，文档在正常缩放级别工作，但是你可以在MathType 400%的缩放比例下编辑公式。
5.在Word里使用键盘输入公式
在Word文档窗口只使用键盘来输入公式：MathType在Word加入了键盘快捷键，这样只需敲击一下键盘就可以插入一个新的公式或者编辑现有的公式。
用Tex直接输入公式到Word中：你可以直接在Word中直接打出Tex代码，当你输入完成后，按下Alt+\（转换Tex）来将它转换成MathType中的公式。随后，如果你想编辑公式的Tex代码，只需要再次按下Alt+\。
6.公式编号
插入公式编号：在您公式的左边或右边插入章、节或公式编号，如果后来您在文档中间插入一个新的公式，文档中的的所有公式都将自动重新编号。
公式编号格式：可以自定义更改公式编号的格式，应用于章、节或公式编号。
7.在文档中查看所有公式和公式编号
拓展Word的浏览特色：您可以用MathType的公式浏览器去查看文档中所有的公式或者检查所有公式编号和参数的连续性。
1.安装过程
首先去下载最新版程序的安装包，与其它软件安装时要附带一堆不必要的安装包不一样，也没有复杂的安装过程，需要这样那样的操作，直接进行傻瓜式的“下一步”直到安装成功，整个过程只需要几分钟的时间，安装过程十分简单。（末尾我会分享最新绿色直装版安装包）
2.开启工具
打开我们需要编辑公式的文档（用Office或WPS均可），点击菜单栏的插入按钮并选择对象，在弹出的对象选择框中，选择前面我们按照步骤安装完成的MathType.0Equation并点击确定即可。
3.简洁实用的编辑界面
打开MathType公式编辑器，就进入到它的编辑界面。在这个编辑界面，你可以一目了然的看到符号面板中的一些符号与模板，这些符号与模板都是我们常用的，没有复杂的操作，没有眼花缭乱的修饰图标，直接一眼望穿。
4.快速的上手过程
和其它工具不一样，需要一个繁琐系统的学习时间，你只要能够打开MathType编辑器，你就会使用它，几乎完全不需要过渡学习的时间。由于MathType是所见即所得的工作模式，你只要点击了MathType工具栏中的符号或者模板，你就可以在编辑区域中看到这些符号和模板是不是你的需要。可以说，只要你知道你的公式长什么样，你就能在MathType中将它编辑出来并分类保存。
好了，小编今天就介绍到这里，总之这款软件方便快捷，占用内存小，用法简单，画面简约。只有你不知道的公式，没有它输入不上的公式，不只有数学公式，还有物理公式，只要你想在word中插入公式，用MathType就能轻松搞定。如果你还不知道下载最新版软件，直接点击下面链接在线安装最新版，或对这款软件有什么疑问，欢迎到评论区留言。
MathType Win下载如下:
https://wm.makeding.com/iclk/?zoneid=34223
MathType Mac下载如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1723faffb51110369eb5cbc63a6e3643/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/788b5cb055e188b6e8d3087a6ddea795/" rel="bookmark">
			coreldraw2022直装版下载 永久免费使用 附安装教程（ 仅限 win 10 用户 ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CorelDRAW2022又被大家伙简称为cdr2022，这是由加拿大Corel公司制作推出的一款老牌图形平面设计软件，当然虽然该软件是好早之前就有了，但是本次小编要介绍的是该系列最新的2022版本。
在该版本中依然为各领域的广大设计师们提供了矢量动画、对象控制、页面设计、页面排版、网站制作、字体管理、位图编辑、网页动画、工作空间自定义等多种功能，十分强大。不过需要注意的是，该软件虽然功能丰富全面，但是简单的说其实就是图像编辑和矢量图及页面设计两大块功能，接着再详细延续出了许许多多小功能来供用户使用制作图像。
像如果你要在cdr2022软件中编辑图像，只需直接导入开始编辑即可，同时丝毫无需担心在编辑的过程中会破坏原始图像或对象，而且还能使用软件中的人工智能技术来快速的提高图像的大小和质量，并还能利用AfterShot 3 HDR 从原始图像创建惊人的高动态范围照片。
另外，经过几十个版本的发展，在本次全新的cdr2022中依旧是为用户们带来了不少的新功能哦，同时与上个版本相比，可是带来了不少的新功能，不仅新增了绘制透视图、协作工作流、注释泊坞窗、协作登录等新功能，还新增了灵活的设计空间、取样选项、伪影移除、艺术样式、位图效果透镜、渐进式图像编辑等特点，总体而言，在该版本中可更好的为用户提供强大省时的协作功能，这样就能有效的加快团队合作，提升工作效率，随心所欲的按照自己想法进行设计获取作品。
CDR安装教程
自己选择下载到电脑那个盘（尽量别选C盘，C盘是系统盘）
第1步：把解压CDR2021文件（我是选择我电脑里的W盘）
第2步：打开安装包，点开setup文件夹，找到Setup这个文件，然后右键以管理员方式打开，即可安装。（看好图片里文件，别选错了）
第3步：输入序列号(CD24R49-CDR5Q44-CDRZVCX-CDRJA88)
第4步：选择自定义安装
第5步：选择自己要用的，默认全选
第6步：重点☆ 之前装过CDR，就把 √ 取消！
第7步：修改安装位置，只改第一个首字母就可以！（我这里是装在W盘，我就把C改成W）
第8步: 安装完成后，直接关闭软件！重点☆ 别点同意！
第9步：打开补丁文件夹，打开操作教程，复制路径，找到文件夹！
第10步：把补丁 复制到打开的这个文件夹中，替换！
第11步：设置防警告，打开 安装完成后必设置 文件夹，打开教程
第12步：复制路径，删除文件夹内容
最后该软件就安装可以使用了!
mac直装安装包下载后在更新即可 :
https://wm.makeding.com/iclk/?zoneid=42701
win直装安装包下载后在更新即可 :
https://wm.makeding.com/iclk/?zoneid=41581
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/60/">«</a>
	<span class="pagination__item pagination__item--current">61/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/62/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>