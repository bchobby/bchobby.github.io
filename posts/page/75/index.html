<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3d587d54df39c94085768ae8cb68ecf/" rel="bookmark">
			向量数据库：使用Elasticsearch实现向量数据存储与搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		向量数据库：使用Elasticsearch实现向量数据存储与搜索 向量数据库：使用Elasticsearch实现向量数据存储与搜索一、简介二、实验前准备2.1 创建索引设置向量字段2.2 写入数据 三、向量计算函数3.1 余弦相似度：cosineSimilarity3.2 计算点积：dotProduct3.3 曼哈顿距离：l1norm3.4 欧几里得距离：l2norm3.5 自定义计算函数 Here’s the table of contents:
向量数据库：使用Elasticsearch实现向量数据存储与搜索 一、简介 Elasticsearch在7.x的版本中支持 向量检索 。在向量函数的计算过程中，会对所有匹配的文档进行线性扫描。因此，查询预计时间会随着匹配文档的数量线性增长。出于这个原因，建议使用查询参数来限制匹配文档的数量（类似二次查找的逻辑，先使用match query检索到相关文档，然后使用向量函数计算文档相关度）。
访问dense_vector的推荐方法是通过cosinessimilarity, dotProduct, 1norm或l2norm函数。但是需要注意，每个DSL脚本只能调用这些函数一次。例如，不要在循环中使用这些函数来计算文档向量和多个其他向量之间的相似性。如果需要该功能，可以通过直接访问向量值来重新实现这些函数。
二、实验前准备 2.1 创建索引设置向量字段 创建一个支持向量检索的mapping，字段类型为dense_vector。
// 7.x 支持的 dims 最大为 1024。 PUT index3 { "mappings": { "properties": { "my_vector": { "type": "dense_vector", "dims": 3 }, "my_text" : { "type" : "keyword" } } } } 2.2 写入数据 PUT index3/_doc/1 { "my_text" : "text1", "my_vector" : [0.5, 10, 6] } PUT index3/_doc/2 { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3d587d54df39c94085768ae8cb68ecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a76f7882d36e32899ce8fa6b7ab848f5/" rel="bookmark">
			Vm挂载虚拟硬盘（手把手教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：下面还有一些知识的补充 一；前置工作 首先，打开我们的Vm，右击我们要测试的系统，点击设置
然后我们点击添加， 我这里之前已经添加了一块5G的虚拟硬盘
在这里默认选择，硬盘，一直下一步
使用物理硬盘：需要一个真实的硬盘去匹配
使用现有虚拟硬盘：对已经创建过的虚拟硬盘进行配置
因为我们没有真实的物理硬盘所以不需要选择第三个，如果有可以选择，既然我们要添加新的虚拟硬盘那就选择第一个。
在这里选择你要挂载的磁盘容量随你选择，我这里选的是5G
然后直接点击完成，（如果你是开着系统配置的，请重启系统，让配置生效）
然后我们直接su - 输入root用户密码切换到管理员模式，然后输入命令ls -l /dev/sdb，原来的那块磁盘叫sda，那你们应该知道挂载的第三块磁盘叫啥了吧！/sdc
二；分区 我们先来看看我们刚刚创建的虚拟磁盘
使用fdisk -l命令（关于fdisk 命令及参数下面有补充）
然后，我们找到这里，sda是我们原有的磁盘，sdb是我们要挂载的磁盘，那么为什么sda下有三个区呢？那是因为别人已经分好区了。待会sdb也会变成这样。我们接着来看，sdb是不是我们刚规定的5G容量，是的
我们现在来开始对sdb分区，输入 fdisk /dev/sdb,(Fdisk是微软公司在DOS和Windows操作系统中自带的分区软件，该软件性能最稳定、兼容性好，但不支持无损分区，分区时会损坏硬盘上的数据，分区速度很慢，而且不能很好地支持大容量的硬盘分区)
输入n创建分区，然后再选择创建主分区p，还是扩展分区e，这里默认是创建主分区p，然后给你要创建的分区编号，默认1从开始，（到4结束，在这里采用的是MBR的分区模式，所以只能创建4个主分区，且容量不可以大于2TB）然后要你给定分区的容量，我这里是给了500MB，然后我们再键入p命令，查看分区信息，结果我们可以看到，我们创建的主分区sdb1
已经分好区了，至于创建扩展分区，我们直接如法炮制就好，只是那个地方我们要选e
然后我创建了一个主分区和一个扩展分区
三；高级硬盘格式化 我这里之前就已经对/dev/sdb1进行过格式化了，所以不用再格式化了，如果想再次格式化就再键入f命令（不建议），既然已经格式化，那么我们直接挂载就好，mkfs.xfs的意思是创建一个xfs格式的文件系统在sdb1分区中
四；挂载 挂载创建的虚拟硬盘的扇区
我们开始挂载刚刚创建的一个文件shijian 然后df -h 查看一下分区信息这里我们可以看到我们挂载的/media/shijian，但是这里我们还只是临时挂载，系统重启之后就会消失的，要想永久挂载，还要键入vim /etc/fstab 去修改启动文件
五；永久挂载 后面我们来试一下永久挂载，注意：写错之后就无法进入桌面系统了，所以用Vm同学记得打个快照，没有特殊要求就按这样写就好，但分区格式你用的是那个就是哪个，我用的是xfs，你可能用的是ext2啥的。（首先按i插入，然后写完之后esc退出，按住shift+：，键入wq，保存并且退出）
然后我们重启系统，一般没报错，就表示成功了（退出后键入reboot命令重启），重启之后，我们发现，我们的挂载还在，就说明挂载成功了。
注：讲到这里，大家可能对磁盘挂载的理论知识比较蒙，大家可以看一下我的这一篇博客对Linux挂载策略有讲解！
https://blog.csdn.net/weixin_64972949/article/details/130978747?spm=1001.2014.3001.5502
补充： 硬盘格式化分为硬盘低级格式化、硬盘分区、硬盘高级格式化。
① 硬盘低级格式化。主要是对一个新硬盘划分磁道和扇区,通常硬盘低级格式化只做一次,多次进行低级格式化将损害硬盘。
② 硬盘分区。把硬盘划分为成若干个相对独立的逻辑分区,每个分区有自己的名字,即硬盘标识符(如C:、D:等),操作系统通过硬盘标识符访问硬盘。
③ 硬盘高级格式化。硬盘建立分区后,使用前必须对每个分区进行高级格式化。高级格式化主要是对指定的硬盘分区进行初始化,建立文件分配表以便系统按指定格式存储文件。
fdisk命令中的参数以及作用
m 查看全部可用的参数
n 添加新的分区
d 删除某个分区信息
l 列出所有可用的分区类型
t 改变某个分区的类型
p 查看分区表信息
w 保存并退出
q 不保存直接退出
p来查看硬盘设备内已有的分区信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a76f7882d36e32899ce8fa6b7ab848f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e12a83b6dd96002c45385dd8741744bc/" rel="bookmark">
			Python按照类划分文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		采用的是Cars-196数据集
文件目录
cars：
-car_ims（里面全是图片）
-cars_annos.mat（标签文件）
from scipy.io import loadmat import os import shutil basepath = r"D:\A_Datasets\cars" # get image list annos = loadmat(os.path.join(basepath, 'cars_annos.mat'), squeeze_me=True)['annotations'] kind = 'test' zeroshot=True imlbs = [] for entry in annos: label = int(entry[5]) istrain = bool(entry[6]) if zeroshot: istrain = True if (label &lt;= 98) else False if (istrain and kind == 'test') or ( not istrain and kind == 'train'): continue imlbs.append(( os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e12a83b6dd96002c45385dd8741744bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/979861d7c6dc949ad119c638215c69f0/" rel="bookmark">
			r语言在用R的ggplot2包的barplot函数绘制条形图，把有效位数缩减为2或3位么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例如，以下代码将y轴的比例尺四舍五入到小数点后两位，并将x轴的比例尺四舍五入到小数点后三位：
library(ggplot2) library(scales) # 生成示例数据 data &lt;- data.frame(category = c("A", "B", "C", "D"), value = c(100000, 200000, 300000, 400000)) # 绘制条形图 ggplot(data, aes(x = category, y = value)) + geom_bar(stat = "identity") + scale_y_continuous(labels = comma_format( thousands = ",.2f" )) + # 四舍五入到小数点后两位，并使用逗号分隔千位 scale_x_continuous(labels = comma_format( thousands = ",.3f" )) + # 四舍五入到小数点后三位，并使用逗号分隔千位 labs(title = "条形图") 在上面的代码中，我们使用了comma_format()函数来格式化数字，将千位用逗号分隔，同时在scale_y_continuous()和scale_x_continuous()函数中使用了.2和.3来指定数字舍入的位数。这将使图例中的数字看起来更加清晰易读。
什么是r语言：R语言是一种用于统计分析、绘图的语言和操作环境，是属于GNU系统的一个自由、免费、开源的软件。它是一个用于统计计算和统计制图的优秀工具，可用于分析数据、制作图表、机器学习、数据挖掘等。R语言拥有广泛的统计和图形方法目录，包括机器学习算法、线性回归、时间序列、统计推理等，可帮助用户完成多个任务。虽然R语言是为数学研究工作者设计的一种数学编程语言，但同样适合于统计分析、绘图、数据挖掘等领域。与C语言不同，R语言主要面向数学研究工作者，但同样可以在多种操作系统上使用，包括Windows、Linux、macOS等。R语言的语法来自于Scheme，但与Scheme不同的是，R语言更加强调面向数学研究工作者的应用，因此具有更多的数学函数和统计方法。
以下是使用R的ggplot2包中的barplot函数绘制条形图的简单示例代码：
library(ggplot2) # 创建数据框 data &lt;- data.frame( group = c("A", "B", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/979861d7c6dc949ad119c638215c69f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a002a13dab1f817d4d25c04cbf38acc/" rel="bookmark">
			C&#43;&#43; MFC 获取当前运行程序的路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取当前运行程序的路径
获取当前进程已加载模块的文件的完整路径，该模块必须由当前进程加载
如果想要获取另一个已加载模块的文件路径，可以使用GetModuleFileNameEx函数
CString CConnectSerialPortDlg::GetPathFile() { CString str = _T("BasicInfo.ini"); TCHAR tcPath[MAX_PATH] = {0}; ::GetModuleFileName(AfxGetInstanceHandle(), tcPath, MAX_PATH*sizeof(TCHAR)); PathRemoveFileSpec(tcPath); CString strPath; strPath.Format(_T("%s"),tcPath); CString strFileName = strPath + "\\" + str; return strFileName; } **************************************************************************************************************
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4167729ea2d1ec124b1007522b71c613/" rel="bookmark">
			Kali Linux上安装OpenVAS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在Kali Linux上安装OpenVAS，请按照以下步骤操作：
打开终端并输入以下命令以更新Kali Linux：
sudo apt-get update &amp;&amp; sudo apt-get upgrade -y 安装OpenVAS：
sudo apt-get install openvas 初始化OpenVAS：
sudo openvas-setup 此命令将引导您完成设置过程。完成后，可以使用以下命令启动OpenVAS：
sudo systemctl start openvas-scanner.service sudo systemctl start openvas-manager.service sudo systemctl start openvas-gsa.service 打开Web界面：
在浏览器中输入以下URL：
https://localhost:9392 您应该能够看到OpenVAS的登录页面。输入用户名和密码进行登录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b03397663f13f246ccdf615ce90f046/" rel="bookmark">
			UnicodeDecodeError: ‘utf-8‘ codec can‘t decode byte 0xb4...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xb4 in position 10: invalid start byte
原因：中文字符的Unicode编码0x0800-0xFFFF之间,(utf-8包含了部分汉字)
当你试图将该“中文字符”转成U码的utf-8时超出了其范筹.而GBK 规范收录了 ISO 10646.1 中的全部 CJK 汉字和符号，并有所补充
解决方法：将.decode(‘utf-8’)改为.decode(‘gbk’)
#fp = open('data.txt','r+',encoding='UTF-8') fp = open('data.txt','r+',encoding='gbk') lines = [] for line in fp: line = line.strip() lines.append(line) fp.close() lines.insert(6, '渣渣猫') lines = str(lines) s = "\n".join(lines) fp = open('data.txt', 'w') fp.write(s) fp.close() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a080547b78465bd229a81340dbfc4c44/" rel="bookmark">
			简单易学！使用 Node.js 编写爬虫，跟着教程一步步实现！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬虫是一种可以自动从网页上获取数据的程序，它可以帮助我们收集和分析各种有用的信息。在这篇文章中，我将向你展示如何用 node.js 来编写一个简单的爬虫，只需几步就可以实现。
1、安装 node.js 和 npm node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，它可以让我们在服务器端运行 JavaScript 代码。npm 是 node.js 的包管理器，它可以让我们方便地安装和管理各种 node.js 模块。
要安装 node.js 和 npm，你可以访问 https://nodejs.org/ 下载并安装最新版本的 node.js，它会自动包含 npm。你也可以使用其他方法来安装，具体可以参考 https://nodejs.org/en/download/package-manager/ 。
安装完成后，你可以在命令行中输入以下命令来检查是否安装成功：
bash node -v npm -v 如果能看到相应的版本号，说明你已经成功安装了 node.js 和 npm。
2、创建项目文件夹和文件 接下来，我们需要创建一个项目文件夹来存放我们的爬虫代码。你可以在任意位置创建一个文件夹，比如在桌面上创建一个叫做 crawler 的文件夹。
在这个文件夹中创建一个叫做 index.js 的文件，这个文件就是我们的爬虫主程序。你可以使用任意的文本编辑器来编写这个文件，比如 VS Code、Sublime Text、Notepad++ 等。
然后在这个文件夹中运行npm init初始化项目，按照提示输入一些项目的相关信息（可以一路回车），项目就算是搭建好啦
3、安装 request 和 cheerio 模块 为了让我们的爬虫能够发送 HTTP 请求和解析 HTML 文档，我们需要使用两个非常有用的 node.js 模块：request 和 cheerio。
request 是一个简单的 HTTP 客户端，它可以让我们方便地发送各种 HTTP 请求，并获取响应数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a080547b78465bd229a81340dbfc4c44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c371cefe717d92d4e39cf6b63aad02fd/" rel="bookmark">
			KEIL5.38 STM32新建工程core_cm3.h报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建工程，该做的都做了后，编译发现报错
网上找了很久，什么说法的都有，自己定义__INLINE的，都不行。
而且打开别人的工程，编译是正常的。
后面才发现别人的工程魔术棒里是ARM Compiler不一样
因为我自己装的版本是5.38比较新，多了一个新的编译器版本如下图
这样导致新的编译器和旧的core_cm3不兼容
把编译器从6降低到5，如下图
编译就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fe8c37b20ce40eb992e7f0d3ed9859d/" rel="bookmark">
			深入了解SAP S/4HANA信用管理：推荐SAP Press - Introducing Credit Management with SAP S/4HANA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Introducing Credit Management with SAP S/4HANA》首先介绍了信用管理在企业中的重要性以及其在财务和销售流程中的角色。接着，本书详细介绍了SAP S/4HANA平台上信用管理功能的关键概念、配置和集成。读者将了解如何设置信用检查规则、配置信用限额、处理异常情况以及使用信用管理报表和指标进行风险评估。
适合阅读的人群： 本书适合以下人群阅读：
金融和财务专业人员：无论您是财务经理、信用控制员还是风险管理人员，本书将为您提供信用管理的全面视角。通过深入了解SAP S/4HANA平台上的信用管理功能，您将能够优化信用决策流程、降低风险并提高收款效率。销售和客户服务专业人员：对于销售和客户服务团队而言，了解信用管理的重要性和工作原理至关重要。本书将帮助您理解信用检查的过程、信用限额的设置以及如何与客户进行沟通，从而提高订单的收款率和客户满意度。SAP顾问：对于SAP顾问而言，本书是提升在信用管理领域专业知识和技能的关键资源。通过学习本书，您将深入了解SAP S/4HANA平台上信用管理功能的配置和实施，并能够为客户提供定制化的信用管理解决方案，帮助企业实现可持续的财务控制和风险管理。 阅读这本书的好处：
掌握信用管理知识：通过阅读本书，您将全面了解SAP S/4HANA平台上的信用管理功能和配置选项。您将了解信用检查的原理、信用限额的设置方法以及如何处理信用冲突和异常情况。优化风险控制：信用管理是确保企业财务稳定和可持续发展的重要环节。通过掌握信用管理的最佳实践和工具，您将能够有效评估风险、制定风险控制策略，并提高企业的信用决策能力。提高客户满意度：良好的信用管理可以确保订单的及时处理和交付，从而提升客户满意度。通过本书所提供的指导，您将能够建立可靠的信用决策流程，提供准确的信用信息给销售团队，并加强与客户的沟通和合作。对SAP顾问的帮助：作为SAP顾问，掌握信用管理的知识和技能将增强您在咨询项目中的竞争力。您将能够为客户提供专业的信用管理解决方案，并根据最佳实践和配置选项进行定制化实施。这将提高您的咨询价值，并为客户提供持续的财务控制和风险管理支持。 SAP Press - Introducing Credit Management with SAP S/4HANA 是一本引人入胜的指南，为读者提供了深入了解SAP S/4HANA平台上信用管理的重要资源。无论您是财务专业人员、销售人员还是SAP顾问，本书都将成为您掌握信用管理的关键工具。通过阅读本书，您将学习信用管理的核心概念、功能和配置，并能够应用这些知识来优化财务风险控制、提高客户满意度和实现持续的业务增长。特别对于SAP顾问而言，本书将提升您在信用管理领域的专业知识和技能，使您能够为客户提供高质量的信用管理解决方案，并助其实现可持续的财务控制和风险管理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eda2494e1e1c50137a11822d7ac5f76/" rel="bookmark">
			SSM答辩面试题 V1.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSM答辩面试题 V1.0 文章目录 SSM答辩面试题 V1.0SSM面试题1. Maven项目依赖中作用范围 scope2. Maven项目之间的三种关系及其特征3. 如何理解框架framework4. 如何理解ORM5. MyBatis中#{}和${}的区别是什么？6. MyBatis中当实体类中的属性名和表中的字段名不一样，怎么办 ?7. MyBatis如何获取自动生成的(主)键值？如何完成MySQL的批量操作?8. 讲述下Mybatis的一级、二级缓存9. 简述Mybatis的动态SQL，列出常用的6个标签及作用。10. 描述下IoC依赖注入，有哪些方式11. 解释Spring自动装配的各种模式12. 说一下Spring中支持的bean作用域13. 解释Spring框架中bean的生命周期14. Spring中常用的设计模式15. 说下对Spring面向切面编程(AOP)的理解16. 说下Spring面向切面编程(AOP)的常用术语17. 请描述一下Spring 的声明式事务管理18. SpringMVC中如何实现请求域request中传递数据19. SpringMVC怎么样设定重定向和转发的20.说出Spring/SpringMVC常用的6个注解，并简单描述作用21. SpringMVC中如何实现Restful风格的数据传输和接收22.简述SpringMVC中如何通过Ajax请求返回JSON数据23.SpringMVC中拦截器和JavaEE中Filter的异同24. 简单的谈一下SpringMVC的工作流程25. 简单的谈一下SpringMVC的核心API26.说下==ContextLoaderListener==的作用 SSM面试题 孙小白de学习 此博客为新手学习进阶用途，有错误请大家指正
1. Maven项目依赖中作用范围 scope 当一个Maven工程添加了对某个jar包的依赖后，这个被依赖的jar包可以对应下面几个可选的范围，默认 是compile。
依赖范围编译(main)测试(test)部署示例compile √ √ √ log4j provided √ √ × servlet-api lomboktest × √ × junitruntime × √ √ JDBC驱动类system √ √ × 和provided相似，很少用import × × × 只能与dependencyManagement配合使用；学习SpringBoot时会使用 2. Maven项目之间的三种关系及其特征 依赖关系（兄弟关系、朋友关系）：
项目A依赖项目B，项目A可以访问项目B中某些依赖，避免重复提供 缺点：但是只有范围为compile时可以访问 继承关系（父子关系，并列关系）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eda2494e1e1c50137a11822d7ac5f76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40b38277e748790c2fcd8ae306a934fe/" rel="bookmark">
			static的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		static 修饰的静态局部变量：只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放，可以将此变量的值保存至下一次调用。
static 修饰全局变量：这个全局变量只能在本文件中访问，不能在其它文件中访问，加上extern 外部声明也不可以。
参考C/C++ 中 static 的用法全局变量与局部变量 | 菜鸟教程 (runoob.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b556f0b740f85fe6db9a90d2525878be/" rel="bookmark">
			vue3实现 下拉框触底加载更多及搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路 做一个全局指令
查询了大量文章 发现统一用的指令 来实现触底加载功能 实操中发现 在vu3 的版本中
（我这个项目中）无法通过自定义指令的形参 获取el-select-dropdown .el-select-dropdown__wrap 元素，所以通过el-select中的popper-class给下拉框加入一个类名 实现下拉框的选中，为了 方便指令通用 给el-select 加入自定义属性标签data-class 同popper-class值 ,方便获取到当前标签的popper-class
2、项目中的实际用法 在el-select 下再次封装
filtereMethod:自定义筛选的方法
popper-class：为当前select 下拉框的类名
data-class： 同popper-class值 是为了解决指令el参数无法获取到.el-select-dropdown .el-select-dropdown__wrap元素
v-selectLoadMore： 自定义指令
&lt;el-select v-model="ruleForm.userId" class="m-2" data-class="selectClass" placeholder="请选择" filterable :filter-method="filtereMethod" v-selectLoadMore="getUserList" popper-class="selectClass" &gt; &lt;el-option v-for="item in options" :key="item.userId" :label="item.nickname" :value="item.userId" /&gt; &lt;/el-select&gt; const userParams = reactive({ bindSupplier: "2", page: 0, pageSize: 10, nickname: "" }); // 用于终止加载 后端数据返回的当前列表的总页数 let totalPage = 1; const getUserList = async () =&gt; { if (userParams.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b556f0b740f85fe6db9a90d2525878be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fea481c88ee0ed371382de4e39d256d7/" rel="bookmark">
			Git已经在本地提交过文件了，但又给撤销了，恢复已经撤销的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Git，我已经在本地提交过文件了，也就是已经执行了git commit -m "xxx"，但提交完之后又给撤销了，撤销的还能回来嘛？
这种情况仍然有机会恢复它。撤销提交的方法取决于你撤销提交的方式。
说白了就是，只要执行了git commit -m "xxx"，就可以有权恢复代码，切记不要慌！ 如果你使用的是git reset命令来撤销提交，可以使用相同的命令来恢复提交。git reset命令会将当前分支指向你指定的提交，并将之前的提交从历史记录中移除
这里有几种撤销方式，只是给你列举一种方法，更多关于撤销可自行查找资料 通过使用git reflog命令，你可以查看过去的提交记录，找到之前被撤销的提交的哈希值。然后，使用git reset 命令，将分支指向被撤销的提交，从而恢复提交。
git reflog git reset &lt;commit-hash&gt; 在这块找到你提交过的文件，找到commit-id，这是你历史提交的文件
好了，你现在看已经恢复回来了，哈哈哈，胆战心惊一回，当然，这时候只是恢复到你本地了，你可以继续你的事情啦 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3afca53471bbd0f9abf907c74941a5d/" rel="bookmark">
			【Linux】（超详细步骤）使用LVM扩容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、LVM逻辑卷的创建 1、准备一个硬盘 可以是重新创建的也可以是已经创建好的：
这里使用已经创建好并且分区好的硬盘sdc；
2、将分区的类型改为 8e ①然后使用命令：fdisk /dev/sdc　让硬盘进入分区模式，进行更改类型；
②输入t，进行模式修改
③输入1，表示修改第一个分区的类型
④输入8e，表示将类型修改为8e
⑤输入p，查看修改结果
⑥全部修改完毕；
注意不能直接修改扩展分区的类型！
⑦记得输入w保存，会提示下一次重启时会生效
3、创建物理卷(PV) ①创建逻辑卷（将新添加的磁盘分区作为物理卷）
注意！！创建物理卷时该磁盘不能被挂载！！否则无法创建！！
注意！！创建物理卷时该磁盘不能被挂载！！否则无法创建！！可能会出现下面的情况
pvs查看物理卷大小 pvscan扫描物理卷 pvdisplay 查看详细信息
删除物理卷 pvremove /dev/sdb1
4、创建卷组(VG) 创建卷组：vgcreate volume-group1 /dev/sdb1 /dev/sdb2 /dev/sdb3（创建卷组其实就是将新磁盘所分好的区，按想想要的个数合并成一个“仓库”）
删除卷组：vgremove volume-group1
5、创建逻辑卷(LV) 创建一个名为'1v1'、大小为100MB的逻辑卷。我们使用小分区减少执行时间（基于物理卷组去划分的大小，大小不能超过物理卷的大小）
-L（逻辑卷大小）
-n（逻辑卷名字）
lvcreate -L 100M -n lv1 vg1
6、格式化和挂载逻辑卷 ①格式化逻辑卷 mkfs.xfs /dev/vg1/lv1 ②创建目录
mkdir /mnt/lv1_mount
③挂载逻辑卷
mount /dev/volume-group1/lv1 /lvm-mount/ lvremove删除逻辑卷：1.# umount /lvm-mount/
2. # lvremove /dev/volume-group1/lv1（ 先卸载再删除） ④查看结果 二、扩展一个LVM卷 扩展逻辑卷 在之前操作的基础上进行下面的操作
lvextend -L +200M /dev/vg1/lv1（最好有加号）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3afca53471bbd0f9abf907c74941a5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d120c8a34735600b68442f48c40089a/" rel="bookmark">
			利用c&#43;&#43;实现对指定的一维数组查找目标值的位置下标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt;
using namespace std;
int fun(int*arr,int start,int end,int target){
if(target&lt;arr[start]||target&gt;arr[end]||start&gt;end){
return -1;
}
int mid=(start+end)/2;
if(target==arr[mid]){
return mid;
}
else if(target&gt;arr[mid]){
return fun(arr,mid+1,end,target);
}
else if(target&lt;arr[mid]){
return fun(arr,start,mid-1,target);
}
}
int main(){
int arr[5]={12,455,23,67,8};
int n=sizeof(arr)/sizeof(arr[0]);
for(int i=0;i&lt;n-1;i++){
for(int j=0;j&lt;n-1-i;j++){
if(arr[j]&gt;arr[j+1]){
int temp=arr[j];
arr[j]=arr[j+1];
arr[j+1]=temp;
}
}
}
for(int m=0;m&lt;n;m++){
cout&lt;&lt;arr[m]&lt;&lt;"\t";
}
int a=0;
int b=4;
int t=23;
cout&lt;&lt;fun(arr,a,b,t);
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45be3379b5f2b9a698064df41f841819/" rel="bookmark">
			高频面试八股文原理篇(六) mysql数据库的左连接,右连接,内链接有何区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
内连接与外连接的区别
在sql中l外连接包括左连接（left join ）和右连接（right join），全外连接（full join），内连接(inner join)
内连接与外连接的区别 自连接
一个表与它自身进行连接，数据均在一张表中。
内连接 是多表联查的另一种书写形式，可以匹配出两张表中符合查询条件的数据，其中包含等值连接、非等值连接、自然连接。
等值连接
连接条件中使用“=”进行连接查询，结果集中包含重复列
非等值连接
连接条件中使用非=进行连接查询
自然连接
使用两表中的同名列进行等值连接查询（列名及列数据类型均一致，等值连接中不做列同名要求），结果集中去除重复列，是去除重复列的等值连接
外连接 主要分为左外连接、右外连接、全外连接
在sql中l外连接包括左连接（left join ）和右连接（right join），全外连接（full join），内连接(inner join) 左外连接（左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。
将返回右表的所有行。如果左表的某行在右表中没有匹配行，则将为右表返回空值。
以左表为主表，右表没数据为null
右外连接（右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。
将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值;
以右表为主表，左表中没数据的为null
全外连接(全连接)：返回左右表中所有的记录和左右表中连接字段相等的记录。
FULL JOIN 或 FULL OUTER JOIN
完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。
如果表之间有匹配行，则整个结果集行包含基表的数据值。
内连接
内连接则不要求两属性列同名，可以用using或on来指定某两列字段相同的连接条件。
Select * from table1 inner join table2 on table1.A=table2.E; 变型：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b24dafa9a08a32b1b4fb4c53ed321549/" rel="bookmark">
			STM32定时器输入捕获航模接收机信号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32定时器输入捕获航模接收机信号 前言一、舵机信号（PWM）二、STM32输入捕获功能框图三、输入捕获初始化结构体定义及说明三、代码 前言 最近在做一个检测航模接收机输出的舵机信号，并根据信号不同执行相应功能的小项目。硬件部分使用的是STM32F103C8T6通用定时器TIM3的通道1和通道2分别做两路信号的输入捕获（Input Capture）。
提示：以下是本篇文章正文内容，下面案例可供参考，如有错误，欢迎批评指正！
一、舵机信号（PWM） PWM就是脉冲宽度调制，也就是占空比可调的脉冲信号。航模接收机输出的舵机PWM信号一般是频率为50HZ即周期为20ms，信号的高电平时间在1000us-2000us之间变化的PWM波，并且当遥控器打到中位时，信号高电平时间为1500us，如下图所：
二、STM32输入捕获功能框图 STM32F103通用定时器输入捕获功能框图如下所示，主要包括捕获通道选择、滤波器设置、捕获极性设置、映射关系设置及分频器配置等部分。
三、输入捕获初始化结构体定义及说明 STM32标准库的stm32f10x_tim.h中定义了定时器输入捕获初始化结构体：
/** * @brief TIM Input Capture Init structure definition */ typedef struct { uint16_t TIM_Channel; /*!&lt; 输入通道选择，共4个通道。TIM_Channel_1-&gt;TIM_Channel_4 */ uint16_t TIM_ICPolarity; /*!&lt; 输入捕获极性设置，可选择上升沿捕获或下降沿捕获或两者都可捕获。 TIM_ICPolarity_Rising/TIM_ICPolarity_Falling/TIM_ICPolarity_BothEdge */ uint16_t TIM_ICSelection; /*!&lt; 输入捕获通道选择，共3个通道。 TIM_ICSelection_DirectTI/TIM_ICSelection_IndirectTI/TIM_ICSelection_TRC */ uint16_t TIM_ICPrescaler; /*!&lt; 输入捕获通道预分频。可设置分频因子为1、2、4、8*/ uint16_t TIM_ICFilter; /*!&lt; 输入捕获滤波器设置。可设置为0x00到0x0F，一般不用设置为0x00 */ } TIM_ICInitTypeDef; 三、代码 #include "drv_pwm.h" u8 TIM3_CHL1_CaptureFlag;	// TIM3 CH1捕获标志 u32 TIM3_CHL1_Rising_Value ;	// TIM3 CH1捕获上升沿值 u32 TIM3_CHL1_Falling_Value ;	// TIM3 CH1捕获下降沿值 u16 TIM3_CHL1_PWM1_pulse;	// TIM3 CH1捕获PWM脉宽数值 u8 TIM3_CHL2_CaptureFlag;	// TIM3 CH2捕获标志 u32 TIM3_CHL2_Rising_Value ;	// TIM3 CH2捕获上升沿值 u32 TIM3_CHL2_Falling_Value ;	// TIM3 CH2捕获下降沿值 u16 TIM3_CHL2_PWM1_pulse;	// TIM3 CH2捕获PWM脉宽数值 void drv_pwm_init(void) { GPIO_InitTypeDef GPIO_InitStruct; TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct; TIM_ICInitTypeDef TIM_ICInitStruct; NVIC_InitTypeDef NVIC_InitStruct; /* 打开GPIO时钟 */ RCC_APB2PeriphClockCmd(TIMX_PORT_CLK, ENABLE); /* 打开定时器时钟 */ RCC_APB1PeriphClockCmd(TIMX_CLK, ENABLE); /* 初始化PA6/PA7为下拉输入 */ GPIO_InitStruct.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b24dafa9a08a32b1b4fb4c53ed321549/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7bcc012fdf6e5f28dff2fdd36a2e152/" rel="bookmark">
			allure美化测试报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.allure下载安装
下载地址：https://repo.maven.apache.org/maven2/io/qameta/allure
下载下来安装包后，把安装包放到一个位置后配置环境变量
高级系统设置–环境变量–path中把allure包中bin的路径配置上
二.在python环境中安装相关库
在python环境中执行以下命令
pip install allure-pytest
pip install pytest
pip install pytest-html
pip install pytest-xdist
pip install pytest-ordering
pip install pytest-rerunfailures
三.生成报告命令
生成每条测试用例报告：
pytest -vs --alluredir=./result/report（./result/report 是测试报告存储位置）
生成整体测试报告：
allure serve ./result/report（./result/report 是测试报告存储位置）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3bc92af5d8276dc71d833c09d727422/" rel="bookmark">
			【20230531】Git命令和Github相关使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 在Git中缓存GitHub凭据 根据系统下载对应的GitHub CLI 2.25.1 2. github主页，点击用户头像选择settings-&gt;Developer Settings-&gt;Personal access tokens申请密钥（主要分为Fine-grained tokens和Tokens classic）gh需要使用的是Tokens classic。 (可以通过网页进行授权认证，所以不需要提前申请密钥）
命令行输入下面内容，按要求进行下一步即可。 gh auth login 2 配置 Git的设置文件为.gitconfig，它可以在用户主目录下(全局配置)，也可以在项目目录下(项目配置)。配置文件在用户目录下可以查看 eg. /home/lieryang/.gitconfig
# 显示当前的Git配置 git config --list # 编辑Git配置文件 git config -e [--global] # 设置提交代码时的用户信息 git config --global user.name "[name]" git config --global user.email "[email address]" # 代理设置 # socks git config --global http.proxy 'socks5://127.0.0.1:1080' git config --global https.proxy 'socks5://127.0.0.1:1080' # http git config --global http.proxy http://127.0.0.1:7890 git config --global https.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3bc92af5d8276dc71d833c09d727422/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ffc18d42138c904d6996305da346fcd/" rel="bookmark">
			访问者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 访问者模式1.访问者模式的本质2.何时选用访问者模式3.优缺点4.访问者模式的结构5.实现 访问者模式 1.访问者模式的本质 访问者模式的本质:预留通路，回调实现。
访问者模式的本质是将数据结构和数据操作分离，通过定义一个访问者对象，实现对数据结构中各个元素的访问和处理，从而达到解耦和灵活性的目的。
2.何时选用访问者模式 建议在以下情况中选用访问者模式。
当需要对一个复杂的数据结构进行操作，并且这些操作可能需要根据不同的元素类型进行变化时，可以考虑使用访问者模式。通过将具体操作封装在访问者对象中，可以在不改变数据结构的情况下，实现对不同元素的不同操作。
当需要在不同的数据结构中执行相似的操作，但不希望在数据结构中添加新的方法时，可以使用访问者模式。访问者模式可以将操作从数据结构中分离出来，使得操作可以独立变化，而不需要修改数据结构本身。
当数据结构中的元素种类相对稳定，但可能需要新增一些新的操作时，可以考虑使用访问者模式。通过定义新的访问者对象，可以在不修改现有元素类的情况下，对新增操作进行扩展。
当需要对数据结构中的元素进行多种操作，并且这些操作之间存在一定的关联或依赖关系时，可以使用访问者模式。访问者模式可以通过在访问者中保存中间结果或状态，实现多个操作之间的数据共享和协作。
3.优缺点 访问者模式有以下优点。
好的扩展性
能够在不修改对象结构中的元素的情况下,为对象结构中的元素添加新的功能。
好的复用性
可以通过访问者来定义整个对象结构通用的功能，从而提高复用程度。
分离无关行为
可以通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。
访问者模式有以下缺点。
对象结构变化很困难
不适用于对象结构中的类经常变化的情况，因为对象结构发生了改变，访问者的接口和访问者的实现都要发生相应的改变，代价太高。
破坏封装
访问者模式通常需要对象结构开放内部数据给访问者和ObjectStructrue，这破坏了对象的封装性。
4.访问者模式的结构 Visitor:访问者接口，为所有的访问者对象声明一个visit方法，用来代表为对象结构添加的功能，理论上可以代表任意的功能。ConcreteVisitor:具体的访问者实现对象，实现要真正被添加到对象结构中的功能。Element:抽象的元素对象，对象结构的顶层接口，定义接受访问的操作。ConcreteElement:具体元素对象，对象结构中具体的对象，也是被访问的对象，通常会回调访问者的真实功能，同时开放自身的数据供访问者使用。ObjectStructure:对象结构，通常包含多个被访问的对象，它可以遍历多个被访问的对象，也可以让访问者访问它的元素。可以是一个复合或是一个集合，如一个列表或无序集合。 5.实现 模拟大众公司生产油车和电车
销售人员关注油车和电车的价格质检人员关注油车和电车的油耗量和电耗量 1.大众汽车接口及其实现类
/** * @description:大众汽车 */ public interface Car { /** * 接受访问者的访问 * @param visitor 访问者对象 */ void accept(Visitor visitor); } /** * @description:大众辉腾（油车） */ @Data @AllArgsConstructor public class HuiTeng implements Car{ /** * 价格 */ private String price; /** * 油耗量 */ private String oilConsumption; @Override public void accept(Visitor visitor) { visitor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ffc18d42138c904d6996305da346fcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/679df735d13033be5a75fc55f5da492f/" rel="bookmark">
			PyEcharts 修改坐标轴颜色/图例字体颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 修改之前的图如下
修改之后的图如下
上代码
from pyecharts import options as opts from pyecharts.charts import Bar from pyecharts.faker import Faker c = ( Bar() .add_xaxis(Faker.choose()) .add_yaxis("商家A", Faker.values(), stack="stack1") .add_yaxis("商家B", Faker.values(), stack="stack1") .set_series_opts(label_opts=opts.LabelOpts(is_show=False)) .set_global_opts(title_opts=opts.TitleOpts(title="Bar-堆叠数据（全部）", ), xaxis_opts=opts.AxisOpts( axislabel_opts=opts.LabelOpts(color="red"), # 修改坐标轴标签颜色 axisline_opts=opts.AxisLineOpts(linestyle_opts=opts.LineStyleOpts(color="red")) # 修改坐标轴线条 ), legend_opts=opts.LegendOpts(textstyle_opts=opts.TextStyleOpts(color="red")) # 修改图例颜色 ) .render("1213.html") ) 其与原代码的区别在于在set_global_opts里添加了
xaxis_opts=opts.AxisOpts( axislabel_opts=opts.LabelOpts(color="red"), # 修改坐标轴标签颜色 axisline_opts=opts.AxisLineOpts(linestyle_opts=opts.LineStyleOpts(color="red")) # 修改坐标轴线条 ), legend_opts=opts.LegendOpts(textstyle_opts=opts.TextStyleOpts(color="red")) # 修改图例颜色 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71c9cb3650a2a24fda9322553ef8b668/" rel="bookmark">
			vuex内容及使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vuex是什么 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化
说起状态管理模式，就不得不提起一个名词——单向数据流。
单向数据流 在Vue中，数据的传输流动必须遵循单向数据流原则：父级 prop 的更新会向下流动到子组件中，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。
单向数据流有一个个人认为最容易理解的例子：props和( e m i t / emit/ emit/on)的组合。没错，就是和vuex 同为组件间通信方式之一的父子组件通信组合。
// 父组件 &lt;child :info="info" @clickButton="handleClickButon"/&gt; export default { data(){ return { info:{ name: 'muyu', age: 28 } } }, methods:{ handleClickButon (name) { this.info.name = name } } } // 子组件 &lt;div&gt; &lt;p&gt;{{info.name}}&lt;/p&gt; &lt;button @click="handleChangeName"&gt;修改&lt;/button&gt; &lt;/div&gt; export default { props:{ info: { type: Object, default: () =&gt; { name: '' } } }, methods: { handleChangeName () { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71c9cb3650a2a24fda9322553ef8b668/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c6f3605f02c30d12a64fc9cc882c2a2/" rel="bookmark">
			Centos7 搭建 Socks 服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博客园地址
Centos7 搭建 Socks 服务 一丶拿到一个动态拨号的服务器还不能使用网络得先打开： pppoe-start 二丶安装命令汇总： 通过yum安装ss5 依赖包： yum install gcc openldap-devel pam-devel openssl-devel 首先下载ss5（如果没有wget先安装：yum install wget）: （# 这个是一个日本大学的sourceforge镜像） wget http://jaist.dl.sourceforge.net/project/ss5/ss5/3.8.9-8/ss5-3.8.9-8.tar.gz 解压压缩包 tar -vzx -f ss5-3.8.9-8.tar.gz 进入解压目录 cd ss5-3.8.9/ configure是一个shell脚本 主要的作用是对即将安装的程序进行配置， 检查当前的环境是否满足要安装程序的依赖关系. 如果系统环境合适，就会生成makefile，否则会报错。 ./configure make是一个命令工具 解释 Makefile 中的规则。 Makefile文件中描述了整个工程所有文件的编译顺序、编译规则。 实际上make是执行Makefile中的第一条命令 执行Makefile中的install 这些都可以在Makefile文件中看到 可以使用vim Makefile查看文件 make &amp;&amp; make install ------------安装完成----------------- 启动ss5： service ss5 start 如果报错 权限不足 就改一下权限 再次启动就可以了： # a+x 给所有人加上可执行权限(所有者，所属组，其他) chmod a+x /etc/init.d/ss5 service ss5 start 目前为止只是安装上了ss5，也可以正常运行服务，但实际上代理服务还是用不了，需要配置一下文件。 vi /etc/opt/ss5/ss5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c6f3605f02c30d12a64fc9cc882c2a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b92c51417e5aabeaf34296dd9875791b/" rel="bookmark">
			RockyLinux9安装Zabbix6.0配置中文界面 中文方块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 CentOS即将停止维护，公司选择RockyLinux9作为替代。在安装zabbix时提示“You are not able to choose some of the languages, because locales for them are not installed on the web server.”。Zabbix6.0界面无法选择中文，通过安装语言包解决。顺便解决了zabbix6中文方块问题。
原因 rockyLinux9默认没有自带中文语言包。
相关查看命令如下：
localectl list-locales #查看系统默认已有的语言包 localectl #查看当前生效的语言包 localectl set-locale LANG="zh_CN.utf8" #修改当前生效语言包为中文zh_CN.utf8 解决 查找dnf源上可下载的其它语言包，并下载安装。
dnf list |grep glibc-langpack	#查看源上有哪些语言包 dnf list |grep glibc-langpack|grep zh #筛选出需要的中文语言包 dnf install glibc-langpack-zh #安装中文语言包 localectl set-locale LANG="zh_CN.utf8" #修改当前生效语言包为中文zh_CN.utf8 systemctl restart zabbix-server zabbix-agent httpd php-fpm #重启zabbix server相关服务 修改语言包不需要reboot操作系统，仅重启zabbix相关服务即可。再次登录zabbix web界面从左下方user settings处即可进行显示语言的修改。
其它 中文方块问题： 改语言包仅解决了整体页面的中文显示问题，具体监控项仍然存在中文方块乱码问题，需要下载中文字体解决。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b92c51417e5aabeaf34296dd9875791b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a2521ff165770bd841cb0e2d40074eb/" rel="bookmark">
			StreamFab Downloader通杀所有常见视频网站，支持Netflix、Disney&#43;1000网站下载视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		StreamFab Downloader 是 StreamFab 公司推出的一款流媒体下载器，其主要功能是从 Netflix、Disney+、Amazon 和 Hulu 等流媒体网站上下载视频和音频内容。
软件特点 支持多个流媒体网站：可以下载来自多个流媒体网站的视频和音频内容，如 Netflix、Disney+、Hulu、Amazon Prime Video 等。
高质量下载：支持下载高达 8K 分辨率的视频和音频内容。
多种输出格式：可以将下载的视频和音频文件转换为多种格式，如 MP4、MKV、AVI、MP3 等。
高速下载：支持 GPU 加速技术，下载速度快，节省时间。
批量下载：可以一次性下载整个系列或剧集。
用户友好界面：清晰简洁的界面设计，易于使用。
自动更新：支持自动检查更新，保证软件始终是最新版。
总之，StreamFab Downloader 是一个强大而易于使用的流媒体下载工具，能够满足用户对高品质视频和音频内容的需求。
下载地址：https://soft.macxf.com/soft/3601.html?id=MzE5MTM%3D
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d64bbca07fe583864ed5653623cce8d/" rel="bookmark">
			用时序数据库 DolphinDB 实现地震波形的分析预警
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 绪论 波形数据的存储与实时流处理是地震预警、地震速报、地震烈度速报、震源机制解等数字地震台网综合处理系统的前提，合理的存储方案与高效的实时流处理架构能极大地节约存储成本、降低响应延时、方便震源分析。
本篇教程会为有该方面需求的客户提供一个基于 DolphinDB 的地震波形数据存储及实时流处理的解决方案，助力用户降低存储成本、提升效率。
1.1 行业背景 国家地震台网、 区域地震台网和流动地震台网等组成的中国数字地震观测网络系统每天不间断地产生地震波行数据。该数据的原始形态是方便数据处理的，但为了进行归档和交换，必须进行统一的数据格式化，现使用的国际通用交换格式为 SEED。 国家测震台网数据备份中心实时接收存储的地震波形数据始于2007年8月，至今数据量大约有 100TB 左右。随着地震台站数量和强震数据的不断增多，可以预见今后的测震数据增速会越来越快。
现今大部分测震数据是以 SEED 文件格式或存储于盘阵内，或存储于光盘、移动硬盘等离线介质内，辅以数十张描述这些数据文件的关系型表，这些表遵从《中国数字测震台网数据规范》。有数据分析需求的研究人员通过网络等方式进行数据申请，数据服务方按照请求进行波形数据的截取和打包，并发送给研究员。
传统模式下的地震波形数据存储较为分散，一次能处理的数据长度有限，分析应用的流程冗长，因此并不能有效支撑大规模的数据查询、分析、计算和可视化服务。
1.2 业务挑战 总体而言，地震波形数据的处理可以简化成数据采集、数据清洗和数据可视化展示三个部分。其中的数据采集一般通过部署在各地的地震计完成。地震计 7X24 小时不间断地记录和测量当地的地面运动数据，然后通过网络传输到台网中心，由数据处理部门以人工交互或自动化方式处理数据，监测全国和全球的地震活动情况。
图1 地震波形数据流向
目前地震行业中数据采集相关工作比较完善，基本上也形成了统一的标准，但是在数据处理与数据分析模块中，还未形成统一的解决方案。随着国家对防震减灾的要求越来越高，用于数据采集的地震计数量将会呈数量级增长，并且随着物联网的发展，将会有更多数据接入用于地震监测。因此，原有在单台机器上运行的地震数据处理软件（如地震自动测定软件）的数据处理压力会越来越大。同时，海量数据的汇入，对数据存储、管理、回溯等都提出了新的要求。现如今，对地震数据的处理与分析面临以下几大难点：
文件存储：以 MiniSeed 文件形式单机存储，横向扩展性差，当数据量大时，扩展成为一个难题离线分析：从服务器上下载 MiniSeed 文件，再通过专业的地震分析软件将其解析成结构化数据进行分析，过程繁琐，效率低下实时处理与展示：目前无法实现实时计算、实时展示，特别是异常检测等时效性强的需求，无法满足 针对上述问题，目前业界的普遍做法是建立云架构数据中心， 它基于分布式文件系统的海量存储能力和分布式计算能力， 整合数据采集工具和 SQL 交互引擎、列式数据存储引擎， 提供对海量数据的采集、存储、处理分析和应用展示等系列功能，但也存在以下几个问题：
存储成本：将 MiniSeed 文件解析成结构化数据存入数据库体积变大，造成硬件资源成本急剧增加数据导入/导出功能：结构化数据存入数据库后，按需将数据打包成 MiniSeed 文件难度大，如一个台站所有通道一天的数据打包下载速度极慢，无法为业务人员提供数据支持外部订阅功能：以接口形式获取数据速度极慢，无法为后续其他系统提供数据支撑 2. DolphinDB解决方案 上述地震波形数据在存储与分析模块时面对的问题，可由 DolphinDB 在存储、流计算上支持的以下特性，以及通过这些特性的组合使用得以解决：
高效存储方式：数据分区列式存储。针对地震数据可采用时间+ id 的方式组合分区来达成灵活分区存储，对于不同分区数据可以多线程并行操作高效压缩算法：支持 lz4、delta 压缩算法，大大提升压缩率，节约硬件资源高效排序算法：sortColumn 对分区内数据排序存储，快速定位数据在分区中的位置强大的流数据计算引擎：毫秒级别计算响应延时 同时 DolphinDB 良好的生态也为 MiniSeed 文件导入、导出以及二次开发提供了极大的便利：
插件支持：自研 MiniSeed 插件，支持 MiniSeed 文件的导入与导出功能，避免了调用第三方工具导入/导出文件的繁琐过程丰富的机器学习支持：内置一系列常用的机器学习算法，例如最小二乘回归、随机森林、K-平均等，同时还提供了一些插件，方便地用 DolphinDB 的脚本语言调用第三方库进行机器学习，如 XGBoost 插件丰富的 API 生态：支持 Python, Java, C++, Go 等 API，助力二次开发 以某台网中心为例：每个通道的采样频率为每10毫秒采集一条监测记录，包含时间戳、sid 和采样值三个字段，并以通道为单位、每 3s 将采集到的监测记录打包成 MiniSeed 文件发送到台网中心。有以下需求：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d64bbca07fe583864ed5653623cce8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd4ee0784e6424f456bbc20de17a349f/" rel="bookmark">
			SparkDF存储目标表修改字段类型解决过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原始问题，指定前三个字段类型后，SparkDF存储数据后出现，更改字段类型
添加插入配置进行测试
rowResult1.write .mode(SaveMode.Overwrite) .option("createTableColumnTypes", "check_health_id varchar(200), column_name varchar(200), row_res varchar(1000), complete int, effective int, standard int, agreement int") .jdbc(url, "health_archives_update", prop) 测试Append插入是否会发生改变
再次使用Append模式再次插入后
字段类型没有发生改变
更换代码为overwrite模式测试
表字段没有发生改变。
再次执行任务查看
字段类型没有发生改变
测试表是否区分大小写
更换为小写U,测试没有影响
类型没有发生改变
PS: 此次出现的问题为SparkDF字段类型为以下所示
root |-- check_health_id: string (nullable = true) |-- column_name: string (nullable = true) |-- row_res: string (nullable = true) |-- complete: integer (nullable = true) |-- effective: integer (nullable = true) |-- standard: integer (nullable = true) |-- agreement: integer (nullable = true) Mysql存储格式为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd4ee0784e6424f456bbc20de17a349f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8606bdf66ebf621dff7df8a2522c6125/" rel="bookmark">
			自动化测试-selenium学习笔记-简单介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 selenium是一个用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE（7, 8, 9, 10, 11），Mozilla Firefox，Safari，Google Chrome，Opera，Edge等。这个工具的主要功能包括：测试与浏览器的兼容性——测试应用程序看是否能够很好得工作在不同浏览器和操作系统之上。测试系统功能——创建回归测试检验软件功能和用户需求。支持自动录制动作和自动生成.Net、Java、Perl等不同语言的测试脚本。
二、功能 1.框架底层使用JavaScript模拟真实用户对浏览器进行操作。测试脚本执行时，浏览器自动按照脚本代码做出点击，输入，打开，验证等操作，就像真实用户所做的一样，从终端用户的角度测试应用程序。
2.使浏览器兼容性测试自动化成为可能，尽管在不同的浏览器上依然有细微的差别。
3.使用简单，可使用Java，Python等多种语言编写用例脚本。
三、组件 1.Selenium IDE：一个Firefox插件，可以录制用户的基本操作，生成测试用例。随后可以运行这些测试用例在浏览器里回放，可将测试用例转换为其他语言的自动化脚本。
优点：
①记录快捷方便。
②代码转换功能和使用方便，易于生成其他编程语言的测试用例代码。
③支持跨域。
④不依赖于Java运行环境。
缺点：
①记录回复方式的稳定性和可靠性有限。
②只支持Mozilla firefox。
③只支持Selense命令语言，虽然可以导出为其他编程语言的测试用例。
④对于复杂的页面逻辑及其处理能力有限。
2.Selenium Remote Control (RC) ：支持多种平台(Windows，Linux，Solaris)和多种浏览器(IE，Firefox，Opera，Safari)，可以用多种语言(Java，Ruby，Python，Perl，PHP，C#)编写测试用例。
3.Selenium Grid ：允许Selenium-RC针对规模庞大的测试案例集或者需要在不同环境中运行的测试案例集进行扩展。
4.Selenium WebDriver ：WebDriver前身是Selenium RC，可以看作是Selenium RC的替代品，直接发送命令给浏览器，并检索结果。
WebDriver和Selenium RC的区别：
WebDriver
①不需要Selenium WebDriver Server就可以运行测试用例。
②WebDriver独立使用本地浏览器运行测试用例。
③WebDriver既可以测试传统的桌面Web应用程序，也可以测试手机上的应用程序，如iPhone或Android应用程序。
④WebDriver可以支持大多数最新版本的浏览器。
Selenium RC
①Selenium RC需要Selenium Server来运行测试用例。
②Selenium RC使用JavaScript来驱动运行测试用例的浏览器。
③Selenium RC只能支持Web应用程序测试。
④Selenium RC可以支持所有浏览器但不支持最新版本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a688fe805a7b35cfb7c9948a20744cae/" rel="bookmark">
			结构型模式-适配器模式学习demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 在目前敏捷开发中，跟随需求版本迭代，部分业务功能，在不同的指标影响下，部分指标下业务规则变动较大时，可能要重构代码，
再或者替换老版本代码时，新人在没有手册的情况下，不敢随意改动复杂业务代码，
可以增加大量的if 、else代码维护老功能吗，不涉及的指标使用老代码，涉及大量改动的使用新代码，外部页面调用时，只有一个入口；
当时此处谈论的只涉及简单的结构调整，使用适配器模式简单维护历史代码，
要是想重构的话，使用简单工厂等创建型模式也可以，例如：简单工厂模式
TODO下次完善
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89394d02d061fa2f1d08b51dab18e86a/" rel="bookmark">
			【2023年电工杯数学建模竞赛B题人工智能对大学生学习影响的评价】完整思路分析&#43;完整代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题背景与描述 这道题整体还是相对简单的，比较适合新手，选的人多对应获奖数量也会多，所以不要纠结于选题，就选你看上去能做的就好
2.问题分析 2.1 问题一的分析 对附件2中所给数据进行分析和数值化处理，并给出处理方法；首先利用问题所给数据进行预处理分析。具体包括对问卷调查数据进行信度分析，确保问卷的可用性与合理性。进一步对问卷数据进行热编码，也就是数值化处理。
首先问卷数据量化这一步至关重要，想做出彩，数据量化和预处理这块可以认真考虑。
下面是ChatGPT给出的数据量化思路，可以参考
数据量化完成之后还可以进行进一步数据分析，具体可以进行的分析包括相关性分析，方差分析，T检验，描述性统计分析。
问题一可以利用spss来做，过程会简单一些，当然最好用python，博主后续会更新python解题代码。
2.2 问题二的分析 本提要求根据分析结果选取合适的评价指标来建立评价指标体系。
ChatGPT给出的思路，不能说毫无作用，只能说完全不理解我说的。（这里就你看出它不是万能的，有自己局限性）
本题其实发散性很强，关键是要有自己的想法。我这里只提供一种思路，首先你要明确你的评价目标。本题是要评价人工智能对大学生学习的影响，也就是利用人工智能使用频次，使用时长，使用方法等指标来评价大学生学习成绩。要求建立评价指标体系，简单的说就是用量化模型来找出影响大学生学习效率和学习成绩的主要影响指标（这些指标就是问题一量化指标的一部分）。总的来说评价指标体系的建立就是一个指标变量筛选过程。具体的筛选方法包括回归分析，共线性诊断等等。
2.3 问题三的分析 本提要求建立数学模型，评价人工智能对大学生学习的影响，给出明确、有说服力的结论；这里就是利用建立的评价指标体系来建立综合评价模型，来分析人工智能的广泛使用是否能有效提升大学生学习效率等。
一种方法还是建立回归模型来讨论具体指标的影响，但是这么做的话感觉和问题二相似了。因此这里也可以拓展一下，求解哪些评价指标对大学生学习提升影响大。可以量化指标影响水平，也就是计算指标得分。从而给出影响水平较大的指标，并进行进一步分析。可以建立熵权法或者灰色关联模型来计算得分并分析。（指标权重得分计算方法有很多，大家可以参考相关文献）
2.4 问题四的分析 这个就比较简单了，chatgpt最擅长的工作，不过这里还是建议大家自己写一下。需要将前三问的建模分析结果进行汇总，并且给出一份文案报告。
3.完整代码分享 你好审核，是站内链接
2023年电工杯B完整代码+结果-站内链接
2023年电工杯B完整paper-参赛作品
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a23e3863f08f51a683c938a35e91915e/" rel="bookmark">
			Jmeter性能测试之命令行执行和生成测试报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 准备 Jmeter有两种运行方式：一种是上面采用的界面模式(GUI)形式，会占用java虚拟机的资源；另一种是命令行模式(non-GUI)执行，这样节约资源，尤其是在持续集成时基本都是采用non-GUI模式。
配置环境变量
命令行执行 命令行格式
jmeter -n -t &lt;testplain filename&gt; -l &lt;listener filename&gt; 参数说明：
testplain filename：jmx文件的绝对路径或相对路径
listener filename：执行之后结果文件名，后缀名必须是.jtl
调试压测请求
命令行下，如果想查看每个请求返回的结果，需要修改jmeter.properties配置文件
将上面的注释打开，并且值修改成true，就会打开该条记录，jmeter就会将该条信息输出到我们指定的jtl文件中，不要要注意压测过程中，会产生大量的这样的记录，真正压测时，最好不要开太多的日志记录。
实时查看压测结果
jmeter命令行下，也可以实时查看压测结果，同样是修改配置文件jmeter.properties
打开上面的summariser.name、summariser.interval、summariser.out这三个配置项，保存，重新运行jmeter，应该就可以在shell里看到统计信息了。 生成测试报告 执行命令如下
jmeter -n -t test.jmx -l result.jtl -e -o ./result_report 参数说明:
n：非GUI模式执行JMeter
t： 脚本文件(.jmx文件)的路径
l： 指定生成测试结果的保存文件(.jtl格式)，此文件必须不存在
e：测试结束后，生成测试报告
o：用于存放测试报告的路径
注意：result_report 是自己创建的测试报告文件夹，每次启动命令之前，文件夹内容要和 jtl 文件一起清空，否则会报错。
查看测试报告
打开index.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96540caf549cd00fd5e1d98485a68488/" rel="bookmark">
			怎么将主机的文件传到容器【docker cp】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要将主机的文件传输到容器中，可以使用 `docker cp` 命令。
以下是一个简单的示例，假设您有一个名为 `mycontainer` 的容器，并且要将主机上的文件 `/path/to/file` 传输到该容器的 `/container/path` 目录：
```
docker cp /path/to/file mycontainer:/container/path
```
这将把主机上的文件复制到容器的指定路径。
请注意，在上述命令中，`mycontainer` 是容器的名称或 ID，`/container/path` 是容器中要复制到的目标路径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43efb3739e251236350762c3caf6646c/" rel="bookmark">
			HDLBits学习（四）Circuits--Combinational Logic
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Combinational Logic Basic Gates wire-- nor-- xor-- More logic gates-- 7420chip-- (此部分为基础逻辑门) Truthtable1 可用卡诺图或公式法化简F=x1x3+x2~x3
需要注意的是：F中的+为或，乘为与，故：f=x1&amp;x3 | x2&amp;~x3;
Mt2015 eq2 题目：创建一个两输入inputs A [1:0], B[1:0]，一输出Z。当A 与 B 相等时，Z 输出为1， 否则为0；
code:无
Mt2015 q4a 题目：创建一个电路，其功能可以实现 z = (x ^ y) &amp; x
codel:无
Mt2015 q4b 用卡诺图化简
Mt2015 q4 ringer 软件思路：如果什么条件成立了，则有什么结果。
硬件思路：当输入为什么条件时，输入是什么结果，输入与输出匹配，而不是有这个输入才导致的输出
thermostat Popcount3 数1的个数，重复题
Gatesv 题目：有一个4bit输入的电路，我们需要了解4bit输入数据之间的关系。
out_both：这个输出向量的每个比特都应该指示对应的输入比特及其左边的邻居（更高的索引）是否都是“1”。例如，out_both[2]应该指示in[2]和in[3]是否都是1。由于in[3]在左边没有邻居，所以答案很明显，所以我们不需要知道out_both[3]。
out_any：这个输出向量的每个比特都应该指示对应的输入比特及其右边的邻居是否为“1”。例如，out_any[2]应指示[2]中或[1]中是否为1。由于in[0]右边没有邻居，答案很明显，所以我们不需要知道out_any[0]。
out_different：这个输出向量的每个比特都应该指示对应的输入比特是否与其左边的邻居不同。例如，out_different[2]应指示[2]中的内容是否与[3]中的内容不同。对于这一部分，将向量视为环绕，因此在[3]中，左侧的邻居在[0]中。
code:
module top_module( input [3:0] in, output [2:0] out_both, output [3:1] out_any, output [3:0] out_different ); assign out_both={in[3]&amp;in[2],in[2]&amp;in[1],in[1]&amp;in[0]}; assign out_any={in[3]|in[2],in[2]|in[1],in[1]|in[0]}; assign out_different={in[3]^in[0],in[3]^in[2],in[2]^in[1],in[1]^in[0]}; endmodule Gatesv100 题目：上题输入长度变为100
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43efb3739e251236350762c3caf6646c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c864384f0bd851980b28778eda2bb7e/" rel="bookmark">
			关于petalinux 2017.4版本petalinux-package 命令打包报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#关于petalinux 2017.4版本petalinux-package 命令打包报“文件不存在”的问题
该问题报错为如下图：
petalinux定制linux系统前面的步骤均没有问题（这里使用petalinux-build命令一次性编译），到最后的打包环节时，显示一级引导程序文件不存在。
解决方法：
先分别buil u-boot，kernel，rootfs
再全部打包一遍
总结：
笔者推测该问题是petalinux2017.04的BUG。该问题困扰了笔者几天，网上没有出现过此类问题，也没有解决方法。我在此写出解决方法，希望可以帮助遇到相同问题的人。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e014ef8b4824a5c2c9fbdd4858b77797/" rel="bookmark">
			Rocketmq消息批量发送&amp;消息批量消费
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：批量发送和消费消息在一定程度上可以提高吞吐量，减少带宽，那么Rocketmq 中的消息怎么进行批量的发送和批量的消费呢；
1 消息的批量发送：
1.1 批量发送的优点以及实现：
批量发送消息可以提高 RocketMQ 的生产者性能和吞吐量。由于批量发送消息可以减少网络 I/O 操作和降低消息发送延迟，因此它在以下情况下特别有用：
发送大量小型消息时需要降低消息发送延迟时需要提高生产者性能时 但是，批量发送消息也存在一些注意事项，需要注意以下几点：
消息列表的大小不能超过 broker 设置的最大消息大小。消息列表的大小不能超过生产者设置的 maxMessageSize 参数，此参数默认为 4MB。批量发送消息不支持消息事务。如果的代码在发送消息列表时发生异常，则可能会发生部分消息发送成功，部分消息发送失败的情况。如果要确保所有消息都已成功发送，则需要增加错误处理逻辑和消息重试机制。 批量发送消息是一种提高 RocketMQ 生产者性能和吞吐量的好方法，但需要注意消息列表大小和错误处理机制，以确保生产者的可靠性和稳定性。
public class SimpleBatchProducer { public static void main(String[] args) throws Exception { DefaultMQProducer producer = new DefaultMQProducer("BatchProducerGroupName"); producer.start(); //If you just send messages of no more than 1MiB at a time, it is easy to use batch //Messages of the same batch should have: same topic, same waitStoreMsgOK and no schedule support String topic = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e014ef8b4824a5c2c9fbdd4858b77797/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fb6face8a60de792fbe3290018b579d/" rel="bookmark">
			vue3中el-collapse-item不想点整个标题折叠和展开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		el-collapse-item组件鼠标点标题时都会折叠和展开，现在的需求只能是在点击最右边的小图标时才进行折叠和展开。组件没有提供可控制的属性，那只能想办法看看能不能通过CSS来实现。研究发现通过样式穿透果然可以。
&lt;style lang="scss" scoped&gt;
:deep(.el-collapse-item__header) {
pointer-events: none;
}
:deep(.el-collapse-item__arrow) {
pointer-events: auto;
}
&lt;/style&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7593facce73c74b59e6837d977840599/" rel="bookmark">
			Python常用数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 提供了多种内置的数据结构，用于存储和组织数据。以下是一些常见的 Python 数据结构：
1.列表（List）：列表是一个有序、可变的数据集合，可以包含任意类型的元素。列表使用方括号 [] 表示，元素之间用逗号分隔。例如：my_list = [1, 2, 3, 'a', 'b', 'c']。
2.元组（Tuple）：元组是一个有序、不可变的数据集合，可以包含任意类型的元素。元组使用圆括号 () 表示，元素之间用逗号分隔。例如：my_tuple = (1, 2, 3, 'a', 'b', 'c')。
3.字典（Dictionary）：字典是一种键值对（Key-Value）的数据结构，用于存储无序的数据集合。每个元素由一个键和一个对应的值组成，键必须是唯一的。字典使用花括号 {} 表示，每个键值对之间用冒号分隔。例如：my_dict = {'name': 'John', 'age': 25, 'city': 'New York'}。
4.集合（Set）：集合是一个无序、不重复的数据集合，用于存储唯一的元素。集合使用花括号 {} 或 set() 函数来创建，元素之间用逗号分隔。例如：my_set = {1, 2, 3, 4, 5} 或 my_set = set([1, 2, 3, 4, 5])。
5.字符串（String）：字符串是一个由字符组成的不可变序列，用于存储文本数据。字符串可以使用单引号或双引号括起来，例如：my_string = "Hello, World!"。
除了这些内置的数据结构，Python 还提供了其他扩展的数据结构，如命名元组（NamedTuple）、队列（Queue）、堆（Heap）等，这些数据结构可以通过导入相应的模块来使用。
另外，Python 还支持自定义数据结构，通过类（Class）来创建自己的数据类型，可以定义数据的属性和方法，并进行封装和抽象。这使得 Python 可以根据特定的需求创建更灵活的数据结构。
当然，还有更多 Python 的数据结构：
1.堆栈（Stack）：堆栈是一种具有后进先出（LIFO）特性的数据结构，类似于一叠盘子。你可以使用列表来实现一个堆栈，通过 append() 方法将元素添加到堆栈顶部，使用 pop() 方法从堆栈顶部移除元素。例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7593facce73c74b59e6837d977840599/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2010b2530d099a6af7fedff1055a4de9/" rel="bookmark">
			【强化学习】Policy Gradient 策略梯度算法求解CartPole倒立摆问题 &#43; Pytorch代码实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、倒立摆问题介绍二、策略梯度算法简介三、详细资料四、Python代码实战4.1 运行前配置4.2 主要代码4.3 运行结果展示4.4 关于可视化的设置 一、倒立摆问题介绍 Agent 必须在两个动作之间做出决定 - 向左或向右移动推车 - 以使连接到它的杆保持直立。
二、策略梯度算法简介 我们可以把采样到的数据代入下式中，把梯度算出来。也就是把每一个 s s s 与 a a a 的对拿进来，计算在某一个状态下采取 某一个动作的对数概率（log probability) log ⁡ p θ ( a t n ∣ s t n ) \log p_\theta\left(a_t^n \mid s_t^n\right) logpθ​(atn​∣stn​) 。对这个概率取梯度，在梯度前面乘一个权重，权重就是这场游戏的奖励。我们计算出梯度后，就可以更新模型。
∇ R ˉ θ = 1 N ∑ n = 1 N ∑ t − 1 T n R ( τ n ) ∇ log ⁡ p θ ( a t n ∣ s t n ) \nabla \bar{R}_\theta=\frac{1}{N} \sum_{n=1}^N \sum_{t-1}^{T_n} R\left(\tau^n\right) \nabla \log p_\theta\left(a_t^n \mid s_t^n\right) ∇Rˉθ​=N1​n=1∑N​t−1∑Tn​​R(τn)∇logpθ​(atn​∣stn​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2010b2530d099a6af7fedff1055a4de9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1698d1b17afad6f9dc0f5c1137b8eda/" rel="bookmark">
			【Python】一个随机生成四则运算题目的小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import random # 生成随机整数 def generate_random_number(): return random.randint(1, 100) # 生成随机运算符 def generate_random_operator(): operators = ['+', '-', '*', '/'] return random.choice(operators) # 生成随机四则运算题目 def generate_math_question(): num1 = generate_random_number() num2 = generate_random_number() operator = generate_random_operator() if operator == '/': # 除法运算，确保结果是整数 num1 = num1 * num2 elif operator == '-': # 减法运算，确保结果不为负数 num1, num2 = max(num1, num2), min(num1, num2) question = f"{num1} {operator} {num2}" answer = eval(question) return question, answer # 生成指定数量的四则运算题目 def generate_math_questions(num_questions): questions = [] for _ in range(num_questions): question, answer = generate_math_question() questions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1698d1b17afad6f9dc0f5c1137b8eda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c95e4c6c7091319323a4ffd70ba2adb1/" rel="bookmark">
			VS2019 WPF制作OTA上位机（三）串口打开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先在UI上添加控件
首先，改变一下原来的方法， 原来的三个控件是没有布局的，添加一下布局。
布局用简单的行布局，也就是说从，上到下，分成一行一行的，如下图
将上一篇文章的代码修改
&lt;Window x:Class="Test.MainWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:local="clr-namespace:Test" mc:Ignorable="d" Title="MainWindow" Height="450" Width="950"&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height="60"&gt;&lt;/RowDefinition&gt; &lt;RowDefinition Height="60"&gt;&lt;/RowDefinition&gt; &lt;RowDefinition Height="170"&gt;&lt;/RowDefinition&gt; &lt;RowDefinition Height="130"&gt;&lt;/RowDefinition&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid Grid.Row="0"&gt; &lt;Label Height="1" Background="Black" VerticalAlignment="Top"&gt;&lt;/Label&gt; &lt;Label Height="40" Width="85" Content="bin文件路径：" VerticalContentAlignment="Center" VerticalAlignment="Center" HorizontalAlignment="Left"&gt;&lt;/Label&gt; &lt;TextBox Name="TextBox_BinFilePath" Height="40" Width="600" VerticalContentAlignment="Center" HorizontalContentAlignment="Left" VerticalAlignment="Center" HorizontalAlignment="Left" Margin="100,0,0,0"&gt;&lt;/TextBox&gt; &lt;Button Name="Button_GetBinFilePath" Content="浏览bin路径" Height="40" Width="70" VerticalAlignment="Center" HorizontalAlignment="Right" Margin="0,0,100,0" Click="Button_GetBinFilePath_Click"&gt;&lt;/Button&gt; &lt;Label Height="1" Background="Black" VerticalAlignment="Bottom"&gt;&lt;/Label&gt; &lt;/Grid&gt; &lt;Grid Grid.Row="1"&gt; &lt;Label Height="40" Width="50" Content="端口号" VerticalContentAlignment="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c95e4c6c7091319323a4ffd70ba2adb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/555c54474573bfa7dcdcf595965d75be/" rel="bookmark">
			由于找不到msvcr110.dll 无法继续执行怎么解决（最新解决方法分享）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MSVCR110.dll是Windows操作系统中的一个重要文件，一旦它出现丢失问题，会导致影响计算机整体的问题。这个跟MSVCP110.dll类似的误报，通常是由于安装编程工具或 部分无法正确安装所导致的问题。在这篇文章中，我们将一些解决此问题的方法分享给大家。
方法一：使用修复程序解决问题
1.在浏览器顶部网页搜索【dll修复程序.site】，进入站点点击下载
2.在站点下载一个【dll修复程序】，这个程序是可以修复百分之百dll丢失的问题
3.安装完成dll修复程序安装包右键进行解压，然后点击开始检测修复dll文件缺失的情况
4.检测完后，点击下一步让程序自动修复安装既可以，提示完成重启一下电脑就可以正常运行
方法二：重新安装msvcr110.dll
1、从windows官网上下载最新版本的msvcr110.dll文件
2、在下载结束后，双击运行下载的文件，按照屏幕上的提示进行安装。
3、重新启动您的计算机，尝试打开应用程序并查看是否已解决问题。
方法三：重新安装计算机系统
1.备份数据：在重装系统之前，需要备份你的计算机中的重要数据。
2.获取安装盘：要重装系统，需要一张操作系统的安装盘。
3.进行系统安装：电脑开机后，系统会从安装盘中启动。按照提示进行系统安装，选择合适的语言、时区、键盘布局等，然后点击“下一步”。
4.安装驱动：系统安装完成后，需要手动安装硬件驱动程序。可以从官方网站下载驱动程序，解压后安装。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab3b6f8fe879cc98149644a9561fa7b6/" rel="bookmark">
			跑python代码过程中遇到的种种bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一行：国际惯例咕咕咕
第二行：不记下错误和解决方法，我就每次都得现搜。我清楚地记得我遇到过这些错，我也清楚地记得我忘记怎么解决了。
第三行：我生平最讨厌配环境。（但还是配好了
第四行：本地能跑服务器跑不起来我再次自闭，跑去配服务器环境了。
以下bug环境相关的都略了，pip conda啥的一阵儿安装：(【upd：本地真好配服务器环境全是bug贴下面了：(】
一、文件读取or路径问题 FileNotFoundError: .\data\eth\hotel\true_pos_.csv not found.
问题：找不到文件路径。
解决方法：找到文件导入部分，将路径改为绝对路径即可
二、逻辑or手残or无脑写错代码问题 RuntimeError: view size is not compatible with input tensor's size and stride (at least one dimension spans across two contiguous subspaces). Use .reshape(...) instead.
问题：tensor中元素地址不连续
解决方法：因为view()需要tensor中的元素地址是连续的，但可能出现tensor不连续的情况，所以先用 .contiguous()将其在内存中变成连续分布。
RuntimeError: Index put requires the source and destination dtypes match, got Long for the destination and Float for the source.
问题：变量类型不匹配
解决方法：找到对应位置，将变量转为float即可。
TypeError: list indices must be integers or slices, not tuple
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab3b6f8fe879cc98149644a9561fa7b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c498e9d54aff67f473cf662db1e4c3/" rel="bookmark">
			stm32快速查阅手册-长期总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stm32编程技巧-长期总结 文章目录 stm32编程技巧-长期总结0. STLINK连接1. 芯片系统结构2. STM32芯片引脚定义3. GPIO库函数4. EXTI库函数5. NVIC库函数6. TIM库函数7. ADC库函数8. DMA库函数9. USART库函数10. I2C外设库函数11. SPI外设库函数 本篇是本人在学习stm32过程中，逐步将常用的一些知识点单独摘出来，以方便后续查阅。不定期更新。 注：笔记主要参考B站 江科大自化协 教学视频“ STM32入门教程-2023持续更新中”。 0. STLINK连接 若STLINK就是连接不上，可以依次尝试以下办法：
更新STLINK驱动。设备管理器删除未识别的设备，然后拔了重插。关闭电源选项中的“USB选择性暂停”，然后重新插。https://www.bilibili.com/read/cv18126898换一个STLINK。 注：宗旨就是遇到什么报错就百度什么报错，实在弄不成就换STLINK。
1. 芯片系统结构 图0-1 STM32芯片系统结构 首先来看看STM32的芯片系统结构（只需要大致了解一下即可）：
Cortex-M3：内核。注意ICode、DCode、System是直接从内核引出的三根总线。Flash：存储编写的程序。ICode总线和DCode总线主要用于连接Flash闪存。SRAM：用于存储程序运行时的变量数据。ICode：指令总线。加载程序指令。DCode：数据总线。加载数据，如常量和调试参数。System：系统总线。连接到Flash以外其他外设上，如SRAM、FSMC（本课程不会用到）。AHB系统总线：先进高性能总线。用于挂载最基本的（如复位和时钟控制RCC、SDIO）、或者性能比较高的外设。APB2、APB1：先进外设总线。用于连接一般的外设。通常AHB（72MHz）性能总体高于APB，而APB2（72MHz）性能高于APB1（36MHz）。所以APB2连接外设中稍微重要的部分，如GPIO、各外设的1号接口；剩下的次要外设给APB1。桥接2、桥接1：由于AHB和APB的总线协议、 总线速度、数据传输格式上的差异，需要加上2个桥接，来完成数据的转换和缓存。DMA2、DMA1：拥有和CPU相同的总线控制权，用于帮助CPU完成数据搬运这样简单但重复的活，相当于CPU的小秘书。若外设需要进行数据搬运，那么会直接找DMA（DMA请求），DMA就会获得总线控制权来搬运数据，整个过程无需CPU的参与。 2. STM32芯片引脚定义 图1-6 STM32F103C8T6引脚定义 上图给出了UP主自己做的STM32F103C8T6引脚定义。一些说明如下：
标红色的是电源相关的引脚，标蓝色的是最小系统相关的引脚，标绿色的是IO口、功能口引脚。所以 最小系统板主要关心红色和蓝色部分。类型：S代表电源、I代表输入、O代表输出、I/O代表输入输出。I/O口电平：表示I/O所能容忍的电压，默认3.3V，FT表示最高容忍5V。注意没有FT标志的引脚都需要加装电平转换电路。主功能：上电默认功能。默认复用功能：I/O口上同时连接的外设功能引脚，配置IO口时可以设置是主功能/复用功能。重定义功能：如果需要某一个端口上实现两个功能，那么可以将其中一个功能重映射到另一个空闲端口上，这个空闲端口的重定义功能需要包含相应的功能。推荐优先使用加粗的IO口，没有加粗的可能需要配置或兼具其他功能，使用时需要注意。 下面来一一介绍这些引脚的功能（包括PA0~PA15、PB0~PB15、PC13~PC15、9个供电、2个时钟、1复位、1个BOOT0）：
引脚1：备用电池供电。可接3V电池，系统断电时为芯片内部的RTC和备用寄存器提供电源。引脚2：IO口/入侵检测/RTC。IO口输出或读取高低电平；入侵检测提供安全保障，可以将外部一些防拆的触点接在此端口，若触点电平变化，STM32芯片会自动清空寄存器数据；RTC可输出RTC校准时钟、RTC闹钟脉冲、秒脉冲。引脚3、4：IO口/32.765kHzRTC晶振。引脚5、6：系统主晶振，一般8MHz，芯片内的锁相环电路将时钟倍频成72MHz作为系统主时钟。引脚7：系统复位引脚。N表示低电平复位。引脚8、9：芯片内部模拟部分的电源，如ADC、RC振荡器等。VSS接地、VDD接3.3V。引脚10~19、21~22、25~33、41~43、45~46：共26个默认普通IO口。 其中的PA0兼具WKUP功能，用于唤醒处于待机状态的STM32。引脚20：IO口/BOOT1引脚。BOOT1引脚用于控制启动模式。引脚23/24、35/36、47/48：系统的主电源口。STM32采用分区供电的方式，所以供电口多。引脚34、37~40：IO口/调试端口。STM32支持SWD和JTAG两种调试方式。SWD只需SWDIO、SWCLK两根线；JTAG需要全部的5根。教程使用STLINK(SWD)下载程序，此时剩余3个引脚可配置成IO口。引脚44：BOOT0，和BOOT1配合，用于启动配置。启动配置就是指定程序开始运行的位置，一般程序在Flash程序存储器中运行，但在某些情况下可以指定程序在别的地方开始执行以完成特殊功能。
“主闪存存储器”启动模式最常用。“系统存储器”模式用于串口下载程序，系统存储器中存储的是一段STM32的BootLoader程序，其作用就是接收串口数据然后刷新到主闪存中。当5个调试端口全被配置成IO口时，单片机将无法再下载程序！！ 此时只能使用串口下载程序的方式进行补救。另外，当手头上没有STLINK和JLINK，也可以使用串口来下载程序，通俗来说就是“刷机”。😂“内置SRAM”模式主要用于程序调试，使用较少，本教程不会出现。注意BOOT值是在上电一瞬间（第4个时钟上升沿）有效，后面随意，即BOOT1引脚后续会变成普通IO口。
一般性描述： 进行某个外设初始化时，一定要注意先开启相应的RCC外设时钟，但是EXTI、内核外设（如NVIC）无需手动开启。配置外设时钟时，可以参考上面的“STM32芯片系统结构”，以找到外设对应的位置。stm32中每个中断通道都对应一个固定的中断函数的名称，这些名称从启动文件startup_stm32f10x_md.s里查看，最开始后缀是xxxxHandler的定义都是中断函数名。保险起见，每次进入中断函数时，都应该先看一下当前中断的中断标志位是否为SET状态。中断函数结束前，也一定要记得清除该中断的中断标志位。 3. GPIO库函数 图0-2 GPIO的库函数 GPIO外设配置：
关于GPIO的模式配置GPIO_Mode，可以查阅参考手册的“8.1.11 外设的GPIO配置”一节，里面已经规定好各种外设（如TIM、USART、SPI、IIC、CAN等）应该配置的GPIO模式。 GPIO_PinLockConfig【使用不多】：用于锁定GPIO配置，防止配置被更改。GPIO_PinRemapConfig【重要】：用于进行引脚重映射，不要随便动SWD调试端口。注意参数GPIO_Remap_SWJ_Disable慎用！！会将PA13、PA14、PA15、PB3、PB4这5个调试端口全变成普通的GPIO口，失去调试功能，就不能使用STLINK下载程序了。恢复的方法就是使用串口重新下载初始化程序。 AFIO外设配置：
库函数在GPIO中。 GPIO_AFIODeInit：复位AFIO外设，调用该函数会清除AFIO外设的全部配置。GPIO_EventOutputConfig【使用不多】：用于配置AFIO的事件输出功能。GPIO_EventOutputCmd【使用不多】：用于配置AFIO的事件输出功能。GPIO_EXTILineConfig【重要】：配置AFIO的数据选择寄存器，来选择想要的中断引脚。 4. EXTI库函数 图0-3 EXTI的库函数 EXTI_DeInit：将EXTI的配置清除，恢复成上电默认的状态。EXTI_Init【常用】：根据结构体的参数配置EXTI外设，常用于初始化EXTI。EXTI_StructInit：把参数传递的结构体变量赋默认值。
注：上面这个三个函数，基本上所有的外设都有。EXTI_GenerateSWInterrupt：用于软件触发外部中断，使得相应的中断线产生一次外部中断。只需要外部引脚触发外部中断，则不需要这个函数。EXTI_GetFlagStatus：获取指定的标志位状态。用于主程序。EXTI_ClearFlag：清除指定的标志位。用于主程序。EXTI_GetITStatus：获取中断标志位。用于中断函数。EXTI_ClearITPendingBit：清除中断挂起标志位。用于中断函数。
上面这四个函数都是对状态寄存器的读写，只不过后两个函数只能读写与中断有关的标志位，并对中断是否允许做出了判断；前两个函数只是一般的读写标志位，没有额外的处理，能不能触发中断的标志位都能读取。 5. NVIC库函数 图0-4 NVIC的库函数 NVIC内核外设配置：（在misc文件中）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32c498e9d54aff67f473cf662db1e4c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caa33b3d88ca8b2379463c724e39d297/" rel="bookmark">
			Linux服务器上如何安装OpenCV的库？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux上安装OpenCV其实挺简单的。对于Python来说，可以直接使用pip进行安装，如：
pip3 install opencv-python 当然，如果你是想在C++或者Java内作为外部包使用，你可以考虑编译安装。
安装依赖 首先是依赖安装问题，我们需要有GCC编译器还有Cmake：
# Debian/Ubuntu版本 sudo apt-get install build-essential sudo apt-get install cmake # CentOS发行版本 sudo yum install gcc gcc-c++ sudo yum install cmake OpenCV源码 我们进入OpenCV的官网找到Source Forge选项：
Cmake预编译 下载好了OpenCV的源码，接下来我们使用Cmake进行预编译，进入OpenCV源码目录，输入：
cmake -S . -B build -DCMAKE_INSTALL_PREFIX=/usr/local/opencv 其中：
DCMAKE_INSTALL_PREFIX：OpenCV的安装地址，这里选择安装到/sur/local/opencv里。
之后，就会开始“跑码”预编译生成build文件夹和Markfile文件：
但是这样，我们后续编译只能安装Python2（系统）和C++的支持，无法支援到Python3和java。
需要支援带Python3和Java，需要在Cmake前，部署JAVA_HOME和设置Python3的地址。具体可以看原文嗷
我们Cmake预编译没问题，只需运行make命令即可：
make make install 卸载OpenCV 卸载OpenCV很简单，我们重新进入OpenCV源码目录内的build文件夹，运行：
make uninstall all 之后，OpenCV就会自动卸载完成：
综上所述，就是Linux上安装OpenCV的方法嗷。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65196e349fdbe10237741d472d12b539/" rel="bookmark">
			定位实测记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司优选利用高德，百度这种地图公司的定位
一.自己总结
gps/北斗可以使用手机定位，但是不在室外基本上获取不到信号
wifi 必须连接,wifi定位其实就是有服务器记录这些wifi地址，也要通过第三方去查询才知道经纬度
基站 只能获取到基站编号，但是获取基站位置需要第三方网址接口查询，才能知道经纬度
蓝牙 室内定位，一般是根据信号去计算到哪个定位用蓝牙基站更近，然后计算出位置
二.蓝牙定位距离计算 获得相对距离，正如您所说的“越来越近”或“越来越远”，使用下面发布的公式在 12 米范围内是有可能的。超过 12 米时，它会变得非常不稳定。但它非常复杂，需要您使用您认为足够长度的移动平均解决方案。
您可以使用以下公式计算 RSSI 与距离之间的关系:
RSSI = -(10*n*log10(d) + A) 在这种情况下， n = 路径损耗指数，因为你不需要精确的距离，只是一种检查距离更近或更远的方法，你可以使用 2 作为值，我发现在大多数情况下这是最现实的。 A = 在 1 米距离处测得的 RSSI 值，您需要提前测量它来进行计算，但由于它变化很大，所以只需使用 -60dB 这样的值。在大多数情况下，这也是平均水平。
因此可以通过以下公式粗略猜测以米为单位的距离:
distance = 10 ^ ((-RSSI - 60) / (10 * 2)); 这不是很准确，但足以告诉您它是否在有限范围内更近/更远。
三.北斗、GPS、WiFi、基站、蓝牙几种定位方式比较
定位方式有很多种，有专门用于室内的定位技术，也有广泛用于室外定位的技术，比如北斗定位、GPS定位、WiFi定位、基站定位、蓝牙定位，今天卫通达要分析的就是这几种适用于室外的定位方式。
1、GPS定位
GPS定位是最常见的，它信号好、定位精度高、使用范围广，几乎所有需要定位的设备都会优先使用GPS定位。缺点是，不能信号透过金属和钢筋水泥混合物，因而不能在室内如地下停车场、高桥下、密集的楼房下使用。而且GPS在首次启动定位时，搜星速度慢，大约需要2~3分钟，不过现在这个缺陷也得到很好的解决了，很多GPS定位的设备都有AGPS或EPO辅助定位功能，帮助在搜星时快速定位位置，一般只需要几秒就搞定了，有的甚至实现秒定定位了。
2、北斗定位
北斗定位，众所周知，北斗是我国全力发展的可以跟GPS定位抗衡的卫星定位方式，定位原理跟GPS是一样的，都是根据天上的卫星来确定当前的位置的。虽然原理都一样吧，但是目前在定位精度、使用范围上还是有一定的差距，现在还是主要用于军事上，民用范围还在大力推广，民用范围定位精度几米到几十米都有，北斗模块的定位芯片价格相较GPS模块要高，在一些偏远山村，偏僻的地方可能会没有信号。
目前GPS卫星定位系统覆盖的是全球范围，能够确保地球上任何地点、任何时间能同时观测到6-9颗卫星(实际上最多能观测到11颗)，而北斗现在仅对东南亚实现了全覆盖，计划在2020年左右，建成覆盖全球的北斗卫星导航系统。
3、基站定位
基站定位，基站定位也是很常见的定位方式了，它是基于三大通信运营商建立的基站来定位的，那么它的优缺点就很明显了，附近的基站点多，那么定位就准，如果站点少甚至没有，那就定位误差大，或者是无法定位。一般说来，不管基站点多少，基站的定位误差在几十米左右，误差大的有几百米。
4、WiFi定位
WiFi定位，WiFi定位其实是室内定位方式的一种，但随着WiFi在室外的大范围覆盖，它也渐渐在室外定位技术上得到很好的应用。wifi定位的原理，这里就不细讲了，技术上的东西说深了其实更难理解，我们只要知道，一般情况下，wifi热点（也就是AP，或者无线路由器）的位置都是固定的，热点只要通电，不管它怎么加密的，都一定会向周围发射信号，只需设备能够扫到wifi，不需要连接wifi，定位端就能把检测到的热点的信息发送给Skyhook（开发WiFi定位技术的公司）的服务器，服务器根据这些信息，查询、运算，就能知道客户端的具体位置了。WiFi定位的精度也是很高的，缺点是客户端必须能上网，而且附近必须有WiFi热点才行，离开大城市，这个功能就很难用到了。
5、蓝牙定位
蓝牙定位，使用蓝牙定位的限制比较多。主要是利用的是蓝牙4.0的beacon广播的功能，一般应用场合是在室内，定点布置beacon基站。
1.这些蓝牙beacon基站不断发送beacon广播报文（报文内含发射功率）。
2.搭载蓝牙4.0模块的终端设备收到beacon广播报文后，测量出接收功率，带入到功率衰减与距离关系的函数中，测算出距离该beacon基站的距离。
3.利用距离多个beacon基站的距离，即可实现多点定位的功能。
蓝牙定位的缺点很明显，需要附近有beacon基站发射信号，客户端需要打开蓝牙功能才能实现定位，而在生活中，这样的beacon基站是很少的，广大用户也没有一直开着蓝牙的习惯。
总结
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65196e349fdbe10237741d472d12b539/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b3905a6c71ffde27a238a1a1c80a7a/" rel="bookmark">
			Swift的日常一些笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：弹出框的自定义View，一个空白的view层，通过调用弹出此类 1.类文件DateSelectView
import UIKit class DateSelectView:UIView{ var commonView:UIView? // var commonViewCloseBlock: (() -&gt; Void)? let ALERTVIEW_HEIGHT = UIScreen.main.bounds.size.height / 2.4 let ALERTVIEW_WIDTH = UIScreen.main.bounds.size.width - 50 init() { let frame = CGRect(x: 0, y: 0, width: screenWidth, height: screenHeight) super.init(frame: frame) initView() } func initView(){ frame = UIScreen.main.bounds commonView = UIView(frame: CGRect(x: 25, y: screenHeight / 2 - ALERTVIEW_HEIGHT / 2, width: ALERTVIEW_WIDTH, height: ALERTVIEW_HEIGHT)) commonView!.backgroundColor = UIColor.white commonView!.layer.cornerRadius = 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25b3905a6c71ffde27a238a1a1c80a7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4278f9908bddccbcc48a6e1c403d5216/" rel="bookmark">
			超详细Zookeeper&#43;Kafka&#43;ELK集群部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Zookeeper 概述 1、Zookeeper 定义 Zookeeper是一个开源的分布式的，为分布式框架提供协调服务的Apache项目。
2、Zookeeper 工作机制 Zookeeper从设计模式角度来理解：是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应。也就是说 Zookeeper = 文件系统 + 通知机制。
3、Zookeeper 特点 （1）Zookeeper：一个领导者（Leader），多个跟随者（Follower）组成的集群。
（2）Zookeepe集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器。
（3）全局数据一致：每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。
（4）更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行，即先进先出。
（5）数据更新原子性，一次数据更新要么成功，要么失败。
（6）实时性，在一定时间范围内，Client能读到最新数据。
4、Zookeeper 数据结构 ZooKeeper数据模型的结构与Linux文件系统很类似，整体上可以看作是一棵树，每个节点称做一个ZNode。每一个ZNode默认能够存储1MB的数据，每个ZNode都可以通过其路径唯一标识。
5、Zookeeper 应用场景 提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。
●统一命名服务
在分布式环境下，经常需要对应用/服务进行统一命名，便于识别。例如：IP不容易记住，而域名容易记住。
●统一配置管理
（1）分布式环境下，配置文件同步非常常见。一般要求一个集群中，所有节点的配置信息是一致的，比如Kafka集群。对配置文件修改后，希望能够快速同步到各个节点上。
（2）配置管理可交由ZooKeeper实现。可将配置信息写入ZooKeeper上的一个Znode。各个客户端服务器监听这个Znode。一旦 Znode中的数据被修改，ZooKeeper将通知各个客户端服务器。
●统一集群管理
（1）分布式环境中，实时掌握每个节点的状态是必要的。可根据节点实时状态做出一些调整。
（2）ZooKeeper可以实现实时监控节点状态变化。可将节点信息写入ZooKeeper上的一个ZNode。监听这个ZNode可获取它的实时状态变化。
●服务器动态上下线
客户端能实时洞察到服务器上下线的变化。
●软负载均衡
在Zookeeper中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求。
6、Zookeeper 选举机制 ●第一次启动选举机制 （1）服务器1启动，发起一次选举。服务器1投自己一票。此时服务器1票数一票，不够半数以上（3票），选举无法完成，服务器1状态保持为LOOKING；
（2）服务器2启动，再发起一次选举。服务器1和2分别投自己一票并交换选票信息：此时服务器1发现服务器2的myid比自己目前投票推举的（服务器1）大，更改选票为推举服务器2。此时服务器1票数0票，服务器2票数2票，没有半数以上结果，选举无法完成，服务器1，2状态保持LOOKING
（3）服务器3启动，发起一次选举。此时服务器1和2都会更改选票为服务器3。此次投票结果：服务器1为0票，服务器2为0票，服务器3为3票。此时服务器3的票数已经超过半数，服务器3当选Leader。服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING；
（4）服务器4启动，发起一次选举。此时服务器1，2，3已经不是LOOKING状态，不会更改选票信息。交换选票信息结果：服务器3为3票，服务器4为1票。此时服务器4服从多数，更改选票信息为服务器3，并更改状态为FOLLOWING；
（5）服务器5启动，同4一样当小弟。
●非第一次启动选举机制 （1）当ZooKeeper 集群中的一台服务器出现以下两种情况之一时，就会开始进入Leader选举：
1）服务器初始化启动。
2）服务器运行期间无法和Leader保持连接。
（2）而当一台机器进入Leader选举流程时，当前集群也可能会处于以下两种状态：
1）集群中本来就已经存在一个Leader。
对于已经存在Leader的情况，机器试图去选举Leader时，会被告知当前服务器的Leader信息，对于该机器来说，仅仅需要和 Leader机器建立连接，并进行状态同步即可。
2）集群中确实不存在Leader。
假设ZooKeeper由5台服务器组成，SID分别为1、2、3、4、5，ZXID分别为8、8、8、7、7，并且此时SID为3的服务器是Leader。某一时刻，3和5服务器出现故障，因此开始进行Leader选举。
选举Leader规则：
1.EPOCH大的直接胜出
2.EPOCH相同，事务id大的胜出
3.事务id相同，服务器id大的胜出
-------------------------------------------------------------------------------------
SID：服务器ID。用来唯一标识一台ZooKeeper集群中的机器，每台机器不能重复，和myid一致。
ZXID：事务ID。ZXID是一个事务ID，用来标识一次服务器状态的变更。在某一时刻，集群中的每台机器的ZXID值不一定完全一致，这和ZooKeeper服务器对于客户端“更新请求”的处理逻辑速度有关。
Epoch：每个Leader任期的代号。没有Leader时同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加
二、部署 Zookeeper 集群 1、部署Zookeeper集群的操作步骤 准备 3 台服务器做 Zookeeper 集群
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4278f9908bddccbcc48a6e1c403d5216/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/632c0df845f31db66721c2dc1832a973/" rel="bookmark">
			30行python代码实现“代码雨”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 介绍 上手 python，很多人最先接触的就是pygame 包了，能在有一定趣味性的同时，建立起对 python 的基本认识。
提到编程，我想很多人的第一印象就是影片中的黑客形象，在黑色背景下敲击键盘，打出闪烁着绿光的字体，潜入破解一个个系统......
当然，真实情况与上述想象当然是毫不相干了，但是既然有了想象，为啥不去靠自己的尝试去实现一下呢？所以，我们这次就用非常简单的30行代码来实现一个代码雨的效果，满足一下我们的幻想和好奇心。
此次我们只是用pygame与random两个包，首先，将他们导入：​​​​​​
import pygameimport random 之后，我们进行pygame界面的初始化工作：
# 参数SCREENSIZE=(600,600)BLACK=(0,0,0,13)# 初始化pygame.init()font = pygame.font.SysFont('宋体', 20)screen = pygame.display.set_mode(SCREENSIZE)surface = pygame.Surface(SCREENSIZE, flags=pygame.SRCALPHA)pygame.Surface.convert(surface)surface.fill(BLACK)screen.fill(BLACK) 之后设置一下我们字体的相关内容：
# 内容lib=[chr(i) for i in range(48,48+10)] + [chr(i) for i in range(97,97+26)] # [0-9 a-z]texts = [font.render(l, True, (0, 255, 0)) for l in lib]cols = list(range(40)) # 字体15, 窗口600 最后在一个循环中，更新界面并绘制出代码雨：
while True: for event in pygame.event.get(): if event.type == pygame.QUIT: exit() pygame.time.delay(33) screen.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/632c0df845f31db66721c2dc1832a973/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19ae94e2b65fbbf0c1cb764e5bee4c1a/" rel="bookmark">
			Hive Aapche 设置为事务表（ACID）This command is not allowed on an ACID table xxx with a non-ACID transaction
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Hive中默认的创建的表为非事务表，如果需要将表设置为事务表需要修改以下参数：
参数配置文件为hive-site.xml
&lt;property&gt; &lt;name&gt;hive.support.concurrency&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.txn.manager&lt;/name&gt; &lt;value&gt;org.apache.hadoop.hive.ql.lockmgr.DbTxnManager&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.compactor.initiator.on&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.compactor.worker.threads&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.create.as.insert.only&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.optimize.acid.meta.columns&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; 当表为事务表时，如果使用非事务的参数去执行SQL，会报如下错误：
Error: Error while compiling statement: FAILED: SemanticException [Error 10265]: This command is not allowed on an ACID table test_acid with a non-ACID transaction manager. Failed command: create table test_acid
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/74/">«</a>
	<span class="pagination__item pagination__item--current">75/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/76/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>