<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1ec49a87b85c83535da51adeee4d9b0/" rel="bookmark">
			C&#43;&#43; 学习——char * ,char a[ ],char ** ,char *a[] 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言中由于指针的灵活性，导致指针能代替数组使用，或者混合使用，这些导致了许多指针和数组的迷惑，因此，刻意再次深入探究了指针和数组这玩意儿，其他类型的数组比较简单，容易混淆的是字符数组和字符指针这两个。
1.数组的本质 数组是多个元素的集合，在内存中分布在地址相连的单元中，所以可以通过其下标访问不同单元的元素。。
2.指针。 指针也是一种变量，只不过它的内存单元中保存的是一个标识其他位置的地址。。由于地址也是整数，在64位平台下，指针默认为8位。(32位平台下，指针默认为4位)
3.指针的指向 指向的直接意思就是指针变量所保存的其他的地址单元中所存放的数据类型。
int * p ;//p 变量保存的地址所在内存单元中的数据类型为整型 float *q;// q变量保存的地址所在内存单元中的数据类型为浮点型 不论指向的数据类型为那种，指针变量其本身永远为整型，因为它保存的地址。
字符串赋给一个指针变量
char *s ; s = "China"; 4.字符数组 char str[10]; //定义了一个有十个元素的数组，元素类型为字符 char str[10] = {"hello world"};//初始化 C语言中没有真正的字符串类型，可以通过字符数组表示字符串，因为它的元素地址是连续的，这就足够了。
C语言中字符串常量的本质表示其实是一个地址，规定数组代表数组所在内存位置的首地址，也是 str[0]的地址，即str = &amp;str[0];
5.char * 与 char a[ ] char *s; char a[ ] ; a代表字符串的首地址，而s 这个指针也保存字符串的地址（其实首地址），即第一个字符的地址，这个地址单元中的数据是一个字符，
可以 s = a;但不能 a = s;
C语言中数组名可以复制给指针表示地址， 但是却不能赋给给数组名，它是一个常量类型，所以不能修改。。
当然也可以这样: char a [ ] = "hello"; char *s =a; for(int i= 0; i &lt; strlen(a) ; i++) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1ec49a87b85c83535da51adeee4d9b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2dc8fed46d2c603c9b1538ae57f85c7/" rel="bookmark">
			安装了Volar插件vue文件没有显示Volar的图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3官网 推荐使用Volar来替换Vetur
一、安装Volar 安装Volar前：
安装Volar后：
二、安装Volar插件后，无法显示高亮 之前我安装Volar插件后，vue文件的&lt;script&gt;、&lt;template&gt;、&lt;style&gt;标签仍然是白色的，无法显示高亮，然后我把和vue相关的插件都卸载了，重新安装Volar插件就可以了。
三、安装了Volar插件，vue文件没有显示图标 解决办法：
点击vscode左下角的设置，搜索Split Editors，找到Volar，勾选下面圈出来的配置项
可以看到vue文件的右上角有下面这个图标：
点击那个图标，可以看到下面的代码效果：&lt;template&gt;标签的内容全部被复制到右侧面板，体现了Volar的拆分功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b2d3e5c770ff95f1de857fbc3eb91ec/" rel="bookmark">
			Java电商秒杀系统项目笔记（不断完善中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要业务包括用户的注册、登录；商品的创建、商品详细信息的展示、单个商品的详情与下单。采用前后端分离的设计思想，使用Ajax进行交互
后端：SpringBoot + Mybatis + Mysql + Redis + Nginx + RocketMQ
前端：Html + CSS + JS
部署在阿里云服务器上面。
项目源码地址：Gitee
MySQL数据库设计 主键查询：千万级别数据 = 1-10 毫秒唯一索引查询：千万级别数据 = 10-100 毫秒非唯一索引查询：千万级别数据 = 100-1000 毫秒无索引：百万条数据 = 1000 毫秒+ 表结构 用户信息表：user_info（id、name、gender、age、telephone）用户密码表：uesr_password（id、encrypte_password、user_id）商品信息表：item（id、title、price、description、sales、img_url）商品库存表：item_stock（id、stock、item_id）活动商品信息表：promo（id、promo_name、start_time、end_time、item_id、promo_item_price）订单信息表：order_info（id、user_id、item_id、promo_id、item_price、amount、order_price）序列号信息表：sequence_info（name、current_value、step）库存流水表：stock_log_id（stock_log_id、item_id、amount、status） 💡 用户信息表（user_info）存放用户的个人信息，用户密码表（uesr_password）存放用户加密后的密码。密码和用户的主表信息分开存储，一是方便管理、二是一般企业级项目中密码可能会由第三方管理平台托管。
💡 库存流水表（stock_log_id）用于在 RocketMQ 调用 checkLocalTransaction() 方法时判断消息的下一步操作（回滚还是提交）
系统设计 系统设计遵从领域模型的分层设计思想
接入层（View Object）：与前端对接的模型，隐藏内部实现，供展示的聚合模型。
View Object：返回给前端的业务模型，保证了 UI 只使用到需要展示的字段业务层（Domain Model）：领域模型，业务核心模型，拥有生命周期，贫血并以服务输出能力。
Domain Model：核心领域模型。在 Service 层组装了核心的领域模型，真正意义上处理业务逻辑的模型。数据层（Data Object）：数据模型，同数据库映射，用以 ORM 方式操作数据库的能力模型。
Data Object：与数据库字段一一映射。负责数据存储到 Service 层的数据传输 用户模块 otp 短信获取otp 用户注册用户登录（建立 token 和用户登录态之间的联系，存入 Redis 中，实现分布式会话的管理） 商品模块 商品创建商品列表页展示商品详情页展示（多级缓存的实现：先从本地缓存中查找商品详情数据，未命中本地缓存，再从 Redis 中查询数据，未命中 Redis，就查询数据库返回数据，并同步到 Redis 和本地缓存中）发布活动商品（该接口用于上架活动商品，并将商品库存同步到 Redis 中，同时设置秒杀大闸的限制数字（秒杀令牌的发放数量） 订单模块 生成验证码（将验证码存储到 Redis 中，用于和用户输入的验证码进行校验）生成秒杀令牌（用户下单之前会调用此接口，获取秒杀令牌，拥有秒杀令牌的用户才能下单，秒杀令牌存放在 Redis 中）下单（RateLimiter 进行限流，校验用户登录信息，校验秒杀令牌信息。线程池队列泄洪，用来控制流量的大量涌入。初始化订单流水，之后就是真正的下单逻辑，使用 RocketMQ 事务型消息机制） ⭐️ 下单逻辑 用户点击商品详情页面的下单按钮，请求下单接口.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b2d3e5c770ff95f1de857fbc3eb91ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4af496fe67e44e2605c8fa2cd0c00d3/" rel="bookmark">
			图像分割模型性能的指标IOU与ACC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IOU（Intersection over Union）和ACC（Accuracy）是两种用于评估图像分割模型性能的指标。 IOU是指分割结果与真实分割结果之间的交集与并集之比。在图像分割中，我们通常将每个像素的预测标签与真实标签进行比较，然后计算它们之间的IOU。具体来说，对于每个类别，我们可以计算出它们在分割结果和真实结果中的像素数目，并计算它们之间的交集和并集。然后，我们可以将交集除以并集，得到该类别的IOU。最后，我们可以将所有类别的IOU求平均，得到整个图像的平均IOU。IOU越高，说明分割结果与真实结果越接近，分割性能越好。
ACC是指分割结果中正确分类的像素数与总像素数之比。在图像分割中，我们通常将每个像素的预测标签与真实标签进行比较，然后计算它们之间的正确率。具体来说，我们可以统计分割结果中与真实结果相同的像素数目，然后将它们除以总像素数，得到分割的准确率。ACC越高，说明分割结果中正确分类的像素越多，分割性能越好。
总之，IOU和ACC都是用于评估图像分割模型性能的指标。IOU主要用于衡量分割结果与真实结果之间的重合度，ACC主要用于衡量分割结果中正确分类的像素数。虽然这两个指标在某些情况下会有冲突，但它们都可以提供有用的信息，帮助我们评估和改进图像分割算法的性能。
aAcc、mIoU和mAcc是三种常用的图像分割模型指标，用于评估模型在不同类别下的性能表现。 aAcc（Average Accuracy）是指模型在所有类别中的像素分类正确率的平均值。具体来说，对于每个类别，我们可以计算出它们在分割结果和真实结果中的像素数目，然后计算分类正确的像素数目，最后将所有类别的像素分类正确率求平均。aAcc可以用来评估模型整体的分类准确率，但它不能反映出不同类别之间的性能差异。
mIoU（Mean Intersection over Union）是指所有类别的IOU的平均值。在图像分割中，我们通常将每个像素的预测标签与真实标签进行比较，然后计算它们之间的IOU。对于每个类别，我们可以计算出它们在分割结果和真实结果中的像素数目，并计算它们之间的交集和并集。然后，我们可以将交集除以并集，得到该类别的IOU。最后，我们可以将所有类别的IOU求平均，得到整个图像的平均IOU。mIoU可以用来评估模型在不同类别之间的性能差异，越高表示模型在不同类别上的分割性能越好。
mAcc（Mean Accuracy）是指所有类别的像素分类正确率的平均值。具体来说，对于每个类别，我们可以计算出它们在分割结果和真实结果中的像素数目，然后计算分类正确的像素数目。最后，我们可以将所有类别的像素分类正确率求平均，得到整个图像的平均像素分类正确率。mAcc可以用来评估模型在不同类别之间的性能差异，并且能够反映出模型在像素分类方面的整体性能。
总之，aAcc、mIoU和mAcc都是常用的图像分割模型指标。aAcc用于评估模型整体的分类准确率，mIoU用于评估模型在不同类别之间的性能差异，mAcc用于评估模型在像素分类方面的整体性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d08e907a5722d45929f470c91a506d88/" rel="bookmark">
			【Pytorch基础】torch.nn.CrossEntropyLoss损失函数介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 交叉熵的定义2 交叉熵的数学原理3 Pytorch交叉熵实现3.1 举个栗子3.2 Pytorch实现3.3 F.cross_entropy 4 参考文献 1 交叉熵的定义 交叉熵主要是用来判定实际的输出与期望的输出的接近程度，为什么这么说呢，举个例子：在做分类的训练的时候，如果一个样本属于第K类，那么这个类别所对应的输出节点的输出值应该为1，而其他节点的输出都为0，即[0,0,1,0,….0,0]，这个数组也就是样本的Label，是神经网络最期望的输出结果。也就是说用它来衡量网络的输出与标签的差异，利用这种差异经过反向传播去更新网络参数。参考文献【1】
2 交叉熵的数学原理 Pytorch常用的交叉熵损失函数CrossEntropyLoss()详解
3 Pytorch交叉熵实现 3.1 举个栗子 交叉熵损失，是分类任务中最常用的一个损失函数。在Pytorch中是基于下面的公式实现的。
Loss ⁡ ( x ^ , x ) = − ∑ i = 1 n x log ⁡ ( x ^ ) \operatorname{Loss}(\hat{x}, x)=-\sum_{i=1}^{n} x \log (\hat{x}) Loss(x^,x)=−i=1∑n​xlog(x^)
其中 x x x是真实标签, x ^ \hat{x} x^ 是预测的类分布（通常是使用softmax将模 型输出转换为概率分布)。
取单个样本举例， 假设 x 1 = [ 0 , 1 , 0 ] x_1=[0, 1, 0] x1​=[0,1,0], 模型预测样本 x 1 x_1 x1​的概率为 x 1 ^ = [ 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d08e907a5722d45929f470c91a506d88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c33ebbd2c1572a1c3b74fd0452b5051/" rel="bookmark">
			【计算机考研408】快速排序的趟数问题 &#43; PAT 甲级 7-2 The Second Run of Quicksort
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 该题还未加入PAT甲级题库中，可以通过购买2022年秋季甲级考试进行答题，纯考研题改编
快速排序 常考的知识点 快速排序是基于分治法快速排序是所有内部排序算法中平均性能最优的排序算法快速排序是一种不稳定的排序算法快速排序算法中，不产生有序子序列，但每趟排序后会将枢轴元素放到其最终位置上 基于分治的思想，主要由两个步
1）划分
2）排序
代码 void QSort(int A[], int L, int R){ if(L &gt;= R) return; int key = A[L + R &gt;&gt; 1];	//选取L，R中间的元素作为基准 int i = L - 1, j = R + 1; whiLe(i &lt; j){ do i ++; whiLe(A[i] &lt; key); //左指针右移，找到比基准大的数 do j --; whiLe(A[j] &gt; key); //右指针左移，找到比基准小的数 if(i &lt; j) swap(A,i,j);	//交换A[i]和A[j] } QSort(A, L ,j); QSort(A, j + 1, R); } void quicksort(int a[], int low, int high){ if (low &lt; high){ int pos = partition(a, low, high); quicksort(a, low, pos-1); quicksort(a, pos+1, high); } } //partition是一趟排序 int partition(int a[], int low, int high){ int pos = a[low];//将表中第一个元素设置位枢轴 while(low &lt; high){ //从右边找到第一个比枢轴值小的 while(low &lt; high &amp;&amp; a[high] &gt;= pos) --high; a[low] = a[high]; while(low &lt; high &amp;&amp; a[low] &gt;= pos) ++low; a[high] = a[low]; } a[low] = pos; return low; } 题源-2019年考研选择题 分析 两次排序，说明起码有两个中枢元素在最终的位置上，若小于两个元素在最终位置上，那么一定不是两趟快速排序若出现两个或者两个以上的元素位于最终位置上，那么起码有一个元素要位于序列的第一个位置或者是最后一个位置 注意题目中的提示，两种类型的题目，（1）分类讨论直接有结果的（2）模拟流程进行解答
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c33ebbd2c1572a1c3b74fd0452b5051/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7181189c218b0357f8d1c588bc1cba5/" rel="bookmark">
			Gradle exclude排除指定依赖的办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在某些场景需要替换掉框架中自带的依赖，然后注入其他第三方依赖。
Maven工程很容易实现这一点，只要简单修改pom文件就行了。
但是在gradle当中应该如何实现？
由于gradle官方文档实在写的太烂，很难从中找到理想的答案。
然后谷歌搜索了很多资料，也没有看到想要的东西，最后查阅大量的资料以后，然后通过多次试验终于找到了有效的解决办法：
在build.gradle文件中加入以下内容：
configurations.implementation { exclude group: '${GroupId}' module: '${$artifactId}' // 例如下面的这样： exclude group: 'com.fasterxml.jackson.core', module: 'jackson-databind' //} 解释一下：exclude后面的group相当于maven中的groupId, module相当于maven中的artifactId
注意： 这里不可以使用exclude的kotlin函数式写法 ！下面的写法是无效的！
//注意： 下面的kotlin函数式写法是无效的 exclude(group: 'org.springframework.boot', module: 'spring-boot-starter-json') 然后看效果, exclude之前：
exclude以后： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e9c8e5dc2946024d51a868b79169072/" rel="bookmark">
			＜ 每日小技巧： 基于Vue状态的过渡动画 - Transition 和 TransitionGroup＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		》基于Vue状态的过渡动画 - Transition 和 TransitionGroup 👉 一、Vue Transition 简介&gt; Transition 和 TransitionGroup 之间的区别 👉 二、`&lt;Transition&gt;` 组件&gt; 触发 `&lt;Transition&gt;` 组件的场景：&gt; 基于 CSS 的过渡效果&gt; 基础案例&gt; 进阶案例&gt; 自定义过渡 class&gt; 过渡动画 - JavaScript 钩子 （Events） 👉 三、`&lt;TransitionGroup&gt;` 组件&gt; 基于 CSS 的过渡效果&gt; 基础案例 📃 梳理文献往期内容 💨 👉 一、Vue Transition 简介 Vue 提供了两个内置组件，可以帮助用户制作基于状态（v-if / v-show）变化的过渡和动画：
&lt;Transition&gt; 会在一个元素或组件进入和离开 DOM 时应用动画。本章节会介绍如何使用它。
&lt;TransitionGroup&gt; 会在一个 v-for 列表中的元素或组件被插入，移动，或移除时应用动画。
&gt; Transition 和 TransitionGroup 之间的区别 &lt;TransitionGroup&gt; 支持和 &lt;Transition&gt; 基本相同的 props、CSS 过渡 class 和 JavaScript 钩子监听器，但有以下几点区别：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e9c8e5dc2946024d51a868b79169072/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1565ec8361eefaec6f1d564bf2d0d8e7/" rel="bookmark">
			JavaScript中的异步编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们在编写JavaScript代码时，经常会遇到需要执行长时间运行的任务的情况，例如从服务器获取数据或进行复杂的计算。在这些情况下，我们不希望阻塞用户界面，因为这会使网站看起来卡顿，甚至无响应。为了避免这种情况，我们需要使用JavaScript中的异步编程技术。
异步编程是JavaScript中的一个核心概念，它使我们能够在执行长时间运行的任务时不会阻塞用户界面，而是在任务完成后立即返回结果。本文将介绍JavaScript中的异步编程方式，并探讨它们的优缺点，以及如何使用它们来解决常见的异步编程问题。
一、回调函数
回调函数是JavaScript中最早和最基本的异步编程方式。它通过在函数参数中传递一个函数，让我们能够在异步操作完成后调用该函数。例如，我们可以使用XMLHttpRequest对象从服务器获取数据：
var xhr = new XMLHttpRequest(); xhr.open('GET', 'https://example.com/data'); xhr.onreadystatechange = function() { if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) { console.log(xhr.responseText); } }; xhr.send(); 在上面的例子中，我们定义了一个XMLHttpRequest对象，然后使用open()方法设置请求的类型和URL。然后，我们为onreadystatechange属性指定了一个函数，当readyState属性变为4且状态码为200时，该函数将被调用。在该函数中，我们可以访问响应文本并在控制台中打印它。
虽然回调函数是JavaScript中最早和最基本的异步编程方式，但它有一些缺点。首先，如果我们需要进行嵌套异步操作，回调函数将变得非常复杂和难以理解。其次，回调函数容易出现回调地狱问题，这是指代码中有太多的回调函数，使得代码难以维护和扩展。
二、Promise
为了解决回调地狱问题，JavaScript引入了Promise，它是一种更加高级的异步编程方式。Promise通过将异步操作的结果封装在一个对象中，使得我们可以更加清晰和简洁地处理异步操作。例如，我们可以使用Promise从服务器获取数据：
fetch('https://example.com/data') .then(response =&gt; response.text()) .then(text =&gt; console.log(text)) .catch(error =&gt; console.error(error)); 在上面的例子中，我们使用fetch()方法发起一个HTTP请求，并将其封装在一个Promise对象中。然后，我们使用.then()方法指定一个函数，当Promise对象的状态变为fulfilled时将被调用。在这个函数中，我们可以访问响应对象并将其转换为文本。然后，我们使用.then()方法指定另一个函数，当上一个Promise对象的状态变为fulfilled时将被调用。在这个函数中，我们可以访问响应文本并在控制台中打印它。最后，我们使用.catch()方法指定一个函数，当Promise对象的状态变为rejected时将被调用。在这个函数中，我们可以处理错误。
Promise还提供了一些其他的方法，如Promise.all()和Promise.race()。Promise.all()可以同时处理多个Promise对象，并在所有Promise对象都变为fulfilled时返回一个包含所有结果的数组。例如：
Promise.all([ fetch('https://example.com/data1'), fetch('https://example.com/data2') ]) .then(responses =&gt; Promise.all(responses.map(response =&gt; response.text()))) .then(texts =&gt; console.log(texts)) .catch(error =&gt; console.error(error)); 在上面的例子中，我们使用Promise.all()方法同时发起两个HTTP请求，并将它们封装在一个数组中。然后，我们使用.then()方法指定一个函数，该函数将结果数组作为参数，并使用Promise.all()方法将结果数组中的所有响应对象转换为文本。最后，我们使用.then()方法指定另一个函数，该函数将文本数组作为参数并在控制台中打印它们。
Promise.race()可以处理多个Promise对象，并在第一个Promise对象变为fulfilled或rejected时返回它的结果。例如：
Promise.race([ new Promise(resolve =&gt; setTimeout(() =&gt; resolve('foo'), 2000)), new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error('bar')), 1000)) ]) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1565ec8361eefaec6f1d564bf2d0d8e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/446bc0b02caa1aa9fe7ff88d0cf20a6a/" rel="bookmark">
			几何图形的继承和派生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题描述】已知下面Shape类的定义，在此基础上派生出Rectangle和Circle类，二者都有GetArea()函数，用于计算对象的面积。再使用Rectangle类创建一个派生类Square。
自行根据需要定义相关的成员，达到以下要求：
（1）达到以上题目所规定的类族要求。
（2）编写主函数，能够动态生成半径为5的圆对象的创建，并实现面积计算和输出。
（3）主函数中能动态生成长为4，宽为6的矩形对象创建，并实现面积计算和输出。
（4）主函数中能动态生成边为5的正方形对象创建，并实现面积计算和输出。
（5）完成上述动态对象的释放。
【输入形式】无输入。
【输出形式】分别输出指定圆、长方形和正方形的面积。
【样例输入】无输入
【样例输出】
The area of the Cirele is:78.5
The area of the Recanale is:24
The area of the Recanale is:25
【程序说明】该程序可使用虚函数相关的知识。
#include&lt;bits/stdc++.h&gt; using namespace std; #define PI 3.14 //抽象类 class Shape{ public : virtual double GetArea()=0;//纯虚函数 }; //矩形类 class Rectangle : public Shape { private : double chang,kuan; public : //构造函数 Rectangle(double c,double k) :chang(c),kuan(k){} double GetArea() { return chang*kuan;//派生类中需要重现虚函数 } }; //正方形类 class Square : public Rectangle {	public : Square(double bian) :Rectangle(bian,bian){} }; //圆类 class Circle : public Shape { private : double radius; public : Circle(double r) : radius(r){} double GetArea(){ return PI*radius*radius; } }; int main(){ Shape *shape1=new Circle (5);//动态生成 cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/446bc0b02caa1aa9fe7ff88d0cf20a6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/251a63a193301774d6e9b00a0b83c60c/" rel="bookmark">
			派生对象和基类对象指针的使用（类型兼容性规则）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题描述】声明-个基类BaseClass,从它派生出类DerivedClass,BaseClass有成员2数fnl()、fn2(),DerivedClass也有成员函数fnl()、fn2(),在主函数中声明向DerivedClass的对象，分别用DerivedClass的对象以及BaseClass和DerivedClass的指针来调用fnl()、fn2(),观察运行结果。
【输入形式】无输入。
【输出形式】分别输出调用指定函数之后的指定信息。
【样例输入】无输入
【样例输出】
the fn1 founction of the DerivedClass
the fn2 founction of the DerivedClass
the fn1 founction of the baseclass
the fn2 founction of the baseclass
the fn1 founction of the DerivedClass
the fn2 founction of the DerivedClass
【程序说明】各个函数的实现中，只需要有相应的函数调用输出信息就可以了。
主函数中函数调用的依次为：DerivedClass对象调用函数fnl()、fn2()；BaseClass类型指针指向DerivedClass对象调用函数fnl()、fn2()；DerivedClass类型指针指向DerivedClass对象调用fnl()、fn2()；
需要仔细观察调用的输出信息，理解类型兼容性原则和指向对象的指针。
#include&lt;iostream&gt; using namespace std; //基类 class BaseClass { public: void fn1() { cout &lt;&lt; "the fn1 founction of the baseclass\n"; } void fn2() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/251a63a193301774d6e9b00a0b83c60c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f660370b5622260f5162760c92846310/" rel="bookmark">
			DNS服务器详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 安装DNS服务器。单击“开始→控制面板→添加或删除程序→添加或删除windows组件→选中网络服务→点击下面的详细信息→域名系统（DNS）→确定”。 2. 配置DNS服务器。 （1）新建正向查找区域。点击“服务器→右击正向查找区域→新建区域”，设置区域名称html.com，后面的直接下一步；
（2）新建主机。右击区域名称（html.com）→新建主机，设置名称：www，IP地址：192.168.1.201；
（3）新建反向查找区域。右击反向查找区域→新建区域，设置网络ID：192.168.1，直接下一步；
（4）新建指针。右击区域（192.168.1.X Subnet），设置主机IP号：201，主机名：www（点击浏览，一直双击，然后选择www）；
3. 设置Windows Server 2003的网络IP（虚拟机），IP和DNS：192.168.1.201，子网掩码：255.255.255.0； 4. 设置物理主机的IP地址（VMnet8）。点击任务栏右边的网络图标→网络和Internet设置→更改适配器设置→右击VMnet8→属性→双击IPv4，设置IP：192.168.1.10，网关：192.168.1.0，子网掩码：255.255.255.0，DNS：192.168.1.201。 5. 测试 （1）ping www.html.com或ping 192.168.1.201；
（2）nslookup www.html.com 或 nslookup 192.168.1.201；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b1cd30273a8d7044cb0319925af081e/" rel="bookmark">
			el-table让选中的行变色，几种情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：点击《el-table》让选中的行变色，亲测实用_怎么实现网页表格的某一行点击后变颜色_0.活在风浪里的博客-CSDN博客
设置点击某一行，改行背景色改变：
给el-table设置 highlight-current-row属性
在style中设置选中行的颜色
/* 用来设置当前页面element全局table 选中某行时的背景色*/
.el-table__body tr.current-row&gt;td{
background-color: #ff784a !important;
color: #fff;
}
设置鼠标移上行的背景色：
// 修改鼠标经过表格的颜色
/deep/ .el-table tbody tr:hover &gt; td {
// background-color: rebeccapurple !important;
// color: #ffffff;
// 可以选择隐藏
background-color: transparent !important
}
或
::v-deep .el-table__body tr:hover &gt; td {
background-color: #cd9f9f!important;
color: #ffffff;
}
点击某一事件表格背景色变化
比如点击行内的编辑按钮时，背景色变化；而我单独点击行时，背景色不变化；
给编辑按钮添加点击事件，存储当前编辑的行。
给表格绑定row-style属性
row-style="isRed" 还有一些其他的选中行操作：
https://www.cnblogs.com/Amerys/p/14688342.html
element ui表格多选修改背景色_elementui表单多选选中项背景色_路边蹲着看美女的博客-CSDN博客
https://blog.csdn.net/luoxuebinfei/article/details/123366501
注意：toggleRowSelection如果没有第二个参数，则点击行 复选框选中，再次点击复选框不被选中。如果有第二个参数为true, 则无论点击多少次，复选框均为选中状态
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be65d3d960c8b98b393e353e2953fa0a/" rel="bookmark">
			基于ELK&#43;Kafka构建分布式日志采集系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、分布式日志采集产生背景二、ELK+Kafka组成elk+kafka原理为什么ELK需要结合KafkaELK+Kafka环境构建验证elk+kafka 环境安装 logstash 三、springboot项目整合elk+kafkamaven依赖aop拦截系统日志配置文件内容在kibana页面查看日志 一、分布式日志采集产生背景 1.传统日志采集存在哪些缺点
2.elk+kafka日志采集的原理
3.基于docker compose 安装elk+kafka环境
4.基于AOP+并发队列实现日志的采集
在传统项目中，如果在生产环境中，有多台不同的服务器集群，如果生产环境需要通过日志定位项目的Bug的话，需要在每台节点上使用传统的命令方式查询，这样效率非常低下。
因此我们需要集中化的管理日志，ELK则应运而生。
传统方式服务器搜索日志命令：tail -200f 日志文件名称
二、ELK+Kafka组成 Elk E= ElasticSeach（存储日志信息）
l Logstash(搬运工)
K Kibana连接到我们ElasticSeach图形化界面查询日志
Elk+kafka实现分布式日志采集
为什么需要将日志存储在ElasticSeach 而不是MySQL中呢
ElasticSeach 底层使用到倒排索引存储数据 ，在 搜索日志效率比mysql要高的。
elk+kafka原理 springboot项目会基于aop的方式拦截系统中日志，请求与响应日志信息—前置或者环绕通知；将该日志投递到我们kafka中 注意该过程一定要是异步的形式，如果是同步形式会影响到整体
接口的响应速度。Logstash 数据源—kafka 订阅kafka的主题 获取日志消息内容Logstash 在将日志消息内容输出到es中存放开发者使用Kibana连接到ElasticSeach 查询存储日志内容。 为什么ELK需要结合Kafka 如果只整合elk 不结合kafka这样的话 每个服务器节点上都会安装Logstash做读写日志IO操作，可能性能不是很好，而且比较冗余。
ELK+Kafka环境构建 整个环境采用 docker compose 来实现构建
注意：环境 cpu 多核 内存 4GB以上
创建docker-compose.yml
version: '2' services: zookeeper: image: wurstmeister/zookeeper ports: - "2181:2181" restart: always kafka: image: wurstmeister/kafka:2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be65d3d960c8b98b393e353e2953fa0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c402fd41d1249edf3160006008226395/" rel="bookmark">
			适合女生从事的IT职业，前途美美光明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着行业的不断发展，越来越多的女性也思考转行学习IT。不过，有些女性可能会担心找不到适合自己的专业方向，毕竟在潜意识里，IT似乎是一个男性占主导的领域。但实际上，女生在互联网行业中有很多值得学习的方向。女性参与IT产业非常酷！下面就为大家简单盘点一下女生在互联网行业中的学习方向。
1️⃣UI设计
UI设计非常注重细节和美感，女性在视觉美感、色彩搭配方面往往更加敏感。因此，在UI设计中，注重细节和美感等因素对于吸引女性用户非常重要。女性设计师能够更好地把握用户的需求和喜好，并在设计过程中更加注重每一个细节，使得界面更加精致。
2️⃣软件测试
女生天生具备细心、耐心和责任心等特质，在软件测试这个需要耐心和细致的工作中 ，女生能够表现出色。女生在团队协作中更容易与人沟通和协调，能够更好地与其他团队成员合作完成任务。
不过在学习的时候难免会使用到一些测试的工具，我刚开始学的适合就在多御浏览器里找在线工具使用，里面有一个互联网网络安全栏目，里面有一些测试的时候回用到工具，可以直接在线使用，十分方便。
3️⃣web前端开发
Web前端是一个极具创造性的领域，女性通常以她们在设计和美学方面的优势，表现出色。同时，Web前端工作需要高度的沟通和协作能力，而女性则天生擅长与人交流和合作，因而很容易在团队中脱颖而出。此外，Web前端行业重视用户体验和可访问性，符合女性对于细节和关注用户需求的敏感度，有利于她们展示自己的才华。总之，女性在学习Web前端方面有很多优势，只要充分发挥自己的特长和才能，就能够取得成功。
总之，女生是非常适合学习IT的❗️❗️❗️
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5b677bab17f96a4e351c825e005e2d3/" rel="bookmark">
			VUE2 &#43; ElementUI 将Table数据导出为Excel文件——vue-json-excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VUE2 + ElementUI 将Table数据导出为Excel文件——vue-json-excel 最近做前端开发遇到一个需求，需要实现在前端将table里的数据导出问excel文件
于是在网上查了好几种方式，但是都不是很好用，最后看中了vue-json-excel这个组件
在此记录一下，方便以后查询
方案一 通过js动态创建一个下载按钮实现下载 这是在网上找到的第一种方式，我尝试了一下只能实现下载下来，得到的却不是excel，而是一堆Object，代码如下：
let url = window.URL.createObjectURL(new Blob(this.tableData)) let link= document.createElement('a') link.style.display='none' link.href=url let filename = this.tableDataType + '.xlsx'; link.setAttribute('download', filename) document.body.appendChild(link) link.click() 结果如下：
原文链接：https://blog.csdn.net/nanchen_J/article/details/123134430
方案二 通过xlsx和file-saver插件实现导出Excel 安装依赖
npm install file-saver npm install xlsx 在main.js中设置全局配置
该步骤可以省略，加入全局配置只是方便复用
// vue中导出excel表格模板 import FileSaver from 'file-saver' import XLSX from 'xlsx' Vue.prototype.$FileSaver = FileSaver; //设置全局 Vue.prototype.$XLSX = XLSX; //设置全局 方法实现
exportExcel() { // table 是表格组件的ID let tables = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5b677bab17f96a4e351c825e005e2d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b54e000d0a7c8aeb3093d7da0175772/" rel="bookmark">
			json-server的使用从入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地数据接口 —— json-server 从入门到膨胀 如果不想自己在本地搭环境，还可以使用 《前端需要的免费在线api接口》 里推荐的几个线上接口平台，里面包括常用的 json 结构数据和图片。
虽然有线上的免费接口可以测试，但需要自定义接口和数据的时候，还是本地模拟数据比较适合前端开发者。
本文分 入门篇 和 进阶篇。再往下滑一点就能看到全文目录。
入门篇： 5分钟内带你实现 本地环境搭建 和 增删改查 操作，满足入门测试使用。
进阶篇： 主要讲解常用的 查询操作，除此之外还包括 常规配置、静态资源配置 等知识点。这部分有点长，建议收藏。
本文约定
本文主要面向的读者是 前端小白，几乎不会涉及到后端知识，所以并不打算讲解 json-server 中间件 的内容。
本文讲到的所有知识点都会提供对应的代码展示（会比官方文档详细点）。
本文使用 postman 测试，希望能照顾到使用不同工具库做数据请求的读者（我知道还有只懂 jQuery 的开发者）。
特殊情况会使用 axios 配合演示。
点赞 + 收藏 = 学会了
目录
思维导图.png
入门 json-server简介 npm地址 | github地址
Get a full fake REST API with zero coding in less than 30 seconds (seriously)
引用了官方的一句话，大概意思是30秒就能获得一套完整的模拟 REST API 接口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b54e000d0a7c8aeb3093d7da0175772/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f16c1caaa7498d83c9d4f6232b9e1391/" rel="bookmark">
			Copilot使用教程：让AI助手提升你的编程效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenAI推出的Copilot是一个基于GPT-4的代码生成器，它可以帮助你在编写代码时给出智能建议，从而提高你的编程效率。
文章目录
什么是CopilotCopilot的安装与配置Copilot的基本功能Copilot实战案例Copilot的优势和局限性Copilot的未来发展 什么是Copilot Copilot是由OpenAI开发的一款人工智能编程助手，它利用了最先进的GPT-4技术来帮助开发者更轻松地编写代码。通过与各种代码编辑器（如VS Code，Atom等）集成，Copilot可以实时地为用户提供代码建议、函数签名、注释等。这使得开发者可以在编程过程中更加专注于解决实际问题，而不是花费大量时间编写或查找相应的代码。
Copilot的安装与配置 在这一部分，我们将介绍如何安装和配置Copilot。我们以VS Code编辑器为例，讲解如何在VS Code中安装和使用Copilot。
安装步骤 打开VS Code编辑器，点击左侧边栏中的Extensions按钮，或者按下快捷键Ctrl+Shift+X。
在搜索框中输入"Copilot"，找到OpenAI Copilot插件，并点击安装。
配置 在安装Copilot插件后，首次使用前需要进行简单的配置。请按照以下步骤完成配置：
点击VS Code左下角的设置按钮，选择"Settings"。在搜索框中输入"copilot"，找到Copilot相关设置。为了获得更好的使用体验，你可以根据自己的需要调整如下设置：
- Copilot提示的延迟时间
- 是否在保存时自动格式化代码
- 是否显示注释等 完成配置后，点击右上角的关闭按钮，返回代码编辑界面完成配置后，点击右上角的关闭按钮，返回代码编辑界面 Copilot的基本功能 在这一部分，我们将详细介绍Copilot的几个基本功能，包括：
自动补全代码 当你在编写代码时，Copilot会根据当前的上下文，实时地为你提供代码补全建议。例如，在编写Python代码时，你只需要输入几个字符，Copilot就会智能地给出可能的补全选项。你可以用键盘方向键或鼠标来选择补全项，然后按下Tab或Enter键，即可将补全项插入到代码中。
自动生成函数签名 在编写函数时，Copilot可以帮助你生成函数签名。例如，当你在编写一个计算两个数之和的函数时，只需输入def add，Copilot会自动给出一个函数签名建议，如def add(a: int, b: int) -&gt; int:。这样，你可以更快地完成函数定义，并专注于函数的实现。
自动生成注释 良好的注释是代码可读性的保证。然而，在实际编程过程中，很多开发者可能会忽略注释的重要性。有了Copilot，你无需担心这个问题。当你在编写代码时，Copilot会根据代码的功能自动生成相应的注释。例如，在编写一个文件操作函数时，Copilot会自动为你生成如下注释：
# This function reads the content of a file and returns it as a string. def read_file(file_path: str) -&gt; str: ... Copilot实战案例 接下来，我们将通过一个实战案例来展示Copilot如何帮助你提高编程效率。假设我们需要编写一个Python程序，实现一个简单的学生信息管理系统。在这个案例中，我们将使用Copilot完成以下功能：
定义一个学生类（Student）实现学生信息的增加、删除、修改和查询功能将学生信息保存到文件，并从文件中读取学生信息 定义一个学生类 首先，我们需要定义一个学生类来存储学生的信息。在编写类的定义时，Copilot会自动为我们生成属性和方法签名。例如，我们可以输入如下代码：
class Student: 然后，Copilot会自动补全属性和方法签名，如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f16c1caaa7498d83c9d4f6232b9e1391/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7827f2e15a6c9d5a2723016a31dbaf24/" rel="bookmark">
			element-ui 上传图片回显
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里是用element-ui组件 已经接收数据 让图片回显
&lt;el-form-item label="景区图片"&gt; &lt;el-upload list-type="picture-card" :action="'https://scienicpc.kuxia.top/pcapi/File/fileimg'" :on-change="handleChanges" :before-remove="beforeRemove" :on-preview="handlePictureCardPreview" :file-list="img" multiple limit="1" name="img" v-model="formLabelAligns.img"&gt; &lt;el-icon class="avatar-uploader-icon"&gt; &lt;Plus /&gt; &lt;/el-icon&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; 注意组件里的 :file-list='img' 这里 这里是回显的关键 有可能你的接口数据获取的是图片链接 没有办法直接在本地显示 在这里要做一个链接处理
//声明一个变量 const img = ref([]) //这里是你的图片的链接格式 需要添加url格式 img.value.push({ url: id.s_img }) 获取到你的图片之后 转一下格式 在:file-list='img'更改你后面引号里的数据 就可以做到回显效果啦
如果点击多个会有多个照片 就在点击事件的时候设置一个空数组就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d247d54ab4f37992a53b9223829fdc96/" rel="bookmark">
			【Git 入门教程】第五节、Git远程仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git是一种分布式版本控制系统，它允许开发者在不同计算机之间协作并共享代码。在本文中，我们将介绍如何以Git为基础进行远程协作。其中包括克隆仓库、推送代码、拉取代码等操作。
一、克隆仓库 要协作开发一个Git项目，需要从服务器上获取该项目的副本。
运行以下命令来克隆Git仓库：
git clone &lt;url&gt; 其中，“url”是Git仓库的远程URL地址。此命令将下载Git仓库的完整副本到指定目录。
# 将远程仓库克隆到本地，形成本地仓库 git clone https://gitee.com/biyu/hello-chat-gpt.git 创建文件并提交到本地仓库
# 增加文件 git add test.txt # 提交文件 git commit -m 'test' 二、推送代码 一旦对代码进行更改并提交，就可以将代码推送回Git仓库。以下是如何将更改推送到Git仓库的步骤：
打开终端并导航到Git仓库目录。
运行以下命令将更改推送到Git仓库：
git push origin &lt;branch&gt; 其中，“branch”是要推送更改的分支名称。
# 同步远程仓库 # 远程仓库默认有个别名叫origin，将本地仓库的文件推送（push）到远程仓库 # git push 远程仓库别名 分支名称 git push origin master 查看日志
# 查看git日志 git log $ git log commit 273d9b34479c78bcf11fe3db84995b80ea2de835 (HEAD -&gt; master, origin/master, origin/HEAD) Author: xu** &lt;xu**@mail&gt; Date: Fri Apr 28 08:45:30 2023 +0800 create test file commit 4f44438458a4a980f7c676b436c3113eb834253c Author: biyu &lt;xu**_dev@163.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d247d54ab4f37992a53b9223829fdc96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8cd9cbfc6c38c8d9b24f22ba2733aae/" rel="bookmark">
			C编程-pta-打印菱形图案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本题要求编写程序，打印一个高度为n的、由“*”组成的正菱形图案。
输入格式: 输入在一行中给出一个正的奇数n。
输出格式: 输出由n行星号“*”组成的菱形，如样例所示。每个星号后跟一个空格。
输入样例: 7 输出样例: * * * * * * * * * * * * * * * * * * * * * * * * * 思路：
输出是菱形，就要分别确定行和列，所以首先对行使用一个for循环，再在行的里面嵌套一个列的循环。观察图案，如果使用循环，需要将图案分为上半部分和下半部分，然后寻找行，列，n，之间的关系，用条件语句阐述即可。
代码如下：
# include &lt;stdio.h&gt; int main () { int n, i, j; scanf ("%d", &amp;n); for (i=1; i&lt;=n; i++) { if (i&lt;=(n+1)/2)//图案上半边 {//两个for循环，先打印空格，之后再打印星号，这样就不用考虑星号的具体位置，剩余的空格不打印就行 for (j=1; j&lt;=(n+1)/2-i; j++)//图案上左半边 { printf (" "); } for (j=1; j&lt;=2*i-1; j++) { printf ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8cd9cbfc6c38c8d9b24f22ba2733aae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72f81101eb0a28eb0151a623276fbbe9/" rel="bookmark">
			Three.js教程：设置Geometry顶点位置、顶点颜色数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐：将 NSDT场景编辑器加入你的3D工具链 其他系列工具： NSDT简石数字孪生 前面几篇文章通过缓冲类型几何体BufferGeometry给大家讲解了顶点位置、颜色、法向量、索引数据，本节课给大家引入一个新的threejs几何体APIGeometry。几何体Geometry和缓冲类型几何体BufferGeometry表达的含义相同，只是对象的结构不同，Threejs渲染的时候会先把Geometry转化为BufferGeometry再解析几何体顶点数据进行渲染。
Vector3定义顶点位置坐标数据 Vector3是threejs的三维向量对象,可以通过Vector3对象表示一个顶点的xyz坐标，顶点的法线向量。
几何体Geometry的顶点位置属性geometry.vertices和缓冲类型几何体BufferGeometry顶点位置属性BufferGeometry.attributes.position是对应的。
var geometry = new THREE.Geometry(); //声明一个几何体对象Geometry var p1 = new THREE.Vector3(50, 0, 0); //顶点1坐标 var p2 = new THREE.Vector3(0, 70, 0); //顶点2坐标 var p3 = new THREE.Vector3(80, 70, 0); //顶点3坐标 //顶点坐标添加到geometry对象 geometry.vertices.push(p1, p2, p3); Color定义顶点颜色数据 通过threejs顶点颜色对象Color可以定义几何体顶点颜色数据，然后顶点颜色数据构成的数组作为几何体Geometry顶点颜色属性geometry.colors的值。
几何体Geometry的顶点颜色属性geometry.colors和缓冲类型几何体BufferGeometry顶点颜色属性BufferGeometry.attributes.color是对应的。
// Color对象表示顶点颜色数据 var color1 = new THREE.Color(0x00ff00); //顶点1颜色——绿色 var color2 = new THREE.Color(0xff0000); //顶点2颜色——红色 var color3 = new THREE.Color(0x0000ff); //顶点3颜色——蓝色 //顶点颜色数据添加到geometry对象 geometry.colors.push(color1, color2, color3); 注意设置几何体Geometry顶点颜色属性geometry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72f81101eb0a28eb0151a623276fbbe9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b170916416ee0a192d04f2af9573fd2/" rel="bookmark">
			西南交通大学算法分析与设计实验4.3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include "iostream" #include "algorithm" using namespace std; #define MAX 100 int map[MAX][MAX]; int n, position_x, position_y, ncount; void Search(int up, int down, int left, int right, int special_x, int special_y) { if (down - up &gt;= 3 || right - left &gt;= 3) { int mid_height = (up + down) / 2; int mid_width = (left + right) / 2; if (mid_height &gt;= special_x &amp;&amp; mid_width &gt;= special_y) { ncount++; map[mid_height + 1][mid_width] = ncount; map[mid_height + 1][mid_width + 1] = ncount; map[mid_height][mid_width + 1] = ncount; Search(up, mid_height, left, mid_width, special_x, special_y); Search(mid_height + 1, down, left, mid_width, mid_height + 1, mid_width); Search(up, mid_height, mid_width + 1, right, mid_height, mid_width + 1); Search(mid_height + 1, down, mid_width + 1, right, mid_height + 1, mid_width + 1); } else if (mid_height &gt;= special_x &amp;&amp; mid_width &lt; special_y) { ncount++; map[mid_height][mid_width] = ncount; map[mid_height + 1][mid_width + 1] = ncount; map[mid_height + 1][mid_width] = ncount; Search(up, mid_height, mid_width + 1, right, special_x, special_y); Search(up, mid_height, left, mid_width, mid_height, mid_width); Search(mid_height + 1, down, left, mid_width, mid_height + 1, mid_width); Search(mid_height + 1, down, mid_width + 1, right, mid_height + 1, mid_width + 1); } else if (mid_height &lt; special_x &amp;&amp; mid_width &gt;= special_y) { ncount++; map[mid_height][mid_width] = ncount; map[mid_height + 1][mid_width + 1] = ncount; map[mid_height][mid_width + 1] = ncount; Search(mid_height + 1, down, left, mid_width, special_x, special_y); Search(up, mid_height, mid_width + 1, right, mid_height, mid_width + 1); Search(up, mid_height, left, mid_width, mid_height, mid_width); Search(mid_height + 1, down, mid_width + 1, right, mid_height + 1, mid_width + 1); } else if (mid_height &lt; special_x &amp;&amp; mid_width &lt; special_y) { ncount++; map[mid_height + 1][mid_width] = ncount; map[mid_height][mid_width] = ncount; map[mid_height][mid_width + 1] = ncount; Search(mid_height + 1, down, mid_width + 1, right, special_x, special_y); Search(up, mid_height, mid_width + 1, right, mid_height, mid_width + 1); Search(up, mid_height, left, mid_width, mid_width, mid_height); Search(mid_height + 1, down, left, mid_width, mid_height + 1, mid_width); } } else { ncount++; for (int i = up; i &lt;= down; i++) { for (int j = left; j &lt;= right; j++) { if (i == special_x &amp;&amp; j == special_y) { continue; } else { map[i][j] = ncount; } } } return ; } } int main() { cin &gt;&gt; n &gt;&gt; position_x &gt;&gt; position_y; if (position_x &lt; 0 || position_y &lt; 0 || position_x &gt;= n || position_y &gt;= n || n % 2 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b170916416ee0a192d04f2af9573fd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69436a7c02907ad103a4d3c2bc53c4b1/" rel="bookmark">
			SystemUI流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
SystemUI类图
SystemUI流程一：SystemUI启动流程
SystemUI流程二：StatusBar创建流程
SystemUI流程三：系统Notification实现流程
附：应用Notification实现流程
源码基于 Android 12。
SystemUI 是 Android 的系统界面，在 Andorid 系统源码中，系统内置 app 一般放在 package/apps下，例如 settings，camera，Phone，Message 等等。而在 framework/base/package 下，它们也是系统的 app，SystemUI 就在此目录下。SystemUI 是系统应用，由 SystemServer 进程进行启动，入口 Application 为SystemUIApplication。常用UI组件有如下几个：
状态栏 StatusBar通知栏 NotificationPanel导航栏 NavigationBar最近任务 Recent键盘锁 Keyguard快捷按键栏 QSPanel SystemUI类图 SystemUI流程一：SystemUI启动流程 SystemUI流程二：StatusBar创建流程 SystemUI流程三：系统Notification实现流程 根布局：super_status_bar.xml；顶上状态栏： status_bar.xml, 通过CollapsedStatusBarFragment.java加载，PhoneStatusBarView(FrameLayout,)是里面的父控件，对应 R.id.status_bar_container ；下拉状态栏：（包括通知为status_bar_expanded.xml）,最外层布局NotificationPanelView。 通知显示过程：
super_status_bar.xmlstatus_bar.xmlsuper_notification_shade.xmlstatus_bar_expanded.xmlNotificationPanelViewNotificationsQuickSettingsContainerNotificationStackScrollLayout 以上从 SystemUI 大概类图，以及自身启动流程开始，到 StatusBar 创建流程，再到系统 Notification 实现流程，一步步去理解 SystemUI 的相关流程。
附：应用Notification实现流程 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/274c18edc9104b615a4adf63694e0f1f/" rel="bookmark">
			人工智能前沿——「全域全知全能」人类新宇宙ChatGPT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🚀🚀🚀OpenAI聊天机器人ChatGPT——「全域全知全能」人类全宇宙大爆炸！！🔥🔥🔥 一、什么是ChatGPT?🍀🍀 ChatGPT是生成型预训练变换模型（Chat Generative Pre-trained Transformer）的缩写，是一种语言模型。而OpenAI所提出的这一系列的模型，可以执行非常复杂的任务，如回复问题、生成文章和程序代码，或者翻译文章内容等。而GPT中的Transformer是指由Google Brain所推出的解码器（decoder），是用来处理输入的自然语言以处理翻译、摘要等。ChatGPT是OpenAI开发的一种创新AI模型，利用强大的GPT-3系列，并通过人类反馈与强化学习相一致。ChatGPT是一个聊天机器人，它为对话带来了一个新的互动和参与水平，对问题提供了深刻和发人深省的回答。
但ChatGPT不仅仅是个聊天机器人，而是上知天文下知地理、可以针对使用者问题给予相应的长篇回复；问答解惑、写程式和debug，甚至撰写论文、剧本小说诗歌等等，都难不倒它，只是有时还是会出现令人啼笑皆非的答案，但都还编得有模有样、令人惊艳。
ChatGPT自2022年11月30日开放公众使用以来，已经吸引超过100万人使用，社群媒体也涌现了大量用户的测试截图，主题广泛，个个都在测试人工智慧的极限。
总之，ChatGPT是一个非常强大和多功能的人工智能模型，能够提供有洞察力和吸引人的对话，并以多种不同的方式推进人工智能研究领域。OpenAI创建ChatGPT的努力无疑是一个令人印象深刻的壮举，为AI的未来提供了不可思议的潜力。
二、ChatGPT的作者是谁？🍀🍀 ChatGPT由马斯克（Elon Musk）参与创立的独立研究机构OpenAI基金会所研发，初衷是为了确保AI最终不会消灭人类。 三、ChatGPT是如何训练的?🍀🍀 📚📚ChatGPT的训练过程分为以下三个阶段👇👇 ✨✨第一阶段： 冷启动阶段的监督策略模型。靠GPT 3.5本身，尽管它很强，但是它很难理解人类不同类型指令中蕴含的不同意图，也很难判断生成内容是否是高质量的结果。为了让GPT 3.5初步具备理解指令中蕴含的意图，首先会从测试用户提交的prompt(就是指令或问题)中随机抽取一批，靠专业的标注人员，给出指定prompt的高质量答案，然后用这些人工标注好的&lt;prompt,answer&gt;数据来Fine-tune GPT 3.5模型。经过这个过程，我们可以认为GPT 3.5初步具备了理解人类prompt中所包含意图，并根据这个意图给出相对高质量回答的能力，但是很明显，仅仅这样做是不够的。
✨✨第二阶段： 训练回报模型（Reward Model,RM）。这个阶段的主要目的是通过人工标注训练数据，来训练回报模型。具体而言，随机抽样一批用户提交的prompt(大部分和第一阶段的相同)，使用第一阶段Fine-tune好的冷启动模型，对于每个prompt，由冷启动模型生成K个不同的回答，于是模型产生出了&lt;prompt,answer1&gt;,&lt;prompt,answer2&gt;….&lt;prompt,answerK&gt;数据。之后，标注人员对K个结果按照很多标准（上面提到的相关性、富含信息性、有害信息等诸多标准）综合考虑进行排序，给出K个结果的排名顺序，这就是此阶段人工标注的数据。
接下来，我们准备利用这个排序结果数据来训练回报模型，采取的训练模式其实就是平常经常用到的pair-wise learning to rank。对于K个排序结果，两两组合，形成个训练数据对，ChatGPT采取pair-wise loss来训练Reward Model。RM模型接受一个输入&lt;prompt,answer&gt;，给出评价回答质量高低的回报分数Score。对于一对训练数据&lt;answer1,answer2&gt;，我们假设人工排序中answer1排在answer2前面，那么Loss函数则鼓励RM模型对&lt;prompt,answer1&gt;的打分要比&lt;prompt,answer2&gt;的打分要高。
归纳下：在这个阶段里，首先由冷启动后的监督策略模型为每个prompt产生K个结果，人工根据结果质量由高到低排序，以此作为训练数据，通过pair-wise learning to rank模式来训练回报模型。对于学好的RM模型来说，输入&lt;prompt,answer&gt;，输出结果的质量得分，得分越高说明产生的回答质量越高。
✨✨第三阶段： 采用强化学习来增强预训练模型的能力。本阶段无需人工标注数据，而是利用上一阶段学好的RM模型，靠RM打分结果来更新预训练模型参数。具体而言，首先，从用户提交的prompt里随机采样一批新的命令（指的是和第一第二阶段不同的新的prompt，这个其实是很重要的，对于提升LLM模型理解instruct指令的泛化能力很有帮助），且由冷启动模型来初始化PPO模型的参数。然后，对于随机抽取的prompt，使用PPO模型生成回答answer， 并用上一阶段训练好的RM模型给出answer质量评估的回报分数score，这个回报分数就是RM赋予给整个回答（由单词序列构成）的整体reward。有了单词序列的最终回报，就可以把每个单词看作一个时间步，把reward由后往前依次传递，由此产生的策略梯度可以更新PPO模型参数。这是标准的强化学习过程，目的是训练LLM产生高reward的答案，也即是产生符合RM标准的高质量回答。
如果我们不断重复第二和第三阶段，很明显，每一轮迭代都使得LLM模型能力越来越强。因为第二阶段通过人工标注数据来增强RM模型的能力，而第三阶段，经过增强的RM模型对新prompt产生的回答打分会更准，并利用强化学习来鼓励LLM模型学习新的高质量内容，这起到了类似利用伪标签扩充高质量训练数据的作用，于是LLM模型进一步得到增强。显然，第二阶段和第三阶段有相互促进的作用，这是为何不断迭代会有持续增强效果的原因。
尽管如此，我觉得第三阶段采用强化学习策略，未必是ChatGPT模型效果特别好的主要原因。假设第三阶段不采用强化学习，换成如下方法：类似第二阶段的做法，对于一个新的prompt，冷启动模型可以产生k个回答，由RM模型分别打分，我们选择得分最高的回答，构成新的训练数据&lt;prompt,answer&gt;,去fine-tune LLM模型。假设换成这种模式，我相信起到的作用可能跟强化学习比，虽然没那么精巧，但是效果也未必一定就差很多。第三阶段无论采取哪种技术模式，本质上很可能都是利用第二阶段学会的RM，起到了扩充LLM模型高质量训练数据的作用。
以上是ChatGPT的训练流程。
四、ChatGPT的演变历程🍀🍀 1. GPT-1 就是第一代GPT模型，于2018年6月诞生时，就已经是个强大的语言理解模型。从判断两个句子间的语意与关系、文本资料分类、问答与常识推理都难不倒，只是并非好的对话式AI模型，训练参数也远低于后续模型。
2. GPT-2 2019年2月OpenAI又推出了由GPT-1演变而来的GPT-2，但主要改变只有使用了更多参数与数据集，参数量达15亿（GPT-1仅有1.17亿），而学习目标改成了「无特定任务训练」。这证明了，大幅增加的参数和资料可以让GPT-2比起GPT-1更上一层楼，虽然有些任务的表现不比随机的好，但在生成短文和编故事等方面都有了一定的突破。
3. GPT-3／GPT-3.5 2020年GPT-3也受简单粗暴地用钱堆出了更多的运算资源，延续过去GPT类的单向语言模型的训练方式，只是将模型增大到1750亿参数。GPT-3在自然语言处理领域已经取得了重大的突破，成为了当时最大、最强大的自然语言生成模型，从机器翻译到文章总结输出，都有着非常出色的表现。
只是，2020年因为疫情严峻所致，人们对于人工智慧领域的突破并没有足够的关注。而且，比起ChatGPT，GPT-3并没有办法进行自然的对话，只能处理单向的任务，因此也只有少数开发者有兴趣。
直到2022年11月底，OpenAI才发布了「GPT-3.5」的更新，主打对话模式，甚至可以承认错误、且拒绝不恰当的请求──这就是支持ChatGPT背后的模型，其更接近人类对话与思考方式的特点也吸引了全球的目光。
4. GPT-4 距上次GPT-3.5的更新不久，2023年3月14日，OpenAI又抛出GPT-4，此次除了正确度高出40%、以整理和搜寻网络上的资讯为主，还可以支援视觉输入、图像辨识，并懂得「看图说故事」！不过GPT-4没有再砸下重金、狂堆训练参数，而是把研发的重点将放在提升利用现有数据的能力上。
🚀🏆🍀【算法创新&amp;算法训练&amp;论文投稿】相关链接👇👇👇 ✨【YOLO创新算法尝新系列】✨ 🏂 美团出品 | YOLOv6 v3.0 is Coming（超越YOLOv7、v8） 🏂 官方正品 | Ultralytics YOLOv8算法来啦（尖端SOTA模型） 🏂 改进YOLOv5/YOLOv7——魔改YOLOv5/YOLOv7提升检测精度（涨点必备） ——————————————🌴【重磅干货来袭】🎄—————————————— 🚀一、主干网络改进（持续更新中）🎄🎈 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/274c18edc9104b615a4adf63694e0f1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bad89111d45698135874facafe110bf3/" rel="bookmark">
			maven打包排除类不生效 maven-compiler-plugin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题
有个springboot项目B作为另一个项目A的依赖，在B打包的时候需要排除它的启动类。
按照百度的说法，只需要添加以下配置就可以排除掉。
&lt;build&gt; &lt;!--打包项目包名--&gt; &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt;**/BApplication.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 但是实际打包后发现排除并不生效。
原因
1.排除的类在某个类C中import了，类C要编译就必须编译排除的类，所以要同时排除掉C。
2.parent pom引入了这个类，导致exclude不生效
解决办法
在项目B中写了单元测试，使用了注解@SpringBootTest(classes={BApplication.class})，所以编译test的时候强行编译了启动类。
因此直接跳过编译
&lt;properties&gt; &lt;!--跳过编译test--&gt; &lt;maven.test.skip&gt;true&lt;/maven.test.skip&gt; &lt;!--跳过执行单元测试--&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/properties&gt; &lt;build&gt; &lt;!--打包项目包名--&gt; &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;!--覆盖parent pom的配置--&gt; &lt;configuration combine.self="override"&gt; &lt;excludes&gt; &lt;exclude&gt;**/BApplication.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0afee2084ec1c3139508e2f7e21e157e/" rel="bookmark">
			【el-table】设置行变色，以及鼠标移入的时候保持背景色不变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、根据条件设置行变色，这个官网上也有示例，没啥难的，直接贴代码了
&lt;el-table :data="navList" :row-class-name="tableRowClassName" :cell-style="tableCellstyle" &gt; tableRowClassName({ row, rowIndex }) { if (row.Flag == 'Y') { return 'changeBcg' } return '' }, /deep/.el-table { .changeBcg { background: #fff2cc; } } 2、设置好背景色后发现，每次鼠标移入到变色的行上面，背景色就会变成灰色，要求是移入也要是变过色的背景色
tableCellstyle({ row, rowIndex }) { if (row.Flag == 'Y') { return 'background: #fff2cc' } return '' }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1a18434dafb5ba101af238c4a295b55/" rel="bookmark">
			windows bat批处理 修改文件夹子目录名称，删除前五个字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 步骤 新建.txt文件，名称任意，如aaa.txt ，编写批处理命令，代码如下 @echo off setlocal enabledelayedexpansion for /d %%f in (*) do ( echo %%f set name=%%f ren !name! !name:~5%!	) pause 修改文件后缀为.bat,确认修改文件名
将.bat 文件放入目录下，点击执行即可
所用命令注释 ::利用for、ren命令 删除文件夹名称前5位 ::@echo off ：作用：在dos命令环境中屏蔽命令提示符 @echo on 为开启 ::setlocal enabledelayedexpansion ： 作用启用延迟扩展，使cmd识别语法!var!，访问current的var值 SETLOCAL DISABLEDELAYEDEXPANSION 为关闭延迟扩展 :: for命令： 具体语法：FOR %%variable IN (set) DO command [command-parameters] ::	%%variable 指定一个单一字母可替换的参数。 ::	(set) 指定一个或一组文件。可以使用通配符 *。 ::	command 指定对每个文件执行的命令。 ::	command-parameters 为特定命令指定参数或命令行开关。 ::	for命令有4个参数 /d /l /r 以及最强大的 /f ； :: /d 表示仅为目录，用于目录搜索,不会搜索文件 ::	/r 表示递归 ，进入根目录树 [Drive:]Path，在树的每个目录中执行 for 语句。如果在 /R 后没有指定目录，则认为是当前目录。 ::	/l 表示迭代数值范围 ，for /L %% Variable in (Start#,Step#,End#) do Command使用迭代变量设置起始值 (Start#)，然后逐::	::	步执行一组范围的值，直到该值超过所设置的终止值 (End#) （Step#）开始迭代的位置如： ::	for /l %%i in (1,1,5) do start cmd 作用：遍历启动五个cmd窗口 ::	/f 有两个参数 delims和tokens，其作用是用来处理文件和一些命令的输出结果，具体可自己了解 ::ren：rename的缩写，是一个操作系统命令，用于给文件重命名 ren oldname newname ::%%f： 变量 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfc9ac29a7a9eb14a5aadfd5ea0a6494/" rel="bookmark">
			SpringBoot启动流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
通过SpringApplication开始引导启动
new SpringApplication——创建引导启动的实例
run()——开始引导启动
new StopWatch()——创建计时器
configureHeadlessProperty()——配置Headless模式
SpringApplicationRunListener.start()——获取监听器,启动监听
prepareEnvironment()——准备环境，创建ConfigurableEnvironment对象
printBanner()——打印横幅
createApplicationContext()——创建应用程序上下文并加载Bean
prepareContext()——准备ApplicationContext
refreshContext()——刷新上下文
afterRefresh()——留给子类的钩子函数
启动完成
准备运行
总结
通过SpringApplication开始引导启动 SpringApplication类是用来执行Spring框架启动的引导类。有两种方式可以进行启动引导：
通过静态方法 SpringApplication.run启动。先创建 SpringApplication实例，在调用的实例方法 run进行启动。 无论是以上哪种方式，最终都是通过创建SpringApplication实例，在调用run()启动。
new SpringApplication——创建引导启动的实例 在创建SpringApplication实例的时候，会根据用户输入和工程环境做一些基础配置，供之后引导启动中使用。
设置ResourceLoader和PrimarySources从类中加载initializer和listener放在集合设置是否为Web环境(先确认用户是否指定，未指定则根据工程目录下是否有servlet相关环境)从工程环境中决定主入口的类 run()——开始引导启动 new StopWatch()——创建计时器 StopWatch是springframework.util中提供的一个工具类，在启动过程中使用StopWatch是为了记录启动花费的时间。
configureHeadlessProperty()——配置Headless模式 Headless模式是在环境缺少显示器等设备情况下的一种配置，和启动流程并无太多关系，不做介绍。
SpringApplicationRunListener.start()——获取监听器,启动监听 监听器可以用来监听SpringApplication启动过程中的各个阶段。默认的监听器是EventPublishRunListener，用户也可以通过实现SpringApplicationRunListener接口，实现应用程序对SpringApplication启动过程的监听。
在 resources/META-INF 下建立 spring.factories 文件，文件中添加 key=value 形式，其中 key 为 SpringApplicationRunListener的全路径名，value 为应用程序对该接口的实现类(类需要一个参数类型为 SpringApplication 和 String 数组的构造函数，用于通过反射创建实例)。
prepareEnvironment()——准备环境，创建ConfigurableEnvironment对象 在这一步，SpringApplication会创建Spring启动所需的环境，这个环境主要由ConfigurableEnviroment对象表示。首先，该对象确认了程序是否需要设置Web环境，其次，该对象还确定了程序所需要的参数和读取的配置文件等信息。
此步骤会回调SpringApplicationRunListener的environmentPrepared()方法，通知监听器环境已经准备好。
printBanner()——打印横幅 这一步骤其实和启动并没有太大关系，只是会向控制台或是日志中输出Spring的Logo和版本信息。
createApplicationContext()——创建应用程序上下文并加载Bean 在准备好环境之后，接下来要做的就是创建应用程序上下文ApplicationContext对象。
ApplicationContext是Spring IoC的核心组件，它不仅是程序所需Bean的容器，还提供了国际化，事件发布等功能。
在创建应用程序上下文的时候，首先会根据之前配置决定上下文的具体类型（AnnotationConfigApplicationContext或是AnnotationConfigServletWebServerApplicationContext）。再通过反射实例化到对象。
prepareContext()——准备ApplicationContext 虽然已经得到了ApplicationContext对象，但此时的对象还只是一个空白对象，需要准备和处理后，ApplicationContext才能被使用。
在准备过程中主要做了做了几件事：为ApplicationContext设置之前准备好的Environment对象。
通过对ApplicationContext后置处理或是BeanDefinitionLoader等方式往容器中添加一些初始的Bean。
应用默认的初始化器初始化应用程序上下文(责任链模式的应用，多个初始化器形成一个List，应用程序需要被每个初始化器应用一次，每个初始化器有自己的职责)。
准备过程中ApplicationRunListener发出两个消息，分别是contextPrepared和contextLoaded。
refreshContext()——刷新上下文 在应用程序上下文准备好后，可以通过刷新应用程序上下文发现Bean并加载到容器中。refreshContext()会调用ApplicationContext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfc9ac29a7a9eb14a5aadfd5ea0a6494/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10cb81bb9c0adbaeb316e342973c8a63/" rel="bookmark">
			ChatGPT中文调教指南（1）——担任面试官
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 担任面试官
示例：Java 后端开发工程师、React 前端开发工程师、全栈开发工程师、iOS 开发工程师、Android开
发工程师等。
我想让你担任Android开发工程师面试官。我将成为候选人，您将向我询问Android开发工程师职
位的面试问题。我希望你只作为面试官回答。不要一次写出所有的问题。我希望你只对我进行采
访。问我问题，等待我的回答。不要写解释。像面试官一样一个一个问我，等我回答。我的第一句 话是“面试官你好”
面试官您好。
您能介绍一下您的Android开发经验吗？您最近在做什么项目？能给我们讲讲吗？您在开发中遇到过最大的挑战是什么？如何解决的？您对于Android架构有哪些了解？您最擅长哪种架构？您对于性能优化有哪些经验？能分享一下您的优化策略吗？您如何保证应用程序的稳定性？您有什么特别的方法或工具吗？您是否有使用过一些比较新的Android技术或框架？您对它们有什么看法？您如何处理Android系统版本兼容性问题？您有什么经验或技巧吗？您对于测试有什么看法？您会如何进行测试？您是否有参与过开源项目？能给我们讲讲您的经验吗？ 我想让你担任软件测试工程师面试官。我将成为候选人，您将向我询问软件测试工程师职
位的面试问题。我希望你只作为面试官回答。不要一次写出所有的问题。我希望你只对我进行采
访。问我问题，等待我的回答。不要写解释。像面试官一样一个一个问我，等我回答。我的第一句 话是“面试官你好”
面试官你好。
请介绍一下你的软件测试经验。你最擅长哪些测试技术和方法？你如何编写测试用例和测试计划？请描述一下你如何进行缺陷跟踪和管理。你如何评估测试覆盖率和测试效果？请谈谈你对自动化测试的看法和经验。如果你发现一个严重的缺陷，你会如何处理和通知相关人员？请描述你如何与软件开发人员和其他团队成员合作进行测试。你如何保证测试过程的质量和效率？请谈谈你对软件测试未来的发展和趋势的看法。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e502371828a37cb5e6ab46e483cc9e45/" rel="bookmark">
			cryoSPARC基础教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cryoSPARC是当前冷冻电镜单颗粒重构的主流软件之一，它的界面交互十分友好。本文采用一套铁蛋白apoferritin的数据作为testdata。我们服务器路径在/data/testdata/apoferritin下。别的朋友有需要的可以通过网盘下载，放在评论区。本人也是新手，文章有不对的或者补充的地方欢迎指出，大家一起讨论进步。
这是cryoSPARC v4.0的主界面，cryoSPARC软件是通过Web网页来访问的。
点击最左边第二个按钮可以显示所有的project
第一步：新建Project 点击上方绿色的New Project按钮可以新建Projet。
Title输入Project的名称，点击Container Directory右边的文件夹图标选择保存的路径并点击Select确认。下方点击Create新建。
注意：它会在选择的文件夹内创建一个“CS-xxx”的文件夹，所有的运算结果都在这个文件夹下。但是和relion不同，它可以允许访问外部文件夹的文件或者数据。最好别在服务器的各种路径下到处生成Project文件夹，一不小心就被管理员清掉了，在自己的文件夹下新建，做好管理和规划。
第二步：创建Workspace 创建Project之后会自动要求你先创建一个Workspace，输入个自己看得懂的名字比如W1。不同worksparce之间是可以互相使用计算的结果的，所以创建Workspace方便分类和查找自己的计算。
新的Workspace会显示如下，因为是空的，所以它给你推荐了一些可能需要的Job类型，一般是Import导入数据。右上角Detail显示Workspace或者Job的信息，点击Builder可以新建所有类型的Job。
第三步：导入数据 冷冻电镜收集的原始图片一般是以Mutiframes Movies形式（比如SeriesEM软件收集的Tiff格式，EPU软件收集的eer格式）。
如果在收集的时候就做过MotionCorretion，或者在别的软件里比如relion、MotionCor2等做过MotionCorretion，那么是文件就是mrc格式的Micrograph，直接选择Import Micrograph就行。
点击Import Movies。
1、点击这个区域可以放大Job看详细信息
2、如果想要暂停一下去做别的事，可以点击Stop Building。同时，这个图标会变成紫色的Build，再点一下就可以继续编辑。
3、输入Movies的路径
4、输入gain文件（gain.mrc）
这里如果收集回来的gain是.dm4格式的，用eman2软件的e2proc2d.py程序转化格式。
module load eman2/2.31 cd /path/to/gain e2proc2d.py gain.dm4 gain.mrc 点击Movie data path右边的文件夹，找到自己的原始数据位置，选择其中一张照片，然后在路径里改成*.tiff或者*.eer（*代表该文件夹下全部文件，为了防止一起导入当前路径下有gain或者其它文件，写*.tiff保证导入的都是以tiff后缀的Movies）。点击Select。这时候再点击Movie data path右边的文件夹图标，我们会发现当前目录下全部Movies都被选中了。
同样的，点击Gain reference path右边的文件夹图标，选中gain.mrc
然后将电镜收集参数填完（这些参数收集数据的时候记下来）。
- Rotate gain ref? 一般gain flip和rotate都不用管，这套tutorial的数据需要旋转90度。输入1代表选择一次90度。
- Raw pixel size (A) 像素大小
- Accelerating Voltage (kV) 加速电压
- Spherical Aberration (mm) 球差系数
- Total exposure dose (e/A^2) 总电子剂量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e502371828a37cb5e6ab46e483cc9e45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0118d0c1d1a5f26c99a3d3c4ef69ebd4/" rel="bookmark">
			外网域名访问tomcat服务器上项目并且通过域名路径访问图片接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家阐述如何在工作中，利用外网进行访问服务器的项目以及文件图片。
通过域名的形式进行公网访问：如：www.xxxxxx.com访问网站，www.xxxxxx.com/image/upload.png 访问服务器上的网络图片
一：主要就是部署修改服务器Tomcat的server.xml文件
(文章底部附全部server.xml) &lt;Connector connectionTimeout="20000" port="80" protocol="HTTP/1.1" redirectPort="8443"/&gt; 修改port=“80”的端口值 注：如果不修改此值，公网或者IP地址访问就需要携带8080端口号才能访问到Tomcat！如果修改为80，就默认不需要加端口：比如：www.123456.com或者公网IP:47.215.xxx.125就可以访问！
&lt;Engine name="Catalina" defaultHost="www.rxxxx731.com"&gt; 修改defaultHost=“www.xxxxxx.com”的值 &lt;Host name="www.rxxxx731.com" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; 修改name=“www.xxxxxx.com”的地址值 在Host里面添加部署网站到tomcat-webapps的路径
&lt;Context path="" docBase="C:\Users\Administrator\Desktop\tomcat\apache-tomcat-8.5.69\webapps\ycWeb"/&gt; 此部署后，在公网上就可以访问到项目网站了 在上方的context下，继续部署一个context，用于公网访问服务器上的文件存储的图片
&lt;Context path="/image" docBase="C:\Users\Administrator\Desktop\image" reloadable="true"&gt;&lt;/Context&gt; 此docBase路径为服务器上桌面上image文件夹的路径，网络图片都存储在这，可以实现外网www.xxxxxx.com/image/1.png就能访问到资源图 总结完毕！如果还不行，可以看看细节部分⬇️ 重点细节： 1，如果tomcat下部署项目后可以访问，把项目删掉也可以外网访问时，可能是开启了IIS服务，需要关闭IIS启动。
2.域名的访问需要备案，备案成功后需要配置相应的安全组
3.外网通过域名的形式访问服务器上存储的图片时，需要在Host下新添加Context
&lt;Context path="/image" docBase="C:\Users\Administrator\Desktop\image" reloadable="true"&gt;&lt;/Context&gt; 我的文件夹全路径是C:\Users\Administrator\Desktop\image\upload
path要填写服务器上桌面上的文件夹名称，不能填写image下面的子文件夹，如：/image/upload是不可行的，不需要填写子文件夹docBase-这个属性也一样，最后就是image(桌面上看见的文件夹)结尾，不用填写到upload了 查看最终的截图： 1.访问tomcat下部署的web项目
2.访问用户上传的图片，存储在服务器image文件夹下的图片
附全览Tomcat下server.xml文件 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0118d0c1d1a5f26c99a3d3c4ef69ebd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d241545974c5a5b8cbcccf3e831d2533/" rel="bookmark">
			46道史上最全Redis面试题，面试官能问的都被我找到了（含答案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis高性能缓存数据库 1、什么是 Redis？简述它的优缺点？
Redis 的全称是：Remote Dictionary.Server，本质上是一个 Key-Value 类型的内存数据库，很像
memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。
因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的Key-Value DB。
Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个 value 的最大限制是 1GB，不像 memcached 只能保存 1MB 的数据，因此 Redis 可以用来实现很多有用的功能。
比方说用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性 能消息队列服务，用他的 Set 可以做高性能的 tag 系统等等。
另外 Redis 也可以对存入的 Key-Value 设置 expire 时间，因此也可以被当作一 个功能加强版的memcached 来用。 Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上
2、Redis 与 memcached 相比有哪些优势？
memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型redis 的速度比 memcached 快很多 redis 的速度比 memcached 快很多redis 可以持久化其数据 redis 可以持久化其数据 3、Redis 支持哪几种数据类型？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d241545974c5a5b8cbcccf3e831d2533/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7696ac1cdcd594f9051cbdf2026c7c0c/" rel="bookmark">
			【虚拟机】在Windows11上下载安装VMware虚拟机以及Ubuntu（Linux）详细操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍
这里是小编成长之路的历程，也是小编的学习之路。希望和各位大佬们一起成长！
以下为小编最喜欢的两句话：
要有最朴素的生活和最遥远的梦想，即使明天天寒地冻，山高水远，路远马亡。
一个人为什么要努力？ 我见过最好的答案就是：因为我喜欢的东西都很贵，我想去的地方都很远，我爱的人超完美。因此，小编想说：共勉！
目录
一、下载VMware虚拟机和Ubuntu（Linux）
VMware Workstation Pro 16
Ubuntu（Linux）
二、安装步骤
以管理员身份运行VMware
三、开启虚拟机
如果出现错误无法连接虚拟设备 sata0:1,因为主机上没有相对应的设备
四、将语言设置为中文
一、下载VMware虚拟机和Ubuntu（Linux） 可以在官网下载VMware的虚拟机和Ubuntu（Linux）
VMware Workstation Pro 16 VMware 中国 - 交付面向企业的数字化基础 | CN
小编下载的就是VMware Workstation Pro 16的
Ubuntu（Linux） 可以在官网下载Ubuntu
Ubuntu 16.04.7 LTS （Xenial Xerus）
二、安装步骤 这个地方可以不选中，选中的话会提示你是否更新版本
以管理员身份运行VMware 小编这里选择的是自定义安装
这里是运行内存，一般选择推荐内存，箭头选择那个绿色的方框
这里可以使用桥接网络，这样就会生成一个新的ip地址，就不会使用你主机windows的ip地址了
完成上述步骤，虚拟机就可以创建完成
三、开启虚拟机 注意:小编报了以上的错误，但是小编没有去解决它，后来运行了几次虚拟机都没有出现这个问题所以小编就没有去解决了。如果大家出现问题了，可以去看看其他博主的文章！
如果出现错误无法连接虚拟设备 sata0:1,因为主机上没有相对应的设备 可以进行下图的操作 再运行虚拟机就会出现一个页面，等一会就可以进入登录页面
登录页面
这个地方需要注意
四、将语言设置为中文 点击系统设置就可以更换语言为中文了
语言支持
下载 输入密码
点击yes之后，需要再次输入密码
下载其他语言
选择中文简体
下载完就可以看到汉语在底部了
将最下面的汉语拖到最上面，语言默认最上面的为首选项
重新启动Ubuntu，登录进来就可以看到你已经更改了语言
打开设置就可以看到 设置中的语言变成了中文
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7696ac1cdcd594f9051cbdf2026c7c0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a63fc056779dea4a23282eafadb235db/" rel="bookmark">
			【SVN】windows SVN安装使用教程（服务器4.3.4版本/客户端1.11.0版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍
这里是小编成长之路的历程，也是小编的学习之路。希望和各位大佬们一起成长！
以下为小编最喜欢的两句话：
要有最朴素的生活和最遥远的梦想，即使明天天寒地冻，山高水远，路远马亡。
一个人为什么要努力？ 我见过最好的答案就是：因为我喜欢的东西都很贵，我想去的地方都很远，我爱的人超完美。因此，小编想说：共勉！
目录
一、SVN的一些概念
1、什么是SVN?
2、SVN的作用是什么？为什么要用SVN？
二、VisualSVN Server服务端–服务器搭建和使用
1、官网下载VisualSVN Server服务端
步骤：
1、下载和搭建SVN服务器
2、建立用户和组，以及权限的分配
新建用户
新建组
权限的分配
三：客户端TortoiseSVN安装
1、官网下载
2、安装步骤
1、首先我们需要下载 ”svn小乌龟”后，进行安装。然后一路next即可安装。
3、再一直下一步！！
4、中文安装包
5、然后右击桌面空白的地方，（只要是空白的地方），出现以下界面即为安装成功
6、如果勾选了命令行，可以在cmd中查看svn命令行是否安装成功
四、一些基本操作
1、在服务端获取svn检出的地址
2、检出
3、在上图中点击确定，就会跳出一个框，让你输入自己的账号和密码（这个地方账号和密码就是服务端创建的用户组）
4、进入你自己检出的路径，就可以看到下图的文件了
一、SVN的一些概念 详细概念可以看一下百度的文章
TortoiseSVN_百度百科
1、什么是SVN? SVN是subversion的缩写，是一个开放源代码的版本控制系统，通过采用分支管理系统的高效管理，简而言之就是用于多个人共同开发同一个项目，实现共享资源，实现最终集中式的管理。
Subversion(SVN) 是一个开源的版本控制系統, 也就是说 Subversion 管理着随时间改变的数据。 这些数据放置在一个中央资料档案库(repository) 中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本, 或是浏览文件的变动历史。
2、SVN的作用是什么？为什么要用SVN？ 代码版本管理的工具，即把代码提交到服务器，可回退历史版本，总结起来有以下几点功能：
1、把自己编写代码提交至服务器。每提交一次会产生一个版本，如果在实际过程中写错了可查看历史版本；
2、回退历史版本功能；
3、协同修改。实际开发中不止一个人在开发，如果多人开发不可能进行通过文件整理来合并代码，如同第1点的每个人都可以提交交代码，SVN服务器会自动合并代码。
4、多版本项目文件管理。如代码可以分开前端和后端两个分支。
5、可以追溯编提交时间和提交人的代码，比如多人修改了同一个地方的代码，可以查看是谁修改了什么代码
6、权限控制，可以把部分代码给不同的开发者，以免一个人把整个项目的代码都获取完，保证代码的安全性。
7、代码仓库，每来一个新的职员提交链接就可以下载代码
二、VisualSVN Server服务端–服务器搭建和使用 1、官网下载VisualSVN Server服务端 Apache Subversion Binary Packages
找到下图中的win（看自己的需要，小编本文所讲是win版本的）
因为小编有安装包，就没有下载最新版的VisualSVN Server，小编使用的是4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a63fc056779dea4a23282eafadb235db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd28f3d3d5da89e86ba9bdb445774885/" rel="bookmark">
			解决hive load local data报FAILED: Execution Error, return code 2 from org.apache.hadoop.hive.ql.exec.mr
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、报错如下 Hadoop job information for Stage-1: number of mappers: 1; number of reducers: 4 2023-04-26 10:20:01,826 Stage-1 map = 0%, reduce = 0% 2023-04-26 10:20:26,371 Stage-1 map = 100%, reduce = 100% Ended Job = job_1682514589825_0023 with errors Error during job, obtaining debugging information... Job Tracking URL: http://hadoop100:8088/proxy/application_1682514589825_0023/ Examining task ID: task_1682514589825_0023_m_000000 (and more) from job job_1682514589825_0023 Task with the most failures(4): ----- Task ID: task_1682514589825_0023_m_000000 URL: http://hadoop100:8088/taskdetails.jsp?jobid=job_1682514589825_0023&amp;tipid=task_1682514589825_0023_m_000000 ----- Diagnostic Messages for this Task: Error: java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd28f3d3d5da89e86ba9bdb445774885/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d306c4ffa17a12fb4cc1578e7a405663/" rel="bookmark">
			【c&#43;&#43;】 定义学生类，包括私有数据成员学号s_id、姓名name、班级grade、成绩score；私有静态成员count（用以统计学生人数）、sum（用以统计学生总成绩）。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义学生类，包括私有数据成员学号s_id、姓名name、班级grade、成绩score；私有静态成员count（用以统计学生人数）、sum（用以统计学生总成绩）。按要求完成以下功能：
（1）定义无参构造函数；定义带参构造函数，实现学生学号、姓名、班级、成绩的初始化。 以及 学生人数递增统计操作；
（2）重载输入运算符，实现学生信息输入；以及学生总分的统计功能；
（3）重载输出运算符，实现学生信息输出；
（4）重载“&gt;”、“&lt;”运算符，比较两个学生的成绩高低；
#include &lt;iostream&gt; //引用头文件 using namespace std; class Student { //定义一个学生类 //私有成员 private: string s_id; //成员学号 string name; //姓名 string grade; //班级 float score; //成绩 //私有静态成员 static int count; //统计学生人数 static float sum; //统计学生总成绩 //公有成员 public: //定义无参构造函数 Student() { count++; } //定义有参函数 Student(string id, string na, string gra, float sco): s_id(id), name(na), grade(gra), score(sco) { } //输出学生的总数和总成绩 void Show() { cout &lt;&lt; "学生的总数:" &lt;&lt; Student::count &lt;&lt; endl; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d306c4ffa17a12fb4cc1578e7a405663/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9593951bf492f239e69780c672236f53/" rel="bookmark">
			hive表类型&amp;建表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、表类型
Hive中的表类型_hive 表类型_小愚就是小小呀的博客-CSDN博客
hive 表类型
Hive内部表与外部表，数据导入，数据导出_hive 导入外部表_遥遥晚风点点的博客-CSDN博客
Hive中的表类型_hive 表类型_小愚就是小小呀的博客-CSDN博客
分区表可参考：hive分区表详细介绍_hive分区表作用_zxzLife的博客-CSDN博客
2、建表
【Hive】Hive 建表语句详解_hql建表写表注释_w1992wishes的博客-CSDN博客
Hive建表语句_zhaozuoyou的博客-CSDN博客
3、常用语句
删库/表 Hive 常用的DDL语句大全 建库建表 详细_hive建库语句_abcdggggggg的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8becd6400dc0cb1f4c025581fa8911b4/" rel="bookmark">
			防火墙基础知识分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 为了因对网络威胁，联网的机构或公司将自己的网络和公共网络进行隔离，其方法是根据网络的安全信任程度和需要保护的对象，人为的划分若干区域，这些安全区域有：
公共外部网路，如internet
内联网（Intranet）：如学校内网，访问限制在组织内部
外联网（Extranet）：内联网的扩展延伸，常用作组织与合作伙伴之间进行通信
军事缓冲区域（DMZ）:是介于内外网之间的网络断，用于放置公共服务措施
在安全区域划分的基础上，通过一种网络安全设备，控制安全区域间的通信，可以隔离有害通信，进而阻断网络攻击。这种安全设备就被称之为防火墙。
一、防火墙技术原理 防火墙技术原理是指防火墙如何对网络流量进行过滤和控制，以保护网络资源和数据的安全性。防火墙技术原理主要包括包过滤、状态检测、应用层网关等多个方面。
1. 包过滤
包过滤是防火墙技术的基础，也是最基本的防火墙技术。包过滤可以根据源IP地址、目标IP地址、端口号、协议类型等多个因素进行设置，以实现对网络流量的过滤和控制。包过滤的过程包括以下几个步骤：
（1）检查数据包的头部信息，包括源IP地址、目标IP地址、端口号、协议类型等。
（2）根据设置的规则，对数据包进行过滤和控制，可以允许数据包通过，也可以拒绝数据包通过。
（3）数据包通过防火墙后，将被传递到目标主机进行处理。
包过滤技术简单、有效，可以实现对网络流量的基本控制和保护。但是，包过滤技术不能对数据包的内容进行检查和分析，容易被攻击者绕过。
2. 状态检测
状态检测是一种高级的防火墙技术，可以检测网络流量的状态信息，以识别和拦截恶意流量。状态检测可以对网络流量进行深度分析，包括TCP连接状态、会话状态等，以确定流量是否为合法流量。状态检测的过程包括以下几个步骤：
（1）对网络流量进行深度分析，包括TCP连接状态、会话状态等。
（2）根据分析结果，判断流量是否为合法流量。
（3）对非法流量进行拦截和处理。
状态检测技术可以有效地识别和拦截恶意流量，提高网络安全的水平。但是，状态检测技术也存在一定的局限性，例如容易被攻击者绕过，对网络性能有一定影响等。
3. 应用层网关
应用层网关是一种高级的防火墙技术，可以对应用层协议进行过滤和控制，例如对HTTP、SMTP等协议进行过滤和控制。应用层网关可以深入到应用层，对网络流量进行深度分析和处理。应用层网关的过程包括以下几个步骤：
（1）对应用层协议进行深度分析，包括协议数据格式、协议状态等。
（2）根据分析结果，判断网络流量是否为合法流量。
（3）对非法流量进行拦截和处理。
应用层网关技术可以对应用层协议进行精细化的过滤和控制，提高网络安全的水平。但是，应用层网关技术需要消耗大量的计算资源和存储资源，对网络性能的影响较大。
综上所述，防火墙技术原理涉及到多个方面，包括包过滤、状态检测、应用层网关等多个方面。不同的防火墙技术具有不同的特点和适用场景，需要根据实际情况进行选择和配置。同时，还需要进行防火墙规则的设置和管理、防火墙的管理和维护等工作，以确保防火墙的有效性和稳定性。
2. 防火墙技术分类 防火墙技术可以根据不同的实现方式进行分类，主要包括软件防火墙和硬件防火墙两种。
1. 软件防火墙
软件防火墙可以运行在普通的操作系统之上，以软件形式实现网络安全功能。软件防火墙可以部署在各种计算机系统上，包括服务器、台式机、笔记本电脑等。软件防火墙的主要优点包括：
（1）灵活性：软件防火墙可以根据实际情况进行配置和管理，以实现对网络流量的精细化管理和保护。
（2）易于部署：软件防火墙可以部署在各种计算机系统上，不需要专门的硬件设备支持。
（3）成本较低：软件防火墙的成本较低，适合中小型企业使用。
软件防火墙的主要缺点包括：
（1）性能较差：软件防火墙需要消耗计算机资源，对计算机的性能有一定影响。
（2）安全性较低：软件防火墙容易被攻击者绕过，存在安全风险。
2. 硬件防火墙
硬件防火墙是一种独立的设备，可以在网络中直接进行网络流量过滤和控制。硬件防火墙通常包括专用的硬件设备和预装的软件，可以实现对网络流量的深度分析和处理。硬件防火墙的主要优点包括：
（1）性能较好：硬件防火墙可以独立运行，不需要消耗计算机资源，对网络性能的影响较小。
（2）安全性较高：硬件防火墙难以被攻击者绕过，具有较高的安全性。
（3）易于管理：硬件防火墙可以通过网络管理接口进行远程管理和监控，管理和维护较为方便。
硬件防火墙的主要缺点包括：
（1）成本较高：硬件防火墙的成本较高，不适合中小型企业使用。
（2）灵活性较差：硬件防火墙的功能和配置受到硬件设备的限制，灵活性较差。
需要注意的是，软件防火墙和硬件防火墙并不是彼此对立的，它们可以相互补充和合作，以实现对网络资源的更加精细化的保护和管理。在进行防火墙选择和配置时，需要根据实际情况进行综合考虑和选择。
3. 防火墙应用场景 防火墙是一种网络安全设备，主要用于保护网络资源和数据的安全性。防火墙可以应用于多个场景，包括以下几个方面：
1. 企业内部网络
防火墙可以应用于企业内部网络，以保护内部网络资源的安全性。企业内部网络通常包括多个子网和多个部门，需要对各个子网和部门进行隔离和保护。防火墙可以对内部网络流量进行过滤和控制，防止内部网络受到来自外部网络的攻击和威胁。同时，防火墙还可以对内部网络进行访问控制，以保护内部网络资源的安全性。
2. 互联网接入口
防火墙可以应用于互联网接入口，以保护企业的网络资源和数据不受来自互联网的攻击和威胁。互联网接入口通常是企业与互联网之间的关键节点，需要进行精细化的网络安全管理和保护。防火墙可以对互联网流量进行深度分析和处理，防止来自互联网的恶意流量进入企业内部网络。
3. 电子商务
防火墙可以应用于电子商务领域，以保护在线交易的安全性。电子商务平台需要对用户的个人隐私和财务信息进行保护，以确保交易的安全和可靠。防火墙可以对电子商务平台的流量进行过滤和控制，防止来自互联网的攻击和威胁。同时，防火墙还可以对用户的访问进行访问控制，以保护用户的个人隐私和财务信息。
4. 移动互联网
随着移动互联网的发展，防火墙也逐渐应用于移动互联网领域。移动互联网通常涉及到多个终端设备和多个网络环境，需要对网络流量进行深度分析和处理，以保护移动设备和用户的安全。防火墙可以对移动设备的流量进行过滤和控制，防止来自互联网的攻击和威胁。
5. 云计算
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8becd6400dc0cb1f4c025581fa8911b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15745b049a65bee5964d8178e69c940a/" rel="bookmark">
			Cookie和Session面试题知识大总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cookie是什么？ HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务，HTTP/1.1 引入 Cookie 来保存状态信息。
Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。
cookie 的出现是因为 HTTP 是无状态的一种协议，换句话说，服务器记不住你，可能你每刷新一次网页，就要重新输入一次账号密码进行登录。这显然是让人无法接受的，cookie 的作用就好比服务器给你贴个标签，然后你每次向服务器再发请求时，服务器就能够 cookie 认出你。
抽象地概括一下：一个 cookie 可以认为是一个「变量」，形如 name=value，存储在浏览器；一个 session 可以理解为一种数据结构，多数情况是「映射」（键值对），存储在服务器上。
题外话：由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。
Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。
新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。
Cookie有什么用途？用途 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）个性化设置（如用户自定义设置、主题等）浏览器行为跟踪（如跟踪分析用户行为等) 在session的实现原理中，每一个session对象都会关联一个sessionid，例如：
JSESSIONID=41C481F0224664BDB28E95081D23D5B8以上的这个键值对数据其实就是cookie对象。对于session关联的cookie来说，这个cookie是被保存在浏览器的“运行内存”当中。只要浏览器不关闭，用户再次发送请求的时候，会自动将运行内存中的cookie发送给服务器。例如，这个Cookie: JSESSIONID=41C481F0224664BDB28E95081D23D5B8就会再次发送给服务器。服务器就是根据41C481F0224664BDB28E95081D23D5B8这个值来找到对应的session对象的。 cookie怎么生成？cookie保存在什么地方？cookie有啥用？浏览器什么时候会发送cookie，发送哪些cookie给服务器？ cookie最终是保存在浏览器客户端上的。
可以保存在运行内存中。（浏览器只要关闭cookie就消失了。）也可以保存在硬盘文件中。（永久保存。） cookie有啥用呢？
cookie和session机制其实都是为了保存会话的状态。cookie是将会话的状态保存在浏览器客户端上。（cookie数据存储在浏览器客户端上的。）session是将会话的状态保存在服务器端上。（session对象是存储在服务器上。）为什么要有cookie和session机制呢？因为HTTP协议是无状态 无连接协议。 cookie的经典案例 京东商城，在未登录的情况下，向购物车中放几件商品。然后关闭商城，再次打开浏览器，访问京东商城的时候，购物车中的商品还在，这是怎么做的？我没有登录，为什么购物车中还有商品呢？ 将购物车中的商品编号放到cookie当中，cookie保存在硬盘文件当中。这样即使关闭浏览器。硬盘上的cookie还在。下一次再打开京东商城的时候，查看购物车的时候，会自动读取本地硬盘中存储的cookie，拿到商品编号，动态展示购物车中的商品。 京东存储购物车中商品的cookie可能是这样的：productIds=xxxxx,yyyy,zzz,kkkk注意：cookie如果清除掉，购物车中的商品就消失了。 126邮箱中有一个功能：十天内免登录
这个功能也是需要cookie来实现的。怎么实现的呢？ 用户输入正确的用户名和密码，并且同时选择十天内免登录。登录成功后。浏览器客户端会保存一个cookie，这个cookie中保存了用户名和密码等信息，这个cookie是保存在硬盘文件当中的，十天有效。在十天内用户再次访问126的时候，浏览器自动提交126的关联的cookie给服务器，服务器接收到cookie之后，获取用户名和密码，验证，通过之后，自动登录成功。 Session知识大总结 除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。
Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。
使用 Session 维护用户登录状态的过程如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15745b049a65bee5964d8178e69c940a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d853b4a9a02fe56039ea14cfc9ff4c3c/" rel="bookmark">
			RedHat8配置本地YUM源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： RedHat8配置本地YUM源1、创建规则文件2、创建挂载点3、挂载ISO镜像(1).将iso镜像连接到虚拟机再进行挂载a.将ISO镜像连接虚拟机b.挂载镜像到挂载点c.使用df -h查看当前系统设备挂载情况 (2)将iso镜像上传至服务器再进行挂载a.将ISO镜像通过ftp工具上传b.挂载镜像到挂载点c.使用df -h查看当前系统设备挂载情况 4、清除YUM缓存5、列出可以安装包6、安装测试7、卸载镜像 RedHat8配置本地YUM源 1、创建规则文件 (1).备份规则文件
cd /etc/yum.repos.d/ mkdir repo mv *.repo ./repo (2).创建规则文件
cat &lt;&lt;EOF&gt;&gt; /etc/yum.repos.d/RedHat8_local_yum.repo [BaseOS] name=BaseOS baseurl=file:///mnt/cdrom/BaseOS gpgcheck=0 enabled=1 [AppStream] name=AppStream baseurl=file:///mnt/cdrom/AppStream gpgcheck=0 enabled=1 EOF 2、创建挂载点 mkdir -p /mnt/cdrom 可以使用其他挂载点，但是规则文件中的baseurl要与挂载点路径保持一致
3、挂载ISO镜像 (1).将iso镜像连接到虚拟机再进行挂载 a.将ISO镜像连接虚拟机 打开虚拟机设置 --&gt;
CD/DVD(SATA) --&gt;
使用ISO镜像文件 --&gt;
点击已连接（此处可以配置开机自动挂载）
将ISO文件连接到虚拟机后在操作系统中对应的就是/dev/sr0设备
b.挂载镜像到挂载点 （默认对镜像文件写保护，以只读方式挂载）
# mount /dev/sr0 /mnt/cdrom mount: /mnt/cdrom: WARNING: device write-protected, mounted read-only. c.使用df -h查看当前系统设备挂载情况 /dev/sr0 7.9G 7.9G 0 100% /mnt/cdrom (2)将iso镜像上传至服务器再进行挂载 a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d853b4a9a02fe56039ea14cfc9ff4c3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eada87fcd7a2953ca63d8bfca460989e/" rel="bookmark">
			CentOS7 安装JDK1.8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 资源下载：评论区留下联系邮箱，阿里网盘暂不支持分享。
1. 在usr目录下创建java安装目录： cd /usr/local mkdir java 2. 解压到当前目录,得到文件夹 jdk1.8.0_60 tar -zxvf jdk-8u60-linux-x64.tar.gz 3. 编辑配置文件，将如下配置添加至文件中，然后保存退出 vi /etc/profile #java export JAVA_HOME=/usr/local/java/jdk1.8.0_181 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib 4. 重启命令 source /etc/profile 5. 查看安装情况 java -version javac -version 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b96891166a14932a819a718c2bfb4123/" rel="bookmark">
			Linux 使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux 目录结构 目录内容/boot系统启动相关的文件，如内核、initrd，以及grub（BootLoader）/etc配置文件/home用户的家目录，每一个用户的家目录通常默认为/home/USERNAME/root管理员的家目录/lib库文件 静态库：单在程序中的库，其他程序不能使用该库文件；动态库：在内存中，任何用到该库的程序都可以使用；/lib/modules/media挂载点目录，- 移动设备（在windows中，插入一张光盘，系统会自动读取光盘，用户可以直接执行，但在linux中，插入光盘后需要在挂载点挂载这个设备之后才可以使用这个设备。）/mnt挂载点目录，额外的临时文件系统/opt可选目录，第三方程序的安装目录/proc伪文件系统，内核映射文件/sys伪文件系统，跟硬件设备相关的属性映射文件/tmp临时文件，/var/tmp/var可变化的文件，经常发生变化的文件/bin可执行文件，用户命令；其中用到的库文件可能在/lib，配置文件可能在/etc/sbin可执行文件，管理命令；其中用到的库文件可能在/lib，配置文件可能在/etc/usr只读文件，shared read-only； /usr/local：第三方软件 操作指南 安装 wget：
yum install wget CentOS7 保存退出 vi 编辑 按ESC键 跳到命令模式，然后输入命令（见下表格）： 命令注释:w保存文件但不退出vi:wfile 将修改另外保存到file中，不退出vi:w!强制保存，不推出vi:wq保存文件并退出vi:wq!强制保存文件，并退出viq:不保存文件，退出vi:q!不保存文件，强制退出vi:e!放弃所有修改，从上次保存文件开始再编辑 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c5960664407bad644b3ff60d1a8a13b/" rel="bookmark">
			带你理清：ROS机器人导航功能实现、解析、以及参数说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇博客字数较多，难免存在争议、问题，我们评论区多交流。
！！！ 表示解释的不好，存在问题，欢迎各位小伙伴评论留言。
目 录 机器人导航先决条件导航1. move_base1.1 move_base功能包参数1.2 全局路径规划器的参数1.3 局部路径规划器的参数1.4 代价地图的参数1.5 在RViz中查看global_costmap和local_costmap1.6 运动恢复1.7 问题&amp;解决1.8 好文章 2. AMCL3. Gmapping4. URDF仿真实现 机器人导航先决条件 在调整新机器人上的导航包时遇到的大部分问题都在本地规划器调谐参数之外的区域。机器人的里程计，定位，传感器以及有效运行导航的其他先决条件常常会出错。所以，第一件事是确保机器人本身准备好了，具有导航能力。这包括三个组件检查：距离传感器、里程计、定位。
距离传感器
如激光雷达、距离传感器等，传感器没有正常工作，无法提供信息，那么导航将无法顺利完成。
可以尝试在rviz中查看传感器信息，是否可以通过话题Topic获取传感器信息，并以预期的速度获取。
里程计
往往机器人无法正确定位，问题根源不在Amcl算法调参，而是里程计不可靠。
可以通过两个健全检查，验证里程计是否可靠。
第一个测试检查角速度是否合理 ：打开rviz，将坐标系设置为“odom”，显示机器人提供的激光扫描， 设置topic的延时时间(decay time)为20s左右，然后原地旋转，然后，看看扫描出来的边线在随后的旋转中如何相互匹配。理想情况下，每次扫描将刚好落在相互的顶端，会重叠在一起，但是有些旋转漂移是预期的，所以我只是确保扫描之间误差，不会超过一度或两度以上。
第二个测试检查线速度是否合理：机器人放置在与距离墙壁几米远地方，然后以上面相同的方式设置rviz。接着控制机器人向墙壁前进，从rviz中聚合的激光扫描看看扫描出来边线的厚度。理想情况下，墙体应该看起来像一个扫描，但我只是确保它的厚度不超过几厘米。如果显示扫描边线的分散在半米以上，但有些可能是错误的测距。
定位
假设里程计和距离传感器都可靠，建图结果和Amcl定位结果通常并不会太糟糕。首先，我将运行gmapping或karto，并操纵机器人来生成环境地图。然后，我将在该地图上进行Amcl定位，良好的定位效果应该是可视化激光扫描和环境地图，机器人移动过程中激光扫描保持与环境地图很好地匹配。
导航 这项工作并不像看起来那么简单。如果对概念和推理了解不清楚，可能会随意尝试，这将浪费大量的时间。 本文旨在引导读者正确微调导航参数。当在设置一些关键参数的时候，需要知道“如何”和“为什么”。
在ROS中，实现导航功能需要使用到的三个包是：
（1） move_base：根据参照的消息进行路径规划，使移动机器人到达指定的位置。
（2） amcl：根据已经有的地图进行定位。
（3） gmapping：根据激光数据（或者深度数据模拟的激光数据）建立地图。
1. move_base 结构框架图：
move_base的输入topic：
/tf：提要提供的tf包括map_frame、odom_frame、base_frame以及机器人各关节之间的完成的一棵tf树。/odom：里程计信息/scan 或 /pointcloud：传感器的输入信息，最常用的是激光雷达(sensor_msgs/LaserScan类型)，也有用点云数据(sensor_msgs/PointCloud)的/map：地图，可以由SLAM程序来提供，也可以由map_server来指定已知地图（或自定义的室内地图） 以上四个Topic是必须持续提供给导航系统的，下面这个是可随时发布的topic：
move_base_simple/goal：目标点位置（也就是导航的目标点） move_base包内包括三种插件：base_local_planner、base_global_planner和recovery_behavior，这三种插件都得用户指定，否则系统会指定默认值。
base_local_planner插件：
base_local_planner/TrajectoryPlannerROS: 实现了Trajectory Rollout和DWA两种局部规划算法dwa_local_planner: 实现了DWA局部规划算法，可以看作是base_local_planner的改进版本除此之外还有：teb_local_planner、eband_local_planner、asr_ftc_local_planner、dwb_local_planner，需要用户自行安装（可以源码安装，可以sudo apt install） base_global_planner插件：
parrot_planner: 实现了较简单的全局规划算法navfn/NavfnROS: 实现了Dijkstra和A*全局规划算法global_planner: 重新实现了Dijkstra和A*全局规划算法,可以看作navfn的改进版 recovery_behavior插件：
clear_costmap_recovery: 实现了清除代价地图的恢复行为rotate_recovery: 实现了旋转的恢复行为move_slow_and_clear: 实现了缓慢移动的恢复行为 DWA与Trajectory Rollout的区别主要是在机器人的控制空间采样差异。Trajectory Rollout采样点来源于整个前向模拟阶段所有可用速度集合，而DWA采样点仅仅来源于一个模拟步骤中的可用速度集合。这意味着相比之下DWA是一种更加有效算法，因为其使用了更小采样空间；然而对于低加速度的机器人来说可能Trajectory Rollout更好，因为DWA不能对常加速度做前向模拟。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c5960664407bad644b3ff60d1a8a13b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0a76d8eddebfae93f0e250efa3668d7/" rel="bookmark">
			VMware 16 安装 CentOS7 教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资源下载：评论区留下联系邮箱，阿里网盘暂不支持分享（VMware16，CentOS7镜像）
VMware16安装好之后，下载好我们要安装的操作系统的镜像文件，这里以CentOS 7版本为例，就可以开始安装了。
1. 在主页选择创建新的虚拟机。 2. 选择自定义安装 3. 选择Workstation 16.x，点击下一步 4. 选择稍后安装操作系统 5. 选择已经下载好的操作系统和版本（这里是Linux的CentOS 7 64位） 6. 给虚拟机命名并选择系统选择存储位置（可以默认) 7. 处理器配置（应使用场景而定） 8. 内存配置（应使用场景而定） 9. 网络类型,使用桥接网络 10. I/O控制器类型（选择默认） 11. 磁盘类型：SCSI(S) 12. 创建新虚拟机的磁盘 13. 指定磁盘容量一般选择默认（虚拟磁盘存储为单个或者多个文件一般影响不大） 14. 指定磁盘文件 15. 点击自定义硬件，CD/DVD(IDE)设置,选择使用ISO映像文件，填写CentOS7系统的保存路径。 16. 完成硬件设置了，同时已准备好创建虚拟机 17. 开启此虚拟机 18. 选择install CentOS 7,等待安装 19. 选择英文安装 20. 设置时区，亚洲-上海 21. 选择安装位置，在这里可以进行磁盘划分 22. 选择i wil configure partitioning（我将会配置分区），然后点击done 23. 如下图所示，点击加号，选择/boot，给boot分区分200M。最后点击Add 24. 然后以同样的办法给其他三个区分配好空间后点击Done 25. 然后会弹出摘要信息，点击AcceptChanges(接受更改) 26. 设置主机名与网卡信息 27. 首先要打开网卡，然后查看是否能获取到IP地址(我这里是桥接)，再更改主机名后点击Done。 28. 最后选择Begin Installation(开始安装) 29. 设置root密码，点击Done 30.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0a76d8eddebfae93f0e250efa3668d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5450034bbc946a5808acaafb745e3242/" rel="bookmark">
			MongoDB管理神器来袭！NexNoSqlClient让你的效率翻倍！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 如果你在日常工作中需要经常使用MongoDB，那么你一定体验过这样一些痛点;繁琐的脚本编写，冗长的命令行操作，复杂的数据建模和索引等等。这些问题不仅让我们的工作效率低下，还容易出现错误和漏洞，给数据安全带来风险，所以我们急需一款能够帮我们解决这一系列问题的软件。
前言： 但是，现在有了NexNoSalClient，这些问题将不再是问题!NexNoSalClient是一款跨平台的NoSOI集群管理利器，它可以帮助我们轻松连接和管理ES，redis，MongoDB集群，让我们免除繁琐的脚本编写和冗长的命令行操作。更重要的是，它提供了图形化的操作界面，让我们可以通过简单的点选实现数据的增删查改，数据建模，索引的修改等功能，大大提高了我们的使用效率和工作质量。
功能介绍： 一、新增MongoDB集群 安装软件之后，打开软件--》左上角--》new--&gt;选择MongoDB，见下图：
二、新增集合 添加MongoDB集群之后，就可以点击集群名称右边的“+”，也即下图红色方框的位置，就会弹出添加集合的对话框，输入集合名称点击confirm即可，这样集合就添加成功了。
三、删除集合 点击刚添加的MongoDB集群，NexNoSalClient会自动把集群里面所有的集合都展示出来，找到我们想要删除的集合，点击集合名称右侧的垃圾箱，即可删除相应的集合，见下图：
四、集合数据操作 1、新增文档 当我们集合新增之后，就可以新增文档了，点击我们刚才新增的集合，就能打开集合数据操作界面，在界面上点击 add 按钮，弹出add document 对话框，输入我们想新增的文档内容，点击confirm，文档新增完成。
2、查询文档 查询功能应该是这个软件最特别的地方，首先它避免了我们写冗长的MongoDB脚本，对于集合里面的字段，可以直接罗列出来，我们来看一下吧：
2.1、支持集合字段的罗列：
2.2、丰富的操作符：
支持=，&gt;,&gt;=,&lt;,&lt;=,!=,in,not in,exists,like，还支持排序
比如我们想查询userNo=72058，根据createTime升序排列，只需要这样即可：
是不是非常便捷，原来要写一坨代码，现在就需要输入 72058，其他的全部都是点选操作。
3、修改文档 找到我们想修改的文档之后，点击edit按钮，弹出edit document对话框
修改文档，又是该软件的一大特色，支持table和JSON两种样式
修改完毕之后，点击confirm，文档修改完毕
4、删除文档 找到我们想删除的文档之后，点击delete按钮，即可对文档进行删除，此处就不再截图了。
五、集合索引操作 新增索引是不是MongoDB的一个比较常用的操作呢，可它也是一坨代码啊，一坨代码。
1、查询索引 当我们切换到索引TAB页，就能看到当前集合的所有索引，默认情况下，MongoDB对_id字段做了一个索引，并且是不可删除的。
我们点击该索引的create script，看看MongoDB建索引的脚本是什么样子的：
db.abc343.createIndex({"_id":1},{"name":"_id_"}) 2、新增索引 当我们想要新增索引的时候，比如我们想在status上面建一个索引：
点击界面新增索引按钮，弹出add index对话框
首先输入索引名称，当然索引名称也不是必选的，你不输入，MongoDB会自动生成
选择索引字段，索引是升序还是降序的，当前还指出text和hash索引
选择可选参数，比如我们选择在后台执行，并且是唯一索引，参考下图：
3、删除索引 删除索引就不详细说了，找到我们要删除的索引，点击删除按钮即可
后记： 小编已经使用了这个软件，感觉非常好用，如果你正在寻找一款易于上手且功能强大的数据库管理软件，那么NexNoSqlClient绝对是你的不二之选！快来试试吧，相信你会惊喜连连！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/784a78fe531950d71a0a2b4f28518c5f/" rel="bookmark">
			Java下载Excel模板文件的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中经常会用到文件下载的功能，比如下载excel模板，这里简单记录一下实现过程
1、将模板文件放到项目资源文件目录中，也可以自定义其他位置，只要通过路径能找到该文件就行：
2、controller层写下载的接口
/** * 下载导入模板 */ @GetMapping("downloadExcel") public void downloadExcel(HttpServletResponse httpServletResponse) { InputStream inputStream = null; try (ServletOutputStream outputStream = httpServletResponse.getOutputStream()) { //设置响应头信息，包括下载后的文件名和编码等 httpServletResponse.addHeader("content-disposition", String.format("attachment;filename= %s", URLEncoder.encode("导入模板.xlsx", "utf-8"))); httpServletResponse.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"); httpServletResponse.setCharacterEncoding("UTF-8"); //在文件夹里获取到文件并转为流 inputStream = new ClassPathResource("/senseXlsx.xlsx").getInputStream(); byte[] b = streamToByteArray(inputStream); httpServletResponse.getOutputStream().write(b); } catch (Exception e) { e.printStackTrace(); } finally { if (inputStream != null) { try { inputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } } 3、前端直接调用这个接口就可以实现下载啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a579d962dbb55b32e20afece00d492e2/" rel="bookmark">
			navicat使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		navicat导出查询结果集, 作为sql的升级脚本, 当然你也可以查询 复制为insert语句,修改insert语句后(删除多余的库名), 作为升级脚本 使用navicat for mysql 将查询语句过滤的结果导出成insert语句时没有带表名的解决办法: 解决办法，将此查询先保存并取个名字，名字必须为查询sql的表名，然后再导出
数据库表有uuid 和create_date列, 用navicat默认打开是以uuid排序的, 你要选择create_date 降序排列,查看最新的记录 一般在设计表的时候:create_time modify_time都使用datetime类型,不推荐用timestamp, modify_time设置为 CURRENT_TIMESTAMP 并且 勾选 根据当前时间戳更新 (当表中 一条记录有修改操作时,,它会自动更新modify_time为mysql系统时间) navicat操作mysql的时候，如何输入null值？
使用navicat将MySQL表结构（含数据类型、字段备注注释）导出成Excel(其实是选中查询结果的5行5列(建议直接ctrl+a全选)粘贴到word中excel的5行5列里即可, 如果有换行,就将navicat字段里的注释的换行删掉即可) word中表格列数 行数多时,会循环粘贴
如何从数据字典中，检索出这个表的字段的相关信息？sql如下:
SELECT COLUMN_NAME 列名, COLUMN_COMMENT 备注,
COLUMN_TYPE 数据类型, CASE WHEN COLUMN_KEY = 'PRI' THEN 'TRUE' ELSE 'FALSE' END AS '是否主键',
CASE WHEN IS_NULLABLE = 'NO' THEN 'TRUE' ELSE 'FALSE' END AS '不为空'
FROM INFORMATION_SCHEMA.COLUMNS where -- developerclub为数据库名称，到时候只需要修改成你要导出表结构的数据库即可 table_schema ='ipvacloud_20180319' AND -- article为表名，到时候换成你要导出的表的名称 -- 如果不写的话，默认会查询出所有表中的数据，这样可能就分不清到底哪些字段是哪张表中的了，所以还是建议写上要导出的名名称 table_name = 'ft_base_data'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a579d962dbb55b32e20afece00d492e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c260305c00e06f70b1683e333a720f2d/" rel="bookmark">
			通用后台管理系统，管理后台框架模板演示地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、这个通用的后台管理系统，管理后台框架模板，主要包括如下功能：
1、功能模块
主要包括新闻管理、留言管理、广告管理、友情链接管理、图片管理、用户管理等。
具体包括搜索、列表展示、分页、图片上传、批量审核等。
2、系统设置
主要包括字典设置、黑名单管理、地区管理、操作日志、回收站、IP管理、短信日志、邮件日志、自动获取IP地址、SEO优化、缓存管理等。
具体包括搜索、列表展示、分页、自动获取IP地址、手动获取IP地址、批量审核等。
3、权限控制
主要包括节点菜单管理、角色管理，权限分配、管理员管理等。
具体包括搜索、列表展示、分页、图片上传、批量审核等。
4、数据图表
数据报表访问统计的各种折线图、柱状图，饼图等。
具体包括拆线图、柱状图、实心饼图、环形饼图、3D实习饼图、3D环形饼图、实时访问统计拆线图等。
5、其他
包括省市县乡四级联动、汉字转拼音、导入导出Excel、Word等的示例。
具体包括搜索、列表展示、分页、图片上传、批量审核、省市县乡四级联动、汉字转拼音、导入导出等。
二、演示地址如下：
http://www.yiduhao.com/mydemo/
账号:demo 密码:demo918
三、功能截屏如下：
1.功能模块-新闻列表.png
2.系统设置-地区列表.png
3.系统设置-IP管理.png
4.系统设置-Redis缓存管理.png
5.权限配置-角色权限.png
6.数据图表-访问统计.png
7.功能示例-省市县乡-四级联动.png
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cae7324a4006f6a6b0967733288cd0ce/" rel="bookmark">
			Java中的方法栈、方法堆和方法区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
方法区、方法栈、方法堆是Java虚拟机（JVM）中的重要概念，理解它们的工作原理对于优化代码和避免内存泄漏是非常有帮助的。
一、方法区：
方法区是JVM内存模型中的一个重要部分，也是Java中存放类信息和常量池的地方。方法区也被称为永久代（Permanent Generation，PG），其中的对象通常都是不会被垃圾回收的，直到虚拟机退出才会被释放。 方法区的大小是通过JVM启动参数来设置的，它的大小可以在运行时进行调整。当方法区被占满时，会抛出OutOfMemoryError异常。
二、方法堆：
方法堆是JVM在堆内存中为方法调用分配的内存区域，它通常包含方法的参数、局部变量和返回值。每次调用方法时，JVM都会为该方法分配一块方法堆内存。 方法堆是线程私有的，也就是说，每个线程都会为它的方法调用分配一个独立的方法堆，这使得多线程程序可以同时调用同一个方法而不会相互影响。 方法堆的大小是由JVM自动管理的，当方法调用结束时，JVM会自动释放该方法所占用的方法堆内存。当你创建一个对象时，对象本身的数据存储在堆中，但该对象的方法（包括构造函数和成员方法）的代码存储在方法区中。方法堆通常用来存储方法调用期间的临时变量和返回值。当你调用一个方法时，方法的参数和局部变量会存储在该方法的方法堆中，当方法调用结束时，这些临时变量会被释放。因此，方法堆不是为了存储对象本身，而是为了存储方法调用期间的临时数据。
三、方法栈：
方法栈是JVM中的一个重要概念，它用来存储线程中每个方法的状态。每个方法在运行时都会创建一个栈帧，栈帧中存储了该方法的参数、局部变量和返回值等信息。 方法栈是线程私有的，也就是说，每个线程都会为它的方法调用分配一个独立的方法栈，这使得多线程程序可以同时调用同一个方法而不会相互影响。 方法栈的大小也是由JVM自动管理的，当方法调用结束时，JVM会自动释放该方法所占用的方法栈内存。
四、方法区、方法堆和方法栈的关系：
方法区、方法堆和方法栈都是JVM内存模型中的重要组成部分，它们之间的关系如下：
1.方法区是存放类信息和常量池的地方，而方法堆和方法栈则是为方法调用分配内存的区域。
2.方法堆和方法栈是线程私有的，每个线程都会为它的方法调用分配独立的内存区域，而方法区则是所有线程共享的。
3.方法区、方法堆和方法栈都由JVM自动管理，它们的大小和释放都是由JVM自动控制的。
4.当一个方法被调用时，JVM会为该方法分配一块方法堆内存，并在当前线程的方法栈中创建一个栈帧用于存储该方法的状态。当方法调用结束时，JVM会自动释放该方法所占用的方法堆内存，并弹出对应的栈帧。在JVM运行时，方法区、方法堆和方法栈的合理使用和优化可以提高程序的性能和减少内存泄漏的风险。
五、总结：
简单的理解来说：可以将 JVM、方法栈、方法区和方法堆看为一座图书馆。
JVM可以看作整个图书馆，它是程序运行的环境，提供了各种内存、线程等资源。
方法栈可以看作读者在图书馆借书时，用来存放读者信息和借书记录的卡片，每个读者都会有一个独立的卡片，而方法栈就是为每个线程中的方法调用分配独立的内存区域。
方法区可以看作图书馆的书库，它是存放类信息和常量池的地方，每个类都有一个对应的类信息，类信息在方法区中存储，而常量池是每个类的一个重要部分，存储着类中定义的常量。
方法堆可以看作借书的书架，它是为方法调用分配内存的区域，每次方法调用时都会在方法堆中分配内存。方法堆是线程私有的，每个线程都会为它的方法调用分配一个独立的方法堆，这使得多线程程序可以同时调用同一个方法而不会相互影响。
这个类比虽然不完全对，但是可以帮助大家更好地理解这四个概念之间的关系和作用。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/81/">«</a>
	<span class="pagination__item pagination__item--current">82/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/83/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>