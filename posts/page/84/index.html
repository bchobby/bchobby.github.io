<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 编程爱好者博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="编程爱好者博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bchobby.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="编程爱好者博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程爱好者博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程爱好者博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/104b47cef89bf64c31c9aecc6583e05c/" rel="bookmark">
			CentOS7 安装MySQL 8.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 在usr/local目录下创建mysql安装目录：
2. 将资源放在MySQL文件下
3. 解压到当前目录,mysql-8.0.18-1.el7.x86_64.rpm-bundle.tar
4. 查看 mariadb 的安装包
5. 卸载mariadb
6. 依次安装
7. 查看已安装资源
8. 初始化
9. 使用root用户登录mysql ,并修改root用户密码
10. 远程连接
11. 开启端口
12. 测试远程连接
注：安装之前准备
yum install -y perl-Module-Install.noarch yum install -y perl yum install net-tools 1. 在usr/local目录下创建mysql安装目录 cd /usr/local mkdir soft/mysql 2. 将资源放在MySQL文件下 3. 解压到当前目录,mysql-8.0.18-1.el7.x86_64.rpm-bundle.tar tar -xvf mysql-8.0.18-1.el7.x86_64.rpm-bundle.tar 4. 查看 mariadb 的安装包 rpm -qa | grep mariadb 5. 卸载mariadb rpm -e mariadb-libs-5.5.60-1.el7_5.x86_64 --nodeps 6. 依次安装 rpm -ivh mysql-community-common-8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/104b47cef89bf64c31c9aecc6583e05c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53db98604137fdf1c24e2a2c900fab5d/" rel="bookmark">
			springboot 如何配置tomcat信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 前两天面试的时候，面试官问我：一个ip发请求过来，是一个ip对应一个线程吗？我突然愣住了，对于SpringBoot如何处理请求好像从来没仔细思考过，所以面试结束后就仔细研究了一番，现在就来探讨一下这个问题。
正文 我们都知道，SpringBoot默认的内嵌容器是Tomcat，也就是我们的程序实际上是运行在Tomcat里的。所以与其说SpringBoot可以处理多少请求，到不如说Tomcat可以处理多少请求。
关于Tomcat的默认配置，都在spring-configuration-metadata.json文件中，对应的配置类则是org.springframework.boot.autoconfigure.web.ServerProperties。
和处理请求数量相关的参数有四个：
server.tomcat.threads.min-spare：最少的工作线程数，默认大小是10。该参数相当于长期工，如果并发请求的数量达不到10，就会依次使用这几个线程去处理请求。server.tomcat.threads.max：最多的工作线程数，默认大小是200。该参数相当于临时工，如果并发请求的数量在10到200之间，就会使用这些临时工线程进行处理。server.tomcat.max-connections：最大连接数，默认大小是8192。表示Tomcat可以处理的最大请求数量，超过8192的请求就会被放入到等待队列。server.tomcat.accept-count：等待队列的长度，默认大小是100。 举个例子说明一下这几个参数之间的关系：
如果把Tomcat比作一家饭店的话，那么一个请求其实就相当于一位客人。min-spare就是厨师(长期工)；max是厨师总数(长期工+临时工)；max-connections就是饭店里的座位数量；accept-count是门口小板凳的数量。来的客人优先坐到饭店里面，然后厨师开始忙活，如果长期工可以干的完，就让长期工干，如果长期工干不完，就再让临时工干。图中画的厨师一共15人，饭店里有30个座位，也就是说，如果现在来了20个客人，那么就会有5个人先在饭店里等着。如果现在来了35个人，饭店里坐不下，就会让5个人先到门口坐一下。如果来了50个人，那么饭店座位+门口小板凳一共40个，所以就会有10人离开。
也就是说，SpringBoot同时所能处理的最大请求数量是max-connections+accept-count，超过该数量的请求直接就会被丢掉。
纸上得来终觉浅，绝知此事要躬行。
上面只是理论结果，现在通过一个实际的小例子来演示一下到底是不是这样：
创建一个SpringBoot的项目，在application.yml里配置一下这几个参数，因为默认的数量太大，不好测试，所以配小一点：
server: tomcat: threads: # 最少线程数 min-spare: 10 # 最多线程数 max: 15 # 最大连接数 max-connections: 30 # 最大等待数 accept-count: 10 复制代码 再来写一个简单的接口：
@GetMapping("/test") public Response test1(HttpServletRequest request) throws Exception { log.info("ip:{},线程:{}", request.getRemoteAddr(), Thread.currentThread().getName()); Thread.sleep(500); return Response.buildSuccess(); } 复制代码 代码很简单，只是打印了一下线程名，然后休眠0.5秒，这样肯定会导致部分请求处理一次性处理不了而进入到等待队列。
然后我用Apifox创建了一个测试用例，去模拟100个请求：
观察一下测试结果：
从结果中可以看出，由于设置的 max-connections+accept-count 的和是40，所以有60个请求会被丢弃，这和我们的预期是相符的。由于最大线程是15，也就是有25个请求会先等待，等前15个处理完了再处理15个，最后在处理10个，也就是将40个请求分成了15,15,10这样三批进行处理。
再从控制台的打印日志可以看到，线程的最大编号是15，这也印证了前面的想法。
总结一下：如果并发请求数量低于server.tomcat.threads.max，则会被立即处理，超过的部分会先进行等待，如果数量超过max-connections与accept-count之和，则多余的部分则会被直接丢弃。
延伸：并发问题是如何产生的 到目前为止，就已经搞明白了SpringBoot可以同时处理多少请求的问题。但是在这里我还想基于上面的例子再延伸一下，就是为什么并发场景下会出现一些值和我们预期的不一样？
设想有以下场景：厨师们用一个账本记录一共做了多少道菜，每个厨师做完菜都记录一下，每次记录都是将账本上的数字先抄到草稿纸上，计算x+1等于多少，然后将计算的结果写回到账本上。
Spring容器中的Bean默认是单例的，也就是说，处理请求的Controller、Service实例就只有一份。在并发场景下，将cookSum定义为全局变量，是所有线程共享的，当一个线程读到了cookSum=20，然后计算，写回前另一个线程也读到是20，两个线程都加1后写回，最终cookSum就变成了21，但是实际上应该是22，因为加了两次。
private int cookSum = 0; ​ @GetMapping("/test") public Response test1(HttpServletRequest request) throws Exception { // 做菜。。。。。。 cookSum += 1; log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53db98604137fdf1c24e2a2c900fab5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c42e7d855c2bef5c5b6bd9c6582aacd/" rel="bookmark">
			HC-SR04超声波传感器测距（学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、任务 利用HC-SR04超声波传感器进行测距实验，通过stm32单片机板载的按键实现手动触发测距，将测得的距离显示在OLED屏上。
2、工作原理 a.单片机IO向HC-SR04的Trig接口发送一个持续时间大于10us的高电平信号；
b.HC-SR04接收到来自单片机的信号后，自动发送8个频率为4KHz的方波，方波遇到障碍物后会反射，HC-SR04会自动检测反射回来的信号；
c.HC-SR04的Trig接口接收到单片机高电平信号自动发送方波的同时，Echo接口向单片机IO口发送高电平信号，当HC-SR04接收到返回信号时，Echo接口向单片机IO发送低电平信号，高电平持续的时间就是超声波从发射到返回的总时间T，此时空气中的声速为v，则测得的距离S=（T*v）/2。
3、硬件 a.硬件：HC-SR04传感器、OLED显示屏、stm32F103C8T6单片机
b.接线：VCC——单片机5V GND——单片机GND Trig——PA6(TIM3_CH1) Echo——PA7(TIM3_CH2)
4、代码实现 代码思路：利用定时器中断获取高电平持续时间，将TIM3重装载周期设为1000次，每次1us，当Echo上升沿时开启TIM3，TIM3将每1ms进入中断，在中断函数中记录中断次数，多少次中断就是多少ms，再获取TIM3的计数寄存器值，寄存器值为0~1000，即0us~1000us。
定时时间：Tout=((arr+1)*(psc+1))/Tclk
Tclk:TIMx的输入时钟频率（单位MHz，一般是72MHz）
Tout:TIMx的溢出时间，即定时时间（单位us）
arr:自动重装载寄存器周期的值，自定
psc:时钟频率除数的预分频值
hcsr.c #include "hcsr.h" #include "sys.h" #include "delay.h" //定时时间=((arr+1)*(psc+1))/72MHz=1000us=1ms u32 arr=1000-1; u32 psc=72-1; u32 HcCount=0; //ms计数 //初始化 void HcsrInit(void) { TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; GPIO_InitTypeDef GPIO_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; //使能RCC时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //PA6 Trig 发送电平引脚 GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6; GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_ResetBits(GPIOA, GPIO_Pin_6); //PA7 Echp 接收电平引脚 GPIO_InitStructure.GPIO_Pin=GPIO_Pin_7; GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IN_FLOATING; GPIO_Init(GPIOA,&amp;GPIO_InitStructure); GPIO_ResetBits(GPIOA,GPIO_Pin_7); //PA0 KEY GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0; GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c42e7d855c2bef5c5b6bd9c6582aacd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b9311588cc66beeaaeaf81b34c8f089/" rel="bookmark">
			Visual Studio的安装注意
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文目前包含的内容：
Visual Studio版本选择工作负载组建的选择安装后的环境配置 目录 1. 安装前1. 安装过程中2. 安装后注意 1. 安装前 安装版本选择：
一定不要选最新的版本，选3-5年前的稳定版本！新版本会出很多bug。 1. 安装过程中 安装的工作负载选择：注意一定要选择c++桌面开发，右侧圈出来的两个也一定到选上 2. 安装后注意 安装后不要删除安装过程中设置的缓存文件夹，如果缓存文件删除了，再打开安装的install.exe就找不到本机上已经安装的vs2022了，也没法对其进行删除、卸载和更改了。
安装后环境配置：
下述三个路径中“D:\VS2022\VS2022”是visual studio在电脑上的安装路径
下述路径汇中的“D:\Windows Ktis\10”在visual studio所安装的盘下
1）Path:
D:\VS2022\VS2022\Common7\IDE
D:\VS2022\VS2022\VC\Tools\MSVC\14.35.32215\bin\Hostx64\x64
2）INCLUDE：
D:\VS2022\VS2022\VC\Tools\MSVC\14.35.32215\bin\Hostx64\x64
3）LIB:
D:\VS2022\VS2022\VC\Tools\MSVC\14.35.32215\lib\x64
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19b5ced1b521100ff58e8d0fb6df90ca/" rel="bookmark">
			二十、SQL 数据分析基础与进阶（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、破冰 SELECT 基础检索1.1 检索所需要的列1.1.1 检索单列数据1.1.2 检索多列数据 1.2 * 符号初体验1.3 独特的 DISTINCT1.4 使用 ORDER BY 排序检索结果1.5 使用 LIMIT 限制返回行数1.6 ORDER BY 与 LIMIT 结合的妙用 二、过滤数据，选你所想三、计算字段真奇妙四、常用的聚合函数五、分组的意义六、SELECT 语句的执行顺序 说明：本文对前面学习的 SQL 查询语句进行总结复习。
一、破冰 SELECT 基础检索 1.1 检索所需要的列 1.1.1 检索单列数据 语法：
SELECT &lt;列名&gt; FROM &lt;数据库名&gt;.&lt;数据表名&gt;; 员工信息表包括 employee_id（员工 ID）、employee_name（员工姓名）、age（年龄）、gender（性别）和 salary（薪资）5 个字段，一共有 5 条数据记录。如下图所示：
准备工作，创建表并插入数据，SQL 代码如下：
DROP TABLE IF EXISTS employee_info; CREATE TABLE employee_info ( employee_id VARCHAR (8), employee_name VARCHAR (8), age INT, gender VARCHAR (8), salary INT ); INSERT employee_info ( employee_id, employee_name, age, gender, salary ) VALUES ('e001', 'Bob', 28, 'male', 8000), ('e002', 'Alice', 25, 'female', 6000), ('e003', 'David', 26, 'male', 9000), ('e004', 'Kitty', 30, 'female', 11000), ('e005', 'Allen', 24, 'male', 5500); 【练习1】查询单列数据。如查询员工姓名，代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19b5ced1b521100ff58e8d0fb6df90ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8764fb1109de55c85a2644ed8f7aa3c4/" rel="bookmark">
			Bat批处理脚本for /F语句扩展详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		for /F 扩展，功能强大，可以解析文本、切分字符串、定点提取、跳过无关内容、忽略以指定字符开头的行等等，主要用来处理文件和一些命令的输出结果。
1. for /F 基本用法 语法格式：
FOR /F ["options"] %variable IN (file-set) DO command [command-parameters] FOR /F ["options"] %variable IN ("string") DO command [command-parameters] FOR /F ["options"] %variable IN ('command') DO command [command-parameters] rem 翻译一下就是： for /f %%i in (文件名) do (……) for /f %%i in ('命令语句') do (……) for /f %%i in ("字符串") do (……) file-set 为一个或多个文件名。options 可选参数，包括一个或多个指定不同解析选项的关键字，这些关键字包括eol=c、skip=n、delims=xxx、tokens=x,y,m-n、usebackq，后面将一一介绍。 先来看一个简单的实例：解析test.txt文本中的内容
@echo off for /F %%i in (test.txt) do echo %%i pause 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8764fb1109de55c85a2644ed8f7aa3c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d159a174818a7cb6fbfbf5b61aaa281b/" rel="bookmark">
			centos 7 下载链接，mini版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS7镜像源
http://mirrors.zju.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirrors.aliyun.com/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirrors.163.com/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirrors.shu.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirrors.tuna.tsinghua.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirrors.huaweicloud.com/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirrors.cqu.edu.cn/CentOS/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://ftp.sjtu.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://centos.ustc.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror.bit.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirrors.nwsuaf.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirrors.njupt.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirrors.nju.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirrors.cn99.com/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirrors.neusoft.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror.lzu.edu.cn/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso Nearby Countries - http://ftp.yzu.edu.tw/Linux/CentOS/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://ftp.stu.edu.tw/Linux/CentOS/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://ftp.isu.edu.tw/pub/Linux/CentOS/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://linux.cs.nctu.edu.tw/CentOS/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://ftp.tc.edu.tw/Linux/CentOS/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://ftp.twaren.net/Linux/CentOS/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://ftp.ksu.edu.tw/pub/CentOS/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror-hk.koddos.net/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror.xtom.com.hk/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror.vpshosting.com.hk/pub/linux/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://repo.virtualhosting.hk/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://ftp.cuhk.edu.hk/pub/Linux/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://centos.uhost.hk/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://centos.01link.hk/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://centos.nethub.com.hk/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror.sunnyvision.com/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://centos.communilink.net/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror.navercorp.com/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://data.aonenetworks.kr/os/CentOS/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://ftp.neowiz.com/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror.kakao.com/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://centos.mirror.cdnetworks.com/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://ftp.kaist.ac.kr/CentOS/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://download.nus.edu.sg/mirror/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror.qoxy.com/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror.nus.edu.sg/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror.0x.sg/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror.vodien.com/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://centos.usonyx.net/main/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://ftp-srv2.kddilabs.jp/Linux/packages/CentOS/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://ftp.nara.wide.ad.jp/pub/Linux/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror.fairway.ne.jp/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirrors.cat.net/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://ftp.tsukuba.wide.ad.jp/Linux/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://ftp.iij.ad.jp/pub/linux/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://ftp.yz.yamagata-u.ac.jp/pub/linux/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://ftp.riken.jp/Linux/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://ftp.jaist.ac.jp/pub/Linux/CentOS/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror.sale-dedic.com/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://dedic.sh/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror.awanti.com/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirrors.powernet.com.ru/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror.yandex.ru/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror.satellite-service.ru/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror.vilkam.ru/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://centos-mirror.rbc.ru/pub/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror.tversu.ru/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror.truenetwork.ru/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://mirror.corbina.net/pub/Linux/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso http://ftp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d159a174818a7cb6fbfbf5b61aaa281b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5fb5393e23670d86a14211b7b91cb71/" rel="bookmark">
			手把手，如何搭建一个通用组件库？（文档&#43;样式&#43;按需打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前的文章# 手把手，如何搭建一个通用组件库，并发布到npm？搭建了一个简单的组件库框架，并发布到了npm。
在文章结果也留了几个个坑，
1.没有样式
2.文档系统也没有
3.组件也不能按需加载
我们今天来一一解决。
样式系统 搭建之前，先来看看element-plus的样式。
主要分为几个部分，公共样式，混入函数，每个组件对应的样式。
我看了其他几个库，也大概是这种模式。
先看一下var_scss文件。
通过map定义选项，然后通过map.get来获取对应的值，具体的样式，通过各种函数来进行计算。
大概思路有了，就来搭建我们自己的样式。
首先是全局样式，以及公用样式。
具体的组件样式跟函数，我放在组件同级目录中。
文档系统 文档系统用的是vitepress。
相比于老大哥vuepress。
vitepress跟vite兼容会更好一些，更轻量一些，但是毕竟比较新，可能坑也会多一些。大家可自行选择。
快速上手，我就不介绍了，官方有详细的说明。
安装好了之后，项目跑起来，就能看到一个简单的文档了。
现在我们就可以直接md在上面写vue语法了。
并不是很方便，对吧——button需要写两次
我们希望的是写一次，既有效果，又能展示代码片段。
所以，引入一个插件——vitepress-theme-demoblock。
markdown: { config(md) { // 这里可以使用markdown-it插件 md.use(demoBlockPlugin, { scriptImports: ["import * as bubuUI from '@/index'"], scriptReplaces: [ { searchValue: /import ({.*}) from 'bubu-ui'/g, replaceValue: (s, s1) =&gt; `const ${s1} = bubuUI`, }, ], }); }, }, 复制代码 scriptImports里面的配置是将doc文档中的import引入替换成本地文件，这样打包之后就不需要做修改了。开发时请求本地文件，打包后使用npm版本。
注意：vitepress-theme-demoblock插件暂不支持vue3.2.44以后得setup写法。需要使用defineComponent写法，且引入库需要使用单引号。
参考如下。
&lt;template&gt; &lt;bu-checkbox v-model="val" label="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5fb5393e23670d86a14211b7b91cb71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8f31525fe4c338ff19896da26e0e228/" rel="bookmark">
			C#基础学习--预处理指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是预处理指令
基本规则
#define 和 #undef 指令
条件编译
条件编译结构
诊断指令
行号指令
​编辑 区域指令
#pragam warning 指令
什么是预处理指令 源代码指定了程序的定义，预处理指令指示编译器如何处理源代码
基本规则 #define 和 #undef 指令 编译符号是只有两种可能状态的标识符，要么被定义，要么未被定义
条件编译 条件编译允许我们根据某个编译符号是否被定义标注一段代码被编译或跳过
条件编译结构 #if 和#endif 指令在条件编译结构中需要配对使用
如果RightHanded 被定义，那么#if 和 #else之间的代码会被编译，否则#else 和 #endif之间的代码会被编译
诊断指令 诊断指令产生用户自定义的编译时警告以及错误信息
Message 是字符串，但是不需要引号包围
行号指令 区域指令 区域指令允许我们标注和有选择性地命名一段代码。#region特性如下：
#pragam warning 指令 #pragma warning指令允许我们关闭及重新开启警告消息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56af2b4c9761ecbe8b8b8f5188733743/" rel="bookmark">
			【C&#43;&#43; 十九】STL-函数对象（仿函数）、一元谓词、二元谓词、算术仿函数、关系仿函数、逻辑仿函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STL-函数对象（仿函数）、谓词、内建函数对象 文章目录 STL-函数对象（仿函数）、谓词、内建函数对象前言1 函数对象1.1 函数对象概念1.2 函数对象使用 2 谓词2.1 谓词概念2.2 一元谓词2.3 二元谓词 3 内建函数对象3.1 内建函数对象意义3.2 算术仿函数3.3 关系仿函数3.4 逻辑仿函数 总结 前言 本文包含函数对象概念、函数对象使用、谓词概念、 一元谓词、 二元谓词、内建函数对象意义、算术仿函数（plus()、minus()、multiplies()、divides()、modulus()、negate()）、关系仿函数（equal_to()、not_equal_to()、greater()、greater_equal()、less()、less_equal()）、逻辑仿函数（logical_and()、logical_or()、logical_not()）。
1 函数对象 1.1 函数对象概念 概念：
（1）、重载 函数调用操作符 的类，其对象常称为 函数对象
（2）、函数对象 使用重载的()时，行为类似函数调用，也叫 仿函数
本质： 函数对象(仿函数)是一个 类，不是一个函数
1.2 函数对象使用 特点：
（1）、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值
（2）、函数对象超出普通函数的概念，函数对象可以有自己的状态
（3）、函数对象可以作为参数传递
// 函数对象（仿函数） #include &lt;iostream&gt; // 包含标准输入输出流头文件 using namespace std; // 使用标准命名空间 // 1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值 class fun_Add { public: int operator()(int a, int b) { // 重载函数调用操作符()，返回两数之和 return a + b; } }; void test01() { fun_Add fun_add; // 通过fun_Add类，创建一个fun_add函数对象 cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56af2b4c9761ecbe8b8b8f5188733743/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f0a590546aca6d3adfccfa439a0efe5/" rel="bookmark">
			用Ada语言实现ARINC653定义的航空电子应用软件的标准接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Ada语言实现ARINC653定义的航空电子应用软件的标准接口（APEX），即是用Ada语言编写一套程序，使之实现APEX规定的功能。
这套程序的开发环境是AdaCore发布的基于Windows平台的GPS 2016，如下图所示。
这套程序通过GPS 2016构建为一个dll库。
再用C语言写了一个外壳程序，通过调用上述dll库使之实现ARINC653的C语言接口。该程序通过Visual Studio 2010构建为又一个dll库。
用户获得这两个dll库以及相应的C语言头文件后，就可在Visual Studio 环境中编写、调试、仿真运行符合ARINC 653的应用程序。
2017年完成了上述工作。但是，至今未能用于实际项目。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61a358c5482a9325ee174a1515a65122/" rel="bookmark">
			深入理解 JavaScript 中的原型和原型链
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript 中的原型和原型链是一个至关重要的概念，同时也是许多前端开发者不熟悉的知识点。在这篇文章中，我将深入讲解这些概念，并通过实例来帮助读者更好地理解它们。
一、构造函数和原型对象 在 JavaScript 中，每个对象都有一个原型对象。可以使用 Object.getPrototypeOf() 来获取一个对象的原型对象。而对象的原型对象又有自己的原型对象，这样的关系称为原型链。
在 JavaScript 中，每个对象都可以通过一个构造函数来创建。构造函数与普通函数的区别在于，它们被用来创建新的对象。在创建对象时，使用 new 关键字调用构造函数，新对象就会继承由该构造函数的原型对象定义的属性和方法。
例如，创建一个猫咪对象：
function Cat(name, color) { this.name = name; this.color = color; } var cat1 = new Cat('Mimi', 'white'); 在这个例子中，Cat 是一个构造函数，它定义了猫咪对象的属性和方法。使用 new 关键字调用 Cat 构造函数可以创建一个新的猫咪对象 cat1。这个猫咪对象继承了 Cat 原型对象中定义的属性和方法。
二、原型链 原型链如前所述，是对象原型对象向上继承的关系链。每个对象都有一个 prototype 属性，它指向该对象的原型对象。如果一个对象的属性或方法在它的原型对象中找不到，那么它会去它的原型对象的原型对象中查找，直到找到顶层的 Object.prototype 为止。
在前面的猫咪对象的例子中，每个 Cat 对象都继承了 Object.prototype 对象中定义的属性和方法，因为 Cat 原型对象是继承自 Object.prototype 对象的。
三、实例 下面我们来看一个例子，通过一个实例来帮助大家更好地理解这些概念。
function Animal(name) { this.name = name; } Animal.prototype.color = 'white'; function Cat(name) { Animal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61a358c5482a9325ee174a1515a65122/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b245b8888791c380c2ef5dd8fb92f46/" rel="bookmark">
			GoNote第四章 GoFrame使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GoNote第四章 GoFrame使用 官方文档：https://goframe.org/pages/viewpage.action
介绍 GoFrame是一个基于Go语言的轻量级模块化的Web框架，它提供了很多实用的组件和工具，可以帮助我们快速地构建高性能的Web应用。下面是使用GoFrame的简单步骤：
安装GoFrame 在安装GoFrame之前，需要先安装Go语言。然后，可以从GoFrame的官方网站（https://goframe.org/）下载对应平台的安装包并进行安装。
Mac环境 wget -O gf "https://github.com/gogf/gf/releases/latest/download/gf_$(go env GOOS)_$(go env GOARCH)" &amp;&amp; chmod +x gf &amp;&amp; ./gf install -y &amp;&amp; rm ./gf Linux环境 wget -O gf Windows环境 git clone --depth=1 https://github.com/gogf/gf.git &amp;&amp; cd gf/cmd/gf &amp;&amp; go install 创建项目 可以使用gf-cli命令行工具来创建一个新的GoFrame项目。执行以下命令：
bashCopy Code$ gf-cli create myapp 其中，myapp是项目名称。该命令将创建一个名为myapp的项目，并生成一些基本目录和文件。
编写代码 在项目中，可以使用GoFrame提供的各种组件和工具来编写自己的Web应用。例如，可以定义一个处理HTTP请求的路由，并返回响应结果：
goCopy Codepackage main import ( "github.com/gogf/gf/frame/g" "github.com/gogf/gf/net/ghttp" ) func main() { s := g.Server() s.BindHandler("/", func(r *ghttp.Request) { r.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b245b8888791c380c2ef5dd8fb92f46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d9b64503e32e28f4c441a3402f3d93f/" rel="bookmark">
			编码器原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为学习记录文，内容主要来源网络。若有侵权，请联系删除，谢谢。
目录
文章目录 **编码器**光电式绝对式编码器原理及组成单圈和多圈码制与码盘 增量式编码器寻找零位方向判断 电容式编码器旋转变压器旋变BRX的原理及结构旋变BRT的原理及结构VR型旋变(VRX)的原理**旋变的比较** 三种编码器有缺点 编码器 旋转编码器的原理是什么？增量式编码器和绝对式编码器有什么区别？ - 知乎 (zhihu.com)
编码器按工作原理可以分为光电式、电容式、感应式、电触式等，光电式又可以分为绝对式编码器和增量式编码器两大类。这里只讨论光电式编码器及磁编码器。编码器包括码盘和码尺。前者用于测角度，后者用于测长度。因为实际接触的基本上是码盘是的，故这里只讨论码盘。
光电式绝对式编码器 原理及组成 光学码盘式是用光电照射方法把被测角位移转换成二进制的电信号的转换部件。
如下图是一个4位的绝对式编码器示意图，整圈分成 2 4 2^4 24份，在半径方向上，每一个扇区又被分成了4份。（17位的编码器，整圈则分为 2 17 2^{17} 217份，每个扇区分成17份。)
LED发射光束，经过棱镜，使光束可以照射一个扇区，在码盘另外一侧有一个探测芯片，探测芯片有4个感应区，每个感应区，可以获取同一个扇区每一份的状态。
传感器的组成：1一LED光源；2-Lens柱面镜；3一码盘；4一狭缝：5一Detector Chip探测芯片
码盘黑色区域，光线不能穿透。但探测芯片接收到光线时，为逻辑1信号，接收不到光线时，为逻辑0信号。如下图，从左到右可以分别表示0001, 0101, 1100。
因为4个逻辑代码可以组成 2 4 2^4 24组，则4位编码器的每一个扇区都有一个唯一的逻辑代码进行标识。
此时可以看到，n位编码器是将一圈分为 2 n 2^n 2n个扇区，每个扇区又有n个组成的逻辑代码进行区分,即n位编码器的每一个扇区都有一个唯一n位逻辑代码进行标识。
比如需要17位，也就是 2 17 = 131072 2^{17}=131072 217=131072个位置，那么就需要131072个不同的编码，这时的分辨率是360/131072＝0.00275°。
单圈和多圈 上述讲的即是单圈编码器原理，在工作当中，码盘旋转不超过一圈时，可以区分具体的位置。
但有时工作，需要码盘旋转几圈，这时若是不能够明确码盘旋转的圈数，则没有办法精确行走的位置变化。多圈编码器就是增加一个装置记录旋转的圈数。
目前常用的方式是利用电子计数器来记录总过转过的圈速。为了保证断电时仍能记录编码器的旋转，多圈编码器一般需要配置电池，为计数器提供电能。
码制与码盘 下面左图所示是一个6位的二进制码盘。最内圈称为C码道，一半透光、一半不透光。最外圈称为 C 1 C_1 C1​码道，一共分成 2 6 = 64 2^6=64 26=64 个黑白间隔。每一个角度方位对应于不同的编码。例如零位对应于000000（全黑），第23个方位对应于010111。测量时，只要根据码盘的起始和终止位置即可确定转角，与转动的中间过程无关。
6位二进制码盘 6位循环码码盘
二进制码盘具有以下主要特点：
n位（n个码道）的二进制码盘具有 2 n 2^n 2n种不同编码，称其容量为 2 n 2^n 2n，其最小分辨率 θ 1 = 36 0 ∘ 2 n \theta_1=\frac{360^{\circ}}{2^n} θ1​=2n360∘​它的最外圈角节距为 2 θ 1 2\theta_1 2θ1​；二进制码为有权码，编码 C n C_n Cn​， C n − 1 C_{n-1} Cn−1​， C n − 2 C_{n-2} Cn−2​，··· ， C 1 C_1 C1​对应于由零位算起的转角为 ∑ i = 1 n C i 2 i − 1 θ 1 \displaystyle\sum_{i=1}^n C_i2^{i-1}\theta_1 i=1∑n​Ci​2i−1θ1​；码盘转动中， C k C_k Ck​变化时，所有 C j （ j &lt; k ） C_j（j&lt;k） Cj​（j&lt;k）应同时变化。 为了达到1’'左右的分辨力，二进制码盘需要采用20或21位码盘。一个刻画直径为400mm的20位码盘，其外圈分别间隔稍大于1um。不仅要求各个码道刻画精确，而且要求彼此对准，这给码盘制作造成很大困难。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d9b64503e32e28f4c441a3402f3d93f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c38820fa10736f9ce283df043b344d8/" rel="bookmark">
			【halcon】小技巧，Union1能省时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：
使用halcon时，修改以一下步骤，发现耗时激增2秒。
定义到关键代码如下：
//再和之前的选择区域取交集 HOperatorSet.Intersection(SelectedRegions0, SelectedRegions, out ho_CutLineRegion); DebugShow(ho_CutLineRegion, "red", false, false); 发现主要是DebugShow这个函数耗时，但是之前并没有发现它耗时。它只是一个显示而已。
public void DebugShow(HObject targetRegions, string color = "red", bool bmargin = false, bool bStop = true) { if (bmargin) { HOperatorSet.SetDraw(hSmart.HalconWindow, "margin"); } else { HOperatorSet.SetDraw(hSmart.HalconWindow, "fill"); } HOperatorSet.SetColor(hSmart?.HalconWindow, color); hSmart?.HalconWindow.DispObj(targetRegions); if (bStop) { MessageBox.Show(""); } } 最后发现，是因为ho_CutLineRegion这个变量它包含了几百个对象，才导致显示耗时。
于是我修改代码如下（将 ho_CutLineRegion 联合一下 然后再显示）：
//再和之前的选择区域取交集 HOperatorSet.Intersection(SelectedRegions0, SelectedRegions, out ho_CutLineRegion); //Unionl之后，不管是显示，而是其他操作，会更加节省时间！ HOperatorSet.Union1(ho_CutLineRegion, out ho_CutLineRegion); DebugShow(ho_CutLineRegion, "red", false, false); 激增的2秒耗时就没了！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c38820fa10736f9ce283df043b344d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb879ba68c53dd42965ec12bf3651b70/" rel="bookmark">
			Qt布局管理（布局控件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实际开发中，一个界面上可能包含十几个控件，手动调整它们的位置既费时又费力。作为一款成熟的 GUI 框架，Qt 提供了很多摆放控件的辅助工具（又称布局管理器或者布局控件），它们可以完成两件事：
自动调整控件的位置，包括控件之间的间距、对齐等；
当用户调整窗口大小时，位于布局管理器内的控件也会随之调整大小，从而保持整个界面的美观。
总之借助布局管理器，我们无需再逐个调整控件的位置和大小，可以将更多的精力放在软件功能的实现上。
Qt 共提供了 5 种布局管理器，每种布局管理器对应一个类，分别是 QVBoxLayout（垂直布局）、QHBoxLayout（水平布局）、QGridLayout（网格布局）、QFormLayout（表单布局）和 QStackedLayout（分组布局），它们的继承关系如下图所示：
图 1 各个布局管理类的继承关系
QVBoxLayout垂直布局 垂直布局指的是将所有控件从上到下（或者从下到上）依次摆放，例如：
图 2 QVBoxLayout垂直布局
图 2 展示了 4 个 QPushButton 按钮利用 QVBoxLayout 垂直布局的效果。实际场景中，QVBoxLayout 中还可以放置其它控件，比如 QLabel 文本框、QLineEdit 单行输入框等。
程序中使用 QVBoxLayout 布局控件，需提前引入&lt;QVBoxLayout&gt;头文件。每个 QVBoxLayout 控件本质都是 QVBoxLayout 类的实例对象，该类提供了两个构造函数，分别是：
QVBoxLayout() QVBoxLayout(QWidget *parent) 创建 QVBoxLayout 控件的同时可以指定父窗口，那么它将作为父窗口中管理其它控件的工具；也可以暂时不指定父窗口，待全部设置完毕后再将其添加到某个窗口中。
QVBoxLayout 类没有新增任何成员方法，它只能使用从父类继承的成员方法，下表给大家罗列了常用的一些：
表 1 QVBoxLayout常用方法
成员方法
功 能
void QBoxLayout::addWidget(QWidget *widget, int stretch = 0, Qt::Alignment alignment = Qt::Alignment())
向布局管理器中添加指定的 widget 控件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb879ba68c53dd42965ec12bf3651b70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c27c76b73ab3e9077d5108639419b04c/" rel="bookmark">
			socks5centos7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装EPEL存储库：Shadowsocks需要安装一些依赖项，这些依赖项通常可以在EPEL存储库中找到。您可以使用以下命令安装EPEL存储库：
sudo yum install epel-release
安装Shadowsocks：您可以使用以下命令通过EPEL存储库安装Shadowsocks：
sudo yum install shadowsocks-libev
创建配置文件：创建一个JSON格式的配置文件，例如 /etc/shadowsocks-libev/config.json，并将以下内容添加到该文件中：
{
“server”:“0.0.0.0”,
“server_port”:1080,
“local_address”: “127.0.0.1”,
“local_port”:1080,
“password”:“your_password”,
“timeout”:300,
“method”:“aes-256-cfb”
}
启动Shadowsocks服务：运行以下命令启动Shadowsocks服务：
sudo systemctl start shadowsocks-libev
您也可以使用以下命令检查Shadowsocks服务是否正在运行：
sudo systemctl status shadowsocks-libev
配置浏览器或其他应用程序：要使用SOCKS5代理，请在浏览器或其他应用程序中进行配置。例如，在Firefox浏览器中，您可以在“首选项”-&gt;“网络设置”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/535bd3304a1cc700a9c61cfd4e0b6b54/" rel="bookmark">
			Android设置ImageView可以移动、旋转、缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;com.example.testdemo.CropImageView android:id="@+id/imageView" android:layout_width="match_parent" android:layout_height="match_parent" android:scaleType="matrix" /&gt; 设置scaleType模式可以使用矩阵
import android.content.Context import android.graphics.Matrix import android.util.AttributeSet import android.view.GestureDetector import android.view.GestureDetector.SimpleOnGestureListener import android.view.MotionEvent import android.view.ScaleGestureDetector import android.view.ScaleGestureDetector.SimpleOnScaleGestureListener import androidx.appcompat.widget.AppCompatImageView /** * @author Kawa * @date 2023/4/21 * @Description */ class CropImageView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, ) : AppCompatImageView(context, attrs) { private var mGestureDetector: GestureDetector? = null private var mScaleDetector: ScaleGestureDetector? = null private var mRotateDetector: RotationGestureDetector? = null private var mMidPntX = 0f private var mMidPntY = 0f private val mCurrentImageMatrix by lazy { Matrix() } init { setupGestureListeners() } private fun setupGestureListeners() { mGestureDetector = GestureDetector( context, GestureListener(), null, true ) mScaleDetector = ScaleGestureDetector(context, ScaleListener()) mRotateDetector = RotationGestureDetector(RotateListener()) } override fun onTouchEvent(event: MotionEvent?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/535bd3304a1cc700a9c61cfd4e0b6b54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb19a1f6683ebd8ebf40b6978b34aa99/" rel="bookmark">
			30天练完这96个爬虫项目案例，成功逆袭！靠接单月入W＋轻轻松松！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在受所有大环境的影响，大家开始一个比一个卷，所以靠固定的收入那一点点是明显不够的。现在谁还没有一点其他的收入呢？Python爬虫就成了大家学习的不二之选~
相信很多学习Python的小伙伴都苦于找不到python项目练手，在我看来，基础知识学的再好，没有经历过实战就是白扯，这️️️个项目非常适合新手学习
Python爬虫虽然做为python学习中较简单的一个知识点，但是它在平时生活中的运用确实非常多的
用其兼职也是一个非常不错的选择，我给大家分享96+附源码的python爬虫项目
Python爬虫项目100例(一):入门级 1.CentOS环境安装
2.和谐图网站爬取
3.美空网数据爬取
4美空网未登录图片爬取
5.27270图片爬取
6.蜂鸟网图片爬取之一
7.蜂鸟网图片爬取之二
8.蜂鸟网图片爬取之三
9.河北阳光理政投诉板块
10.Pyt图虫网多线程爬取
11.行行网电子书多线程爬取
12.半次元COS图爬取
13斗图啦表情包多线程爬取
14.AllITeBooks多线程爬取
15.石家庄政民互动数据爬取
16.500px摄影师社区抓取摄影师数据
17.CSDN博客抓取数据
…
60.python识别验证码，阿里、腾讯、百度、聚合数据等大公司都这么干
Python爬虫项目100例(七):反爬虫技术 61.写个爬虫碰到反爬了，动手破坏它!
62.30岁了，想找点文献提高自己，还被反爬了，Python
搞起，反爬第2篇
63.Python字体反爬之一，没办法，这个必须写，反爬第3篇
64.反爬教科书级别的网站-汽车之家，字体反爬之二
65.爬虫与反爬虫的修罗场，点评网站，字体反爬之三
66.对微博登录好奇嘛，用Python试试
67.Python爬虫摆脱控制台，开始走上台面
68.一招解决爬虫程序卡死问题
69.哪些年我们碰到的懒加载
70.爬虫原理应用到多种场景，Python下载B站视频
71.续上篇，python爬虫爬取B站视频
Python爬虫项目100例(八):分布式爬虫技术 72.分布式爬虫初步解析-配好环境肝完一半
73Python分布式爬虫顶级教程
好了上面的Python爬虫项目实例已经整理打包完毕了，需要的可以直接在下面的文末获取！
关于Python技术储备 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
一、Python所有方向的学习路线 Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、学习软件 工欲善其事必先利其器。学习Python常用的开发软件都在这里了，给大家节省了很多时间。
三、入门学习视频 我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了。
四、实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
五、面试资料 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf8681f765336c50c7deb90467f25ec3/" rel="bookmark">
			VMware安装macos无法联网的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware安装macos无法联网的问题
1: 控制面板—&gt;网络和共享中心
2：选择属性，点击共享按钮。
3：将internet连接共享下面选项都选中，然后在家庭网络连接选择VMware Network Adapter VMnet1。
4：在安装的虚拟机中选择虚拟机-&gt;设置选项。
按快捷键Ctrl+R,输入service.msc
5：点击网络适配器，将网络连接改成NAT模式，点击确定（如果NAT 不行可以每个都选一下试试，我就是这么试的）。
6.要特别注意macOS的时间，如果时间不对也是不行的。
![在这里插入图片描述](https://img-blog.csdnimg.cn/a3f26a4b13ba4744bdbc83c50f927a87.jpeg#pic_center
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2093bbb7dad7e9c78e3056f288fbca67/" rel="bookmark">
			spring security （史上最全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		认证与授权（Authentication and Authorization） 一般意义来说的应用访问安全性，都是围绕认证（Authentication）和授权（Authorization）这两个核心概念来展开的。
即：
首先需要确定用户身份，再确定这个用户是否有访问指定资源的权限。 认证这块的解决方案很多，主流的有CAS、SAML2、OAUTH2等（不巧这几个都用过-_-），我们常说的单点登录方案（SSO）说的就是这块，
授权的话主流的就是spring security和shiro。
shiro比较轻量级，相比较而言spring security确实架构比较复杂。但是shiro与 ss，掌握一个即可。
这里尼恩给大家做一下系统化、体系化的梳理，供后面的小伙伴参考，提升大家的 3高 架构、设计、开发水平。
注：本文以 PDF 持续更新，最新尼恩 架构笔记、面试题 的PDF文件，请从下面的链接获取： 码云
什么是OAuth2 ？ OAuth2是一个关于授权的开放标准，核心思路是通过各类认证手段（具体什么手段OAuth2不关心）认证用户身份，
并颁发token（令牌），使得第三方应用可以使用该令牌在限定时间、限定范围访问指定资源。
主要涉及的RFC规范有【RFC6749（整体授权框架）】、【RFC6750（令牌使用）】、【RFC6819（威胁模型）】这几个，一般我们需要了解的就是RFC6749。
获取令牌的方式主要有四种，分别是授权码模式、简单模式、密码模式、客户端模式，
总之：OAuth2是一个授权（Authorization）协议。
认证（Authentication）证明的你是不是这个人，
而授权（Authorization）则是证明这个人有没有访问这个资源（Resource）的权限。
下面这张图来源于OAuth 2.0 authorization framework RFC Document，是OAuth2的一个抽象流程。
+--------+ +---------------+ | |--(A)- Authorization Request -&gt;| Resource | | | | Owner | | |&lt;-(B)-- Authorization Grant ---| | | | +---------------+ | | | | +---------------+ | |--(C)-- Authorization Grant --&gt;| Authorization | | Client | | Server | | |&lt;-(D)----- Access Token -------| | | | +---------------+ | | | | +---------------+ | |--(E)----- Access Token ------&gt;| Resource | | | | Server | | |&lt;-(F)--- Protected Resource ---| | +--------+ +---------------+ 先来解释一下上图的名词：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2093bbb7dad7e9c78e3056f288fbca67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a5e3079eb58f67283be198dfc9376dc/" rel="bookmark">
			Halcon图像中的字体设定 字体颜色设定 显示样式设定 信息显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像中的字体设定set_display_font
算子：set_display_font( : : WindowHandle, Size, Font, Bold, Slant : )
示例：set_display_font (200000, 24, 'mono', 'true', 'false')
200000（输入参数1）：输入窗口句柄
24（输入参数2）：输入字体大小
'mono'（输入参数3）：输入字体类型
'true'（输入参数4）：是否选择粗体
'false'（输入参数5）：是否选择斜体
图像中的字体颜色设定dev_set_color
算子：dev_set_color( : : ColorName : )
示例：dev_set_color ('green')
'green'（输入参数）：设定颜色
图像中的显示样式设定dev_set_draw
算子：dev_set_draw( : : DrawMode : )
示例：dev_set_draw ('margin')
'margin'（输入参数）：显示类型 填充or 不填充
图像中的信息显示设定
第一种disp_message
算子：disp_message( : : WindowHandle, String, CoordSystem, Row, Column, Color, Box : )
示例：disp_message (200000, '第一种显示设定图像中的信息显示', 'Image', 10, 10, 'black', 'true')
200000（输入参数1）：输入窗口句柄
'第一种显示设定图像中的信息显示'（输入参数2）：输入显示内容
'Image'（输入参数3）：输入在哪张图像上显示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a5e3079eb58f67283be198dfc9376dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dacbb6a5c6ecbcaba1458ad8f277953c/" rel="bookmark">
			Halcon区域集合运算及变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		difference(Region, Sub : RegionDifference : : )
示例：difference (RegionUnion, ObjectSelected1, RegionDifference)
RegionUnion（输入对象）：输入大的区域对象
ObjectSelected1（输入对象）：输入小的区域对象
RegionDifference（输出对象）：输出大的区域减去小的区域对象的区域
两个区域的交集：intersection
算子：
intersection(Region1, Region2 : RegionIntersection : : )
示例：intersection (Rectangle, Rectangle1, RegionIntersection)
Rectangle（输入对象）：输入第一个区域对象
Rectangle1（输入对象）：输入第二个区域对象
RegionIntersection（输出对象）：输出两个区域相交的区域对象
区域变换
断开不相连的区域：connection
算子：connection(Region : ConnectedRegions : : )
示例：connection (Region1, ConnectedRegions)
Region1（输入对象）：输入一个连成一块的对象
ConnectedRegions（输出对象）：输出断开不相连的各个区域
区域填充：fill_up
算子：fill_up(Region : RegionFillUp : : )
示例：fill_up (Region, RegionFillUp)
Region（输入对象）：输入需要填充的对象
RegionFillUp（输出对象）：输出填充好的区域对象
抠图：reduce_domain
算子：reduce_domain(Image, Region : ImageReduced : : )
示例：reduce_domain (GrayImage, RegionFillUp, ImageReduced)
GrayImage（输入对象）：输入灰度图对象
RegionFillUp（输入对象）：输入二值化区域
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dacbb6a5c6ecbcaba1458ad8f277953c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f32d5473fa542385dae5c33fae7e55f7/" rel="bookmark">
			分布式锁的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.itheima.utils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.dao.DataAccessException; import org.springframework.data.redis.connection.RedisConnection; import org.springframework.data.redis.core.RedisCallback; import org.springframework.data.redis.core.StringRedisTemplate; import java.util.concurrent.TimeUnit; public class RedisLock { private static Logger log = LoggerFactory.getLogger(RedisLock.class); private StringRedisTemplate stringRedisTemplate; private String lockKey; private String value; private static final String PREFIX_KEY = "gb.common.distributed.lock.redis_"; private boolean locked; private int expireSecond; private int timeout; private static final int DEFAULT_RETRY_INTERVAL_MILLIS = 100; private int retryCount; private int retryIntervalMillisecond; /** * @deprecated */ @Deprecated public RedisLock(StringRedisTemplate stringRedisTemplate, String lockKey) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f32d5473fa542385dae5c33fae7e55f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52237a3e51cd5000bfb4ed2c10679e8d/" rel="bookmark">
			抽象方法和抽象类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、抽象方法 定义： Java中可以定义不含方法体的方法，方法的方法体由其所在类的子类根据实际需求去实现，这样的方法叫抽象方法，包含抽象方法的类必须是抽象类。
Java中提供了 abstract 关键字，表示抽象的意思，用其修饰的方法称为抽象方法。抽象方法是不完整的方法，只有方法声明，没有方法体。
抽象方法的语法格式：
[修饰符] abstract 方法返回值类型 方法名（[参数列表]）；
举个栗子：
正常的方法：
public void fly(){
System.out.println("我要飞得更高”）； //此为方法体
}
抽象方法：
pubilc astract void fly()； //没有方法体
二、抽象类 用 abstact 修饰的类，称为抽象类，抽象类可以不包含任何抽象方法。
抽象类的语法格式：
[修饰符] abstrct class 类名{
......
}
注意点：
使用抽象类时需要注意，抽象类不能被实例化，即不能用new关键字创建对象。这是因为抽象类中可能包含抽象方法，抽象方法只有声明没有方法体，不能被调用。但是，我们可以通过子类继承抽象父类去实现抽象方法。
由于抽象类不能实例化，所以用上面的例子的话，就是不能 使用 Bird b =new Bird（）；
来创建对象。那么我们就得引入上转型的定义了。
向上转型：
向上转型就是把子类对象直接赋给父类的引用变量，不用强制转换。使用向上转型可以调用父类类型中的所有成员。
注意点：
上转型对象不能调用子类新增的成员变量和方法，但是可以调用父类隐藏的变量/方法和继承以及重写的变量和方法。
格式：
父类类型 创建对象 = new 子类类型
例如：上面例题的 Bird b =new B1()；
注意点：
非抽象子类要重写抽象父类的所有抽象方法，一个都不可以少，否则会报错。
举个栗子：
abstract class Bird{ public abstract void fly(); public abstract void say(); } class B1 extends Bird{ public void fly(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52237a3e51cd5000bfb4ed2c10679e8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0adaed8a6c275a516a4006aa04cbd92/" rel="bookmark">
			Apache服务器配置 Windows
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 下载Apache 登录http://httpd.apache.org/download.cgi 这个地址，找到下图所示位置。
2 安转 解压压缩包，找到G:\Apache24\conf\httpd.conf，修改两个地方。
一个是Apache文件所在地址，一个是监听地址。
打开CMD窗口，输入G:\Apache24\bin\httpd.exe -k install -n apache，然后回车。服务安装完毕，若有问题，窗口会提示错误，此时，请根据错误自行排查。
正常安装后，启动bin下的ApacheMonitor.exe文件，如下所示，点击启动即可。
3 修改默认界面 这是一个基于HTML、CSS和JavaScript的石头、剪刀、布游戏，旨在演示如何使用JavaScript实现一个简单的游戏，并展示如何将HTML、CSS和JavaScript组合在一起创建动态网页。
该游戏采用经典的石头、剪刀、布规则，玩家可以选择其中一个手势，与计算机进行比较。游戏包含两个主要部分：用户界面和游戏逻辑。用户界面包括选择手势的按钮、显示结果的区域以及重新开始游戏的按钮。游戏逻辑负责根据玩家和计算机的选择计算结果，并将结果显示在结果区域中。
该游戏的架构主要由三个部分组成：HTML文件、CSS文件和JavaScript文件。HTML文件定义了游戏的页面结构和布局，CSS文件定义了游戏的样式和外观，JavaScript文件包含游戏的逻辑和交互行为。在JavaScript中，通过获取用户输入、计算结果和更新页面内容等操作来实现游戏逻辑。整个游戏是基于事件驱动的，当用户点击按钮时，会触发相关的事件，然后JavaScript会执行相应的操作。
在htddocs下进行编辑，三个文件。
代码如下所示：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;石头、剪刀、布游戏&lt;/title&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;link rel="stylesheet" href="style.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;h1&gt;石头、剪刀、布游戏&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;请选择你的手势：&lt;/p&gt; &lt;div class="choices"&gt; &lt;button id="rock" class="choice" data-choice="rock"&gt;石头&lt;/button&gt; &lt;button id="paper" class="choice" data-choice="paper"&gt;布&lt;/button&gt; &lt;button id="scissors" class="choice" data-choice="scissors"&gt;剪刀&lt;/button&gt; &lt;/div&gt; &lt;div class="results"&gt; &lt;p&gt;你的选择：&lt;span id="player-choice"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;计算机的选择：&lt;span id="computer-choice"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p id="result"&gt;&lt;/p&gt; &lt;/div&gt; &lt;button id="reset"&gt;再来一局&lt;/button&gt; &lt;/main&gt; &lt;script src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0adaed8a6c275a516a4006aa04cbd92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9c283e44f7a12770a0ae05d031e5116/" rel="bookmark">
			ubuntu硬盘空间不足，扩容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在VM中给虚拟机增加内存20G 步骤如下：点击克隆好的虚拟机【Ubunt16】，可以看到内存只有20G，下面扩展，点击【编辑虚拟机设置】-&gt; 【硬盘】-&gt; 【扩展】（此处如果扩展不可点，需要删除所有快照）-&gt; 弹出页面填写【40G】-&gt;【扩展】，等待完成即可；
安装 gparted，重新分配 内存 步骤如下
1、安装gparted，报了一个 版本不兼容的错，解决方案是使用aptitude安装，通过降级依赖的软件解决依赖关系。过程记录如下
sudo apt-get update # 更新一哈
sudo apt-get install gparted # 安装 gparted ，居然报错了，还好这个错我见过，是版本的问题
# 使用aptitude安装，通过降级依赖的软件解决依赖关系
sudo apt-get install aptitude # 安装aptitude -- 使用aptitude软件包管理器
sudo aptitude install gparted n y y
# 第一个 n , 是不接受当前解决方案
# 第一个 y , 是接受 降级依赖软件 安装
# 第二个 y , 是允许安装
sudo gparted # 打开 gparted ，重新分配内存
重新调整分区，由于在 sda1 和 新加的20G 之间有 个 extend，所以不能直接 将这20G 扩展到 sda1，需要先删除 extend，配置好分区后，再重新添加 extend。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9c283e44f7a12770a0ae05d031e5116/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1885a5e37a78d0e9292029b8986c78d9/" rel="bookmark">
			Java 成绩管理系统(包含抛异常)，无继承、GUI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分为三部分
Subject、Student、Main
主体部分在Main的main中
运行界面
`Subject.java`
public class subject { private String name; private int grade; public subject(){}; public subject(subject _subject) { setName(_subject.name); setGrade(_subject.grade); } public subject(String _name , int _grade) { setName(_name); setGrade(_grade); } public int getGrade() { return grade; } public void setName(String name) { this.name = name; } public void setGrade(int grade) { this.grade = grade; } public void print() { System.out.print(this.grade + " \t"); } } `Student.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1885a5e37a78d0e9292029b8986c78d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3376afeae65e7823c01506b171b8b755/" rel="bookmark">
			Python内执行cmd命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		def log_popen_pipe(process, stdfile): while process.poll() is None: if stdfile == process.stdout: out_msg = stdfile.readline().decode("utf-8") if out_msg: sys.stdout.write("[stdout]" + out_msg) sys.stdout.flush() else: err_msg = stdfile.readline().decode("utf-8") if err_msg: sys.stderr.write("[stderr]" + err_msg) sys.stderr.flush() # Write the rest from the buffer if stdfile == process.stdout: sys.stdout.write(stdfile.read().decode("utf-8")) else: sys.stderr.write(stdfile.read().decode("utf-8")) def run_process(cmd, env=None): print("run_process = ", " ".join(cmd)) with subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env) as proc: with ThreadPoolExecutor(max_workers=2) as pool: stdout = pool.submit(log_popen_pipe, proc, proc.stdout) stderr = pool.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3376afeae65e7823c01506b171b8b755/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/843974f0ae22204eb96f3393895436b1/" rel="bookmark">
			​windows通过修改路由表，通过特定的网卡访问特定IP​
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows通过修改路由表，通过特定的网卡访问特定IP 方式：修改路由表，指定的IP网段走指定的无线网卡。
步骤1：查看无线网卡的网关信息。终端里输入ipconfig，找到无线网卡对应的网关信息；这里是192.168.44.1。
步骤2：查看无线网卡的接口信息。终端里输入route print，找到无线网卡对应的接口信息，这里是30。
步骤3： 添加路由表信息。我要添加192.168.101.xxx网段的子网服务器路由信息，因此，在终端里输入：
route -p add 192.168.101.0 MASK 255.255.255.0 192.168.44.1 IF 30
其中-p代表添加为永久的陆游信息，add后的IP网段和MASK对应我要匹配的路由网段，192.168.44.1为无线网卡对应的网关地址（因人而异），IF后的是无线网卡的接口信息。
之后，访问192.168.101字段IP的数据，就会从无线网卡发出。
我本机的 需要访问的网络如下
route add 27.0.0.0 MASK 255.0.0.0 192.168.1.1 IF 13
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee3b212a660bd23c7c2128c42e0317cc/" rel="bookmark">
			【STM32】按键抖动及消除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于按键的抖动会导致一次按键动作被当成多次按键，为确保MCU对按键的一次闭合仅作一次处理，必须消除按键的抖动，在按键处于稳定状态时读取按键的状态。
按键的去抖动,通常有硬件消抖和软件消抖两种方式。
（1）硬件消抖
在按键数目较少时，可以采用硬件的方法消除按键抖动。比较简单的硬件电路是利用电阻和电容构成的RC低通滤波器来实现，电路结构如图所示。
采用RC低通滤波器实现硬件去抖的关键是选择适当的电阻值和电容值。由于人按键的频率一般低于1kHz，而按键抖动的频率一般是几十到几百kHz。因此，可以将低通滤波器的截止频率选择为10kHz。根据截止频率计算式fLP=1/2πRC可以选取160 Ω的电阻以及0.1 pF的电容来构成RC低通滤波器。
（2）软件消抖
如果按键数目较多，可以采用软件的方法消除按键抖动。处理流程如下：当检测到按键按下后执行一个延时程序,延时时间为5~10 ms。当前沿抖动消失后,再次检测按键的状态，如果仍然保持按下状态,则确认按键真正按下，并执行按键处理任务。同样，对于按键的释放，也需要采用延时函数去掉后沿的抖动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93ced4f7c66199413ba243f83c5d9dc5/" rel="bookmark">
			verdi基础操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看波形：
1.代码里选中，再按鼠标中键拖进去
2.选中，ctrl+w
3.用get signal
在波形框中，按照鼠标左键再左右移动，可以放大这一部分的波形，还有下面的功能键可以用
删除波形：
按delete或者cut掉
更新了代码：
用gvim更新修改代码后，需要重新打开一个终端重新跑vcs，然后在verdi的代码框用shift+l刷新，会同时刷新代码和波形
放大缩小：
鼠标放到波形框，按住左键拉
按f回到全屏，按z慢慢变大
或者用GUI的按键
存波形
从波形的file处进入save signal，或者shift+s存波形
再次用就restore signal
找drive和load
双击或者点功能键
debug：
代码内双击，跳转drive或者load。功能行左右箭头可以前进回退至之前点击的信号处
另外可以在波形里双击沿，会跳转到导致沿变化的语句
二维数组拖波形
默认情况拖到波形处会warning，可以在仿真里加 $fsdbDumpMDA;
看波形移动时间
shift time可以移动时间，方便看pipeline的波形
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75494b8ba3e7c48a52f023b2e89e6968/" rel="bookmark">
			数据采集方式有哪些，都有什么特点？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着中国社会的进一步发展，各行各业都得到了一定程度的进步。进入21世纪以来，大数据、人工智能等行业的飞速发展，极大的带动全社会进步。但是，在一些传统行业内部，还存在这落后的东西，例如数据采集还是沿用传统的采集方式，大部分借助于人工采集方式，耗时耗力，亟需改进。
随着企业业务数字化转型的推进，非数字原生企业对数据的感知和获取提出了新的要求和挑战，原有信息化平台的数据输出和人工录入能力已经远远满足不了企业内部组织在数字化下的运作需求。企业需要构建数据感知能力，采用现代化手段采集和获取数据，减少人工录入。
和这些内容息息相关的就是数据采集，小亿今天就和大家聊聊关于数据采集。
一、什么是数据采集？ 数据采集，又称数据获取，是利用一种装置，从系统外部采集数据并输入到系统内部的一个接口。在互联网行业快速发展的今天，数据采集已经被广泛应用于人工智能等相关领域，摄像头、麦克风等，都是数据采集的工具。
数据采集系统整合了信号、传感器等数据采集设备和应用软件。在数据大爆炸的互联网时代，数据的类型也是复杂多样的，包括结构化数据、半结构化数据、非结构化数据。结构化数据最常见，就是具有模式的数据。非结构化数据是数据结构不规则或不完整，没有预定义的数据模型，包括所有格式的办公文档、文本、图片、HTML、各类报表、图像和音频/视频信息等等。大数据采集，是大数据分析的入口，所以是相当重要的一个环节。
而数据采集的要点，主要有以下三点：
1、全面性
数据量足够具有分析价值、数据面足够支撑分析需求。比如对于“查看商品详情”这一行为，需要采集用户触发时的环境信息、会话、以及背后的用户id，最后需要统计这一行为在某一时段触发的人数、次数、人均次数、活跃比等。
2、多维性
数据更重要的是能够满足分析需求。灵活、快速自定义数据的多种属性和不同类型，从而满足不同的分析目标。比如“查看商品详情”这一行为，通过埋点，我们才能知道用户查看的商品是什么、价格、类型、商品id等多个属性。从而知道用户看过哪些商品、什么类型的商品被查看的多、某一个商品被查看了多少次，而不仅仅是知道用户进入了商品详情页。
3、高效性
高效性包含技术执行的高效性、团队内部成员协同的高效性以及数据分析需求和目标实现的高效性。也就是说采集数据一定要明确采集目的，带着问题搜集信息，使信息采集更高效、更有针对性。此外，还要考虑数据的时效性。 不同应用领域的大数据其特点、数据量、用户群体均不相同。不同领域根据数据源的物理性质及数据分析的目标采取不同的数据采集方法。 通过了解数据采集的三大要点，选择全面、准确、高效的数据合作伙伴至关重要。
二、数据采集方式有哪些？ 数据感知可分为“硬感知”和“软感知”，面向不同场景，即数据采集技术可以分为这两个方面的技术。
“硬感知”主要利用设备或装置进行数据的收集，收集对象为物理世界中的物理实体，或者是以物理实体为载体的信息、事件、流程等。而“软感知”使用软件或者各种技术进行数据收集，收集的对象存在于数字世界，通常不依赖物理设备进行收集。
1、基于物理世界的“硬感知”能力
数据采集方式主要经历了人工采集和自动采集两个阶段。自动采集技术仍在发展中，不同的应用领域所使用的具体技术手段也不同。基于物理世界的“硬感知”依靠的就是数据采集，是将物理对象镜像到数字世界中的主要通道，是构建数据感知的关键，是实现人工智能的基础。
基于当前的技术水平和应用场景，我们将“硬感知”分为9类，每一类感知方式都有自身的特点和应用场景。
（1）条形码与二维码
条形码或者条码是将宽度不等的多个黑条和空白，按一定的编码规则排列，用以表达一组信息的图形标识符，通常一维条形码所能表示的字符集不过10个数字、26个英文字母及一些特殊字符，条码字符集所能表示的字符个数最多为128个ASCII字符，信息量非常有限。
二维码是用某种特定的几何图形按一定规律在平面上分布的黑白相间的图形，用来记录数据符号信息。二维码拥有庞大的信息携带量，能够把使用一维条码时存储于后台数据库中的信息包含在条码中，可以直接阅读条码得到相应的信息，并且二维码还有错误修正及防伪功能，增加了数据的安全性。
（2）磁卡
磁卡是一种卡片状的磁性记录介质，利用磁性载体记录字符与数字信息，用来保存身份信息。视使用基材的不同，可分为PET卡、PVC卡和纸卡三种；视磁层构造的不同，又可分为磁条卡和全涂磁卡两种。
磁卡的优点是成本低，这是它容易推广的原因，但缺点也比较明显，例如卡的保密性和安全性较差，使用磁卡的应用系统需要有可靠的计算机系统和中央数据库的支持。
（3）RFID
RFID（Radio Frequency Identification，无线射频识别）是一种非接触式的自动识别技术，通过无线射频方式进行非接触双向数据通信，利用无线射频方式对记录媒体（电子标签或射频卡）进行读写，从而达到识别目标和数据交换的目的。
基于特别业务场景的需求，在RFID的基础上发展出了NFC（Near Field Communication，近场通信）。NFC本质上与RFID没有太大区别，在应用上的区别如下。
NFC的距离小于10cm，所以具有很高的安全性，而RFID距离从几米到几十米都有。
NFC仅限于13.56MHz的频段，与现有非接触智能卡技术兼容，所以很多的厂商和相关团体都支持NFC。而RFID标准较多，难以统一，只能在特殊行业有特殊需求的情况下，采用相应的技术标准。
RFID更多地被应用在生产、物流、跟踪、资产管理上，而NFC则在门禁、公交、手机支付等领域发挥着巨大的作用。
（4）OCR和ICR
OCR（Optical Character Recognition，光学字符识别）是指电子设备（例如扫描仪或者数码相机）检查纸上打印的字符，通过边检测暗、亮的模式确定其形状，将其形状翻译成计算机文字的过程。如何除错或利用辅助信息提高识别正确率，是OCR的重要课题。
ICR（Intelligent Character Recognition，智能字符识别）是一种更先进的OCR。它植入了计算机深度学习的人工智能技术，采用语义推理和语义分析，根据字符上下文语句信息并结合语义知识库，对未识别部分的字符进行信息补全，解决了OCR的技术缺陷。
一个OCR识别系统，从影像到结果输出，须经过影像输入、影像预处理、文字特征抽取、比对识别，最后经人工校正将认错的文字更正，将结果输出。
目前OCR和ICR技术在业界有较为成熟的解决方案供应商，非数字原生企业不需要自行研发就可以完成相关技术的部署和数据的采集。
（5）图像数据采集
图像数据采集是指利用计算机对图像进行采集、处理、分析和理解，以识别不同模式的目标和对象的技术，是深度学习算法的一种实践应用。
（6）音频数据采集
语音识别技术也被称为自动语音识别（Automatic Speech Recognition，ASR），可将人类的语音中的词汇内容转换为计算机可读的输入，例如二进制编码、字符序列或者文本文件。
目前音频数据采集技术在业界也有较为成熟的解决方案供应商，可以很便捷地通过解决方案供应商的技术，完成技术的部署和数据的采集。
采集来的声音作为音频文件存储。音频文件是指通过声音录入设备录制的原始声音，直接记录了真实声音的二进制采样数据，是互联网多媒体中重要的一种文件。音频获取途径包括下载音频、麦克风录制、MP3录音、录制计算机的声音、从CD中获取音频等。
（7）视频数据采集
视频是动态的数据，内容随时间而变化，声音与运动图像同步。通常视频信息体积较大，集成了影像、声音、文本等多种信息。
视频的获取方式包括网络下载、从VCD或DVD中捕获、从录像带中采集、利用摄像机拍摄等，以及购买视频素材、屏幕录制等。
（8）传感器数据采集
传感器是一种检测装置，能感受到被检测的信息，并能将检测到的信息按一定规律变换成信号或其他所需形式的信息输出，以满足信息的采集、传输、处理、存储、显示、记录等要求。信号类型包括IEPE信号、电流信号、电压信号、脉冲信号、I/O信号、电阻变化信号等。
传感器数据的主要特点是多源、实时、时序化、海量、高噪声、异构、价值密度低等，数据通信和处理难度都较大。
（9）工业设备数据采集
工业设备数据是对工业机器设备产生数据的统称。在机器中有很多特定功能的元器件（阀门、开关、压力计、摄像头等），这些元器件接受工业设备和系统的命令开、关或上报数据。工业设备和系统能够采集、存储、加工、传输数据。工业设备目前应用在很多行业，有联网设备，也有未联网设备。
工业设备数据采集应用广泛，例如可编程逻辑控制器（PLC）现场监控、数控设备故障诊断与检测、专用设备等大型工控设备的远程监控等。
2、基于数字世界的“软感知”能力
物理世界的“硬感知”是将物理对象构建到数字世界中的主要通道，是构建数据孪生的关键，而已经存在于数字世界中的那些分散、异构信息，可通过“软感知”能力来利用。目前“软感知”比较成熟，并随着数字原生企业的崛起而得到了广泛的应用。
（1）埋点
埋点是数据采集领域，尤其是用户行为数据采集领域的术语，指的是针对特定用户行为或事件进行捕获的相关技术。埋点的技术实质，是监听软件应用运行过程中的事件，当需要关注的事件发生时进行判断和捕获。
埋点的主要作用是能够帮助业务和数据分析人员打通固有信息墙，为了解用户交互行为、扩宽用户信息和前移运营机会提供数据支撑。在产品数据分析的初级阶段，业务人员通过自有或第三方的数据统计平台了解App用户访问的数据指标，包括新增用户数、活跃用户数等。
这些指标能帮助企业宏观地了解用户访问的整体情况和趋势，从总体上把握产品的运营状况，通过分析埋点获取的数据，制定产品改进策略。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75494b8ba3e7c48a52f023b2e89e6968/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f92c289e307b386af4073093902bb699/" rel="bookmark">
			BCompare的一些常用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.设置
当打开的文件没有差异，但是却还是变红了，然后开合后变黑了，是设置没设好，照这里设置即可。
2.常用操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e75c9850a77dea875af3594012487f7/" rel="bookmark">
			vue,使用elementui，实现表格点击每一行换个颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div&gt; &lt;template&gt; &lt;el-table :data="tableData" style="width: 100%" @row-click="clickData" :row-class-name="tableRowClassName" &gt; &lt;el-table-column prop="date" label="日期" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="name" label="姓名" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="address" label="地址"&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/template&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { tableData: [{ date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-04', name: '王小虎', address: '上海市普陀区金沙江路 1517 弄' }, { date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄' }, { date: '2016-05-03', name: '王小虎', address: '上海市普陀区金沙江路 1516 弄' }], abc:0 } }, methods:{ clickData(row) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e75c9850a77dea875af3594012487f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5da133480ec099e9f965d5820d276c5/" rel="bookmark">
			转换CAJ到PDF: 教你如何转换这两种文件格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现代信息化社会中，我们常常需要处理各种文件格式，例如常见的文本文档、PDF、图片、视频等等。其中，学术界或者专业人士常常会接触到一种叫做CAJ格式的文件，而这个格式在阅读、编辑以及分享方面可能存在一些限制。为了解决这个问题，我们需要将CAJ格式的文件转换成PDF格式，这样就可以更方便地进行查阅、编辑和分享了。
CAJ格式文件通常指的是中国知网收录的文献，这种文件格式在国内学术界应用非常广泛。但是，由于知网对于CAJ格式的文件进行了加密处理，因此普通的PDF阅读器并不能够打开这种文件，而且CAJ格式文件相对于PDF格式的文件，也不太容易进行编辑和分享。所以，在这种情况下，我们需要将CAJ格式的文件转换成PDF格式的文件。
具体的转换过程如下：
1.下载CAJViewer软件
CAJViewer是中国知网提供的一款CAJ格式文献阅读软件，通过这个软件可以打开、阅读CAJ格式的文件。在进行转换之前，我们需要先安装这个软件。
2.打开CAJViewer软件并导出PDF文件
打开CAJViewer软件，选择需要转换的CAJ格式的文件并打开，然后在菜单栏中选择“文件”-&gt;“导出为PDF”，即可将CAJ格式的文件转换为PDF格式的文件。
3.等待导出完成并保存文件
在导出PDF文件的过程中，需要等待一段时间，具体时间取决于文件的大小和您的计算机性能。当导出完成之后，您需要选择保存路径并保存文件。
如果您不想下载和安装CAJViewer软件，也可以使用记灵在线工具来进行CAJ格式文件的转换。
1.打开记灵在线工具网站
首先，在浏览器中输入“记灵在线工具”并打开该网站。
2.选择“CAJ转PDF”工具
在记灵在线工具网站中，选择“CAJ转PDF”工具。
3.上传CAJ格式文件并进行转换
在“CAJ转PDF”工具页面中，点击“上传文件”按钮，选择需要转换的CAJ格式文件并上传。然后，点击“转换”按钮进行转换。在转换过程中需要等待一段时间，具体时间取决于文件的大小和您的网络速度。
4.下载PDF格式文件
当转换完成之后，您可以点击“下载”按钮来下载转换后的PDF格式文件。并选择保存路径，保存文件即可。
总之，通过上述步骤，我们可以很容易地将CAJ格式的文件转换成PDF格式的文件，这样就可以更方便地进行查阅、编辑和分享了。但是需要注意的是，由于知网对于CAJ格式的文件进行了加密处理，因此在进行转换之前，需要确保您已经获得了相应的授权或者证书。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebde18bc9eb48f1186101935b1a1ea30/" rel="bookmark">
			如何提高图片清晰度？三种方法来帮你！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何提高图片清晰度？图片在上传到网络后会被压缩，导致图片变得模糊。今天，我将分享三种方法，帮助您提高图片的清晰度。
方法一：使用记灵在线工具
工具地址：记灵在线工具 - 更专注于发现工具的实用性
该工具可以批量处理千张图片，处理速度快。但需要联网使用。
具体操作步骤：打开记灵在线工具，选择【图片变清晰】，提交文件进行在线处理，等待处理完成后下载转换好的图片文件。
方法二：使用Gigapixel AI
该软件操作简单，无隐私风险，但需要付费成本。
具体操作步骤：安装并启动Gigapixel AI软件，导入需要处理的图片，右侧可以调整参数，根据需求设置参数，设置完成后，点击【Save】按钮保存图片到本地。
方法三：使用AI算法扩大图
该方法无需下载任何软件，直接在网页端操作，但操作速度较慢。
具体操作步骤：打开AI算法扩大图网站，选择摄影图片或插画漫画，将图片上传到功能框内，设置好扩大图比例及其他参数，点击【确定】，等待图片扩大完成后，点击【下载】按钮下载处理完成的图片。
以上三种方法可以快速提高图片的清晰度，选择适合自己的方法即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ad5a2fa959308b7c34881816c23ac09/" rel="bookmark">
			轻松掌握K8S命名空间、Pod、Deployment部署工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、NameSpace命名空间 在官方可视化工具界面为如下
也可以使用kubectl命令行具体看使用命令行操作
2、Pod应用组 k8s所说的应用通常就是指pod，一个pod可以部署多个容器。容器间共享网络空间，共享存储
3、根据应用类型选择部署Pod的工具 k8s官方也有对着部分的说明
1、Deployment部署无状态应用 如微服务应用
控制Pod，使Pod拥有多副本，自愈，扩缩容等能力
1、应用自愈能力 使用Deployment部署的应用，如果该应用宕机了，会自动重新启动一个，不怕机器宕机，（即使使用kubectl delete 删除此应用，也会自动重新部署一个，只有使用对应Deployment的删除命令才能完全删除应用。）关于Depoyment的应用部署参考使用命令行操作内容。
机器断电了，会在正常的机器重新启动一份，这过程又称为故障转移
2、多副本应用 使用Deployment可以部署多副本应用，达到集群的目的，见使用命令行操作
3、扩缩容 可以根据应用的负载，进行扩缩容，也可以做到动态扩缩容能力。
4、滚动更新应用 如原先部署多个副本的nginx为1.6.0版本，现在要升级为1.6.2，则可以使用Deployment的滚动更新命令。
整个流程为现在一个节点启动一个新版本应用，成功启动后将这个节点旧的应用下线。然后依次将其他节点更新为新版本，好处可以无感知的更新应用。
5、回退旧版本应用 可以查到部署的历史版本，并指定回退到某个版本，同样使用了滚动更新的机制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89b6ddca067074fd78789afb80b04eb8/" rel="bookmark">
			vue3.2使用QrCode生成二维码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、安装 npm install qrcode.vue --save 二、引入 import QrcodeVue from 'qrcode.vue' 三、使用 &lt;qrcode-vue :value="codeUrl" :size="size" level="H" /&gt; 参数说明：
value：二维码链接size：二维码大小level：二维码容错率 "L" | "M" | "Q" | "H" 四、完整代码 &lt;template&gt; &lt;qrcode-vue :value="codeUrl" :size="size" level="H" /&gt; &lt;/template&gt; &lt;script lang="ts" setup&gt; import QrcodeVue from 'qrcode.vue' import {ref} from 'vue' const codeUrl = ref('https://www.baidu.com') const size = ref&lt;number&gt;(180); &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d51199a43a483769d3b65727e541fa6/" rel="bookmark">
			VSDebug调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、插入间断点 在代码前面、行数前面的空白，左击插入间断点，右击插入条件间断点等其他种类的间断点，这里根据自己的需求。
二、调试 F10：逐过程，通常处理有个过程，一次过程可以是一个函数调用或者一条语句
F11：逐语句，就是每次都执行一条语句，但这个快捷键可以帮助我们进入函数内部（这个功能是最常用的）
注：开始调试之后，自动窗口会显示变量及内容，如图： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9616e58cb2fb7829180b9a5d752d583f/" rel="bookmark">
			简单使用Linux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Linux的组成
使用桌面终端访问linux
字符命令
基础
查看网卡信息以及获取ip地址
远程连接Linux服务器
Xshell远程连接Linux
使用MobaXterm远程连接Linux
​编辑 远程操作命令
重置root密码
Linux的组成 Linux内核：内核是系统的核心，是运行程序和管理 像磁盘和打印机等硬件设备的核心程序。 文件系统: 文件存放在磁盘等存储设备上的组织方法。 Shell ： Shell 是系统的用户界面，提供了用户与内核进行交互操作的一种接口。 应用程序：包括文本编辑器、编程语言、 X Window 、办公套件、 Internet 工具、数据库等。 Linux 的操作界面常称为 Shell ， Shell 是操作系统提供给用户使用的界面（图形、字符），它提供了用户与内核进行交互操作的一种接口。当用户发出指令( 命令或鼠标操作 ) ，先将这些指令发送给 Shell ，由Shell将用户的指令翻译后传送给内核，再由内核来控制硬件的工作。然后内核将硬件的工作情况发送给Shell，并由 Shell 返回硬件的工作信息和情况。 shell又分为图形界面的和字符界面的shell，我们主要学习字符界面的bash。 使用桌面终端访问linux 终端：也称为终端设备，是计算机网络中处于网络最外围的设备，主要用于用户信息的输入以及处 理结果的输出等。 虚拟终端：同一台终端（物理设备）上虚拟出多个终端，它们之间互相不影响，这些终端就是虚拟 终端，默认有6 个，可通过 ctrl + alt +f[1/2/3/4/5/6] 来进行切换。 在活动概览中，从仪表板选择终端。 字符命令 在终端窗口上输入命令，命令的格式： 主命令 选项 参数（操作对象） 基础 1、查看当前linux的发行版信息
[root@localhost ~]# cat /etc/redhat-release 2、查看内核版本
[root@localhost ~]# uname -r 3、 查看 shell 的类型 [root@localhost ~]# cat /etc/shells /bin/sh /bin/bash /usr/bin/sh /usr/bin/bash 或
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9616e58cb2fb7829180b9a5d752d583f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/034e33a5250542ef2a965ecb6803307f/" rel="bookmark">
			linux系统unzip无法解压超大文件，大于4GB文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实习解决问题记录，Linux中解压zip文件最大不能超过4GB，这是因为unzip的缓存位数最大为2的是32次，刚好就是4GB，解压直接爆缓存。建议用tar文件压缩然后用tar -xvf filename.tar解压，该死的Linux系统限制，我弄了一下午。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/182c231bd03a1aba3a1f66f556d59b93/" rel="bookmark">
			修改数据时，form表单重置resetFields无效原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误代码：
editUser(data) { this.userDialog = true this.ifAction = false this.userForm = JSON.parse(JSON.stringify(data)) }) }, 正确代码：
editUser(data) { this.userDialog = true this.ifAction = false this.$nextTick(() =&gt; { this.userForm = JSON.parse(JSON.stringify(data)) }) }, 原因：表单的resetFields是将表单数据重置为初始值，而不是清空内容，错误代码中，会在dialog挂载成功前就将值复制给表单了，则此时表单的初始值就不是空了，所以重置时会出现重置无效的感觉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9668c7258b2468a2fcf307c0c55ebfe/" rel="bookmark">
			前端向后端请求数据，使用Vuex管理(加工)数据，动态展示数据（state仓库三连环），组件复用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vuex使用，获取后端数据，展示（三连），组件复用 一、写api 使用mock模拟后端数据(链接)：https://blog.csdn.net/WinnerCC/article/details/130153124?spm=1001.2014.3001.5502
project &gt; src &gt; api &gt; index.js
import mockRequets from './mockAjax'; //获取floor数据 export const reqFloorList = () =&gt; mockRequets.get('/floor'); 二、vuex仓库获取并管理数据（state）（仓库三连环） 把vuex的原理图摆上，方便对着看
① Step1：组件派发Aciton Vue Components Dispatch Actions
project &gt; src &gt; pages &gt; Home &gt; index.vue
在组件要去获取数据的时机中，派发action
mounted() { this.$store.dispatch("getFloorList"); } ②Step2：在Vuex中的Actions中获取数据 project &gt; src &gt; store&gt; home.js
引入我们在一中写好的api：
import { reqFloorList } from "@/api"; 初始化数据
const state = { floorList:[], }; Actions中获取数据并commit给Mutations
actions中可以包含异步代码（定时器，Ajax等）
Actions中的函数能够接收到一个与store实例具有相同方法和属性的context对象（打印如下），这个对象中有个commit方法，是Actions用来向Mutation提交数据的
const actions = { async getFloorList({ commit }) { let result = await reqFloorList(); if (result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9668c7258b2468a2fcf307c0c55ebfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7895b5fd9c2df4047f2ecb5385024780/" rel="bookmark">
			react 之 useState
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://blog.csdn.net/Ljwen_/article/details/125319191
一、基本使用
useState是 react 提供的一个定义响应式变量的 hook 函数，基本语法如下：
const [count, setCount] = useState(initialCount) 它返回一个状态和一个修改状态的方法，状态需要通过这个方法来进行修改；
initialCount 是我们传入的一个初始状态，它是惰性的，我们可以通过传一个函数来返回一个值当作初始状态，并且这个函数只会在初始渲染时执行一次；
const [count, setCount] = useState(() =&gt; { const initialCount = someExpensiveComputation(); return initialCount }) 接下来把定义好的状态运用到页面：
import { useState } from 'react' function App() { const [count, setCount] = useState(0) const handleClick = () =&gt; { setCount(count + 1) // 传入一个函数，更新的值是基于之前的值来执行 // setCount(count =&gt; count + 1) } return ( &lt;div&gt; &lt;h4&gt;count: {count}&lt;/h4&gt; &lt;button onClick={ handleClick }&gt;点击更新状态&lt;/button&gt; &lt;/div&gt; ) } 页面渲染完成后，我们可以看到 count的值是 0，当我们点击按钮时，会将 count的值加 1，页面也同时更新；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7895b5fd9c2df4047f2ecb5385024780/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b301edcbd86852d84bee6ff47f53108/" rel="bookmark">
			算法——双指针技巧总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法——双指针技巧总结 一、双指针二、链表快慢指针19.删除链表的倒数第 N 个结点双指针 206.反转链表思路：双指针法递归法 92.反转链表 II1.递归2.迭代（双指针头插法） 876.链表的中间结点常规思路双指针思路 141.环形链表（判断链表是否有环）双指针 142.环形链表 II（找链表的环入口）双指针 相交链表思路1思路2 三、数组快慢指针27.移除元素1.暴力解法2.双指针法（快慢指针法）3.双指针优化 26.删除有序数组中的重复项双指针法 80.删除有序数组中的重复项 II1.双指针法2.有序数组去重保留k位重复数的通法 283.移动零双指针法 四、左右指针977.有序数组的平方1.暴力排序解法2.双指针法（左右指针法） 344. 反转字符串 （数组）双指针 18. 四数之和双指针法 167. 两数之和 II - 输入有序数组870. 优势洗牌回文子串问题 五、二分查找与滑动窗口 一、双指针 双指针技巧可细分分为两类，一类是快慢指针，一类是左右指针。
前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环、反转链表、找链表的中间节点、删除链表的倒数第 N 个结点；也用来解决数组中的问题，如移动/移除元素、删除有序数组中的重复项。
后者主要解决数组（或者字符串）中的问题，比如二分查找，滑动窗口。
二、链表快慢指针 快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，可以巧妙解决一些链表中的问题。
19.删除链表的倒数第 N 个结点 19.删除链表的倒数第 N 个结点
给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
进阶：你能尝试使用一趟扫描实现吗？
示例 1：
输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5]
示例 2：
输入：head = [1], n = 1 输出：[]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b301edcbd86852d84bee6ff47f53108/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c85f7f496762f76ef3c3cbd7cbe3e282/" rel="bookmark">
			一文带你了解javascript中的for...of循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript 是一种非常流行的编程语言，用于前端和后端开发，以及各种 Web 应用程序。其中，for...of 循环是 JavaScript 中的一种重要循环结构，它能够帮助开发者遍历各种数据结构，从而更加高效地编写代码。本文将深入探讨 JavaScript 中的 for...of 循环，包括其语法、用法、应用场景以及一些实际的例子。
什么是 for...of 循环 for...of 循环是 JavaScript 中的一种循环结构，它可以用于遍历各种数据结构，例如数组、字符串、Map、Set 等。for...of 循环通常用于替代传统的 for 循环或 forEach 循环，因为它具有更加简洁和易读的语法，能够提高代码的可读性和可维护性。
在 JavaScript 中，for...of 循环的语法如下：
for (variable of iterable) { // code block to be executed } 其中，variable 是一个变量名，表示循环中每次迭代时的当前值，iterable 是一个可迭代对象，表示要遍历的数据结构。在每次循环中，变量 variable 将依次赋值为 iterable 中的每个元素，并执行一次 code block 中的代码。
在 for...of 循环中，可迭代对象可以是数组、字符串、Map、Set 等，但不能是对象。如果需要遍历对象中的属性，可以使用 for...in 循环。
for...of 循环的应用场景 for...of 循环在 JavaScript 中有许多应用场景，例如：
遍历数组 for...of 循环可以用于遍历数组中的所有元素，例如：
const arr = [1, 2, 3]; for (const element of arr) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c85f7f496762f76ef3c3cbd7cbe3e282/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/697d5c85360da6ac1446a656d38e7919/" rel="bookmark">
			UnityWebRequest.Post报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息是：
看报错信息后端无法读取前端传递的数据格式，而且可以发现，为什么后端收到的数据中会有个 “%”，前端传的不是 Json 格式的数据吗？哪来的 % 呢？
不过看到这个 %，我大致可以猜到是进行了某种字符编码。应该是URLEncoded的问题。
上网搜索有更加详细的解释链接：
UnityWebRequest如何发送Json数据格式的Post请求，为什么使用UnityWebRequest.Post会报错？_unity post json_YY-nb的博客-CSDN博客
下面我用了一种比较笨的方法也能解决。
出错的请求是：
这里使用的笨方法是：
先用Put请求，完事再换成Post，也能解决这个问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6662da2aeb21622af14f4055e244c7f/" rel="bookmark">
			安装tidevice在Mac上报错：Defaulting to user installation because normal site-packages is not writeable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错：
Defaulting to user installation because normal site-packages is not writeable
Requirement already satisfied: tidevice[openssl] in ./Library/Python/3.9/lib/python/site-packages (0.10.7)
Requirement already satisfied: Pillow in ./Library/Python/3.9/lib/python/site-packages (from tidevice[openssl]) (9.5.0)
添加环境变量
在vi ~/.zshrc添加：
export PATH="$HOME/Library/Python/3.9/bin:$PATH" 再执行：
source ~/.zshrc 再执行：
tidevice --version 0.10.7
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b01875b39fcd386596560376d0d6a80/" rel="bookmark">
			【Kafka】SASL认证的Kafka客户端代码示例(spring-kafka和原生客户端)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 spring-kafka原生客户端Tips spring-kafka 添加依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt; &lt;version&gt;2.6.3&lt;/version&gt; &lt;/dependency&gt; 添加spring-kafka相关配置：
#=============== 集群通用配置 ================ spring.kafka.bootstrap-servers=kafka-dyskevxt-headless.kafka-uat.svc.xke.test.xdf.cn:29092 spring.kafka.security.protocol=SASL_PLAINTEXT spring.kafka.properties.sasl.mechanism=PLAIN spring.kafka.properties.sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required username="zhurunhua" password="pwd"; #=============== producer ================= spring.kafka.producer.retries=5 # 每次批量发送消息的数量 spring.kafka.producer.batch-size=1000 spring.kafka.producer.buffer-memory=1000000 # 指定消息key和消息体的编解码方式 spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer #=============== consumer ================== spring.kafka.consumer.group-id=zhurunhua-test-group spring.kafka.consumer.auto-offset-reset=earliest spring.kafka.consumer.enable-auto-commit=true spring.kafka.consumer.auto-commit-interval=100 spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer 消费者：
@Component public class TestPlainConsumer { @KafkaListener(topics = {"zhurunhua-test-topic"}) public void consumer(ConsumerRecord&lt;String, String&gt; record) { System.out.println(record.value()); } } topic可以从配置文件读取，代码中通过${}的方式获取配置的topic：
@Component public class TestPlainConsumer { @KafkaListener(topics = {"${kafka.subscribe.topic}"}) public void consumer(ConsumerRecord&lt;String, String&gt; record) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b01875b39fcd386596560376d0d6a80/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/83/">«</a>
	<span class="pagination__item pagination__item--current">84/306</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/85/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程爱好者博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151260"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>